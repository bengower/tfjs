var mj=Object.create;var Ug=Object.defineProperty;var fj=Object.getOwnPropertyDescriptor;var dj=Object.getOwnPropertyNames;var hj=Object.getPrototypeOf,gj=Object.prototype.hasOwnProperty;var EN=r=>Ug(r,"__esModule",{value:!0});var ns=typeof require!="undefined"?require:r=>{throw new Error('Dynamic require of "'+r+'" is not supported')};var Sn=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Qe=(r,e)=>{EN(r);for(var t in e)Ug(r,t,{get:e[t],enumerable:!0})},bj=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of dj(e))!gj.call(r,n)&&n!=="default"&&Ug(r,n,{get:()=>e[n],enumerable:!(t=fj(e,n))||t.enumerable});return r},Tl=r=>bj(EN(Ug(r!=null?mj(hj(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var eD=Sn((ome,JN)=>{JN.exports=Jt;var ws=null;try{ws=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(r){}function Jt(r,e,t){this.low=r|0,this.high=e|0,this.unsigned=!!t}Jt.prototype.__isLong__;Object.defineProperty(Jt.prototype,"__isLong__",{value:!0});function Vn(r){return(r&&r.__isLong__)===!0}Jt.isLong=Vn;var KN={},VN={};function wl(r,e){var t,n,o;return e?(r>>>=0,(o=0<=r&&r<256)&&(n=VN[r],n)?n:(t=er(r,(r|0)<0?-1:0,!0),o&&(VN[r]=t),t)):(r|=0,(o=-128<=r&&r<128)&&(n=KN[r],n)?n:(t=er(r,r<0?-1:0,!1),o&&(KN[r]=t),t))}Jt.fromInt=wl;function Ss(r,e){if(isNaN(r))return e?Sl:_s;if(e){if(r<0)return Sl;if(r>=HN)return ZN}else{if(r<=-qN)return jn;if(r+1>=qN)return QN}return r<0?Ss(-r,e).neg():er(r%vc|0,r/vc|0,e)}Jt.fromNumber=Ss;function er(r,e,t){return new Jt(r,e,t)}Jt.fromBits=er;var qg=Math.pow;function vk(r,e,t){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return _s;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return vk(r.substring(1),e,t).neg();for(var o=Ss(qg(t,8)),s=_s,a=0;a<r.length;a+=8){var i=Math.min(8,r.length-a),u=parseInt(r.substring(a,a+i),t);if(i<8){var l=Ss(qg(t,i));s=s.mul(l).add(Ss(u))}else s=s.mul(o),s=s.add(Ss(u))}return s.unsigned=e,s}Jt.fromString=vk;function Ta(r,e){return typeof r=="number"?Ss(r,e):typeof r=="string"?vk(r,e):er(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}Jt.fromValue=Ta;var jN=1<<16,zj=1<<24,vc=jN*jN,HN=vc*vc,qN=HN/2,XN=wl(zj),_s=wl(0);Jt.ZERO=_s;var Sl=wl(0,!0);Jt.UZERO=Sl;var wc=wl(1);Jt.ONE=wc;var YN=wl(1,!0);Jt.UONE=YN;var wk=wl(-1);Jt.NEG_ONE=wk;var QN=er(4294967295|0,2147483647|0,!1);Jt.MAX_VALUE=QN;var ZN=er(4294967295|0,4294967295|0,!0);Jt.MAX_UNSIGNED_VALUE=ZN;var jn=er(0,2147483648|0,!1);Jt.MIN_VALUE=jn;var Ie=Jt.prototype;Ie.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ie.toNumber=function(){return this.unsigned?(this.high>>>0)*vc+(this.low>>>0):this.high*vc+(this.low>>>0)};Ie.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(jn)){var t=Ss(e),n=this.div(t),o=n.mul(t).sub(this);return n.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=Ss(qg(e,6),this.unsigned),a=this,i="";;){var u=a.div(s),l=a.sub(u.mul(s)).toInt()>>>0,p=l.toString(e);if(a=u,a.isZero())return p+i;for(;p.length<6;)p="0"+p;i=""+p+i}};Ie.getHighBits=function(){return this.high};Ie.getHighBitsUnsigned=function(){return this.high>>>0};Ie.getLowBits=function(){return this.low};Ie.getLowBitsUnsigned=function(){return this.low>>>0};Ie.getNumBitsAbs=function(){if(this.isNegative())return this.eq(jn)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};Ie.isZero=function(){return this.high===0&&this.low===0};Ie.eqz=Ie.isZero;Ie.isNegative=function(){return!this.unsigned&&this.high<0};Ie.isPositive=function(){return this.unsigned||this.high>=0};Ie.isOdd=function(){return(this.low&1)==1};Ie.isEven=function(){return(this.low&1)==0};Ie.equals=function(e){return Vn(e)||(e=Ta(e)),this.unsigned!==e.unsigned&&this.high>>>31==1&&e.high>>>31==1?!1:this.high===e.high&&this.low===e.low};Ie.eq=Ie.equals;Ie.notEquals=function(e){return!this.eq(e)};Ie.neq=Ie.notEquals;Ie.ne=Ie.notEquals;Ie.lessThan=function(e){return this.comp(e)<0};Ie.lt=Ie.lessThan;Ie.lessThanOrEqual=function(e){return this.comp(e)<=0};Ie.lte=Ie.lessThanOrEqual;Ie.le=Ie.lessThanOrEqual;Ie.greaterThan=function(e){return this.comp(e)>0};Ie.gt=Ie.greaterThan;Ie.greaterThanOrEqual=function(e){return this.comp(e)>=0};Ie.gte=Ie.greaterThanOrEqual;Ie.ge=Ie.greaterThanOrEqual;Ie.compare=function(e){if(Vn(e)||(e=Ta(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Ie.comp=Ie.compare;Ie.negate=function(){return!this.unsigned&&this.eq(jn)?jn:this.not().add(wc)};Ie.neg=Ie.negate;Ie.add=function(e){Vn(e)||(e=Ta(e));var t=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,a=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,p=0,c=0,m=0,f=0;return f+=s+l,m+=f>>>16,f&=65535,m+=o+u,c+=m>>>16,m&=65535,c+=n+i,p+=c>>>16,c&=65535,p+=t+a,p&=65535,er(m<<16|f,p<<16|c,this.unsigned)};Ie.subtract=function(e){return Vn(e)||(e=Ta(e)),this.add(e.neg())};Ie.sub=Ie.subtract;Ie.multiply=function(e){if(this.isZero())return _s;if(Vn(e)||(e=Ta(e)),ws){var t=ws.mul(this.low,this.high,e.low,e.high);return er(t,ws.get_high(),this.unsigned)}if(e.isZero())return _s;if(this.eq(jn))return e.isOdd()?jn:_s;if(e.eq(jn))return this.isOdd()?jn:_s;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(XN)&&e.lt(XN))return Ss(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,a=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,p=e.low&65535,c=0,m=0,f=0,d=0;return d+=a*p,f+=d>>>16,d&=65535,f+=s*p,m+=f>>>16,f&=65535,f+=a*l,m+=f>>>16,f&=65535,m+=o*p,c+=m>>>16,m&=65535,m+=s*l,c+=m>>>16,m&=65535,m+=a*u,c+=m>>>16,m&=65535,c+=n*p+o*l+s*u+a*i,c&=65535,er(f<<16|d,c<<16|m,this.unsigned)};Ie.mul=Ie.multiply;Ie.divide=function(e){if(Vn(e)||(e=Ta(e)),e.isZero())throw Error("division by zero");if(ws){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?ws.div_u:ws.div_s)(this.low,this.high,e.low,e.high);return er(t,ws.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Sl:_s;var n,o,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Sl;if(e.gt(this.shru(1)))return YN;s=Sl}else{if(this.eq(jn)){if(e.eq(wc)||e.eq(wk))return jn;if(e.eq(jn))return wc;var a=this.shr(1);return n=a.div(e).shl(1),n.eq(_s)?e.isNegative()?wc:wk:(o=this.sub(e.mul(n)),s=n.add(o.div(e)),s)}else if(e.eq(jn))return this.unsigned?Sl:_s;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=_s}for(o=this;o.gte(e);){n=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:qg(2,i-48),l=Ss(n),p=l.mul(e);p.isNegative()||p.gt(o);)n-=u,l=Ss(n,this.unsigned),p=l.mul(e);l.isZero()&&(l=wc),s=s.add(l),o=o.sub(p)}return s};Ie.div=Ie.divide;Ie.modulo=function(e){if(Vn(e)||(e=Ta(e)),ws){var t=(this.unsigned?ws.rem_u:ws.rem_s)(this.low,this.high,e.low,e.high);return er(t,ws.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Ie.mod=Ie.modulo;Ie.rem=Ie.modulo;Ie.not=function(){return er(~this.low,~this.high,this.unsigned)};Ie.and=function(e){return Vn(e)||(e=Ta(e)),er(this.low&e.low,this.high&e.high,this.unsigned)};Ie.or=function(e){return Vn(e)||(e=Ta(e)),er(this.low|e.low,this.high|e.high,this.unsigned)};Ie.xor=function(e){return Vn(e)||(e=Ta(e)),er(this.low^e.low,this.high^e.high,this.unsigned)};Ie.shiftLeft=function(e){return Vn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?er(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):er(0,this.low<<e-32,this.unsigned)};Ie.shl=Ie.shiftLeft;Ie.shiftRight=function(e){return Vn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?er(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):er(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Ie.shr=Ie.shiftRight;Ie.shiftRightUnsigned=function(e){if(Vn(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return er(n>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?er(t,0,this.unsigned):er(t>>>e-32,0,this.unsigned)};Ie.shru=Ie.shiftRightUnsigned;Ie.shr_u=Ie.shiftRightUnsigned;Ie.toSigned=function(){return this.unsigned?er(this.low,this.high,!1):this};Ie.toUnsigned=function(){return this.unsigned?this:er(this.low,this.high,!0)};Ie.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Ie.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Ie.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Jt.fromBytes=function(e,t,n){return n?Jt.fromBytesLE(e,t):Jt.fromBytesBE(e,t)};Jt.fromBytesLE=function(e,t){return new Jt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Jt.fromBytesBE=function(e,t){return new Jt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});var BD=Sn(()=>{});var OD=Sn(()=>{});var k0=Sn((T0,KI)=>{(function(r,e,t){function n(i){var u=this,l=a();u.next=function(){var p=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=p-(u.c=p|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(i),u.s0<0&&(u.s0+=1),u.s1-=l(i),u.s1<0&&(u.s1+=1),u.s2-=l(i),u.s2<0&&(u.s2+=1),l=null}function o(i,u){return u.c=i.c,u.s0=i.s0,u.s1=i.s1,u.s2=i.s2,u}function s(i,u){var l=new n(i),p=u&&u.state,c=l.next;return c.int32=function(){return l.next()*4294967296|0},c.double=function(){return c()+(c()*2097152|0)*11102230246251565e-32},c.quick=c,p&&(typeof p=="object"&&o(p,l),c.state=function(){return o(l,{})}),c}function a(){var i=4022871197,u=function(l){l=String(l);for(var p=0;p<l.length;p++){i+=l.charCodeAt(p);var c=.02519603282416938*i;i=c>>>0,c-=i,c*=i,i=c>>>0,c-=i,i+=c*4294967296}return(i>>>0)*23283064365386963e-26};return u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(T0,typeof KI=="object"&&KI,typeof define=="function"&&define)});var C0=Sn((I0,VI)=>{(function(r,e,t){function n(a){var i=this,u="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var p=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^p^p>>>8},a===(a|0)?i.x=a:u+=a;for(var l=0;l<u.length+64;l++)i.x^=u.charCodeAt(l)|0,i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(I0,typeof VI=="object"&&VI,typeof define=="function"&&define)});var w0=Sn((v0,jI)=>{(function(r,e,t){function n(a){var i=this,u="";i.next=function(){var p=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(p^p<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:u+=a;for(var l=0;l<u.length+64;l++)i.x^=u.charCodeAt(l)|0,l==u.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(v0,typeof jI=="object"&&jI,typeof define=="function"&&define)});var _0=Sn((S0,HI)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var l=i.x,p=i.i,c,m,f;return c=l[p],c^=c>>>7,m=c^c<<24,c=l[p+1&7],m^=c^c>>>10,c=l[p+3&7],m^=c^c>>>3,c=l[p+4&7],m^=c^c<<7,c=l[p+7&7],c=c^c<<13,m^=c^c<<9,l[p]=m,i.i=p+1&7,m};function u(l,p){var c,m,f=[];if(p===(p|0))m=f[0]=p;else for(p=""+p,c=0;c<p.length;++c)f[c&7]=f[c&7]<<15^p.charCodeAt(c)+f[c+1&7]<<13;for(;f.length<8;)f.push(0);for(c=0;c<8&&f[c]===0;++c);for(c==8?m=f[7]=-1:m=f[c],l.x=f,l.i=0,c=256;c>0;--c)l.next()}u(i,a)}function o(a,i){return i.x=a.x.slice(),i.i=a.i,i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},p.int32=u.next,p.quick=p,l&&(l.x&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(S0,typeof HI=="object"&&HI,typeof define=="function"&&define)});var N0=Sn((A0,qI)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var l=i.w,p=i.X,c=i.i,m,f;return i.w=l=l+1640531527|0,f=p[c+34&127],m=p[c=c+1&127],f^=f<<13,m^=m<<17,f^=f>>>15,m^=m>>>12,f=p[c]=f^m,i.i=c,f+(l^l>>>16)|0};function u(l,p){var c,m,f,d,h,g=[],y=128;for(p===(p|0)?(m=p,p=null):(p=p+"\0",m=0,y=Math.max(y,p.length)),f=0,d=-32;d<y;++d)p&&(m^=p.charCodeAt((d+32)%p.length)),d===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,d>=0&&(h=h+1640531527|0,c=g[d&127]^=m+h,f=c==0?f+1:0);for(f>=128&&(g[(p&&p.length||0)&127]=-1),f=127,d=4*128;d>0;--d)m=g[f+34&127],c=g[f=f+1&127],m^=m<<13,c^=c<<17,m^=m>>>15,c^=c>>>12,g[f]=m^c;l.w=h,l.X=g,l.i=f}u(i,a)}function o(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},p.int32=u.next,p.quick=p,l&&(l.X&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(A0,typeof qI=="object"&&qI,typeof define=="function"&&define)});var P0=Sn((D0,XI)=>{(function(r,e,t){function n(a){var i=this,u="";i.next=function(){var p=i.b,c=i.c,m=i.d,f=i.a;return p=p<<25^p>>>7^c,c=c-m|0,m=m<<24^m>>>8^f,f=f-p|0,i.b=p=p<<20^p>>>12^c,i.c=c=c-m|0,i.d=m<<16^c>>>16^f,i.a=f-p|0},i.a=0,i.b=0,i.c=2654435769|0,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):u+=a;for(var l=0;l<u.length+20;l++)i.b^=u.charCodeAt(l)|0,i.next()}function o(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,f=(c+m)/(1<<21);while(f===0);return f},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(D0,typeof XI=="object"&&XI,typeof define=="function"&&define)});var F0=Sn(()=>{});var E0=Sn((M0,xb)=>{(function(r,e,t){var n=256,o=6,s=52,a="random",i=t.pow(n,o),u=t.pow(2,s),l=u*2,p=n-1,c;function m(T,k,w){var P=[];k=k==!0?{entropy:!0}:k||{};var A=g(h(k.entropy?[T,x(e)]:T??y(),3),P),F=new f(P),E=function(){for(var $=F.g(o),W=i,K=0;$<u;)$=($+K)*n,W*=n,K=F.g(1);for(;$>=l;)$/=2,W/=2,K>>>=1;return($+K)/W};return E.int32=function(){return F.g(4)|0},E.quick=function(){return F.g(4)/4294967296},E.double=E,g(x(F.S),e),(k.pass||w||function($,W,K,B){return B&&(B.S&&d(B,F),$.state=function(){return d(F,{})}),K?(t[a]=$,W):$})(E,A,"global"in k?k.global:this==t,k.state)}function f(T){var k,w=T.length,P=this,A=0,F=P.i=P.j=0,E=P.S=[];for(w||(T=[w++]);A<n;)E[A]=A++;for(A=0;A<n;A++)E[A]=E[F=p&F+T[A%w]+(k=E[A])],E[F]=k;(P.g=function($){for(var W,K=0,B=P.i,V=P.j,j=P.S;$--;)W=j[B=p&B+1],K=K*n+j[p&(j[B]=j[V=p&V+W])+(j[V]=W)];return P.i=B,P.j=V,K})(n)}function d(T,k){return k.i=T.i,k.j=T.j,k.S=T.S.slice(),k}function h(T,k){var w=[],P=typeof T,A;if(k&&P=="object")for(A in T)try{w.push(h(T[A],k-1))}catch(F){}return w.length?w:P=="string"?T:T+"\0"}function g(T,k){for(var w=T+"",P,A=0;A<w.length;)k[p&A]=p&(P^=k[p&A]*19)+w.charCodeAt(A++);return x(k)}function y(){try{var T;return c&&(T=c.randomBytes)?T=T(n):(T=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(T)),x(T)}catch(P){var k=r.navigator,w=k&&k.plugins;return[+new Date,r,w,r.screen,x(e)]}}function x(T){return String.fromCharCode.apply(0,T)}if(g(t.random(),e),typeof xb=="object"&&xb.exports){xb.exports=m;try{c=F0()}catch(T){}}else typeof define=="function"&&define.amd?define(function(){return m}):t["seed"+a]=m})(typeof self!="undefined"?self:M0,[],Math)});var Pf=Sn((g1e,R0)=>{var j5=k0(),H5=C0(),q5=w0(),X5=_0(),Y5=N0(),Q5=P0(),Kl=E0();Kl.alea=j5;Kl.xor128=H5;Kl.xorwow=q5;Kl.xorshift7=X5;Kl.xor4096=Y5;Kl.tychei=Q5;R0.exports=Kl});var Yv=Sn(()=>{});var u4=Sn((Wx,hN)=>{var dN=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};function t(){return te.buffer!=Je&&Pr(te.buffer),Ct}function n(){return te.buffer!=Je&&Pr(te.buffer),Ht}function o(){return te.buffer!=Je&&Pr(te.buffer),In}function s(){return te.buffer!=Je&&Pr(te.buffer),zr}function a(){return te.buffer!=Je&&Pr(te.buffer),rn}var i=typeof e!="undefined"?e:{},u,l;i.ready=new Promise(function(S,M){u=S,l=M});var p={},c;for(c in i)i.hasOwnProperty(c)&&(p[c]=i[c]);var m=[],f="./this.program",d=function(S,M){throw M},h=!1,g=!1,y=!1,x=!1;h=typeof window=="object",g=typeof importScripts=="function",y=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",x=!h&&!y&&!g;var T=i.ENVIRONMENT_IS_PTHREAD||!1;T&&(Je=i.buffer);var k="";function w(S){return i.locateFile?i.locateFile(S,k):k+S}var P,A,F,E,$,W;if(y){g?k=ns("path").dirname(k)+"/":k=__dirname+"/",P=function(M,z){return $||($=ns("fs")),W||(W=ns("path")),M=W.normalize(M),$.readFileSync(M,z?null:"utf8")},F=function(M){var z=P(M,!0);return z.buffer||(z=new Uint8Array(z)),fe(z.buffer),z},process.argv.length>1&&(f=process.argv[1].replace(/\\/g,"/")),m=process.argv.slice(2),process.on("uncaughtException",function(S){if(!(S instanceof Zm))throw S}),process.on("unhandledRejection",di),d=function(S){process.exit(S)},i.inspect=function(){return"[Emscripten Module object]"};var K;try{K=ns("worker_threads")}catch(S){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),S}global.Worker=K.Worker}else x?(typeof read!="undefined"&&(P=function(M){return read(M)}),F=function(M){var z;return typeof readbuffer=="function"?new Uint8Array(readbuffer(M)):(z=read(M,"binary"),fe(typeof z=="object"),z)},typeof scriptArgs!="undefined"?m=scriptArgs:typeof arguments!="undefined"&&(m=arguments),typeof quit=="function"&&(d=function(S){quit(S)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(h||g)&&(g?k=self.location.href:typeof document!="undefined"&&document.currentScript&&(k=document.currentScript.src),typeof r!="undefined"&&r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.lastIndexOf("/")+1):k="",y?(P=function(M,z){return $||($=ns("fs")),W||(W=ns("path")),M=W.normalize(M),$.readFileSync(M,z?null:"utf8")},F=function(M){var z=P(M,!0);return z.buffer||(z=new Uint8Array(z)),fe(z.buffer),z}):(P=function(S){var M=new XMLHttpRequest;return M.open("GET",S,!1),M.send(null),M.responseText},g&&(F=function(S){var M=new XMLHttpRequest;return M.open("GET",S,!1),M.responseType="arraybuffer",M.send(null),new Uint8Array(M.response)}),A=function(S,M,z){var q=new XMLHttpRequest;q.open("GET",S,!0),q.responseType="arraybuffer",q.onload=function(){if(q.status==200||q.status==0&&q.response){M(q.response);return}z()},q.onerror=z,q.send(null)}),E=function(S){document.title=S});y&&typeof performance=="undefined"&&(global.performance=ns("perf_hooks").performance);var B=i.print||console.log.bind(console),V=i.printErr||console.warn.bind(console);for(c in p)p.hasOwnProperty(c)&&(i[c]=p[c]);p=null,i.arguments&&(m=i.arguments),i.thisProgram&&(f=i.thisProgram),i.quit&&(d=i.quit);function j(S){j.shown||(j.shown={}),j.shown[S]||(j.shown[S]=1,V(S))}var H=Atomics.load,J=Atomics.store,X=Atomics.compareExchange,ne;i.wasmBinary&&(ne=i.wasmBinary);var oe=i.noExitRuntime||!0;typeof WebAssembly!="object"&&di("no native wasm support detected");var te,le,ae=!1,ge;function fe(S,M){S||di("Assertion failed: "+M)}function xe(S){var M=i["_"+S];return fe(M,"Cannot call unknown function "+S+", make sure it is exported"),M}function Se(S,M,z,q,Te){var be={string:function(nn){var Up=0;if(nn!=null&&nn!==0){var MN=(nn.length<<2)+1;Up=zp(MN),gt(nn,Up,MN)}return Up},array:function(nn){var Up=zp(nn.length);return Bt(nn,Up),Up}};function ye(nn){return M==="string"?Oe(nn):M==="boolean"?Boolean(nn):nn}var Fe=xe(S),Nt=[],Fr=0;if(q)for(var Sr=0;Sr<q.length;Sr++){var _u=be[z[Sr]];_u?(Fr===0&&(Fr=Qm()),Nt[Sr]=_u(q[Sr])):Nt[Sr]=q[Sr]}var Wp=Fe.apply(null,Nt);return Wp=ye(Wp),Fr!==0&&Op(Fr),Wp}function Be(S,M,z,q){z=z||[];var Te=z.every(function(ye){return ye==="number"}),be=M!=="string";return be&&Te&&!q?xe(S):function(){return Se(S,M,z,arguments,q)}}function Re(S,M,z){for(var q=M+z,Te="";!(M>=q);){var be=S[M++];if(!be)return Te;if(!(be&128)){Te+=String.fromCharCode(be);continue}var ye=S[M++]&63;if((be&224)==192){Te+=String.fromCharCode((be&31)<<6|ye);continue}var Fe=S[M++]&63;if((be&240)==224?be=(be&15)<<12|ye<<6|Fe:be=(be&7)<<18|ye<<12|Fe<<6|S[M++]&63,be<65536)Te+=String.fromCharCode(be);else{var Nt=be-65536;Te+=String.fromCharCode(55296|Nt>>10,56320|Nt&1023)}}return Te}function Oe(S,M){return S?Re(n(),S,M):""}function rt(S,M,z,q){if(!(q>0))return 0;for(var Te=z,be=z+q-1,ye=0;ye<S.length;++ye){var Fe=S.charCodeAt(ye);if(Fe>=55296&&Fe<=57343){var Nt=S.charCodeAt(++ye);Fe=65536+((Fe&1023)<<10)|Nt&1023}if(Fe<=127){if(z>=be)break;M[z++]=Fe}else if(Fe<=2047){if(z+1>=be)break;M[z++]=192|Fe>>6,M[z++]=128|Fe&63}else if(Fe<=65535){if(z+2>=be)break;M[z++]=224|Fe>>12,M[z++]=128|Fe>>6&63,M[z++]=128|Fe&63}else{if(z+3>=be)break;M[z++]=240|Fe>>18,M[z++]=128|Fe>>12&63,M[z++]=128|Fe>>6&63,M[z++]=128|Fe&63}}return M[z]=0,z-Te}function gt(S,M,z){return rt(S,n(),M,z)}function $t(S){for(var M=0,z=0;z<S.length;++z){var q=S.charCodeAt(z);q>=55296&&q<=57343&&(q=65536+((q&1023)<<10)|S.charCodeAt(++z)&1023),q<=127?++M:q<=2047?M+=2:q<=65535?M+=3:M+=4}return M}function Bt(S,M){t().set(S,M)}function kt(S,M){return S%M>0&&(S+=M-S%M),S}var Je,Ct,Ht,On,gr,In,zr,Vs,rn;function Pr(S){Je=S,i.HEAP8=Ct=new Int8Array(S),i.HEAP16=On=new Int16Array(S),i.HEAP32=In=new Int32Array(S),i.HEAPU8=Ht=new Uint8Array(S),i.HEAPU16=gr=new Uint16Array(S),i.HEAPU32=zr=new Uint32Array(S),i.HEAPF32=Vs=new Float32Array(S),i.HEAPF64=rn=new Float64Array(S)}var eo=i.INITIAL_MEMORY||16777216;if(T)te=i.wasmMemory,Je=i.buffer;else if(i.wasmMemory)te=i.wasmMemory;else if(te=new WebAssembly.Memory({initial:eo/65536,maximum:2147483648/65536,shared:!0}),!(te.buffer instanceof SharedArrayBuffer))throw V("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),y&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");te&&(Je=te.buffer),eo=Je.byteLength,Pr(Je);var br,Cn=[],zn=[],dl=[],hl=[],js=[],fi=!1,Gm=!1;T||zn.push({func:function(){Lg()}});function Rp(){if(!T){if(i.preRun)for(typeof i.preRun=="function"&&(i.preRun=[i.preRun]);i.preRun.length;)jx(i.preRun.shift());Lp(Cn)}}function Tg(){fi=!0,!T&&Lp(zn)}function kg(){T||Lp(dl)}function vn(){T||(Gm=!0)}function Ig(){if(!T){if(i.postRun)for(typeof i.postRun=="function"&&(i.postRun=[i.postRun]);i.postRun.length;)Hx(i.postRun.shift());Lp(js)}}function jx(S){Cn.unshift(S)}function Hx(S){js.unshift(S)}var rs=0,Wm=null,gl=null;function qx(S){fe(!T,"addRunDependency cannot be used in a pthread worker"),rs++,i.monitorRunDependencies&&i.monitorRunDependencies(rs)}function Xx(S){if(rs--,i.monitorRunDependencies&&i.monitorRunDependencies(rs),rs==0&&(Wm!==null&&(clearInterval(Wm),Wm=null),gl)){var M=gl;gl=null,M()}}i.preloadedImages={},i.preloadedAudios={};function di(S){i.onAbort&&i.onAbort(S),T&&console.error("Pthread aborting at "+new Error().stack),S+="",V(S),ae=!0,ge=1,S="abort("+S+"). Build with -s ASSERTIONS=1 for more info.";var M=new WebAssembly.RuntimeError(S);throw l(M),M}function bl(S,M){return String.prototype.startsWith?S.startsWith(M):S.indexOf(M)===0}var Yx="data:application/octet-stream;base64,";function Cg(S){return bl(S,Yx)}var Qx="file://";function vg(S){return bl(S,Qx)}var wn="tfjs-backend-wasm-threaded-simd.wasm";Cg(wn)||(wn=w(wn));function Zx(S){try{if(S==wn&&ne)return new Uint8Array(ne);if(F)return F(S);throw"both async and sync fetching of the wasm failed"}catch(M){di(M)}}function wg(){if(!ne&&(h||g)){if(typeof fetch=="function"&&!vg(wn))return fetch(wn,{credentials:"same-origin"}).then(function(S){if(!S.ok)throw"failed to load wasm binary file at '"+wn+"'";return S.arrayBuffer()}).catch(function(){return Zx(wn)});if(A)return new Promise(function(S,M){A(wn,function(z){S(new Uint8Array(z))},M)})}return Promise.resolve().then(function(){return Zx(wn)})}function Jx(){var S={a:VT};function M(ye,Fe){var Nt=ye.exports;if(i.asm=Nt,br=i.asm.kb,le=Fe,!T){var Fr=Me.unusedWorkers.length;Me.unusedWorkers.forEach(function(Sr){Me.loadWasmModuleToWorker(Sr,function(){--Fr||Xx("wasm-instantiate")})})}}T||qx("wasm-instantiate");function z(ye){M(ye.instance,ye.module)}function q(ye){return wg().then(function(Fe){return WebAssembly.instantiate(Fe,S)}).then(ye,function(Fe){V("failed to asynchronously prepare wasm: "+Fe),di(Fe)})}function Te(){return!ne&&typeof WebAssembly.instantiateStreaming=="function"&&!Cg(wn)&&!vg(wn)&&typeof fetch=="function"?fetch(wn,{credentials:"same-origin"}).then(function(ye){var Fe=WebAssembly.instantiateStreaming(ye,S);return Fe.then(z,function(Nt){return V("wasm streaming compile failed: "+Nt),V("falling back to ArrayBuffer instantiation"),q(z)})}):q(z)}if(i.instantiateWasm)try{var be=i.instantiateWasm(S,M);return be}catch(ye){return V("Module.instantiateWasm callback failed with error: "+ye),!1}return Te().catch(l),{}}var Sg={10072:function(){throw"Canceled!"},10090:function(S,M){setTimeout(function(){_N(S,M)},0)}};function eT(){Me.initRuntime()}function Lp(S){for(;S.length>0;){var M=S.shift();if(typeof M=="function"){M(i);continue}var z=M.func;typeof z=="number"?M.arg===void 0?br.get(z)():br.get(z)(M.arg):z(M.arg===void 0?null:M.arg)}}var Iu={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};function Um(S,M){if(S<=0||S>t().length||S&!0||M<0)return-28;if(M==0)return 0;M>=2147483647&&(M=1/0);var z=Atomics.load(o(),Gp>>2),q=0;if(z==S){var Te=Atomics.compareExchange(o(),Gp>>2,z,0);if(Te==z&&(--M,q=1,M<=0))return 1}var be=Atomics.notify(o(),S>>2,M);if(be>=0)return be+q;throw"Atomics.notify returned an unexpected value "+be}i._emscripten_futex_wake=Um;function tT(S){if(T)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!S)throw"Internal Error! Null pthread_ptr in killThread!";o()[S+12>>2]=0;var M=Me.pthreads[S];M.worker.terminate(),Me.freeThreadData(M),Me.runningWorkers.splice(Me.runningWorkers.indexOf(M.worker),1),M.worker.pthread=void 0}function rT(S){if(T)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!S)throw"Internal Error! Null pthread_ptr in cancelThread!";var M=Me.pthreads[S];M.worker.postMessage({cmd:"cancel"})}function _g(S){if(T)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!S)throw"Internal Error! Null pthread_ptr in cleanupThread!";var M=Me.pthreads[S];if(M){o()[S+12>>2]=0;var z=M.worker;Me.returnWorkerToPool(z)}}var Me={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var S=8,M=0;M<S;++M)Me.allocateUnusedWorker()},initRuntime:function(){for(var S=xl(228),M=0;M<228/4;++M)s()[S/4+M]=0;o()[S+12>>2]=S;var z=S+152;o()[z>>2]=z;for(var q=xl(512),M=0;M<128;++M)s()[q/4+M]=0;Atomics.store(s(),S+100>>2,q),Atomics.store(s(),S+40>>2,S),ck(S,!g,1),wN(S)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;Me.threadExitHandlers.length>0;)Me.threadExitHandlers.pop()();T&&Su()&&vN()},runExitHandlersAndDeinitThread:function(S,M){Atomics.store(s(),S+56>>2,1),Atomics.store(s(),S+60>>2,0),Me.runExitHandlers(),Atomics.store(s(),S+4>>2,M),Atomics.store(s(),S+0>>2,1),Um(S+0,2147483647),ck(0,0,0)},threadExit:function(S){var M=Su();M&&(Me.runExitHandlersAndDeinitThread(M,S),T&&postMessage({cmd:"exit"}))},threadCancel:function(){Me.runExitHandlersAndDeinitThread(Su(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var S in Me.pthreads){var M=Me.pthreads[S];M&&M.worker&&Me.returnWorkerToPool(M.worker)}Me.pthreads={};for(var z=0;z<Me.unusedWorkers.length;++z){var q=Me.unusedWorkers[z];q.terminate()}Me.unusedWorkers=[];for(var z=0;z<Me.runningWorkers.length;++z){var q=Me.runningWorkers[z],M=q.pthread;Me.freeThreadData(M),q.terminate()}Me.runningWorkers=[]},freeThreadData:function(S){if(!!S){if(S.threadInfoStruct){var M=o()[S.threadInfoStruct+100>>2];o()[S.threadInfoStruct+100>>2]=0,Ym(M),Ym(S.threadInfoStruct)}S.threadInfoStruct=0,S.allocatedOwnStack&&S.stackBase&&Ym(S.stackBase),S.stackBase=0,S.worker&&(S.worker.pthread=null)}},returnWorkerToPool:function(S){Me.runWithoutMainThreadQueuedCalls(function(){delete Me.pthreads[S.pthread.threadInfoStruct],Me.unusedWorkers.push(S),Me.runningWorkers.splice(Me.runningWorkers.indexOf(S),1),Me.freeThreadData(S.pthread),S.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(S){o()[FN>>2]=0;try{S()}finally{o()[FN>>2]=1}},receiveObjectTransfer:function(S){},loadWasmModuleToWorker:function(S,M){S.onmessage=function(z){var q=z.data,Te=q.cmd;if(S.pthread&&(Me.currentProxiedOperationCallerThread=S.pthread.threadInfoStruct),q.targetThread&&q.targetThread!=Su()){var be=Me.pthreads[q.targetThread];be?be.worker.postMessage(z.data,q.transferList):console.error('Internal error! Worker sent a message "'+Te+'" to target pthread '+q.targetThread+", but that thread no longer exists!"),Me.currentProxiedOperationCallerThread=void 0;return}if(Te==="processQueuedMainThreadWork")Gg();else if(Te==="spawnThread")Eg(z.data);else if(Te==="cleanupThread")_g(q.thread);else if(Te==="killThread")tT(q.thread);else if(Te==="cancelThread")rT(q.thread);else if(Te==="loaded")S.loaded=!0,M&&M(S),S.runPthread&&(S.runPthread(),delete S.runPthread);else if(Te==="print")B("Thread "+q.threadId+": "+q.text);else if(Te==="printErr")V("Thread "+q.threadId+": "+q.text);else if(Te==="alert")alert("Thread "+q.threadId+": "+q.text);else if(Te==="exit"){var ye=S.pthread&&Atomics.load(s(),S.pthread.threadInfoStruct+64>>2);ye&&Me.returnWorkerToPool(S)}else if(Te==="exitProcess")try{cj(q.returnCode)}catch(Fe){if(Fe instanceof Zm)return;throw Fe}else Te==="cancelDone"?Me.returnWorkerToPool(S):Te==="objectTransfer"?Me.receiveObjectTransfer(z.data):z.data.target==="setimmediate"?S.postMessage(z.data):V("worker sent an unknown command "+Te);Me.currentProxiedOperationCallerThread=void 0},S.onerror=function(z){V("pthread sent an error! "+z.filename+":"+z.lineno+": "+z.message)},y&&(S.on("message",function(z){S.onmessage({data:z})}),S.on("error",function(z){S.onerror(z)}),S.on("exit",function(z){})),S.postMessage({cmd:"load",urlOrBlob:i.mainScriptUrlOrBlob||r,wasmMemory:te,wasmModule:le})},allocateUnusedWorker:function(){var S=w("tfjs-backend-wasm-threaded-simd.worker.js");Me.unusedWorkers.push(new Worker(S))},getNewWorker:function(){return Me.unusedWorkers.length==0&&(Me.allocateUnusedWorker(),Me.loadWasmModuleToWorker(Me.unusedWorkers[0])),Me.unusedWorkers.length>0?Me.unusedWorkers.pop():null},busySpinWait:function(S){for(var M=performance.now()+S;performance.now()<M;);}};function nT(S,M){DN(S,M),Op(S)}i.establishStackSpace=nT;function oT(){return oe}i.getNoExitRuntime=oT;function sT(S,M){return br.get(S)(M)}i.invokeEntryPoint=sT;function aT(S,M,z,q){di("Assertion failed: "+Oe(S)+", at: "+[M?Oe(M):"unknown filename",z,q?Oe(q):"unknown function"])}function iT(S,M){var z=_main(S,M)}var yl;y?yl=function(){var S=process.hrtime();return S[0]*1e3+S[1]/1e6}:T?yl=function(){return performance.now()-i.__performance_now_clock_drift}:typeof dateNow!="undefined"?yl=dateNow:yl=function(){return performance.now()};function uT(S){return o()[IN()>>2]=S,S}function lT(S,M){if(T)return Cu(1,1,S,M)}function pT(S,M){if(S==M)postMessage({cmd:"processQueuedMainThreadWork"});else if(T)postMessage({targetThread:S,cmd:"processThreadQueue"});else{var z=Me.pthreads[S],q=z&&z.worker;if(!q)return;q.postMessage({cmd:"processThreadQueue"})}return 1}function cT(){di()}function mT(S,M,z){var q=gT(M,z);return Sg[S].apply(null,q)}function fT(S,M){}function Ag(S,M,z){if(S<=0||S>t().length||S&!0)return-28;if(h){if(Atomics.load(o(),S>>2)!=M)return-6;for(var Te=performance.now(),be=Te+z,ye=Atomics.exchange(o(),Gp>>2,S);;){if(Te=performance.now(),Te>be)return ye=Atomics.exchange(o(),Gp>>2,0),-73;if(ye=Atomics.exchange(o(),Gp>>2,0),ye==0)break;if(Gg(),Atomics.load(o(),S>>2)!=M)return-6;ye=Atomics.exchange(o(),Gp>>2,S)}return 0}else{var q=Atomics.wait(o(),S>>2,M,z);if(q==="timed-out")return-73;if(q==="not-equal")return-6;if(q==="ok")return 0;throw"Atomics.wait returned an unexpected value "+q}}function dT(S,M,z){n().copyWithin(S,M,M+z)}function hT(){return y?ns("os").cpus().length:navigator.hardwareConcurrency}function Cu(S,M){for(var z=arguments.length-2,q=Qm(),Te=z,be=zp(Te*8),ye=be>>3,Fe=0;Fe<z;Fe++){var Nt=arguments[2+Fe];a()[ye+Fe]=Nt}var Fr=NN(S,Te,be,M);return Op(q),Fr}var Km=[],Vm=[];function gT(S,M){Vm.length=0;var z;for(M>>=2;z=n()[S++];){var q=z<105;q&&M&1&&M++,Vm.push(q?a()[M++>>1]:o()[M]),++M}return Vm}function bT(S,M,z){Km.length=M;for(var q=z>>3,Te=0;Te<M;Te++)Km[Te]=a()[q+Te];var be=S<0,ye=be?Sg[-S-1]:KT[S];return ye.apply(null,Km)}function yT(){return n().length}function xT(S){try{return te.grow(S-Je.byteLength+65535>>>16),Pr(te.buffer),1}catch(M){}}function TT(S){var M=yT();if(S<=M)return!1;var z=2147483648;if(S>z)return!1;for(var q=1;q<=4;q*=2){var Te=M*(1+.2/q);Te=Math.min(Te,S+100663296);var be=Math.min(z,kt(Math.max(S,Te),65536)),ye=xT(be);if(ye)return!0}return!1}var st={inEventHandler:0,removeAllEventListeners:function(){for(var S=st.eventHandlers.length-1;S>=0;--S)st._removeHandler(S);st.eventHandlers=[],st.deferredCalls=[]},registerRemoveEventListeners:function(){st.removeEventListenersRegistered||(hl.push(st.removeAllEventListeners),st.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(S,M,z){function q(ye,Fe){if(ye.length!=Fe.length)return!1;for(var Nt in ye)if(ye[Nt]!=Fe[Nt])return!1;return!0}for(var Te in st.deferredCalls){var be=st.deferredCalls[Te];if(be.targetFunction==S&&q(be.argsList,z))return}st.deferredCalls.push({targetFunction:S,precedence:M,argsList:z}),st.deferredCalls.sort(function(ye,Fe){return ye.precedence<Fe.precedence})},removeDeferredCalls:function(S){for(var M=0;M<st.deferredCalls.length;++M)st.deferredCalls[M].targetFunction==S&&(st.deferredCalls.splice(M,1),--M)},canPerformEventHandlerRequests:function(){return st.inEventHandler&&st.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!st.canPerformEventHandlerRequests())for(var S=0;S<st.deferredCalls.length;++S){var M=st.deferredCalls[S];st.deferredCalls.splice(S,1),--S,M.targetFunction.apply(null,M.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(S,M){for(var z=0;z<st.eventHandlers.length;++z)st.eventHandlers[z].target==S&&(!M||M==st.eventHandlers[z].eventTypeString)&&st._removeHandler(z--)},_removeHandler:function(S){var M=st.eventHandlers[S];M.target.removeEventListener(M.eventTypeString,M.eventListenerFunc,M.useCapture),st.eventHandlers.splice(S,1)},registerOrRemoveHandler:function(S){var M=function(Te){++st.inEventHandler,st.currentEventHandler=S,st.runDeferredCalls(),S.handlerFunc(Te),st.runDeferredCalls(),--st.inEventHandler};if(S.callbackfunc)S.eventListenerFunc=M,S.target.addEventListener(S.eventTypeString,M,S.useCapture),st.eventHandlers.push(S),st.registerRemoveEventListeners();else for(var z=0;z<st.eventHandlers.length;++z)st.eventHandlers[z].target==S.target&&st.eventHandlers[z].eventTypeString==S.eventTypeString&&st._removeHandler(z--)},queueEventHandlerOnThread_iiii:function(S,M,z,q,Te){var be=Qm(),ye=zp(12);o()[ye>>2]=z,o()[ye+4>>2]=q,o()[ye+8>>2]=Te,pk(0,S,637534208,M,q,ye),Op(be)},getTargetThreadForEventCallback:function(S){switch(S){case 1:return 0;case 2:return Me.currentProxiedOperationCallerThread;default:return S}},getNodeNameForTarget:function(S){return S?S==window?"#window":S==screen?"#screen":S&&S.nodeName?S.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function kT(S){var M=$t(S)+1,z=xl(M);return gt(S,z,M),z}function IT(S,M,z,q){var Te=Qm(),be=zp(12),ye=0;M&&(ye=kT(M)),o()[be>>2]=ye,o()[be+4>>2]=z,o()[be+8>>2]=q,pk(0,S,657457152,0,ye,be),Op(Te)}function CT(S,M,z,q){M=M?Oe(M):"",IT(S,M,z,q)}function vT(S){return S>2?Oe(S):S}var wT=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function ST(S){S=vT(S);var M=wT[S]||(typeof document!="undefined"?document.querySelector(S):void 0);return M}function jm(S){return ST(S)}function Ng(S,M,z){var q=jm(S);if(!q)return-4;if(q.canvasSharedPtr&&(o()[q.canvasSharedPtr>>2]=M,o()[q.canvasSharedPtr+4>>2]=z),q.offscreenCanvas||!q.controlTransferredOffscreen){q.offscreenCanvas&&(q=q.offscreenCanvas);var Te=!1;if(q.GLctxObject&&q.GLctxObject.GLctx){var be=q.GLctxObject.GLctx.getParameter(2978);Te=be[0]===0&&be[1]===0&&be[2]===q.width&&be[3]===q.height}q.width=M,q.height=z,Te&&q.GLctxObject.GLctx.viewport(0,0,M,z)}else if(q.canvasSharedPtr){var ye=o()[q.canvasSharedPtr+8>>2];return CT(ye,S,M,z),1}else return-4;return 0}function Dg(S,M,z){return T?Cu(2,1,S,M,z):Ng(S,M,z)}function _T(S,M,z){var q=jm(S);return q?Ng(S,M,z):Dg(S,M,z)}function AT(S){}function NT(S,M){}function DT(S){var M=S.getExtension("ANGLE_instanced_arrays");if(M)return S.vertexAttribDivisor=function(z,q){M.vertexAttribDivisorANGLE(z,q)},S.drawArraysInstanced=function(z,q,Te,be){M.drawArraysInstancedANGLE(z,q,Te,be)},S.drawElementsInstanced=function(z,q,Te,be,ye){M.drawElementsInstancedANGLE(z,q,Te,be,ye)},1}function PT(S){var M=S.getExtension("OES_vertex_array_object");if(M)return S.createVertexArray=function(){return M.createVertexArrayOES()},S.deleteVertexArray=function(z){M.deleteVertexArrayOES(z)},S.bindVertexArray=function(z){M.bindVertexArrayOES(z)},S.isVertexArray=function(z){return M.isVertexArrayOES(z)},1}function FT(S){var M=S.getExtension("WEBGL_draw_buffers");if(M)return S.drawBuffers=function(z,q){M.drawBuffersWEBGL(z,q)},1}function MT(S){return!!(S.multiDrawWebgl=S.getExtension("WEBGL_multi_draw"))}var vt={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(M){vt.lastError||(vt.lastError=M)},getNewId:function(S){for(var M=vt.counter++,z=S.length;z<M;z++)S[z]=null;return M},getSource:function(S,M,z,q){for(var Te="",be=0;be<M;++be){var ye=q?o()[q+be*4>>2]:-1;Te+=Oe(o()[z+be*4>>2],ye<0?void 0:ye)}return Te},createContext:function(S,M){var z=S.getContext("webgl",M);if(!z)return 0;var q=vt.registerContext(z,M);return q},registerContext:function(S,M){var z=xl(8);o()[z+4>>2]=Su();var q={handle:z,attributes:M,version:M.majorVersion,GLctx:S};return S.canvas&&(S.canvas.GLctxObject=q),vt.contexts[z]=q,(typeof M.enableExtensionsByDefault=="undefined"||M.enableExtensionsByDefault)&&vt.initExtensions(q),z},makeContextCurrent:function(S){return vt.currentContext=vt.contexts[S],i.ctx=vu=vt.currentContext&&vt.currentContext.GLctx,!(S&&!vu)},getContext:function(S){return vt.contexts[S]},deleteContext:function(S){vt.currentContext===vt.contexts[S]&&(vt.currentContext=null),typeof st=="object"&&st.removeAllHandlersOnTarget(vt.contexts[S].GLctx.canvas),vt.contexts[S]&&vt.contexts[S].GLctx.canvas&&(vt.contexts[S].GLctx.canvas.GLctxObject=void 0),Ym(vt.contexts[S].handle),vt.contexts[S]=null},initExtensions:function(S){if(S||(S=vt.currentContext),!S.initExtensionsDone){S.initExtensionsDone=!0;var M=S.GLctx;DT(M),PT(M),FT(M),M.disjointTimerQueryExt=M.getExtension("EXT_disjoint_timer_query"),MT(M);var z=M.getSupportedExtensions()||[];z.forEach(function(q){q.indexOf("lose_context")<0&&q.indexOf("debug")<0&&M.getExtension(q)})}},populateUniformTable:function(S){for(var M=vt.programs[S],z=vt.programInfos[S]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},q=z.uniforms,Te=vu.getProgramParameter(M,35718),be=0;be<Te;++be){var ye=vu.getActiveUniform(M,be),Fe=ye.name;z.maxUniformLength=Math.max(z.maxUniformLength,Fe.length+1),Fe.slice(-1)=="]"&&(Fe=Fe.slice(0,Fe.lastIndexOf("[")));var Nt=vu.getUniformLocation(M,Fe);if(Nt){var Fr=vt.getNewId(vt.uniforms);q[Fe]=[ye.size,Fr],vt.uniforms[Fr]=Nt;for(var Sr=1;Sr<ye.size;++Sr){var _u=Fe+"["+Sr+"]";Nt=vu.getUniformLocation(M,_u),Fr=vt.getNewId(vt.uniforms),vt.uniforms[Fr]=Nt}}}}},ET=["default","low-power","high-performance"];function RT(S,M){var z=M>>2,q=o()[z+(24>>2)],Te={alpha:!!o()[z+(0>>2)],depth:!!o()[z+(4>>2)],stencil:!!o()[z+(8>>2)],antialias:!!o()[z+(12>>2)],premultipliedAlpha:!!o()[z+(16>>2)],preserveDrawingBuffer:!!o()[z+(20>>2)],powerPreference:ET[q],failIfMajorPerformanceCaveat:!!o()[z+(28>>2)],majorVersion:o()[z+(32>>2)],minorVersion:o()[z+(36>>2)],enableExtensionsByDefault:o()[z+(40>>2)],explicitSwapControl:o()[z+(44>>2)],proxyContextToMainThread:o()[z+(48>>2)],renderViaOffscreenBackBuffer:o()[z+(52>>2)]},be=jm(S);if(!be||Te.explicitSwapControl)return 0;var ye=vt.createContext(be,Te);return ye}function LT(S,M){return RT(S,M)}var $p={mappings:{},buffers:[null,[],[]],printChar:function(S,M){var z=$p.buffers[S];M===0||M===10?((S===1?B:V)(Re(z,0)),z.length=0):z.push(M)},varargs:void 0,get:function(){$p.varargs+=4;var S=o()[$p.varargs-4>>2];return S},getStr:function(S){var M=Oe(S);return M},get64:function(S,M){return S}};function Pg(S){return T?Cu(3,1,S):0}function Fg(S,M,z,q,Te){if(T)return Cu(4,1,S,M,z,q,Te)}function Mg(S,M,z,q){if(T)return Cu(5,1,S,M,z,q);for(var Te=0,be=0;be<z;be++){for(var ye=o()[M+be*8>>2],Fe=o()[M+(be*8+4)>>2],Nt=0;Nt<Fe;Nt++)$p.printChar(S,n()[ye+Nt]);Te+=Fe}return o()[q>>2]=Te,0}function $T(S){var M=Me.threadExitHandlers.pop();S&&M()}function BT(S,M){Me.threadExitHandlers.push(function(){br.get(S)(M)})}function Eg(S){if(T)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var M=Me.getNewWorker();if(M.pthread!==void 0)throw"Internal error!";if(!S.pthread_ptr)throw"Internal error, no pthread ptr!";Me.runningWorkers.push(M);for(var z=xl(128*4),q=0;q<128;++q)o()[z+q*4>>2]=0;var Te=S.stackBase+S.stackSize,be=Me.pthreads[S.pthread_ptr]={worker:M,stackBase:S.stackBase,stackSize:S.stackSize,allocatedOwnStack:S.allocatedOwnStack,threadInfoStruct:S.pthread_ptr},ye=be.threadInfoStruct>>2;Atomics.store(s(),ye+(64>>2),S.detached),Atomics.store(s(),ye+(100>>2),z),Atomics.store(s(),ye+(40>>2),be.threadInfoStruct),Atomics.store(s(),ye+(80>>2),S.stackSize),Atomics.store(s(),ye+(76>>2),Te),Atomics.store(s(),ye+(104>>2),S.stackSize),Atomics.store(s(),ye+(104+8>>2),Te),Atomics.store(s(),ye+(104+12>>2),S.detached);var Fe=CN(),Nt=Fe+40;Atomics.store(s(),ye+(172>>2),Nt),M.pthread=be;var Fr={cmd:"run",start_routine:S.startRoutine,arg:S.arg,threadInfoStruct:S.pthread_ptr,stackBase:S.stackBase,stackSize:S.stackSize};M.runPthread=function(){Fr.time=performance.now(),M.postMessage(Fr,S.transferList)},M.loaded&&(M.runPthread(),delete M.runPthread)}function OT(S,M,z,q){if(typeof SharedArrayBuffer=="undefined")return V("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!S)return V("pthread_create called with a null thread pointer!"),28;var Te=[],be=0;if(T&&(Te.length===0||be))return AN(687865856,S,M,z,q);if(be)return be;var ye=0,Fe=0,Nt=0;M&&M!=-1?(ye=o()[M>>2],ye+=81920,Fe=o()[M+8>>2],Nt=o()[M+12>>2]!==0):ye=2097152;var Fr=Fe==0;Fr?Fe=PN(16,ye):(Fe-=ye,fe(Fe>0));for(var Sr=xl(228),_u=0;_u<228>>2;++_u)s()[(Sr>>2)+_u]=0;o()[S>>2]=Sr,o()[Sr+12>>2]=Sr;var Wp=Sr+152;o()[Wp>>2]=Wp;var nn={stackBase:Fe,stackSize:ye,allocatedOwnStack:Fr,detached:Nt,startRoutine:z,pthread_ptr:Sr,arg:q,transferList:Te};return T?(nn.cmd="spawnThread",postMessage(nn,Te)):Eg(nn),0}function zT(){if(!!T){var S=Su();if(!!S){var M=Atomics.load(s(),S+56>>2);if(!M){var z=Atomics.load(s(),S+0>>2);if(z==2)throw"Canceled!"}}}}function GT(){y||g||j("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function WT(S,M,z){if(!S)return V("pthread_join attempted on a null thread pointer!"),Iu.ESRCH;if(T&&Su()==S)return V("PThread "+S+" is attempting to join to itself!"),Iu.EDEADLK;if(!T&&SN()==S)return V("Main thread "+S+" is attempting to join to itself!"),Iu.EDEADLK;var q=o()[S+12>>2];if(q!==S)return V("pthread_join attempted on thread "+S+", which does not point to a valid thread, or does not exist anymore!"),Iu.ESRCH;var Te=Atomics.load(s(),S+64>>2);if(Te)return V("Attempted to join thread "+S+", which was already detached!"),Iu.EINVAL;for(z&&GT();;){var be=Atomics.load(s(),S+0>>2);if(be==1){var ye=Atomics.load(s(),S+4>>2);return M&&(o()[M>>2]=ye),Atomics.store(s(),S+64>>2,1),T?postMessage({cmd:"cleanupThread",thread:S}):_g(S),0}if(!z)return Iu.EBUSY;zT(),T||Gg(),Ag(S+0,be,T?100:1)}}function UT(S,M){return WT(S,M,!0)}function Rg(S){if(T)return Cu(6,1,S);switch(S){case 30:return 16384;case 85:var M=2147483648;return M/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return uT(28),-1}T||Me.initMainThreadBlock();var vu,KT=[null,lT,Dg,Pg,Fg,Mg,Rg],VT={e:aT,r:iT,x:pT,b:cT,y:mT,j:fT,d:Ag,c:Um,f:yl,p:dT,A:hT,u:bT,q:TT,v:_T,i:AT,s:NT,w:LT,l:Pg,n:Fg,g:Mg,o:eT,a:te||i.wasmMemory,z:$T,k:BT,h:OT,m:UT,t:Rg},kN=Jx(),Lg=i.___wasm_call_ctors=function(){return(Lg=i.___wasm_call_ctors=i.asm.B).apply(null,arguments)},jT=i._init=function(){return(jT=i._init=i.asm.C).apply(null,arguments)},HT=i._init_with_threads_count=function(){return(HT=i._init_with_threads_count=i.asm.D).apply(null,arguments)},qT=i._get_threads_count=function(){return(qT=i._get_threads_count=i.asm.E).apply(null,arguments)},XT=i._register_tensor=function(){return(XT=i._register_tensor=i.asm.F).apply(null,arguments)},YT=i._dispose_data=function(){return(YT=i._dispose_data=i.asm.G).apply(null,arguments)},QT=i._dispose=function(){return(QT=i._dispose=i.asm.H).apply(null,arguments)},ZT=i._Abs=function(){return(ZT=i._Abs=i.asm.I).apply(null,arguments)},JT=i._Add=function(){return(JT=i._Add=i.asm.J).apply(null,arguments)},ek=i._AddN=function(){return(ek=i._AddN=i.asm.K).apply(null,arguments)},tk=i._All=function(){return(tk=i._All=i.asm.L).apply(null,arguments)},rk=i._Any=function(){return(rk=i._Any=i.asm.M).apply(null,arguments)},nk=i._ArgMax=function(){return(nk=i._ArgMax=i.asm.N).apply(null,arguments)},ok=i._AvgPool=function(){return(ok=i._AvgPool=i.asm.O).apply(null,arguments)},sk=i._BatchMatMul=function(){return(sk=i._BatchMatMul=i.asm.P).apply(null,arguments)},ak=i._Ceil=function(){return(ak=i._Ceil=i.asm.Q).apply(null,arguments)},ik=i._ClipByValue=function(){return(ik=i._ClipByValue=i.asm.R).apply(null,arguments)},uk=i._Conv2D=function(){return(uk=i._Conv2D=i.asm.S).apply(null,arguments)},$g=i._Conv2DBackpropInput=function(){return($g=i._Conv2DBackpropInput=i.asm.T).apply(null,arguments)},Bg=i._Cos=function(){return(Bg=i._Cos=i.asm.U).apply(null,arguments)},Hm=i._Cosh=function(){return(Hm=i._Cosh=i.asm.V).apply(null,arguments)},Bp=i._CropAndResize=function(){return(Bp=i._CropAndResize=i.asm.W).apply(null,arguments)},lk=i._Cumsum=function(){return(lk=i._Cumsum=i.asm.X).apply(null,arguments)},qm=i._DepthToSpace=function(){return(qm=i._DepthToSpace=i.asm.Y).apply(null,arguments)},Z=i._DepthwiseConv2dNative=function(){return(Z=i._DepthwiseConv2dNative=i.asm.Z).apply(null,arguments)},se=i._Elu=function(){return(se=i._Elu=i.asm._).apply(null,arguments)},Ne=i._Equal=function(){return(Ne=i._Equal=i.asm.$).apply(null,arguments)},yt=i._Exp=function(){return(yt=i._Exp=i.asm.aa).apply(null,arguments)},pr=i._FlipLeftRight=function(){return(pr=i._FlipLeftRight=i.asm.ba).apply(null,arguments)},rr=i._Floor=function(){return(rr=i._Floor=i.asm.ca).apply(null,arguments)},ut=i._FloorDiv=function(){return(ut=i._FloorDiv=i.asm.da).apply(null,arguments)},pt=i._FusedBatchNorm=function(){return(pt=i._FusedBatchNorm=i.asm.ea).apply(null,arguments)},Gr=i._FusedConv2D=function(){return(Gr=i._FusedConv2D=i.asm.fa).apply(null,arguments)},hi=i._FusedDepthwiseConv2D=function(){return(hi=i._FusedDepthwiseConv2D=i.asm.ga).apply(null,arguments)},gi=i._Gather=function(){return(gi=i._Gather=i.asm.ha).apply(null,arguments)},Og=i._GatherNd=function(){return(Og=i._GatherNd=i.asm.ia).apply(null,arguments)},Xm=i._Greater=function(){return(Xm=i._Greater=i.asm.ja).apply(null,arguments)},Gn=i._GreaterEqual=function(){return(Gn=i._GreaterEqual=i.asm.ka).apply(null,arguments)},wu=i._LeakyRelu=function(){return(wu=i._LeakyRelu=i.asm.la).apply(null,arguments)},zg=i._Less=function(){return(zg=i._Less=i.asm.ma).apply(null,arguments)},h4=i._LessEqual=function(){return(h4=i._LessEqual=i.asm.na).apply(null,arguments)},g4=i._Log=function(){return(g4=i._Log=i.asm.oa).apply(null,arguments)},b4=i._LogicalAnd=function(){return(b4=i._LogicalAnd=i.asm.pa).apply(null,arguments)},y4=i._Max=function(){return(y4=i._Max=i.asm.qa).apply(null,arguments)},x4=i._MaxPool=function(){return(x4=i._MaxPool=i.asm.ra).apply(null,arguments)},T4=i._Maximum=function(){return(T4=i._Maximum=i.asm.sa).apply(null,arguments)},k4=i._Mean=function(){return(k4=i._Mean=i.asm.ta).apply(null,arguments)},I4=i._Min=function(){return(I4=i._Min=i.asm.ua).apply(null,arguments)},C4=i._Minimum=function(){return(C4=i._Minimum=i.asm.va).apply(null,arguments)},v4=i._MirrorPad=function(){return(v4=i._MirrorPad=i.asm.wa).apply(null,arguments)},w4=i._Multiply=function(){return(w4=i._Multiply=i.asm.xa).apply(null,arguments)},S4=i._Neg=function(){return(S4=i._Neg=i.asm.ya).apply(null,arguments)},_4=i._NonMaxSuppressionV3=function(){return(_4=i._NonMaxSuppressionV3=i.asm.za).apply(null,arguments)},A4=i._NonMaxSuppressionV4=function(){return(A4=i._NonMaxSuppressionV4=i.asm.Aa).apply(null,arguments)},N4=i._NonMaxSuppressionV5=function(){return(N4=i._NonMaxSuppressionV5=i.asm.Ba).apply(null,arguments)},D4=i._NotEqual=function(){return(D4=i._NotEqual=i.asm.Ca).apply(null,arguments)},P4=i._OneHot=function(){return(P4=i._OneHot=i.asm.Da).apply(null,arguments)},F4=i._PadV2=function(){return(F4=i._PadV2=i.asm.Ea).apply(null,arguments)},M4=i._Pow=function(){return(M4=i._Pow=i.asm.Fa).apply(null,arguments)},E4=i._Prelu=function(){return(E4=i._Prelu=i.asm.Ga).apply(null,arguments)},R4=i._Prod=function(){return(R4=i._Prod=i.asm.Ha).apply(null,arguments)},L4=i._RealDiv=function(){return(L4=i._RealDiv=i.asm.Ia).apply(null,arguments)},$4=i._Relu=function(){return($4=i._Relu=i.asm.Ja).apply(null,arguments)},B4=i._Relu6=function(){return(B4=i._Relu6=i.asm.Ka).apply(null,arguments)},O4=i._ResizeBilinear=function(){return(O4=i._ResizeBilinear=i.asm.La).apply(null,arguments)},z4=i._Reverse=function(){return(z4=i._Reverse=i.asm.Ma).apply(null,arguments)},G4=i._RotateWithOffset=function(){return(G4=i._RotateWithOffset=i.asm.Na).apply(null,arguments)},W4=i._Round=function(){return(W4=i._Round=i.asm.Oa).apply(null,arguments)},U4=i._Rsqrt=function(){return(U4=i._Rsqrt=i.asm.Pa).apply(null,arguments)},K4=i._ScatterNd=function(){return(K4=i._ScatterNd=i.asm.Qa).apply(null,arguments)},V4=i._SelectV2=function(){return(V4=i._SelectV2=i.asm.Ra).apply(null,arguments)},j4=i._Sigmoid=function(){return(j4=i._Sigmoid=i.asm.Sa).apply(null,arguments)},H4=i._Sin=function(){return(H4=i._Sin=i.asm.Ta).apply(null,arguments)},q4=i._Softmax=function(){return(q4=i._Softmax=i.asm.Ua).apply(null,arguments)},X4=i._Sqrt=function(){return(X4=i._Sqrt=i.asm.Va).apply(null,arguments)},Y4=i._Square=function(){return(Y4=i._Square=i.asm.Wa).apply(null,arguments)},Q4=i._SquaredDifference=function(){return(Q4=i._SquaredDifference=i.asm.Xa).apply(null,arguments)},Z4=i._Step=function(){return(Z4=i._Step=i.asm.Ya).apply(null,arguments)},J4=i._StridedSlice=function(){return(J4=i._StridedSlice=i.asm.Za).apply(null,arguments)},ej=i._Sub=function(){return(ej=i._Sub=i.asm._a).apply(null,arguments)},tj=i._Sum=function(){return(tj=i._Sum=i.asm.$a).apply(null,arguments)},rj=i._Tan=function(){return(rj=i._Tan=i.asm.ab).apply(null,arguments)},nj=i._Tanh=function(){return(nj=i._Tanh=i.asm.bb).apply(null,arguments)},oj=i._Tile=function(){return(oj=i._Tile=i.asm.cb).apply(null,arguments)},sj=i._TopK=function(){return(sj=i._TopK=i.asm.db).apply(null,arguments)},aj=i._Transform=function(){return(aj=i._Transform=i.asm.eb).apply(null,arguments)},ij=i._Transpose=function(){return(ij=i._Transpose=i.asm.fb).apply(null,arguments)},uj=i.__FusedMatMul=function(){return(uj=i.__FusedMatMul=i.asm.gb).apply(null,arguments)},xl=i._malloc=function(){return(xl=i._malloc=i.asm.hb).apply(null,arguments)},Ym=i._free=function(){return(Ym=i._free=i.asm.ib).apply(null,arguments)},IN=i.___errno_location=function(){return(IN=i.___errno_location=i.asm.jb).apply(null,arguments)},CN=i._emscripten_get_global_libc=function(){return(CN=i._emscripten_get_global_libc=i.asm.lb).apply(null,arguments)},Su=i._pthread_self=function(){return(Su=i._pthread_self=i.asm.mb).apply(null,arguments)},vN=i.___pthread_tsd_run_dtors=function(){return(vN=i.___pthread_tsd_run_dtors=i.asm.nb).apply(null,arguments)},Gg=i._emscripten_main_thread_process_queued_calls=function(){return(Gg=i._emscripten_main_thread_process_queued_calls=i.asm.ob).apply(null,arguments)},lj=i._emscripten_current_thread_process_queued_calls=function(){return(lj=i._emscripten_current_thread_process_queued_calls=i.asm.pb).apply(null,arguments)},wN=i._emscripten_register_main_browser_thread_id=function(){return(wN=i._emscripten_register_main_browser_thread_id=i.asm.qb).apply(null,arguments)},SN=i._emscripten_main_browser_thread_id=function(){return(SN=i._emscripten_main_browser_thread_id=i.asm.rb).apply(null,arguments)},_N=i.__emscripten_do_dispatch_to_thread=function(){return(_N=i.__emscripten_do_dispatch_to_thread=i.asm.sb).apply(null,arguments)},AN=i._emscripten_sync_run_in_main_thread_4=function(){return(AN=i._emscripten_sync_run_in_main_thread_4=i.asm.tb).apply(null,arguments)},NN=i._emscripten_run_in_main_runtime_thread_js=function(){return(NN=i._emscripten_run_in_main_runtime_thread_js=i.asm.ub).apply(null,arguments)},pk=i.__emscripten_call_on_thread=function(){return(pk=i.__emscripten_call_on_thread=i.asm.vb).apply(null,arguments)},pj=i._emscripten_tls_init=function(){return(pj=i._emscripten_tls_init=i.asm.wb).apply(null,arguments)},ck=i.__emscripten_thread_init=function(){return(ck=i.__emscripten_thread_init=i.asm.xb).apply(null,arguments)},Qm=i.stackSave=function(){return(Qm=i.stackSave=i.asm.yb).apply(null,arguments)},Op=i.stackRestore=function(){return(Op=i.stackRestore=i.asm.zb).apply(null,arguments)},zp=i.stackAlloc=function(){return(zp=i.stackAlloc=i.asm.Ab).apply(null,arguments)},DN=i._emscripten_stack_set_limits=function(){return(DN=i._emscripten_stack_set_limits=i.asm.Bb).apply(null,arguments)},PN=i._memalign=function(){return(PN=i._memalign=i.asm.Cb).apply(null,arguments)},FN=i.__emscripten_allow_main_runtime_queued_calls=10064,Gp=i.__emscripten_main_thread_futex=10268;i.cwrap=Be,i.PThread=Me,i.PThread=Me,i.wasmMemory=te,i.ExitStatus=Zm;var Wg;function Zm(S){this.name="ExitStatus",this.message="Program terminated with exit("+S+")",this.status=S}gl=function S(){Wg||mk(),Wg||(gl=S)};function mk(S){if(S=S||m,rs>0)return;if(T){u(i),Tg(),postMessage({cmd:"loaded"});return}if(Rp(),rs>0)return;function M(){Wg||(Wg=!0,i.calledRun=!0,!ae&&(Tg(),kg(),u(i),i.onRuntimeInitialized&&i.onRuntimeInitialized(),Ig()))}i.setStatus?(i.setStatus("Running..."),setTimeout(function(){setTimeout(function(){i.setStatus("")},1),M()},1)):M()}i.run=mk;function cj(S,M){if(!(M&&oe&&S===0)){if(!M&&T)throw postMessage({cmd:"exitProcess",returnCode:S}),new Zm(S);oe||(Me.terminateAllThreads(),ge=S,vn(),i.onExit&&i.onExit(S),ae=!0),d(S,new Zm(S))}}if(i.preInit)for(typeof i.preInit=="function"&&(i.preInit=[i.preInit]);i.preInit.length>0;)i.preInit.pop()();return T&&(oe=!1,Me.initWorker()),mk(),e.ready}}();typeof Wx=="object"&&typeof hN=="object"?hN.exports=dN:typeof define=="function"&&define.amd?define([],function(){return dN}):typeof Wx=="object"&&(Wx.WasmBackendModuleThreadedSimd=dN)});var p4=Sn((Ux,bN)=>{var gN=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};var t=typeof e!="undefined"?e:{},n,o;t.ready=new Promise(function(Z,se){n=Z,o=se});var s={},a;for(a in t)t.hasOwnProperty(a)&&(s[a]=t[a]);var i=[],u="./this.program",l=function(Z,se){throw se},p=!1,c=!1,m=!1,f=!1;p=typeof window=="object",c=typeof importScripts=="function",m=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f=!p&&!m&&!c;var d="";function h(Z){return t.locateFile?t.locateFile(Z,d):d+Z}var g,y,x,T,k,w;m?(c?d=ns("path").dirname(d)+"/":d=__dirname+"/",g=function(se,Ne){return k||(k=ns("fs")),w||(w=ns("path")),se=w.normalize(se),k.readFileSync(se,Ne?null:"utf8")},x=function(se){var Ne=g(se,!0);return Ne.buffer||(Ne=new Uint8Array(Ne)),B(Ne.buffer),Ne},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),i=process.argv.slice(2),process.on("uncaughtException",function(Z){if(!(Z instanceof lk))throw Z}),process.on("unhandledRejection",js),l=function(Z){process.exit(Z)},t.inspect=function(){return"[Emscripten Module object]"}):f?(typeof read!="undefined"&&(g=function(se){return read(se)}),x=function(se){var Ne;return typeof readbuffer=="function"?new Uint8Array(readbuffer(se)):(Ne=read(se,"binary"),B(typeof Ne=="object"),Ne)},typeof scriptArgs!="undefined"?i=scriptArgs:typeof arguments!="undefined"&&(i=arguments),typeof quit=="function"&&(l=function(Z){quit(Z)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(p||c)&&(c?d=self.location.href:typeof document!="undefined"&&document.currentScript&&(d=document.currentScript.src),r&&(d=r),d.indexOf("blob:")!==0?d=d.substr(0,d.lastIndexOf("/")+1):d="",g=function(Z){var se=new XMLHttpRequest;return se.open("GET",Z,!1),se.send(null),se.responseText},c&&(x=function(Z){var se=new XMLHttpRequest;return se.open("GET",Z,!1),se.responseType="arraybuffer",se.send(null),new Uint8Array(se.response)}),y=function(Z,se,Ne){var yt=new XMLHttpRequest;yt.open("GET",Z,!0),yt.responseType="arraybuffer",yt.onload=function(){if(yt.status==200||yt.status==0&&yt.response){se(yt.response);return}Ne()},yt.onerror=Ne,yt.send(null)},T=function(Z){document.title=Z});var P=t.print||console.log.bind(console),A=t.printErr||console.warn.bind(console);for(a in s)s.hasOwnProperty(a)&&(t[a]=s[a]);s=null,t.arguments&&(i=t.arguments),t.thisProgram&&(u=t.thisProgram),t.quit&&(l=t.quit);var F;t.wasmBinary&&(F=t.wasmBinary);var E=t.noExitRuntime||!0;typeof WebAssembly!="object"&&js("no native wasm support detected");var $,W=!1,K;function B(Z,se){Z||js("Assertion failed: "+se)}function V(Z){var se=t["_"+Z];return B(se,"Cannot call unknown function "+Z+", make sure it is exported"),se}function j(Z,se,Ne,yt,pr){var rr={string:function(Gn){var wu=0;if(Gn!=null&&Gn!==0){var zg=(Gn.length<<2)+1;wu=Hm(zg),te(Gn,wu,zg)}return wu},array:function(Gn){var wu=Hm(Gn.length);return le(Gn,wu),wu}};function ut(Gn){return se==="string"?ne(Gn):se==="boolean"?Boolean(Gn):Gn}var pt=V(Z),Gr=[],hi=0;if(yt)for(var gi=0;gi<yt.length;gi++){var Og=rr[Ne[gi]];Og?(hi===0&&(hi=$g()),Gr[gi]=Og(yt[gi])):Gr[gi]=yt[gi]}var Xm=pt.apply(null,Gr);return Xm=ut(Xm),hi!==0&&Bg(hi),Xm}function H(Z,se,Ne,yt){Ne=Ne||[];var pr=Ne.every(function(ut){return ut==="number"}),rr=se!=="string";return rr&&pr&&!yt?V(Z):function(){return j(Z,se,Ne,arguments,yt)}}var J=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function X(Z,se,Ne){for(var yt=se+Ne,pr=se;Z[pr]&&!(pr>=yt);)++pr;if(pr-se>16&&Z.subarray&&J)return J.decode(Z.subarray(se,pr));for(var rr="";se<pr;){var ut=Z[se++];if(!(ut&128)){rr+=String.fromCharCode(ut);continue}var pt=Z[se++]&63;if((ut&224)==192){rr+=String.fromCharCode((ut&31)<<6|pt);continue}var Gr=Z[se++]&63;if((ut&240)==224?ut=(ut&15)<<12|pt<<6|Gr:ut=(ut&7)<<18|pt<<12|Gr<<6|Z[se++]&63,ut<65536)rr+=String.fromCharCode(ut);else{var hi=ut-65536;rr+=String.fromCharCode(55296|hi>>10,56320|hi&1023)}}return rr}function ne(Z,se){return Z?X(xe,Z,se):""}function oe(Z,se,Ne,yt){if(!(yt>0))return 0;for(var pr=Ne,rr=Ne+yt-1,ut=0;ut<Z.length;++ut){var pt=Z.charCodeAt(ut);if(pt>=55296&&pt<=57343){var Gr=Z.charCodeAt(++ut);pt=65536+((pt&1023)<<10)|Gr&1023}if(pt<=127){if(Ne>=rr)break;se[Ne++]=pt}else if(pt<=2047){if(Ne+1>=rr)break;se[Ne++]=192|pt>>6,se[Ne++]=128|pt&63}else if(pt<=65535){if(Ne+2>=rr)break;se[Ne++]=224|pt>>12,se[Ne++]=128|pt>>6&63,se[Ne++]=128|pt&63}else{if(Ne+3>=rr)break;se[Ne++]=240|pt>>18,se[Ne++]=128|pt>>12&63,se[Ne++]=128|pt>>6&63,se[Ne++]=128|pt&63}}return se[Ne]=0,Ne-pr}function te(Z,se,Ne){return oe(Z,xe,se,Ne)}function le(Z,se){fe.set(Z,se)}function ae(Z,se){return Z%se>0&&(Z+=se-Z%se),Z}var ge,fe,xe,Se,Be,Re,Oe,rt,gt;function $t(Z){ge=Z,t.HEAP8=fe=new Int8Array(Z),t.HEAP16=Se=new Int16Array(Z),t.HEAP32=Re=new Int32Array(Z),t.HEAPU8=xe=new Uint8Array(Z),t.HEAPU16=Be=new Uint16Array(Z),t.HEAPU32=Oe=new Uint32Array(Z),t.HEAPF32=rt=new Float32Array(Z),t.HEAPF64=gt=new Float64Array(Z)}var Bt=t.INITIAL_MEMORY||16777216,kt,Je=[],Ct=[],Ht=[],On=[],gr=!1;Ct.push({func:function(){wg()}});function In(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)Pr(t.preRun.shift());rs(Je)}function zr(){gr=!0,rs(Ct)}function Vs(){rs(Ht)}function rn(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)eo(t.postRun.shift());rs(On)}function Pr(Z){Je.unshift(Z)}function eo(Z){On.unshift(Z)}var br=0,Cn=null,zn=null;function dl(Z){br++,t.monitorRunDependencies&&t.monitorRunDependencies(br)}function hl(Z){if(br--,t.monitorRunDependencies&&t.monitorRunDependencies(br),br==0&&(Cn!==null&&(clearInterval(Cn),Cn=null),zn)){var se=zn;zn=null,se()}}t.preloadedImages={},t.preloadedAudios={};function js(Z){t.onAbort&&t.onAbort(Z),Z+="",A(Z),W=!0,K=1,Z="abort("+Z+"). Build with -s ASSERTIONS=1 for more info.";var se=new WebAssembly.RuntimeError(Z);throw o(se),se}function fi(Z,se){return String.prototype.startsWith?Z.startsWith(se):Z.indexOf(se)===0}var Gm="data:application/octet-stream;base64,";function Rp(Z){return fi(Z,Gm)}var Tg="file://";function kg(Z){return fi(Z,Tg)}var vn="tfjs-backend-wasm.wasm";Rp(vn)||(vn=h(vn));function Ig(Z){try{if(Z==vn&&F)return new Uint8Array(F);if(x)return x(Z);throw"both async and sync fetching of the wasm failed"}catch(se){js(se)}}function jx(){if(!F&&(p||c)){if(typeof fetch=="function"&&!kg(vn))return fetch(vn,{credentials:"same-origin"}).then(function(Z){if(!Z.ok)throw"failed to load wasm binary file at '"+vn+"'";return Z.arrayBuffer()}).catch(function(){return Ig(vn)});if(y)return new Promise(function(Z,se){y(vn,function(Ne){Z(new Uint8Array(Ne))},se)})}return Promise.resolve().then(function(){return Ig(vn)})}function Hx(){var Z={a:wn};function se(ut,pt){var Gr=ut.exports;t.asm=Gr,$=t.asm.h,$t($.buffer),kt=t.asm.Sa,hl("wasm-instantiate")}dl("wasm-instantiate");function Ne(ut){se(ut.instance)}function yt(ut){return jx().then(function(pt){return WebAssembly.instantiate(pt,Z)}).then(ut,function(pt){A("failed to asynchronously prepare wasm: "+pt),js(pt)})}function pr(){return!F&&typeof WebAssembly.instantiateStreaming=="function"&&!Rp(vn)&&!kg(vn)&&typeof fetch=="function"?fetch(vn,{credentials:"same-origin"}).then(function(ut){var pt=WebAssembly.instantiateStreaming(ut,Z);return pt.then(Ne,function(Gr){return A("wasm streaming compile failed: "+Gr),A("falling back to ArrayBuffer instantiation"),yt(Ne)})}):yt(Ne)}if(t.instantiateWasm)try{var rr=t.instantiateWasm(Z,se);return rr}catch(ut){return A("Module.instantiateWasm callback failed with error: "+ut),!1}return pr().catch(o),{}}function rs(Z){for(;Z.length>0;){var se=Z.shift();if(typeof se=="function"){se(t);continue}var Ne=se.func;typeof Ne=="number"?se.arg===void 0?kt.get(Ne)():kt.get(Ne)(se.arg):Ne(se.arg===void 0?null:se.arg)}}function Wm(){js()}function gl(Z,se,Ne){xe.copyWithin(Z,se,se+Ne)}function qx(){return xe.length}function Xx(Z){try{return $.grow(Z-ge.byteLength+65535>>>16),$t($.buffer),1}catch(se){}}function di(Z){var se=qx(),Ne=2147483648;if(Z>Ne)return!1;for(var yt=1;yt<=4;yt*=2){var pr=se*(1+.2/yt);pr=Math.min(pr,Z+100663296);var rr=Math.min(Ne,ae(Math.max(Z,pr),65536)),ut=Xx(rr);if(ut)return!0}return!1}var bl={mappings:{},buffers:[null,[],[]],printChar:function(Z,se){var Ne=bl.buffers[Z];se===0||se===10?((Z===1?P:A)(X(Ne,0)),Ne.length=0):Ne.push(se)},varargs:void 0,get:function(){bl.varargs+=4;var Z=Re[bl.varargs-4>>2];return Z},getStr:function(Z){var se=ne(Z);return se},get64:function(Z,se){return Z}};function Yx(Z){return 0}function Cg(Z,se,Ne,yt,pr){}function Qx(Z,se,Ne,yt){for(var pr=0,rr=0;rr<Ne;rr++){for(var ut=Re[se+rr*8>>2],pt=Re[se+(rr*8+4)>>2],Gr=0;Gr<pt;Gr++)bl.printChar(Z,xe[ut+Gr]);pr+=pt}return Re[yt>>2]=pr,0}function vg(){return 28}var wn={a:Wm,d:gl,e:di,f:Yx,c:Cg,b:Qx,g:vg},Zx=Hx(),wg=t.___wasm_call_ctors=function(){return(wg=t.___wasm_call_ctors=t.asm.i).apply(null,arguments)},Jx=t._init=function(){return(Jx=t._init=t.asm.j).apply(null,arguments)},Sg=t._init_with_threads_count=function(){return(Sg=t._init_with_threads_count=t.asm.k).apply(null,arguments)},eT=t._get_threads_count=function(){return(eT=t._get_threads_count=t.asm.l).apply(null,arguments)},Lp=t._register_tensor=function(){return(Lp=t._register_tensor=t.asm.m).apply(null,arguments)},Iu=t._dispose_data=function(){return(Iu=t._dispose_data=t.asm.n).apply(null,arguments)},Um=t._dispose=function(){return(Um=t._dispose=t.asm.o).apply(null,arguments)},tT=t._Abs=function(){return(tT=t._Abs=t.asm.p).apply(null,arguments)},rT=t._Add=function(){return(rT=t._Add=t.asm.q).apply(null,arguments)},_g=t._AddN=function(){return(_g=t._AddN=t.asm.r).apply(null,arguments)},Me=t._All=function(){return(Me=t._All=t.asm.s).apply(null,arguments)},nT=t._Any=function(){return(nT=t._Any=t.asm.t).apply(null,arguments)},oT=t._ArgMax=function(){return(oT=t._ArgMax=t.asm.u).apply(null,arguments)},sT=t._AvgPool=function(){return(sT=t._AvgPool=t.asm.v).apply(null,arguments)},aT=t._BatchMatMul=function(){return(aT=t._BatchMatMul=t.asm.w).apply(null,arguments)},iT=t._Ceil=function(){return(iT=t._Ceil=t.asm.x).apply(null,arguments)},yl=t._ClipByValue=function(){return(yl=t._ClipByValue=t.asm.y).apply(null,arguments)},uT=t._Conv2D=function(){return(uT=t._Conv2D=t.asm.z).apply(null,arguments)},lT=t._Conv2DBackpropInput=function(){return(lT=t._Conv2DBackpropInput=t.asm.A).apply(null,arguments)},pT=t._Cos=function(){return(pT=t._Cos=t.asm.B).apply(null,arguments)},cT=t._Cosh=function(){return(cT=t._Cosh=t.asm.C).apply(null,arguments)},mT=t._CropAndResize=function(){return(mT=t._CropAndResize=t.asm.D).apply(null,arguments)},fT=t._Cumsum=function(){return(fT=t._Cumsum=t.asm.E).apply(null,arguments)},Ag=t._DepthToSpace=function(){return(Ag=t._DepthToSpace=t.asm.F).apply(null,arguments)},dT=t._DepthwiseConv2dNative=function(){return(dT=t._DepthwiseConv2dNative=t.asm.G).apply(null,arguments)},hT=t._Elu=function(){return(hT=t._Elu=t.asm.H).apply(null,arguments)},Cu=t._Equal=function(){return(Cu=t._Equal=t.asm.I).apply(null,arguments)},Km=t._Exp=function(){return(Km=t._Exp=t.asm.J).apply(null,arguments)},Vm=t._FlipLeftRight=function(){return(Vm=t._FlipLeftRight=t.asm.K).apply(null,arguments)},gT=t._Floor=function(){return(gT=t._Floor=t.asm.L).apply(null,arguments)},bT=t._FloorDiv=function(){return(bT=t._FloorDiv=t.asm.M).apply(null,arguments)},yT=t._FusedBatchNorm=function(){return(yT=t._FusedBatchNorm=t.asm.N).apply(null,arguments)},xT=t._FusedConv2D=function(){return(xT=t._FusedConv2D=t.asm.O).apply(null,arguments)},TT=t._FusedDepthwiseConv2D=function(){return(TT=t._FusedDepthwiseConv2D=t.asm.P).apply(null,arguments)},st=t._Gather=function(){return(st=t._Gather=t.asm.Q).apply(null,arguments)},kT=t._GatherNd=function(){return(kT=t._GatherNd=t.asm.R).apply(null,arguments)},IT=t._Greater=function(){return(IT=t._Greater=t.asm.S).apply(null,arguments)},CT=t._GreaterEqual=function(){return(CT=t._GreaterEqual=t.asm.T).apply(null,arguments)},vT=t._LeakyRelu=function(){return(vT=t._LeakyRelu=t.asm.U).apply(null,arguments)},wT=t._Less=function(){return(wT=t._Less=t.asm.V).apply(null,arguments)},ST=t._LessEqual=function(){return(ST=t._LessEqual=t.asm.W).apply(null,arguments)},jm=t._Log=function(){return(jm=t._Log=t.asm.X).apply(null,arguments)},Ng=t._LogicalAnd=function(){return(Ng=t._LogicalAnd=t.asm.Y).apply(null,arguments)},Dg=t._Max=function(){return(Dg=t._Max=t.asm.Z).apply(null,arguments)},_T=t._MaxPool=function(){return(_T=t._MaxPool=t.asm._).apply(null,arguments)},AT=t._Maximum=function(){return(AT=t._Maximum=t.asm.$).apply(null,arguments)},NT=t._Mean=function(){return(NT=t._Mean=t.asm.aa).apply(null,arguments)},DT=t._Min=function(){return(DT=t._Min=t.asm.ba).apply(null,arguments)},PT=t._Minimum=function(){return(PT=t._Minimum=t.asm.ca).apply(null,arguments)},FT=t._MirrorPad=function(){return(FT=t._MirrorPad=t.asm.da).apply(null,arguments)},MT=t._Multiply=function(){return(MT=t._Multiply=t.asm.ea).apply(null,arguments)},vt=t._Neg=function(){return(vt=t._Neg=t.asm.fa).apply(null,arguments)},ET=t._NonMaxSuppressionV3=function(){return(ET=t._NonMaxSuppressionV3=t.asm.ga).apply(null,arguments)},RT=t._NonMaxSuppressionV4=function(){return(RT=t._NonMaxSuppressionV4=t.asm.ha).apply(null,arguments)},LT=t._NonMaxSuppressionV5=function(){return(LT=t._NonMaxSuppressionV5=t.asm.ia).apply(null,arguments)},$p=t._NotEqual=function(){return($p=t._NotEqual=t.asm.ja).apply(null,arguments)},Pg=t._OneHot=function(){return(Pg=t._OneHot=t.asm.ka).apply(null,arguments)},Fg=t._PadV2=function(){return(Fg=t._PadV2=t.asm.la).apply(null,arguments)},Mg=t._Pow=function(){return(Mg=t._Pow=t.asm.ma).apply(null,arguments)},$T=t._Prelu=function(){return($T=t._Prelu=t.asm.na).apply(null,arguments)},BT=t._Prod=function(){return(BT=t._Prod=t.asm.oa).apply(null,arguments)},Eg=t._RealDiv=function(){return(Eg=t._RealDiv=t.asm.pa).apply(null,arguments)},OT=t._Relu=function(){return(OT=t._Relu=t.asm.qa).apply(null,arguments)},zT=t._Relu6=function(){return(zT=t._Relu6=t.asm.ra).apply(null,arguments)},GT=t._ResizeBilinear=function(){return(GT=t._ResizeBilinear=t.asm.sa).apply(null,arguments)},WT=t._Reverse=function(){return(WT=t._Reverse=t.asm.ta).apply(null,arguments)},UT=t._RotateWithOffset=function(){return(UT=t._RotateWithOffset=t.asm.ua).apply(null,arguments)},Rg=t._Round=function(){return(Rg=t._Round=t.asm.va).apply(null,arguments)},vu=t._Rsqrt=function(){return(vu=t._Rsqrt=t.asm.wa).apply(null,arguments)},KT=t._ScatterNd=function(){return(KT=t._ScatterNd=t.asm.xa).apply(null,arguments)},VT=t._SelectV2=function(){return(VT=t._SelectV2=t.asm.ya).apply(null,arguments)},kN=t._Sigmoid=function(){return(kN=t._Sigmoid=t.asm.za).apply(null,arguments)},Lg=t._Sin=function(){return(Lg=t._Sin=t.asm.Aa).apply(null,arguments)},jT=t._Softmax=function(){return(jT=t._Softmax=t.asm.Ba).apply(null,arguments)},HT=t._Sqrt=function(){return(HT=t._Sqrt=t.asm.Ca).apply(null,arguments)},qT=t._Square=function(){return(qT=t._Square=t.asm.Da).apply(null,arguments)},XT=t._SquaredDifference=function(){return(XT=t._SquaredDifference=t.asm.Ea).apply(null,arguments)},YT=t._Step=function(){return(YT=t._Step=t.asm.Fa).apply(null,arguments)},QT=t._StridedSlice=function(){return(QT=t._StridedSlice=t.asm.Ga).apply(null,arguments)},ZT=t._Sub=function(){return(ZT=t._Sub=t.asm.Ha).apply(null,arguments)},JT=t._Sum=function(){return(JT=t._Sum=t.asm.Ia).apply(null,arguments)},ek=t._Tan=function(){return(ek=t._Tan=t.asm.Ja).apply(null,arguments)},tk=t._Tanh=function(){return(tk=t._Tanh=t.asm.Ka).apply(null,arguments)},rk=t._Tile=function(){return(rk=t._Tile=t.asm.La).apply(null,arguments)},nk=t._TopK=function(){return(nk=t._TopK=t.asm.Ma).apply(null,arguments)},ok=t._Transform=function(){return(ok=t._Transform=t.asm.Na).apply(null,arguments)},sk=t._Transpose=function(){return(sk=t._Transpose=t.asm.Oa).apply(null,arguments)},ak=t.__FusedMatMul=function(){return(ak=t.__FusedMatMul=t.asm.Pa).apply(null,arguments)},ik=t._malloc=function(){return(ik=t._malloc=t.asm.Qa).apply(null,arguments)},uk=t._free=function(){return(uk=t._free=t.asm.Ra).apply(null,arguments)},$g=t.stackSave=function(){return($g=t.stackSave=t.asm.Ta).apply(null,arguments)},Bg=t.stackRestore=function(){return(Bg=t.stackRestore=t.asm.Ua).apply(null,arguments)},Hm=t.stackAlloc=function(){return(Hm=t.stackAlloc=t.asm.Va).apply(null,arguments)};t.cwrap=H;var Bp;function lk(Z){this.name="ExitStatus",this.message="Program terminated with exit("+Z+")",this.status=Z}zn=function Z(){Bp||qm(),Bp||(zn=Z)};function qm(Z){if(Z=Z||i,br>0||(In(),br>0))return;function se(){Bp||(Bp=!0,t.calledRun=!0,!W&&(zr(),Vs(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),rn()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),se()},1)):se()}if(t.run=qm,t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return qm(),e.ready}}();typeof Ux=="object"&&typeof bN=="object"?bN.exports=gN:typeof define=="function"&&define.amd?define([],function(){return gN}):typeof Ux=="object"&&(Ux.WasmBackendModule=gN)});var yj=1e-7,xj=1e-4,Oa=class{constructor(e,t){this.backend=e;this.dataMover=t;this.data=new WeakMap;this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},os=class{refCount(e){return ss("refCount")}incRef(e){return ss("incRef")}timerAvailable(){return!0}time(e){return ss("time")}read(e){return ss("read")}readSync(e){return ss("readSync")}numDataIds(){return ss("numDataIds")}disposeData(e,t){return ss("disposeData")}write(e,t,n){return ss("write")}move(e,t,n,o,s){return ss("move")}memory(){return ss("memory")}floatPrecision(){return ss("floatPrecision")}epsilon(){return this.floatPrecision()===32?yj:xj}dispose(){return ss("dispose")}};function ss(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function RN(r){let e=r.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Kg(r,e,t)}function Tj(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Kg(r,t,n),Kg(e,t,n)}function Kp(r,e,t){return Math.max(r,Math.min(e,t))}function kj(r){return r%2==0?r:r+1}function Kg(r,e,t){let n=r[e];r[e]=r[t],r[t]=n}function Ij(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function Cj(r,e){let t=Math.random();return e*t+(1-t)*r}function vj(r,e){let t=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(e[n]);t+=o*o}return t}function D(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Wt(r,e,t=""){D(on(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function to(r){D(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Hs(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||kr(r)&&!t)for(let n=0;n<r.length;++n)Hs(r[n],e,t);else e.push(r);return e}function ct(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function wj(r){return r.length===0}function on(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function mt(r){return r%1==0}function Sj(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let e=Math.exp(2*r);return(e-1)/(e+1)}}function _j(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function Aj(r){let e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return RN(e),e}function kl(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function Nj(r,e=n=>0,t){return new Promise((n,o)=>{let s=0,a=()=>{if(r()){n();return}s++;let i=e(s);if(t!=null&&s>=t){o();return}setTimeout(a,i)};a()})}function Dj(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=r.slice();return o[n]=e/t,o}function yr(r,e){let t=e.length;return r=r==null?e.map((n,o)=>o):[].concat(r),D(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),D(r.every(n=>mt(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function fk(r,e){let t=[],n=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:yr(e,r).sort(),a=0;for(let i=0;i<r.length;++i){if(s!=null){if(s[a]===i&&r[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${r[i]}' is not 1`);(s[a]==null||s[a]>i)&&r[i]===1&&(t.push(r[i]),n.push(i)),s[a]<=i&&a++}r[i]!==1&&(t.push(r[i]),n.push(i))}return{newShape:t,keptDims:n}}function dk(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function hk(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function gk(r,e){for(let t=0;t<r.length;t++){let n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function bk(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function Pj(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function kr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function Vg(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function yk(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function qs(r){return typeof r=="string"||r instanceof String}function LN(r){return typeof r=="boolean"}function $N(r){return typeof r=="number"}function Vp(r){return Array.isArray(r)?Vp(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":$N(r)?"float32":qs(r)?"string":LN(r)?"bool":"float32"}function za(r){return!!(r&&r.constructor&&r.call&&r.apply)}function jp(r,e){for(let t=e;t<r;++t)if(r%t==0)return t;return r}function Ga(r){let e=r.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function BN(r,e,t,n=!1){let o=new Array;if(e.length===1){let s=e[0]*(n?2:1);for(let a=0;a<s;a++)o[a]=t[r+a]}else{let s=e[0],a=e.slice(1),i=a.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=BN(r+u*i,a,t,n)}return o}function Il(r,e,t=!1){if(r.length===0)return e[0];let n=r.reduce((o,s)=>o*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return BN(0,r,e,t)}function Jm(r,e){let t=Hp(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function Hp(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function Fj(r,e){let t=r.reduce((n,o)=>n*o,1);if(e==null||e==="float32")return Il(r,new Float32Array(t));if(e==="int32")return Il(r,new Int32Array(t));if(e==="bool")return Il(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function ef(r){r.forEach(e=>{D(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function Mj(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=t[o]*r[o];return n}function Ej(r,e,t){if(e===0)return[];if(e===1)return[r];let n=new Array(e);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/t[o]),r-=n[o]*t[o];return n[n.length-1]=r,n}function tf(r){return r&&r.then&&typeof r.then=="function"}function ro(...r){U().getBool("IS_TEST")||U().getBool("PROD")||console.warn(...r)}function Rj(...r){U().getBool("IS_TEST")||U().getBool("PROD")||console.log(...r)}var ON="tfjsflags",jg=class{constructor(e){this.global=e;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=Lj;this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&ro(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let o=this.urlFlags[e];ro(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(tf(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);ON in e&&e[ON].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=Bj(o,s)})}};function Lj(r){let e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>($j(e,n[0],n[1]),n.join("="))),e}function $j(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function Bj(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function U(){return xk}var xk=null;function zN(r){xk=r}var Tk;function kk(){if(Tk==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");Tk=r}return Tk}function Oj(){let r=kk();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function rf(r,e){let t=Oj();if(t.has(r))return t.get(r);{let n=e();return t.set(r,n),t.get(r)}}var as="Abs",bi="Acos",yi="Acosh",_n="Add",no="AddN",xi="All",Ti="Any",oo="ArgMax",Wa="ArgMin",ki="Asin",Ii="Asinh",Ci="Atan",vi="Atanh",wi="Atan2",so="AvgPool",qp="AvgPoolGrad",Au="AvgPool3D",Xp="AvgPool3DGrad",ao="BatchMatMul",is="BatchToSpaceND",Yp="Bincount",GN="BroadcastTo",Qp="BroadcastArgs",Wn="Cast",io="Ceil",Un="ClipByValue",Nu="Complex",Du="ComplexAbs",us="Concat",uo="Conv2D",Zp="Conv2DBackpropFilter",lo="Conv2DBackpropInput",Pu="Conv3D",Jp="Conv3DBackpropFilterV2",ec="Conv3DBackpropInputV2",po="Cos",co="Cosh",Xs="Cumsum",Ys="CropAndResize",tc="DenseBincount",Qs="DepthToSpace",mo="DepthwiseConv2dNative",rc="DepthwiseConv2dNativeBackpropFilter",nc="DepthwiseConv2dNativeBackpropInput",oc="Diag",Fu="Dilation2D",nf="Dilation2DBackpropInput",of="Dilation2DBackpropFilter",fo="RealDiv",Mu="Einsum",ho="Elu",sc="EluGrad",Si="Erf",Zs="Equal",go="Exp",ls="ExpandDims",Js="Expm1",ac="FFT",Ua="Fill",ea="FlipLeftRight",bo="Floor",yo="FloorDiv",xo="FusedBatchNorm",ps="GatherV2",ta="GatherNd",ra="Greater",To="GreaterEqual",Kn="Identity",ic="IFFT",Eu="Imag",_i="IsFinite",Ai="IsInf",Ni="IsNan",na="LeakyRelu",oa="Less",sa="LessEqual",uc="LinSpace",ko="Log",Di="Log1p",aa="LogicalAnd",Pi="LogicalNot",Cl="LogicalOr",WN="LogSoftmax",Ru="LRN",lc="LRNGrad",Io="Max",Co="Maximum",vo="MaxPool",pc="MaxPoolGrad",Lu="MaxPool3D",cc="MaxPool3DGrad",mc="MaxPoolWithArgmax",wo="Mean",So="Min",_o="Minimum",Ao="MirrorPad",Fi="Mod",fc="Multinomial",No="Multiply",cs="Neg",ia="NotEqual",ua="NonMaxSuppressionV3",Mi="NonMaxSuppressionV4",la="NonMaxSuppressionV5",ms="OnesLike",pa="OneHot",fs="Pack",Do="PadV2",Xce="Pool",Po="Pow",Fo="Prelu",ca="Prod",Ka="Range",$u="Real",Ei="Reciprocal",Mo="Relu",ds="Reshape",Va="ResizeNearestNeighbor",dc="ResizeNearestNeighborGrad",Eo="ResizeBilinear",hc="ResizeBilinearGrad",Ro="Relu6",ma="Reverse",fa="Round",Lo="Rsqrt",da="ScatterNd",hs="Select",Ri="Selu",gs="Slice",$o="Sin",ha="Sinh",Li="Sign",Bo="Sigmoid",$i="Softplus",Oo="Sqrt",zo="Sum",bs="SpaceToBatchND",ys="SplitV",Go="Softmax",gc="SparseFillEmptyRows",bc="SparseReshape",yc="SparseSegmentMean",xc="SparseSegmentSum",Bu="SparseToDense",Wo="SquaredDifference",ja="Square",ga="StridedSlice",Ou="StringNGrams",Tc="StringSplit",kc="StringToHashBucketFast",Uo="Sub",ba="Tan",Ko="Tanh",An="Tile",Bi="TopK",ya="Transform",Vo="Transpose",Ic="Unique",xs="Unpack",zu="UnsortedSegmentSum",Ts="ZerosLike",ks="Step",vl="FromPixels",xa="RotateWithOffset",Is="_FusedMatMul",Cs="FusedConv2D",vs="FusedDepthwiseConv2D";var Cc=rf("kernelRegistry",()=>new Map),sf=rf("gradRegistry",()=>new Map);function af(r,e){let t=Ck(r,e);return Cc.get(t)}function Ik(r){return sf.get(r)}function Hg(r){let e=Cc.entries(),t=[];for(;;){let{done:n,value:o}=e.next();if(n)break;let[s,a]=o,[i]=s.split("_");i===r&&t.push(a)}return t}function Oi(r){let{kernelName:e,backendName:t}=r,n=Ck(e,t);Cc.has(n)&&ro(`The kernel '${e}' for backend '${t}' is already registered`),Cc.set(n,r)}function UN(r){let{kernelName:e}=r;sf.has(e)&&U().getBool("DEBUG")&&ro(`Overriding the gradient for '${e}'`),sf.set(e,r)}function eme(r,e){let t=Ck(r,e);if(!Cc.has(t))throw new Error(`The kernel '${r}' for backend '${e}' is not registered`);Cc.delete(t)}function tme(r){if(!sf.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);sf.delete(r)}function rme(r,e){Hg(r).forEach(n=>{let o=Object.assign({},n,{backendName:e});Oi(o)})}function Ck(r,e){return`${e}_${r}`}var b={};Qe(b,{arraysEqual:()=>on,assert:()=>D,assertNonNegativeIntegerDimensions:()=>ef,assertNonNull:()=>to,assertShapesMatch:()=>Wt,bytesFromStringArray:()=>yk,bytesPerElement:()=>Vg,checkConversionForErrors:()=>gk,clamp:()=>Kp,computeStrides:()=>Ga,createScalarValue:()=>jj,createShuffledIndices:()=>Aj,decodeString:()=>_c,distSquared:()=>vj,encodeString:()=>Wu,fetch:()=>qj,fingerPrint64:()=>Vj,flatten:()=>Hs,getArrayFromDType:()=>hk,getTypedArrayFromDType:()=>dk,hasEncodingLoss:()=>Pj,hexToLong:()=>uf,indexToLoc:()=>Ej,inferDtype:()=>Vp,inferFromImplicitShape:()=>Dj,isBoolean:()=>LN,isFunction:()=>za,isInt:()=>mt,isNumber:()=>$N,isPromise:()=>tf,isScalarShape:()=>wj,isString:()=>qs,isTypedArray:()=>kr,isValidDtype:()=>bk,locToIndex:()=>Mj,makeOnesTypedArray:()=>Jm,makeZerosNestedTypedArray:()=>Fj,makeZerosTypedArray:()=>Hp,nearestDivisor:()=>jp,nearestLargerEven:()=>kj,now:()=>Nl,parseAxisParam:()=>yr,randUniform:()=>Cj,repeatedTry:()=>Nj,rightPad:()=>kl,shuffle:()=>RN,shuffleCombo:()=>Tj,sizeFromShape:()=>ct,sizeToSquarishShape:()=>_j,squeezeShape:()=>fk,sum:()=>Ij,swap:()=>Kg,tanh:()=>Sj,toNestedArray:()=>Il,toTypedArray:()=>Sc});var tD=Tl(eD());var _l=tD.default||tD;function uf(r){return _l.fromString(r,!0,16)}var rD=uf("c3a5c85c97cb3127"),Al=uf("b492b66fbe98f273"),sn=uf("9ae16a3b2f90404f");function Sk(r){return r.xor(r.shru(47))}function nD(r,e,t){let n=r.slice(e,e+t);return _l.fromBytes(Array.from(n),!0,!0)}function qt(r,e){return nD(r,e,8)}function oD(r,e){return nD(r,e,4)}function Mr(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function Gu(r,e,t=uf("9ddfea08eb382d69")){let n=r.xor(e).mul(t);n=n.xor(n.shru(47));let o=e.xor(n).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function Gj(r,e,t,n,o,s){o=o.add(r),s=Mr(s.add(o).add(n),21);let a=o;return o=o.add(e),o=o.add(t),s=s.add(Mr(o,44)),[o.add(n),s.add(a)]}function Xg(r,e,t,n){return Gj(qt(r,e),qt(r,e+8),qt(r,e+16),qt(r,e+24),t,n)}function Wj(r,e=r.length){if(e>=8){let t=sn.add(e*2),n=qt(r,0).add(sn),o=qt(r,e-8),s=Mr(o,37).mul(t).add(n),a=Mr(n,25).add(o).mul(t);return Gu(s,a,t)}if(e>=4){let t=sn.add(e*2),n=oD(r,0);return Gu(n.shl(3).add(e),oD(r,e-4),t)}if(e>0){let t=r[0],n=r[e>>1],o=r[e-1],s=t+(n<<8),a=e+(o<<2);return Sk(sn.mul(s).xor(rD.mul(a))).mul(sn)}return sn}function Uj(r,e=r.length){let t=sn.add(e*2),n=qt(r,0).mul(Al),o=qt(r,8),s=qt(r,e-8).mul(t),a=qt(r,e-16).mul(sn);return Gu(Mr(n.add(o),43).add(Mr(s,30)).add(a),n.add(Mr(o.add(sn),18)).add(s),t)}function Kj(r,e=r.length){let t=sn.add(e*2),n=qt(r,0).mul(sn),o=qt(r,8),s=qt(r,e-8).mul(t),a=qt(r,e-16).mul(sn),i=Mr(n.add(o),43).add(Mr(s,30)).add(a),u=Gu(i,n.add(Mr(o.add(sn),18)).add(s),t),l=qt(r,16).mul(t),p=qt(r,24),c=i.add(qt(r,e-32)).mul(t),m=u.add(qt(r,e-24)).mul(t);return Gu(Mr(l.add(p),43).add(Mr(c,30)).add(m),l.add(Mr(p.add(n),18)).add(c),t)}function Vj(r,e=r.length){let t=_l.fromNumber(81,!0);if(e<=32)return e<=16?Wj(r,e):Uj(r,e);if(e<=64)return Kj(r,e);let n=t,o=t.mul(Al).add(113),s=Sk(o.mul(sn).add(113)).mul(sn),a=[_l.UZERO,_l.UZERO],i=[_l.UZERO,_l.UZERO];n=n.mul(sn).add(qt(r,0));let u=0,l=(e-1>>6)*64,p=l+(e-1&63)-63;do n=Mr(n.add(o).add(a[0]).add(qt(r,u+8)),37).mul(Al),o=Mr(o.add(a[1]).add(qt(r,u+48)),42).mul(Al),n=n.xor(i[1]),o=o.add(a[0]).add(qt(r,u+40)),s=Mr(s.add(i[0]),33).mul(Al),a=Xg(r,u,a[1].mul(Al),n.add(i[0])),i=Xg(r,u+32,s.add(i[1]),o.add(qt(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let c=Al.add(s.and(255).shl(1));return u=p,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),n=Mr(n.add(o).add(a[0]).add(qt(r,u+8)),37).mul(c),o=Mr(o.add(a[1]).add(qt(r,u+48)),42).mul(c),n=n.xor(i[1].mul(9)),o=o.add(a[0].mul(9).add(qt(r,u+40))),s=Mr(s.add(i[0]),33).mul(c),a=Xg(r,u,a[1].mul(c),n.add(i[0])),i=Xg(r,u+32,s.add(i[1]),o.add(qt(r,u+16))),[s,n]=[n,s],Gu(Gu(a[0],i[0],c).add(Sk(o).mul(rD)).add(s),Gu(a[1],i[1],c).add(n),c)}function jj(r,e){return e==="string"?Wu(r):Sc([r],e)}function Hj(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Sc(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Hs(r)),U().getBool("DEBUG")&&gk(r,e),Hj(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){let t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Nl(){return U().platform.now()}function qj(r,e){return U().platform.fetch(r,e)}function Wu(r,e="utf-8"){return e=e||"utf-8",U().platform.encode(r,e)}function _c(r,e="utf-8"){return e=e||"utf-8",U().platform.decode(r,e)}var _k=class{constructor(e,t){this.backendTimer=e;this.logger=t;t==null&&(this.logger=new sD)}profileKernel(e,t,n){let o,s=()=>{o=n()},a,i=Nl();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();a=Promise.resolve({kernelMs:Nl()-i})}if(U().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let p=o[l];p.data().then(c=>{Xj(c,p.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:o,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),o,a]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],s,u[2])})})}};function Xj(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var sD=class{logKernelProfile(e,t,n,o,s,a){let i=typeof o=="number"?kl(`${o}ms`,9):o.error,u=kl(e,25),l=t.rank,p=t.size,c=kl(t.shape.toString(),14),m="";for(let f in s){let d=s[f];if(d!=null){let h=d.shape||t.shape,g=h.length;m+=`${f}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${c}	%c${p}	%c${m}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function aD(r,e,t){let n={},o={};for(let u=0;u<e.length;u++)n[e[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],p=l.inputs;for(let c in p){let m=p[c],f=!1;for(let d=0;d<e.length;d++)if(n[m.id]){l.outputs.forEach(h=>n[h.id]=!0),f=!0,o[l.id]=!0;break}if(f)break}}let s={};s[t.id]=!0;let a={};for(let u=r.length-1;u>=0;u--){let l=r[u],p=l.inputs;for(let c=0;c<l.outputs.length;c++)if(s[l.outputs[c].id]){for(let m in p)s[p[m].id]=!0,a[l.id]=!0;break}}let i=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&a[l.id]){let p={};for(let m in l.inputs){let f=l.inputs[m];n[f.id]&&(p[m]=f)}let c=Object.assign({},l);c.inputs=p,c.outputs=l.outputs,i.push(c)}}return i}function iD(r,e,t,n){for(let o=e.length-1;o>=0;o--){let s=e[o],a=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?a.push(l):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let i=s.gradient(a);for(let u in s.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);let l=t(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let p=s.inputs[u];if(!on(l.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${p.shape}'`);if(r[p.id]==null)r[p.id]=l;else{let c=r[p.id];r[p.id]=n(c,l),c.dispose()}}}}var uD=20,lf=3,Ak=7;function lD(r,e,t,n){let o=Ga(e),s=Yj(r,e,t,o),a=e.length,i=Yg(r,e,t,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function Yj(r,e,t,n){let o=ct(e),s=n[n.length-1],a=new Array(s).fill(0),i=e.length,u=t==="complex64"?cf(r):r;if(i>1)for(let l=0;l<o/s;l++){let p=l*s;for(let c=0;c<s;c++)a[c]=Math.max(a[c],pf(u[p+c],0,t).length)}return a}function pf(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(Ak))} + ${parseFloat(r[1].toFixed(Ak))}j`:qs(r)?n=`'${r}'`:t==="bool"?n=pD(r):n=parseFloat(r.toFixed(Ak)).toString(),kl(n,e)}function pD(r){return r===0?"false":"true"}function Yg(r,e,t,n,o,s=!0){let a=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){let h=cf(r);return[pf(h[0],0,t)]}return t==="bool"?[pD(r[0])]:[r[0].toString()]}if(u===1){if(i>uD){let g=lf*a,y=Array.from(r.slice(0,g)),x=Array.from(r.slice((i-lf)*a,i*a));return t==="complex64"&&(y=cf(y),x=cf(x)),["["+y.map((T,k)=>pf(T,o[k],t)).join(", ")+", ..., "+x.map((T,k)=>pf(T,o[i-lf+k],t)).join(", ")+"]"]}let h=t==="complex64"?cf(r):Array.from(r);return["["+h.map((g,y)=>pf(g,o[y],t)).join(", ")+"]"]}let l=e.slice(1),p=n.slice(1),c=n[0]*a,m=[];if(i>uD){for(let h=0;h<lf;h++){let g=h*c,y=g+c;m.push(...Yg(r.slice(g,y),l,t,p,o,!1))}m.push("...");for(let h=i-lf;h<i;h++){let g=h*c,y=g+c;m.push(...Yg(r.slice(g,y),l,t,p,o,h===i-1))}}else for(let h=0;h<i;h++){let g=h*c,y=g+c;m.push(...Yg(r.slice(g,y),l,t,p,o,h===i-1))}let f=u===2?",":"";m[0]="["+m[0]+f;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+f;let d=`,
`;for(let h=2;h<u;h++)d+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":d),m}function cf(r){let e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}var xt=class{constructor(e,t,n){this.dtype=t;if(this.shape=e.slice(),this.size=ct(e),n!=null){let o=n.length;D(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||hk(t,this.size),this.strides=Ga(e)}set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let o=0;o<e.length-1;++o)n+=this.strides[o]*e[o];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ha().makeTensor(this.values,this.shape,this.dtype)}},Ha=null,Ac=null,Qj=null;function cD(r){Ha=r}function mD(r){Ac=r}function fD(r){Qj=r}var Ye=class{constructor(e,t,n,o){this.kept=!1;this.isDisposedInternal=!1;this.shape=e.slice(),this.dtype=t||"float32",this.size=ct(e),this.strides=Ga(e),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Ac.buffer(this.shape,this.dtype,e)}bufferSync(){return Ac.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Il(this.shape,e,this.dtype==="complex64")}arraySync(){return Il(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Ha().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>_c(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();let e=Ha().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>_c(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Ha().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ha().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ac.print(this,e)}clone(){return this.throwIfDisposed(),Ac.clone(this)}toString(e=!1){let t=this.dataSync();return lD(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ac.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ha().makeVariable(this,e,t,n)}};Object.defineProperty(Ye,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function Zj(){return rf("Tensor",()=>Ye)}Zj();var Uu=class extends Ye{constructor(e,t,n,o){super(e.shape,e.dtype,e.dataId,o);this.trainable=t;this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!on(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ha().disposeTensor(this),this.dataId=e.dataId,Ha().incRef(this,null)}dispose(){Ha().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Uu,Symbol.hasInstance,{value:r=>r instanceof Ye&&r.assign!=null&&r.assign instanceof Function});var As={};Qe(As,{assertTypesMatch:()=>Ek,getTensorsInContainer:()=>mf,isTensorInList:()=>eH,makeTypesMatch:()=>Ze});var Nk;(function(i){i.R0="R0",i.R1="R1",i.R2="R2",i.R3="R3",i.R4="R4",i.R5="R5",i.R6="R6"})(Nk||(Nk={}));var Dk;(function(o){o.float32="float32",o.int32="int32",o.bool="int32",o.complex64="complex64"})(Dk||(Dk={}));var Pk;(function(o){o.float32="float32",o.int32="int32",o.bool="bool",o.complex64="complex64"})(Pk||(Pk={}));var Fk;(function(o){o.float32="float32",o.int32="float32",o.bool="float32",o.complex64="complex64"})(Fk||(Fk={}));var Mk;(function(o){o.float32="complex64",o.int32="complex64",o.bool="complex64",o.complex64="complex64"})(Mk||(Mk={}));var Jj={float32:Fk,int32:Dk,bool:Pk,complex64:Mk};function Ut(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return Jj[r][e]}function zi(r){return Ut(r,"int32")}function Ze(r,e){if(r.dtype===e.dtype)return[r,e];let t=Ut(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function Ek(r,e){D(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function eH(r,e){return e.some(t=>t.id===r.id)}function mf(r){let e=[],t=new Set;return dD(r,e,t),e}function dD(r,e,t){if(r==null)return;if(r instanceof Ye){e.push(r);return}if(!tH(r))return;let n=r;for(let o in n){let s=n[o];t.has(s)||(t.add(s),dD(s,e,t))}}function tH(r){return Array.isArray(r)||typeof r=="object"}function Rk(r){return r.kernelName!=null}var Lk=class{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=!1;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},Zg=class{constructor(e){this.ENV=e;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new Lk}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ro(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new _k(this.backendInstance),!0}setupRegisteredKernels(){Hg(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Hg(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof os)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(a=>o<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,ro(`Initialization of backend ${e} failed`),ro(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return ro(`Initialization of backend ${e} failed`),ro(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),o=n.backend,s=this.readSync(t),a=o.refCount(t);o.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=t(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,t,n){e();try{let o=n();return t(),o}catch(o){throw t(),o}}nextTensorId(){return Zg.nextTensorId++}nextVariableId(){return Zg.nextVariableId++}clone(e){let t=N.runKernel(Kn,{x:e}),n={x:e},o=a=>({x:()=>{let i="float32",u={x:a},l={dtype:i};return N.runKernel(Wn,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],o,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(af(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=o-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],o=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u,l=Rk(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Rk(e)){let{kernelName:d,inputs:h,attrs:g}=e;this.backendName==null&&this.backend;let y=af(d,this.backendName);D(y!=null,()=>`Cannot find registered kernel '${d}' for backend '${this.backendName}'`),i=()=>{let x=this.backend.numDataIds();u=y.kernelFunc({inputs:h,attrs:g,backend:this.backend});let T=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,x,T);let k=T.map(w=>{if(w.rank!=null)return w;let{dataId:P,shape:A,dtype:F}=w;return this.makeTensorFromDataId(P,A,F)});if(o){let w=this.getTensorsForGradient(d,h,k);n=this.saveTensorsForBackwardMode(w)}return k}}else{let{forwardFunc:d}=e,h=g=>{!o||(n=g.map(y=>this.keep(this.clone(y))))};i=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>d(this.backend,h));let y=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,y),y}}let{inputs:p,attrs:c}=e,m=Rk(e)?null:e.backwardsFunc,f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(f=this.profiler.profileKernel(l,p,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),o&&this.addTapeNode(l,p,t,m,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(d=>p[d]!=null?p[d].shape:null),outputShapes:t.map(d=>d.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let o=Ik(e);if(o!=null){let s=o.inputsToSave||[],a=o.outputsToSave||[],i;o.saveAllInputs?(D(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=s.map(l=>t[l]);let u=n.filter((l,p)=>a[p]);return i.concat(u)}return[]}makeTensor(e,t,n,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=e;n==="string"&&qs(e[0])&&(s=e.map(u=>Wu(u)));let a=o.write(s,t,n),i=new Ye(t,n,a,this.nextTensorId());if(this.trackTensor(i,o),n==="string"){let u=this.state.tensorInfo.get(a),l=yk(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,t,n,o){n=n||"float32";let s=new Ye(t,n,e,this.nextTensorId());return this.trackTensor(s,o),s}makeVariable(e,t=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));let s=new Uu(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*Vg(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Uu||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*Vg(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,o,s,a){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},u=Ik(e);u!=null&&(o=u.gradFunc),o!=null&&(i.gradient=l=>(l=l.map((p,c)=>{if(p==null){let m=n[c],f=Hp(m.size,m.dtype);return this.makeTensor(f,m.shape,m.dtype)}return p}),o(l.length>1?l:l[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=mf(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(e,t,n,o=!1){if(D(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(s instanceof Ye,()=>"The result y returned by f() must be a tensor.");let a=aD(this.state.activeTape,t,s);if(!o&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[s.id]=n??rH(s.shape),iD(i,a,l=>this.tidy(l),nH);let u=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let p of l.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(e){return D(za(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{D(t.every(i=>i instanceof Ye),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};t.forEach((i,u)=>{o[u]=i});let s=(i,u)=>(n=e(...t,u),D(n.value instanceof Ye,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(za(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(i,u)=>{let l=n.gradFunc(i,u),p=Array.isArray(l)?l:[l];D(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(p.every(m=>m instanceof Ye),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let c={};return p.forEach((m,f)=>{c[f]=()=>m}),c};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){let t=Nl(),n=await this.backend.time(e);return n.wallMs=Nl()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Lk;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},Qg=Zg;Qg.nextTensorId=0,Qg.nextVariableId=0;function rH(r){let e=Jm(ct(r),"float32");return N.makeTensor(e,r,"float32")}function $k(){let r=kk();if(r._tfengine==null){let e=new jg(r);r._tfengine=new Qg(e)}return zN(r._tfengine.ENV),cD(()=>r._tfengine),r._tfengine}var N=$k();function nH(r,e){let t={a:r,b:e};return N.runKernel(_n,t)}var Gi={};Qe(Gi,{isBrowser:()=>Ok,isMobile:()=>aH,mockIsMobile:()=>sH});function oH(){return typeof navigator!="undefined"&&navigator!=null}var Bk;function sH(r){Bk=r}function aH(r){if(Bk!==void 0)return Bk;if(r||oH()){if(r||(r=navigator),r.product==="ReactNative")return!0;let e=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!e){let t=r;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function Ok(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var ka=U();ka.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ka.registerFlag("IS_BROWSER",()=>Ok());ka.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");ka.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ka.registerFlag("PROD",()=>!1);ka.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ka.getBool("DEBUG"));ka.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ka.registerFlag("IS_TEST",()=>!1);ka.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ka.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);function Wr(r,e){let t=r;if(kr(r))return e==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(t)||kr(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&U().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&hD(r,n,[]),n}function hD(r,e,t){if(t=t||[],!Array.isArray(r)&&!kr(r)){D(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}D(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),D(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);let n=e.slice(1);for(let o=0;o<r.length;++o)hD(r[o],n,t.concat(o))}function gD(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function C(r,e,t,n="numeric"){if(r instanceof Ye)return gD(n,r.dtype,e,t),r;let o=Vp(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),gD(n,o,e,t),r==null||!kr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Wr(r,o);!kr(r)&&!Array.isArray(r)&&(r=[r]);let i=o!=="string"?Sc(r,o):Hs(r,[],!0);return N.makeTensor(i,s,o)}function Wi(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,a)=>C(s,`${e}[${a}]`,t,n))}var bD="__op";function _(r){let e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+bD;let o=(...s)=>{N.startScope(t);try{let a=n(...s);return tf(a)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(a),a}catch(a){throw N.endScope(null),a}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}function iH(r,e){let t=C(r,"real","complex"),n=C(e,"imag","complex");Wt(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:t,imag:n};return N.runKernel(Nu,o)}var Hn=_({complex_:iH});function an(r,e,t,n){if(n==null&&(n=Vp(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!kr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){ef(e);let o=ct(e),s=ct(t);D(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let a=0;a<t.length;++a){let i=t[a],u=a===t.length-1?i!==ct(e.slice(a)):!0;D(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!kr(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Sc(r,n):Hs(r,[],!0),N.makeTensor(r,e,n)}function Er(r,e,t){let n=Wr(r,t);return an(r,e,n,t)}var ff={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Jg=4;async function yD(r,e){let t=[],n=[],o=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<o.length;++a){let i=o[a],u=Array.isArray(r)?r[a].tensor:r[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);let l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let p=new Promise(async c=>{let m=await u.bytes(),f=m.reduce((g,y)=>g+y.length,0)+Jg*m.length,d=new Uint8Array(f),h=0;for(let g=0;g<m.length;g++){let y=m[g],x=new Uint8Array(new Uint32Array([y.length]).buffer);d.set(x,h),h+=Jg,d.set(y,h),h+=y.length}c(d)});n.push(p)}else n.push(u.data());e!=null&&(l.group=e),t.push(l)}let s=await Promise.all(n);return{data:uH(s),specs:t}}function eb(r,e){let t={},n,o=0;for(let s of e){let a=s.name,i=s.dtype,u=s.shape,l=ct(u),p;if("quantization"in s){let c=s.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${s.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${s.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=ff[c.dtype],f=r.slice(o,o+l*m),d=c.dtype==="uint8"?new Uint8Array(f):new Uint16Array(f);if(i==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){p=new Float32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];p[h]=g*c.scale+c.min}}else if(c.dtype==="float16")n===void 0&&(n=mH()),p=n(d);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(i==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);p=new Int32Array(d.length);for(let h=0;h<d.length;h++){let g=d[h];p[h]=Math.round(g*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=l*m}else if(i==="string"){let c=ct(s.shape);p=[];for(let m=0;m<c;m++){let f=new Uint32Array(r.slice(o,o+Jg))[0];o+=Jg;let d=new Uint8Array(r.slice(o,o+f));p.push(d),o+=f}}else{let c=ff[i],m=r.slice(o,o+l*c);if(i==="float32")p=new Float32Array(m);else if(i==="int32")p=new Int32Array(m);else if(i==="bool")p=new Uint8Array(m);else if(i==="complex64"){p=new Float32Array(m);let f=new Float32Array(p.length/2),d=new Float32Array(p.length/2);for(let y=0;y<f.length;y++)f[y]=p[y*2],d[y]=p[y*2+1];let h=Er(f,u,"float32"),g=Er(d,u,"float32");t[a]=Hn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=l*c}i!=="complex64"&&(t[a]=Er(p,u,i))}return t}function uH(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0,t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(e),o=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var zk=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function xD(r){return zk?Buffer.byteLength(r):new Blob([r]).size}function TD(r){if(zk)return Buffer.from(r).toString("base64");let e=new Uint8Array(r),t="";for(let n=0,o=e.length;n<o;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function kD(r){if(zk){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function Nc(r){if(r.length===1)return r[0];let e=0;r.forEach(o=>{e+=o.byteLength});let t=new Uint8Array(e),n=0;return r.forEach(o=>{t.set(new Uint8Array(o),n),n+=o.byteLength}),t.buffer}function Gk(r){let e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);let t=r.split(e);return t[t.length-1]}function tb(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}async function Dc(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await e(r.weightsManifest);t.weightSpecs=n,t.weightData=o}return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),t}function qa(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:xD(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:xD(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function lH(){let r=t=>{let n=t<<13,o=0;for(;(n&8388608)==0;)o-=8388608,n<<=1;return n&=~8388608,o+=947912704,n|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function pH(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function cH(){let r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function mH(){let r=lH(),e=pH(),t=cH();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let a=0;a<n.length;a++){let i=n[a],u=r[t[i>>10]+(i&1023)]+e[i>>10];s[a]=u}return new Float32Array(o)}}var Et=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Et.instance==null&&(Et.instance=new Et),Et.instance}static registerSaveRouter(e){Et.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Et.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Et.getHandlers(e,"save")}static getLoadHandlers(e,t){return Et.getHandlers(e,"load",t)}static getHandlers(e,t,n){let o=[];return(t==="load"?Et.getInstance().loadRouters:Et.getInstance().saveRouters).forEach(a=>{let i=a(e,n);i!==null&&o.push(i)}),o}},ID=r=>Et.registerSaveRouter(r),CD=r=>Et.registerLoadRouter(r),vD=r=>Et.getSaveHandlers(r),wD=(r,e)=>Et.getLoadHandlers(r,e);var Wk="tensorflowjs",Uk=1,Dl="models_store",Ku="model_info_store";function SD(){if(!U().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Kk(r){let e=r.result;e.createObjectStore(Dl,{keyPath:"modelPath"}),e.createObjectStore(Ku,{keyPath:"modelPath"})}var Ui=class{constructor(e){if(this.indexedDB=SD(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,o)=>{let s=this.indexedDB.open(Wk,Uk);s.onupgradeneeded=()=>Kk(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(Dl,"readonly"),l=i.objectStore(Dl).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=p=>(a.close(),o(l.error)),i.oncomplete=()=>a.close()}else{let i=qa(t),u=a.transaction(Ku,"readwrite"),l=u.objectStore(Ku),p=l.put({modelPath:this.modelPath,modelArtifactsInfo:i}),c;p.onsuccess=()=>{c=a.transaction(Dl,"readwrite");let f=c.objectStore(Dl).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});f.onsuccess=()=>n({modelArtifactsInfo:i}),f.onerror=d=>{l=u.objectStore(Ku);let h=l.delete(this.modelPath);h.onsuccess=()=>(a.close(),o(f.error)),h.onerror=g=>(a.close(),o(f.error))}},p.onerror=m=>(a.close(),o(p.error)),u.oncomplete=()=>{c==null?a.close():c.oncomplete=()=>a.close()}}},s.onerror=a=>o(s.error)})}};Ui.URL_SCHEME="indexeddb://";var _D=r=>U().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ui.URL_SCHEME)?fH(r.slice(Ui.URL_SCHEME.length)):null;Et.registerSaveRouter(_D);Et.registerLoadRouter(_D);function fH(r){return new Ui(r)}function dH(r){return r.startsWith(Ui.URL_SCHEME)?r.slice(Ui.URL_SCHEME.length):r}var Vk=class{constructor(){this.indexedDB=SD()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Wk,Uk);n.onupgradeneeded=()=>Kk(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Ku,"readonly"),i=s.objectStore(Ku).getAll();i.onsuccess=()=>{let u={};for(let l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(o.close(),t(i.error)),s.oncomplete=()=>o.close()},n.onerror=o=>t(n.error)})}async removeModel(e){return e=dH(e),new Promise((t,n)=>{let o=this.indexedDB.open(Wk,Uk);o.onupgradeneeded=()=>Kk(o),o.onsuccess=()=>{let s=o.result,a=s.transaction(Ku,"readwrite"),i=a.objectStore(Ku),u=i.get(e),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let p=i.delete(e),c=()=>{l=s.transaction(Dl,"readwrite");let f=l.objectStore(Dl).delete(e);f.onsuccess=()=>t(u.result.modelArtifactsInfo),f.onerror=d=>n(u.error)};p.onsuccess=c,p.onerror=m=>(c(),s.close(),n(u.error))}},u.onerror=p=>(s.close(),n(u.error)),a.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var Ki="/",Pc="tensorflowjs_models",AD="info",hH="model_topology",gH="weight_specs",bH="weight_data",yH="model_metadata";function ND(r){return{info:[Pc,r,AD].join(Ki),topology:[Pc,r,hH].join(Ki),weightSpecs:[Pc,r,gH].join(Ki),weightData:[Pc,r,bH].join(Ki),modelMetadata:[Pc,r,yH].join(Ki)}}function DD(r){for(let e of Object.values(r))window.localStorage.removeItem(e)}function xH(r){let e=r.split(Ki);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(Ki)}function TH(r){return r.startsWith(Vi.URL_SCHEME)?r.slice(Vi.URL_SCHEME.length):r}var Vi=class{constructor(e){if(!U().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ND(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),o=qa(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,TD(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch(s){throw DD(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=kD(a),t}};Vi.URL_SCHEME="localstorage://";var PD=r=>U().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Vi.URL_SCHEME)?kH(r.slice(Vi.URL_SCHEME.length)):null;Et.registerSaveRouter(PD);Et.registerLoadRouter(PD);function kH(r){return new Vi(r)}var jk=class{constructor(){D(U().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=Pc+Ki,n=Ki+AD;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(n)){let a=xH(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=TH(e);let t=ND(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return DD(t),n}};var Fc="://",un=class{constructor(){this.managers={}}static getInstance(){return un.instance==null&&(un.instance=new un),un.instance}static registerManager(e,t){D(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Fc)&&(e=e.slice(0,e.indexOf(Fc))),D(e.length>0,()=>"scheme must not be an empty string.");let n=un.getInstance();D(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function rb(r){if(r.indexOf(Fc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${un.getSchemes().join(",")}`);return{scheme:r.split(Fc)[0],path:r.split(Fc)[1]}}async function FD(r,e,t=!1){D(r!==e,()=>`Old path and new path are the same: '${r}'`);let n=Et.getLoadHandlers(r);D(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),D(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=Et.getSaveHandlers(e);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),D(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);let a=s[0],i=rb(r).scheme,u=rb(r).path,l=i===rb(r).scheme,p=await o.load();t&&l&&await un.getManager(i).removeModel(u);let c=await a.save(p);return t&&!l&&await un.getManager(i).removeModel(u),c.modelArtifactsInfo}async function MD(){let r=un.getSchemes(),e={};for(let t of r){let n=await un.getManager(t).listModels();for(let o in n){let s=t+Fc+o;e[s]=n[o]}}return e}async function ED(r){let e=rb(r);return un.getManager(e.scheme).removeModel(e.path)}async function RD(r,e){return FD(r,e,!1)}async function LD(r,e){return FD(r,e,!0)}var $D=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if(U().get("IS_BROWSER")){U().setPlatform("browser",new $D);try{un.registerManager(Vi.URL_SCHEME,new jk)}catch(r){}try{un.registerManager(Ui.URL_SCHEME,new Vk)}catch(r){}}var IH={importFetch:()=>BD()},Hk;var zD=class{constructor(){this.util=OD(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return U().global.fetch!=null?U().global.fetch(e,t):(Hk==null&&(Hk=IH.importFetch()),Hk(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};U().get("IS_NODE")&&U().setPlatform("node",new zD);function Ce(r,e="float32",t){return e=e||"float32",ef(r),new xt(r,e,t)}function CH(r,e){let t=C(r,"x","cast");if(!bk(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:t},o={dtype:e};return N.runKernel(Wn,n,o)}var Q=_({cast_:CH});function vH(r){let t={x:C(r,"x","clone","string_or_numeric")};return N.runKernel(Kn,t)}var Nn=_({clone_:vH});function qk(r,e=!1){console.log(r.toString(e))}$k();var wH={buffer:Ce,cast:Q,clone:Nn,print:qk};mD(wH);var Ur={};Qe(Ur,{browserFiles:()=>UD,browserHTTPRequest:()=>jD,concatenateArrayBuffers:()=>Nc,copyModel:()=>RD,decodeWeights:()=>eb,encodeWeights:()=>yD,fromMemory:()=>qD,getLoadHandlers:()=>wD,getModelArtifactsForJSON:()=>Dc,getModelArtifactsInfoForJSON:()=>qa,getSaveHandlers:()=>vD,http:()=>ab,isHTTPScheme:()=>sb,listModels:()=>MD,loadWeights:()=>KD,moveModel:()=>LD,registerLoadRouter:()=>CD,registerSaveRouter:()=>ID,removeModel:()=>ED,weightsLoaderFactory:()=>Qk,withSaveHandler:()=>XD});var SH="model",_H=".json",AH=".weights.bin";function GD(r){return new Promise(e=>setTimeout(e)).then(r)}var nb=class{constructor(e){if(!U().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(nb.URL_SCHEME)&&(e=e.slice(nb.URL_SCHEME.length)),(e==null||e.length===0)&&(e=SH),this.modelJsonFileName=e+_H,this.weightDataFileName=e+AH}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=tb(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await GD(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await GD(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:qa(e)}}}},df=nb;df.URL_SCHEME="downloads://";var WD=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let u=Dc(s,l=>this.loadWeights(l));e(u)},n.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let o=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,o[a]));return Promise.all(s).then(a=>[t,Nc(a)])}loadWeightsFile(e,t){return new Promise((n,o)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>o(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>Gk(s.name)),o={};for(let s of e)s.paths.forEach(a=>{let i=Gk(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);o[a]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},NH=r=>U().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(df.URL_SCHEME)?DH(r.slice(df.URL_SCHEME.length)):null;Et.registerSaveRouter(NH);function DH(r="model"){return new df(r)}function UD(r){return new WD(r)}function Xk(r,e,t,n){a(r),t=t??0,n=n??1,i(t,n);let o=0,s=u=>(u.then(l=>{let p=t+ ++o/r.length*(n-t);return e(p),l}),u);function a(u){D(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),D(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function Yk(r,e){e==null&&(e={});let t=e.fetchFunc==null?U().platform.fetch:e.fetchFunc,n=r.map(c=>t(c,e.requestInit,{isBinary:!0})),o=0,s=.5,i=(e.onProgress==null?await Promise.all(n):await Xk(n,e.onProgress,o,s)).map(c=>c.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(i):await Xk(i,e.onProgress,u,l)}async function KD(r,e="",t,n){return Qk(a=>Yk(a,{requestInit:n}))(r,e,t)}function Qk(r){return async(e,t="",n)=>{let o=e.map(()=>!1),s={},a=n!=null?n.map(()=>!1):[],i=[];if(e.forEach((f,d)=>{let h=0;f.weights.forEach(g=>{let y="quantization"in g?g.quantization.dtype:g.dtype,x=ff[y]*ct(g.shape),T=()=>{o[d]=!0,s[d]==null&&(s[d]=[]),s[d].push({manifestEntry:g,groupOffset:h,sizeBytes:x})};n!=null?n.forEach((k,w)=>{k===g.name&&(T(),a[w]=!0)}):T(),i.push(g.name),h+=x})}),!a.every(f=>f)){let f=n.filter((d,h)=>!a[h]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let u=o.reduce((f,d,h)=>(d&&f.push(h),f),[]),l=[];u.forEach(f=>{e[f].paths.forEach(d=>{let h=t+(t.endsWith("/")?"":"/")+d;l.push(h)})});let p=await r(l),c={},m=0;return u.forEach(f=>{let d=e[f].paths.length,h=0;for(let k=0;k<d;k++)h+=p[m+k].byteLength;let g=new ArrayBuffer(h),y=new Uint8Array(g),x=0;for(let k=0;k<d;k++){let w=new Uint8Array(p[m+k]);y.set(w,x),x+=w.byteLength}s[f].forEach(k=>{let w=g.slice(k.groupOffset,k.groupOffset+k.sizeBytes),P=eb(w,[k.manifestEntry]);for(let A in P)c[A]=P[A]}),m+=d}),c}}var PH="application/octet-stream",FH="application/json",ob=class{constructor(e,t){this.DEFAULT_METHOD="POST";if(t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(D(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=U().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o=tb(e,n);t.body.append("model.json",new Blob([JSON.stringify(o)],{type:FH}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:PH}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:qa(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(s){let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,o=t.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Dc(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=MH(t),s=this.weightPathPrefix||n,a=[];for(let p of e)a.push(...p.weights);let i=[],u=[];for(let p of e)for(let c of p.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(c)):i.push(s+c+o);this.weightUrlConverter&&i.push(...await Promise.all(u));let l=await Yk(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,Nc(l)]}};ob.URL_SCHEME_REGEX=/^https?:\/\//;function MH(r){let e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),o=t>e?r.substring(t):"";return[n+"/",o]}function sb(r){return r.match(ob.URL_SCHEME_REGEX)!=null}var VD=(r,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>sb(n)):t=sb(r),t)return ab(r,e)}return null};Et.registerSaveRouter(VD);Et.registerLoadRouter(VD);function ab(r,e){return new ob(r,e)}function jD(r,e){return ab(r,e)}var ib=class{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}},HD=class{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}};function qD(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new ib(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ib({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new ib({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function XD(r){return new HD(r)}var QD={};Qe(QD,{confusionMatrix:()=>YD});function EH(r,e,t=!1,n=!1){let o=C(r,"a","matMul"),s=C(e,"b","matMul");[o,s]=Ze(o,s);let a={a:o,b:s},i={transposeA:t,transposeB:n};return N.runKernel(ao,a,i)}var Ve=_({matMul_:EH});function RH(r,e,t=1,n=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let s={indices:C(r,"indices","oneHot","int32")},a={depth:e,onValue:t,offValue:n};return N.runKernel(pa,s,a)}var ji=_({oneHot_:RH});function LH(r,e){let t=C(r,"x","transpose");if(e==null&&(e=t.shape.map((s,a)=>a).reverse()),D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(s=>{D(s>=0&&s<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();let n={x:t},o={perm:e};return N.runKernel(Vo,n,o)}var qe=_({transpose_:LH});function $H(r,e,t){let n=C(r,"labels","confusionMatrix"),o=C(e,"predictions","confusionMatrix");D(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),D(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),D(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),D(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),D(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=ji(Q(n,"int32"),t),a=ji(Q(o,"int32"),t),i=qe(s),u=Ve(i,a);return Q(u,"int32")}var YD=_({confusionMatrix_:$H});var ub={};Qe(ub,{fromPixels:()=>KH,fromPixelsAsync:()=>WH,toPixels:()=>UH});function Zk(r,e,t){if(to(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Wr(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return an(r,e,n,t)}var Mc;function ZD(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,o=!1,s=!1,a=!1,i=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(o){let d=2;if(o&&r.readyState<d)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(af(vl,N.backendName)!=null){let d={pixels:r},h={numChannels:e};return N.runKernel(vl,d,h)}let[l,p]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c;a?c=r.getContext("2d").getImageData(0,0,l,p).data:n||t?c=r.data:(s||o||i)&&(Mc==null&&(Mc=document.createElement("canvas").getContext("2d")),Mc.canvas.width=l,Mc.canvas.height=p,Mc.drawImage(r,0,0,l,p),c=Mc.getImageData(0,0,l,p).data);let m;if(e===4)m=new Int32Array(c);else{let d=l*p;m=new Int32Array(d*e);for(let h=0;h<d;h++)for(let g=0;g<e;++g)m[h*e+g]=c[h*4+g]}return Zk(m,[p,l,e],"int32")}function BH(r){return r!=null&&r.data instanceof Uint8Array}function OH(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function zH(r){return r!=null&&r.width!==0&&r.height!==0}function GH(r){return OH()&&!(r instanceof ImageBitmap)&&zH(r)&&!BH(r)}async function WH(r,e=3){let t=null;if(U().getBool("WRAP_TO_IMAGEBITMAP")&&GH(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch(o){n=null}n!=null&&n.width===r.width&&n.height===r.height?t=n:t=r}else t=r;return ZD(t,e)}async function UH(r,e){let t=C(r,"img","toPixels");if(!(r instanceof Ye)){let l=t;t=Q(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let[n,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);let a=await t.data(),i=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let p=[0,0,0,255];for(let m=0;m<s;m++){let f=a[l*s+m];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);s===1?(p[0]=f*i,p[1]=f*i,p[2]=f*i):p[m]=f*i}let c=l*4;u[c+0]=Math.round(p[0]),u[c+1]=Math.round(p[1]),u[c+2]=Math.round(p[2]),u[c+3]=Math.round(p[3])}if(e!=null){e.width=o,e.height=n;let l=e.getContext("2d"),p=new ImageData(u,o,n);l.putImageData(p,0,0)}return t!==r&&t.dispose(),u}var KH=_({fromPixels_:ZD});var lb={};Qe(lb,{prepareAndValidate:()=>JD});function JD(r,e){let t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(ct(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=e.shape,s=o[o.length-1],a=1;for(let c=0;c<o.length-1;++c)a*=o[c];let i=r.shape,u=o.slice();u.pop();let l=1;for(let c=s;c<t;++c)l*=i[c],u.push(i[c]);let p=[...Ga(r.shape).map(c=>c/l),1].slice(0,s);return[u,a,l,p]}var cb={};Qe(cb,{calculateShapes:()=>e0,validateInput:()=>pb,validateUpdateShape:()=>Jk});function Jk(r,e,t){let n=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(t.rank-o))throw new Error(s+` Output shape length < ${n+(t.rank-o)}`);if(t.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let a=0;a<o;++a)if(t.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-o;++a)if(t.shape[a+o]!==r[a+n])throw new Error(s+` updates.shape[${a+o}] (${t.shape[a+o]}) != shape[${a+o}] (${r[a+o]})`)}function pb(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}Jk(t,e,r)}function e0(r,e,t){let n=e.shape.length,o=n>1?e.shape[n-1]:1,s=t.length,a=1;for(let c=o;c<s;++c)a*=t[c];let i=o<1?1:o,u=ct(e.shape)/i,l=[...Ga(t.slice(0,o)),1],p=ct(t);return{sliceRank:o,numUpdates:u,sliceSize:a,strides:l,outputSize:p}}var Xt={};Qe(Xt,{assertParamsValid:()=>VH,computeFlatOffset:()=>HH,computeOutShape:()=>t0,getNormalizedAxes:()=>s0,isSliceContinous:()=>jH,maskToAxes:()=>mb,parseSliceParams:()=>eI,sliceInfo:()=>qH,startForAxis:()=>l0,startIndicesWithElidedDims:()=>a0,stopForAxis:()=>p0,stopIndicesWithElidedDims:()=>i0,stridesForAxis:()=>u0,stridesWithElidedDims:()=>r0});function VH(r,e,t){let n=r.shape.length;D(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),D(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)D(e[o]+t[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function mb(r){let e=[],t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function t0(r,e,t){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((e[o]-r[o])/t[o]);return n}function r0(r,e,t,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function n0(r,e,t){return t<=r?t:t-(e-1)}function o0(r,e){let t=[];for(let n=0;n<r;n++)t.push(e+n);return t}function s0(r,e,t,n,o,s,a,i,u){let l=r.length,p=new Array(l),c=new Array(l),m=new Array(l);if(e.length&&t>0){let f=e[0],d=t+1;p=a0(a,f,d,n,r),c=i0(i,f,d,o,r),m=r0(s,f,d,r)}else for(let f=0;f<l;f++)p[f]=l0(a,n,s,r,f,u),c[f]=p0(i,o,s,r,f,u),m[f]=u0(s,f,u);return{begin:p,end:c,strides:m}}function a0(r,e,t,n,o){let s=[...o],a=o0(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{let u=n0(e,t,i),l=n[u];r&1<<u&&(l=0),s[i]=l}return s}function i0(r,e,t,n,o){let s=[...o],a=o0(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{let u=n0(e,t,i),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[i]=l}for(let i=0;i<s.length;i++){let u=o[i];s[i]<0&&(s[i]+=u),s[i]=Kp(0,s[i],o[i])}return s}function u0(r,e,t){let n=r[e];return(t&1<<e||n==null)&&(n=1),n}function l0(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),a=Kp(0,a,u-1),a}function p0(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),i>0?a=Kp(0,a,u):a=Kp(-1,a,u-1),a}function jH(r,e,t){let n=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){n=o;break}for(let o=n+1;o<t.length;o++)if(e[o]>0||t[o]!==r[o])return!1;return!0}function HH(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function eI(r,e,t){let n,o=r.shape.length;typeof e=="number"?n=[e,...new Array(o-1).fill(0)]:e.length<o?n=e.concat(new Array(o-e.length).fill(0)):n=e.slice(),n.forEach(a=>{D(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((a,i)=>a>=0?a:(D(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),r.shape[i]-n[i])),[n,s]}function qH(r,e,t,n,o,s,a,i,u){let l=e.slice(),p=t.slice(),c=n;n==null&&(c=new Array(l.length));let m=mb(a);if(m.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(a!==0&&i!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(a!==0&&u!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let f=r.length-l.length,d=mb(i),h=r.slice();d.forEach(A=>{l[A]=0,p[A]=1,h.splice(A,0,1)});let{begin:g,end:y,strides:x}=s0(h,m,f,l,p,c,o,s,a);l=g,p=y,c=x;let T=mb(u);T.forEach(A=>{p[A]=l[A]+1,c[A]=1});let k=t0(l,p,c),w=k.filter((A,F)=>T.indexOf(F)===-1);return{nonStrided:c.every(A=>A===1),$begin:l,$end:p,$strides:c,size:k,newShape:h,outShape:w}}var ee={};Qe(ee,{Serializable:()=>fb,SerializationMap:()=>Hi,registerClass:()=>Dn});var fb=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Hi=class{constructor(){this.classNameMap={}}static getMap(){return Hi.instance==null&&(Hi.instance=new Hi),Hi.instance}static register(e){Hi.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function Dn(r){D(r.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),D(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Hi.register(r)}var d0={};Qe(d0,{TEST_EPSILON_FLOAT16:()=>c0,encodeStrings:()=>f0,expectArrayBuffersEqual:()=>eq,expectArraysClose:()=>YH,expectArraysEqual:()=>ZH,expectNumbersClose:()=>m0,expectPromiseToFail:()=>QH,expectValuesInRange:()=>JH,testEpsilon:()=>db});var XH=.001,c0=.1;function YH(r,e,t){return t==null&&(t=db()),tI(r,e,(n,o)=>rI(n,o,t))}function db(){return N.backend.floatPrecision()===32?XH:c0}function tI(r,e,t){let n=!0;if((kr(r)||kr(e))&&(n=!1),kr(r)&&kr(e)&&(n=!0),n){let a=r.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(r)&&Array.isArray(e)){let a=Wr(r),i=Wr(e);if(!on(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let o=kr(r)?r:Hs(r),s=kr(e)?e:Hs(e);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){let i=o[a],u=s[a];if(!t(i,u))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}}function QH(r,e){r().then(()=>e.fail(),()=>e())}function ZH(r,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return qs(r)||qs(r[0])||qs(e)||qs(e[0])?tI(r,t,(n,o)=>n==o):tI(r,e,(n,o)=>rI(n,o,0))}function m0(r,e,t){if(t==null&&(t=db()),!rI(r,e,t))throw new Error(`Numbers differ: actual === ${r}, expected === ${e}`)}function rI(r,e,t){return!isFinite(r)&&!isFinite(e)?!0:!(isNaN(r)||isNaN(e)||Math.abs(r-e)>t)}function JH(r,e,t){for(let n=0;n<r.length;n++)if(r[n]<e||r[n]>t)throw new Error(`Value out of range:${r[n]} low: ${e}, high: ${t}`)}function eq(r,e){expect(new Float32Array(r)).toEqual(new Float32Array(e))}function f0(r){for(let e=0;e<r.length;e++){let t=r[e];Array.isArray(t)?f0(t):r[e]=Wu(t)}return r}var tq="0.0.0";function Hge(){U().set("PROD",!0)}function qge(){U().set("DEBUG",!0)}function Xge(){U().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function nI(r){U().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}fD(nI);function Yge(){N.disposeVariables()}function jo(){return N}function hf(){return N.memory()}function Qge(r){return N.profile(r)}function G(r,e){return N.tidy(r,e)}function Ee(r){mf(r).forEach(t=>t.dispose())}function Kt(r){return N.keep(r)}function Zge(r){return N.time(r)}function rq(r){return N.setBackend(r)}function Jge(){return N.ready()}function ebe(){return N.backendName}function tbe(r){N.removeBackend(r)}function rbe(r){return N.findBackend(r)}function nbe(r){return N.findBackendFactory(r)}function Vu(r,e,t=1){return N.registerBackend(r,e,t)}function h0(){return N.backend}function obe(r,e){U().setPlatform(r,e)}function nq(r,e){let t=C(r,"a","add"),n=C(e,"b","add");[t,n]=Ze(t,n);let o={a:t,b:n};return N.runKernel(_n,o)}var Y=_({add_:nq});function oq(r,e){let t=C(r,"a","floorDiv"),n=C(e,"b","floorDiv");[t,n]=Ze(t,n);let o={a:t,b:n};return N.runKernel(yo,o)}var gf=_({floorDiv_:oq});function sq(r,e){let t=C(r,"a","div"),n=C(e,"b","div");if([t,n]=Ze(t,n),t.dtype==="int32"&&n.dtype==="int32")return gf(t,n);let o={a:t,b:n},s={};return N.runKernel(fo,o,s)}var pe=_({div_:sq});function aq(r,e){let t=C(r,"a","mul"),n=C(e,"b","mul");[t,n]=Ze(t,n);let o={a:t,b:n};return N.runKernel(No,o)}var R=_({mul_:aq});function iq(r){let e=C(r,"x","abs");if(e.dtype==="complex64"){let t={x:e};return N.runKernel(Du,t)}else{let t={x:e};return N.runKernel(as,t)}}var Ot=_({abs_:iq});function uq(r){let t={x:C(r,"x","acos")};return N.runKernel(bi,t)}var oI=_({acos_:uq});function lq(r){let t={x:C(r,"x","acosh")};return N.runKernel(yi,t)}var sI=_({acosh_:lq});function pq(r){D(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),D(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let e=r.map((o,s)=>C(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!on(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=e;return N.runKernel(no,n)}var aI=_({addN_:pq});function cq(r,e=null,t=!1){let o={x:C(r,"x","all","bool")},s={axis:e,keepDims:t};return N.runKernel(xi,o,s)}var bf=_({all_:cq});function mq(r,e=null,t=!1){let o={x:C(r,"x","any","bool")},s={axis:e,keepDims:t};return N.runKernel(Ti,o,s)}var Ec=_({any_:mq});function fq(r,e=0){let n={x:C(r,"x","argMax")},o={axis:e};return N.runKernel(oo,n,o)}var qi=_({argMax_:fq});function dq(r,e=0){let n={x:C(r,"x","argMin")},o={axis:e};return N.runKernel(Wa,n,o)}var iI=_({argMin_:dq});function hq(r){let t={x:C(r,"x","asin")};return N.runKernel(ki,t)}var uI=_({asin_:hq});function gq(r){let t={x:C(r,"x","asinh")};return N.runKernel(Ii,t)}var lI=_({asinh_:gq});function bq(r){let t={x:C(r,"x","atan")};return N.runKernel(Ci,t)}var pI=_({atan_:bq});function yq(r,e){let t=C(r,"a","atan2"),n=C(e,"b","atan2");[t,n]=Ze(t,n);let o={a:t,b:n};return N.runKernel(wi,o)}var cI=_({atan2_:yq});function xq(r){let t={x:C(r,"x","atanh")};return N.runKernel(vi,t)}var mI=_({atanh_:xq});function Tq(r,e,t,n,o="NHWC",s){let a=r[3],i=[...e,a],u=b0(o);return Pl(r,i,t,s,n,null,null,u)}function fI(r,e,t,n,o,s,a="channelsLast"){let[i,u]=hb(e),l;if(a==="channelsLast")l=[i,u,r[3],r[3]];else if(a==="channelsFirst")l=[i,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return Pl(r,l,t,n,o,s,!1,a)}function kq(r,e,t,n,o,s,a="NDHWC"){let[i,u,l]=hI(e),p,c;if(a==="NDHWC")c="channelsLast",p=[i,u,l,r[4],r[4]];else if(a==="NCDHW")c="channelsFirst",p=[i,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return g0(r,p,t,n,o,!1,c,s)}function Pl(r,e,t,n,o,s,a=!1,i="channelsLast"){let[u,l,p,c]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,p,c]=r;else if(i==="channelsFirst")[u,c,l,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[m,f,,d]=e,[h,g]=hb(t),[y,x]=hb(n),T=Rc(m,y),k=Rc(f,x),{padInfo:w,outHeight:P,outWidth:A}=vq(o,l,p,h,g,T,k,s,i),F=a?d*c:d,E;return i==="channelsFirst"?E=[u,F,P,A]:i==="channelsLast"&&(E=[u,P,A,F]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:p,inChannels:c,outHeight:P,outWidth:A,outChannels:F,padInfo:w,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:f,effectiveFilterHeight:T,effectiveFilterWidth:k,dilationHeight:y,dilationWidth:x,inShape:r,outShape:E,filterShape:e}}function g0(r,e,t,n,o,s=!1,a="channelsLast",i){let[u,l,p,c,m]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,l,p,c,m]=r;else if(a==="channelsFirst")[u,m,l,p,c]=r;else throw new Error(`Unknown dataFormat ${a}`);let[f,d,h,,g]=e,[y,x,T]=hI(t),[k,w,P]=hI(n),A=Rc(f,k),F=Rc(d,w),E=Rc(h,P),{padInfo:$,outDepth:W,outHeight:K,outWidth:B}=wq(o,l,p,c,y,x,T,A,F,E,i),V=s?g*m:g,j;return a==="channelsFirst"?j=[u,V,W,K,B]:a==="channelsLast"&&(j=[u,W,K,B,V]),{batchSize:u,dataFormat:a,inDepth:l,inHeight:p,inWidth:c,inChannels:m,outDepth:W,outHeight:K,outWidth:B,outChannels:V,padInfo:$,strideDepth:y,strideHeight:x,strideWidth:T,filterDepth:f,filterHeight:d,filterWidth:h,effectiveFilterDepth:A,effectiveFilterHeight:F,effectiveFilterWidth:E,dilationDepth:k,dilationHeight:w,dilationWidth:P,inShape:r,outShape:j,filterShape:e}}function Iq(r,e,t,n,o){n==null&&(n=dI(r,e,t));let s=r[0],a=r[1],i=Fl((s-e+2*n)/t+1,o),u=Fl((a-e+2*n)/t+1,o);return[i,u]}function Cq(r,e,t,n,o,s){o==null&&(o=dI(r,e,n));let a=r[0],i=r[1],u=r[2],l=Fl((a-e+2*o)/n+1,s),p=Fl((i-e+2*o)/n+1,s),c=Fl((u-e+2*o)/n+1,s);return[l,p,c,t]}function dI(r,e,t,n=1){let o=Rc(e,n);return Math.floor((r[0]*(t-1)-t+o)/2)}function hb(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function hI(r){return typeof r=="number"?[r,r,r]:r}function Rc(r,e){return e<=1?r:r+(r-1)*(e-1)}function vq(r,e,t,n,o,s,a,i,u){let l,p,c;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let f=Iq([e,t],s,n,r,i);p=f[0],c=f[1]}else if(r==="same"){p=Math.ceil(e/n),c=Math.ceil(t/o);let m=Math.max(0,(p-1)*n+s-e),f=Math.max(0,(c-1)*o+a-t),d=Math.floor(m/2),h=m-d,g=Math.floor(f/2),y=f-g;l={top:d,bottom:h,left:g,right:y,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-s+1)/n),c=Math.ceil((t-a+1)/o);else if(typeof r=="object"){let m=u==="channelsLast"?r[1][0]:r[2][0],f=u==="channelsLast"?r[1][1]:r[2][1],d=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:m,bottom:f,left:d,right:h,type:m===0&&f===0&&d===0&&h===0?"VALID":"EXPLICIT"},p=Fl((e-s+m+f)/n+1,i),c=Fl((t-a+d+h)/o+1,i)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:p,outWidth:c}}function wq(r,e,t,n,o,s,a,i,u,l,p){let c,m,f,d;if(typeof r=="number"){c={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=Cq([e,t,n,1],i,1,o,r,p);m=g[0],f=g[1],d=g[2]}else if(r==="same"){m=Math.ceil(e/o),f=Math.ceil(t/s),d=Math.ceil(n/a);let h=(m-1)*o+i-e,g=(f-1)*s+u-t,y=(d-1)*a+l-n,x=Math.floor(h/2),T=h-x,k=Math.floor(g/2),w=g-k,P=Math.floor(y/2),A=y-P;c={top:k,bottom:w,left:P,right:A,front:x,back:T,type:"SAME"}}else if(r==="valid")c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((e-i+1)/o),f=Math.ceil((t-u+1)/s),d=Math.ceil((n-l+1)/a);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:c,outDepth:m,outHeight:f,outWidth:d}}function Fl(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ho(r){let[e,t,n]=hb(r);return e===1&&t===1&&n===1}function Rr(r,e){return Ho(r)||Ho(e)}function b0(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Sq(r,e){let n={x:C(r,"x","reshape","string_or_numeric")},o={shape:e};return N.runKernel(ds,n,o)}var L=_({reshape_:Sq});function _q(r,e,t,n,o){let s=C(r,"x","avgPool","float32"),a=1;D(Rr(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=s,u=!1;s.rank===3&&(u=!0,i=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),o!=null&&D(mt(n),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},c=N.runKernel(so,l,p);return c=Q(c,s.dtype),u?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Ml=_({avgPool_:_q});function Aq(r,e,t,n,o,s="NDHWC"){let a=C(r,"x","avgPool3d","float32"),i=a,u=!1;a.rank===4&&(u=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),o!=null&&D(mt(n),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},c=N.runKernel(Au,l,p);return c=Q(c,i.dtype),u?L(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var yf=_({avgPool3d_:Aq});function Nq(r,e=0){D(r.length>=1,()=>"Pass at least one tensor to concat");let t=Wi(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Nn(t[0]);let n=t,o={axis:e};return N.runKernel(us,n,o)}var lt=_({concat_:Nq});function Dq(r){let t={x:C(r,"x","sigmoid","float32")};return N.runKernel(Bo,t)}var ln=_({sigmoid_:Dq});function Pq(r,e,t){let n=C(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:e,size:t};return N.runKernel(gs,o,s)}var We=_({slice_:Pq});function Fq(r){let t={x:C(r,"x","tanh","float32")};return N.runKernel(Ko,t)}var Xi=_({tanh_:Fq});function Mq(r,e,t,n,o,s){let a=C(r,"forgetBias","basicLSTMCell"),i=C(e,"lstmKernel","basicLSTMCell"),u=C(t,"lstmBias","basicLSTMCell"),l=C(n,"data","basicLSTMCell"),p=C(o,"c","basicLSTMCell"),c=C(s,"h","basicLSTMCell"),m=lt([l,c],1),f=Ve(m,i),d=Y(f,u),h=d.shape[0],g=d.shape[1]/4,y=[h,g],x=We(d,[0,0],y),T=We(d,[0,g],y),k=We(d,[0,g*2],y),w=We(d,[0,g*3],y),P=Y(R(ln(x),Xi(T)),R(p,ln(Y(a,k)))),A=R(Xi(P),ln(w));return[P,A]}var Eq=_({basicLSTMCell_:Mq});function Rq(r,e,t){let n=C(r,"x","batchToSpaceND"),o=e.reduce((i,u)=>i*u);D(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),D(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),D(n.shape[0]%o==0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:n},a={blockShape:e,crops:t};return N.runKernel(is,s,a)}var El=_({batchToSpaceND_:Rq});function y0(r){let e;return r.rank===0||r.rank===1?e=L(r,[1,1,1,r.size]):r.rank===2?e=L(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}function Lq(r,e,t,n,o,s){s==null&&(s=.001);let a=C(r,"x","batchNorm"),i=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let p;n!=null&&(p=C(n,"offset","batchNorm")),D(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(p==null||i.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:y0(a),scale:l,offset:p,mean:i,variance:u},f={varianceEpsilon:s},d=N.runKernel(xo,m,f);return L(d,a.shape)}var Xa=_({batchNorm_:Lq});function $q(r,e,t,n,o,s){let a=C(r,"x","batchNorm"),i=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let p;return n!=null&&(p=C(n,"offset","batchNorm")),D(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),D(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Xa(a,i,u,p,l,s)}var gI=_({batchNorm2d_:$q});function Bq(r,e,t,n,o,s){let a=C(r,"x","batchNorm"),i=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let p;return n!=null&&(p=C(n,"offset","batchNorm")),D(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),D(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Xa(a,i,u,p,l,s)}var bI=_({batchNorm3d_:Bq});function Oq(r,e,t,n,o,s){let a=C(r,"x","batchNorm"),i=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm"),l;o!=null&&(l=C(o,"scale","batchNorm"));let p;return n!=null&&(p=C(n,"offset","batchNorm")),D(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),D(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Xa(a,i,u,p,l,s)}var yI=_({batchNorm4d_:Oq});function zq(r,e,t){let n=C(r,"x","bincount"),o=C(e,"weights","bincount");D(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},a={size:t};return N.runKernel(Yp,s,a)}var xf=_({bincount_:zq});function Gq(r,e){let t=C(r,"s0","broadcastArgs","int32"),n=C(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:t,s1:n};return N.runKernel(Qp,o)}var xI=_({broadcastArgs_:Gq});function Wq(r,e){let t=C(r,"broadcastTo","x"),n=t.shape;if(e.some(l=>!(l>0)||l%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=L(t,l)}let o=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(o[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((l,p)=>l>1?p:-1).filter(l=>l>=0).length===0)return Nn(t);let i={x:t},u={reps:s};return N.runKernel(An,i,u)}var Rl=_({broadcastTo_:Wq});function Uq(r){let t={x:C(r,"x","ceil","float32")};return N.runKernel(io,t)}var TI=_({ceil_:Uq});function Kq(r,e,t){let n=C(r,"x","clipByValue");D(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);let o={x:n},s={clipValueMin:e,clipValueMax:t};return N.runKernel(Un,o,s)}var Lr=_({clipByValue_:Kq});function Vq(r){return lt(r,0)}var kI=_({concat1d_:Vq});function jq(r,e){return lt(r,e)}var II=_({concat2d_:jq});function Hq(r,e){return lt(r,e)}var CI=_({concat3d_:Hq});function qq(r,e){return lt(r,e)}var vI=_({concat4d_:qq});function Xq(r,e,t,n,o="NHWC",s=[1,1],a){let i=C(r,"x","conv2d","float32"),u=C(e,"filter","conv2d","float32"),l=i,p=!1;i.rank===3&&(p=!0,l=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),a!=null&&D(mt(n),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`);let c=o==="NHWC"?l.shape[3]:l.shape[1];D(c===u.shape[2],()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${u.shape[2]}.`),D(Rr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let m={x:l,filter:u},f={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},d=N.runKernel(uo,m,f);return p?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var qn=_({conv2d_:Xq});function Yq(r,e,t,n,o="NWC",s=1,a){let i=C(r,"x","conv1d"),u=C(e,"filter","conv1d"),l=i,p=!1;i.rank===2&&(p=!0,l=L(i,[1,i.shape[0],i.shape[1]])),D(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),D(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),a!=null&&D(mt(n),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`),D(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),D(Rr(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),D(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let c=L(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=L(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=qn(m,c,[1,t],n,"NHWC",[1,s],a);return p?L(g,[g.shape[2],g.shape[3]]):L(g,[g.shape[0],g.shape[2],g.shape[3]])}var Tf=_({conv1d_:Yq});function Qq(r,e,t,n,o,s="NHWC",a){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let i=r,u=e,l=!1;e.rank===3&&(l=!0,u=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,r[0],r[1],r[2]]),D(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),D(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),D(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let p=s==="NHWC"?i[3]:i[1],c=s==="NHWC"?u.shape[3]:u.shape[1];D(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),D(c===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[3]}.`),a!=null&&D(mt(o),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let m={dy:u,filter:t},f={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,inputShape:i},d=N.runKernel(lo,m,f);return l?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var Lc=_({conv2DBackpropInput_:Qq});function Zq(r,e,t,n,o,s){let a=C(r,"x","conv2dTranspose"),i=C(e,"filter","conv2dTranspose");return Lc(t,a,i,n,o,"NHWC",s)}var kf=_({conv2dTranspose_:Zq});function Jq(r,e,t,n,o="NDHWC",s=[1,1,1]){let a=C(r,"x","conv3d"),i=C(e,"filter","conv3d"),u=a,l=!1;a.rank===4&&(l=!0,u=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),D(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),D(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),D(Rr(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let p={x:u,filter:i},c={strides:t,pad:n,dataFormat:o,dilations:s},m=N.runKernel(Pu,p,c);return l?L(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var If=_({conv3d_:Jq});function e6(r,e,t,n,o){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,a=e,i=!1;e.rank===4&&(i=!0,a=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=a.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),D(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),D(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),D(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);let p={dy:a,filter:t},c={pad:o,strides:n,inputShape:s},m=N.runKernel(ec,p,c);return i?L(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var gb=_({conv3DBackpropInput_:e6});function t6(r,e,t,n,o){let s=C(r,"x","conv3dTranspose"),a=C(e,"filter","conv3dTranspose");return gb(t,s,a,n,o)}var wI=_({conv3dTranspose_:t6});function r6(r){let t={x:C(r,"x","cos","float32")};return N.runKernel(po,t)}var Ll=_({cos_:r6});function n6(r){let t={x:C(r,"x","cosh","float32")};return N.runKernel(co,t)}var Cf=_({cosh_:n6});function o6(r,e=0,t=!1,n=!1){let s={x:C(r,"x","cumsum")},a={axis:e,exclusive:t,reverse:n};return N.runKernel(Xs,s,a)}var vf=_({cumsum_:o6});function s6(r,e,t,n=!1){let o=C(r,"x","denseBincount"),s=C(e,"weights","denseBincount");D(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),D(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let a={x:o,weights:s},i={size:t,binaryOutput:n};return N.runKernel(tc,a,i)}var SI=_({denseBincount_:s6});function a6(r,e,t="NHWC"){let n=C(r,"x","depthToSpace","float32"),o=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];D(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),D(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${n.shape}`),D(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),D(a%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${n.shape}`);let i={x:n},u={blockSize:e,dataFormat:t};return N.runKernel(Qs,i,u)}var _I=_({depthToSpace_:a6});function i6(r,e,t,n,o="NHWC",s=[1,1],a){let i=C(r,"x","depthwiseConv2d","float32"),u=C(e,"filter","depthwiseConv2d","float32"),l=i,p=!1;i.rank===3&&(p=!0,l=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),a!=null&&D(mt(n),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`);let c={x:l,filter:u},m={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=N.runKernel(mo,c,m);return p?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Yi=_({depthwiseConv2d_:i6});function u6(r){let t={x:C(r,"x","diag")};return N.runKernel(oc,t)}var l6=_({diag_:u6});function p6(r,e,t,n,o=[1,1],s="NHWC"){let a=C(r,"x","dilation2d"),i=C(e,"filter","dilation2d");D(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),D(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=a,l=!1;a.rank===3&&(u=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=!0);let p={x:u,filter:i},c={strides:t,pad:n,dilations:o},m=N.runKernel(Fu,p,c);return l?L(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var AI=_({dilation2d_:p6});function c6(r,e){let t=r.length,n=[];for(let o=0;o<t;o++){let s=t-1-o,a=r[s]||1;(e[e.length-1-o]||1)>1&&a===1&&n.unshift(s)}return n}function Dt(r,e){let t=[];for(let n=0;n<e.length;n++){let o=r[r.length-n-1],s=e.length-n-1,a=e[s];(o==null||o===1&&a>1)&&t.unshift(s)}return t}function je(r,e){let t=[],n=Math.max(r.length,e.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let a=e[e.length-o-1];if(a==null&&(a=1),s===1)t.unshift(a);else if(a===1)t.unshift(s);else if(s!==a){let i=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(i)}else t.unshift(s)}return t}function m6(r,e){let t=C(r,"a","equal","string_or_numeric"),n=C(e,"b","equal","string_or_numeric");[t,n]=Ze(t,n),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Zs,o)}var Kr=_({equal_:m6});function f6(r,e,t){let n=C(e,"a","where"),o=C(t,"b","where"),s=C(r,"condition","where","bool"),a=je(je(s.shape,n.shape),o.shape),i=Rl(s,a),u=Rl(n,a),l=Rl(o,a),p={condition:i,t:u,e:l};return N.runKernel(hs,p)}var zt=_({where_:f6});function d6(r){let t={x:C(r,"x","zerosLike")};return N.runKernel(Ts,t)}var De=_({zerosLike_:d6});function h6(r,e){let t=C(r,"a","div"),n=C(e,"b","div");[t,n]=Ze(t,n);let o=pe(t,n),s=De(o),a=Kr(n,s);return zt(a,s,o)}var NI=_({divNoNan_:h6});function g6(r,e){let t=C(r,"t1","dot"),n=C(e,"t2","dot");D((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=n.rank===1?n.size:n.shape[0];if(D(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&n.rank===1){let a=L(t,[1,-1]),i=L(n,[-1,1]),u=Ve(a,i);return L(u,[])}else if(t.rank===1&&n.rank===2){let a=L(t,[1,-1]),i=L(n,[n.shape[0],n.shape[1]]),u=Ve(a,i);return L(u,[u.size])}else if(t.rank===2&&n.rank===1){let a=L(n,[-1,1]),i=Ve(t,a);return L(i,[i.size])}else{let a=L(n,[n.shape[0],n.shape[1]]);return Ve(t,a)}}var b6=_({dot_:g6});function y6(r,...e){let t=e.map((o,s)=>C(o,`tensors${s}`,"einsum")),n={equation:r};return N.runKernel(Mu,t,n)}var DI=_({einsum_:y6});function x6(r){let t={x:C(r,"x","elu","float32")};return N.runKernel(ho,t)}var Qi=_({elu_:x6});function T6(r){let e=C(r,"x","erf");D(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Q(e,"float32"));let t={x:e};return N.runKernel(Si,t)}var PI=_({erf_:T6});function k6(r){let t={x:C(r,"x","exp")};return N.runKernel(go,t)}var cr=_({exp_:k6});function I6(r,e=0){let t=C(r,"x","expandDims","string_or_numeric");D(e<=t.rank,()=>"Axis must be <= rank of the tensor");let n={input:t},o={dim:e};return N.runKernel(ls,n,o)}var _r=_({expandDims_:I6});function C6(r){let t={x:C(r,"x","expm1")};return N.runKernel(Js,t)}var FI=_({expm1_:C6});function v6(r,e){let t=C(r,"x","tile","string_or_numeric");D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let n={x:t},o={reps:e};return N.runKernel(An,n,o)}var Vr=_({tile_:v6});function w6(r,e,t,n="float32"){e==null&&(e=r);let o=Ce([r,e],n),s=r<=e?r:e;for(let i=0;i<s;++i)o.set(1,i,i);let a=L(o.toTensor(),[r,e]);if(t==null)return a;if(t.length===1)return Vr(_r(a,0),[t[0],1,1]);if(t.length===2)return Vr(_r(_r(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return Vr(_r(_r(_r(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var $c=_({eye_:w6});function Ia(r,e,t){let n={shape:r,value:e,dtype:t};return N.runKernel(Ua,{},n)}function S6(r){let t={x:C(r,"x","floor","float32")};return N.runKernel(bo,t)}var Zi=_({floor_:S6});function _6(r,e,t=0,n=0){let o=C(r,"x","gather"),s=C(e,"indices","gather","int32"),a={x:o,indices:s},i={axis:t,batchDims:n};return N.runKernel(ps,a,i)}var Ya=_({gather_:_6});function A6(r,e){let t=C(r,"a","greater","string_or_numeric"),n=C(e,"b","greater","string_or_numeric");[t,n]=Ze(t,n),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(ra,o)}var nr=_({greater_:A6});function N6(r,e){let t=C(r,"a","greaterEqual","string_or_numeric"),n=C(e,"b","greaterEqual","string_or_numeric");[t,n]=Ze(t,n),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(To,o)}var qo=_({greaterEqual_:N6});function D6(r){let t={input:C(r,"input","imag")};return N.runKernel(Eu,t)}var $l=_({imag_:D6});function P6(r){let t={x:C(r,"x","isFinite")};return N.runKernel(_i,t)}var F6=_({isFinite_:P6});function M6(r){let t={x:C(r,"x","isInf")};return N.runKernel(Ai,t)}var E6=_({isInf_:M6});function R6(r){let t={x:C(r,"x","isNaN")};return N.runKernel(Ni,t)}var MI=_({isNaN_:R6});function L6(r,e=.2){let n={x:C(r,"x","leakyRelu")},o={alpha:e};return N.runKernel(na,n,o)}var Bl=_({leakyRelu_:L6});function $6(r,e){let t=C(r,"a","less","string_or_numeric"),n=C(e,"b","less","string_or_numeric");[t,n]=Ze(t,n),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(oa,o)}var wf=_({less_:$6});function B6(r,e){let t=C(r,"a","lessEqual","string_or_numeric"),n=C(e,"b","lessEqual","string_or_numeric");[t,n]=Ze(t,n),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(sa,o)}var Xo=_({lessEqual_:B6});function EI(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:e,num:t};return N.runKernel(uc,{},n)}function O6(r,e=5,t=1,n=1,o=.5){let s=C(r,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(mt(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,i=!1;s.rank===3&&(i=!0,a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:a},l={depthRadius:e,bias:t,alpha:n,beta:o},p=N.runKernel(Ru,u,l);return i?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var RI=_({localResponseNormalization_:O6});function z6(r){let t={x:C(r,"x","log","float32")};return N.runKernel(ko,t)}var $r=_({log_:z6});function G6(r){let t={x:C(r,"x","log1p")};return N.runKernel(Di,t)}var Ol=_({log1p_:G6});function W6(r){return D(za(r),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let n=C(e,"x","tf.grad","string_or_numeric"),o=t!=null?C(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(n),[n],o);return o!=null&&Wt(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),yb(a),a[0]})}}function U6(r){return D(za(r),()=>"The f passed in grads(f) must be a function"),(e,t)=>{D(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=Wi(e,"args","tf.grads","string_or_numeric"),o=t!=null?C(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(...n),n,o);return o!=null&&Wt(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),yb(a),a})}}function K6(r){return D(za(r),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{D(e instanceof Ye,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(t==null||t instanceof Ye,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=N.gradients(()=>r(e),[e],t);return yb(n),{grad:n[0],value:o}}}function V6(r){return D(za(r),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{D(Array.isArray(e)&&e.every(o=>o instanceof Ye),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(t==null||t instanceof Ye,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=N.gradients(()=>r(...e),e,t);return t!=null&&Wt(n.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),yb(n.grads),n}}function bb(r,e){D(za(r),()=>"The f passed in variableGrads(f) must be a function"),D(e==null||Array.isArray(e)&&e.every(l=>l instanceof Uu),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let l in N.registeredVariables)e.push(N.registeredVariables[l])}let n=t?e.filter(l=>!l.trainable):null,o=e.length;e=e.filter(l=>l.trainable),D(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:a,grads:i}=N.gradients(r,e,null,s);D(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let u={};return e.forEach((l,p)=>{i[p]!=null&&(u[l.name]=i[p])}),n!=null&&n.forEach(l=>u[l.name]=null),{value:a,grads:u}}function pn(r){return N.customGrad(r)}function yb(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function j6(r){let t={x:C(r,"x","neg")};return N.runKernel(cs,t)}var et=_({neg_:j6});function H6(r){let t={x:C(r,"x","softplus")};return N.runKernel($i,t)}var Qa=_({softplus_:H6});function q6(r){let e=C(r,"x","logSigmoid");return pn(n=>({value:et(Qa(et(n))),gradFunc:a=>R(a,ln(et(n)))}))(e)}var X6=_({logSigmoid_:q6});function Y6(r,e=null,t=!1){let o={x:C(r,"x","max")},s={reductionIndices:e,keepDims:t};return N.runKernel(Io,o,s)}var Qr=_({max_:Y6});function Q6(r,e){let t=C(r,"a","sub"),n=C(e,"b","sub");[t,n]=Ze(t,n);let o={a:t,b:n};return N.runKernel(Uo,o)}var ue=_({sub_:Q6});function Z6(r,e=null,t=!1){let n=C(r,"x","sum");n.dtype==="bool"&&(n=Q(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(zo,o,s)}var me=_({sum_:Z6});function J6(r,e=-1){let t=C(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return pn((o,s)=>{let a=!0,i=Qr(o,e,!0),u=ue(o,i),l=ue(Q(u,"float32"),$r(me(cr(u),e,a)));return s([l]),{value:l,gradFunc:(c,m)=>{let[f]=m,d=!0,h=cr(f);return ue(c,R(me(c,e,d),h))}}})(t)}var Sf=_({logSoftmax_:J6});function LI(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function x0(r,e,t){let n=r.length+e.length,o=[],s=0,a=0;for(let i=0;i<n;i++)t.indexOf(i)===-1?o.push(r[s++]):o.push(e[a++]);return o}function $I(r,e){let t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);let o=e.map(s=>r[s]);return[t,o]}function Ns(r,e){let t=e.map(n=>1);return x0(r,t,e)}function e5(r,e,t){D(LI(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function BI(r,e){if(LI(r,e))return null;let t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function _f(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function t5(r,e){let t=[];for(let n=e-r;n<e;++n)t.push(n);return t}function r5(r,e=null,t=!1){let n=C(r,"x","logSumExp"),o=yr(e,n.shape),s=Qr(n,o,!0),a=ue(n,s),i=cr(a),u=me(i,o),l=$r(u),p=Y(L(s,l.shape),l);if(t){let c=Ns(p.shape,o);return L(p,c)}return p}var OI=_({logSumExp_:r5});function n5(r,e){let t=C(r,"a","logicalAnd","bool"),n=C(e,"b","logicalAnd","bool");je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(aa,o)}var jr=_({logicalAnd_:n5});function o5(r){let t={x:C(r,"x","logicalNot","bool")};return N.runKernel(Pi,t)}var zl=_({logicalNot_:o5});function s5(r,e){let t=C(r,"a","logicalOr","bool"),n=C(e,"b","logicalOr","bool");je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Cl,o)}var Af=_({logicalOr_:s5});function a5(r,e){let t=C(r,"a","logicalXor","bool"),n=C(e,"b","logicalXor","bool");return je(t.shape,n.shape),jr(Af(r,e),zl(jr(r,e)))}var i5=_({logicalXor_:a5});function u5(r,e,t,n,o){let s=C(r,"x","maxPool"),a=1,i=s,u=!1;s.rank===3&&(u=!0,i=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),D(Rr(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),o!=null&&D(mt(n),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},c=N.runKernel(vo,l,p);return u?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Gl=_({maxPool_:u5});function l5(r,e=[1,1,1],t,n,o,s="NDHWC"){let a=C(r,"x","maxPool3d"),i=a,u=!1;a.rank===4&&(u=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),o!=null&&D(mt(n),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${o} but got pad ${n}.`);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},c=N.runKernel(Lu,l,p);return u?L(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Nf=_({maxPool3d_:l5});function p5(r,e,t,n,o=!1){let a={x:C(r,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:n,includeBatchInIndex:o},u=N.runKernel(mc,a,i);return{result:u[0],indexes:u[1]}}var zI=_({maxPoolWithArgmax_:p5});function c5(r,e){let t=C(r,"a","maximum"),n=C(e,"b","maximum");[t,n]=Ze(t,n),t.dtype==="bool"&&(t=Q(t,"int32"),n=Q(n,"int32")),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Co,o)}var Xn=_({maximum_:c5});function m5(r,e=null,t=!1){let o={x:C(r,"x","mean")},s={axis:e,keepDims:t};return N.runKernel(wo,o,s)}var Rt=_({mean_:m5});function Tt(r,e="float32"){if(e==="complex64"){let n=Tt(r,"float32"),o=Tt(r,"float32");return Hn(n,o)}let t=Hp(ct(r),e);return N.makeTensor(t,r,e)}function mr(r,e="float32"){if(e==="complex64"){let n=mr(r,"float32"),o=Tt(r,"float32");return Hn(n,o)}let t=Jm(ct(r),e);return N.makeTensor(t,r,e)}function f5(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=C(r,"x","meshgrid",r instanceof Ye?r.dtype:"float32");if(e===void 0)return[n];let o=C(e,"y","meshgrid",e instanceof Ye?e.dtype:"float32"),s=ct(n.shape),a=ct(o.shape);return t==="xy"?(n=L(n,[1,-1]),o=L(o,[-1,1]),[Ve(mr([a,1],n.dtype),n),Ve(o,mr([1,s],o.dtype))]):(n=L(n,[-1,1]),o=L(o,[1,-1]),[Ve(n,mr([1,a],n.dtype)),Ve(mr([s,1],o.dtype),o)])}function d5(r,e=null,t=!1){let o={x:C(r,"x","min")},s={axis:e,keepDims:t};return N.runKernel(So,o,s)}var Bc=_({min_:d5});function h5(r,e){let t=C(r,"a","minimum"),n=C(e,"b","minimum");[t,n]=Ze(t,n),t.dtype==="bool"&&(t=Q(t,"int32"),n=Q(n,"int32")),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(_o,o)}var Ji=_({minimum_:h5});function g5(r,e,t){D(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let n=C(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let i=0;i<n.rank;i++)D(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(e[i][0]>=0&&e[i][0]<=n.shape[i]-o&&e[i][1]>=0&&e[i][1]<=n.shape[i]-o,()=>`Padding in dimension ${i} cannot be greater than or equal to ${n.shape[i]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:e,mode:t},a={x:n};return N.runKernel(Ao,a,s)}var GI=_({mirrorPad_:g5});function b5(r,e){let t=C(r,"a","mod"),n=C(e,"b","mod");[t,n]=Ze(t,n);let o={a:t,b:n};return N.runKernel(Fi,o)}var WI=_({mod_:b5});function y5(r){let e=C(r,"x","square"),t={};return N.runKernel("Square",{x:e},t)}var Xe=_({square_:y5});function x5(r,e=null,t=!1){r=C(r,"x","moments");let n=yr(e,r.shape),o=Rt(r,n,t),s=o.shape;t||(s=Ns(o.shape,n));let a=Xe(ue(Q(r,"float32"),L(o,s))),i=Rt(a,n,t);return{mean:o,variance:i}}var Oc=_({moments_:x5});function T5(r,e,t,n){let o=C(e,"data","multiRNNCell"),s=Wi(t,"c","multiRNNCell"),a=Wi(n,"h","multiRNNCell"),i=o,u=[];for(let c=0;c<r.length;c++){let m=r[c](i,s[c],a[c]);u.push(m[0]),u.push(m[1]),i=m[1]}let l=[],p=[];for(let c=0;c<u.length;c+=2)l.push(u[c]),p.push(u[c+1]);return[l,p]}var k5=_({multiRNNCell_:T5});function I5(r,e,t,n=!1){let o=C(r,"logits","multinomial"),s=o.size,a=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();let u={logits:a===1?L(o,[1,-1]):o},l={numSamples:e,seed:t,normalized:n},p=N.runKernel(fc,u,l);return a===1?L(p,[p.size]):p}var UI=_({multinomial_:I5});function C5(r,e){let t=C(r,"a","notEqual","string_or_numeric"),n=C(e,"b","notEqual","string_or_numeric");[t,n]=Ze(t,n),je(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(ia,o)}var Za=_({notEqual_:C5});function v5(r){let t={x:C(r,"x","onesLike")};return N.runKernel(ms,t)}var Ar=_({onesLike_:v5});function w5(r,e){let t=C(r,"v1","outerProduct"),n=C(e,"v2","outerProduct");D(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);let o=L(t,[-1,1]),s=L(n,[1,-1]);return Ve(o,s)}var S5=_({outerProduct_:w5});function _5(r,e,t=0){let n=C(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:n};return N.runKernel(Do,s,o)}var Pn=_({pad_:_5});function A5(r,e,t=0){return D(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Pn(r,[e],t)}var N5=_({pad1d_:A5});function D5(r,e,t=0){return D(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pn(r,e,t)}var P5=_({pad2d_:D5});function F5(r,e,t=0){return D(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pn(r,e,t)}var M5=_({pad3d_:F5});function E5(r,e,t=0){return D(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pn(r,e,t)}var R5=_({pad4d_:E5});function L5(r,e,t){let n=C(r,"x","spaceToBatchND");D(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),D(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),D(n.shape.reduce((a,i,u)=>u>0&&u<=e.length?a&&(i+t[u-1][0]+t[u-1][1])%e[u-1]==0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:n},s={blockShape:e,paddings:t};return N.runKernel(bs,o,s)}var Wl=_({spaceToBatchND_:L5});function $5(r,e,t,n,o,s){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=C(r,"x","maxPool"),i=a,u=!1;a.rank===3&&(u=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(Rr(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let l=fI(i.shape,e,s,o,n),p=[l.dilationHeight,l.dilationWidth],c;n==="same"?c=O5([l.filterHeight,l.filterWidth],p):c=[[0,0],[0,0]];let m=p[0]===1&&p[1]===1,[f,d]=B5([l.inHeight,l.inWidth],p,c),h=m?n:"valid",g=m?i:Wl(i,p,f),x=(t==="avg"?()=>Ml(g,e,s,h):()=>Gl(g,e,s,h))(),T=m?x:El(x,p,d);return u?L(T,[T.shape[1],T.shape[2],T.shape[3]]):T}function B5(r,e,t){let n=t.map(p=>p[0]),o=t.map(p=>p[1]),s=r.concat(n,o),a=e.map((p,c)=>(p-s[c]%p)%p),i=o.map((p,c)=>p+a[c]),u=e.map((p,c)=>[n[c],i[c]]),l=e.map((p,c)=>[0,a[c]]);return[u,l]}function O5(r,e){let n=r.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),o=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-o[i]);return n.map((a,i)=>[o[i],s[i]])}var z5=_({pool_:$5});function G5(r,e){let t=C(r,"base","pow"),n=C(e,"exp","pow");[t,n]=Ze(t,n);let o={a:t,b:n};return N.runKernel(Po,o)}var Fn=_({pow_:G5});function W5(r,e){let t=C(r,"x","prelu"),n=C(e,"alpha","prelu"),o={x:t,alpha:n};return N.runKernel(Fo,o)}var Ul=_({prelu_:W5});function U5(r,e=null,t=!1){let n=C(r,"x","prod");n.dtype==="bool"&&(n=Q(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(ca,o,s)}var Df=_({prod_:U5});function K5(r,e,t){let n=ct(r),o=null;if(t==null||t==="float32")o=new Float32Array(n);else if(t==="int32")o=new Int32Array(n);else if(t==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<n;s++)o[s]=e();return N.makeTensor(o,r,t)}var V5=_({rand_:K5});var Tb=Tl(Pf());var zc=class{constructor(e,t,n,o,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=Tb.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,n=!1;for(;!n;){let o,s,a;do o=2*this.random()-1,s=2*this.random()-1,a=o*o+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*o*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},YI=class{constructor(e,t,n,o){this.alpha=e,this.beta=1/t,this.dtype=n;let s=o||Math.random();this.randu=Tb.alea(s.toString()),this.randn=new zc(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,o,s,a;for(;;){do o=this.randn.nextValue(),a=1+this.c*o;while(a<=0);if(a*=a*a,e=o*o,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},QI=class{constructor(e=0,t=1,n,o){this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32";if(this.min=e,this.range=t-e,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Tb.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function Z5(r,e,t=1,n="float32",o){if(t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new YI(e,t,n,o),a=Ce(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var J5=_({randomGamma_:Z5});function e8(r,e=0,t=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new zc(e,t,n,!1,o),a=Ce(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var kb=_({randomNormal_:e8});function t8(r,e=0,t=1,n="float32",o){let s=Ce(r,n),a=new QI(e,t,null,o);for(let i=0;i<s.values.length;i++)s.values[i]=a.nextValue();return s.toTensor()}var Ca=_({randomUniform_:t8});function eu(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:e,step:t,dtype:n};return N.runKernel(Ka,{},o)}function r8(r){let t={input:C(r,"input","real")};return N.runKernel($u,t)}var ju=_({real_:r8});function n8(r){let t={x:C(r,"x","reciprocal")};return N.runKernel(Ei,t)}var ZI=_({reciprocal_:n8});function o8(r){let t={x:C(r,"x","relu")};return N.runKernel(Mo,t)}var Hr=_({relu_:o8});function s8(r){let t={x:C(r,"x","relu6")};return N.runKernel(Ro,t)}var Ff=_({relu6_:s8});function a8(r,e){let n={x:C(r,"x","reverse")},o={dims:e};return N.runKernel(ma,n,o)}var xr=_({reverse_:a8});function i8(r){let e=C(r,"x","reverse");return D(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),xr(e,0)}var u8=_({reverse1d_:i8});function l8(r,e){let t=C(r,"x","reverse");return D(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),xr(t,e)}var p8=_({reverse2d_:l8});function c8(r,e){let t=C(r,"x","reverse");return D(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),xr(t,e)}var m8=_({reverse3d_:c8});function f8(r,e){let t=C(r,"x","reverse");return D(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),xr(t,e)}var d8=_({reverse4d_:f8});function h8(r){let t={x:C(r,"x","round")};return N.runKernel(fa,t)}var Mf=_({round_:h8});function g8(r){let t={x:C(r,"x","rsqrt","float32")};return N.runKernel(Lo,t)}var Ef=_({rsqrt_:g8});function ce(r,e){if((kr(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&kr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return an(r,[],[],e)}function b8(r){let t={x:C(r,"x","selu")};return N.runKernel(Ri,t)}var Rf=_({selu_:b8});function y8(r,e,t,n,o,s=[1,1],a="NHWC"){let i=C(r,"x","separableConv2d"),u=C(e,"depthwiseFilter","separableConv2d"),l=C(t,"pointwiseFilter","separableConv2d"),p=i,c=!1;if(i.rank===3&&(c=!0,p=L(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),D(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let m=u.shape[2],f=u.shape[3];D(l.shape[2]===m*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*f}, but got ${l.shape[2]}.`);let d=Yi(p,u,n,o,a,s),g=qn(d,l,1,"valid",a);return c?L(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var JI=_({separableConv2d_:y8});async function x8(r,e){let t=C(r,"x","setdiff1d"),n=C(e,"y","setdiff1d");D(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),D(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),D(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await t.data(),s=await n.data(),a=new Set(s),i=0;for(let p=0;p<o.length;p++)a.has(o[p])||i++;let u=new xt([i],t.dtype),l=new xt([i],"int32");for(let p=0,c=0;p<o.length;p++)a.has(o[p])||(u.values[c]=o[p],l.values[c]=p,c++);return[u.toTensor(),l.toTensor()]}var eC=x8;function T8(r){let t={x:C(r,"x","sign")};return N.runKernel(Li,t)}var tC=_({sign_:T8});function k8(r){let t={x:C(r,"x","sin","float32")};return N.runKernel($o,t)}var Lf=_({sin_:k8});function I8(r){let t={x:C(r,"x","sinh")};return N.runKernel(ha,t)}var $f=_({sinh_:I8});function C8(r,e,t){let n=C(r,"x","slice1d");return D(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),We(n,[e],[t])}var Bf=_({slice1d_:C8});function v8(r,e,t){let n=C(r,"x","slice2d");return D(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),We(n,e,t)}var Ib=_({slice2d_:v8});function w8(r,e,t){let n=C(r,"x","slice3d");return D(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),We(n,e,t)}var Of=_({slice3d_:w8});function S8(r,e,t){let n=C(r,"x","slice4d");return D(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),We(n,e,t)}var Gc=_({slice4d_:S8});function _8(r,e=-1){let t=C(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let n={logits:t},o={dim:e};return N.runKernel(Go,n,o)}var Vl=_({softmax_:_8});function A8(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(ac,e)}var jl=_({fft_:A8});function N8(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(ic,e)}var Hu=_({ifft_:N8});function D8(r){let e=r.shape[r.shape.length-1],t=r.size/e,n;if(e<=2){let o=L(r,[t,e]);n=Hu(o)}else{let o=[t,2*(e-1)],s=L(ju(r),[t,e]),a=L($l(r),[t,e]),i=xr(We(s,[0,1],[t,e-2]),1),u=R(xr(We(a,[0,1],[t,e-2]),1),ce(-1)),l=lt([s,i],1),p=lt([a,u],1),c=L(Hn(l,p),[o[0],o[1]]);n=Hu(c)}if(n=ju(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=L(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var zf=_({irfft_:D8});function P8(r,e,t=0){let o={x:C(r,"x","split")},s={numOrSizeSplits:e,axis:t};return N.runKernel(ys,o,s)}var Ir=_({split_:P8});function F8(r,e){D(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1],n=r.size/t,o;if(e!=null&&e<t){let d=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=e,o=We(r,d,h),t=e}else if(e!=null&&e>t){let d=r.shape.map(h=>h);d[r.shape.length-1]=e-t,o=lt([r,Tt(d)],r.shape.length-1),t=e}else o=r;let s=De(o),a=L(Hn(o,s),[n,t]),i=jl(a),u=Math.floor(t/2)+1,l=ju(i),p=$l(i),c=Ir(l,[u,t-u],l.shape.length-1),m=Ir(p,[u,t-u],p.shape.length-1),f=o.shape.slice();return f[o.shape.length-1]=u,L(Hn(c[0],m[0]),f)}var Hl=_({rfft_:F8});function M8(r){let t={x:C(r,"x","sqrt","float32")};return N.runKernel(Oo,t)}var Lt=_({sqrt_:M8});function E8(r,e){let t=C(r,"a","squaredDifference"),n=C(e,"b","squaredDifference");[t,n]=Ze(t,n),je(t.shape,n.shape);let o={a:t,b:n},s={};return N.runKernel(Wo,o,s)}var Gf=_({squaredDifference_:E8});function R8(r,e){let t=C(r,"x","squeeze");return L(t,fk(t.shape,e).newShape)}var cn=_({squeeze_:R8});function L8(r,e=0){let t=Wi(r,"tensors","stack","string_or_numeric");D(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&D(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let n=t,o={axis:e};return N.runKernel(fs,n,o)}var fr=_({stack_:L8});function $8(r,e=0){let n={x:C(r,"x","step")},o={alpha:e};return N.runKernel(ks,n,o)}var tu=_({step_:$8});function B8(r,e,t,n,o=0,s=0,a=0,i=0,u=0){let p={x:C(r,"x","stridedSlice","string_or_numeric")},c={begin:e,end:t,strides:n,beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};return N.runKernel(ga,p,c)}var rC=_({stridedSlice_:B8});function O8(r){let t={x:C(r,"x","tan","float32")};return N.runKernel(ba,t)}var nC=_({tan_:O8});function Gt(r,e){to(r);let t=Wr(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return an(r,null,t,e)}function Ja(r,e,t){if(to(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Wr(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return an(r,e,n,t)}function z8(r,e,t){if(to(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Wr(r,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return an(r,e,n,t)}function G8(r,e,t){if(to(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Wr(r,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return an(r,e,n,t)}function W8(r,e,t){if(to(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Wr(r,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,an(r,e,n,t)}function U8(r,e=1,t=!0){let n=C(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:n},a={k:e,sorted:t},[i,u]=N.runKernel(Bi,s,a);return{values:i,indices:u}}var oC=_({topk_:U8});function K8(r,e=0,t=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new zc(e,t,n,!0,o),a=Ce(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var ql=_({truncatedNormal_:K8});function V8(r,e=0){let t=C(r,"x","unique","string_or_numeric");D(t.rank>0,()=>"The input tensor must be at least 1D");let n={x:t},o={axis:e},[s,a]=N.runKernel(Ic,n,o);return{values:s,indices:a}}var Cb=_({unique_:V8});function j8(r,e,t){let n=C(r,"x","unsortedSegmentSum"),o=C(e,"segmentIds","unsortedSegmentSum","int32");D(mt(t),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},a={numSegments:t};return N.runKernel(zu,s,a)}var sC=_({unsortedSegmentSum_:j8});function H8(r,e=0){let t=C(r,"x","unstack","string_or_numeric");D(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let n={value:t},o={axis:e};return N.runKernel(xs,n,o)}var Br=_({unstack_:H8});function aC(r,e=!0,t,n){return N.makeVariable(r,e,t,n)}function vb(r,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let n=Ce(r,"int32"),o=Ce([t.length,r.length],"int32");for(let s=0;s<t.length;s++){let a=n.indexToLoc(t[s]),i=s*r.length;o.values.set(a,i)}return o.toTensor()}async function q8(r){let e=C(r,"condition","whereAsync","bool"),t=await e.data(),n=vb(e.shape,t);return r!==e&&e.dispose(),n}var Wf=q8;async function X8(r,e,t){let n=C(r,"tensor","boolMask"),o=C(e,"mask","boolMask","bool"),s=t??0,a=o.rank,i=n.shape;D(a>0,()=>"mask cannot be scalar"),Wt(i.slice(s,s+a),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+a;h++)u*=i[h];let l=i.slice(0,s).concat([u],i.slice(s+a)),p=L(n,l),c=L(o,[-1]),m=await Wf(c),f=cn(m,[1]),d=Ya(p,f,s);return r!==n&&n.dispose(),e!==o&&o.dispose(),f.dispose(),p.dispose(),c.dispose(),m.dispose(),d}var JRe=X8;function Y8(r,e="euclidean",t=null,n=!1){r=C(r,"x","norm");let o=L0(r,e,t),s=o.shape;if(n){let a=yr(t,r.shape);s=Ns(o.shape,a)}return L(o,s)}function L0(r,e,t=null){if(r.rank===0)return Ot(r);if(r.rank!==1&&t===null)return L0(L(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return me(Ot(r),t);if(e===1/0)return Qr(Ot(r),t);if(e===-1/0)return Bc(Ot(r),t);if(e==="euclidean"||e===2)return Lt(me(Fn(Ot(r),ce(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Qr(me(Ot(r),t[0]),t[1]-1);if(e===1/0)return Qr(me(Ot(r),t[1]),t[0]);if(e===-1/0)return Bc(me(Ot(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Lt(me(Xe(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var wb=_({norm_:Y8});function Q8(r,e,t,n,o=!0){let s=C(r,"v","movingAverage"),a=C(e,"x","movingAverage"),i=C(t,"decay","movingAverage");Ek(s,a),D(on(s.shape,a.shape),()=>"Shape mismatch in v and x");let u=ce(1),l=ue(u,i),p=R(ue(a,s),l);if(o){D(n!=null,()=>"When using zeroDebias: true, step is required.");let c=C(n,"step","movingAverage");p=pe(p,ue(u,Fn(i,c)))}return Y(s,p)}var wLe=_({movingAverage_:Q8});function Z8(r,e,t){let n=C(r,"indices","scatterND","int32"),o=C(e,"updates","scatterND");pb(o,n,t);let s={indices:n,updates:o},a={shape:t};return N.runKernel(da,s,a)}var $0=_({scatterND_:Z8});function B0(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let a=e.size;if(!(e.rank===0||e.rank===1&&a===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function J8(r,e,t,n=0){let o=C(r,"sparseIndices","sparseToDense","int32"),s=C(e,"sparseValues","sparseToDense"),a=C(n,"defaultValue","sparseToDense",s.dtype);B0(o,s,t,a);let i={sparseIndices:o,sparseValues:s,defaultValue:a},u={outputShape:t};return N.runKernel(Bu,i,u)}var Sb=_({sparseToDense_:J8});function eX(r,e){let t=C(e,"indices","gatherND","int32"),o={params:C(r,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(ta,o)}var O0=_({gatherND_:eX});function z0(r,e){if(e==null)return r.shape.slice();if(on(r.shape,e))return e;if(r.shape.length===e.length){let t=[];for(let n=0;n<r.shape.length;n++)e[n]==null&&r.shape[n]!=null?t.push(r.shape[n]):t.push(e[n]);return t}return e}function tX(r,e,t,n){let o=C(r,"x","dropout");if(D(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),D(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof Ye?o.clone():o;let s=z0(o,t),a=1-e,i=pe(Zi(Y(Ca(s,0,1,"float32",n),a)),a);return R(o,i)}var G0=_({dropout_:tX});function W0(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function _b(r,e,t){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let a=2*Math.PI*s/(r+n-1);o[s]=e-t*Math.cos(a)}return Gt(o,"float32")}async function rX(r,e,t=1){let n=C(r,"predictions","inTopK"),o=C(e,"targets","inTopK");D(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),D(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Wt(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];D(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let a=await n.data(),i=await o.data(),[u,l]=[a.length/s,s],p=dk("bool",u);for(let c=0;c<u;c++){let m=c*l,f=a.subarray(m,m+l),d=[];for(let h=0;h<f.length;h++)d.push({value:f[h],index:h});d.sort((h,g)=>g.value-h.value),p[c]=0;for(let h=0;h<t;h++)if(d[h].index===i[c]){p[c]=1;break}}return r!==n&&n.dispose(),e!==o&&o.dispose(),Er(p,o.shape,"bool")}var d$e=rX;var Ds={};Qe(Ds,{conv2d:()=>U0,depthwiseConv2d:()=>K0,matMul:()=>V0});function nX(r,e,t,n,o,s="NHWC",a){let i=r;r.rank===3&&(i=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=L(e,[1,e.shape[0],e.shape[1],e.shape[2]])),D(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),D(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),D(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let l=s==="NHWC"?i.shape[3]:i.shape[1],p=s==="NHWC"?u.shape[3]:u.shape[1];D(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),D(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),a!=null&&D(mt(o),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let c={x:i,dy:u},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,filterShape:t};return N.runKernel(Zp,c,m)}var Wc=_({conv2DBackpropFilter_:nX});function Xl(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return R(r,tu(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function Yl(r,e){let t=e,n=Dt(r.shape,e.shape);return n.length>0&&(t=me(t,n)),L(t,r.shape)}function Ql(r,e,t,n){if(e==="linear")return r;if(e==="relu")return Hr(r);if(e==="elu")return Qi(r);if(e==="relu6")return Ff(r);if(e==="prelu")return Ul(r,t);if(e==="leakyrelu")return Bl(r,n);if(e==="sigmoid")return ln(r);throw new Error(`Unknown fused activation ${e}.`)}var Zl=(r,e)=>!(r>0)||e==="linear";function oX({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(u=u||"linear",Zl(N.state.gradientDepth,u)===!1){let w=qn(r,e,t,n,o,s,a);return i!=null&&(w=Y(w,i)),Ql(w,u,l,p)}let c=C(r,"x","conv2d","float32"),m=C(e,"filter","conv2d","float32"),f=c,d=!1;c.rank===3&&(d=!0,f=L(c,[1,c.shape[0],c.shape[1],c.shape[2]])),D(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),D(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),a!=null&&D(mt(n),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`),D(f.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${f.shape[3]}) must match input depth for filter ${m.shape[2]}.`),D(Rr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);let h=Pl(f.shape,m.shape,t,s,n,a),g;i!=null&&(g=C(i,"bias","fused conv2d"),[g]=Ze(g,c),je(h.outShape,g.shape));let y;l!=null&&(y=C(l,"prelu weights","fused conv2d"));let x=(w,P)=>{let[A,F,E,$]=P,W=Xl(w,E,u);D(Ho(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let K=Lc(F.shape,W,A,t,n),B=Wc(F,W,A.shape,t,n),V=[K,B];if($!=null){let j=Yl($,W);V.push(j)}return V},T={x:f,filter:m,bias:g,preluActivationWeights:y},k={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return i==null?pn((P,A,F)=>{let E=N.runKernel(Cs,T,k);return F([A,P,E]),d&&(E=L(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(f,m):pn((P,A,F,E)=>{let $=N.runKernel(Cs,T,k);return E([A,P,$,F]),d&&($=L($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(f,m,g)}var U0=_({fusedConv2d_:oX});function sX(r,e,t,n,o,s=[1,1],a){let i=r;r.rank===3&&(i=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={x:i,dy:u},p={strides:n,pad:o,dimRoundingMode:a,dilations:s,filterShape:t};return N.runKernel(rc,l,p)}var Ab=_({depthwiseConv2dNativeBackpropFilter_:sX});function aX(r,e,t,n,o,s=[1,1],a){let i=e,u=!1;e.rank===3&&(u=!0,i=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={dy:i,filter:t},p={strides:n,pad:o,dimRoundingMode:a,dilations:s,inputShape:r},c=N.runKernel(nc,l,p);return u?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Nb=_({depthwiseConv2dNativeBackpropInput_:aX});function iX({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(Zl(N.state.gradientDepth,u)===!1){let w=Yi(r,e,t,n,o,s,a);return i!=null&&(w=Y(w,i)),Ql(w,u,l,p)}let c=C(r,"x","depthwiseConv2d","float32"),m=C(e,"filter","depthwiseConv2d","float32"),f=c,d=!1;c.rank===3&&(d=!0,f=L(c,[1,c.shape[0],c.shape[1],c.shape[2]])),D(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),D(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),D(f.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),D(Rr(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),a!=null&&D(mt(n),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${n}.`);let h=Pl(f.shape,m.shape,t,s,n,a,!0),g;i!=null&&(g=C(i,"bias","fused conv2d"),[g]=Ze(g,c),je(h.outShape,g.shape));let y;l!=null&&(y=C(l,"prelu weights","fused depthwiseConv2d"));let x=(w,P)=>{D(Ho(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[A,F,E,$]=P,W=Xl(w,E,u),K=Nb(F.shape,W,A,t,n,s,a),B=Ab(F,W,A.shape,t,n,s,a);if($!=null){let V=Yl(g,W);return[K,B,V]}return[K,B]},T={x:f,filter:m,bias:g,preluActivationWeights:y},k={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return i==null?pn((P,A,F)=>{let E=N.runKernel(vs,T,k);return F([A,P,E]),d&&(E=L(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(f,m):pn((P,A,F,E)=>{let $=N.runKernel(vs,T,k);return E([A,P,$,F]),d&&($=L($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(f,m,g)}var K0=_({fusedDepthwiseConv2d_:iX});function uX({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:i}){if(Zl(N.state.gradientDepth,s)===!1){let $=Ve(r,e,t,n);return o!=null&&($=Y($,o)),Ql($,s,a,i)}let u=C(r,"a","fused matMul"),l=C(e,"b","fused matMul");[u,l]=Ze(u,l);let p=t?u.shape[u.rank-2]:u.shape[u.rank-1],c=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],f=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=ct(d),y=ct(h);D(u.rank>=2&&l.rank>=2&&u.rank===l.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${l.rank}.`),D(on(d,h),()=>`Error in fused matMul: outer dimensions (${d}) and (${h}) of Tensors with shapes ${u.shape} and ${l.shape} must match.`),D(p===c,()=>`Error in fused matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${n} must match.`);let x=u.shape.slice(0,-2).concat([m,f]),T=t?L(u,[g,p,m]):L(u,[g,m,p]),k=n?L(l,[y,f,c]):L(l,[y,c,f]),w;o!=null&&(w=C(o,"bias","fused matMul"),[w]=Ze(w,u),je(x,w.shape));let P;a!=null&&(P=C(a,"prelu weights","fused matMul"));let A=($,W)=>{let[K,B,V,j]=W,H=Xl(L($,V.shape),V,s),J,X;if(!t&&!n?(J=Ve(H,B,!1,!0),X=Ve(K,H,!0,!1)):!t&&n?(J=Ve(H,B,!1,!1),X=Ve(H,K,!0,!1)):t&&!n?(J=Ve(B,H,!1,!0),X=Ve(K,H,!1,!1)):(J=Ve(B,H,!0,!0),X=Ve(H,K,!0,!0)),o!=null){let ne=Yl(j,H);return[J,X,ne]}else return[J,X]},F={a:T,b:k,bias:w,preluActivationWeights:P},E={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:i};return o==null?pn((W,K,B)=>{let V=N.runKernel(Is,F,E);return B([W,K,V]),{value:L(V,x),gradFunc:A}})(T,k):pn((W,K,B,V)=>{let j=N.runKernel(Is,F,E);return V([W,K,j,B]),{value:L(j,x),gradFunc:A}})(T,k,w)}var V0=_({fusedMatMul_:uX});function lX(r){return _b(r,.54,.46)}var j0=_({hammingWindow_:lX});function pX(r){return _b(r,.5,.5)}var Db=_({hannWindow_:pX});function cX(r,e,t,n=!1,o=0){let s=0,a=[];for(;s+e<=r.size;)a.push(We(r,s,e)),s+=t;if(n)for(;s<r.size;){let i=s+e-r.size,u=lt([We(r,s,e-i),Ia([i],o)]);a.push(u),s+=t}return a.length===0?Ja([],[0,e]):L(lt(a),[a.length,e])}var Pb=_({frame_:cX});function mX(r,e,t,n,o=Db){n==null&&(n=W0(e));let s=Pb(r,e,t),a=R(s,o(e));return Hl(a,n)}var H0=_({stft_:mX});function fX(r,e,t,n,o="bilinear",s=0){let a=C(r,"image","cropAndResize"),i=C(e,"boxes","cropAndResize","float32"),u=C(t,"boxInd","cropAndResize","int32"),l=i.shape[0];D(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),D(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),D(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),D(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),D(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),D(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let p={image:a,boxes:i,boxInd:u},c={method:o,extrapolationValue:s,cropSize:n};return N.runKernel(Ys,p,c)}var q0=_({cropAndResize_:fX});function dX(r){let e=C(r,"image","flipLeftRight","float32");D(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return N.runKernel(ea,t,{})}var X0=_({flipLeftRight_:dX});function hX(r){let e=C(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];D(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),D(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,Vr(e,o)}var Y0=_({grayscaleToRGB_:hX});function gX(r,e,t=0,n=.5){let o=C(r,"image","rotateWithOffset","float32");D(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},a={radians:e,fillValue:t,center:n};return N.runKernel(xa,s,a)}var Q0=_({rotateWithOffset_:gX});function Ps(r,e,t,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let a=r.shape[0];return t=Math.min(t,a),D(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),D(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),D(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),D(e.rank===1,()=>"scores must be a 1D tensor"),D(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function bX(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppression","float32"),a=C(e,"scores","nonMaxSuppression","float32"),i=Ps(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u={maxOutputSize:t,iouThreshold:n,scoreThreshold:o};return N.runKernel(ua,{boxes:s,scores:a},u)}var Z0=_({nonMaxSuppression_:bX});function J0(r,e,t){let n=yX(r,e,t),o=n<0?-(n+1):n;r.splice(o,0,e)}function yX(r,e,t){return TX(r,e,t||xX)}function xX(r,e){return r>e?1:r<e?-1:0}function TX(r,e,t){let n=0,o=r.length,s=0,a=!1;for(;n<o;){s=n+(o-n>>>1);let i=t(e,r[s]);i>0?n=s+1:(o=s,a=!i)}return a?n:-n-1}function Fb(r,e,t,n,o){return iC(r,e,t,n,o,0)}function Mb(r,e,t,n,o,s){return iC(r,e,t,n,o,0,!1,s,!0)}function Eb(r,e,t,n,o,s){return iC(r,e,t,n,o,s,!0)}function iC(r,e,t,n,o,s,a=!1,i=!1,u=!1){let l=[];for(let g=0;g<e.length;g++)e[g]>o&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(e2);let p=s>0?-.5/s:0,c=[],m=[];for(;c.length<t&&l.length>0;){let g=l.pop(),{score:y,boxIndex:x,suppressBeginIndex:T}=g;if(y<o)break;let k=!1;for(let w=c.length-1;w>=T;--w){let P=kX(r,x,c[w]);if(P>=n){k=!0;break}if(g.score=g.score*IX(n,p,P),g.score<=o)break}g.suppressBeginIndex=c.length,k||(g.score===y?(c.push(x),m.push(g.score)):g.score>o&&J0(l,g,e2))}let f=c.length,d=t-f;i&&d>0&&(c.push(...new Array(d).fill(0)),m.push(...new Array(d).fill(0)));let h={selectedIndices:c};return a&&(h.selectedScores=m),u&&(h.validOutputs=f),h}function kX(r,e,t){let n=r.subarray(e*4,e*4+4),o=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),i=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),p=Math.min(o[1],o[3]),c=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),f=(i-s)*(u-a),d=(c-l)*(m-p);if(f<=0||d<=0)return 0;let h=Math.max(s,l),g=Math.max(a,p),y=Math.min(i,c),x=Math.min(u,m),T=Math.max(y-h,0)*Math.max(x-g,0);return T/(f+d-T)}function IX(r,e,t){let n=Math.exp(e*t*t);return t<=r?n:0}function e2(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}async function CX(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=C(r,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),i=Ps(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u=await Promise.all([s.data(),a.data()]),l=u[0],p=u[1],{selectedIndices:c}=Fb(l,p,t,n,o);return s!==r&&s.dispose(),a!==e&&a.dispose(),Gt(c,"int32")}var t2=CX;function vX(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=C(r,"boxes","nonMaxSuppression"),i=C(e,"scores","nonMaxSuppression"),u=Ps(a,i,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:a,scores:i},p={maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},c=N.runKernel(la,l,p);return{selectedIndices:c[0],selectedScores:c[1]}}var r2=_({nonMaxSuppressionWithScore_:vX});async function wX(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=C(r,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),u=Ps(a,i,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([a.data(),i.data()]),p=l[0],c=l[1],{selectedIndices:m,selectedScores:f}=Eb(p,c,t,n,o,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Gt(m,"int32"),selectedScores:Gt(f)}}var n2=wX;function SX(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=C(r,"boxes","nonMaxSuppression"),i=C(e,"scores","nonMaxSuppression"),u=Ps(a,i,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,c=u.scoreThreshold,m={boxes:a,scores:i},f={maxOutputSize:l,iouThreshold:p,scoreThreshold:c,padToMaxOutputSize:s},d=N.runKernel(Mi,m,f);return{selectedIndices:d[0],validOutputs:d[1]}}var o2=_({nonMaxSuppressionPadded_:SX});async function _X(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=C(r,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),u=Ps(a,i,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,c=u.scoreThreshold,[m,f]=await Promise.all([a.data(),i.data()]),{selectedIndices:d,validOutputs:h}=Mb(m,f,l,p,c,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Gt(d,"int32"),validOutputs:ce(h,"int32")}}var s2=_X;function AX(r,e,t=!1,n=!1){let o=C(r,"images","resizeBilinear");D(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),D(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(Eo,i,u);return a?L(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var a2=_({resizeBilinear_:AX});function NX(r,e,t=!1,n=!1){let o=C(r,"images","resizeNearestNeighbor");D(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),D(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(Va,i,u);return a?L(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var i2=_({resizeNearestNeighbor_:NX});function DX(r,e="binary",t=!1,n=.5){let o=C(r,"image","threshold"),s=.2989,a=.587,i=.114,u=o.shape[0]*o.shape[1],l=R(Gt([n]),255),p,c,m,f;if(D(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),D(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),D(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),D(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[p,c,m]=Ir(o,[1,1,1],-1);let g=R(p,s),y=R(c,a),x=R(m,i);f=Y(Y(g,y),x)}else f=r;if(e==="otsu"){let g=xf(Q(Mf(f),"int32"),Er([]),256);l=PX(g,u)}let d=t?Xo(f,l):nr(f,l);return Q(R(d,255),"int32")}function PX(r,e){let t=Gt([-1]),n=Gt([0]),o=Gt([0]),s,a,i,u,l,p;for(let c=0;c<r.size-1;c++){s=We(r,0,c+1),a=We(r,c+1),l=pe(me(s),e),p=pe(me(a),e);let m=me(R(s,eu(0,s.size)));i=pe(m,me(s));let f=Ia(a.shape,s.size),d=Y(eu(0,a.size),f),h=R(a,d);u=pe(me(h),me(a));let g=ue(i,u),y=ue(i,u),x=R(l,p);o=R(R(x,g),y);let T=nr(o,n);n=zt(T,o,n),t=zt(T,Gt([c]),t)}return t}var u2=_({threshold_:DX});function FX(r,e,t="nearest",n="constant",o=0,s){let a=C(r,"image","transform","float32"),i=C(e,"transforms","transform","float32");D(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),D(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:a,transforms:i},l={interpolation:t,fillMode:n,fillValue:o,outputShape:s};return N.runKernel(ya,u,l)}var l2=_({transform_:FX});function MX(r,e,t){D(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),D(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);let n=C(r,"a","bandPart");D(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,a]=n.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=s),t<0&&(t=a);let i=L(eu(0,s,1,"int32"),[-1,1]),u=eu(0,a,1,"int32"),l=ue(i,u),p=jr(Xo(l,ce(+e,"int32")),qo(l,ce(-t,"int32"))),c=Tt([s,a],n.dtype);return L(fr(Br(L(n,[-1,s,a])).map(m=>zt(p,m,c))),o)}var p2=_({bandPart_:MX});function EX(r){let e;if(Array.isArray(r)){e=!1,D(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)D(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else e=!0,r=Ir(r,r.shape[0],0).map(o=>cn(o,[0]));D(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let t=[],n=r;for(let o=0;o<r.length;++o)t.push(N.tidy(()=>{let s=n[o];if(o>0)for(let a=0;a<o;++a){let i=R(me(R(t[a],s)),t[a]);s=ue(s,i)}return pe(s,wb(s,"euclidean"))}));return e?fr(t,0):t}var c2=_({gramSchmidt_:EX});function RX(r,e=!1){if(D(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return m2(r,e);{let t=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=Br(L(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,p]=m2(u,e);o.push(l),s.push(p)});let a=L(fr(o,0),r.shape),i=L(fr(s,0),r.shape);return[a,i]}}function m2(r,e=!1){return N.tidy(()=>{D(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let t=r.shape[0],n=r.shape[1],o=$c(t),s=Nn(r),a=Ja([[1]],[1,1]),i=Nn(a),u=t>=n?n:t;for(let l=0;l<u;++l){let p=s,c=i,m=o;[i,s,o]=N.tidy(()=>{let f=We(s,[l,l],[t-l,1]),d=wb(f),h=We(s,[l,l],[1,1]),g=zt(nr(h,0),Ja([[-1]]),Ja([[1]])),y=ue(h,R(g,d)),x=pe(f,y);x.shape[0]===1?i=Nn(a):i=lt([a,We(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);let T=et(pe(Ve(g,y),d)),k=We(s,[l,0],[t-l,n]),w=R(T,i),P=qe(i);if(l===0)s=ue(k,Ve(w,Ve(P,k)));else{let E=ue(k,Ve(w,Ve(P,k)));s=lt([We(s,[0,0],[l,n]),E],0)}let A=qe(w),F=We(o,[0,l],[t,o.shape[1]-l]);if(l===0)o=ue(F,Ve(Ve(F,i),A));else{let E=ue(F,Ve(Ve(F,i),A));o=lt([We(o,[0,0],[t,l]),E],1)}return[i,s,o]}),Ee([p,c,m])}return!e&&t>n&&(o=We(o,[0,0],[t,n]),s=We(s,[0,0],[n,n])),[o,s]})}var f2=_({qr_:RX});var or;(function(o){o[o.NONE=0]="NONE",o[o.MEAN=1]="MEAN",o[o.SUM=2]="SUM",o[o.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(or||(or={}));function LX(r,e,t=or.SUM_BY_NONZERO_WEIGHTS){let n=C(r,"losses","computeWeightedLoss"),o=null;e!=null&&(o=C(e,"weights","computeWeightedLoss"));let s=o==null?n:R(n,o);if(t===or.NONE)return s;if(t===or.SUM)return me(s);if(t===or.MEAN){if(o==null)return Rt(s);{let a=n.size/o.size,i=pe(me(s),me(o));return a>1?pe(i,ce(a)):i}}if(t===or.SUM_BY_NONZERO_WEIGHTS){if(o==null)return pe(me(s),ce(n.size));{let a=R(o,mr(n.shape)),i=Q(me(Za(a,ce(0))),"float32");return pe(me(s),i)}}throw Error(`Unknown reduction: ${t}`)}var qr=_({computeWeightedLoss_:LX});function $X(r,e,t,n=or.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","absoluteDifference"),s=C(e,"predictions","absoluteDifference"),a=null;t!=null&&(a=C(t,"weights","absoluteDifference")),Wt(o.shape,s.shape,"Error in absoluteDifference: ");let i=Ot(ue(o,s));return qr(i,a,n)}var d2=_({absoluteDifference_:$X});function BX(r,e,t,n,o=or.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","cosineDistance"),a=C(e,"predictions","cosineDistance"),i=null;n!=null&&(i=C(n,"weights","cosineDistance")),Wt(s.shape,a.shape,"Error in cosineDistance: ");let u=ce(1),l=ue(u,me(R(s,a),t,!0));return qr(l,i,o)}var h2=_({cosineDistance_:BX});function OX(r,e,t,n=or.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","hingeLoss"),s=C(e,"predictions","hingeLoss"),a=null;t!=null&&(a=C(t,"weights","hingeLoss")),Wt(o.shape,s.shape,"Error in hingeLoss: ");let i=ce(1);o=ue(R(ce(2),o),i);let u=Hr(ue(i,R(o,s)));return qr(u,a,n)}var g2=_({hingeLoss_:OX});function zX(r,e,t,n=1,o=or.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","huberLoss"),a=C(e,"predictions","huberLoss"),i=null;t!=null&&(i=C(t,"weights","huberLoss")),Wt(s.shape,a.shape,"Error in huberLoss: ");let u=ce(n),l=Ot(ue(a,s)),p=Ji(l,u),c=ue(l,p),m=Y(R(ce(.5),Xe(p)),R(u,c));return qr(m,i,o)}var b2=_({huberLoss_:zX});function GX(r,e,t,n=1e-7,o=or.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"labels","logLoss"),a=C(e,"predictions","logLoss"),i=null;t!=null&&(i=C(t,"weights","logLoss")),Wt(s.shape,a.shape,"Error in logLoss: ");let u=ce(1),l=ce(n),p=et(R(s,$r(Y(a,l)))),c=R(ue(u,s),$r(Y(ue(u,a),l))),m=ue(p,c);return qr(m,i,o)}var y2=_({logLoss_:GX});function WX(r,e,t,n=or.SUM_BY_NONZERO_WEIGHTS){let o=C(r,"labels","meanSquaredError"),s=C(e,"predictions","meanSquaredError"),a=null;t!=null&&(a=C(t,"weights","meanSquaredError")),Wt(o.shape,s.shape,"Error in meanSquaredError: ");let i=Gf(o,s);return qr(i,a,n)}var x2=_({meanSquaredError_:WX});function UX(r,e){let t=C(r,"labels","sigmoidCrossEntropyWithLogits"),n=C(e,"logits","sigmoidCrossEntropyWithLogits");Wt(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Hr(n),s=R(n,t),a=Ol(cr(et(Ot(n))));return Y(ue(o,s),a)}function KX(r,e,t,n=0,o=or.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"multiClassLabels","sigmoidCrossEntropy"),a=C(e,"logits","sigmoidCrossEntropy"),i=null;if(t!=null&&(i=C(t,"weights","sigmoidCrossEntropy")),Wt(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=ce(n),p=ce(1),c=ce(.5);s=Y(R(s,ue(p,l)),R(c,l))}let u=UX(s,a);return qr(u,i,o)}var T2=_({sigmoidCrossEntropy_:KX});function VX(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return pn((o,s,a)=>{let u=OI(s,[t],!0),l=ue(Q(s,"float32"),u);a([o,l]);let p=et(R(l,o));return{value:me(p,[t]),gradFunc:(f,d)=>{let[h,g]=d,y=Ns(f.shape,[t]);return[R(L(f,y),ue(Q(h,"float32"),cr(g))),R(L(f,y),ue(cr(g),Q(h,"float32")))]}}})(r,e)}function jX(r,e,t,n=0,o=or.SUM_BY_NONZERO_WEIGHTS){let s=C(r,"onehotLabels","softmaxCrossEntropy"),a=C(e,"logits","softmaxCrossEntropy"),i=null;if(t!=null&&(i=C(t,"weights","softmaxCrossEntropy")),Wt(s.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){let l=ce(n),p=ce(1),c=ce(s.shape[1]);s=Y(R(s,ue(p,l)),pe(l,c))}let u=VX(s,a);return qr(u,i,o)}var k2=_({softmaxCrossEntropy_:jX});function HX(r,e,t,n){let o=C(r,"indices","sparseFillEmptyRows"),s=C(e,"values","sparseFillEmptyRows"),a=C(t,"denseShape","sparseFillEmptyRows"),i=C(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let u={indices:o,values:s,denseShape:a,defaultValue:i},l=N.runKernel(gc,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var I2=_({sparseFillEmptyRows_:HX});function qX(r,e,t){let n=C(r,"inputIndices","sparseReshape"),o=C(e,"inputShape","sparseReshape"),s=C(t,"newShape","sparseReshape");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let a={inputIndices:n,inputShape:o,newShape:s},i=N.runKernel(bc,a);return{outputIndices:i[0],outputShape:i[1]}}var C2=_({sparseReshape_:qX});function XX(r,e,t){let n=C(r,"data","sparseSegmentMean"),o=C(e,"indices","sparseSegmentMean"),s=C(t,"segmentIds","sparseSegmentMean");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return N.runKernel(yc,a)}var v2=_({sparseSegmentMean_:XX});function YX(r,e,t){let n=C(r,"data","sparseSegmentSum"),o=C(e,"indices","sparseSegmentSum"),s=C(t,"segmentIds","sparseSegmentSum");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return N.runKernel(xc,a)}var w2=_({sparseSegmentSum_:YX});function QX(r,e,t,n,o,s,a,i){let u=C(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=C(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let p={separator:t,nGramWidths:n,leftPad:o,rightPad:s,padWidth:a,preserveShortSequences:i},c={data:u,dataSplits:l},m=N.runKernel(Ou,c,p);return{nGrams:m[0],nGramsSplits:m[1]}}var S2=_({stringNGrams_:QX});function ZX(r,e,t=!0){let n=C(r,"input","stringSplit","string"),o=C(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},a={input:n,delimiter:o},i=N.runKernel(Tc,a,s);return{indices:i[0],values:i[1],shape:i[2]}}var _2=_({stringSplit_:ZX});function JX(r,e){let t=C(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return N.runKernel(kc,o,n)}var A2=_({stringToHashBucketFast_:JX});var yKe={fft:jl,ifft:Hu,rfft:Hl,irfft:zf},CKe={hammingWindow:j0,hannWindow:Db,frame:Pb,stft:H0},Mn={flipLeftRight:X0,grayscaleToRGB:Y0,resizeNearestNeighbor:i2,resizeBilinear:a2,rotateWithOffset:Q0,cropAndResize:q0,nonMaxSuppression:Z0,nonMaxSuppressionAsync:t2,nonMaxSuppressionWithScore:r2,nonMaxSuppressionWithScoreAsync:n2,nonMaxSuppressionPadded:o2,nonMaxSuppressionPaddedAsync:s2,threshold:u2,transform:l2},N2={bandPart:p2,gramSchmidt:c2,qr:f2},YKe={absoluteDifference:d2,computeWeightedLoss:qr,cosineDistance:h2,hingeLoss:g2,huberLoss:b2,logLoss:y2,meanSquaredError:x2,sigmoidCrossEntropy:T2,softmaxCrossEntropy:k2},Uf={sparseFillEmptyRows:I2,sparseReshape:C2,sparseSegmentMean:v2,sparseSegmentSum:w2},Rb={stringNGrams:S2,stringSplit:_2,stringToHashBucketFast:A2};var Zr=class extends fb{minimize(e,t=!1,n){let{value:o,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return Ee(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return bb(e,t)}dispose(){this.iterations_!=null&&Ee(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ce(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Zr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var Jl=class extends Zr{constructor(e,t,n=null){super();this.learningRate=e;this.rho=t;this.epsilon=n;this.accumulatedGrads=[];this.accumulatedUpdates=[];n==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n],a=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:G(()=>De(s).variable(a))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:G(()=>De(s).variable(a))});let i=Array.isArray(e)?e[o].tensor:e[n];if(i==null)return;let u=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;G(()=>{let p=Y(R(u,this.rho),R(Xe(i),1-this.rho)),c=R(pe(Lt(Y(l,this.epsilon)),Lt(Y(u,this.epsilon))),i),m=Y(R(l,this.rho),R(Xe(c),1-this.rho));u.assign(p),l.assign(m);let f=Y(R(c,-this.learningRate),s);s.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Ee(this.accumulatedGrads.map(e=>e.variable)),Ee(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};Jl.className="Adadelta";Dn(Jl);var ep=class extends Zr{constructor(e,t=.1){super();this.learningRate=e;this.initialAccumulatorValue=t;this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n];if(this.accumulatedGrads[o]==null){let u=!1;this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:G(()=>Ia(s.shape,this.initialAccumulatorValue).variable(u))}}let a=Array.isArray(e)?e[o].tensor:e[n];if(a==null)return;let i=this.accumulatedGrads[o].variable;G(()=>{let u=Y(i,Xe(a));i.assign(u);let l=Y(R(pe(a,Lt(Y(u,N.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Ee(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};ep.className="Adagrad";Dn(ep);var tp=class extends Zr{constructor(e,t,n,o=null){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=o;this.accumulatedFirstMoment=[];this.accumulatedSecondMoment=[];G(()=>{this.accBeta1=ce(t).variable(),this.accBeta2=ce(n).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);G(()=>{let n=ue(1,this.accBeta1),o=ue(1,this.accBeta2);t.forEach((s,a)=>{let i=N.registeredVariables[s],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:G(()=>De(i).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:G(()=>De(i).variable(u))});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let p=this.accumulatedFirstMoment[a].variable,c=this.accumulatedSecondMoment[a].variable,m=Y(R(p,this.beta1),R(l,1-this.beta1)),f=Y(R(c,this.beta2),R(Xe(l),1-this.beta2)),d=pe(m,n),h=pe(f,o);p.assign(m),c.assign(f);let g=Y(R(pe(d,Y(Lt(h),this.epsilon)),-this.learningRate),i);i.assign(g)}),this.accBeta1.assign(R(this.accBeta1,this.beta1)),this.accBeta2.assign(R(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Ee(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),G(()=>{this.accBeta1.assign(Fn(this.beta1,this.iterations_+1)),this.accBeta2.assign(Fn(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};tp.className="Adam";Dn(tp);var rp=class extends Zr{constructor(e,t,n,o=null,s=0){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=o;this.decay=s;this.accumulatedFirstMoment=[];this.accumulatedWeightedInfNorm=[];G(()=>{this.iteration=ce(0).variable(),this.accBeta1=ce(t).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);G(()=>{let n=ue(1,this.accBeta1),o=pe(-this.learningRate,Y(R(this.iteration,this.decay),1));t.forEach((s,a)=>{let i=N.registeredVariables[s],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:De(i).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:De(i).variable(u)});let l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;let p=this.accumulatedFirstMoment[a].variable,c=this.accumulatedWeightedInfNorm[a].variable,m=Y(R(p,this.beta1),R(l,1-this.beta1)),f=R(c,this.beta2),d=Ot(l),h=Xn(f,d);p.assign(m),c.assign(h);let g=Y(R(pe(o,n),pe(m,Y(h,this.epsilon))),i);i.assign(g)}),this.iteration.assign(Y(this.iteration,1)),this.accBeta1.assign(R(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Ee(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Ee(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};rp.className="Adamax";Dn(rp);var ru=class extends Zr{constructor(e){super();this.learningRate=e;this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=Array.isArray(e)?e[o].tensor:e[n];if(s==null)return;let a=N.registeredVariables[n];G(()=>{let i=Y(R(this.c,s),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Kt(ce(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};ru.className="SGD";Dn(ru);var np=class extends ru{constructor(e,t,n=!1){super(e);this.learningRate=e;this.momentum=t;this.useNesterov=n;this.accumulations=[];this.m=ce(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n];if(this.accumulations[o]==null){let u=!1;this.accumulations[o]={originalName:`${n}/momentum`,variable:G(()=>De(s).variable(u))}}let a=this.accumulations[o].variable,i=Array.isArray(e)?e[o].tensor:e[n];i!=null&&G(()=>{let u,l=Y(R(this.m,a),i);this.useNesterov?u=Y(R(this.c,Y(i,R(l,this.m))),s):u=Y(R(this.c,l),s),a.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Ee(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};np.className="Momentum";Dn(np);var op=class extends Zr{constructor(e,t=.9,n=0,o=null,s=!1){super();this.learningRate=e;this.decay=t;this.momentum=n;this.epsilon=o;this.accumulatedMeanSquares=[];this.accumulatedMoments=[];this.accumulatedMeanGrads=[];if(this.centered=s,o==null&&(this.epsilon=N.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n],a=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:G(()=>De(s).variable(a))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:G(()=>De(s).variable(a))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:G(()=>De(s).variable(a))});let i=Array.isArray(e)?e[o].tensor:e[n];if(i==null)return;let u=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;G(()=>{let p=Y(R(u,this.decay),R(Xe(i),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[o].variable,m=Y(R(c,this.decay),R(i,1-this.decay)),f=pe(R(i,this.learningRate),Lt(ue(p,Y(Xe(m),this.epsilon)))),d=Y(R(l,this.momentum),f);u.assign(p),c.assign(m),l.assign(d);let h=ue(s,d);s.assign(h)}else{let c=Y(R(u,this.decay),R(Xe(i),1-this.decay)),m=Y(R(l,this.momentum),pe(R(i,this.learningRate),Lt(Y(c,this.epsilon))));u.assign(c),l.assign(m);let f=ue(s,m);s.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Ee(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Ee(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Ee(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};op.className="RMSProp";Dn(op);var nu=class{static sgd(e){return new ru(e)}static momentum(e,t,n=!1){return new np(e,t,n)}static rmsprop(e,t=.9,n=0,o=null,s=!1){return new op(e,t,n,o,s)}static adam(e=.001,t=.9,n=.999,o=null){return new tp(e,t,n,o)}static adadelta(e=.001,t=.95,n=null){return new Jl(e,t,n)}static adamax(e=.002,t=.9,n=.999,o=null,s=0){return new rp(e,t,n,o,s)}static adagrad(e,t=.1){return new ep(e,t)}};var sp={sgd:nu.sgd,momentum:nu.momentum,adadelta:nu.adadelta,adagrad:nu.adagrad,rmsprop:nu.rmsprop,adamax:nu.adamax,adam:nu.adam};var eY=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function uC(){return new Promise(r=>eY(()=>r()))}var I={};Qe(I,{ERF_A1:()=>cY,ERF_A2:()=>mY,ERF_A3:()=>fY,ERF_A4:()=>dY,ERF_A5:()=>hY,ERF_P:()=>pY,PARALLELIZE_THRESHOLD:()=>Lb,SELU_SCALE:()=>pC,SELU_SCALEALPHA:()=>lC,applyActivation:()=>Ql,assertAndGetBroadcastShape:()=>je,assertAxesAreInnerMostDims:()=>e5,assertParamsConsistent:()=>tY,assignToTypedArray:()=>kY,axesAreInnerMostDims:()=>LI,calculateShapes:()=>e0,checkEinsumDimSizes:()=>_Y,combineLocations:()=>x0,complexWithEvenIndex:()=>yY,complexWithOddIndex:()=>xY,computeConv2DInfo:()=>Pl,computeConv3DInfo:()=>g0,computeDefaultPad:()=>dI,computeDilation2DInfo:()=>Tq,computeOptimalWindowSize:()=>nY,computeOutAndReduceShapes:()=>$I,computeOutShape:()=>rY,computePool2DInfo:()=>fI,computePool3DInfo:()=>kq,convertConv2DDataFormat:()=>b0,decodeEinsumEquation:()=>wY,eitherStridesOrDilationsAreOne:()=>Rr,expandShapeToKeepDim:()=>Ns,exponent:()=>CY,exponents:()=>IY,fromStringArrayToUint8:()=>LY,fromUint8ToStringArray:()=>RY,getAxesPermutation:()=>BI,getBroadcastDims:()=>c6,getComplexWithIndex:()=>TY,getEinsumComputePath:()=>AY,getEinsumPermutation:()=>SY,getFusedBiasGradient:()=>Yl,getFusedDyActivation:()=>Xl,getImageCenter:()=>oY,getInnerMostAxes:()=>t5,getPermuted:()=>aY,getReductionAxes:()=>Dt,getReshaped:()=>sY,getReshapedPermuted:()=>iY,getSliceBeginCoords:()=>uY,getSliceSize:()=>lY,getUndoAxesPermutation:()=>_f,isIdentityPermutation:()=>NY,log:()=>Rj,mergeRealAndImagArrays:()=>gY,prepareAndValidate:()=>JD,prepareSplitSize:()=>PY,segment_util:()=>mC,shouldFuse:()=>Zl,slice_util:()=>Xt,splitRealAndImagArrays:()=>bY,tupleValuesAreOne:()=>Ho,upcastType:()=>Ut,validateInput:()=>pb,validateUpdateShape:()=>Jk,warn:()=>ro});function tY(r,e){let t=r[0].length;r.forEach((o,s)=>{D(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),D(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let n=r[0];r.forEach((o,s)=>{for(let a=0;a<t;a++)D(a===e||o[a]===n[a],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function rY(r,e){let t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}var Lb=30;function nY(r){return r<=Lb?r:jp(r,Math.floor(Math.sqrt(r)))}function oY(r,e,t){let n=t*(typeof r=="number"?r:r[0]),o=e*(typeof r=="number"?r:r[1]);return[n,o]}function sY(r,e,t,n=!0){let o=[];if(n)o=o.concat(e.slice(0)),o.push(r[0]/t),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=e.length;for(let a=0;a<s;++a)o=o.concat([r[a+1]/e[a],e[a]]);o=o.concat(r.slice(s+1))}return o}function aY(r,e,t=!0){let n=[];if(t){n.push(e);for(let o=e+1;o<r;++o)o<=2*e?(n.push(o),n.push(o-(e+1))):n.push(o)}else{let o=[],s=[];for(let a=1;a<r;++a)a>=e*2+1||a%2==1?s.push(a):o.push(a);n.push(...o),n.push(0),n.push(...s)}return n}function iY(r,e,t,n=!0){let o=[];n?o.push(r[0]/t):o.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?o.push(e[s-1]*r[s]):o.push(r[s]/e[s-1]):o.push(r[s]);return o}function uY(r,e){let t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function lY(r,e,t){let n=r.slice(0,1);for(let o=0;o<t;++o)n.push(r[o+1]-e[o][0]-e[o][1]);return n}var lC=1.7580993408473768,pC=1.0507009873554805;var pY=.3275911,cY=.254829592,mY=-.284496736,fY=1.421413741,dY=-1.453152027,hY=1.061405429;function gY(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);let t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}function bY(r){let e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)e[n/2]=r[n],t[n/2]=r[n+1];return{real:e,imag:t}}function yY(r){let e=Math.ceil(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=0;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function xY(r){let e=Math.floor(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=2;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function TY(r,e){let t=r[e*2],n=r[e*2+1];return{real:t,imag:n}}function kY(r,e,t,n){r[n*2]=e,r[n*2+1]=t}function IY(r,e){let t=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(e?2:-2)*Math.PI*(o/r);t[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:t,imag:n}}function CY(r,e,t){let n=(t?2:-2)*Math.PI*(r/e),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var cC="->",vY=/->/g,D2=",",P2="...";function wY(r,e){r=r.replace(/\s/g,"");let t=(r.length-r.replace(vY,"").length)/cC.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${cC}").`);let[n,o]=r.split(cC);D(n.indexOf(P2)===-1,()=>`The ellipsis notation ("${P2}") is not supported yet.`);let s=n.split(D2),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let m=0;m<o.length;++m){let f=o[m];if(!s.some(d=>d.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);i.indexOf(f)===-1&&i.push(f)}for(let m=0;m<n.length;++m){let f=n[m];i.indexOf(f)===-1&&f!==D2&&i.push(f)}let u=new Array(s.length);for(let m=0;m<a;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let f=0;f<s[m].length;++f)u[m].push(i.indexOf(s[m][f]))}let l=i.length,p=o.length,c=[];for(let m=p;m<l;++m)c.push(m);return{allDims:i,summedDims:c,idDims:u}}function SY(r,e){let t=new Array(r);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let n=[];for(let o=0;o<r;++o)t[o]===-1&&n.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:n}}function _Y(r,e,t){let n=new Array(r);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let a=0;a<e[o].length;++a)n[e[o][a]]===void 0?n[e[o][a]]=s[a]:D(n[e[o][a]]===s[a],()=>`Expected dimension ${n[e[o][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function AY(r,e){let t=r,n=[],o=0;r.length===0&&t.push(-1),o=r.length+1;for(let a=0;a<o;++a)n.push([]);let s=[];for(let a=0;a<t.length;++a){let i=t[a],u=DY(e,i);for(let l of u)s.indexOf(l)===-1&&(n[a].push(l),s.push(l))}return{path:t,steps:n}}function NY(r){return r.every((e,t)=>e===t)}function DY(r,e){let t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function PY(r,e,t=0){let n=[];if(typeof e=="number")D(r.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{let o=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);D(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let a=e.reduce((i,u)=>u>0?i+u:i);e[s]=r.shape[t]-a}D(r.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}var mC={};Qe(mC,{collectGatherOpShapeInfo:()=>EY,computeOutShape:()=>MY,segOpComputeOptimalWindowSize:()=>FY});function FY(r,e){let t=!1,n;for(r<=Lb?(n=r,t=!0):n=jp(r,Math.floor(Math.sqrt(r)));!t;)n>e||n===r?t=!0:n=jp(r,n+1);return n}function MY(r,e,t){let n=[],o=r.length;for(let s=0;s<o;s++)s!==e?n.push(r[s]):n.push(t);return n}function EY(r,e,t,n){let o=e.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let c=0;c<n;++c)if(r.shape[c]!==e.shape[c])throw new Error(`x.shape[${c}]: ${r.shape[c]} should be equal to indices.shape[${c}]: ${e.shape[c]}.`);let a=r.shape[t],i=[],u=1,l=1,p=1;for(let c=0;c<n;++c)i.push(r.shape[c]),u*=r.shape[c];for(let c=n;c<t;c++)i.push(r.shape[c]),l*=r.shape[c];for(let c=n;c<o;c++)i.push(e.shape[c]);for(let c=t+1;c<s;c++)i.push(r.shape[c]),p*=r.shape[c];return{batchSize:u,sliceSize:p,outerSize:l,dimSize:a,outputShape:i}}function RY(r){try{return r.map(e=>_c(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function LY(r){return r.map(e=>Wu(e))}var Tr={};Qe(Tr,{nonMaxSuppressionV3Impl:()=>Fb,nonMaxSuppressionV4Impl:()=>Mb,nonMaxSuppressionV5Impl:()=>Eb,whereImpl:()=>vb});var $b={kernelName:as,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,tu(Q(t,"float32"),-1))}}};var F2={kernelName:bi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Xe(Q(t,"float32")),o=Lt(ue(ce(1),n));return et(pe(r,o))}}}};var M2={kernelName:yi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Lt(ue(Xe(Q(t,"float32")),1));return pe(r,n)}}}};var E2={kernelName:_n,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=je(t.shape,n.shape);return{a:()=>{let i=r,u=Dt(t.shape,o);return u.length>0&&(i=me(i,u)),L(i,t.shape)},b:()=>{let i=r,u=Dt(n.shape,o);return u.length>0&&(i=me(i,u)),L(i,n.shape)}}}};var R2={kernelName:no,saveAllInputs:!0,gradFunc:(r,e)=>{let t={};return e.forEach((n,o)=>{t[o]=()=>r.clone()}),t}};var L2={kernelName:oo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>De(t)}}};var $2={kernelName:Wa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>De(t)}}};var B2={kernelName:ki,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,Lt(ue(ce(1),Xe(Q(t,"float32")))))}}};var O2={kernelName:Ii,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Lt(Y(ce(1),Xe(Q(t,"float32"))));return pe(r,n)}}}};var z2={kernelName:wi,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=je(t.shape,n.shape);return{a:()=>{let i=Y(Xe(t),Xe(n)),u=R(r,pe(n,i)),l=Dt(t.shape,o);return l.length>0&&(u=me(u,l)),L(u,t.shape)},b:()=>{let i=Y(Xe(t),Xe(n)),u=et(R(r,pe(t,i))),l=Dt(n.shape,o);return l.length>0&&(u=me(u,l)),L(u,n.shape)}}}};var G2={kernelName:Ci,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,Y(Xe(Q(t,"float32")),1))}}};var W2={kernelName:vi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,ue(ce(1),Xe(Q(t,"float32"))))}}};function $Y(r,e,t,n,o,s){let a=C(r,"dy","avgPool3dGrad"),i=C(e,"input","avgPool3dGrad"),u=a,l=i,p=!1;i.rank===4&&(p=!0,u=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),l=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),D(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),s!=null&&D(mt(o),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${s} but got pad ${o}.`);let c={dy:u,input:l},m={filterSize:t,strides:n,pad:o,dimRoundingMode:s},f=N.runKernel(Xp,c,m);return p?L(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}var U2=_({avgPool3dGrad_:$Y});var K2={kernelName:Au,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a,dimRoundingMode:i}=t;return{x:()=>U2(r,n,o,s,a,i)}}};function BY(r,e,t,n,o){let s=C(r,"dy","avgPoolGrad"),a=C(e,"input","avgPoolGrad");D(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let i=a,u=s,l=!1;a.rank===3&&(l=!0,i=L(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),D(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let p={dy:u,input:i},c={filterSize:t,strides:n,pad:o},m=N.runKernel(qp,p,c);return l?L(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var V2=_({avgPoolGrad_:BY});var j2={kernelName:so,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a}=t;return{x:()=>V2(r,n,o,s,a)}}};var H2={kernelName:ao,inputsToSave:["a","b"],gradFunc:(r,e,t)=>{let[n,o]=e,{transposeA:s,transposeB:a}=t;return!s&&!a?{a:()=>Ve(r,o,!1,!0),b:()=>Ve(n,r,!0,!1)}:!s&&a?{a:()=>Ve(r,o,!1,!1),b:()=>Ve(r,n,!0,!1)}:s&&!a?{a:()=>Ve(o,r,!1,!0),b:()=>Ve(n,r,!1,!1)}:{a:()=>Ve(o,r,!0,!0),b:()=>Ve(r,n,!0,!0)}}};var q2={kernelName:is,gradFunc:(r,e,t)=>{let{blockShape:n,crops:o}=t;return{x:()=>Wl(r,n,o)}}};var X2={kernelName:GN,gradFunc:(r,e,t)=>{let n=t,o=n.inputShape,s=n.shape,a=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])a[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let i=[];for(let u=0;u<a.length;u++)a[u]>1&&i.push(u);return{x:()=>me(r,i,!0)}}};var Y2={kernelName:Wn,gradFunc:r=>({x:()=>r.clone()})};var Q2={kernelName:io,gradFunc:r=>({x:()=>De(r)})};var Z2={kernelName:Un,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{clipValueMin:o,clipValueMax:s}=t;return{x:()=>zt(jr(qo(n,o),Xo(n,s)),r,De(r))}}};var J2={kernelName:Du,inputsToSave:["x"],gradFunc:$b.gradFunc};var e1={kernelName:us,saveAllInputs:!0,gradFunc:(r,e,t)=>{let n=e.map(u=>u.shape),{axis:o}=t,s=yr(o,e[0].shape)[0],a=n.map(u=>u[s]);return Ir(r,a,s).map(u=>()=>u)}};var t1={kernelName:uo,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{dilations:s,strides:a,pad:i,dataFormat:u}=t;return D(Ho(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>Lc(n.shape,r,o,a,i,u),filter:()=>Wc(n,r,o.shape,a,i,u)}}};var r1={kernelName:lo,inputsToSave:["dy","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{strides:s,pad:a,dataFormat:i,dimRoundingMode:u}=t;return{dy:()=>qn(r,o,s,a,i,1,u),filter:()=>Wc(r,n,o.shape,s,a,i,u)}}};function OY(r,e,t,n,o){let s=r;r.rank===4&&(s=L(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let a=e;a.rank===4&&(a=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),D(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),D(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),D(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),D(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),D(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);let i={x:s,dy:a},u={strides:n,pad:o,filterShape:t};return N.runKernel(Jp,i,u)}var n1=_({conv3DBackpropFilter_:OY});var o1={kernelName:Pu,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s}=t;D(Ho(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[a,i]=e;return{x:()=>gb(a.shape,r,i,o,s),filter:()=>n1(a,r,i.shape,o,s)}}};var s1={kernelName:po,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(et(Lf(Q(t,"float32"))),r)}}};var a1={kernelName:co,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R($f(Q(t,"float32")),r)}}};var i1={kernelName:Xs,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o,exclusive:s,reverse:a}=t;return{x:()=>{let i=BI([o],n.rank),u=vf(r,o,s,!a);return i!=null&&(u=qe(u,i)),u}}}};var u1={kernelName:mo,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:a}=t,i=n??[1,1];D(Ho(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[u,l]=e;return D(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),D(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),D(Rr(o,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${i}'.`),a!=null&&D(mt(s),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`),{x:()=>Nb(u.shape,r,l,o,s,i,a),filter:()=>Ab(u,r,l.shape,o,s,i,a)}}};var l1={kernelName:Fu,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,s={x:n,filter:o,dy:r},a={x:n,filter:o,dy:r};return{x:()=>N.runKernel(nf,s,t),filter:()=>N.runKernel(of,a,t)}}};var p1={kernelName:ho,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e,n={dy:r,y:t};return{x:()=>N.runKernel(sc,n)}}};var c1={kernelName:Si,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=R(cr(et(Xe(t))),2/Math.sqrt(Math.PI));return{x:()=>R(r,n)}}};var m1={kernelName:go,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,t)}}};var f1={kernelName:ls,inputsToSave:["input"],gradFunc:(r,e)=>{let[t]=e;return{input:()=>L(r,t.shape)}}};var d1={kernelName:Js,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,cr(t))}}};var h1={kernelName:bo,gradFunc:r=>({x:()=>De(r)})};var g1={kernelName:yo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=je(t.shape,n.shape);return{a:()=>{let i=pe(r,Q(n,"float32")),u=Dt(t.shape,o);return u.length>0?L(me(i,u),t.shape):i},b:()=>{let i=R(r,Q(t,"float32")),u=Dt(n.shape,o);u.length>0&&(i=L(me(i,u),n.shape));let l=Xe(n);return et(pe(i,Q(l,"float32")))}}}};var b1={kernelName:xo,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,e,t)=>{let{varianceEpsilon:n}=t,[o,s,a,i]=e,u=i??ce(1),l=Dt(s.shape,o.shape),p=[];if(s.rank===1){for(let k=0;k<o.shape.length-1;++k)p.push(o.shape[k]);p.push(1)}let c=ue(o,s),m=R(r,u),f=Ef(Y(a,ce(n))),d=R(R(R(f,f),f),ce(-.5));return{x:()=>s.rank===1?L(R(R(r,Vr(L(f,[1,1,1,s.shape[0]]),p)),u),o.shape):L(R(R(r,f),u),o.shape),mean:()=>{let k=R(R(f,ce(-1)),m);return s.rank===1&&(k=me(k,l)),L(k,s.shape)},variance:()=>{let k=R(R(d,c),m);return s.rank===1&&(k=me(k,l)),L(k,s.shape)},scale:()=>{let k=R(c,f),w=R(r,k);return s.rank===1&&(w=me(w,l)),L(w,s.shape)},offset:()=>{let k=r;return s.rank===1&&(k=me(k,l)),L(k,s.shape)}}}};var y1={kernelName:ps,inputsToSave:["x","indices"],gradFunc:(r,e,t)=>{let[n,o]=e,{axis:s}=t,a=yr(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,p=u.slice(0,a),c=p.length,m=u.slice(s,u.length).slice(1),f=m.length,d=x1(0,c),h=x1(c+1,c+1+f),g=T1([p,[l],m]),y=L(r,g),x=L(o,[l]),T=T1([[c],d,h]),k=qe(y,T),w=sC(k,x,n.shape[a]),P=_f(T);return w=qe(w,P),w},indices:()=>o}}};function x1(r,e){let t=[];for(let n=r;n<e;++n)t.push(n);return t}function T1(r){let e=[];for(let t=0;t<r.length;++t)for(let n=0;n<r[t].length;++n)e.push(r[t][n]);return e}var k1={kernelName:To,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>De(t),b:()=>De(n)}}};var I1={kernelName:Kn,gradFunc:r=>({x:()=>Q(r,"float32")})};var C1={kernelName:_i,gradFunc:r=>({x:()=>De(r)})};var v1={kernelName:Ai,gradFunc:r=>({x:()=>De(r)})};var w1={kernelName:Ni,gradFunc:r=>({x:()=>De(r)})};var S1={kernelName:na,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{alpha:o}=t,s=nr(n,0);return{x:()=>zt(s,r,R(r,o))}}};var _1={kernelName:Di,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,Y(t,1))}}};var A1={kernelName:ko,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,Q(t,"float32"))}}};var N1={kernelName:WN,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t;return{logits:()=>{let s=!0,a=cr(n);return ue(r,R(me(r,o,s),a))}}}};function zY(r,e,t,n=5,o=1,s=1,a=.5){let i={x:r,y:e,dy:t},u={depthRadius:n,bias:o,alpha:s,beta:a};return N.runKernel(lc,i,u)}var D1=_({localResponseNormalizationBackprop_:zY});var P1={kernelName:Ru,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{depthRadius:s,bias:a,alpha:i,beta:u}=t;return{x:()=>D1(n,o,r,s,a,i,u)}}};function Bb(r,e,t,n){return e.rank<t.rank&&(e=L(e,Ns(e.shape,n))),r.rank<t.rank&&(r=L(r,Ns(r.shape,n))),{x:()=>R(r,Q(Kr(t,e),r.dtype))}}var fC={kernelName:Io,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{reductionIndices:o}=n,s=e[0],a=e[1],i=yr(o,s.shape),u=Bb(r,a,s,i);return{x:()=>u.x()}}};var F1={kernelName:Co,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>R(r,Q(qo(t,n),"float32")),b:()=>R(r,Q(wf(t,n),"float32"))}}};function GY(r,e,t,n,o,s,a){let i=C(r,"dy","maxPool3dGrad"),u=C(e,"input","maxPool3dGrad"),l=C(t,"output","maxPool3dGrad"),p=i,c=u,m=l,f=!1;u.rank===4&&(f=!0,p=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),c=L(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=L(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),D(p.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),D(c.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),D(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),a!=null&&D(mt(s),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let d={dy:p,input:c,output:m},h={filterSize:n,strides:o,pad:s,dimRoundingMode:a},g=N.runKernel(cc,d,h);return f?L(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var M1=_({maxPool3dGrad_:GY});var E1={kernelName:Lu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=t;return{x:()=>M1(r,n,o,s,a,i,u)}}};function WY(r,e,t,n,o,s,a){let i=C(r,"dy","maxPoolGrad"),u=C(e,"input","maxPoolGrad"),l=C(t,"output","maxPoolGrad");D(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),D(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),D(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),a!=null&&D(mt(s),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let p={dy:i,input:u,output:l},c={filterSize:n,strides:o,pad:s,dimRoundingMode:a};return N.runKernel(pc,p,c)}var R1=_({maxPoolGrad_:WY});var L1={kernelName:vo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i}=t;return{x:()=>R1(r,n,o,s,a,i)}}};var $1={kernelName:wo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t,s=yr(o,n.shape),i=$I(n.shape,s)[1],u=ct(i);return{x:()=>{let p=n.shape.slice();s.forEach(f=>{p[f]=1});let c=L(r,p);return pe(R(c,mr(n.shape,"float32")),u)}}}};var B1={kernelName:So,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{axis:o}=n,[s,a]=e,i=yr(o,s.shape),u=Bb(r,a,s,i);return{x:()=>u.x()}}};var O1={kernelName:_o,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>R(r,Q(Xo(t,n),"float32")),b:()=>R(r,Q(nr(t,n),"float32"))}}};var z1={kernelName:Ao,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>We(r,s,n.shape)}}};var G1={kernelName:Fi,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=je(t.shape,n.shape);return{a:()=>{let i=Dt(t.shape,o);return i.length>0?L(me(r,i),t.shape):r},b:()=>{let i=R(r,et(Zi(pe(t,n)))),u=Dt(n.shape,o);return u.length>0?L(me(i,u),n.shape):i}}}};var W1={kernelName:No,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=je(t.shape,n.shape);return{a:()=>{let i=R(r,Q(n,"float32")),u=Dt(t.shape,o);return u.length>0?L(me(i,u),t.shape):i},b:()=>{let i=R(r,Q(t,"float32")),u=Dt(n.shape,o);return u.length>0?L(me(i,u),n.shape):i}}}};var U1={kernelName:cs,gradFunc:r=>({x:()=>et(r)})};var K1={kernelName:pa,inputsToSave:["indices"],gradFunc:(r,e)=>{let t=e[0];return{indices:()=>Tt(t.shape,"float32")}}};var V1={kernelName:ms,gradFunc:r=>({x:()=>De(r)})};var j1={kernelName:fs,saveAllInputs:!0,gradFunc:(r,e,t)=>{let{axis:n}=t;return Br(r,n).map(s=>()=>s)}};var dC={kernelName:Do,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>We(r,s,n.shape)}}};var H1={kernelName:Po,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,e)=>{let[t,n,o]=e,s=t,a=n,i=je(s.shape,a.shape);return{a:()=>{let p=Q(a,"float32"),c=R(r,R(p,Fn(s,ue(p,ce(1))))),m=Dt(s.shape,i);return m.length>0&&(c=me(c,m)),L(c,s.shape)},b:()=>{let p=nr(s,0),c=zt(p,$r(s),De(s)),m=R(r,R(o,c)),f=Dt(a.shape,i);return f.length>0&&(m=me(m,f)),L(m,a.shape)}}}};var q1={kernelName:Fo,inputsToSave:["x","alpha"],gradFunc:(r,e)=>{let[t,n]=e,o=nr(t,0);return{x:()=>zt(o,r,R(r,n)),alpha:()=>{let s=zt(o,De(r),R(r,t)),a=Dt(n.shape,r.shape);return a.length>0&&(s=me(s,a)),L(s,n.shape)}}}};var X1={kernelName:fo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=je(t.shape,n.shape);return{a:()=>{let i=pe(r,Q(n,"float32")),u=Dt(t.shape,o);return u.length>0?L(me(i,u),t.shape):i},b:()=>{let i=R(r,Q(t,"float32")),u=Dt(n.shape,o);u.length>0&&(i=L(me(i,u),n.shape));let l=Xe(n);return et(pe(i,Q(l,"float32")))}}}};var Y1={kernelName:Ei,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,et(Xe(t)))}}};var Q1={kernelName:Ro,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=R(Xo(t,6),tu(t));return{x:()=>R(r,Q(n,"float32"))}}};var Z1={kernelName:Mo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,Q(tu(t),"float32"))}}};var J1={kernelName:ds,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>L(r,t.shape)}}};var eP={kernelName:Eo,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(hc,o,t)}}};var tP={kernelName:Va,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(dc,o,t)}}};var rP={kernelName:ma,gradFunc:(r,e,t)=>{let{dims:n}=t,o=yr(n,r.shape);return{x:()=>xr(r,o)}}};var nP={kernelName:fa,gradFunc:r=>({x:()=>De(r)})};var oP={kernelName:Lo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>et(pe(r,R(Fn(t,1.5),2)))}}};var sP={kernelName:hs,inputsToSave:["condition"],gradFunc:(r,e)=>{let[t]=e;return{condition:()=>Q(De(t),"float32"),t:()=>R(r,Q(t,r.dtype)),e:()=>R(r,Q(zl(t),r.dtype))}}};var aP={kernelName:Ri,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=nr(t,ce(0)),o=ce(lC),s=ce(pC),a=R(r,s),i=R(R(r,o),cr(Q(t,"float32")));return zt(n,a,i)}}}};var iP={kernelName:Bo,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,R(t,ue(ce(1),t)))}}};var uP={kernelName:Li,gradFunc:r=>({x:()=>De(r)})};var lP={kernelName:$o,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(Ll(Q(t,"float32")),r)}}};var pP={kernelName:ha,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(Cf(Q(t,"float32")),r)}}};var cP={kernelName:gs,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{begin:o,size:s}=t,a=n.shape,[i,u]=eI(n,o,s),l=[];for(let p=0;p<r.rank;p++)l.push([i[p],a[p]-i[p]-u[p]]);return{x:()=>Pn(r,l)}}};var mP={kernelName:Go,outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{dim:o}=t,s=!0,a=R(r,n);return{logits:()=>ue(a,R(me(a,[o],s),n))}}};var fP={kernelName:$i,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,ln(t))}}};var hC={kernelName:bs,gradFunc:(r,e,t)=>{let{blockShape:n,paddings:o}=t;return{x:()=>El(r,n,o)}}};var gC={kernelName:ys,gradFunc:(r,e,t)=>{let{axis:n}=t;return{x:()=>lt(r,n)}}};var dP={kernelName:Oo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,R(Lt(Q(t,"float32")),2))}}};var hP={kernelName:ja,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,R(Q(t,"float32"),2))}}};var gP={kernelName:Wo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=ce(2);return{a:()=>R(r,R(o,ue(t,n))),b:()=>R(r,R(o,ue(n,t)))}}};var bP={kernelName:ks,gradFunc:r=>({x:()=>De(r)})};var yP={kernelName:Uo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=je(t.shape,n.shape);return{a:()=>{let i=r,u=Dt(t.shape,o);return u.length>0&&(i=me(i,u)),L(i,t.shape)},b:()=>{let i=r,u=Dt(n.shape,o);return u.length>0&&(i=me(i,u)),L(et(i),n.shape)}}}};var xP={kernelName:zo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,o=n.shape.slice(),{axis:s}=t;yr(s,n.shape).forEach(l=>{o[l]=1});let i=L(r,o),u=R(i,mr(n.shape,"float32"));return{x:()=>u}}};var TP={kernelName:ba,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>pe(r,Xe(Ll(t)))}}};var kP={kernelName:Ko,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(ue(ce(1),Xe(t)),r)}}};var IP={kernelName:An,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{reps:o}=t;return{x:()=>{let a=De(n);if(n.rank===1)for(let i=0;i<o[0];++i)a=Y(a,We(r,[i*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)a=Y(a,We(r,[i*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)a=Y(a,We(r,[i*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let p=0;p<o[3];++p)a=Y(a,We(r,[i*n.shape[0],u*n.shape[1],l*n.shape[2],p*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return a}}}};var CP={kernelName:Vo,gradFunc:(r,e,t)=>{let n=t,{perm:o}=n,s=_f(o);return{x:()=>qe(r,s)}}};var vP={kernelName:xs,gradFunc:(r,e,t)=>{let n=t,{axis:o}=n;return{value:()=>fr(r,o)}}};var wP={kernelName:zu,inputsToSave:["segmentIds"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>UY(r,t)}}};function UY(r,e){let t=Xn(e,De(e)),n=Ya(r,t),o=qo(e,ce(0,"int32")),s=n.rank-o.rank;for(let i=0;i<s;++i)o=_r(o,i+1);o=jr(o,mr(n.shape,"bool"));let a=De(n);return zt(o,n,a)}var SP={kernelName:Ts,gradFunc:r=>({x:()=>De(r)})};var KY=[$b,F2,M2,E2,R2,L2,$2,B2,O2,z2,G2,W2,K2,j2,H2,q2,X2,Y2,Q2,Z2,J2,e1,r1,t1,o1,s1,a1,i1,u1,l1,X1,p1,c1,m1,f1,d1,g1,h1,b1,y1,k1,I1,C1,v1,w1,S1,_1,A1,N1,P1,fC,fC,F1,E1,L1,$1,B1,O1,z1,G1,W1,U1,K1,V1,j1,dC,dC,H1,q1,Y1,Q1,Z1,J1,eP,tP,rP,nP,oP,sP,aP,iP,uP,lP,pP,cP,mP,fP,hC,hC,gC,gC,dP,gP,hP,bP,yP,xP,TP,kP,IP,CP,vP,wP,SP];for(let r of KY)UN(r);var FP={};Qe(FP,{maxNorm:()=>jY,minMaxNorm:()=>XY,nonNeg:()=>qY,unitNorm:()=>HY});var bC;function dr(){return bC==null&&(bC=h0().epsilon()),bC}function mn(){return"channelsLast"}var Yn=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Yn.prototype)}},Jr=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Jr.prototype)}},O=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,O.prototype)}},Pe=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Pe.prototype)}},Kf=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Kf.prototype)}};function Fs(r,e){if(Array.isArray(r)){let t=[];for(let n=0;n<e;n++)t=t.concat(r);return t}else{let t=new Array(e);return t.fill(r),t}}function Yo(r,e){if(!r)throw new Kf(e)}function yC(r,e){let t=0;for(let n of r)n===e&&t++;return t}function Nr(r){return r.length===1?r[0]:r}function wt(r){return Array.isArray(r)?r:[r]}function Ms(r){let t=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function ou(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}var Es={};function Uc(r){if(r==null)return null;let e={};return e.className=r.getClassName(),e.config=r.getConfig(),e}function xC(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(e=>xC(e));else{let e=Object.keys(r);for(let t of e){let n=r[t];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[t]=n.value:xC(n))}}}function ei(r,e={},t={},n="object",o=!1){if(typeof r=="string"){let s=r,a;if(s in t)a=t[s];else if(s in Es)a=Es[s];else if(a=e[s],a==null)throw new O(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let s=r;if(s.className==null||s.config==null)throw new O(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let a=s.className,i,u;if(a in t?[i,u]=t[a]:a in Es?[i,u]=Es.className:a in e&&([i,u]=e[a]),i==null)throw new O(`Unknown ${n}: ${a}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let f of Object.keys(Es))l[f]=Es[f];for(let f of Object.keys(t))l[f]=t[f];let p=s.config;p.customObjects=l;let c={...Es};for(let f of Object.keys(t))Es[f]=t[f];xC(s.config);let m=u(i,s.config,t,o);return Es={...c},m}else{let l={...Es};for(let c of Object.keys(t))Es[c]=t[c];let p=new i(s.config);return Es={...l},p}}}function VY(r,e){return r<e?-1:r>e?1:0}function Vf(r,e){return-1*VY(r,e)}function Rs(r){if(r==null)return r;let e=[];for(let t of r)e.indexOf(t)===-1&&e.push(t);return e}function _P(r){if(r==null)throw new O(`Invalid value in obj: ${JSON.stringify(r)}`);for(let e in r)if(r.hasOwnProperty(e))return!1;return!0}function ti(r,e,t){if(t!=null&&r.indexOf(t)<0)throw new O(`${t} is not a valid ${e}.  Valid values are ${r} or null/undefined.`)}function Ob(r,e,t=0,n=1/0){return Yo(t>=0),Yo(n>=t),Array.isArray(r)&&r.length>=t&&r.length<=n&&r.every(o=>typeof o===e)}function sr(r,e){Array.isArray(r)?(b.assert(r.length>0,()=>`${e} is unexpectedly an empty array.`),r.forEach((t,n)=>sr(t,`element ${n+1} of ${e}`))):b.assert(Number.isInteger(r)&&r>0,()=>`Expected ${e} to be a positive integer, but got ${AP(r)}.`)}function AP(r){return r===null?"null":Array.isArray(r)?"["+r.map(e=>AP(e)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function NP(r,e,t){let n=t!=null?t():b.now(),o;return(...a)=>{let i=t!=null?t():b.now();return i-n<e||(n=i,o=r(...a)),o}}function zb(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}function TC(r,e){return G(()=>Lt(me(R(r,r),e,!0)))}var Kc=class extends ee.Serializable{getConfig(){return{}}},jf=class extends Kc{constructor(e){super();this.defaultMaxValue=2;this.defaultAxis=0;this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return G(()=>{let t=TC(e,this.axis),n=Lr(t,0,this.maxValue);return R(e,pe(n,Y(dr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};jf.className="MaxNorm";ee.registerClass(jf);var Hf=class extends Kc{constructor(e){super();this.defaultAxis=0;this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return G(()=>pe(e,Y(dr(),TC(e,this.axis))))}getConfig(){return{axis:this.axis}}};Hf.className="UnitNorm";ee.registerClass(Hf);var qf=class extends Kc{apply(e){return Hr(e)}};qf.className="NonNeg";ee.registerClass(qf);var Xf=class extends Kc{constructor(e){super();this.defaultMinValue=0;this.defaultMaxValue=1;this.defaultRate=1;this.defaultAxis=0;this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return G(()=>{let t=TC(e,this.axis),n=Y(R(this.rate,Lr(t,this.minValue,this.maxValue)),R(1-this.rate,t));return R(e,pe(n,Y(dr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Xf.className="MinMaxNorm";ee.registerClass(Xf);var DP={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Yt(r){return Uc(r)}function PP(r,e={}){return ei(r,ee.SerializationMap.getMap().classNameMap,e,"constraint")}function Qt(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in DP?DP[r]:r,config:{}};return PP(t)}else return r instanceof Kc?r:PP(r)}function jY(r){return new jf(r)}function HY(r){return new Hf(r)}function qY(){return new qf}function XY(r){return new Xf(r)}var ZP={};Qe(ZP,{constant:()=>n7,glorotNormal:()=>p7,glorotUniform:()=>l7,heNormal:()=>c7,heUniform:()=>m7,identity:()=>i7,leCunNormal:()=>f7,leCunUniform:()=>d7,ones:()=>r7,orthogonal:()=>h7,randomNormal:()=>s7,randomUniform:()=>o7,truncatedNormal:()=>a7,varianceScaling:()=>u7,zeros:()=>t7});var MP=["channelsFirst","channelsLast"],EP=["nearest","bilinear"],RP=["valid","same","causal"],LP=["max","avg"],$P=["sum","mul","concat","ave"];var Vc=new Map;function Vt(r){ti(MP,"DataFormat",r)}function BP(r){ti(EP,"InterpolationFormat",r)}function fn(r){ti(RP,"PaddingMode",r)}function kC(r){ti(LP,"PoolMode",r)}var Yf=[],OP="/";function va(r,e){Yf.push(r);try{let t=e();return Yf.pop(),t}catch(t){throw Yf.pop(),t}}function YY(){return Yf.length===0?"":Yf.join(OP)+OP}function Gb(r){if(!zP(r))throw new Error("Not a valid tensor name: '"+r+"'");return YY()+r}function Wb(r){if(!zP(r))throw new Error("Not a valid tensor name: '"+r+"'");Vc.has(r)||Vc.set(r,0);let e=Vc.get(r);if(Vc.set(r,Vc.get(r)+1),e>0){let t=`${r}_${e}`;return Vc.set(t,1),t}else return r}var QY=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function zP(r){return!!r.match(QY)}function GP(r){return r===parseInt(r.toString(),10)}function Ls(r,e,t){e==null&&(e=0),t==null&&(t=r.length);let n=1;for(let o=e;o<t;++o)n*=r[o];return n}function ap(r){if(r.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n<e&&(e=n)}return e}function wa(r){if(r.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n>e&&(e=n)}return e}function en(r,e){if(e<r)throw new O(`end (${e}) < begin (${r}) is forbidden.`);let t=[];for(let n=r;n<e;++n)t.push(n);return t}function ip(r,e){return Q(r,e)}function su(r,e=-1){let t=r.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),L(r,t)}function WP(r,e){return G(()=>{if(r.shape.length!==2)throw new O(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let t=su(r,1);return Ub(t,[1,e,1])})}function UP(r){let e=[Ls(r.shape)];return L(r,e)}function KP(r){if(r.rank<=1)throw new O(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let e=[r.shape[0],Ls(r.shape,1)];return L(r,e)}function au(r,e,t){return G(()=>{switch(r.rank){case 1:return Bf(r,e,t);case 2:return Ib(r,[e,0],[t,r.shape[1]]);case 3:return Of(r,[e,0,0],[t,r.shape[1],r.shape[2]]);case 4:return Gc(r,[e,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3]]);case 5:return We(r,[e,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return We(r,[e,0,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new O(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function IC(r,e,t){return G(()=>{switch(r.rank){case 1:return Bf(r,e,t);case 2:return Ib(r,[0,e],[r.shape[0],t]);case 3:return Of(r,[0,0,e],[r.shape[0],r.shape[1],t]);case 4:return Gc(r,[0,0,0,e],[r.shape[0],r.shape[1],r.shape[2],t]);default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Qf(r,e,t,n){return G(()=>{switch(r.rank){case 1:return Bf(r,e,t);case 2:switch(n){case 1:return au(r,e,t);case 2:return IC(r,e,t);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return au(r,e,t);case 2:return Of(r,[0,e,0],[r.shape[0],t,r.shape[2]]);case 3:return IC(r,e,t);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return au(r,e,t);case 2:return Gc(r,[0,e,0,0],[r.shape[0],t,r.shape[2],r.shape[3]]);case 3:return Gc(r,[0,0,e,0],[r.shape[0],r.shape[1],t,r.shape[3]]);case 4:return IC(r,e,t);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function jc(r,e=-1){let t;return e<0&&(t=r[0].rank,t!==0?e=t:e=0),e===r[0].rank&&(e=-1),lt(r,e)}function CC(r,e){switch(r.rank){case 1:return kI([r,e]);case 2:return II([r,e],0);case 3:return CI([r,e],0);case 4:return vI([r,e],0);default:throw new O(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function Ub(r,e){if(Array.isArray(e)||(e=[e]),r.rank!==e.length)throw new O(`The length of input n (${e.length}) does not match the number of dimensions in input x (${r.rank})`);return Vr(r,e)}function Hc(r,e=0,t=1,n,o){return kb(r,e,t,n,o)}function $s(r,e,t,n){if(r.rank<2||e.rank<2)throw new Pe(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${e.shape}`);if(e.rank>=3){let o=r.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(o!==s)throw new Pe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${e.shape}`)}if(r.rank===2&&e.rank===2){let o=!1,s=!1;return Ds.matMul({a:r,b:e,transposeA:o,transposeB:s,bias:n?vC(r.rank,n,mn()):null,activation:t})}else{let o=r.shape.slice(),s=o.pop();r=L(r,[-1,s]);let a=e.shape.slice(),i=a.pop(),u=a.pop(),l=[...a,i],p=Array.from({length:e.rank},(d,h)=>h===0?e.rank-2:h<=e.rank-2?h-1:h);e=L(qe(e,p),[u,-1]);let c=[...o,...l],m=!1,f=!1;return L(Ds.matMul({a:r,b:e,transposeA:m,transposeB:f,bias:n?vC(r.rank,n,mn()):null,activation:t}),c)}}function Kb(r,e,t){return G(()=>(Array.isArray(e)?e=Gt(e,"int32"):e=Q(e,"int32"),Ya(r,e,t)))}function up(r){return R(r,r)}function vC(r,e,t){let n=e.shape;if(e.rank!==1&&e.rank!==r)throw new O(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${r}`);if(r===5){if(t==="channelsFirst")return n.length===1?L(e,[1,n[0],1,1,1]):L(e,[1,n[3],n[0],n[1],n[2]]);if(t==="channelsLast")return n.length===1?L(e,[1,1,1,1,n[0]]):L(e,[1].concat(n))}else if(r===4){if(t==="channelsFirst")return n.length===1?L(e,[1,n[0],1,1]):L(e,[1,n[2],n[0],n[1]]);if(t==="channelsLast")return n.length===1?L(e,[1,1,1,n[0]]):L(e,[1].concat(n))}else if(r===3){if(t==="channelsFirst")return n.length===1?L(e,[1,n[0],1]):L(e,[1,n[1],n[0]]);if(t==="channelsLast")return n.length===1?L(e,[1,1,n[0]]):L(e,[1].concat(n))}else if(r<3)return e;throw new O(`Unsupported input rank by biasAdd: ${e.rank}`)}function dn(r,e,t){return G(()=>(t==null&&(t=mn()),Vt(t),Y(r,vC(r.rank,e,t))))}function VP(r,e=1){if(e!==1)throw new Pe(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Qi(r)}function jP(r){return G(()=>pe(r,Y(Ot(r),1)))}function Vb(r,e,t,n){return G(()=>G0(r,e,t,n))}function HP(r){return G(()=>{let e=Y(.5,R(.2,r));return Lr(e,0,1)})}function qu(r,e,t=!1){return t?r():e()}var qP=["fanIn","fanOut","fanAvg"],XP=["normal","uniform","truncatedNormal"];function ZY(r){ti(qP,"FanMode",r)}function JY(r){ti(XP,"Distribution",r)}var En=class extends ee.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Zf=class extends En{apply(e,t){return Tt(e,t)}};Zf.className="Zeros";ee.registerClass(Zf);var lp=class extends En{apply(e,t){return mr(e,t)}};lp.className="Ones";ee.registerClass(lp);var Jf=class extends En{constructor(e){super();if(typeof e!="object")throw new O(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new O(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return G(()=>R(ce(this.value),mr(e,t)))}getConfig(){return{value:this.value}}};Jf.className="Constant";ee.registerClass(Jf);var ed=class extends En{constructor(e){super();this.DEFAULT_MINVAL=-.05;this.DEFAULT_MAXVAL=.05;this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ca(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};ed.className="RandomUniform";ee.registerClass(ed);var td=class extends En{constructor(e){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Pe(`randomNormal does not support dType ${t}.`);return Hc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};td.className="RandomNormal";ee.registerClass(td);var rd=class extends En{constructor(e){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Pe(`truncatedNormal does not support dType ${t}.`);return ql(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};rd.className="TruncatedNormal";ee.registerClass(rd);var nd=class extends En{constructor(e){super();this.gain=e.gain!=null?e.gain:1}apply(e,t){return G(()=>{if(e.length!==2||e[0]!==e[1])throw new O("Identity matrix initializer can only be used for 2D square matrices.");return R(this.gain,$c(e[0]))})}getConfig(){return{gain:this.gain}}};nd.className="Identity";ee.registerClass(nd);function e7(r,e="channelsLast"){let t,n;if(Vt(e),r.length===2)t=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(e==="channelsFirst"){let o=Ls(r,2);t=r[1]*o,n=r[0]*o}else if(e==="channelsLast"){let o=Ls(r,0,r.length-2);t=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=Ls(r);t=Math.sqrt(o),n=Math.sqrt(o)}return[t,n]}var tn=class extends En{constructor(e){super();if(e.scale<0)throw new O(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,ZY(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,JY(this.distribution),this.seed=e.seed}apply(e,t){let n=e7(e),o=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,o):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(o+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Pe(`${this.getClassName()} does not support dType ${t}.`);return ql(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return Ca(e,-i,i,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};tn.className="VarianceScaling";ee.registerClass(tn);var qc=class extends tn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return tn.className}};qc.className="GlorotUniform";ee.registerClass(qc);var Xc=class extends tn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return tn.className}};Xc.className="GlorotNormal";ee.registerClass(Xc);var Yc=class extends tn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return tn.className}};Yc.className="HeNormal";ee.registerClass(Yc);var Qc=class extends tn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return tn.className}};Qc.className="HeUniform";ee.registerClass(Qc);var Zc=class extends tn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return tn.className}};Zc.className="LeCunNormal";ee.registerClass(Zc);var Jc=class extends tn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return tn.className}};Jc.className="LeCunNormal";ee.registerClass(Jc);var od=class extends En{constructor(e){super();this.DEFAULT_GAIN=1;if(this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Pe("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return G(()=>{if(e.length<2)throw new Pe("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,o=Hc(n,0,1,"float32"),s=N2.gramSchmidt(o);return e[0]>e[1]&&(s=qe(s)),R(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};od.className="Orthogonal";ee.registerClass(od);var YP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function QP(r,e={}){return ei(r,ee.SerializationMap.getMap().classNameMap,e,"initializer")}function Pt(r){return Uc(r)}function It(r){if(typeof r=="string"){let e=r in YP?YP[r]:r;if(e==="GlorotNormal")return new Xc;if(e==="GlorotUniform")return new qc;if(e==="HeNormal")return new Yc;if(e==="HeUniform")return new Qc;if(e==="LeCunNormal")return new Zc;if(e==="LeCunUniform")return new Jc;{let t={};return t.className=e,t.config={},QP(t)}}else return r instanceof En?r:QP(r)}function t7(){return new Zf}function r7(){return new lp}function n7(r){return new Jf(r)}function o7(r){return new ed(r)}function s7(r){return new td(r)}function a7(r){return new rd(r)}function i7(r){return new nd(r)}function u7(r){return new tn(r)}function l7(r){return new qc(r)}function p7(r){return new Xc(r)}function c7(r){return new Yc(r)}function m7(r){return new Qc(r)}function f7(r){return new Zc(r)}function d7(r){return new Jc(r)}function h7(r){return new od(r)}var MF={};Qe(MF,{Layer:()=>Ke,RNN:()=>Bs,RNNCell:()=>tl,activation:()=>$Q,add:()=>jQ,alphaDropout:()=>NZ,average:()=>HQ,averagePooling1d:()=>hv,averagePooling2d:()=>gv,averagePooling3d:()=>bv,avgPool1d:()=>rZ,avgPool2d:()=>oZ,avgPool3d:()=>aZ,avgPooling1d:()=>nZ,avgPooling2d:()=>sZ,avgPooling3d:()=>iZ,batchNormalization:()=>JQ,bidirectional:()=>kZ,concatenate:()=>qQ,conv1d:()=>AQ,conv2d:()=>NQ,conv2dTranspose:()=>DQ,conv3d:()=>PQ,conv3dTranspose:()=>FQ,convLstm2d:()=>bZ,convLstm2dCell:()=>yZ,cropping2D:()=>EQ,dense:()=>BQ,depthwiseConv2d:()=>LQ,dot:()=>ZQ,dropout:()=>OQ,elu:()=>IQ,embedding:()=>VQ,flatten:()=>GQ,gaussianDropout:()=>AZ,gaussianNoise:()=>_Z,globalAveragePooling1d:()=>uZ,globalAveragePooling2d:()=>lZ,globalMaxPool1d:()=>CZ,globalMaxPool2d:()=>vZ,globalMaxPooling1d:()=>NF,globalMaxPooling2d:()=>DF,gru:()=>cZ,gruCell:()=>mZ,input:()=>$C,inputLayer:()=>kQ,layerNormalization:()=>eZ,leakyReLU:()=>vQ,lstm:()=>fZ,lstmCell:()=>dZ,masking:()=>DZ,maxPool1d:()=>wZ,maxPool2d:()=>SZ,maxPooling1d:()=>PF,maxPooling2d:()=>FF,maxPooling3d:()=>pZ,maximum:()=>XQ,minimum:()=>YQ,multiply:()=>QQ,permute:()=>KQ,prelu:()=>wQ,reLU:()=>CQ,repeatVector:()=>WQ,reshape:()=>UQ,rnn:()=>xZ,separableConv2d:()=>MQ,simpleRNN:()=>hZ,simpleRNNCell:()=>gZ,softmax:()=>SQ,spatialDropout1d:()=>zQ,stackedRNNCells:()=>TZ,thresholdedReLU:()=>_Q,timeDistributed:()=>IZ,upSampling2d:()=>RQ,zeroPadding2d:()=>tZ});var g7=0;function jb(){return g7++}var Hb={};function Xu(r=""){return r in Hb||(Hb[r]=0),Hb[r]+=1,r+Hb[r].toString()}function qb(r){return Array.isArray(r)&&Array.isArray(r[0])}function em(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Ge(r){let e;if(Array.isArray(r)){if(r.length!==1)throw new O(`Expected Tensor length to be 1; got ${r.length}`);e=r[0]}else e=r;return e}function tt(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new O(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function tm(r){let e=0;for(let t of r)t.shape.length===0?e+=1:e+=t.shape.reduce((n,o)=>n*o);return e}var JP="Variable",Xb=class{constructor(e,t="float32",n=JP,o=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=jb(),n=n??JP,this.originalName=Gb(n),this.name=Wb(this.originalName),this.trainable_=o,this.constraint=s,this.val=aC(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),b7(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function b7(r,e){if(r.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(e.shape))}function sd(r){return r.map(e=>e.read())}function rm(r){r.forEach(e=>{e[0].write(e[1])})}var Ft=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},hn=class{constructor(e,t,n,o,s,a,i){this.dtype=e;this.shape=t;this.sourceLayer=n;this.inputs=o;this.callArgs=s;this.outputTensorIndex=i;this.id=jb(),a!=null&&(this.originalName=Gb(a),this.name=Wb(this.originalName)),this.rank=t.length}},y7=0,Yu=class{constructor(e,t){this.callArgs=t;this.id=y7++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},x7=0,Ke=class extends ee.Serializable{constructor(e={}){super();this._callHook=null;this._addedWeightNames=[];this._stateful=!1;this.id=x7++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Ms(n)+"_"+Xu(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let o=e.dtype;o==null&&(o=e.inputDType),o==null&&(o="float32"),this.dtype=o}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Jr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new O(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Nr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Nr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Yn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Yn(`Layer ${this.name} is not connected, no input to return.`);return Nr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Yn(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Yn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Nr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=wt(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=wt(this.inputSpec);if(e.length!==t.length)throw new O(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let o=e[n],s=t[n];if(s==null)continue;let a=o.rank;if(s.ndim!=null&&a!==s.ndim)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new O(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let i=o.shape;for(let u in s.axes){let l=Number(u),p=s.axes[u],c=l>=0?i[l]:i[i.length+l];if(p!=null&&[p,null].indexOf(c)===-1)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${p} but got shape ${i}.`)}}if(s.shape!=null)for(let i=0;i<s.shape.length;++i){let u=s.shape[i],l=o.shape[i];if(u!=null&&l!=null&&u!==l)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=wt(e),o=!0;for(let a of n)if(!(a instanceof hn)){o=!1;break}let s=!0;for(let a of n)if(a instanceof hn){s=!1;break}if(o===s)throw new O("Arguments to apply() must be all SymbolicTensors or all Tensors");return va(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of wt(e))a.push(i.shape);this.build(Nr(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t),i=wt(a),u=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(a=Nr(u),this.activityRegularizer!=null)throw new Pe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=T7(e),i=this.computeOutputShape(a),u,l=k7(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?u=i.map((p,c)=>new hn(l,p,this,wt(e),t,this.name,c)):u=new hn(l,i,this,wt(e),t,this.name),this.addInboundNode(e,u,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new Pe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&e[o]!=null&&e[o]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Yn(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Yn(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Jr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return tm(this.weights)}build(e){this.built=!0}getWeights(e=!1){return sd(e?this.trainableWeights:this.weights)}setWeights(e){G(()=>{let t=this.weights;if(t.length!==e.length)throw new O(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],o=sd(t);for(let s=0;s<o.length;++s){let a=o[s],i=t[s],u=e[s];if(!b.arraysEqual(a.shape,u.shape))throw new O(`Layer weight shape ${a.shape} not compatible with provided weight shape ${u.shape}`);n.push([i,u])}rm(n)})}addWeight(e,t,n,o,s,a,i,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new O(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():It("zeros"));let l=o.apply(t,n),p=new Xb(l,n,e,a,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(p.read())),a==null&&(a=!0),a?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=wt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,o,s,a,i=null){let u=wt(e);t=wt(t),n=wt(n),o=wt(o),s=em(s),a=em(a);let l=[],p=[],c=[];for(let m of u)l.push(m.sourceLayer),p.push(m.nodeIndex),c.push(m.tensorIndex);new Yu({outboundLayer:this,inboundLayers:l,nodeIndices:p,tensorIndices:c,inputTensors:u,outputTensors:t,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:a},i);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount==0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function T7(r){r=wt(r);let e=[];for(let t of r)e.push(t.shape);return Nr(e)}function k7(r){return"float32"}function wC(r,e,t){if((e==null||t!=null&&t>0)&&(e=r.sourceLayer,t=r.nodeIndex),e.inboundNodes.length===0)return[r];{let n=e.inboundNodes[t];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let a=n.inputTensors[s],i=n.inboundLayers[s],u=n.nodeIndices[s],l=wC(a,i,u);for(let p of l)o.indexOf(p)===-1&&o.push(p)}return o}}}var ri=class extends Ke{constructor(e){super({dtype:e.dtype,name:e.name!=null?e.name:Xu("input").toString()});if(e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new O("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new O("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new O("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let o=new hn(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new Yu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new O(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};ri.className="InputLayer";ee.registerClass(ri);function Yb(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new O("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=r.batchShape;r.shape!=null&&e==null&&(e=[null].concat(r.shape));let t=r.dtype;return t==null&&(t="float32"),new ri({batchInputShape:e,name:r.name,dtype:t,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}async function ni(r){if(r==null)return;let e=[],t=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let a=s;e.push(a.data()),t.push(o),n.push(a)}}if(e.length>0){let o=await Promise.all(e);for(let s=0;s<o.length;++s)r[t[s]]=o[s][0];Ee(n)}}function Qb(r){if(r!=null)for(let e in r){let t=r[e];typeof t!="number"&&t.dispose()}}var eF;(function(t){t[t.SILENT=0]="SILENT",t[t.VERBOSE=1]="VERBOSE"})(eF||(eF={}));var I7=125,Qu=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},SC=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},tF=class extends Qu{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let o in t){let s=t[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let a;o in this.totals?a=this.totals[o]:this.totals[o]=0;let i=G(()=>Y(this.totals[o],R(s,n)));this.totals[o]=i,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:G(()=>{let o=R(pe(1,this.seen),this.totals[n]);t[n]=o,this.totals[n].dispose(),Kt(t[n])}))}},_C=class extends Qu{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let u=a[i];e.push(u.data()),t.push(s),n.push(i)}}let o=await Promise.all(e);for(let s=0;s<o.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=o[s][0]}},AC=class extends Qu{constructor(e,t){super();this.currentEpoch=0;if(this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||uC,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=I7),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");b.isNumber(this.yieldEvery)&&(this.maybeWait=NP(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let o=[];this.yield!=null&&(await ni(n),o.push(this.yield(e,t,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await ni(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await ni(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await ni(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await ni(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):b.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await ni(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await ni(e),await this.trainEnd(e))}};function Zb(r,e){return r==null&&(r={}),r instanceof Qu?[r]:Array.isArray(r)&&r[0]instanceof Qu?r:wt(r).map(n=>new AC(n,e))}var Sa=class{constructor(){}static registerCallbackConstructor(e,t){b.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Sa.checkForDuplicate(t),Sa.constructors[e]==null&&(Sa.constructors[e]=[]),Sa.constructors[e].push(t)}static checkForDuplicate(e){for(let t in Sa.constructors)Sa.constructors[+t].forEach(o=>{if(o===e)throw new O("Duplicate callback constructor.")})}static clear(){Sa.constructors={}}static createCallbacks(e){let t=[];for(let n in Sa.constructors){let o=+n;e>=o&&t.push(...Sa.constructors[o])}return t.map(n=>new n)}},ad=Sa;ad.constructors={};function Jb(r,e,t,n,o,s,a,i,u){let l=new _C,p=[new tF,...ad.createCallbacks(e)];r!=null&&p.push(...r),p.push(l);let c=new SC(p);return c.setParams({epochs:t,initialEpoch:n,samples:o,steps:s,batchSize:a,verbose:e,doValidation:i,metrics:u}),{callbackList:c,history:l}}function gn(r,e={},t=!1){return ei(r,ee.SerializationMap.getMap().classNameMap,e,"layer",t)}function id(r,e){return G(()=>{r.dtype!=="float32"&&(r=Q(r,"float32"));let t=me(up(r),e,!0),n=Ia(t.shape,dr()),o=Lt(Xn(t,n));return pe(r,o)})}function oi(r,e){return G(()=>Rt(up(ue(e,r)),-1))}function nm(r,e){return G(()=>Rt(Ot(ue(e,r)),-1))}function Zu(r,e){return G(()=>{let t=ue(r,e),n=Lr(Ot(r),dr(),Number.MAX_VALUE),o=Ot(pe(t,n));return R(100,Rt(o,-1))})}function C7(r,e){return G(()=>{let t=Lr(e,dr(),Number.MAX_VALUE),n=$r(Y(1,t)),o=Lr(r,dr(),Number.MAX_VALUE),s=$r(Y(1,o));return Rt(up(ue(n,s)),-1)})}function v7(r,e){return G(()=>{let t=Xn(0,ue(1,R(r,e)));return Rt(up(t),-1)})}function w7(r,e){return G(()=>{let t=Xn(0,ue(1,R(r,e)));return Rt(t,-1)})}function S7(r,e){return G(()=>{let t=me(R(r,e),-1),n=Qr(R(ue(1,r),e),-1);return Xn(0,Y(1,ue(n,t)))})}function _7(r,e){return G(()=>{let t=Math.log(2),n=ue(e,r),o=ue(Y(n,Qa(R(-2,n))),t);return Rt(o,-1)})}function pp(r,e,t=!1){return G(()=>{if(t)e=Vl(e);else{let n=me(e,e.shape.length-1,!0);e=pe(e,n)}return e=Lr(e,dr(),1-dr()),et(me(R(Q(r,"float32"),$r(e)),e.shape.length-1))})}function om(r,e,t=!1){return G(()=>{let n=Q(Zi(UP(r)),"int32");e=Lr(e,dr(),1-dr());let o=e.shape,s=L(ji(n,o[o.length-1]),o);return pp(s,e,t)})}function A7(r,e){if(!b.arraysEqual(r.shape,e.shape))throw new O(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(e.shape)}`);return G(()=>{let t=Hr(e),n=et(Ot(e));return Y(ue(t,R(e,r)),Ol(cr(n)))})}function sm(r,e){return G(()=>{let t;return t=Lr(e,dr(),1-dr()),t=$r(pe(t,ue(1,t))),Rt(A7(r,t),-1)})}function N7(r,e){return G(()=>{let t=Lr(r,dr(),1),n=Lr(e,dr(),1);return me(R(r,$r(pe(t,n))),-1)})}function D7(r,e){return G(()=>{let t=$r(Y(dr(),e));return Rt(ue(e,R(r,t)),-1)})}function ud(r,e){return G(()=>{let t=id(r,-1),n=id(e,-1),o=R(t,n);return et(me(o,-1))})}var ld={meanSquaredError:oi,meanAbsoluteError:nm,meanAbsolutePercentageError:Zu,meanSquaredLogarithmicError:C7,squaredHinge:v7,hinge:w7,categoricalHinge:S7,logcosh:_7,categoricalCrossentropy:pp,sparseCategoricalCrossentropy:om,binaryCrossentropy:sm,kullbackLeiblerDivergence:N7,poisson:D7,cosineProximity:ud};function ey(r){if(typeof r=="string"){if(r in ld)return ld[r];let e=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new O(e)}else return r}function pd(r,e){return G(()=>{let t=R(.5,Ar(e)),n=ip(nr(e,t),r.dtype);return Rt(Kr(r,n),-1)})}function cd(r,e){return G(()=>ip(Kr(qi(r,-1),qi(e,-1)),"float32"))}function rF(r,e){return G(()=>Q(me(jr(Kr(r,1),Kr(e,1))),"float32"))}function P7(r,e){return G(()=>Q(me(jr(Kr(r,1),Kr(e,0))),"float32"))}function F7(r,e){return G(()=>Q(me(jr(Kr(r,0),Kr(e,1))),"float32"))}function NC(r,e){return G(()=>{let t=rF(r,e),n=F7(r,e),o=Y(t,n);return Q(zt(nr(o,0),pe(t,o),0),"float32")})}function nF(r,e){return G(()=>{let t=rF(r,e),n=P7(r,e),o=Y(t,n);return Q(zt(nr(o,0),pe(t,o),0),"float32")})}function ty(r,e){return sm(r,e)}function ry(r,e){return r.rank===e.rank&&(r=cn(r,[r.rank-1])),e=qi(e,-1),e.dtype!==r.dtype&&(e=Q(e,r.dtype)),Q(Kr(r,e),"float32")}var M7=oi,E7=oi,R7=nm,L7=nm,$7=Zu,B7=Zu,md=pp,O7=ud,DC=om,ny={binaryAccuracy:pd,categoricalAccuracy:cd,precision:NC,categoricalCrossentropy:md,sparseCategoricalCrossentropy:DC,mse:M7,MSE:E7,mae:R7,MAE:L7,mape:$7,MAPE:B7,cosine:O7};function oF(r){if(typeof r=="string"&&r in ny)return ny[r];if(typeof r!="string"&&r!=null)return r;throw new O(`Unknown metric ${r}`)}function fd(r){if(Yo(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let e;for(let t of Object.keys(ld))if(ld[t]===r){e=t;break}if(e!==void 0)return e;for(let t of Object.keys(ny))if(ny[t]===r){e=t;break}return e!==void 0?e:r.name}}function sF(r){let e={Adagrad:()=>sp.adagrad(.01),Adadelta:()=>sp.adadelta(1,.95,dr()),Adam:()=>sp.adam(.001,.9,.999,dr()),Adamax:()=>sp.adamax(.002,.9,.999,dr(),0),RMSProp:()=>sp.rmsprop(.001,.9,0,dr()),SGD:()=>sp.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,r in e)return e[r]();throw new O(`Unknown Optimizer ${r}`)}var aF=1*1024*1024;function PC(r,e,t=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!FC(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){let n=JSON.stringify(r);n.length>aF&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${aF}.`)}}function FC(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let e=Object.keys(r);for(let t of e)if(typeof t!="string"||!FC(r[t]))return!1;return!0}else if(Array.isArray(r)){for(let e of r)if(!FC(e))return!1;return!0}else return!1;else{let e=typeof r;return e==="string"||e==="number"||e==="boolean"}}function iF(r,e,t,n=console.log){let o=G7(r),s=["Layer (type)","Output shape","Param #"];o?(e=e||65,t=t||[.45,.85,1]):(e=e||98,t=t||[.33,.55,.67,1]),t[t.length-1]<=1&&(t=t.map(p=>Math.floor(e*p)));let a;if(!o){s.push("Receives inputs"),a=[];for(let p in r.nodesByDepth)a.push(...r.nodesByDepth[p])}n("_".repeat(e)),oy(s,t,n),n("=".repeat(e));let i=r.layers;for(let p=0;p<i.length;++p)o?W7(i[p],t,n):U7(i[p],t,a,n),n((p===i.length-1?"=":"_").repeat(e));r.checkTrainableWeightsConsistency();let u=z7(r),l=tm(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(e))}function z7(r){let e;return r.collectedTrainableWeights!=null?e=tm(r.collectedTrainableWeights):e=tm(r.trainableWeights),e}function G7(r){let e=!0,t=[],n=[];for(let o in r.nodesByDepth)t.push(r.nodesByDepth[o]);for(let o of t){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){e=!1;break}n.push(...o)}if(e)for(let o of r.layers){let s=!1;for(let a of o.inboundNodes)if(n.indexOf(a)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function oy(r,e,t=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,e[o]),n+=" ".repeat(e[o]-n.length);t(n)}function W7(r,e,t){let n;try{n=JSON.stringify(r.outputShape)}catch(i){n="multiple"}let o=r.name,s=r.getClassName(),a=[`${o} (${s})`,n,r.countParams().toString()];oy(a,e,t)}function U7(r,e,t,n){let o;try{o=JSON.stringify(r.outputShape)}catch(p){o="multiple"}let s=[];for(let p of r.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(p)===-1))for(let c=0;c<p.inboundLayers.length;++c){let m=p.inboundLayers[c].name,f=p.nodeIndices[c],d=p.tensorIndices[c];s.push(`${m}[${f}][${d}]`)}let a=r.name,i=r.getClassName(),u=s.length===0?"":s[0],l=[`${a} (${i})`,o,r.countParams().toString(),u];oy(l,e,n);for(let p=1;p<s.length;++p)oy(["","","",s[p]],e,n)}function uF(r,e,t){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&e===0&&typeof t=="string"}function cp(r,e){if(r===null)return null;if(typeof r=="string")return ou(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];uF(e,o,s)?t.push(s):t.push(cp(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")t[n]=o;else{let s=ou(n);t[s]=cp(o,s)}}return t}}function sy(r,e){if(r==null)return null;if(typeof r=="string")return Ms(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];uF(e,o,s)?t.push(s):t.push(sy(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n],s=Ms(n);(n==="name"||n==="className")&&typeof o=="string"?t[s]=o:t[s]=sy(o,n)}return t}}var dd="0.0.0";function K7(r,e){if(r.dtype==null||r.dtype===e.dtype)return e;try{return Q(e,r.dtype)}catch(t){throw new O(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var _a=class{constructor(e){this.id2Value={};this.id2Mask={};this.name2Id={};if(e instanceof _a)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=K7(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new O(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof hn){if(this.id2Value[e.id]==null)throw new O(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new O(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof hn){if(this.id2Value[e.id]==null)throw new O(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new O(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Ee(this.id2Mask)}},MC={},lF={};function mp(r,e,t,n){let o=t==null?!1:t.training,s=Array.isArray(r),a=s?r:[r],i=a.map(d=>d.name),u=[],l=e.names();for(let d of i)l.indexOf(d)!==-1?u.push(e.getValue(d)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let p=i.join(",")+"|"+e.names().join(","),c,m;if(MC[p]==null){let d=V7(a,e);c=d.sorted,m=d.recipientCounts,MC[p]=c,lF[p]=m}c=MC[p],m={},o||Object.assign(m,lF[p]);let f=new _a(e);for(let d=0;d<c.length;++d){if(n!=null){let E=hf().numTensors;E>n.maxNumTensors&&(n.maxNumTensors=E),E<n.minNumTensors&&(n.minNumTensors=E)}let h=c[d],g=h.sourceLayer;if(g instanceof ri)continue;let y=[],x=[],T=[],k=!1;for(let E of h.inputs){let $=f.getValue(E),W=f.getMask(E);y.push($),x.push(W),W!=null&&(k=!0),o||(m[E.name]--,m[E.name]===0&&!e.hasKey(E)&&i.indexOf(E.name)===-1&&!$.isDisposed&&E.sourceLayer.stateful!==!0&&T.push($))}k&&(t=t||{},t.mask=x[0]);let w=wt(g.apply(y,t)),P=null;g.supportsMasking&&(P=g.computeMask(y,x));let A=H7(h),F=Array.isArray(A)?A:[A];for(let E=0;E<F.length;++E){f.hasKey(F[E])||f.add(F[E],w[E],Array.isArray(P)?P[0]:P);let $=i.indexOf(F[E].name);$!==-1&&(u[$]=w[E])}o||Ee(T)}return f.disposeMasks(),s?u:u[0]}function V7(r,e){b.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let t=[],n={};if(r.length===1){let o=pF(r[0],e);t=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:a,recipientMap:i}=pF(s,e);for(let u of a)o.has(u.name)||(t.push(u),o.add(u.name));for(let u in i)n[u]==null&&(n[u]=new Set),i[u].forEach(l=>n[u].add(l))}}return{sorted:t,recipientCounts:j7(n)}}function j7(r){let e={};for(let t in r)e[t]=r[t].size;return e}function pF(r,e){let t=new Set,n=[],o={};for(let i of e.names())t.add(i);let s=[],a=[];for(s.push(r);s.length>0;){let i=s[s.length-1];if(t.has(i.name)){s.pop();continue}let u=a[a.length-1]===s.length-1;if(i.inputs.length===0||u)s.pop(),n.push(i),t.add(i.name),u&&a.pop();else{a.push(s.length-1);for(let l of i.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(i.name),!t.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function H7(r){let e;if(r.sourceLayer.inboundNodes.length===1)e=r.sourceLayer.output;else{let t=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){t=n;break}e=r.sourceLayer.getOutputAt(t)}return e}var Qo=class extends Ke{constructor(e){super({});this.containerNodes=new Set;if(this.name=e.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=Xu(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Rs(this.inputs).length!==this.inputs.length)throw new O(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);Rs(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let T=x.sourceLayer,k=x.nodeIndex,w=x.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(w)}for(let x of this.inputs){let T=x.sourceLayer,k=x.nodeIndex,w=x.tensorIndex;Yo(k===0,"input layer has >1 nodes"),Yo(w===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let T=this.inputLayers[x];if(!(T instanceof ri))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let t={},n={},o={},s={},a={},i=[],u=(x,T,k,w,P,A)=>{(w==null||P==null||A==null)&&(w=x.sourceLayer,P=x.nodeIndex,A=x.tensorIndex);let F=w.inboundNodes[P];if(k.indexOf(F)!==-1)throw new Jr(`The tensor ${x.name} at layer "${w.name}" is part of a cycle.`);if(T.indexOf(F)!==-1)return;this.containerNodes.add(Qo.nodeKey(w,P)),w.id in a||(a[w.id]=Object.keys(a).length),k.indexOf(F)===-1&&k.push(F);let E=F.inboundLayers.length;for(let $=0;$<E;$++){let W=F.inputTensors[$],K=F.inboundLayers[$],B=F.nodeIndices[$],V=F.tensorIndices[$];u(W,T,k,K,B,V)}for(T.push(F);k.indexOf(F)>=0;)k.splice(k.indexOf(F),1);i.push(F)},l=[],p=[];for(let x of this.outputs)u(x,l,p);let c=i.slice().reverse();for(let x of c){n[x.id]=x,x.id in t||(t[x.id]=0);let T=t[x.id],k=o[x.outboundLayer.id]==null?0:o[x.outboundLayer.id];T=Math.max(T,k),o[x.outboundLayer.id]=T,s[x.outboundLayer.id]=x.outboundLayer,t[x.id]=T;for(let w=0;w<x.inboundLayers.length;w++){let P=x.inboundLayers[w],A=x.nodeIndices[w],F=P.inboundNodes[A],E=t[F.id]==null?0:t[F.id];t[F.id]=Math.max(T+1,E),n[F.id]=F}}let m={};for(let x in t){let T=t[x];T in m||(m[T]=[]),m[T].push(n[x])}let f={};for(let x in o){let T=o[x];T in f||(f[T]=[]),f[T].push(s[x])}let d=Object.keys(f).map(x=>parseInt(x,10)).sort(Vf);this.layers=[];for(let x of d){let T=f[x];T.sort((k,w)=>{let P=a[k.id],A=a[w.id];return P<A?-1:P>A?1:0});for(let k of T)k instanceof Qo&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=f,d=Object.keys(m).map(x=>parseInt(x,10)).sort(Vf);let h=this.inputs.slice(),g=[];for(let x of d)for(let T of m[x]){let k=T.outboundLayer;if(k!=null){for(let w of T.inputTensors)if(h.indexOf(w)===-1)throw new Jr(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${k.name}". The following previous layers were accessed without issue: ${g}`);for(let w of T.outputTensors)h.push(w);g.push(k.name)}}this.nodesByDepth=m;let y=this.layers.map(x=>x.name);for(let x of y){let T=y.filter(k=>k===x).length;if(T!==1)throw new Jr(`The name "${x}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(y))}this.outboundNodes=[],this.inboundNodes=[],new Yu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new O("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},o=0;for(let a of this.layers)for(let i of a.weights){if(n[i.originalName]!=null)throw new O(`Duplicate weight name: ${i.originalName}`);n[i.originalName]=i,o++}let s=[];for(let a in e){let i=a;if(n[a]==null){let u=a.split("/");i=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[i]!=null)s.push([n[i],e[a]]);else if(t)throw new O(`Provided weight data has no target variable: ${a}`);delete n[i]}if(t){let a=[];for(let i in n)a.push(i);if(a.length>0)throw new O(`${a.length} of ${o} weights are not set: ${a}`)}rm(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${dd}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=sy(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return G(()=>{e=wt(e);let n=new _a;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],e[o]);return mp(this.outputs,n,t)})}computeMask(e,t){return G(()=>{e=wt(e);let n;return t==null?n=Fs(null,e.length):n=wt(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=em(e);if(t.length!==this.inputLayers.length)throw new O(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let u=this.inputLayers[i],l=t[i],p=u.name+"_0_0";n[p]=l}let o=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(Vf);if(o.length>1)for(let i of o){let u=this.nodesByDepth[i];for(let l of u){let p=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(p.id)!==-1)continue;let c=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],y=l.nodeIndices[h],x=l.tensorIndices[h],T=`${g.name}_${y}_${x}`,k=n[T];c.push(k)}let m=p.computeOutputShape(Nr(c)),f=em(m),d=p.inboundNodes.indexOf(l);for(let h=0;h<f.length;h++){let g=`${p.name}_${d}_${h}`;n[g]=f[h]}}}let s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){let u=this.outputLayers[i],l=this.outputLayersNodeIndices[i],p=this.outputLayersTensorIndices[i],c=`${u.name}_${l}_${p}`;a.push(c)}for(let i=0;i<a.length;i++){let u=a[i];Yo(u in n),s.push(n[u])}return Nr(s)}runInternalGraph(e,t){t==null&&(t=Fs(null,e.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],p=e[u],c=t[u];n[l.id]=[p,c]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Vf);for(let u of o){let l=this.nodesByDepth[u];for(let p of l){let c=p.outboundLayer,m=p.inputTensors,f=p.outputTensors,d=new Array;for(let h of m)h.id in n&&d.push(n[h.id]);if(d.length===m.length){let h={},g,y,x,T;if(p.callArgs!=null&&(h=p.callArgs),d.length===1){let[k,w]=d[0];h.mask==null&&(h.mask=w),x=wt(c.call(k,h)),T=wt(c.computeMask(k,w)),g=[k],y=[w]}else g=d.map(k=>k[0]),y=d.map(k=>k[1]),h.mask==null&&(h.mask=y),x=wt(c.call(g,h)),T=wt(c.computeMask(g,y));if(c.activityRegularizer)throw new Pe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<f.length;++k){let w=f[k],P=x[k],A=T[k];n[w.id]=[P,A]}}}}let s=[],a=[],i=[];for(let u of this.outputs){Yo(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,p]=n[u.id];i.push(l.shape),s.push(l),a.push(p)}return[s,a,i]}buildNodeConversionMap(e){let t={},n;for(let o of this.layers){n=o instanceof Qo?1:0;for(let s=0;s<o.inboundNodes.length;s++){let a=Qo.nodeKey(o,s);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new O(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new O("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new O(`No such layer: ${e}`)}calculateLosses(){return G(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let o=Qo.nodeKey(t,n);this.containerNodes.has(o)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let i=a.getClassName(),u=a.getConfig(),l=[];for(let c=0;c<a.inboundNodes.length;c++){let m=a.inboundNodes[c],f=Qo.nodeKey(a,c),d={};if(this.containerNodes.has(f)){if(m.callArgs)try{JSON.stringify(m.callArgs),d=m.callArgs}catch(h){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),d={}}if(m.inboundLayers.length>0){let h=[];for(let g=0;g<m.inboundLayers.length;g++){let y=m.inboundLayers[g],x=m.nodeIndices[g],T=m.tensorIndices[g],k=Qo.nodeKey(y,x),w=t[k];w==null&&(w=0),h.push([y.name,w,T,d])}l.push(h)}}}let p={};p.name=a.name,p.className=i,p.config=u,p.inboundNodes=l,n.push(p)}e.layers=n;let o=[];for(let a=0;a<this.inputLayers.length;a++){let i=this.inputLayers[a],u=this.inputLayersNodeIndices[a],l=Qo.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let c=this.inputLayersTensorIndices[a];o.push([i.name,p,c])}e.inputLayers=o;let s=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],u=this.outputLayersNodeIndices[a],l=Qo.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let c=this.outputLayersTensorIndices[a];s.push([i.name,p,c])}return e.outputLayers=s,e}static fromConfig(e,t,n={},o=!1){let s={},a={};function i(g,y){g.name in a?a[g.name].push(y):a[g.name]=[y]}function u(g,y){let x=[],T;for(let k of y){let w=k[0],P=k[1],A=k[2];if(T=k[3]==null?{}:k[3],!(w in s)){i(g,y);return}let F=s[w];if(F.inboundNodes.length<=P){i(g,y);return}let E=F.inboundNodes[P];x.push(E.outputTensors[A])}x.length>0&&g.apply(Nr(x),T)}function l(g){let y=g.name,x=gn(g,t.customObjects!=null?t.customObjects:{});x.setFastWeightInitDuringBuild(o),s[y]=x,g.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new O(`Corrupted configuration, expected array for nodeData: ${k}`);i(x,k)})}let p=t.name,c=t.layers;for(let g of c)l(g);for(;!_P(a);)for(let g of c){let y=s[g.name];if(y.name in a){let x=a[y.name];delete a[y.name];for(let T of x)u(y,T)}}let m=[],f=[],d=t.inputLayers;for(let g of d){let y=g[0],x=g[1],T=g[2];Yo(y in s);let w=s[y].inboundNodes[x].outputTensors;m.push(w[T])}let h=t.outputLayers;for(let g of h){let y=g[0],x=g[1],T=g[2];Yo(y in s);let w=s[y].inboundNodes[x].outputTensors;f.push(w[T])}return new e({inputs:m,outputs:f,name:p})}get stateful(){if(this._stateful)throw new O("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){G(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function q7(r,e,t){let n=e.length;if(r==null||Array.isArray(r)&&r.length===0)return e.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&e[0]in r?[r[e[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${t} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return e.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${t} must be either an array with ${n} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(r)}`)}function ay(r,e){return q7(r,e,"classWeight")}async function iy(r,e,t,n){if(e!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){let o=G(()=>{if(r.shape.length===1)return Nn(r);if(r.shape.length===2){if(r.shape[1]>1)return qi(r,1);if(r.shape[1]===1)return L(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());Ee(o);let a=[];return s.forEach(i=>{if(t[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(t[i])}),Gt(a,"float32")}else return null}function cF(r,e){return R(r,e)}var X7=32;function mF(r,e){let t,n,o=e;t=o.xs,n=o.ys,b.assert(t!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);let s=fF("input",r.inputNames,t),a=fF("output",r.outputNames,n),i=s[0].shape[0];b.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),b.assert(a.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)b.assert(s[u].shape[0]===i,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);for(let u=0;u<a.length;u++)b.assert(a[u].shape[0]===i,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${a[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);return{xs:s,ys:a}}function fF(r,e,t){if(t instanceof Ye)return[t];if(Array.isArray(t))return b.assert(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${r} keys ${e}.`),t;{let n=[];for(let o of e){if(t[o]==null)throw new O(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(t[o])}return n}}function Y7(r){if(r.length===3)throw new Pe("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function dF(r,e,t){let n=t.batchesPerEpoch!=null;if(b.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),b.assert(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),b.assert(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),b.assert(!n||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),b.assert(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=t.validationData!=null,s,a;if(o)if(hF(t.validationData))b.assert(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{let g=Y7(t.validationData);s=g.xs,a=g.ys}let i=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let p=Zb(t.callbacks,t.yieldEvery),c=t.verbose==null?1:t.verbose,{callbackList:m,history:f}=Jb(p,c,t.epochs,null,null,Q7(e,t),null,o,l);m.setModel(r),r.history=f,await m.onTrainBegin(),r.stopTraining_=!1;let d=t.initialEpoch==null?0:t.initialEpoch,h=await e.iterator();for(;d<t.epochs;){let g={};await m.onEpochBegin(d);let y=0,x=0;for(n||(h=await e.iterator());n?y<t.batchesPerEpoch:!0;){let T=await h.next();if(n&&T.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${y} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(T.value!=null){let{xs:k,ys:w}=mF(r,T.value),P={};P.batch=x,P.size=k[0].shape[0],await m.onBatchBegin(x,P);let A=[];if(t.classWeight!=null){let $=ay(t.classWeight,r.outputNames);for(let W=0;W<$.length;++W)A.push(await iy(w[W],null,$[W]))}let F=k.concat(w).concat(A),E=i(F);Ee(F);for(let $=0;$<u.length;++$){let W=u[$],K=E[$];P[W]=K,Kt(K)}await m.onBatchEnd(x,P),Qb(P),x++,y++}if(n?y>=t.batchesPerEpoch:T.done){if(o){let k;hF(t.validationData)?k=wt(await r.evaluateDataset(t.validationData,{batches:t.validationBatches})):k=wt(r.evaluate(s,a,{batchSize:t.validationBatchSize==null?X7:t.validationBatchSize,verbose:0}));for(let w=0;w<r.metricsNames.length;++w)g[`val_${r.metricsNames[w]}`]=k[w]}break}if(r.stopTraining_)break}if(await m.onEpochEnd(d,g),d++,r.stopTraining_)break}return await m.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function Q7(r,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(r.size)&&(t=r.size),t}function hF(r){return typeof r.iterator=="function"}function Z7(r){return typeof r.next=="function"}async function gF(r,e,t){t=t||{};let n=t.batches!=null,o=r.testFunction,s=[];if(t.verbose>0)throw new Pe("Verbose mode is not implemented yet.");b.assert(!n||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);let a=Z7(e)?e:await e.iterator(),i=0,u=0;for(;n?u<t.batches:!0;){let l=await a.next();if(s=G(()=>{if(l.value){let{xs:p,ys:c}=mF(r,l.value),m=p.concat(c),f=G(()=>o(m));if(Ee(m),u===0)for(let h=0;h<f.length;++h)s.push(ce(0));let d=m[0].shape[0];for(let h=0;h<f.length;++h){let g=f[h],y=s[h];s[h]=G(()=>Y(s[h],R(d,g))),u>0&&Ee(y)}Ee(f),i+=d,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let p=s[l];s[l]=pe(s[l],i),Ee(p)}return Nr(s)}function uy(r){b.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function am(r,e,t){return r==null?[null]:Array.isArray(r)?r.map(n=>au(n,e,t-e)):au(r,e,t-e)}function ly(r,e){return G(()=>r==null?null:Array.isArray(r)?r.map(t=>ly(t,e)):Kb(r,e.dtype==="int32"?e:Q(e,"int32")))}function py(r,e){let t=[],n=0,o=null;for(;n<r;)o=n+e,o>=r&&(o=r),t.push([n,o]),n=o;return t}async function J7(r,e,t,n,o,s,a,i,u,l,p,c,m,f,d){o==null&&(o=32),s==null&&(s=1),p==null&&(p=!0),m==null&&(m=0);let h=!1;if(u!=null&&l!=null&&(h=!0),d!=null&&(h=!0,f==null))throw new O("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(t,o,f,"steps_per_epoch"),y;g!=null&&(y=en(0,g)),a==null&&(a=1);let{callbackList:x,history:T}=Jb(i,a,s,m,g,f,o,h,c);x.setModel(r),r.history=T,await x.onTrainBegin(),r.stopTraining_=!1;for(let k=m;k<s;++k){await x.onEpochBegin(k);let w={};if(f!=null)throw new Pe("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new Pe("batch shuffling is not implemneted yet");p&&b.shuffle(y);let P=Gt(y),A=py(g,o);for(let F=0;F<A.length;++F){let E={};if(await x.onBatchBegin(F,E),G(()=>{let $=A[F][0],W=A[F][1],K=au(P,$,W-$);E.batch=F,E.size=W-$;let B=ly(t,K),V=e(B);for(let j=0;j<n.length;++j){let H=n[j],J=V[j];E[H]=J,Kt(J)}if(F===A.length-1&&h){let j=r.testLoop(u,l,o);for(let H=0;H<n.length;++H){let J=n[H],X=j[H];Kt(X),w["val_"+J]=X}}}),await x.onBatchEnd(F,E),Qb(E),r.stopTraining_)break}P.dispose()}if(await x.onEpochEnd(k,w),r.stopTraining_)break}return await x.onTrainEnd(),await r.history.syncData(),r.history}async function bF(r,e,t,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,a,i,u,l,p;try{let c=n.batchSize==null?32:n.batchSize;uy(c);let m=!1,f=await r.standardizeUserData(e,t,n.sampleWeight,n.classWeight,m,c);o=f[0],s=f[1],p=f[2];let d=!1,h;if(n.validationData!=null&&n.validationData.length>0){if(d=!0,n.validationData.length===2)a=n.validationData[0],i=n.validationData[1];else throw n.validationData.length===3?new Pe("validationData including sample weights is not supported yet."):new O(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let A=!0,F=await r.standardizeUserData(a,i,null,null,A,c);u=F[0],l=F[1],h=u.concat(l)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){d=!0;let A=Math.floor(o[0].shape[0]*(1-n.validationSplit)),F=o[0].shape[0];u=am(o,A,F),o=am(o,0,A),l=am(s,A,F),s=am(s,0,A),h=u.concat(l)}else n.validationSteps!=null&&(d=!0);let g=o.concat(s).concat(p);r.checkTrainableWeightsConsistency();let y=r.makeTrainFunction(),x=r.getDedupedMetricsNames(),T,k;d?(r.makeTestFunction(),T=r.testFunction,k=x.slice().concat(x.map(A=>"val_"+A))):(T=null,h=[],k=x.slice());let w=Zb(n.callbacks,n.yieldEvery);return await J7(r,y,g,x,c,n.epochs,n.verbose,w,T,h,n.shuffle,k,n.initialEpoch,null,null)}finally{r.isTraining=!1,Ju(o,e),Ju(s,t),Ju(u,a),Ju(l,i),p!=null&&Ee(p)}}function EC(r){let e=[];r instanceof Ye&&(r=[r]);for(let t=0;t<r.length;++t){let n=r[t];if(n.rank===1)e.push(su(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(n)}}return e}function Ju(r,e){if(r==null)return;let t=[];if(e instanceof Ye)t.push(e.id);else if(Array.isArray(e))e.forEach(o=>t.push(o.id));else if(e!=null)for(let o in e){let s=e[o];t.push(s.id)}let n=[];if(r instanceof Ye)t.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{t.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];t.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function eQ(r){return r instanceof Ye}function RC(r){return Array.isArray(r)}function yF(r){return!eQ(r)&&!RC(r)}function xF(r,e,t,n=!0,o=""){if(e==null||e.length===0){if(r!=null){let a=!1;if(RC(r)&&r.length>0)a=!0;else if(yF(r)){for(let i in r)if(r.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new O(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return e.map(a=>null);let s;if(yF(r)){r=r,s=[];for(let a of e){if(r[a]==null)throw new O(`No data provided for "${a}". Need data for each key in: ${e}`);s.push(r[a])}}else if(RC(r)){if(r=r,r.length!==e.length)throw new O(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,e.length>1)throw new O(`The model ${o} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=EC(s),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new O(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<t[a].length;++u){if(u===0&&!n)continue;let l=i.shape[u],p=t[a][u];if(p!=null&&p>=0&&l!==p)throw new O(`${o} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${o} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function tQ(r,e,t){let n=Rs(r.map(s=>s.shape[0]));n.sort();let o=Rs(e.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new O(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new O(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!b.arraysEqual(n,o))throw new O(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function rQ(r,e,t){let n=[oi,sm,pp];for(let o=0;o<r.length;++o){let s=r[o],a=e[o],i=t[o];if(a!=null){if(a===pp&&s.shape[s.shape.length-1]===1)throw new O(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(a)!==-1){let u=s.shape.slice(1),l=i.slice(1);for(let p=0;p<u.length;++p){let c=u[p],m=l[p];if(m!=null&&c!==m)throw new O(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function TF(r,e,t,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==e.length)throw new O(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(e.length>1)throw new O(`The model expects ${e.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new O(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<t[a].length;++u){if(u===0&&!n)continue;let l=i.shape[u],p=t[a][u];if(p!=null&&p!==l)throw new O(`Error when checking ${o}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function nQ(r,e){if(r==null||Array.isArray(r)&&r.length===0)return e.map(n=>[]);let t;if(typeof r=="string"||typeof r=="function")t=[r];else if(Array.isArray(r)||typeof r=="object")t=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(t))return e.map(n=>t);{let n=[];for(let o of e){let s=t.hasOwnProperty(o)?t[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var oQ="layers-model",Zo=class extends Qo{constructor(e){super(e);this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new O("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");iF(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=sF(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Zr))throw new O("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new O(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(ey(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new O(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>ey(i))}else{let a=ey(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],va("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let o=nQ(e.metrics,this.outputNames),s=(a,i,u)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([u,a])};va("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=o[a];(l=>{let p="",c,m,f;for(let d of l){if(typeof d=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(d)!==-1){let g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===sm?["accuracy","acc"].indexOf(d)!==-1?m=pd:["crossentropy","ce"].indexOf(d)!==-1&&(m=ty):this.lossFunctions[a]===om?["accuracy","acc"].indexOf(d)!==-1?m=ry:["crossentropy","ce"].indexOf(d)!==-1&&(m=DC):["accuracy","acc"].indexOf(d)!==-1?m=cd:["crossentropy","ce"].indexOf(d)!==-1&&(m=md);let y;["accuracy","acc"].indexOf(d)!==-1?y="acc":["crossentropy","ce"].indexOf(d)!==-1&&(y="ce"),f=m,c=p+y}else f=oF(d),c=p+fd(d);let h;va(c,()=>{h=f}),s(a,c,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let o=n.batchSize==null?32:n.batchSize;uy(o);let s=!0,a=this.standardizeUserDataXY(e,t,s,o);try{let i=a[0].concat(a[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,i,o,n.verbose,n.steps);return Nr(l)}finally{Ju(a[0],e),Ju(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),gF(this,e,t)}checkNumSamples(e,t,n,o="steps"){let s;if(n!=null){if(s=null,t!=null)throw new O(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new O(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new O("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),o=n?t:[t],s=this.retrieveSymbolicTensors(o),a=new _a;if(e instanceof Ye&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new O(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(let u of this.inputs){let l=e[u.name];if(l==null)throw new O(`No value is provided for the model's input ${u.name}`);a.add(u,l)}let i=mp(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Fs(null,e.length),n=e.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let u=a.indexOf(e[i]);if(u!==-1&&(t[i]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw t.forEach((s,a)=>{s==null&&o.push(e[a])}),new O(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return t}predictLoop(e,t=32,n=!1){return G(()=>{let o=this.checkNumSamples(e);if(n)throw new Pe("Verbose predictLoop() is not implemented yet.");let s=py(o,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)G(()=>{let l=s[i][0],p=s[i][1],c=am(e,l,p),m=[];if(Array.isArray(c))for(let d=0;d<c.length;++d)m.push({key:this.inputs[d],value:c[d]});else m.push({key:this.inputs[0],value:c});let f=new _a(m);return mp(this.outputs,f)}).forEach((l,p)=>a[p].push(l));return Nr(a.map(i=>lt(i,0)))})}predict(e,t={}){let n=EC(e);TF(n,this.inputNames,this.feedInputShapes,!1);try{let o=t.batchSize==null?32:t.batchSize;return uy(o),this.predictLoop(n,o)}finally{Ju(n,e)}}predictOnBatch(e){TF(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,o){if(this.optimizer_==null)throw new Jr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===om?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=xF(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=xF(t,this.feedOutputNames,s,!1,"target"),tQ(e,t,null),rQ(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&e[0].shape[0]%o!=0)throw new O(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,o,s=!0,a){let[i,u]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let p=ay(o,this.outputNames);l=[];for(let c=0;c<p.length;++c)l.push(await iy(u[c],null,p[c]))}return[i,u,l]}testLoop(e,t,n,o=0,s){return G(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(o>0)throw new Pe("Verbose mode is not implemented yet.");if(s!=null)throw new Pe("steps mode in testLoop() is not implemented yet");{let u=py(a,n),l=Gt(en(0,a));for(let p=0;p<u.length;++p){let c=u[p][0],m=u[p][1],f=au(l,c,m-c),d=ly(t,f),h=e(d);if(p===0)for(let g=0;g<h.length;++g)i.push(ce(0));for(let g=0;g<h.length;++g){let y=h[g];i[g]=Y(i[g],R(m-c,y))}}for(let p=0;p<i.length;++p)i[p]=pe(i[p],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let o=e[n],s=o;yC(e,o)>1&&(s+=`_${yC(e.slice(0,n),o)}`),t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let c=[];for(let h=0;h<this.inputs.length;++h)c.push({key:this.inputs[h],value:n[h]});let m=new _a(c),f=mp(this.outputs,m,{training:!0}),d;for(let h=0;h<this.lossFunctions.length;++h){let y=this.lossFunctions[h](o[h],f[h]);s[h]!=null&&(y=cF(y,s[h]));let x=Rt(y);t.push(x),h===0?d=y:d=Y(d,y)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=t[h];else{let y=this.metricsTensors[h][0],x=this.metricsTensors[h][1];g=Rt(y(o[x],f[x]))}Kt(g),a.push(g)}return d=Rt(d),this.calculateLosses().forEach(h=>{d=Y(d,h)}),d},u=this.collectedTrainableWeights.map(c=>c.read()),l=!0;return[this.optimizer_.minimize(i,l,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>G(()=>{let t=[],n,o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:o[l]});let i=new _a(a),u=mp(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let p=this.lossFunctions[l],c=Rt(p(s[l],u[l]));l===0?n=c:n=Y(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let p=this.metricsTensors[l][0],c=this.metricsTensors[l][1],m=Rt(p(s[c],u[c]));t.push(m)}return t})}async fit(e,t,n={}){return bF(this,e,t,n)}async fitDataset(e,t){return dF(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),o=n[0],s=n[1],i=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of i){let p=await l.data();u.push(p[0])}return Ee(i),Nr(u)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<o.length;++a)n&&!o[a].trainable||t.push({name:o[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=hf().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-hf().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Ms(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Ms(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let o of t)if(typeof n[o]=="string")e[o]=Ms(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Ms(fd(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Ms(fd(e)));{let e={};for(let t in this.metrics)e[t]=Ms(fd(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=cp(e.optimizer_config),n=gn(t),o;if(typeof e.loss=="string")o=ou(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>ou(a));else if(e.loss!=null){o={};for(let a in e.loss)o[a]=ou(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>ou(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=ou(e.metrics[a])}this.compile({loss:o,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let l=Ur.getSaveHandlers(e);if(l.length===0)throw new O(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new O(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new O("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Ur.encodeWeights(this.getNamedWeights(t)),o=!1,s=null,i={modelTopology:this.toJSON(s,o),format:oQ,generatedBy:`TensorFlow.js tfjs-layers v${dd}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:p,specs:c}=await Ur.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...c),n.data=Ur.concatenateArrayBuffers([n.data,p])}if(this.userDefinedMetadata!=null){let l=!0;PC(this.userDefinedMetadata,this.name,l),i.userDefinedMetadata=this.userDefinedMetadata}return i.weightData=n.data,i.weightSpecs=n.specs,e.save(i)}setUserDefinedMetadata(e){PC(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Zo.className="Model";ee.registerClass(Zo);var LC=class extends Zo{};LC.className="Functional";ee.registerClass(LC);async function kF(r,e){"modelTopology"in r||(r={modelTopology:r}),r=r;let t=r.modelTopology;t.model_config!=null&&(t=t.model_config);let n=cp(t),o=gn(n,e);if(r.weightsManifest!=null){let s=await Ur.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(i=>i.originalName)),a={};for(let i of o.weights)a[i.originalName]=s[i.originalName];o.loadWeights(a),Ee(s)}return o}async function IF(r,e){if(e==null&&(e={}),typeof r=="string"){let t=Ur.getLoadHandlers(r,e);if(t.length===0)t.push(Ur.browserHTTPRequest(r,e));else if(t.length>1)throw new O(`Found more than one (${t.length}) load handlers for URL '${r}'`);r=t[0]}return sQ(r,void 0,e)}async function sQ(r,e,t){if(t==null&&(t={}),r.load==null)throw new O("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=t.strict==null?!0:t.strict,a=n.weightData!=null&&n.weightSpecs!=null&&s,i=gn(cp(o),e,a),u=n.trainingConfig;if(u!=null&&i.loadTrainingConfig(u),n.userDefinedMetadata!=null&&i.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new O("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:p}=aQ(n.weightData,n.weightSpecs);i.loadWeights(l,s),i.optimizer!=null&&p.length>0&&await i.optimizer.setWeights(p),Ee(l),Ee(p.map(c=>c.tensor))}return i}function aQ(r,e){let t=Ur.decodeWeights(r,e),n={},o=[];return e.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:t[s.name]}):n[s.name]=t[s.name]}),{modelWeights:n,optimizerWeights:o}}var cy=class extends Zo{constructor(e){super({inputs:[],outputs:[]});if(e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Xu("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new O(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof cy||e instanceof Zo,n;if(t){if(n=e,n.outputs.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new O("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new O("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=Yb({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new O(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=wC(this.outputs[0])}this.inboundNodes=[],new Yu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Fs(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(tt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Zo({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Jr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},o=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new O("Legacy serialization format not supported yet.");s=t}else b.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;let i=new e(a);if(!(i instanceof cy))throw new Pe(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let u of s){let p=gn(u,void 0,o);o&&p.setFastWeightInitDuringBuild(!0),i.add(p)}return i}set stopTraining(e){if(this.model==null)throw new O("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new O("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}},im=cy;im.className="Sequential";ee.registerClass(im);function iQ(r){return new Zo(r)}function uQ(r){return new im(r)}function lQ(r,e){return e==null&&(e={}),IF(r,e)}function $C(r){return Yb(r)}function pQ(r,e){ad.registerCallbackConstructor(r,e)}var bn=class extends ee.Serializable{getConfig(){return{}}},BC=class extends bn{apply(e,t=1){return VP(e,t)}};BC.className="elu";ee.registerClass(BC);var OC=class extends bn{apply(e){return Rf(e)}};OC.className="selu";ee.registerClass(OC);var zC=class extends bn{apply(e){return Hr(e)}};zC.className="relu";ee.registerClass(zC);var GC=class extends bn{apply(e){return G(()=>Ji(6,Hr(e)))}};GC.className="relu6";ee.registerClass(GC);var WC=class extends bn{apply(e){return e}};WC.className="linear";ee.registerClass(WC);var UC=class extends bn{apply(e){return ln(e)}};UC.className="sigmoid";ee.registerClass(UC);var KC=class extends bn{apply(e){return HP(e)}};KC.className="hardSigmoid";ee.registerClass(KC);var VC=class extends bn{apply(e){return Qa(e)}};VC.className="softplus";ee.registerClass(VC);var jC=class extends bn{apply(e){return jP(e)}};jC.className="softsign";ee.registerClass(jC);var HC=class extends bn{apply(e){return Xi(e)}};HC.className="tanh";ee.registerClass(HC);var hd=class extends bn{apply(e,t=-1){return Vl(e,t)}};hd.className="softmax";ee.registerClass(hd);var qC=class extends bn{apply(e,t=-1){return Sf(e,t)}};qC.className="logSoftmax";ee.registerClass(qC);var XC=class extends bn{apply(e,t=1){return G(()=>R(ln(R(e,t)),e))}};XC.className="swish";ee.registerClass(XC);var YC=class extends bn{apply(e){return G(()=>R(e,Xi(Qa(e))))}};YC.className="mish";ee.registerClass(YC);function Aa(r){return r.getClassName()}function QC(r,e={}){return ei(r,ee.SerializationMap.getMap().classNameMap,e,"activation")}function Na(r){if(r==null){let e={};return e.className="linear",e.config={},QC(e)}if(typeof r=="string"){let e={};return e.className=r,e.config={},QC(e)}else return r instanceof bn?r:QC(r)}function ZC(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var JC=class extends ee.Serializable{},fp=class extends JC{constructor(e){super();ZC(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return G(()=>{let t=Tt([1]);return this.hasL1&&(t=Y(t,me(R(this.l1,Ot(e))))),this.hasL2&&(t=Y(t,me(R(this.l2,up(e))))),L(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};fp.className="L1L2";ee.registerClass(fp);function CF(r){return ZC(r),new fp({l1:r!=null?r.l1:null,l2:0})}function vF(r){return ZC(r),new fp({l2:r!=null?r.l2:null,l1:0})}var wF={l1l2:"L1L2"};function bt(r){return Uc(r)}function SF(r,e={}){return ei(r,ee.SerializationMap.getMap().classNameMap,e,"regularizer")}function St(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in wF?wF[r]:r,config:{}};return SF(t)}else return r instanceof JC?r:SF(r)}var gd=class extends Ke{constructor(e){super(e??{});this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Ge(e);let n=Hr(e);return this.maxValue!=null&&(n=Lr(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};gd.className="ReLU";ee.registerClass(gd);var bd=class extends Ke{constructor(e){super(e??{});this.DEFAULT_ALPHA=.3;e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ge(e);return Bl(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};bd.className="LeakyReLU";ee.registerClass(bd);var yd=class extends Ke{constructor(e){super(e??{});this.DEFAULT_ALPHA_INITIALIZER="zeros";if(e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=It(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=St(e.alphaRegularizer),this.alphaConstraint=Qt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new O(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=tt(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)t[o-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<e.length;++o)n[o]=e[o];this.inputSpec=[new Ft({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Ge(e),Ul(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Pt(this.alphaInitializer),alphaRegularizer:bt(this.alphaRegularizer),alphaConstraint:Yt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};yd.className="PReLU";ee.registerClass(yd);var xd=class extends Ke{constructor(e){super(e??{});this.DEFAULT_ALPHA=1;if(e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Pe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Ge(e);return Qi(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};xd.className="ELU";ee.registerClass(xd);var Td=class extends Ke{constructor(e){super(e??{});this.DEFAULT_THETA=1;e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Ge(e);return R(n,Q(nr(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};Td.className="ThresholdedReLU";ee.registerClass(Td);var kd=class extends Ke{constructor(e){super(e??{});this.DEFAULT_AXIS=1;e==null&&(e={}),this.softmax=new hd().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=Ge(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};kd.className="Softmax";ee.registerClass(kd);function el(r,e,t){if(typeof r=="number")return Fs(r,e);if(r.length!==e)throw new O(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${r.length} elements.`);for(let n=0;n<e;++n){let o=r[n];if(!GP(o))throw new O(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function Rn(r,e,t,n,o=1){if(r==null)return r;let s=e+(e-1)*(o-1),a;return t==="same"?a=r:a=r-s+1,Math.floor((a+n-1)/n)}function Da(r,e,t,n){if(r==null)return null;if(n==="valid")r=r*e+wa([t-e,0]);else if(n==="same")r=r*e;else throw new O(`Unsupport padding mode: ${n}.`);return r}function Id(r,e){return G(()=>(Vt(e),e==="channelsFirst"?qe(r,[0,2,3,1]):r))}function ev(r,e){return G(()=>(Vt(e),e==="channelsFirst"?qe(r,[0,2,3,4,1]):r))}function cQ(r,e,t,n=1,o="valid",s,a=1){return G(()=>{if(s==null&&(s=mn()),Vt(s),r.shape.length!==3)throw new O(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(e.shape.length!==3)throw new O(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new O(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(r=qe(r,[0,2,1])),o==="causal")throw new Pe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Tf(r,e,n,o==="same"?"same":"valid","NWC",a);return t!=null&&(i=dn(i,t)),i})}function _F(r,e,t,n=[1,1],o="valid",s,a,i=null){return G(()=>{if(s==null&&(s=mn()),Vt(s),r.rank!==3&&r.rank!==4)throw new O(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(e.rank!==3&&e.rank!==4)throw new O(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=Id(r,s);if(o==="causal")throw new Pe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Ds.conv2d({x:u,filter:e,strides:n,pad:o==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:i}),s==="channelsFirst"&&(u=qe(u,[0,3,1,2])),u})}function mQ(r,e,t,n=[1,1,1],o="valid",s,a){return G(()=>{if(s==null&&(s=mn()),Vt(s),r.rank!==4&&r.rank!==5)throw new O(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(e.rank!==4&&e.rank!==5)throw new O(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let i=ev(r,s);if(o==="causal")throw new Pe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=If(i,e,n,o==="same"?"same":"valid","NDHWC",a),t!=null&&(i=dn(i,t)),s==="channelsFirst"&&(i=qe(i,[0,4,1,2,3])),i})}var um=class extends Ke{constructor(e,t){super(t);this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(um.verifyArgs(t),this.rank=e,sr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Pe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=el(t.kernelSize,e,"kernelSize"),this.strides=el(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,fn(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Vt(this.dataFormat),this.activation=Na(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=It(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Qt(t.biasConstraint),this.biasRegularizer=St(t.biasRegularizer),this.activityRegularizer=St(t.activityRegularizer),this.dilationRate=el(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new O(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new O(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new O(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Yo("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Ob(e.kernelSize,"number",1,3))throw new O(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Aa(this.activation),useBias:this.useBias,biasInitializer:Pt(this.biasInitializer),biasRegularizer:bt(this.biasRegularizer),activityRegularizer:bt(this.activityRegularizer),biasConstraint:Yt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},dp=class extends um{constructor(e,t){super(e,t);this.kernel=null;dp.verifyArgs(t),this.filters=t.filters,sr(this.filters,"filters"),this.kernelInitializer=It(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Qt(t.kernelConstraint),this.kernelRegularizer=St(t.kernelRegularizer)}build(e){e=tt(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return G(()=>{e=Ge(e);let n,o=this.bias==null?null:this.bias.read(),s=zb(this.activation.getClassName());if(s!=null&&this.rank===2)n=_F(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=cQ(e,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=_F(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=mQ(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Pe("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=tt(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let a=Rn(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let o=[e[0]];return this.dataFormat==="channelsLast"?(o=o.concat(t),o.push(this.filters)):(o.push(this.filters),o=o.concat(t)),o}getConfig(){let e={filters:this.filters,kernelInitializer:Pt(this.kernelInitializer),kernelRegularizer:bt(this.kernelRegularizer),kernelConstraint:Yt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new O(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},rv=class extends dp{constructor(e){super(2,e);rv.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Ob(e.kernelSize,"number",1,2))throw new O(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}},lm=rv;lm.className="Conv2D";ee.registerClass(lm);var nv=class extends dp{constructor(e){super(3,e);nv.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new O(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}},pm=nv;pm.className="Conv3D";ee.registerClass(pm);var Cd=class extends lm{constructor(e){super(e);if(this.inputSpec=[new Ft({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=tt(e),e.length!==4)throw new O("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ft({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return G(()=>{let n=Ge(e);if(n.shape.length!==4)throw new O(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let u=o[a],l=o[i],p=this.kernelSize[0],c=this.kernelSize[1],m=this.strides[0],f=this.strides[1],d=Da(u,m,p,this.padding),h=Da(l,f,c,this.padding),g=[s,d,h,this.filters];this.dataFormat!=="channelsLast"&&(n=qe(n,[0,2,3,1]));let y=kf(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(y=qe(y,[0,3,1,2])),this.bias!=null&&(y=dn(y,this.bias.read(),this.dataFormat)),this.activation!=null&&(y=this.activation.apply(y)),y})}computeOutputShape(e){e=tt(e);let t=e.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[o]=Da(t[o],u,a,this.padding),t[s]=Da(t[s],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Cd.className="Conv2DTranspose";ee.registerClass(Cd);var vd=class extends pm{constructor(e){super(e);if(this.inputSpec=[new Ft({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=tt(e),e.length!==5)throw new O("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ft({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return G(()=>{let n=Ge(e);if(n.shape.length!==5)throw new O(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i,u;this.dataFormat==="channelsFirst"?(u=2,a=3,i=4):(u=1,a=2,i=3);let l=o[u],p=o[a],c=o[i],m=this.kernelSize[0],f=this.kernelSize[1],d=this.kernelSize[2],h=this.strides[0],g=this.strides[1],y=this.strides[2],x=Da(l,h,m,this.padding),T=Da(p,g,f,this.padding),k=Da(c,y,d,this.padding),w=[s,x,T,k,this.filters];this.dataFormat!=="channelsLast"&&(n=qe(n,[0,2,3,4,1]));let P=wI(n,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(P=qe(P,[0,4,1,2,3])),this.bias!==null&&(P=dn(P,this.bias.read(),this.dataFormat)),this.activation!==null&&(P=this.activation.apply(P)),P})}computeOutputShape(e){e=tt(e);let t=e.slice(),n,o,s,a;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,a=4):(n=4,o=1,s=2,a=3);let i=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],p=this.strides[0],c=this.strides[1],m=this.strides[2];return t[n]=this.filters,t[o]=Da(t[o],p,i,this.padding),t[s]=Da(t[s],c,u,this.padding),t[a]=Da(t[a],m,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};vd.className="Conv3DTranspose";ee.registerClass(vd);var tv=class extends dp{constructor(e,t){super(e,t);this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform";this.depthwiseKernel=null;this.pointwiseKernel=null;if(t.filters==null)throw new O("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new O("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new O(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=It(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=St(t.depthwiseRegularizer),this.depthwiseConstraint=Qt(t.depthwiseConstraint),this.pointwiseInitializer=It(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=St(t.pointwiseRegularizer),this.pointwiseConstraint=Qt(t.pointwiseConstraint)}build(e){if(e=tt(e),e.length<this.rank+2)throw new O(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new O(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Ft({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return G(()=>{e=Ge(e);let n;if(this.rank===1)throw new Pe("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=qe(e,[0,2,3,1])),n=JI(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=dn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=qe(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Pt(this.depthwiseInitializer),e.pointwiseInitializer=Pt(this.pointwiseInitializer),e.depthwiseRegularizer=bt(this.depthwiseRegularizer),e.pointwiseRegularizer=bt(this.pointwiseRegularizer),e.depthwiseConstraint=Yt(this.depthwiseConstraint),e.pointwiseConstraint=Yt(this.pointwiseConstraint),e}};tv.className="SeparableConv";var wd=class extends tv{constructor(e){super(2,e)}};wd.className="SeparableConv2D";ee.registerClass(wd);var ov=class extends dp{constructor(e){super(1,e);ov.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Ob(e.kernelSize,"number",1,1))throw new O(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}},Sd=ov;Sd.className="Conv1D";ee.registerClass(Sd);var _d=class extends Ke{constructor(e){super(e);typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return G(()=>{if(e=Ge(e),this.dataFormat==="channelsLast"){let n=Qf(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Qf(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Qf(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Qf(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};_d.className="Cropping2D";ee.registerClass(_d);var Ad=class extends Ke{constructor(e){super(e);this.DEFAULT_SIZE=[2,2];this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,BP(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return G(()=>{let n=Ge(e),o=n.shape;if(this.dataFormat==="channelsFirst"){n=qe(n,[0,2,3,1]);let s=this.size[0]*o[2],a=this.size[1]*o[3],i=this.interpolation==="nearest"?Mn.resizeNearestNeighbor(n,[s,a]):Mn.resizeBilinear(n,[s,a]);return qe(i,[0,3,1,2])}else{let s=this.size[0]*o[1],a=this.size[1]*o[2];return this.interpolation==="nearest"?Mn.resizeNearestNeighbor(n,[s,a]):Mn.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Ad.className="UpSampling2D";ee.registerClass(Ad);function fQ(r,e,t=[1,1],n="valid",o,s){return G(()=>{o==null&&(o=mn()),Vt(o);let a=Id(r,o);if(r.rank!==4)throw new O(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(e.rank!==4)throw new O(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Yi(a,e,t,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(a=qe(a,[0,3,1,2])),a})}var Nd=class extends um{constructor(e){super(2,e);this.depthwiseKernel=null;this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=It(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Qt(e.depthwiseConstraint),this.depthwiseRegularizer=St(e.depthwiseRegularizer)}build(e){if(e=tt(e),e.length<4)throw new O(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new O(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G(()=>{e=Ge(e);let n=fQ(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=dn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=tt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Rn(t,this.kernelSize[0],this.padding,this.strides[0]),a=Rn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],o,s,a]:[e[0],s,a,o]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Pt(this.depthwiseInitializer),e.depthwiseRegularizer=bt(this.depthwiseRegularizer),e.depthwiseConstraint=Yt(this.depthwiseRegularizer),e}};Nd.className="DepthwiseConv2D";ee.registerClass(Nd);function sv(r,e,t,n){if(Array.isArray(r)){if(e!=null||t!=null)throw new O("When inputs is an array, neither initialState or constants should be provided");n!=null&&(t=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(e=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return e=o(e),t=o(t),{inputs:r,initialState:e,constants:t}}function av(r,e,t,n=!1,o,s,a=!1,i=!1){return G(()=>{let u=e.shape.length;if(u<3)throw new O(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(en(2,u));if(e=qe(e,l),s!=null)throw new Pe("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=Q(Q(o,"bool"),"float32"),o.rank===u-1&&(o=_r(o,-1)),o=qe(o,l)),n&&(e=xr(e,0),o!=null&&(o=xr(o,0)));let p=[],c,m=t,f=e.shape[0],d=Br(e),h;o!=null&&(h=Br(o));for(let y=0;y<f;++y){let x=d[y],T=G(()=>r(x,m));if(o==null)c=T[0],m=T[1];else{let k=G(()=>{let w=h[y],P=ue(Ar(w),w),A=Y(R(T[0],w),R(m[0],P)),F=m.map((E,$)=>Y(R(T[1][$],w),R(E,P)));return{output:A,newStates:F}});c=k.output,m=k.newStates}i&&p.push(c)}let g;return i&&(g=fr(p,1)),[c,g,m]})}var iv=class extends Ke{constructor(e){super(e);let t;if(e.cell==null)throw new O("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new fm({cells:e.cell}):t=e.cell,t.stateSize==null)throw new O("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ft({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return en(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){qb(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],o;if(this.returnSequences?o=[e[0],e[1],n]:o=[e[0],n],this.returnState){let s=[];for(let a of t)s.push([e[0],a]);return[o].concat(s)}else return o}computeMask(e,t){return G(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){let t=null;if(this.numConstants!=null)throw new Pe("Constants support is not implemented in RNN yet.");qb(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new Ft({shape:[n,null,...o]});let s=[e[0]].concat(e.slice(2));if(t!=null)throw new Pe("Constants support is not implemented in RNN yet.");this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!b.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new O(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new Ft({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){G(()=>{if(!this.stateful)throw new Yn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Tt([n,o])):this.states_=[Tt([n,this.cell.stateSize])];else if(e==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Tt([n,o])):this.states_[0]=Tt([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let o=0;o<this.states_.length;++o){let s=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,i=[n,a];if(!b.arraysEqual(s.shape,i))throw new O(`State ${o} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Kt(o.clone()))})}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=sv(e,n,o,this.numConstants);e=s.inputs,n=s.initialState,o=s.constants;let a=[],i=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new Ft({shape:l.shape}));i=i.concat(this.stateSpec)}if(o!=null&&(t.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof hn){let l=[e].concat(a),p=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=p;let m=super.apply(l,t);return this.inputSpec=c,m}else return super.apply(e,t)}call(e,t){return G(()=>{let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;e=Ge(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new O(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:o},l=av((d,h)=>{let g=this.cell.call([d].concat(h),i);return[g[0],g.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),p=l[0],c=l[1],m=l[2];this.stateful&&this.resetStates(m,o);let f=this.returnSequences?c:p;return this.returnState?[f].concat(m):f})}getInitialState(e){return G(()=>{let t=Tt(e.shape);return t=me(t,[1,2]),t=su(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Ub(t,[1,n]):t):this.cell.stateSize>1?[Ub(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===iv.className&&(t.cell={className:this.cell.getClassName(),config:n}),{...n,...e,...t}}static fromConfig(e,t,n={}){let o=t.cell,s=gn(o,n);return new e(Object.assign(t,{cell:s}))}},Bs=iv;Bs.className="RNN";ee.registerClass(Bs);var tl=class extends Ke{},cm=class extends tl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=e.units,sr(this.units,"units"),this.activation=Na(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=It(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=It(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=It(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=St(e.kernelRegularizer),this.recurrentRegularizer=St(e.recurrentRegularizer),this.biasRegularizer=St(e.biasRegularizer),this.kernelConstraint=Qt(e.kernelConstraint),this.recurrentConstraint=Qt(e.recurrentConstraint),this.biasConstraint=Qt(e.biasConstraint),this.dropout=ap([1,wa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ap([1,wa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=tt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G(()=>{if(e=e,e.length!==2)throw new O(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let o=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ar(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ar(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=$s(R(e,a),this.kernel.read()):s=$s(e,this.kernel.read()),this.bias!=null&&(s=dn(s,this.bias.read())),i!=null&&(n=R(n,i));let u=Y(s,$s(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Aa(this.activation),useBias:this.useBias,kernelInitializer:Pt(this.kernelInitializer),recurrentInitializer:Pt(this.recurrentInitializer),biasInitializer:Pt(this.biasInitializer),kernelRegularizer:bt(this.kernelRegularizer),recurrentRegularizer:bt(this.recurrentRegularizer),biasRegularizer:bt(this.biasRegularizer),activityRegularizer:bt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),recurrentConstraint:Yt(this.recurrentConstraint),biasConstraint:Yt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return{...e,...t}}};cm.className="SimpleRNNCell";ee.registerClass(cm);var Dd=class extends Bs{constructor(e){e.cell=new cm(e);super(e)}call(e,t){return G(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return new e(t)}};Dd.className="SimpleRNN";ee.registerClass(Dd);var mm=class extends tl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(e.resetAfter)throw new O("GRUCell does not support reset_after parameter set to true.");this.units=e.units,sr(this.units,"units"),this.activation=Na(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Na(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=It(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=It(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=It(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=St(e.kernelRegularizer),this.recurrentRegularizer=St(e.recurrentRegularizer),this.biasRegularizer=St(e.biasRegularizer),this.kernelConstraint=Qt(e.kernelConstraint),this.recurrentConstraint=Qt(e.recurrentConstraint),this.biasConstraint=Qt(e.biasConstraint),this.dropout=ap([1,wa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ap([1,wa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=tt(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G(()=>{if(e=e,e.length!==2)throw new O(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ar(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ar(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,u,l;0<this.dropout&&this.dropout<1&&(e=R(e,s[0]));let p=$s(e,this.kernel.read());this.useBias&&(p=dn(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=R(o,a[0]));let c=this.recurrentKernel.read(),[m,f]=Ir(c,[2*this.units,this.units],c.rank-1),d=$s(o,m),[h,g,y]=Ir(p,3,p.rank-1),[x,T]=Ir(d,2,d.rank-1);i=this.recurrentActivation.apply(Y(h,x)),u=this.recurrentActivation.apply(Y(g,T));let k=$s(R(u,o),f);l=this.activation.apply(Y(y,k));let w=Y(R(i,o),R(Y(1,et(i)),l));return[w,w]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Aa(this.activation),recurrentActivation:Aa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Pt(this.kernelInitializer),recurrentInitializer:Pt(this.recurrentInitializer),biasInitializer:Pt(this.biasInitializer),kernelRegularizer:bt(this.kernelRegularizer),recurrentRegularizer:bt(this.recurrentRegularizer),biasRegularizer:bt(this.biasRegularizer),activityRegularizer:bt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),recurrentConstraint:Yt(this.recurrentConstraint),biasConstraint:Yt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return{...e,...t}}};mm.className="GRUCell";ee.registerClass(mm);var Pd=class extends Bs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mm(e);super(e)}call(e,t){return G(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Pd.className="GRU";ee.registerClass(Pd);var rl=class extends tl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=e.units,sr(this.units,"units"),this.activation=Na(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Na(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=It(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=It(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=It(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=St(e.kernelRegularizer),this.recurrentRegularizer=St(e.recurrentRegularizer),this.biasRegularizer=St(e.biasRegularizer),this.kernelConstraint=Qt(e.kernelConstraint),this.recurrentConstraint=Qt(e.recurrentConstraint),this.biasConstraint=Qt(e.biasConstraint),this.dropout=ap([1,wa([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=ap([1,wa([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var o;e=tt(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let n;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,a=this.units;n=new(o=class extends En{apply(u,l){let p=s.apply([a]),c=new lp().apply([a]),m=s.apply([a*2]);return CC(CC(p,c),m)}},o.className="CustomInit",o)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return G(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new O(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ar(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ar(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,u,l,p,c;0<this.dropout&&this.dropout<1&&(e=R(e,a[0]));let m=$s(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=R(o,i[0])),m=Y(m,$s(o,this.recurrentKernel.read())),this.useBias&&(m=dn(m,this.bias.read()));let[f,d,h,g]=Ir(m,4,m.rank-1);u=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(d),p=Y(R(l,s),R(u,this.activation.apply(h))),c=this.recurrentActivation.apply(g);let y=R(c,this.activation.apply(p));return[y,y,p]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Aa(this.activation),recurrentActivation:Aa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Pt(this.kernelInitializer),recurrentInitializer:Pt(this.recurrentInitializer),biasInitializer:Pt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:bt(this.kernelRegularizer),recurrentRegularizer:bt(this.recurrentRegularizer),biasRegularizer:bt(this.biasRegularizer),activityRegularizer:bt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),recurrentConstraint:Yt(this.recurrentConstraint),biasConstraint:Yt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return{...e,...t}}};rl.className="LSTMCell";ee.registerClass(rl);var Fd=class extends Bs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new rl(e);super(e)}call(e,t){return G(()=>{this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Fd.className="LSTM";ee.registerClass(Fd);var fm=class extends tl{constructor(e){super(e);this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return G(()=>{e=e;let n=e.slice(1),o=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?o.push(n.splice(0,i.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let u=this.cells[i];n=o[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=u.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){qb(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,o)=>{va(`RNNCell_${o}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(t)};return{...e,...o}}static fromConfig(e,t,n={}){let o=[];for(let s of t.cells)o.push(gn(s,n));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return sd(e)}setWeights(e){let t=[];for(let n of this.cells){let o=n.weights.length,s=e.splice(o);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}rm(t)}};fm.className="StackedRNNCells";ee.registerClass(fm);function iu(r){let{ones:e,rate:t,training:n=!1,count:o=1,dropoutFunc:s}=r,a=()=>s!=null?s(e(),t):Vb(e(),t),i=()=>qu(a,e,n);return!o||o<=1?Kt(i().clone()):Array(o).fill(void 0).map(i).map(l=>Kt(l.clone()))}var uv=class extends Bs{constructor(e){if(e.unroll)throw new Pe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Pe("It is not possible at the moment to stack convolutional cells.");super(e);this.inputSpec=[new Ft({ndim:5})]}call(e,t){return G(()=>{if(this.cell.dropoutMask!=null&&(Ee(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Ee(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new O("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return G(()=>{let{stateSize:t}=this.cell,n=e.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],a=Tt(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){G(()=>{if(!this.stateful)throw new Yn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Tt(s)):this.states_=[Tt(s)];else if(e==null)Ee(this.states_),this.keptStates!=null&&(Ee(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Tt(s)):this.states_[0]=Tt(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Ee(this.states_);for(let i=0;i<this.states_.length;++i){let u=e[i],l=s;if(!b.arraysEqual(u.shape,l))throw new O(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[i]=u}}this.states_=this.states_.map(i=>Kt(i.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:o,padding:s,strides:a,dilationRate:i}=this.cell,u=t==="channelsFirst",l=e[u?3:2],p=e[u?4:3],c=Rn(l,o[0],s,a[0],i[0]),m=Rn(p,o[1],s,a[1],i[1]);return[...e.slice(0,2),...u?[n,c,m]:[c,m,n]]}};uv.className="ConvRNN2D";var dm=class extends rl{constructor(e){let{filters:t,kernelSize:n,strides:o,padding:s,dataFormat:a,dilationRate:i}=e;super({...e,units:t});this.filters=t,sr(this.filters,"filters"),this.kernelSize=el(n,2,"kernelSize"),this.kernelSize.forEach(u=>sr(u,"kernelSize")),this.strides=el(o||1,2,"strides"),this.strides.forEach(u=>sr(u,"strides")),this.padding=s||"valid",fn(this.padding),this.dataFormat=a||"channelsLast",Vt(this.dataFormat),this.dilationRate=el(i||1,2,"dilationRate"),this.dilationRate.forEach(u=>sr(u,"dilationRate"))}build(e){var i;e=tt(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=4,s=this.kernelSize.concat([n,this.filters*o]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let l=this.biasInitializer,p=this.filters;u=new(i=class extends En{apply(m,f){let d=l.apply([p]),h=mr([p]),g=l.apply([p*2]);return jc([d,h,g])}},i.className="CustomInit",i)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return G(()=>{if(e.length!==3)throw new O(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,o=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=iu({ones:()=>Ar(o),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(oe,te,le)=>!te||!te[le]?oe:R(te[le],oe),p=l(o,u,0),c=l(o,u,1),m=l(o,u,2),f=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=iu({ones:()=>Ar(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let d=this.recurrentDropoutMask,h=l(s,d,0),g=l(s,d,1),y=l(s,d,2),x=l(s,d,3),T=3,[k,w,P,A]=Ir(this.kernel.read(),i,T),[F,E,$,W]=this.useBias?Ir(this.bias.read(),i):[null,null,null,null];p=this.inputConv(p,k,F,this.padding),c=this.inputConv(c,w,E,this.padding),m=this.inputConv(m,P,$,this.padding),f=this.inputConv(f,A,W,this.padding);let[K,B,V,j]=Ir(this.recurrentKernel.read(),i,T);h=this.recurrentConv(h,K),g=this.recurrentConv(g,B),y=this.recurrentConv(y,V),x=this.recurrentConv(x,j);let H=this.recurrentActivation.apply(Y(p,h)),J=this.recurrentActivation.apply(Y(c,g)),X=Y(R(J,a),R(H,this.activation.apply(Y(m,y)))),ne=R(this.recurrentActivation.apply(Y(f,x)),this.activation.apply(X));return[ne,ne,X]})}getConfig(){let{units:e,...t}=super.getConfig(),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return{...t,...n}}inputConv(e,t,n,o){let s=qn(e,t,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?dn(s,n,this.dataFormat):s}recurrentConv(e,t){return qn(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};dm.className="ConvLSTM2DCell";ee.registerClass(dm);var Md=class extends uv{constructor(e){let t=new dm(e);super({...e,cell:t})}static fromConfig(e,t){return new e(t)}};Md.className="ConvLSTM2D";ee.registerClass(Md);var hm=class extends Ke{constructor(e){super(e);this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?t[o]:this.noiseShape[o]);return n}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e);if(0<this.rate&&this.rate<1){let o=t.training==null?!1:t.training,s=this.getNoiseShape(n);return qu(()=>Vb(n,this.rate,s,this.seed),()=>n,o)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};hm.className="Dropout";ee.registerClass(hm);var Ed=class extends hm{constructor(e){super(e);this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};Ed.className="SpatialDropout1D";ee.registerClass(Ed);var Rd=class extends Ke{constructor(e){super(e);this.activation=null;this.useBias=!0;this.kernel=null;this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,sr(this.units,"units"),this.activation=Na(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=It(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=It(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Qt(e.kernelConstraint),this.biasConstraint=Qt(e.biasConstraint),this.kernelRegularizer=St(e.kernelRegularizer),this.biasRegularizer=St(e.biasRegularizer),this.activityRegularizer=St(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=tt(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=tt(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e),o=zb(this.activation.getClassName()),s;return o!=null?s=$s(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=$s(n,this.kernel.read()),this.bias!=null&&(s=dn(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:Aa(this.activation),useBias:this.useBias,kernelInitializer:Pt(this.kernelInitializer),biasInitializer:Pt(this.biasInitializer),kernelRegularizer:bt(this.kernelRegularizer),biasRegularizer:bt(this.biasRegularizer),activityRegularizer:bt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),biasConstraint:Yt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Rd.className="Dense";ee.registerClass(Rd);var Ld=class extends Ke{constructor(e){e=e||{};super(e);this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=tt(e);for(let t of e.slice(1))if(t==null)throw new O(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ls(e,1)]}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=qe(n,o)}return KP(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};Ld.className="Flatten";ee.registerClass(Ld);var $d=class extends Ke{constructor(e){super(e);this.supportsMasking=!0,this.activation=Na(e.activation)}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e);return this.activation.apply(n)})}getConfig(){let e={activation:Aa(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};$d.className="Activation";ee.registerClass($d);var Bd=class extends Ke{constructor(e){super(e);this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return G(()=>(e=Ge(e),WP(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};Bd.className="RepeatVector";ee.registerClass(Bd);var Od=class extends Ke{constructor(e){super(e);this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",o=t.slice(),s=1,a=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(a===null)a=u;else throw new O("Can only specifiy one unknown dimension.");else s*=l}let i=Ls(e);if(a!==null){if(s===0||i%s!=0)throw new O(n);o[a]=i/s}else if(i!==s)throw new O(n);return o}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return L(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Od.className="Reshape";ee.registerClass(Od);var zd=class extends Ke{constructor(e){super(e);if(e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=en(1,e.dims.length+1);if(!b.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ft({ndim:this.dims.length+1})]}computeOutputShape(e){e=tt(e);let t=e.slice();return this.dims.forEach((n,o)=>{t[o+1]=e[n]}),t}call(e,t){return qe(Ge(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};zd.className="Permute";ee.registerClass(zd);var Gd=class extends Ke{constructor(e){super(e??{});this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Ge(e),o=-1;return Ec(Za(n,this.maskValue),o)}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e),o=-1,s=!0,a=Ec(Za(n,this.maskValue),o,s);return R(n,Q(a,n.dtype))})}};Gd.className="Masking";ee.registerClass(Gd);var Wd=class extends Ke{constructor(e){super(e);this.embeddings=null;this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform";if(e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(wt(e.inputLength))}this.inputDim=e.inputDim,sr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,sr(this.outputDim,"outputDim"),this.embeddingsInitializer=It(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=St(e.embeddingsRegularizer),this.activityRegularizer=St(e.activityRegularizer),this.embeddingsConstraint=Qt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return G(()=>this.maskZero?(e=Ge(e),Za(e,De(e))):null)}computeOutputShape(e){if(e=tt(e),this.inputLength==null)return[...e,this.outputDim];let t=wt(this.inputLength);if(t.length!==e.length-1)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let o=0;o<t.length;++o){let s=t[o],a=e[o+1];if(s!=null&&a!=null&&s!==a)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e);n.dtype!=="int32"&&(n=ip(n,"int32"));let o=Kb(this.embeddings.read(),L(n,[n.size]));return L(o,tt(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Pt(this.embeddingsInitializer),embeddingsRegularizer:bt(this.embeddingsRegularizer),activityRegularizer:bt(this.activityRegularizer),embeddingsConstraint:Yt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};Wd.className="Embedding";ee.registerClass(Wd);var nl=class extends Ke{constructor(e){super(e||{});this.supportsMasking=!0}mergeFunction(e){throw new Pe}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let o=0;o<t.length;++o){let s=e[e.length-t.length+o],a=t[o];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new O("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[tt(e)]),e=e,e.length<2)throw new O(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Rs(t),t.length>1)throw new O(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let o=e.map(s=>s.length);e.indexOf(null)===-1&&Rs(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return G(()=>{if(e=e,this.reshapeRequired){let n=[],o=e.map(s=>s.rank);if(o.indexOf(null)===-1){let s=wa(o);for(let a of e){let i=a.rank;for(let u=0;u<s-i;++u)a=su(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let u of e){let l=u.rank;if(l==null){let p=u.shape,c=p[0],m=p.slice(1).concat([c]),f=L(u,[c].concat(Ls(p.slice(1))));f=qe(f,[1,0]),f=L(f,m),n.push(f),s=!0}else if(l>1){let p=en(1,l).concat([0]);n.push(qe(u,p)),s=!0}else n.push(u)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let u=a.shape,l=u.length,p=u[l-1],c=[p].concat(u.slice(0,u.length-1));a=L(qe(L(a,[-1,p]),[1,0]),c)}else if(i>1){let u=[i-1].concat(en(0,i-1));a=qe(a,u)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let o=1;o<e.length;++o){let s=e[o]==null?null:e[o].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let o of e)o!=null&&o[0]!==null&&n.push(o[0]);return n=Rs(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return G(()=>{if(t==null)return null;if(!Array.isArray(t))throw new O("`mask` should be an Array");if(!Array.isArray(e))throw new O("`inputs` should be an Array");if(t.length!==e.length)throw new O(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(o=>o==null))return null;t=t.map(o=>o==null?o:_r(o,0));let n=t[0];for(let o=1;o<t.length-1;++o)n=jr(n,t[o]);return n})}},Ud=class extends nl{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Y(t,e[n]);return t})}};Ud.className="Add";ee.registerClass(Ud);var Kd=class extends nl{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=R(t,e[n]);return t})}};Kd.className="Multiply";ee.registerClass(Kd);var Vd=class extends nl{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Y(t,e[n]);return R(1/e.length,t)})}};Vd.className="Average";ee.registerClass(Vd);var jd=class extends nl{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Xn(t,e[n]);return t})}};jd.className="Maximum";ee.registerClass(jd);var Hd=class extends nl{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ji(t,e[n]);return t})}};Hd.className="Minimum";ee.registerClass(Hd);var qd=class extends nl{constructor(e){super(e);this.DEFAULT_AXIS=-1;e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new O("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let o of e)if(o!=null){t=!1;break}if(t)return;let n=[];for(let o=0;o<e.length;++o){let s=e[o].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if(b.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new O("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return G(()=>jc(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new O("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new O("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new O("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new O(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return G(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let o=[];for(let a=0;a<e.length;++a)t[a]==null?o.push(Q(Ar(e[a]),"bool")):t[a].rank<e[a].rank?o.push(_r(t[a],-1)):o.push(t[a]);let s=lt(o,this.axis);return bf(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};qd.className="Concatenate";ee.registerClass(qd);function Xd(r,e){for(;r<0;)r+=e;return r}function dQ(r,e,t){if(r.shape.length>3||e.shape.length>3)throw new Pe("batchDot is not implemented for tensors of 4D or higher rank yet");if(b.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),b.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),r.dtype==="complex64"||e.dtype==="complex64")throw new Pe("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=e.shape.length;t==null&&(t=[n-1,o-2]);let s=t;return G(()=>{let a;if(n>o){a=n-o;let u=[];for(let l=0;l<a;++l)u.push(1);e=L(e,e.shape.concat(u))}else if(o>n){a=o-n;let u=[];for(let l=0;l<a;++l)u.push(1);r=L(r,r.shape.concat(u))}else a=0;let i;if(r.shape.length===2&&e.shape.length===2)s[0]===s[1]?i=me(R(r,e),s[0]):i=me(R(qe(r,[1,0]),e),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===e.shape.length-1;i=Ve(r,e,u,l)}if(a>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let p=u;p<u+a;++p)l.push(p);i=cn(i,l)}return i.shape.length===1&&(i=_r(i,1)),i})}var Yd=class extends nl{constructor(e){super(e);this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Pe("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);if(t[o[0]]!==n[o[1]])throw new O(`Dimension incompatibility: ${t[o[0]]} !== ${n[o[1]]}`)}mergeFunction(e){if(e.length!==2)throw new O(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,a)=>Xd(s,e[a].shape.length)):o=[Xd(this.axes,t.shape.length),Xd(this.axes,n.shape.length)],this.normalize&&(t=id(t,o[0]),n=id(n,o[1])),dQ(t,n,o)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Xd(this.axes,e.length),Xd(this.axes,t.length)],n}computeOutputShape(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Pe("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);t.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};Yd.className="Dot";ee.registerClass(Yd);var Qd=class extends Ke{constructor(e){super(e);this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e);return qu(()=>Y(Hc(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};Qd.className="GaussianNoise";ee.registerClass(Qd);var Zd=class extends Ke{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Ge(e);return this.rate>0&&this.rate<1?qu(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return R(n,Hc(n.shape,1,s))},()=>n,t.training||!1):n})}};Zd.className="GaussianDropout";ee.registerClass(Zd);var Jd=class extends Ke{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Ge(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return G(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return qu(()=>{let s=Ge(e),a=1.6732632423543772,i=1.0507009873554805,u=-a*i,l=qo(Ca(n),this.rate);l=ip(l,"float32");let p=((1-this.rate)*(1+this.rate*u**2))**-.5,c=-p*u*this.rate,m=Y(R(s,l),R(Y(l,-1),u));return Y(R(m,p),c)},()=>Ge(e),t.training||!1)}return e})}};Jd.className="AlphaDropout";ee.registerClass(Jd);function eh(r,e,t,n,o,s=.001){let a;if(r.rank===2)a=gI(r,e,t,n,o,s);else if(r.rank===3)a=bI(r,e,t,n,o,s);else if(r.rank===4)a=yI(r,e,t,n,o,s);else throw new Pe(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return a}function hQ(r,e,t,n,o=.001){return G(()=>{let s=Oc(r,n),a=s.mean,i=s.variance;return[eh(r,a,i,t,e,o),a,i]})}function gQ(r,e,t,n,o=.001){return G(()=>{let s=Oc(r,n),a=s.mean,i=s.variance,u=[];for(let d of en(0,r.rank))n.indexOf(d)!==-1?u.push(1):u.push(r.shape[d]);let l=L(a,u),p=L(i,u),c=e==null?null:L(e,u),m=t==null?null:L(t,u);return[eh(r,l,p,m,c,o),a,i]})}function bQ(r,e,t,n,o=.001){return b.arraysEqual(n.slice().sort(),en(0,r.rank-1))?hQ(r,e,t,n,o):gQ(r,e,t,n,o)}var th=class extends Ke{constructor(e){e==null&&(e={});super(e);this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=It(e.betaInitializer||"zeros"),this.gammaInitializer=It(e.gammaInitializer||"ones"),this.movingMeanInitializer=It(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=It(e.movingVarianceInitializer||"ones"),this.betaConstraint=Qt(e.betaConstraint),this.gammaConstraint=Qt(e.gammaConstraint),this.betaRegularizer=St(e.betaRegularizer),this.gammaRegularizer=St(e.gammaRegularizer)}build(e){e=tt(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new O(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ft({ndim:e.length,axes:{[t]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return G(()=>{let n=t.training==null?!1:t.training,o=Ge(e),s=o.shape,a=s.length,i=en(0,a),u=this.axis>=0?this.axis:this.axis+a;i.splice(u,1);let l=Fs(1,a);l[u]=s[u];let p=i.slice();p.sort();let c=!b.arraysEqual(p,en(0,a).slice(0,a-1)),m=()=>{if(c){let x=L(this.movingMean.read(),l),T=L(this.movingVariance.read(),l),k=this.center?L(this.beta.read(),l):null,w=this.scale?L(this.gamma.read(),l):null;return eh(o,x,T,k,w,this.epsilon)}else return eh(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return m();let[f,d,h]=bQ(o,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(x,T,k)=>{G(()=>{let w=1-k,P=x.read(),A=R(ue(P,T),w);x.write(ue(P,A))})};return(()=>{g(this.movingMean,d,this.momentum),g(this.movingVariance,h,this.momentum)})(),f})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Pt(this.betaInitializer),gammaInitializer:Pt(this.gammaInitializer),movingMeanInitializer:Pt(this.movingMeanInitializer),movingVarianceInitializer:Pt(this.movingVarianceInitializer),betaRegularizer:bt(this.betaRegularizer),gammaRegularizer:bt(this.gammaRegularizer),betaConstraint:Yt(this.betaConstraint),gammaConstraint:Yt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};th.className="BatchNormalization";ee.registerClass(th);var rh=class extends Ke{constructor(e){e==null&&(e={});super(e);if(this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=It(e.betaInitializer||"zeros"),this.gammaInitializer=It(e.gammaInitializer||"ones"),this.betaRegularizer=St(e.betaRegularizer),this.gammaRegularizer=St(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=tt(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Rs(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(e,t){let n=Ge(e),o=n.shape,s=o.length;return G(()=>{let a=!0,{mean:i,variance:u}=Oc(n,this.axis,a),l=Fs(1,s);for(let h of this.axis)l[h]=o[h];let p=h=>h!=null&&h.shape.length!==s?L(h,l):h,c=p(this.gamma.read()),m=p(this.beta.read()),f=[],d=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(f.push(o[h]),d.push(1)):(f.push(1),d.push(o[h]));return i=Vr(i,f),u=Vr(u,f),c=Vr(c,d),m=Vr(m,d),eh(n,i,u,m,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Pt(this.betaInitializer),gammaInitializer:Pt(this.gammaInitializer),betaRegularizer:bt(this.betaRegularizer),gammaRegularizer:bt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};rh.className="LayerNormalization";ee.registerClass(rh);function yQ(r,e,t){return G(()=>{if(r.rank!==4)throw new O(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new O("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=mn()),t!=="channelsLast"&&t!=="channelsFirst")throw new O(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return t==="channelsFirst"?n=[[0,0],[0,0],e[0],e[1]]:n=[[0,0],e[0],e[1],[0,0]],Pn(r,n)})}var nh=class extends Ke{constructor(e){e==null&&(e={});super(e);if(this.dataFormat=e.dataFormat==null?mn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new O(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new O(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new O(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){e=tt(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return G(()=>yQ(Ge(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};nh.className="ZeroPadding2D";ee.registerClass(nh);function my(r,e,t,n,o,s){return G(()=>{Vt(o),kC(s),fn(n),t==null&&(t=[1,1]),n==null&&(n="valid"),o==null&&(o=mn()),s==null&&(s="max"),r=Id(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=Gl(r,e,t,i):a=Ml(r,e,t,i),o==="channelsFirst"&&(a=qe(a,[0,3,1,2])),a})}function AF(r,e,t,n,o,s){return G(()=>{Vt(o),kC(s),fn(n),t==null&&(t=[1,1,1]),n==null&&(n="valid"),o==null&&(o=mn()),s==null&&(s="max"),r=ev(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=Nf(r,e,t,i):a=yf(r,e,t,i),o==="channelsFirst"&&(a=qe(a,[0,4,1,2,3])),a})}var lv=class extends Ke{constructor(e){e.poolSize==null&&(e.poolSize=2);super(e);if(typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new O(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(sr(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new O(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,fn(this.padding),this.inputSpec=[new Ft({ndim:3})]}computeOutputShape(e){e=tt(e);let t=Rn(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return G(()=>{this.invokeCallHook(e,t),e=su(Ge(e),2);let n=this.poolingFunction(Ge(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return cn(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},oh=class extends lv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Vt(s),fn(o),my(e,t,n,o,s,"max")}};oh.className="MaxPooling1D";ee.registerClass(oh);var sh=class extends lv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Vt(s),fn(o),my(e,t,n,o,s,"avg")}};sh.className="AveragePooling1D";ee.registerClass(sh);var pv=class extends Ke{constructor(e){e.poolSize==null&&(e.poolSize=[2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new O(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];sr(this.poolSize,"poolSize"),sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),fn(this.padding),this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){e=tt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Rn(t,this.poolSize[0],this.padding,this.strides[0]),n=Rn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return G(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},ah=class extends pv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Vt(s),fn(o),my(e,t,n,o,s,"max")}};ah.className="MaxPooling2D";ee.registerClass(ah);var ih=class extends pv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Vt(s),fn(o),my(e,t,n,o,s,"avg")}};ih.className="AveragePooling2D";ee.registerClass(ih);var cv=class extends Ke{constructor(e){e.poolSize==null&&(e.poolSize=[2,2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new O(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];sr(this.poolSize,"poolSize"),sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),fn(this.padding),this.inputSpec=[new Ft({ndim:5})]}computeOutputShape(e){e=tt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Rn(t,this.poolSize[0],this.padding,this.strides[0]),n=Rn(n,this.poolSize[1],this.padding,this.strides[1]),o=Rn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,o]:[e[0],t,n,o,e[4]]}call(e,t){return G(()=>(this.invokeCallHook(e,t),this.poolingFunction(Ge(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},uh=class extends cv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Vt(s),fn(o),AF(e,t,n,o,s,"max")}};uh.className="MaxPooling3D";ee.registerClass(uh);var lh=class extends cv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Vt(s),fn(o),AF(e,t,n,o,s,"avg")}};lh.className="AveragePooling3D";ee.registerClass(lh);var mv=class extends Ke{constructor(e){super(e);this.inputSpec=[new Ft({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Pe}},ph=class extends mv{constructor(e){super(e||{})}call(e,t){return G(()=>{let n=Ge(e);return Rt(n,1)})}};ph.className="GlobalAveragePooling1D";ee.registerClass(ph);var ch=class extends mv{constructor(e){super(e||{})}call(e,t){return G(()=>{let n=Ge(e);return Qr(n,1)})}};ch.className="GlobalMaxPooling1D";ee.registerClass(ch);var fv=class extends Ke{constructor(e){super(e);this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Pe}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},mh=class extends fv{call(e,t){return G(()=>{let n=Ge(e);return this.dataFormat==="channelsLast"?Rt(n,[1,2]):Rt(n,[2,3])})}};mh.className="GlobalAveragePooling2D";ee.registerClass(mh);var fh=class extends fv{call(e,t){return G(()=>{let n=Ge(e);return this.dataFormat==="channelsLast"?Qr(n,[1,2]):Qr(n,[2,3])})}};fh.className="GlobalMaxPooling2D";ee.registerClass(fh);var dv=class extends Ke{constructor(e){super(e);this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let o=t.layer,s=gn(o,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},dh=class extends dv{constructor(e){super(e);this.supportsMasking=!0}build(e){if(e=tt(e),e.length<3)throw new O(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=tt(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),o=e[1];return[n[0],o].concat(n.slice(1))}call(e,t){return G(()=>(e=Ge(e),av((a,i)=>[Ge(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};dh.className="TimeDistributed";ee.registerClass(dh);function xQ(r){ti($P,"BidirectionalMergeMode",r)}var TQ="concat",hh=class extends dv{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=gn(n),t.goBackwards=t.goBackwards!==!0;let o={};if(o.className=e.layer.getClassName(),o.config=t,this.backwardLayer=gn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?TQ:e.mergeMode,xQ(this.mergeMode),e.weights)throw new Pe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,o,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Nr(o)}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=sv(e,n,o,this.numConstants);if(e=s.inputs,n=s.initialState,o=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&o==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new O("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let p=n.map(c=>new Ft({shape:c.shape}));this.forwardLayer.stateSpec=p.slice(0,l/2),this.backwardLayer.stateSpec=p.slice(l/2),i.push(...p)}if(o!=null)throw new Pe("Support for constants in Bidirectional layers is not implemented yet.");let u=a[0]instanceof hn;for(let l of a)if(l instanceof hn!==u)throw new O("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[e].concat(a),p=this.inputSpec.concat(i),c=this.inputSpec;this.inputSpec=p;let m=super.apply(l,t);return this.inputSpec=c,m}else return super.apply(e,t)}call(e,t){return G(()=>{let n=t.initialState,o,s;if(n==null)o=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=xr(s,1));let i;return this.mergeMode==="concat"?i=jc([o,s]):this.mergeMode==="sum"?i=Y(o,s):this.mergeMode==="ave"?i=R(.5,Y(o,s)):this.mergeMode==="mul"?i=R(o,s):this.mergeMode==null&&(i=[o,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){va(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),va(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=gn(t.layer);if(delete t.layer,t.numConstants!=null)throw new Pe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=t;return o.layer=n,new e(o)}};hh.className="Bidirectional";ee.registerClass(hh);function kQ(r){return new ri(r)}function IQ(r){return new xd(r)}function CQ(r){return new gd(r)}function vQ(r){return new bd(r)}function wQ(r){return new yd(r)}function SQ(r){return new kd(r)}function _Q(r){return new Td(r)}function AQ(r){return new Sd(r)}function NQ(r){return new lm(r)}function DQ(r){return new Cd(r)}function PQ(r){return new pm(r)}function FQ(r){return new vd(r)}function MQ(r){return new wd(r)}function EQ(r){return new _d(r)}function RQ(r){return new Ad(r)}function LQ(r){return new Nd(r)}function $Q(r){return new $d(r)}function BQ(r){return new Rd(r)}function OQ(r){return new hm(r)}function zQ(r){return new Ed(r)}function GQ(r){return new Ld(r)}function WQ(r){return new Bd(r)}function UQ(r){return new Od(r)}function KQ(r){return new zd(r)}function VQ(r){return new Wd(r)}function jQ(r){return new Ud(r)}function HQ(r){return new Vd(r)}function qQ(r){return new qd(r)}function XQ(r){return new jd(r)}function YQ(r){return new Hd(r)}function QQ(r){return new Kd(r)}function ZQ(r){return new Yd(r)}function JQ(r){return new th(r)}function eZ(r){return new rh(r)}function tZ(r){return new nh(r)}function hv(r){return new sh(r)}function rZ(r){return hv(r)}function nZ(r){return hv(r)}function gv(r){return new ih(r)}function oZ(r){return gv(r)}function sZ(r){return gv(r)}function bv(r){return new lh(r)}function aZ(r){return bv(r)}function iZ(r){return bv(r)}function uZ(r){return new ph(r)}function lZ(r){return new mh(r)}function NF(r){return new ch(r)}function DF(r){return new fh(r)}function PF(r){return new oh(r)}function FF(r){return new ah(r)}function pZ(r){return new uh(r)}function cZ(r){return new Pd(r)}function mZ(r){return new mm(r)}function fZ(r){return new Fd(r)}function dZ(r){return new rl(r)}function hZ(r){return new Dd(r)}function gZ(r){return new cm(r)}function bZ(r){return new Md(r)}function yZ(r){return new dm(r)}function xZ(r){return new Bs(r)}function TZ(r){return new fm(r)}function kZ(r){return new hh(r)}function IZ(r){return new dh(r)}var CZ=NF,vZ=DF,wZ=PF,SZ=FF;function _Z(r){return new Qd(r)}function AZ(r){return new Zd(r)}function NZ(r){return new Jd(r)}function DZ(r){return new Gd(r)}var EF={};Qe(EF,{MAPE:()=>GZ,MSE:()=>KZ,binaryAccuracy:()=>PZ,binaryCrossentropy:()=>FZ,categoricalAccuracy:()=>EZ,categoricalCrossentropy:()=>RZ,cosineProximity:()=>BZ,mape:()=>WZ,meanAbsoluteError:()=>OZ,meanAbsolutePercentageError:()=>zZ,meanSquaredError:()=>UZ,mse:()=>VZ,precision:()=>LZ,recall:()=>$Z,sparseCategoricalAccuracy:()=>MZ});function PZ(r,e){return pd(r,e)}function FZ(r,e){return ty(r,e)}function MZ(r,e){return ry(r,e)}function EZ(r,e){return cd(r,e)}function RZ(r,e){return md(r,e)}function LZ(r,e){return NC(r,e)}function $Z(r,e){return nF(r,e)}function BZ(r,e){return ud(r,e)}function OZ(r,e){return nm(r,e)}function zZ(r,e){return Zu(r,e)}function GZ(r,e){return Zu(r,e)}function WZ(r,e){return Zu(r,e)}function UZ(r,e){return oi(r,e)}function KZ(r,e){return oi(r,e)}function VZ(r,e){return oi(r,e)}var RF={};Qe(RF,{modelFromJSON:()=>kF});var LF={};Qe(LF,{l1:()=>HZ,l1l2:()=>jZ,l2:()=>qZ});function jZ(r){return new fp(r)}function HZ(r){return CF(r)}function qZ(r){return vF(r)}var yv=class extends Qu{constructor(){super(...arguments);this.model=null}setModel(e){if(!(e instanceof Zo))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function fy(r,e){return r<e}function $F(r,e){return r>e}var xv=class extends yv{constructor(e){super();if(e==null&&(e={}),e.restoreBestWeights)throw new Pe("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=fy:this.mode==="max"?this.monitorFunc=$F:this.monitor.indexOf("acc")!==-1?this.monitorFunc=$F:this.monitorFunc=fy,this.monitorFunc===fy&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===fy?1/0:-1/0}async onEpochEnd(e,t){await ni(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function XZ(r){return new xv(r)}var YZ={earlyStopping:XZ};var Os;(function(B){B[B.DT_INVALID=0]="DT_INVALID",B[B.DT_FLOAT=1]="DT_FLOAT",B[B.DT_DOUBLE=2]="DT_DOUBLE",B[B.DT_INT32=3]="DT_INT32",B[B.DT_UINT8=4]="DT_UINT8",B[B.DT_INT16=5]="DT_INT16",B[B.DT_INT8=6]="DT_INT8",B[B.DT_STRING=7]="DT_STRING",B[B.DT_COMPLEX64=8]="DT_COMPLEX64",B[B.DT_INT64=9]="DT_INT64",B[B.DT_BOOL=10]="DT_BOOL",B[B.DT_QINT8=11]="DT_QINT8",B[B.DT_QUINT8=12]="DT_QUINT8",B[B.DT_QINT32=13]="DT_QINT32",B[B.DT_BFLOAT16=14]="DT_BFLOAT16",B[B.DT_FLOAT_REF=101]="DT_FLOAT_REF",B[B.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",B[B.DT_INT32_REF=103]="DT_INT32_REF",B[B.DT_UINT8_REF=104]="DT_UINT8_REF",B[B.DT_INT16_REF=105]="DT_INT16_REF",B[B.DT_INT8_REF=106]="DT_INT8_REF",B[B.DT_STRING_REF=107]="DT_STRING_REF",B[B.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",B[B.DT_INT64_REF=109]="DT_INT64_REF",B[B.DT_BOOL_REF=110]="DT_BOOL_REF",B[B.DT_QINT8_REF=111]="DT_QINT8_REF",B[B.DT_QUINT8_REF=112]="DT_QUINT8_REF",B[B.DT_QINT32_REF=113]="DT_QINT32_REF",B[B.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(Os||(Os={}));var BF;(function(e){let r;(function(s){s[s.LEGACY=0]="LEGACY",s[s.V1=1]="V1",s[s.V2=2]="V2"})(r=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(BF||(BF={}));var Tv={};function QZ(r,e){let t={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:e};Tv[r]=t}function dy(r){return Tv[r]}function ZZ(r){delete Tv[r]}function v(r,e,t,n,o){let s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){let i=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?i+1:s.inputIndexEnd;if(s.type==="tensor")return Cr(e.inputNames[s.inputIndexStart],t,n,o);if(s.type==="tensors")return e.inputNames.slice(i,u).map(m=>Cr(m,t,n,o));let l=Cr(e.inputNames.slice(i)[0],t,n,o),p=l.dataSync();return s.type==="number"?p[0]:b.toNestedArray(l.shape,p)}let a=e.attrParams[r];return a&&a.value}function Cr(r,e,t,n){let[o,s]=yn(r);if(n!=null){let i=n.getHashTableHandleByName(o);if(i!=null)return i}let a=t.currentContextIds.find(i=>!!e[hy(o,i)]);return a!==void 0?e[hy(o,a)][s]:void 0}function OF(r,e,t){return e[hy(r,t.currentContextId)]}function Pa(r,e){let[t,n,o]=yn(r);return[hy(t,e&&e.currentContextId),n,o]}function hy(r,e){return e?`${r}-${e}`:r}function yn(r){let e=r.split(":");if(e.length===1)return[r,0,void 0];let t=e[0],n=e.length===3?e[1]:void 0,o=Number(e[e.length-1]);return[t,o,n]}function gh(r,e,t){let n=v("pad",r,e,t);if(n==="explicit"){n=v("explicitPaddings",r,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function Fa(r){return r.kept?r:Nn(r)}var kv={};Qe(kv,{json:()=>JZ});var JZ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Iv={};Qe(Iv,{json:()=>eJ});var eJ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Cv={};Qe(Cv,{json:()=>tJ});var tJ=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var vv={};Qe(vv,{json:()=>rJ});var rJ=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var wv={};Qe(wv,{json:()=>nJ});var nJ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var Sv={};Qe(Sv,{json:()=>oJ});var oJ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var _v={};Qe(_v,{json:()=>sJ});var sJ=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var Av={};Qe(Av,{json:()=>aJ});var aJ=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var Nv={};Qe(Nv,{json:()=>iJ});var iJ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var Dv={};Qe(Dv,{json:()=>uJ});var uJ=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var Pv={};Qe(Pv,{json:()=>lJ});var lJ=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Fv={};Qe(Fv,{json:()=>pJ});var pJ=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var Mv={};Qe(Mv,{json:()=>cJ});var cJ=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var Ev={};Qe(Ev,{json:()=>mJ});var mJ=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var Rv={};Qe(Rv,{json:()=>fJ});var fJ=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var Lv={};Qe(Lv,{json:()=>dJ});var dJ=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var $v={};Qe($v,{json:()=>hJ});var hJ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var Bv={};Qe(Bv,{json:()=>gJ});var gJ=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var Ov={};Qe(Ov,{json:()=>bJ});var bJ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var gy=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[kv,Iv,Cv,vv,wv,Sv,_v,Av,Nv,Dv,Pv,Fv,Mv,Ev,Rv,Lv,$v,Bv,Ov],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(e,t={}){let n=e.node,o=[],s=[],a=[],i=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&a.push(h[g.name]),h),{}),u=[],l=[],p={},c={};t!=null&&(p=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let m=Object.keys(i);m.forEach(h=>{let g=i[h];g.inputNames.forEach((y,x)=>{let[T,,k]=Pa(y),w=i[T];if(w.outputs!=null){let P=w.outputs.indexOf(k);if(P!==-1){let A=`${T}:${P}`;g.inputNames[x]=A}}g.inputs.push(w),w.children.push(g)})}),Object.keys(c).length===0?m.forEach(h=>{let g=i[h];g.children.length===0&&l.push(g)}):Object.keys(c).forEach(h=>{let[g]=Pa(h),y=i[g];y!=null&&(y.signatureKey=c[h],l.push(y))}),Object.keys(p).length>0?Object.keys(p).forEach(h=>{let[g]=Pa(h),y=i[g];y&&(y.signatureKey=p[h],u.push(y))}):u=o;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let d={nodes:i,inputs:u,outputs:l,weights:s,placeholders:o,signature:t,functions:f};return a.length>0&&(d.initNodes=a),d}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=dy(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.substr(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((o,s)=>{let a=s.type,i;switch(s.type){case"string":i=by(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=by(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=vy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=vy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=xy(e.attr,s.tfName,s.defaultValue||0),i===void 0&&!!s.tfDeprecatedName&&(i=xy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=Cy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=Cy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=yy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=yy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=Sy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=Sy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=Iy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=Iy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=wy(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=wy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=Ty(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=Ty(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=ky(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ky(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=GF(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=GF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:i,type:a},o},{})),n}mapFunction(e){let t=e.nodeDef,n=[],o=[],s={};t!=null&&(s=t.reduce((c,m)=>(c[m.name]=this.mapNode(m),m.op==="Const"&&o.push(c[m.name]),c),{}));let a=[],i=[];e.signature.inputArg.forEach(c=>{let[m]=Pa(c.name),f={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:zv(c.type),type:"dtype"}},children:[]};f.signatureKey=c.name,a.push(f),s[m]=f}),Object.keys(s).forEach(c=>{let m=s[c];m.inputNames.forEach((f,d)=>{let[h,,g]=Pa(f),y=s[h];if(y.outputs!=null){let x=y.outputs.indexOf(g);if(x!==-1){let T=`${h}:${x}`;m.inputNames[d]=T}}m.inputs.push(y),y.children.push(m)})});let l=e.ret;e.signature.outputArg.forEach(c=>{let[m,f]=Pa(l[c.name]),d=s[m];d!=null&&(d.defaultOutput=f,i.push(d))});let p=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:o,placeholders:n,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function yJ(r){let e=U().global;if(typeof e.atob!="undefined")return e.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function zF(r,e){let t=Array.isArray(r)?String.fromCharCode.apply(null,r):yJ(r);return e?t:t.toLowerCase()}function by(r,e,t,n=!1){let o=r[e];return o!=null?zF(o.s,n):t}function yy(r,e,t){let n=r[e];return n?n.b:t}function xy(r,e,t){let n=r[e]||{},o=n.i!=null?n.i:n.f!=null?n.f:t;return typeof o=="number"?o:parseInt(o,10)}function zv(r){switch(typeof r=="string"&&(r=Os[r]),r){case Os.DT_FLOAT:return"float32";case Os.DT_INT32:case Os.DT_INT64:case Os.DT_INT8:case Os.DT_UINT8:return"int32";case Os.DT_BOOL:return"bool";case Os.DT_DOUBLE:return"float32";case Os.DT_STRING:return"string";default:return null}}function GF(r,e,t){let n=r[e];return n&&n.func?n.func.name:t}function Ty(r,e,t){let n=r[e];return n&&n.type?zv(n.type):t}function ky(r,e,t){let n=r[e];return n&&n.list&&n.list.type?n.list.type.map(o=>zv(o)):t}function WF(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Iy(r,e,t){let n=r[e];return n&&n.shape?WF(n.shape):t}function Cy(r,e,t){let n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function vy(r,e,t,n=!1){let o=r[e];return o&&o.list&&o.list.s?o.list.s.map(s=>zF(s,n)):t}function wy(r,e,t){let n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(o=>WF(o)):t}function Sy(r,e,t){let n=r[e];return n&&n.list&&n.list.b?n.list.b:t}var Gv=class{constructor(e,t,n){this.node=e;this.tensorMap=t;this.context=n;this.inputs=[];this.attrs={};this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(e){return Cr(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return Cr(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return xy(this.node.rawAttrs,e,t);if(n.s!=null)return by(this.node.rawAttrs,e,t);if(n.b!=null)return yy(this.node.rawAttrs,e,t);if(n.shape!=null)return Iy(this.node.rawAttrs,e,t);if(n.type!=null)return Ty(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Cy(this.node.rawAttrs,e,t);if(n.list.s!=null)return vy(this.node.rawAttrs,e,t);if(n.list.shape!=null)return wy(this.node.rawAttrs,e,t);if(n.list.b!=null)return Sy(this.node.rawAttrs,e,t);if(n.list.type!=null)return ky(this.node.rawAttrs,e,t)}return t}};var UF=(r,e,t)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[Y(v("a",r,e,t),v("b",r,e,t))];case"AddN":return[aI(v("tensors",r,e,t))];case"FloorMod":case"Mod":return[WI(v("a",r,e,t),v("b",r,e,t))];case"Mul":return[R(v("a",r,e,t),v("b",r,e,t))];case"RealDiv":case"Div":return[pe(v("a",r,e,t),v("b",r,e,t))];case"DivNoNan":return[NI(v("a",r,e,t),v("b",r,e,t))];case"FloorDiv":return[gf(v("a",r,e,t),v("b",r,e,t))];case"Sub":return[ue(v("a",r,e,t),v("b",r,e,t))];case"Minimum":return[Ji(v("a",r,e,t),v("b",r,e,t))];case"Maximum":return[Xn(v("a",r,e,t),v("b",r,e,t))];case"Pow":return[Fn(v("a",r,e,t),v("b",r,e,t))];case"SquaredDifference":return[Gf(v("a",r,e,t),v("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var KF=(r,e,t)=>{switch(r.op){case"Abs":case"ComplexAbs":return[Ot(v("x",r,e,t))];case"Acos":return[oI(v("x",r,e,t))];case"Acosh":return[sI(v("x",r,e,t))];case"Asin":return[uI(v("x",r,e,t))];case"Asinh":return[lI(v("x",r,e,t))];case"Atan":return[pI(v("x",r,e,t))];case"Atan2":return[cI(v("x",r,e,t),v("y",r,e,t))];case"Atanh":return[mI(v("x",r,e,t))];case"Ceil":return[TI(v("x",r,e,t))];case"Complex":return[Hn(v("real",r,e,t),v("imag",r,e,t))];case"Cos":return[Ll(v("x",r,e,t))];case"Cosh":return[Cf(v("x",r,e,t))];case"Elu":return[Qi(v("x",r,e,t))];case"Erf":return[PI(v("x",r,e,t))];case"Exp":return[cr(v("x",r,e,t))];case"Expm1":return[FI(v("x",r,e,t))];case"Floor":return[Zi(v("x",r,e,t))];case"Log":return[$r(v("x",r,e,t))];case"Log1p":return[Ol(v("x",r,e,t))];case"Imag":return[$l(v("x",r,e,t))];case"Neg":return[et(v("x",r,e,t))];case"Reciprocal":return[ZI(v("x",r,e,t))];case"Real":return[ju(v("x",r,e,t))];case"Relu":return[Hr(v("x",r,e,t))];case"Round":return[Mf(v("x",r,e,t))];case"Selu":return[Rf(v("x",r,e,t))];case"Sigmoid":return[ln(v("x",r,e,t))];case"Sin":return[Lf(v("x",r,e,t))];case"Sign":return[tC(v("x",r,e,t))];case"Sinh":return[$f(v("x",r,e,t))];case"Softplus":return[Qa(v("x",r,e,t))];case"Sqrt":return[Lt(v("x",r,e,t))];case"Square":return[Xe(v("x",r,e,t))];case"Tanh":return[Xi(v("x",r,e,t))];case"Tan":return[nC(v("x",r,e,t))];case"ClipByValue":return[Lr(v("x",r,e,t),v("clipValueMin",r,e,t),v("clipValueMax",r,e,t))];case"Relu6":return[Ff(v("x",r,e,t))];case"Rsqrt":return[Ef(Cr(r.inputNames[0],e,t))];case"Prod":return[Df(v("x",r,e,t),v("axes",r,e,t))];case"LeakyRelu":return[Bl(v("x",r,e,t),v("alpha",r,e,t))];case"Prelu":return[Ul(v("x",r,e,t),v("alpha",r,e,t))];case"IsNan":return[MI(Cr(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Qn(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){b.assert(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=e[n];b.assert(o<0||s<0||o===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function VF(r){return!(typeof r=="number"||r.some(e=>e<0))}function gm(r,e,t){let n=_y(r,t),o=!VF(n);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&e.forEach(s=>{n=_y(s.shape,n)}),!VF(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function _y(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);let t=[];for(let n=0;n<r.length;++n){let o=r[n],s=e[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=o>=0?o:s}return t}var Wv=class{constructor(e,t,n,o,s,a,i){this.name=e;this.dtype=t;this.maxSize=n;this.elementShape=o;this.identicalElementShapes=s;this.dynamicSize=a;this.clearAfterRead=i;this.tensors=[];this.closed_=!1;this.idTensor=ce(0),Kt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Qn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Kt(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,o)=>this.write(n,t[o]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return Er([],[0].concat(this.elementShape));let n=this.readMany(e);return Qn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),fr(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Er([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let n=this.readMany(t);return Qn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),lt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Br(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,o=e.map(u=>(n+=u,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];G(()=>{t=L(t,[1,n,s]);for(let u=0;u<e.length;++u){let l=u===0?0:o[u-1],p=[0,l,0],c=[1,e[u],s];a[u]=L(We(t,p,c),this.elementShape)}return a});let i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,a)}};var hp=class{constructor(e,t,n,o=-1){this.tensors=e;this.elementShape=t;this.elementDtype=n;e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Qn(t,s.shape,"TensorList shape mismatch: "),Kt(s)}),this.idTensor=ce(0),this.maxNumElements=o,Kt(this.idTensor)}get id(){return this.idTensor.id}copy(){return new hp([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Qn(e,this.elementShape,"TensorList shape mismatch: ");let o=gm(this.elementShape,this.tensors,e);return G(()=>{let s=this.tensors.map(a=>L(a,o));return fr(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=gm(this.elementShape,this.tensors,e),o=this.tensors.pop();return Qn(o.shape,e,"TensorList shape mismatch: "),L(o,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Qn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Kt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Qn(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=gm(this.elementShape,this.tensors,t);return L(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Qn(this.elementShape,t.shape,"TensorList shape mismatch: "),Kt(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Qn(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=gm(this.elementShape,this.tensors,n);return e.length===0?Er([],[0].concat(o)):G(()=>{let s=e.map(a=>L(this.tensors[a],o));return fr(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Qn(this.elementShape,t,"TensorList shape mismatch: ");let n=gm(this.elementShape,this.tensors,t);return this.size()===0?Er([],[0].concat(n)):G(()=>{let o=this.tensors.map(s=>L(s,n));return lt(o,0)})}};function jF(r,e,t){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);let o=r.shape.slice(1);Qn(o,e,"TensorList shape mismatch: ");let s=Br(r);return new hp(s,e,n)}function HF(r,e,t){return new hp([],r,e,t)}function qF(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);let o=Math.max(...e);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new hp([],t,r.dtype,n),a=Br(r,0);return e.forEach((i,u)=>{s.setItem(i,a[u])}),s}function XF(r,e,t){let n=0,o=e.map(p=>(n+=p,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),a=_y(s,t),i=n===0?0:r.size/n,u=G(()=>{let p=[];r=L(r,[1,n,i]);for(let c=0;c<e.length;++c){let m=c===0?0:o[c-1],f=[0,m,0],d=[1,e[c],i];p[c]=L(We(r,f,d),a)}return r.dispose(),p}),l=new hp([],t,r.dtype,e.length);for(let p=0;p<u.length;p++)l.setItem(p,u[p]);return l}var YF=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{let n=v("thenBranch",r,e,t),o=v("elseBranch",r,e,t),s=v("cond",r,e,t),a=v("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let n=v("body",r,e,t),o=v("cond",r,e,t),s=v("args",r,e,t),a=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),i=s.map(p=>p.id),u=await a[0].data();a.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&p.dispose()});let l=s;for(;u[0];){let p=l;l=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);let c=l.map(f=>f.id);p.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&c.indexOf(f.id)===-1&&f.dispose()});let m=await t.functionMap[o].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(f=>{!f.kept&&i.indexOf(f.id)===-1&&c.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{let n=v("pred",r,e,t);return[Fa(n)]}case"Switch":{let n=v("pred",r,e,t),o=v("data",r,e,t);return o.kept||(o=Fa(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>Cr(o,e,t)!==void 0);if(n){let o=Cr(n,e,t);return[Fa(o)]}return}case"Enter":{let n=v("frameName",r,e,t),o=v("tensor",r,e,t);return t.enterFrame(n),[Fa(o)]}case"Exit":{let n=v("tensor",r,e,t);return t.exitFrame(),[Fa(n)]}case"NextIteration":{let n=v("tensor",r,e,t);return t.nextIteration(),[Fa(n)]}case"TensorArrayV3":{let n=v("size",r,e,t),o=v("dtype",r,e,t),s=v("elementShape",r,e,t),a=v("dynamicSize",r,e,t),i=v("clearAfterRead",r,e,t),u=v("identicalElementShapes",r,e,t),l=v("name",r,e,t),p=new Wv(l,o,n,s,u,a,i);return t.addTensorArray(p),[p.idTensor,ce(1)]}case"TensorArrayWriteV3":{let n=v("tensorArrayId",r,e,t),o=v("index",r,e,t),s=v("tensor",r,e,t),a=t.getTensorArray(n.id);return a.write(o,s),[a.idTensor]}case"TensorArrayReadV3":{let n=v("tensorArrayId",r,e,t),o=v("index",r,e,t);return[t.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=v("tensorArrayId",r,e,t),o=v("indices",r,e,t),s=v("dtype",r,e,t);return[t.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=v("tensorArrayId",r,e,t),o=v("indices",r,e,t),s=v("tensor",r,e,t),a=t.getTensorArray(n.id);return a.scatter(o,s),[a.idTensor]}case"TensorArrayConcatV3":{let n=v("tensorArrayId",r,e,t),o=t.getTensorArray(n.id),s=v("dtype",r,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let n=v("tensorArrayId",r,e,t),o=v("tensor",r,e,t),s=v("lengths",r,e,t),a=t.getTensorArray(n.id);return a.split(s,o),[a.idTensor]}case"TensorArraySizeV3":{let n=v("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return[ce(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=v("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=v("tensorListId",r,e,t),o=v("index",r,e,t),s=v("tensor",r,e,t),a=t.getTensorList(n.id);return a.setItem(o,s),[a.idTensor]}case"TensorListGetItem":{let n=v("tensorListId",r,e,t),o=v("index",r,e,t),s=v("elementShape",r,e,t),a=v("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(o,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{let n=v("indices",r,e,t),o=v("tensor",r,e,t),s=v("elementShape",r,e,t),a=v("numElements",r,e,t),i=qF(o,n,s,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=v("elementShape",r,e,t),o=v("elementDType",r,e,t),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let a=v(s,r,e,t),i=HF(n,o,a);return t.addTensorList(i),[i.idTensor]}case"TensorListGather":{let n=v("tensorListId",r,e,t),o=v("indices",r,e,t),s=v("elementShape",r,e,t),a=v("elementDType",r,e,t);return[t.getTensorList(n.id).gather(o,a,s)]}case"TensorListStack":{let n=v("tensorListId",r,e,t),o=v("elementShape",r,e,t),s=v("elementDType",r,e,t),a=v("numElements",r,e,t);return[t.getTensorList(n.id).stack(o,s,a)]}case"TensorListFromTensor":{let n=v("tensor",r,e,t),o=v("elementShape",r,e,t),s=v("elementDType",r,e,t),a=jF(n,o,s);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":{let n=v("tensorListId",r,e,t),o=t.getTensorList(n.id),s=v("dtype",r,e,t),a=v("elementShape",r,e,t);return[o.concat(s,a)]}case"TensorListPushBack":{let n=v("tensorListId",r,e,t),o=v("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=v("tensorListId",r,e,t),o=v("elementShape",r,e,t),s=v("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=v("tensor",r,e,t),o=v("elementShape",r,e,t),s=v("lengths",r,e,t),a=XF(n,s,o);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function QF(r,e,t){let[n,o]=v("fusedOps",r,e,t),s=n==="biasadd",a=!s,i=o==="prelu",u=n==="fusedbatchnorm",l=v("numArgs",r,e,t);if(s){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=v("strides",r,e,t),c=gh(r,e,t),m=v("dataFormat",r,e,t).toUpperCase(),f=v("dilations",r,e,t),[d,h]=v("args",r,e,t);a&&(h=d,d=void 0);let g=v("leakyreluAlpha",r,e,t);return{stride:p,pad:c,dataFormat:m,dilations:f,biasArg:d,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var ZF=(r,e,t)=>{switch(r.op){case"Conv1D":{let n=v("stride",r,e,t),o=v("pad",r,e,t),s=v("dataFormat",r,e,t).toUpperCase(),a=v("dilation",r,e,t);return[Tf(v("x",r,e,t),v("filter",r,e,t),n,o,s,a)]}case"Conv2D":{let n=v("strides",r,e,t),o=gh(r,e,t),s=v("dataFormat",r,e,t).toUpperCase(),a=v("dilations",r,e,t);return[qn(v("x",r,e,t),v("filter",r,e,t),[n[1],n[2]],o,s,[a[1],a[2]])]}case"_FusedConv2D":{let{stride:n,pad:o,dataFormat:s,dilations:a,biasArg:i,preluArg:u,activationFunc:l,leakyreluAlpha:p}=QF(r,e,t);return[Ds.conv2d({x:v("x",r,e,t),filter:v("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:i,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:o,dataFormat:s,dilations:a,biasArg:i,preluArg:u,activationFunc:l,leakyreluAlpha:p}=QF(r,e,t);return[Ds.depthwiseConv2d({x:v("x",r,e,t),filter:v("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[a[1],a[2]],bias:i,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=v("outputShape",r,e,t),o=v("strides",r,e,t),s=gh(r,e,t);return[kf(v("x",r,e,t),v("filter",r,e,t),n,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=v("strides",r,e,t),o=gh(r,e,t),s=v("dilations",r,e,t),a=v("dataFormat",r,e,t).toUpperCase();return[Yi(v("input",r,e,t),v("filter",r,e,t),[n[1],n[2]],o,a,[s[1],s[2]])]}case"Conv3D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("dataFormat",r,e,t).toUpperCase(),a=v("dilations",r,e,t);return[If(v("x",r,e,t),v("filter",r,e,t),[n[1],n[2],n[3]],o,s,[a[1],a[2],a[3]])]}case"AvgPool":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[Ml(v("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPool":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[Gl(v("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPoolWithArgmax":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t),a=v("includeBatchInIndex",r,e,t),{result:i,indexes:u}=zI(v("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o,a);return[i,u]}case"AvgPool3D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[yf(v("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"MaxPool3D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("kernelSize",r,e,t);return[Nf(v("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"Dilation2D":{let n=v("strides",r,e,t),o=v("pad",r,e,t),s=v("dilations",r,e,t),a=n[1],i=n[2],u=s[1],l=s[2];return[AI(v("x",r,e,t),v("filter",r,e,t),[a,i],o,[u,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var JF=(r,e,t)=>{switch(r.op){case"Fill":{let n=v("shape",r,e,t),o=v("dtype",r,e,t),s=v("value",r,e,t);return[Ia(n,s,o)]}case"LinSpace":{let n=v("start",r,e,t),o=v("stop",r,e,t),s=v("num",r,e,t);return[EI(n,o,s)]}case"Multinomial":{let n=v("logits",r,e,t),o=v("numSamples",r,e,t),s=v("seed",r,e,t);return[UI(n,o,s)]}case"OneHot":{let n=v("indices",r,e,t),o=v("depth",r,e,t),s=v("onValue",r,e,t),a=v("offValue",r,e,t);return[ji(n,o,s,a)]}case"Ones":return[mr(v("shape",r,e,t),v("dtype",r,e,t))];case"OnesLike":return[Ar(v("x",r,e,t))];case"RandomUniform":return[Ca(v("shape",r,e,t),v("minval",r,e,t),v("maxval",r,e,t),v("dtype",r,e,t))];case"Range":{let n=v("start",r,e,t),o=v("stop",r,e,t),s=v("step",r,e,t);return[eu(n,o,s,v("dtype",r,e,t))]}case"TruncatedNormal":{let n=v("shape",r,e,t),o=v("mean",r,e,t),s=v("stdDev",r,e,t),a=v("seed",r,e,t);return[ql(n,o,s,v("dtype",r,e,t),a)]}case"Zeros":return[Tt(v("shape",r,e,t),v("dtype",r,e,t))];case"ZerosLike":return[De(v("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Uv(r,e,t){let n=v("boxes",r,e,t),o=v("scores",r,e,t),s=v("maxOutputSize",r,e,t),a=v("iouThreshold",r,e,t),i=v("scoreThreshold",r,e,t),u=v("softNmsSigma",r,e,t);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}}var eM=async(r,e,t)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}=Uv(r,e,t),l=await Mn.nonMaxSuppressionWithScoreAsync(n,o,s,a,i,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i}=Uv(r,e,t),u=v("padToMaxOutputSize",r,e,t),l=await Mn.nonMaxSuppressionPaddedAsync(n,o,s,a,i,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i}=Uv(r,e,t);return[await Mn.nonMaxSuppressionAsync(n,o,s,a,i)]}case"Where":{let n=Q(v("condition",r,e,t),"bool"),o=[await Wf(n)];return n.dispose(),o}case"ListDiff":return eC(v("x",r,e,t),v("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var tM=(r,e,t)=>{switch(r.op){case"TopKV2":{let n=v("x",r,e,t),o=v("k",r,e,t),s=v("sorted",r,e,t),a=oC(n,o,s);return[a.values,a.indices]}case"Unique":{let n=v("x",r,e,t),o=Cb(n);return[o.values,o.indices]}case"UniqueV2":{let n=v("x",r,e,t),o=v("axis",r,e,t),s=Cb(n,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var rM=(r,e,t)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":let n=v("default",r,e,t);return[Cr(r.name,e,t)||n];case"Placeholder":return[Cr(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=v("x",r,e,t);return[Fa(l)]}case"IdentityN":return v("x",r,e,t).map(l=>Fa(l));case"Snapshot":let o=v("x",r,e,t);return[Fa(o)];case"Shape":return[Gt(v("x",r,e,t).shape,"int32")];case"ShapeN":return v("x",r,e,t).map(l=>Gt(l.shape));case"Size":return[ce(v("x",r,e,t).size,"int32")];case"Rank":return[ce(v("x",r,e,t).rank,"int32")];case"NoOp":return[ce(1)];case"Print":let s=v("x",r,e,t),a=v("data",r,e,t),i=v("message",r,e,t),u=v("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let l=0;l<a.length;l++)console.log(Array.prototype.slice.call(a[l].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var Kv=class{constructor(e,t){this.keyDType=e;this.valueDType=t;this.handle=ce(0),this.tensorMap=new Map,Kt(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ce(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),G(()=>{let o=Br(t),s=n.length,a=o.length;b.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let u=n[i],l=o[i];Kt(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return G(()=>{let o=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);o.push(i)}return fr(o)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};var nM=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=v("keyDType",r,e,t),s=v("valueDType",r,e,t),a=new Kv(o,s);return n.addHashTable(r.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=v("tableHandle",r,e,t,n),s=v("keys",r,e,t),a=v("values",r,e,t);return[await n.getHashTableById(o.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{let o=v("tableHandle",r,e,t,n),s=v("keys",r,e,t),a=v("defaultValue",r,e,t);return[await n.getHashTableById(o.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=v("tableHandle",r,e,t,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var oM=(r,e,t)=>{switch(r.op){case"ResizeBilinear":{let n=v("images",r,e,t),o=v("size",r,e,t),s=v("alignCorners",r,e,t),a=v("halfPixelCenters",r,e,t);return[Mn.resizeBilinear(n,[o[0],o[1]],s,a)]}case"ResizeNearestNeighbor":{let n=v("images",r,e,t),o=v("size",r,e,t),s=v("alignCorners",r,e,t),a=v("halfPixelCenters",r,e,t);return[Mn.resizeNearestNeighbor(n,[o[0],o[1]],s,a)]}case"CropAndResize":{let n=v("image",r,e,t),o=v("boxes",r,e,t),s=v("boxInd",r,e,t),a=v("cropSize",r,e,t),i=v("method",r,e,t),u=v("extrapolationValue",r,e,t);return[Mn.cropAndResize(n,o,s,a,i,u)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var sM=(r,e,t)=>{switch(r.op){case"Equal":return[Kr(v("a",r,e,t),v("b",r,e,t))];case"NotEqual":return[Za(v("a",r,e,t),v("b",r,e,t))];case"Greater":return[nr(v("a",r,e,t),v("b",r,e,t))];case"GreaterEqual":return[qo(v("a",r,e,t),v("b",r,e,t))];case"Less":return[wf(v("a",r,e,t),v("b",r,e,t))];case"LessEqual":return[Xo(v("a",r,e,t),v("b",r,e,t))];case"LogicalAnd":return[jr(v("a",r,e,t),v("b",r,e,t))];case"LogicalNot":return[zl(v("a",r,e,t))];case"LogicalOr":return[Af(v("a",r,e,t),v("b",r,e,t))];case"Select":case"SelectV2":return[zt(v("condition",r,e,t),v("a",r,e,t),v("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var aM=(r,e,t)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ve(v("a",r,e,t),v("b",r,e,t),v("transposeA",r,e,t),v("transposeB",r,e,t))];case"Einsum":return[DI(v("equation",r,e,t),...v("tensors",r,e,t))];case"Transpose":return[qe(v("x",r,e,t),v("perm",r,e,t))];case"_FusedMatMul":let[n,o]=v("fusedOps",r,e,t),s=n==="biasadd",a=o==="prelu",i=v("numArgs",r,e,t),u=v("leakyreluAlpha",r,e,t);if(s){if(a&&i!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,p]=v("args",r,e,t);return[Ds.matMul({a:v("a",r,e,t),b:v("b",r,e,t),transposeA:v("transposeA",r,e,t),transposeB:v("transposeB",r,e,t),bias:l,activation:o,preluActivationWeights:p,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var iM=(r,e,t)=>{switch(r.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[Xa(v("x",r,e,t),v("mean",r,e,t),v("variance",r,e,t),v("offset",r,e,t),v("scale",r,e,t),v("epsilon",r,e,t))];case"FusedBatchNormV3":return[Xa(v("x",r,e,t),v("mean",r,e,t),v("variance",r,e,t),v("offset",r,e,t),v("scale",r,e,t),v("epsilon",r,e,t))];case"LRN":return[RI(v("x",r,e,t),v("radius",r,e,t),v("bias",r,e,t),v("alpha",r,e,t),v("beta",r,e,t))];case"Softmax":return[Vl(v("x",r,e,t))];case"LogSoftmax":return[Sf(v("x",r,e,t))];case"SparseToDense":return[Sb(v("sparseIndices",r,e,t),v("outputShape",r,e,t),v("sparseValues",r,e,t),v("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var uM=(r,e,t)=>{switch(r.op){case"Max":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[Qr(v("x",r,e,t),a,i)]}case"Mean":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[Rt(v("x",r,e,t),a,i)]}case"Min":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[Bc(v("x",r,e,t),a,i)]}case"Sum":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[me(v("x",r,e,t),a,i)]}case"All":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[bf(v("x",r,e,t),a,i)]}case"Any":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[Ec(v("x",r,e,t),a,i)]}case"ArgMax":{let a=v("axis",r,e,t);return[qi(v("x",r,e,t),a)]}case"ArgMin":{let a=v("axis",r,e,t);return[iI(v("x",r,e,t),a)]}case"Prod":{let a=v("axis",r,e,t),i=v("keepDims",r,e,t);return[Df(v("x",r,e,t),a,i)]}case"Cumsum":{let a=v("axis",r,e,t),i=v("exclusive",r,e,t),u=v("reverse",r,e,t);return[vf(v("x",r,e,t),a,i,u)]}case"Bincount":let n=v("x",r,e,t),o=v("weights",r,e,t),s=v("size",r,e,t);return[xf(n,o,s)];case"DenseBincount":{let a=v("x",r,e,t),i=v("weights",r,e,t),u=v("size",r,e,t),l=v("binaryOutput",r,e,t);return[SI(a,i,u,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var lM=(r,e,t)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=v("n",r,e,t),o=v("axis",r,e,t),s=v("tensors",r,e,t);return s=s.slice(0,n),[lt(s,o)]}case"Gather":{let n=v("x",r,e,t),o=v("indices",r,e,t);return[Ya(n,Q(o,"int32"),0)]}case"GatherV2":{let n=v("axis",r,e,t),o=v("batchDims",r,e,t),s=v("x",r,e,t),a=v("indices",r,e,t);return[Ya(s,Q(a,"int32"),n,o)]}case"Reverse":{let n=v("dims",r,e,t),o=[];for(let a=0;a<n.length;a++)n[a]&&o.push(a);let s=v("x",r,e,t);return[xr(s,o)]}case"ReverseV2":{let n=v("axis",r,e,t),o=v("x",r,e,t);return[xr(o,n)]}case"Slice":{let n=v("begin",r,e,t),o=v("size",r,e,t);return[We(v("x",r,e,t),n,o)]}case"StridedSlice":{let n=v("begin",r,e,t),o=v("end",r,e,t),s=v("strides",r,e,t),a=v("beginMask",r,e,t),i=v("endMask",r,e,t),u=v("ellipsisMask",r,e,t),l=v("newAxisMask",r,e,t),p=v("shrinkAxisMask",r,e,t),c=v("x",r,e,t);return[rC(c,n,o,s,a,i,u,l,p)]}case"Pack":return G(()=>{let n=v("axis",r,e,t),o=v("tensors",r,e,t),s=o[0].shape,a=cn(o[0]).shape,i=o.map(u=>{let l=b.arraysEqual(u.shape,s);if(!l&&!b.arraysEqual(cn(u).shape,a))throw new Error("the input tensors shape does not match");return l?u:L(u,s)});return[fr(i,n)]});case"Unpack":{let n=v("axis",r,e,t),o=v("tensor",r,e,t);return Br(o,n)}case"Tile":{let n=v("reps",r,e,t);return[Vr(v("x",r,e,t),n)]}case"Split":case"SplitV":{let n=v("axis",r,e,t),o=v("numOrSizeSplits",r,e,t),s=v("x",r,e,t);return Ir(s,o,n)}case"ScatterNd":{let n=v("indices",r,e,t),o=v("values",r,e,t),s=v("shape",r,e,t);return[$0(n,o,s)]}case"GatherNd":{let n=v("x",r,e,t),o=v("indices",r,e,t);return[O0(n,o)]}case"SparseToDense":{let n=v("sparseIndices",r,e,t),o=v("outputShape",r,e,t),s=v("sparseValues",r,e,t),a=v("defaultValue",r,e,t);return[Sb(n,s,o,s.dtype===a.dtype?a:Q(a,s.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var pM=(r,e,t)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:o,emptyRowIndicator:s,reverseIndexMap:a}=Uf.sparseFillEmptyRows(v("indices",r,e,t),v("values",r,e,t),v("denseShape",r,e,t),v("defaultValue",r,e,t));return[n,o,s,a]}case"SparseReshape":{let{outputIndices:n,outputShape:o}=Uf.sparseReshape(v("inputIndices",r,e,t),v("inputShape",r,e,t),v("newShape",r,e,t));return[n,o]}case"SparseSegmentMean":return[Uf.sparseSegmentMean(v("data",r,e,t),v("indices",r,e,t),v("segmentIds",r,e,t))];case"SparseSegmentSum":return[Uf.sparseSegmentSum(v("data",r,e,t),v("indices",r,e,t),v("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var cM=(r,e,t)=>{switch(r.op){case"FFT":return[jl(v("x",r,e,t))];case"IFFT":return[Hu(v("x",r,e,t))];case"RFFT":return[Hl(v("x",r,e,t))];case"IRFFT":return[zf(v("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var mM=(r,e,t)=>{switch(r.op){case"StringNGrams":{let{nGrams:n,nGramsSplits:o}=Rb.stringNGrams(v("data",r,e,t),v("dataSplits",r,e,t),v("separator",r,e,t),v("nGramWidths",r,e,t),v("leftPad",r,e,t),v("rightPad",r,e,t),v("padWidth",r,e,t),v("preserveShortSequences",r,e,t));return[n,o]}case"StringSplit":{let{indices:n,values:o,shape:s}=Rb.stringSplit(v("input",r,e,t),v("delimiter",r,e,t),v("skipEmpty",r,e,t));return[n,o,s]}case"StringToHashBucketFast":return[Rb.stringToHashBucketFast(v("input",r,e,t),v("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var fM=(r,e,t)=>{switch(r.op){case"Cast":return[Q(v("x",r,e,t),v("dtype",r,e,t))];case"ExpandDims":{let n=v("axis",r,e,t);return[_r(v("x",r,e,t),n)]}case"Squeeze":{let n=v("axis",r,e,t);return[cn(v("x",r,e,t),n)]}case"Reshape":return[L(v("x",r,e,t),v("shape",r,e,t))];case"MirrorPad":return[GI(v("x",r,e,t),v("padding",r,e,t),v("mode",r,e,t))];case"PadV2":case"Pad":return[Pn(v("x",r,e,t),v("padding",r,e,t),v("constantValue",r,e,t))];case"SpaceToBatchND":{let n=v("blockShape",r,e,t),o=v("paddings",r,e,t);return[Wl(v("x",r,e,t),n,o)]}case"BatchToSpaceND":{let n=v("blockShape",r,e,t),o=v("crops",r,e,t);return[El(v("x",r,e,t),n,o)]}case"DepthToSpace":{let n=v("blockSize",r,e,t),o=v("dataFormat",r,e,t).toUpperCase();return[_I(v("x",r,e,t),n,o)]}case"BroadcastTo":return[Rl(v("x",r,e,t),v("shape",r,e,t))];case"BroadcastArgs":return[xI(v("s0",r,e,t),v("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Vv(r,e,t,n){let o=((s,a,i)=>{switch(s.category){case"arithmetic":return G(()=>UF(s,a,i));case"basic_math":return G(()=>KF(s,a,i));case"control":return YF(s,a,i);case"convolution":return G(()=>ZF(s,a,i));case"creation":return G(()=>JF(s,a,i));case"dynamic":return eM(s,a,i);case"evaluation":return G(()=>tM(s,a,i));case"image":return G(()=>oM(s,a,i));case"graph":return G(()=>rM(s,a,i));case"logical":return G(()=>sM(s,a,i));case"matrices":return G(()=>aM(s,a,i));case"normalization":return G(()=>iM(s,a,i));case"reduction":return G(()=>uM(s,a,i));case"slice_join":return G(()=>lM(s,a,i));case"sparse":return G(()=>pM(s,a,i));case"spectral":return G(()=>cM(s,a,i));case"string":return G(()=>mM(s,a,i));case"transformation":return G(()=>fM(s,a,i));case"hash_table":return nM(s,a,i,n);case"custom":let u=dy(s.op);if(u&&u.customExecutor)return u.customExecutor(new Gv(s,a,i));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return b.isPromise(o)?o.then(s=>[].concat(s)):[].concat(o)}var Ay=class{constructor(e={},t={},n={},o={}){this.weightMap=e;this.tensorArrayMap=t;this.tensorListMap=n;this.functionMap=o;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function jv(r,e,t,n){let o=new Set,s=[],a=null,i=null,u=new Set,l=Object.keys(r).map(m=>yn(m)[0]),p=[];n!=null&&(p=n.map(m=>yn(m.name)[0]));let c=[...e];for(;c.length>0;){let m=c.pop();if((Hv(m)||IJ(m)||CJ(m))&&a==null&&(a=m,i=a.children.map(f=>f.name).filter(f=>o.has(f))),o.add(m.name),t[m.name]==null&&l.indexOf(m.name)===-1&&p.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),c.push(f))})}}return{inputs:r,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:a,syncInputs:i}}function dM(r,e,t){let{usedNodes:n,inputs:o}=t,s=[],a=Object.keys(o).map(p=>yn(p)[0]).map(p=>r.nodes[p]),i=r.initNodes;a.forEach(p=>{n.has(p.name)&&s.push(p)}),r.weights.forEach(p=>{n.has(p.name)&&s.push(p)}),i!=null&&i.forEach(p=>{n.has(p.name)&&s.push(p)});let u=new Set,l=[];for(;s.length>0;){let p=s.pop();u.add(p.name),e[p.name]||l.push(p),p.children.forEach(c=>{!u.has(c.name)&&n.has(c.name)&&c.inputs.every(m=>u.has(m.name))&&s.push(c)})}return l}var xJ=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],TJ=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],kJ=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Hv(r){return xJ.indexOf(r.op)>=0}function IJ(r){return TJ.indexOf(r.op)>=0}function CJ(r){return kJ.indexOf(r.op)>=0}var bm=class{constructor(e,t){this.graph=e;this.parent=t;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this._functions={};this._functionExecutorMap={};this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new bm(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,t){let n=jv(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(o.length>0){let i=t.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return dM(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=n.map(c=>this.graph.nodes[yn(c)[0]]),s=t.map(c=>yn(c)[0]),a=s.map(c=>this.graph.nodes[c]);a.length===0&&(a=this._outputs);let i=this.getCompilationKey(o,a),u=this.compiledMap.get(i);u==null&&(u=this.compile(e,a),this.compiledMap.set(i,u));let l={},p={};return G(()=>{let c=new Ay(this.weightMap,l,p,this.functionExecutorMap),m={...this.weightMap};Object.keys(e).forEach(h=>{let[g,y]=yn(h),x=[];x[y]=e[h],m[g]=x});let f=this.getFrozenTensorIds(m),d={};for(let h=0;h<u.length;h++){let g=u[h];if(!m[g.name]){let y=Vv(g,m,c,this._resourceManager);if(b.isPromise(y))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=y,this.checkTensorForDisposal(g.name,g,m,c,f,s,d)}}return this.parent==null&&c.dispose(f),t.map(h=>Cr(h,m,c))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,n,o,s,a,i){t.category==="control"||a.indexOf(e)!==-1||(n[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){let l=OF(u.name,n,o);l!=null&&l.forEach(p=>{if(p&&!p.kept&&!s.has(p.id)){let c=i[p.id];c===1?(p.dispose(),delete i[p.id]):c!=null&&i[p.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}async _executeAsync(e,t,n=!1,o={},s={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));let a=new Ay(this.weightMap,o,s,this.functionExecutorMap),i=await this.executeWithControlFlow(e,a,t,n),u=t.map(m=>Cr(m,i,a)),l=u.map(m=>m.id),p=Object.keys(e).map(m=>e[m].id),c=new Set([...l,...p,...this.weightIds]);return Object.keys(i).forEach(m=>{i[m].forEach(d=>{d&&!d.kept&&!d.isDisposed&&!c.has(d.id)&&d.dispose()})}),this.parent==null&&a.dispose(c),u}async executeFunctionAsync(e,t,n){let o=e.reduce((s,a,i)=>(s[this.inputs[i].name]=a,s),{});return this._executeAsync(o,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,o){let s=Object.keys(e),a=s.map(T=>this.graph.nodes[yn(T)[0]]),i=n.map(T=>yn(T)[0]),u=i.map(T=>this.graph.nodes[T]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:p,dynamicNode:c,syncInputs:m}=jv(e,u,this.weightMap,this._initNodes),f=[...a,...this.graph.weights,...this._initNodes||[]].map(T=>({node:T,contexts:t.currentContext})),d={...this.weightMap};Object.keys(e).forEach(T=>{let[k,w]=yn(T),P=[];P[w]=e[T],d[k]=P});let h={},g=this.getFrozenTensorIds(d),y={};for(;f.length>0;){let T=this.processStack(a,f,t,d,y,g,i,h,l);await Promise.all(T)}c==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let x=u.filter(T=>!Hv(T)&&!Cr(T.name,d,t)).map(T=>T.name);if(x.length>0){let T="";throw c!=null&&(T=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${T}`)}return d}processStack(e,t,n,o,s,a,i,u,l){let p=[];for(;t.length>0;){let c=t.pop();n.currentContext=c.contexts;let m="";if(c.node.op==="Enter"&&v("isConstant",c.node,o,n)&&([m]=Pa(c.node.name,n)),o[c.node.name]==null){let f=Vv(c.node,o,n,this._resourceManager);m||([m]=Pa(c.node.name,n));let d=n.currentContext;b.isPromise(f)?p.push(f.then(h=>(o[m]=h,n.currentContext=d,this.checkTensorForDisposal(m,c.node,o,n,a,i,u),this.processChildNodes(c.node,t,n,o,s,l),h))):(o[m]=f,this.checkTensorForDisposal(m,c.node,o,n,a,i,u),this.processChildNodes(c.node,t,n,o,s,l))}else this.processChildNodes(c.node,t,n,o,s,l)}return p}processChildNodes(e,t,n,o,s,a){e.children.forEach(i=>{let[u]=Pa(i.name,n);s[u]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Cr(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:i})):i.inputNames.every(l=>!!Cr(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[o]=yn(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,i=a.length===n.shape.length&&n.shape.every((u,l)=>a[l]===-1||a[l]===u);b.assert(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&b.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];t[o.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[o]=yn(n);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{let[n]=yn(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}};var qv=class{constructor(e={},t={}){this.hashTableNameToHandle=e;this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};var vJ="?tfjs-format=file",wJ="model.json",Xv=class{constructor(e,t={}){this.modelUrl=e;this.loadOptions=t;this.version="n/a";t==null&&(this.loadOptions={}),this.resourceManager=new qv}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Ur.browserHTTPRequest(e,this.loadOptions);else{let t=Ur.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(Ur.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let o=Ur.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new bm(gy.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=gy.Instance.transformGraph(e.modelInitializer);this.initializer=new bm(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){let n=Ur.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Ye)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,o)=>(t[n]=e[o],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function SJ(r,e={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${wJ}${vJ}`);let t=new Xv(r,e);return await t.load(),t}var _J="0.0.0";var QM={};Qe(QM,{CSVDataset:()=>kh,Dataset:()=>si,FileDataSource:()=>Sh,TextLineDataset:()=>xh,URLDataSource:()=>_h,array:()=>LM,csv:()=>VM,func:()=>jM,generator:()=>HM,microphone:()=>XM,version_data:()=>YM,webcam:()=>qM,zip:()=>$M});var RM=Tl(Pf());var TM=Tl(Pf());function hM(r,e){return Ny(r,e)}function Ny(r,e,t=new Map,n=new Set){if(r==null)return null;if(n.has(r))throw new Error("Circular references are not supported.");if(t.has(r))return t.get(r);let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(ol(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let i=r[a],u=Ny(i,e,t,n);s[a]=u}return n.delete(r),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return t.set(r,o.value),o.value}function gM(r,e=Qv){return bM(r,e)}function bM(r,e,t=new Set){let n=r[0];if(t.has(n))throw new Error("Circular references are not supported.");let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(ol(n)){let s=Array.isArray(n)?[]:{};t.add(n);for(let a in n){let i=r.map(l=>l[a]),u=bM(i,e,t);s[a]=u}return t.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function Qv(r){return r===null?null:ol(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function Dy(r,e){let t=new Map;Ny(r,e,t);for(let o of Array.from(t.keys())){let s=t.get(o);if(b.isPromise(s)){let a=await s;t.set(o,a)}}return Ny(r,e,t)}function ol(r){let e=!1;if(U().get("IS_BROWSER"))e=r instanceof TextDecoder;else{let{StringDecoder:t}=Yv();e=r instanceof t}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Ye)&&!(r instanceof Promise)&&!e)}function yM(r){return r==null||AJ(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Ye||b.isTypedArray(r)}function AJ(r){return r===null||typeof r!="object"&&typeof r!="function"}function xM(r){return hM(r,NJ)}function NJ(r){return r instanceof Ye?{value:r.clone(),recurse:!1}:ol(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var bh=class{constructor(e){this.capacity=e;this.begin=0;this.end=0;if(e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}};var Zv=class extends bh{constructor(){super(Zv.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let o=0;o<n;o++)t[o]=this.get(this.wrap(this.begin+o));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},Py=Zv;Py.INITIAL_CAPACITY=32;function Jv(r){return new CM(r)}function yh(r){return new vM(r)}function kM(r,e){return new tw(r,e)}function IM(r,e=uu.FAIL){return new MM(r,e)}var ur=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new PM(this,e)}filter(e){return new NM(this,e)}map(e){return new DM(this,e)}mapAsync(e){return new ew(this,e)}serialMapAsync(e){return new ew(this,e).serial()}flatmap(e){return new FM(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new AM(this,e,t)}columnMajorBatch(e,t=!0,n=Qv){return this.rowMajorBatch(e,t).map(s=>gM(s,n))}concatenate(e,t){return new tw(Jv([this,e]),t)}take(e){return e<0||e==null?this:new _M(this,e)}skip(e){return e<0||e==null?this:new SM(this,e)}prefetch(e){return new rw(this,e)}shuffle(e,t){return new EM(this,e,t)}serial(){return new wM(this)}},CM=class extends ur{constructor(e){super();this.items=e;this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:xM(e),done:!1}}},vM=class extends ur{constructor(e){super();this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},wM=class extends ur{constructor(e){super();this.upstream=e;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},SM=class extends ur{constructor(e,t){super();this.upstream=e;this.maxCount=t;this.count=0;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Ee(e.value)}return this.upstream.next()}},_M=class extends ur{constructor(e,t){super();this.upstream=e;this.maxCount=t;this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},AM=class extends ur{constructor(e,t,n=!0){super();this.upstream=e;this.batchSize=t;this.enableSmallLastBatch=n;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},NM=class extends ur{constructor(e,t){super();this.upstream=e;this.predicate=t;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Ee(e.value)}}},DM=class extends ur{constructor(e,t){super();this.upstream=e;this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=As.getTensorsInContainer(e.value),n=this.transform(e.value),o=As.getTensorsInContainer(n);for(let s of t)As.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},PM=class extends ur{constructor(e,t){super();this.upstream=e;this.handler=t;this.count=0;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},ew=class extends ur{constructor(e,t){super();this.upstream=e;this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=As.getTensorsInContainer(e.value),n=await this.transform(e.value),o=As.getTensorsInContainer(n);for(let s of t)As.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},ym=class extends ur{constructor(){super();this.outputQueue=new Py,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},FM=class extends ym{constructor(e,t){super();this.upstream=e;this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=As.getTensorsInContainer(e.value),n=this.transform(e.value),o=As.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)As.isTensorInList(s,o)||s.dispose();return!0}},tw=class extends ur{constructor(e,t){super();this.baseErrorHandler=t;this.lastRead=null;this.iterator=null;this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},uu;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(uu||(uu={}));var MM=class extends ur{constructor(e,t=0){super();this.iterators=e;this.mismatchMode=t;this.count=0;this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function o(a){return a instanceof ur?{value:a.next().then(u=>(t++,u.done&&n++,u.value)),recurse:!1}:{value:null,recurse:!0}}let s=await Dy(this.iterators,o);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case 0:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case 1:return{value:null,done:!0};case 2:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},rw=class extends ur{constructor(e,t){super();this.upstream=e;this.bufferSize=t;this.buffer=new bh(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},EM=class extends rw{constructor(e,t,n){super(e,t);this.upstream=e;this.windowSize=t;this.upstreamExhausted=!1;this.random=TM.alea(n||b.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}};var si=class{constructor(){this.size=null}batch(e,t=!0){let n=this;b.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let o;return this.size===1/0||this.size==null?o=this.size:t?o=Math.ceil(this.size/e):o=Math.floor(this.size/e),Ln(async()=>(await n.iterator()).columnMajorBatch(e,t,DJ),o)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Ln(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Ln(async()=>(await t.iterator()).filter(o=>G(()=>e(o))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Ln(async()=>(await t.iterator()).map(n=>G(()=>e(n))),this.size)}mapAsync(e){let t=this;return Ln(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Ln(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Ln(async()=>{let o=yh(async()=>({value:await t.iterator(),done:!1}));return kM(o.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Ln(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=RM.alea(t||b.now().toString());return Ln(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await o.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Ln(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};si.MAX_BUFFER_SIZE=1e4;function Ln(r,e=null){return new class extends si{constructor(){super(...arguments);this.size=e}async iterator(){return r()}}}function LM(r){return Ln(async()=>Jv(r),r.length)}function $M(r){if(!ol(r))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(r))for(let t=0;t<r.length;t++)e=e==null?r[t].size:Math.min(e,r[t].size);else if(r instanceof Object)for(let t in r)e=e==null?r[t].size:Math.min(e,r[t].size);return Ln(async()=>{let t=await Dy(r,n=>{if(n instanceof si)return{value:n.iterator(),recurse:!1};if(ol(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return IM(t,uu.SHORTEST)},e)}function DJ(r){if(r===null)return null;let e=r[0];return yM(e)?{value:PJ(r),recurse:!1}:{value:null,recurse:!0}}function PJ(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Ye?fr(r):Er(r)}var xh=class extends si{constructor(e){super();this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}};var Fy='"',Th=Symbol("out"),BM=Symbol("field"),My=Symbol("quote"),nw=Symbol("quoteafterquote"),OM=Symbol("quoteinquote"),kh=class extends si{constructor(e,t){super();this.input=e;this.hasHeader=!0;this.fullColumnNames=null;this.columnNamesValidated=!1;this.columnConfigs=null;this.configuredColumnsOnly=!1;this.delimiter=",";this.delimWhitespace=!1;this.base=new xh(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(b.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&b.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((o,s)=>(o[s]=o[s]+1||1,o),{}),n=Object.keys(t).filter(o=>t[o]>1);if(b.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");let n=t.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},o={};for(let s=0;s<this.fullColumnNames.length;s++){let a=this.fullColumnNames[s],i=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!i)){let u=t[s],l=null;if(u==="")if(i&&i.default!==void 0)l=i.default;else{if(i&&(i.required||i.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);l=void 0}else{let p=Number(u);if(isNaN(p))i&&i.dtype==="bool"?l=this.getBoolean(u):l=u;else if(!i||!i.dtype)l=p;else switch(i.dtype){case"float32":l=p;break;case"int32":l=Math.floor(p);break;case"bool":l=this.getBoolean(u);break;default:l=p}}i&&i.isLabel?o[a]=l:n[a]=l}}return Object.keys(o).length===0?n:{xs:n,ys:o}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],o=0,s=e.length,a=Th;for(let i=0;i<s;i++)switch(a){case Th:switch(e.charAt(i)){case Fy:o=i+1,a=My;break;case this.delimiter:if(o=i+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),a=Th;break;default:a=BM,o=i;break}break;case BM:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(o,i)),a=Th,o=i+1;break;default:}break;case My:switch(e.charAt(i)){case Fy:a=nw;break;default:}break;case nw:switch(e.charAt(i)){case this.delimiter:n.push(e.substring(o,i-1)),a=Th,o=i+1;break;case Fy:a=My;break;default:a=OM;break}break;case OM:switch(e.charAt(i)){case Fy:a=My;break;default:}break;default:}if(a===nw?n.push(e.substring(o,s-1)):n.push(e.substring(o)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}};var Ih=class extends ur{constructor(e){super();this.microphoneConfig=e;this.isClosed=!1;this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(U().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let t=new Ih(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let o=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let o=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(o=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&o({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),o({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((o,s)=>n.set(o,s*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(b.sizeFromShape(t));return n.set(e,n.length-e.length),Er(n,t)}};var Ch=class extends ur{constructor(e,t){super();this.webcamVideoElement=e;this.webcamConfig=t;this.isClosed=!0;this.resize=!1;if(this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Gt([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,a=(1-o)/2,i=s+n,u=o+a;this.cropBox=Ja([a,s,u,i],[1,4])}else this.cropBox=Ja([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(U().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new Ch(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&b.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=ub.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return G(()=>{let t=_r(Q(e,"float32"),0),n;n=Mn.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let o=n.shape;return L(n,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var vh=class{};var Ey=class extends ur{split(e){return new zM(this,e)}},zM=class extends Ey{constructor(e,t){super();this.upstream=e;this.impl=new GM(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},GM=class extends ym{constructor(e,t){super();this.upstream=e;this.separator=t;this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}};var ow=class extends ur{decodeUTF8(){return new WM(this)}},WM=class extends Ey{constructor(e){super();this.upstream=e;this.impl=new UM(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},UM=class extends ym{constructor(e){super();this.upstream=e;if(U().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=Yv();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return U().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}};var wh=class extends ow{constructor(e,t={}){super();this.file=e;this.options=t;b.assert(e instanceof Uint8Array||(U().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,n)=>{let o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,o)));else{let s=new FileReader;s.onload=i=>{let u=s.result;if(u instanceof ArrayBuffer&&(u=new Uint8Array(u)),!(u instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));t(u)},s.onabort=i=>n(new Error("Aborted")),s.onerror=i=>n(new Error(i.type));let a=this.file.slice(this.offset,o);s.readAsArrayBuffer(a)}this.offset=o}),done:!1}}};async function KM(r,e={}){let t,n;typeof r=="string"?t=r:(t=r.url,n=FJ(r));let o=await b.fetch(t,n);if(o.ok){let s=new Uint8Array(await o.arrayBuffer());return new wh(s,e)}else throw new Error(o.statusText)}var FJ=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function Ry(r){return typeof r=="string"&&r.substr(0,7)==="file://"}var Sh=class extends vh{constructor(e,t={}){super();this.input=e;this.options=t}async iterator(){if(Ry(this.input)&&U().get("IS_NODE")){let e=ns("fs");this.input=e.readFileSync(this.input.substr(7))}return new wh(this.input,this.options)}};var _h=class extends vh{constructor(e,t={}){super();this.url=e;this.fileOptions=t}async iterator(){return Ry(this.url)?new Sh(this.url,this.fileOptions).iterator():KM(this.url,this.fileOptions)}};function VM(r,e={}){return new kh(new _h(r),e)}function jM(r){let e=yh(r);return Ln(async()=>e)}function HM(r){return Ln(async()=>{let e=await r();return yh(()=>e.next())})}async function qM(r,e){return Ch.create(r,e)}async function XM(r){return Ih.create(r)}var YM="0.0.0";function re(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&b.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var MJ=Tr.whereImpl,sw=class extends os{constructor(){super();this.blockSize=48;this.firstUse=!0;this.data=new Oa(this,jo())}nextDataId(){return sw.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,U().get("IS_NODE")&&I.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:n,refCount:1}),o}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&b.isString(n[0])){let s=n.map(a=>b.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,o,s){this.data.set(e,{values:t,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return I.mergeRealAndImagArrays(o,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>b.decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}makeOutput(e,t,n){let o=this.write(e,t,n);return jo().makeTensorFromDataId(o,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=b.now();return e(),{kernelMs:b.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){re([e],"where");let t=this.readSync(e.dataId);return MJ(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},Ah=sw;Ah.nextDataId=0;var vm={};Qe(vm,{addImpl:()=>iw,bincountImpl:()=>km,bincountReduceImpl:()=>Ly,ceilImpl:()=>uw,concatImpl:()=>gp,equalImpl:()=>lw,expImpl:()=>cw,expm1Impl:()=>fw,floorImpl:()=>dw,gatherNdImpl:()=>$y,gatherV2Impl:()=>By,greaterEqualImpl:()=>gw,greaterImpl:()=>hw,lessEqualImpl:()=>yw,lessImpl:()=>bw,linSpaceImpl:()=>Oy,logImpl:()=>xw,maxImpl:()=>zy,maximumImpl:()=>Tw,minimumImpl:()=>kw,multiplyImpl:()=>Nh,negImpl:()=>Iw,notEqualImpl:()=>Cw,prodImpl:()=>vw,rangeImpl:()=>yp,rsqrtImpl:()=>ww,sigmoidImpl:()=>IE,simpleAbsImpl:()=>aw,sliceImpl:()=>xp,sparseFillEmptyRowsImpl:()=>Gy,sparseReshapeImpl:()=>Wy,sparseSegmentReductionImpl:()=>Cm,sqrtImpl:()=>wE,squaredDifferenceImpl:()=>_w,stridedSliceImpl:()=>Uy,stringNGramsImpl:()=>Ky,stringSplitImpl:()=>Vy,stringToHashBucketFastImpl:()=>jy,subImpl:()=>Aw,tileImpl:()=>Hy,topKImpl:()=>qy,transposeImpl:()=>Im,uniqueImpl:()=>Xy});function aw(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}var EJ=r=>{let{x:e}=r.inputs,t=r.backend;re(e,"abs");let n=new Float32Array(b.sizeFromShape(e.shape)),o=t.data.get(e.dataId).values;return n=aw(o),t.makeOutput(n,e.shape,e.dtype)},ZM={kernelName:as,backendName:"cpu",kernelFunc:EJ};function nt(r){return(e,t,n,o,s)=>{let a=I.assertAndGetBroadcastShape(e,t),i=a.length,u=b.computeStrides(a),l=b.sizeFromShape(a),p=b.getTypedArrayFromDType(s,l),c=e.length,m=t.length,f=b.computeStrides(e),d=b.computeStrides(t),h=I.getBroadcastDims(e,a),g=I.getBroadcastDims(t,a);if(h.length+g.length===0)for(let y=0;y<p.length;++y)p[y]=r(n[y%n.length],o[y%o.length]);else for(let y=0;y<p.length;++y){let x=b.indexToLoc(y,i,u),T=x.slice(-c);h.forEach(A=>T[A]=0);let k=b.locToIndex(T,c,f),w=x.slice(-m);g.forEach(A=>w[A]=0);let P=b.locToIndex(w,m,d);p[y]=r(n[k],o[P])}return[p,a]}}function vr(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,i=t.makeTensorInfo(n.shape,"complex64"),u=t.data.get(i.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",a)},i}var JM={kernelName:Nu,backendName:"cpu",kernelFunc:vr};function xm(r,e,t="float32"){if(t==="complex64"){let o=xm(r,e,"float32"),s=xm(r,e,"float32");return vr({inputs:{real:o,imag:s},backend:r})}let n=b.makeZerosTypedArray(b.sizeFromShape(e),t);return r.makeTensorInfo(e,t,n)}function Xr(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var eE={kernelName:Kn,backendName:"cpu",kernelFunc:Xr};function zs(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var tE={kernelName:$u,backendName:"cpu",kernelFunc:zs};function Gs(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Xr({inputs:{x:o},backend:t});let a=xm(t,o.shape,o.dtype),i=Gs({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=vr({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}if(o.dtype==="complex64"){let a=zs({inputs:{input:o},backend:t}),i=Gs({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),i}if(!b.hasEncodingLoss(o.dtype,s)){let a=Xr({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(s==="int32"){let a=t.data.get(o.dataId).values,i=Int32Array.from(a);return t.makeTensorInfo(o.shape,"int32",i)}if(s==="bool"){let a=t.data.get(o.dataId).values,i=b.toTypedArray([0],o.dtype),[u,l]=nt((p,c)=>p!==c?1:0)(o.shape,[],a,i,"bool");return t.makeTensorInfo(l,"bool",u)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var rE={kernelName:Wn,backendName:"cpu",kernelFunc:Gs};function it(r,e,t,n){return t==null?({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;re([a,i],r);let l=u.data.get(a.dataId).values,p=u.data.get(i.dataId).values,c=a.dtype==="string"?I.fromUint8ToStringArray(l):l,m=a.dtype==="string"?I.fromUint8ToStringArray(p):p,f=n||a.dtype,[d,h]=e(a.shape,i.shape,c,m,f);return u.makeTensorInfo(h,f,d)}:({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(a.dtype==="complex64"||i.dtype==="complex64"){let l=Gs({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(l.dataId),c=p.complexTensorInfos.real,m=p.complexTensorInfos.imag,f=u.data.get(c.dataId).values,d=u.data.get(m.dataId).values,h=Gs({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),y=g.complexTensorInfos.real,x=g.complexTensorInfos.imag,T=u.data.get(y.dataId).values,k=u.data.get(x.dataId).values,[w,P,A]=t(a.shape,i.shape,f,d,T,k),F=u.makeTensorInfo(A,"float32",w),E=u.makeTensorInfo(A,"float32",P),$=vr({inputs:{real:F,imag:E},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(F),u.disposeIntermediateTensorInfo(E),$}else{let l=u.data.get(a.dataId).values,p=u.data.get(i.dataId).values,c=n||a.dtype,[m,f]=e(a.shape,i.shape,l,p,c);return u.makeTensorInfo(f,c,m)}}}function Tm(r){return(e,t,n,o,s,a)=>{let i=I.assertAndGetBroadcastShape(e,t),u=b.sizeFromShape(i),l=i.length,p=b.computeStrides(i),c=b.getTypedArrayFromDType("float32",u),m=b.getTypedArrayFromDType("float32",u),f=I.getBroadcastDims(e,i),d=I.getBroadcastDims(t,i),h=I.mergeRealAndImagArrays(n,o),g=I.mergeRealAndImagArrays(s,a),y=e.length,x=b.computeStrides(e),T=t.length,k=b.computeStrides(t);if(f.length+d.length===0)for(let w=0;w<c.length;w++){let P=w%h.length,A=w%g.length,F=r(h[P*2],h[P*2+1],g[A*2],g[A*2+1]);c[w]=F.real,m[w]=F.imag}else for(let w=0;w<c.length;w++){let P=b.indexToLoc(w,l,p),A=P.slice(-y);f.forEach(K=>A[K]=0);let F=b.locToIndex(A,y,x),E=P.slice(-T);d.forEach(K=>E[K]=0);let $=b.locToIndex(E,T,k),W=r(h[F*2],h[F*2+1],g[$*2],g[$*2+1]);c[w]=W.real,m[w]=W.imag}return[c,m,i]}}var iw=nt((r,e)=>r+e),RJ=Tm((r,e,t,n)=>({real:r+t,imag:e+n})),lu=it(_n,iw,RJ),nE={kernelName:_n,backendName:"cpu",kernelFunc:lu};function km(r,e,t,n,o){let s=b.sizeFromShape(n),a=b.makeZerosTypedArray(o,t);for(let i=0;i<r.length;i++){let u=r[i];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?a[u]+=e[i]:a[u]+=1)}return a}function Ly(r,e,t,n=!1){let o=r.shape[0],s=r.shape[1],a=Ce([o,t],e.dtype);for(let i=0;i<o;i++)for(let u=0;u<s;u++){let l=r.get(i,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(n?a.set(1,i,l):e.size>0?a.set(a.get(i,l)+e.get(i,u),i,l):a.set(a.get(i,l)+1,i,l))}return a}function xn(r){return(e,t,n)=>{let o=b.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=r(e[s],n);return o}}function $e(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(re(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,l=b.sizeFromShape(a.shape),p=t||a.dtype,c=b.getArrayFromDType(p,l);for(let m=0;m<l;++m)c[m]=e(u[m],o);return i.makeTensorInfo(a.shape,p,c)}}function Ws(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(re(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,l=t||a.dtype,p=e(u,l,o);return i.makeTensorInfo(a.shape,l,p)}}var uw=xn(r=>Math.ceil(r)),LJ=Ws(io,uw),oE={kernelName:io,backendName:"cpu",kernelFunc:LJ};function gp(r,e,t,n){let o=b.getArrayFromDType(t,b.sizeFromShape(e));if(n&&t!=="string"){let s=0;r.forEach(a=>{let i=b.sizeFromShape(a.shape);o.set(a.vals,s),s+=i})}else{let s=0;r.forEach(a=>{let i=t==="string"?I.fromUint8ToStringArray(a.vals):a.vals,u=0;for(let l=0;l<a.shape[0];++l){let p=l*e[1]+s;for(let c=0;c<a.shape[1];++c)o[p+c]=i[u++]}s+=a.shape[1]})}return o}var lw=nt((r,e)=>r===e?1:0),pw=it(Zs,lw,null,"bool"),sE={kernelName:Zs,backendName:"cpu",kernelFunc:pw};var cw=xn(r=>Math.exp(r)),mw=Ws(go,cw,"float32"),aE={kernelName:go,backendName:"cpu",kernelFunc:mw};var fw=xn(r=>Math.expm1(r)),$J=Ws(Js,fw),iE={kernelName:Js,backendName:"cpu",kernelFunc:$J};var dw=xn(r=>Math.floor(r)),BJ=Ws(bo,dw),uE={kernelName:bo,backendName:"cpu",kernelFunc:BJ};function $y(r,e,t,n,o,s,a,i,u){let l=Ce([n,s],t);for(let p=0;p<n;p++){let c=[],m=0;for(let f=0;f<o;f++){let d=r[p*o+f];m+=d*a[f],c.push(d)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${c} does not index into ${i}`);for(let f=0;f<s;f++)l.values[p*s+f]=e.get(...e.indexToLoc(m*s+f))}return l}function By(r,e,t){let n=Ce(t,r.dtype);for(let o=0;o<n.size;++o){let a=n.indexToLoc(o).slice(),i=a[0],u=a[2],l=e.locToIndex([i,u]);a[2]=e.values[l];let p=r.locToIndex(a);n.values[o]=r.values[p]}return n}var hw=nt((r,e)=>r>e?1:0),OJ=it(ra,hw,null,"bool"),lE={kernelName:ra,backendName:"cpu",kernelFunc:OJ};var gw=nt((r,e)=>r>=e?1:0),zJ=it(To,gw,null,"bool"),pE={kernelName:To,backendName:"cpu",kernelFunc:zJ};var bw=nt((r,e)=>r<e?1:0),GJ=it(oa,bw,null,"bool"),cE={kernelName:oa,backendName:"cpu",kernelFunc:GJ};var yw=nt((r,e)=>r<=e?1:0),WJ=it(sa,yw,null,"bool"),mE={kernelName:sa,backendName:"cpu",kernelFunc:WJ};function Oy(r,e,t){let n=(e-r)/(t-1),o=b.makeZerosTypedArray(t,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var xw=xn(r=>Math.log(r)),UJ=Ws(ko,xw),fE={kernelName:ko,backendName:"cpu",kernelFunc:UJ};function zy(r,e,t,n){let o=b.getTypedArrayFromDType(n,b.sizeFromShape(t));for(let s=0;s<o.length;++s){let a=s*e,i=r[a];for(let u=0;u<e;++u){let l=r[a+u];(Number.isNaN(l)||l>i)&&(i=l)}o[s]=i}return o}var Tw=nt((r,e)=>Math.max(r,e)),KJ=it(Co,Tw),dE={kernelName:Co,backendName:"cpu",kernelFunc:KJ};var kw=nt((r,e)=>Math.min(r,e)),VJ=it(_o,kw),hE={kernelName:_o,backendName:"cpu",kernelFunc:VJ};var Nh=nt((r,e)=>r*e),jJ=Tm((r,e,t,n)=>({real:r*t-e*n,imag:r*n+e*t})),bp=it(No,Nh,jJ),gE={kernelName:No,backendName:"cpu",kernelFunc:bp};function Iw(r,e,t){let n=b.createScalarValue(-1,t);return Nh([],e,n,r,t)}function HJ(r){let{inputs:e,backend:t}=r,{x:n}=e;re(n,"neg");let o=t.data.get(n.dataId).values,[s,a]=Iw(o,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,s)}var bE={kernelName:cs,backendName:"cpu",kernelFunc:HJ};var Cw=nt((r,e)=>r!==e?1:0),qJ=it(ia,Cw,null,"bool"),yE={kernelName:ia,backendName:"cpu",kernelFunc:qJ};function Im(r,e,t,n,o){let s=e.length,a=b.sizeFromShape(e),i=b.computeStrides(e),u=b.computeStrides(o),l=b.getTypedArrayFromDType(t,b.sizeFromShape(o));for(let p=0;p<a;++p){let c=b.indexToLoc(p,s,i),m=new Array(c.length);for(let d=0;d<m.length;d++)m[d]=c[n[d]];let f=b.locToIndex(m,s,u);l[f]=r[p]}return l}function lr(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{perm:s}=t;re(o,"transpose");let a=o.shape.length,i=new Array(a);for(let c=0;c<i.length;c++)i[c]=o.shape[s[c]];let u=n.data.get(o.dataId).values,l=Im(u,o.shape,o.dtype,s,i);return{dataId:n.write(l,i,o.dtype),shape:i,dtype:o.dtype}}var xE={kernelName:Vo,backendName:"cpu",kernelFunc:lr};function vw(r,e,t,n){let[o,s]=I.computeOutAndReduceShapes(r,n),a=Ut(e,"int32"),i=b.makeZerosTypedArray(b.sizeFromShape(o),a),u=b.sizeFromShape(s);for(let l=0;l<i.length;++l){let p=l*u,c=1;for(let m=0;m<u;++m)c*=t[p+m];i[l]=c}return{outVals:i,outShape:o,outDtype:a}}function XJ(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;re(o,"prod");let i=o.shape.length,u=b.parseAxisParam(s,o.shape),l=I.getAxesPermutation(u,i),p=u,c=o,m=[];l!=null&&(c=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),m.push(c),p=I.getInnerMostAxes(p.length,i));let f=t.data.get(c.dataId).values,{outVals:d,outShape:h,outDtype:g}=vw(c.shape,c.dtype,f,p),y=h;return a&&(y=I.expandShapeToKeepDim(h,u)),m.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(y,g,d)}var TE={kernelName:ca,backendName:"cpu",kernelFunc:XJ};function yp(r,e,t,n){let o=r===e,s=r<e&&t<0,a=e<r&&t>1;if(o||s||a)return b.makeZerosTypedArray(0,n);let i=Math.abs(Math.ceil((e-r)/t)),u=b.makeZerosTypedArray(i,n);e<r&&t===1&&(t=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}var ww=xn(r=>1/Math.sqrt(r)),YJ=Ws(Lo,ww),kE={kernelName:Lo,backendName:"cpu",kernelFunc:YJ};var IE=xn(r=>1/(1+Math.exp(-r))),Sw=$e(Bo,r=>1/(1+Math.exp(-r))),CE={kernelName:Bo,backendName:"cpu",kernelFunc:Sw};function xp(r,e,t,n,o){let s=Xt.isSliceContinous(n,e,t),a=b.sizeFromShape(t),i=b.computeStrides(n);if(s){let c=Xt.computeFlatOffset(e,i);return o==="string"?r.slice(c,c+a):r.subarray(c,c+a)}let u=o==="string"?I.fromUint8ToStringArray(r):r,l=Ce(n,o,u),p=Ce(t,o);for(let c=0;c<p.size;++c){let m=p.indexToLoc(c),f=m.map((d,h)=>d+e[h]);p.set(l.get(...f),...m)}return o==="string"?I.fromStringArrayToUint8(p.values):p.values}function Us(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n;re(o,"slice");let[i,u]=Xt.parseSliceParams(o,s,a);Xt.assertParamsValid(o,i,u);let l=t.data.get(o.dataId).values,p=xp(l,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,p)}var vE={kernelName:gs,backendName:"cpu",kernelFunc:Us};function Gy(r,e,t,n,o,s,a){let i=e[0],u=s[0],l=new Array(u),p=new Array(i),c=e[1];if(u===0){if(i!==0)throw new Error(`Received SparseTensor with denseShape[0] = 0 but
         indices.shape[0] = ${i}`);let g=b.getArrayFromDType(t,0),y=b.getArrayFromDType(o,0);return[g,[0,c],y,l,p]}let m=!0,f=0,d=new Array(u).fill(0);for(let g=0;g<i;++g){let y=r[g*c];if(y<0)throw new Error(`indices(${g}, 0) is invalid: ${y} < 0`);if(y>=u)throw new Error(`indices(${g}, 0) is invalid: ${y} >= ${u}`);++d[y],m=m&&y>=f,f=y}let h=!0;for(let g=0;g<u;++g){let y=d[g]===0;l[g]=y,h=h&&!y,d[g]=Math.max(d[g],1),g>0&&(d[g]+=d[g-1])}if(h&&m){let g=r,y=n;for(let x=0;x<i;++x)p[x]=x;return[g,[i,c],y,l,p]}else{let g=d[u-1],y=b.getArrayFromDType(t,g*c),x=b.getArrayFromDType(o,g),T=new Array(u).fill(0);for(let k=0;k<i;++k){let w=r[k*c],P=T[w],A=(w===0?0:d[w-1])+P;T[w]++;for(let F=0;F<c;++F)y[A*c+F]=r[k*c+F];x[A]=n[k],p[k]=A}for(let k=0;k<u;++k)if(T[k]===0){let P=k===0?0:d[k-1];y[P*c+0]=k;for(let A=1;A<c;++A)y[P*c+A]=0;x[P]=a}return[y,[g,c],x,l,p]}}function Wy(r,e,t,n,o){let s=b.sizeFromShape(n),a=e[0],i=o.length,u=[],l=1,p=-1;for(let g=0;g<i;++g){let y=o[g];if(y===-1){if(p!==-1)throw new Error(`only one output dimension may be -1, not both ${p} and ${g}`);p=g,u.push(1)}else{if(y<0)throw new Error(`size ${g} must be non-negative, not ${y}`);l*=y,u.push(y)}}if(p!==-1){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");let g=Math.trunc(s/l);if(l*g!==s)throw new Error(`Input to reshape is a SparseTensor with ${s}
          dense values, but the requested shape requires a multiple of ${l}. inputShape=${n} outputShape= ${u}`);u[p]=g}let c=b.sizeFromShape(u);if(c!==s)throw new Error(`Input to reshape is a tensor with ${s} dense values, but the requested shape has ${c}. inputShape=${n} outputShape=${u}`);let m=n.length,f=[];if(m>0){f[m-1]=1;for(let g=m-2;g>=0;--g)f[g]=f[g+1]*n[g+1]}let d=[];if(i>0){d[i-1]=1;for(let g=i-2;g>=0;--g)d[g]=d[g+1]*u[g+1]}let h=b.getArrayFromDType(t,a*i);for(let g=0;g<a;++g){let y=0;for(let x=0;x<m;++x)y+=r[g*m+x]*f[x];for(let x=0;x<i;++x)h[g*i+x]=Math.trunc(y/d[x]),y%=d[x]}return[h,[a,i],u]}function Cm(r,e,t,n,o,s=!1,a=0){let i=n.length;if(i!==o.length)throw new Error("segmentIds and indices should have same size.");let u=[e[0],r.length/e[0]],l=u[1],c=i>0?o[i-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");let m=e.slice();m[0]=c;let f=m.reduce((T,k)=>T*k,1),d=b.getArrayFromDType(t,f);if(i===0)return c>0&&d.fill(a),[d,m];if(c<=0)throw new Error("segment ids must be >= 0");let h=0,g=1,y=0,x=o[h];for(;;){let T=0;if(g<i){if(T=o[g],x===T){++g;continue}if(x>=T)throw new Error("segment ids are not increasing")}if(x<0||x>=c)throw new Error(`Segment id ${x} out of range [0, ${c}), possibly because segmentIds input is not sorted.`);x>y&&d.fill(a,y*l,x*l);for(let k=h;k<g;++k){let w=n[k];if(w<0||w>=u[0])throw new Error(`Bad: indices[${k}] == ${n[k]} out of range [0, ${u[0]})`);for(let P=0;P<l;P++)d[x*l+P]+=r[w*l+P]}if(s)for(let k=0;k<l;k++)d[x*l+k]/=g-h;if(h=g,++g,y=x+1,x=T,g>i)break}return y<c&&d.fill(a,y*l,c*l),[d,m]}var wE=xn(r=>Math.sqrt(r)),QJ=$e(Oo,r=>Math.sqrt(r)),SE={kernelName:Oo,backendName:"cpu",kernelFunc:QJ};var _w=nt((r,e)=>{let t=r-e;return t*t}),ZJ=it(Wo,_w),_E={kernelName:Wo,backendName:"cpu",kernelFunc:ZJ};function Uy(r,e,t,n){let o=Ce(r,e.dtype);for(let s=0;s<o.size;s++){let a=o.indexToLoc(s),i=new Array(a.length);for(let u=0;u<i.length;u++)i[u]=a[u]*t[u]+n[u];o.set(e.get(...i),...a)}return o}var AE=class{constructor(e,t,n,o,s,a){this.separator=b.encodeString(e),this.nGramWidths=t,this.leftPad=b.encodeString(n),this.rightPad=b.encodeString(o),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,o,s,a){for(let i=0;i<s;++i){let u=this.getPadWidth(a),l=Math.max(0,u-i),p=Math.max(0,u-(s-(i+1))),c=a-(l+p),m=t+(l>0?0:i-u),f=0;f+=l*this.leftPad.length;for(let x=0;x<c;++x)f+=e[m+x].length;f+=p*this.rightPad.length,f+=(l+p+c-1)*this.separator.length,n[o+i]=new Uint8Array(f);let h=n[o+i],g=0,y=x=>x.forEach(T=>h[g++]=T);for(let x=0;x<l;++x)y(this.leftPad),y(this.separator);for(let x=0;x<c-1;++x)y(e[m+x]),y(this.separator);if(c>0){y(e[m+c-1]);for(let x=0;x<p;++x)y(this.separator),y(this.rightPad)}else{for(let x=0;x<p-1;++x)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,t){let n=e.length,o=t.length;if(o>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let p=t[l]>=u;if(p=p&&t[l]<=n,!p)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${n}]`);u=t[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,a=b.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)a[l]=0;return[u,a]}a[0]=0;for(let u=1;u<=s;++u){let l=t[u]-t[u-1],p=0;this.nGramWidths.forEach(c=>{p+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&p===0&&(p=1),a[u]=a[u-1]+p}let i=new Array(a[s]);for(let u=0;u<s;++u){let l=t[u],p=a[u];if(this.nGramWidths.forEach(c=>{let m=t[u+1]-t[u],f=this.getNumNGrams(m,c);this.createNGrams(e,l,i,p,f,c),p+=f}),this.preserveShort&&p===a[u]){let c=t[u+1]-t[u];if(c===0)continue;let m=c+2*this.padWidth,f=1;this.createNGrams(e,l,i,p,f,m)}}return[i,a]}};function Ky(r,e,t,n,o,s,a,i){return new AE(t,n,o,s,a,i).compute(r,e)}function JJ(r,e,t,n){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(e.length===1){let s=e[0],a=r.indexOf(s);for(;a!==-1;){let i=r.subarray(0,a);(!t||i.length!==0)&&n.push(i),r=r.subarray(a+1),a=r.indexOf(s)}(!t||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){let a=r.subarray(o,s);(!t||a.length!==0)&&n.push(a),o=s+1}}function Vy(r,e,t){let n=r.length,o=[],s=0,a=0,i=new Array(n);for(let m=0;m<n;++m){let f=o.length;JJ(r[m],e,t,o);let d=o.length-f;i[m]=d,s+=d,a=Math.max(a,d)}let u=b.getArrayFromDType("int32",s*2),l=new Array(s),p=[n,a],c=0;for(let m=0;m<n;++m)for(let f=0;f<i[m];++f)u[c*2]=m,u[c*2+1]=f,l[c]=o[c],++c;return[u,l,p]}function jy(r,e){let t=b.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)t[n]=b.fingerPrint64(r[n]).modulo(e).getLowBitsUnsigned();return t}var Aw=nt((r,e)=>r-e),e9=Tm((r,e,t,n)=>({real:r-t,imag:e-n})),Dh=it(Uo,Aw,e9),NE={kernelName:Uo,backendName:"cpu",kernelFunc:Dh};function Hy(r,e){let t=new Array(r.rank);for(let o=0;o<t.length;o++)t[o]=r.shape[o]*e[o];let n=Ce(t,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),a=new Array(r.rank);for(let u=0;u<a.length;u++)a[u]=s[u]%r.shape[u];let i=r.locToIndex(a);n.values[o]=r.values[i]}return n}var Ph=(r,e)=>{let t=e.value-r.value;return t===0?r.index-e.index:t};function DE(r,e,t=0,n=r.length-1){for(;n>t;){if(n-t>600){let i=n-t+1,u=e-t+1,l=Math.log(i),p=.5*Math.exp(2*l/3),c=.5*Math.sqrt(l*p*(i-p)/i)*Math.sign(u-i/2),m=Math.max(t,Math.floor(e-u*p/i+c)),f=Math.min(n,Math.floor(e+(i-u)*p/i+c));DE(r,e,m,f)}let o=r[e],s=t,a=n;for(b.swap(r,t,e),Ph(r[n],o)>0&&b.swap(r,t,n);s<a;){for(b.swap(r,s,a),s++,a--;Ph(r[s],o)<0;)s=s+1;for(;Ph(r[a],o)>0;)a=a-1}Ph(r[t],o)===0?b.swap(r,t,a):(a=a+1,b.swap(r,a,n)),a<=e&&(t=a+1),e<=a&&(n=a-1)}}function qy(r,e,t,n,o){let s=e[e.length-1],[a,i]=[r.length/s,s],u=b.getTypedArrayFromDType(t,a*n),l=b.getTypedArrayFromDType("int32",a*n);for(let c=0;c<a;c++){let m=c*i,f=r.subarray(m,m+i),d=new Array(f.length);f.forEach((x,T)=>d[T]={value:x,index:T}),n<d.length&&(DE(d,n),d=d.slice(0,n)),o&&d.sort(Ph);let h=c*n,g=u.subarray(h,h+n),y=l.subarray(h,h+n);for(let x=0;x<n;x++)g[x]=d[x].value,y[x]=d[x].index}let p=e.slice();return p[p.length-1]=n,[Ce(p,t,u),Ce(p,"int32",l)]}function Xy(r,e,t,n){let o=b.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let d=0;d<o;d++)s[0]*=t[d];s[1]=t[o];for(let d=o+1;d<t.length;d++)s[2]*=t[d];let a={},i=new Int32Array(t[o]),u=new xt(s,n,r),l=[],p=s[0]===1&&s[2]===1;for(let d=0;d<t[o];d++){let h;if(p)h=r[d].toString();else{let g=[];for(let y=0;y<s[0];y++)for(let x=0;x<s[2];x++)g.push(u.get(y,d,x));h=g.join(",")}if(a[h]!==void 0)i[d]=a[h];else{let g=Object.keys(a).length;a[h]=g,i[d]=g,l.push(d)}}let c=s.slice();c[1]=Object.keys(a).length;let m=new xt(c,n);l.forEach((d,h)=>{for(let g=0;g<s[0];g++)for(let y=0;y<s[2];y++)m.set(u.get(g,d,y),g,h,y)});let f=t.slice();return f[o]=c[1],{outputValues:m.values,outputShape:f,indices:i}}var t9="0.0.0";Vu("cpu",()=>new Ah,1);var Nw=$e(ho,r=>r>=0?r:Math.exp(r)-1),PE={kernelName:ho,backendName:"cpu",kernelFunc:Nw};function Dw(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n;re([o],"leakyRelu");let a=b.sizeFromShape(o.shape),i=t.data.get(o.dataId).values,u=b.getTypedArrayFromDType("float32",a);for(let l=0;l<i.length;l++)u[l]=i[l]<0?s*i[l]:i[l];return t.makeTensorInfo(o.shape,"float32",u)}var FE={kernelName:na,backendName:"cpu",kernelFunc:Dw};var r9=nt((r,e)=>r<0?e*r:r);function Pw(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e;re([n,o],"prelu");let s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,[i,u]=r9(n.shape,o.shape,s,a,"float32");return t.makeTensorInfo(u,"float32",i)}var ME={kernelName:Fo,backendName:"cpu",kernelFunc:Pw};var Fw=$e(Mo,r=>Math.max(0,r)),EE={kernelName:Mo,backendName:"cpu",kernelFunc:Fw};var Mw=$e(Ro,r=>Math.min(Math.max(0,r),6)),RE={kernelName:Ro,backendName:"cpu",kernelFunc:Mw};function wm(r,e,t,n,o){if(t==="linear")return Xr({inputs:{x:e},backend:r});if(t==="relu")return Fw({inputs:{x:e},backend:r});if(t==="elu")return Nw({inputs:{x:e},backend:r});if(t==="relu6")return Mw({inputs:{x:e},backend:r});if(t==="prelu")return Pw({inputs:{x:e,alpha:n},backend:r});if(t==="leakyrelu")return Dw({inputs:{x:e},backend:r,attrs:{alpha:o}});if(t==="sigmoid")return Sw({inputs:{x:e},backend:r});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function ot(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=b.sizeFromShape(o.shape),i=b.inferFromImplicitShape(s,a),u=b.sizeFromShape(i);b.assert(a===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let l=t.data.get(o.dataId);if(l.complexTensorInfos!=null){let p=l.complexTensorInfos.real,c=l.complexTensorInfos.imag;p.shape=i,c.shape=i}return{dataId:o.dataId,shape:i,dtype:o.dtype}}var LE={kernelName:ds,backendName:"cpu",kernelFunc:ot};function Ew(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;re([o,s],"matMul");let u=o.shape.length,l=s.shape.length,p=a?o.shape[u-2]:o.shape[u-1],c=i?s.shape[l-1]:s.shape[l-2],m=a?o.shape[u-1]:o.shape[u-2],f=i?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=b.sizeFromShape(d),y=b.sizeFromShape(h),x=g===y||g===1||y===1;b.assert(u>=2&&l>=2&&x,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${d}) and (${h}).`);let k=(g>y?o.shape.slice(0,-2):s.shape.slice(0,-2)).concat([m,f]);b.assert(p===c,()=>`Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let w=a?[g,p,m]:[g,m,p],P=i?[y,f,c]:[y,c,f],A=ot({inputs:{x:o},backend:t,attrs:{shape:w}}),F=ot({inputs:{x:s},backend:t,attrs:{shape:P}}),E=a?A.shape[1]:A.shape[2],$=a?A.shape[2]:A.shape[1],W=i?F.shape[1]:F.shape[2],K=Math.max(g,y),B=t.data.get(A.dataId).values,V=t.data.get(F.dataId).values,j=b.computeStrides(A.shape),H=b.computeStrides(F.shape),[J,X,ne]=a?[j[0],1,j[1]]:[j[0],j[1],1],[oe,te,le]=i?[1,H[1],H[0]]:[H[1],1,H[0]],ae=$*W,ge=Ce([K,$,W],A.dtype),fe=ge.values,xe=t.blockSize;for(let Se=0;Se<K;Se++)for(let Be=0;Be<$;Be+=xe)for(let Re=0;Re<W;Re+=xe)for(let Oe=0;Oe<E;Oe+=xe){let rt=Math.min(Be+xe,$),gt=Math.min(Re+xe,W),$t=Math.min(Oe+xe,E);for(let Bt=Be;Bt<rt;Bt++)for(let kt=Re;kt<gt;kt++){let Je=0;for(let Ct=Oe;Ct<$t;Ct++){let Ht=Math.min(Se,g-1)*J,On=Math.min(Se,y-1)*le,gr=B[Ht+Bt*X+Ct*ne],In=V[Ct*oe+kt*te+On];Je+=gr*In}fe[Se*ae+(Bt*W+kt)]+=Je}}return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(F),t.makeTensorInfo(k,ge.dtype,ge.values)}var $E={kernelName:ao,backendName:"cpu",kernelFunc:Ew};function n9(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n,m,f,d,h=[];m=Ew({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:t}),a&&(f=lu({inputs:{a:m,b:a},backend:t}),h.push(m),m=f),p&&(d=wm(t,m,p,i,c),h.push(m),m=d);for(let y of h)t.disposeIntermediateTensorInfo(y);return m}var BE={kernelName:Is,backendName:"cpu",kernelFunc:n9};var o9=$e(bi,r=>Math.acos(r)),OE={kernelName:bi,backendName:"cpu",kernelFunc:o9};var s9=$e(yi,r=>Math.acosh(r)),zE={kernelName:yi,backendName:"cpu",kernelFunc:s9};function a9(r){let{inputs:e,backend:t}=r,n=e;re(e,"addN");let o=n.map(i=>t.data.get(i.dataId).values),s=Ce(n[0].shape,n[0].dtype),a=s.values;for(let i=0;i<n.length;i++){let u=o[i];for(let l=0;l<a.length;l++)a[l]+=u[l]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var GE={kernelName:no,backendName:"cpu",kernelFunc:a9};function i9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;re(o,"all");let i=b.parseAxisParam(s,o.shape),u=i,l=I.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),u=I.getInnerMostAxes(u.length,o.shape.length)),I.assertAxesAreInnerMostDims("all",u,p.shape.length);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),f=b.sizeFromShape(m),d=b.makeZerosTypedArray(b.sizeFromShape(c),p.dtype),h=t.data.get(p.dataId).values;for(let y=0;y<d.length;++y){let x=y*f,T=h[x];for(let k=0;k<f;++k){let w=h[x+k];T=T&&w}d[y]=T}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(c,p.dtype,d);if(a){let y=I.expandShapeToKeepDim(c,i),x=ot({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}var WE={kernelName:xi,backendName:"cpu",kernelFunc:i9};function u9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;re(o,"any");let i=b.parseAxisParam(s,o.shape),u=i,l=I.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),u=I.getInnerMostAxes(u.length,o.shape.length)),I.assertAxesAreInnerMostDims("any",u,p.shape.length);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),f=b.sizeFromShape(m),d=b.makeZerosTypedArray(b.sizeFromShape(c),p.dtype),h=t.data.get(p.dataId).values;for(let y=0;y<d.length;++y){let x=y*f,T=h[x];for(let k=0;k<f;++k){let w=h[x+k];T=T||w}d[y]=T}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(c,p.dtype,d);if(a){let y=I.expandShapeToKeepDim(c,i),x=ot({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}var UE={kernelName:Ti,backendName:"cpu",kernelFunc:u9};function l9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;re(o,"argMax");let a=b.parseAxisParam(s,o.shape),i=I.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=lr({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=I.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],I.assertAxesAreInnerMostDims("argMax",a,u.shape.length);let[p,c]=I.computeOutAndReduceShapes(u.shape,a),m=b.sizeFromShape(p),f=b.makeZerosTypedArray(m,"int32"),d=b.sizeFromShape(c),h=t.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,x=h[y],T=0;for(let k=0;k<d;++k){let w=h[y+k];w>x&&(x=w,T=k)}f[g]=T}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",f)}var KE={kernelName:oo,backendName:"cpu",kernelFunc:l9};function p9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;re(o,"argMin");let a=b.parseAxisParam(s,o.shape),i=I.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=lr({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=I.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],I.assertAxesAreInnerMostDims("argMin",a,u.shape.length);let[p,c]=I.computeOutAndReduceShapes(u.shape,a),m=b.sizeFromShape(p),f=b.makeZerosTypedArray(m,"int32"),d=b.sizeFromShape(c),h=t.data.get(u.dataId).values;for(let g=0;g<f.length;++g){let y=g*d,x=h[y],T=0;for(let k=0;k<d;++k){let w=h[y+k];w<x&&(x=w,T=k)}f[g]=T}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",f)}var VE={kernelName:Wa,backendName:"cpu",kernelFunc:p9};var c9=$e(ki,r=>Math.asin(r)),jE={kernelName:ki,backendName:"cpu",kernelFunc:c9};var m9=$e(Ii,r=>Math.asinh(r)),HE={kernelName:Ii,backendName:"cpu",kernelFunc:m9};var f9=$e(Ci,r=>Math.atan(r)),qE={kernelName:Ci,backendName:"cpu",kernelFunc:f9};var d9=nt((r,e)=>Math.atan2(r,e)),h9=it(wi,d9),XE={kernelName:wi,backendName:"cpu",kernelFunc:h9};var g9=$e(vi,r=>Math.atanh(r)),YE={kernelName:vi,backendName:"cpu",kernelFunc:g9};function Sm(r,e,t,n,o,s){let a=o.strideHeight,i=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,p=o.effectiveFilterHeight,c=o.effectiveFilterWidth,m=o.padInfo.top,f=o.padInfo.left,d=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=Ce(o.outShape,t),g=h.values,y=o.outShape[1]*o.outShape[2]*o.outShape[3],x=o.outShape[2]*o.outShape[3],T=o.outShape[3];for(let k=0;k<o.batchSize;++k){let w=k*y,P=k*n[0];for(let A=0;A<o.inChannels;++A)for(let F=0;F<o.outHeight;++F){let E=F*a-m,$=Math.max(0,E),W=Math.min(o.inHeight,p+E),K=w+F*x;for(let B=0;B<o.outWidth;++B){let V=B*i-f,j=Math.max(0,V),H=Math.min(o.inWidth,c+V),J=d,X=0,ne=0;for(let te=$;te<W;te+=u){let le=P+te*n[1];for(let ae=j;ae<H;ae+=l){let ge=le+ae*n[2],fe=r[ge+A];s==="max"&&fe>J?J=fe:s==="avg"&&(X+=fe,ne++)}if(isNaN(J))break}let oe=K+B*T+A;g[oe]=s==="avg"?X/ne:J}}}return h}function Yy(r,e,t,n,o=!1,s=!1){let a=Ce(n.outShape,"int32"),i=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,p=n.dilationWidth,c=n.effectiveFilterHeight,m=n.effectiveFilterWidth,f=n.padInfo.top,d=n.padInfo.left,h=Ce(e,t,r);for(let g=0;g<n.batchSize;++g)for(let y=0;y<n.inChannels;++y)for(let x=0;x<n.outHeight;++x){let T=x*i-f,k=T;for(;k<0;)k+=l;let w=Math.min(n.inHeight,c+T);for(let P=0;P<n.outWidth;++P){let A=P*u-d,F=A;for(;F<0;)F+=p;let E=Math.min(n.inWidth,m+A),$=Number.NEGATIVE_INFINITY,W=-1;for(let K=k;K<w;K+=l){let B=K-T;for(let V=F;V<E;V+=p){let j=V-A,H=h.get(g,K,V,y);H>$&&($=H,o?W=s?((g*n.inHeight+K)*n.inWidth+V)*n.inChannels+y:(K*n.inWidth+V)*n.inChannels+y:W=B*m+j)}}a.set(W,g,x,P,y)}}return a}function Qy(r,e,t,n,o,s){let a=o.strideDepth,i=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,p=o.dilationHeight,c=o.dilationWidth,m=o.effectiveFilterDepth,f=o.effectiveFilterHeight,d=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,y=o.padInfo.left,x=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=Ce(o.outShape,t),k=T.values,w=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],P=o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[3]*o.outShape[4],F=o.outShape[4];for(let E=0;E<o.batchSize;++E){let $=E*w,W=E*n[0];for(let K=0;K<o.inChannels;++K)for(let B=0;B<o.outDepth;++B){let V=B*a-h,j=V;for(;j<0;)j+=l;let H=Math.min(o.inDepth,m+V),J=$+B*P;for(let X=0;X<o.outHeight;++X){let ne=X*i-g,oe=ne;for(;oe<0;)oe+=p;let te=Math.min(o.inHeight,f+ne),le=J+X*A;for(let ae=0;ae<o.outWidth;++ae){let ge=ae*u-y,fe=ge;for(;fe<0;)fe+=c;let xe=Math.min(o.inWidth,d+ge),Se=le+ae*F,Be=x,Re=0,Oe=0;for(let gt=j;gt<H;gt+=l){let $t=W+gt*n[1];for(let Bt=oe;Bt<te;Bt+=p){let kt=$t+Bt*n[2];for(let Je=fe;Je<xe;Je+=c){let Ct=kt+Je*n[3],Ht=r[Ct+K];if(s==="max"&&Ht>Be?Be=Ht:s==="avg"&&(Re+=Ht,Oe++),isNaN(Be))break}if(isNaN(Be))break}if(isNaN(Be))break}let rt=Se+K;k[rt]=s==="avg"?Re/Oe:Be}}}}return T}function QE(r,e){let t=Ce(e.outShape,"int32"),n=e.strideDepth,o=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,p=e.effectiveFilterHeight,c=e.effectiveFilterWidth,m=e.padInfo.front,f=e.padInfo.top,d=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let y=0;y<e.outDepth;++y){let x=y*n-m,T=x;for(;T<0;)T+=a;let k=Math.min(e.inDepth,l+x);for(let w=0;w<e.outHeight;++w){let P=w*o-f,A=P;for(;A<0;)A+=i;let F=Math.min(e.inHeight,p+P);for(let E=0;E<e.outWidth;++E){let $=E*s-d,W=$;for(;W<0;)W+=u;let K=Math.min(e.inWidth,c+$),B=Number.NEGATIVE_INFINITY,V=-1;for(let j=T;j<k;j+=a){let H=j-x;for(let J=A;J<F;J+=i){let X=J-P;for(let ne=W;ne<K;ne+=u){let oe=ne-$,te=r.get(h,j,J,ne,g);te>=B&&(B=te,V=H*p*c+X*p+oe)}}}t.set(V,h,y,w,E,g)}}}return t}function b9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;re(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,a,l,i,u),c;if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))c=Xr({inputs:{x:o},backend:t});else{let m=t.data.get(o.dataId).values,f=b.computeStrides(o.shape),d=Sm(m,o.shape,o.dtype,f,p,"avg");c=t.makeTensorInfo(p.outShape,o.dtype,d.values)}return c}var ZE={kernelName:so,backendName:"cpu",kernelFunc:b9};function y9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n;re(o,"avgPool3d");let p=I.computePool3DInfo(o.shape,s,a,1,i,u,l),c=t.data.get(o.dataId).values,m=Qy(c,o.shape,o.dtype,b.computeStrides(o.shape),p,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}var JE={kernelName:Au,backendName:"cpu",kernelFunc:y9};function x9(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=n;re([o,s],"avgPool3DGrad");let p=I.computePool3DInfo(s.shape,a,i,1,u,l),c=p.strideDepth,m=p.strideHeight,f=p.strideWidth,d=p.filterDepth,h=p.filterHeight,g=p.filterWidth,y=p.dilationDepth,x=p.dilationHeight,T=p.dilationWidth,k=p.effectiveFilterDepth,w=p.effectiveFilterHeight,P=p.effectiveFilterWidth,A=k-1-p.padInfo.front,F=P-1-p.padInfo.left,E=w-1-p.padInfo.top,$=Ce(s.shape,"float32"),W=1/(d*h*g),K=t.bufferSync(o);for(let B=0;B<p.batchSize;++B)for(let V=0;V<p.inChannels;++V)for(let j=0;j<p.inDepth;++j)for(let H=0;H<p.inHeight;++H)for(let J=0;J<p.inWidth;++J){let X=j-A,ne=H-E,oe=J-F,te=0;for(let le=0;le<k;le+=y){let ae=(X+le)/c;if(!(ae<0||ae>=p.outDepth||Math.floor(ae)!==ae))for(let ge=0;ge<w;ge+=x){let fe=(ne+ge)/m;if(!(fe<0||fe>=p.outHeight||Math.floor(fe)!==fe))for(let xe=0;xe<P;xe+=T){let Se=(oe+xe)/f;if(Se<0||Se>=p.outWidth||Math.floor(Se)!==Se)continue;te+=K.get(B,ae,fe,Se,V)}}}$.set(te*W,B,j,H,J,V)}return t.makeTensorInfo($.shape,$.dtype,$.values)}var eR={kernelName:Xp,backendName:"cpu",kernelFunc:x9};function T9(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;re([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=n,p=I.computePool2DInfo(a.shape,i,u,1,l),c=p.strideHeight,m=p.strideWidth,f=p.filterHeight,d=p.filterWidth,h=p.dilationHeight,g=p.dilationWidth,y=p.effectiveFilterHeight,x=p.effectiveFilterWidth,T=x-1-p.padInfo.left,k=y-1-p.padInfo.top,w=Ce(a.shape,"float32"),P=1/(f*d),A=t.data.get(o.dataId).values,F=Ce(o.shape,"float32",A);for(let E=0;E<p.batchSize;++E)for(let $=0;$<p.inChannels;++$)for(let W=0;W<p.inHeight;++W)for(let K=0;K<p.inWidth;++K){let B=W-k,V=K-T,j=0;for(let H=0;H<y;H+=h){let J=(B+H)/c;if(!(J<0||J>=p.outHeight||Math.floor(J)!==J))for(let X=0;X<x;X+=g){let ne=(V+X)/m;if(ne<0||ne>=p.outWidth||Math.floor(ne)!==ne)continue;j+=F.get(E,J,ne,$)}}w.set(j*P,E,W,K,$)}return t.makeTensorInfo(w.shape,w.dtype,w.values)}var tR={kernelName:qp,backendName:"cpu",kernelFunc:T9};function k9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,scale:s,offset:a,mean:i,variance:u}=e;b.assert(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(s==null||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),re([o,i,u,s,a],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let p=t.data.get(o.dataId).values,c=t.data.get(i.dataId).values,m=t.data.get(u.dataId).values,f=s?t.data.get(s.dataId).values:new Float32Array([1]),d=a?t.data.get(a.dataId).values:new Float32Array([0]),h=new Float32Array(p.length),g=d.length,y=f.length,x=m.length,T=c.length,k=0,w=0,P=0,A=0;for(let F=0;F<p.length;++F)h[F]=d[k++]+(p[F]-c[w++])*f[P++]/Math.sqrt(m[A++]+l),k>=g&&(k=0),w>=T&&(w=0),P>=y&&(P=0),A>=x&&(A=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var rR={kernelName:xo,backendName:"cpu",kernelFunc:k9};function I9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;re([o],"batchToSpaceND");let i=s.reduce((y,x)=>y*x),u=I.getReshaped(o.shape,s,i),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,i),c=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(p,a,s.length),f=ot({inputs:{x:o},backend:t,attrs:{shape:u}}),d=lr({inputs:{x:f},backend:t,attrs:{perm:l}}),h=ot({inputs:{x:d},backend:t,attrs:{shape:p}}),g=Us({inputs:{x:h},backend:t,attrs:{begin:c,size:m}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var nR={kernelName:is,backendName:"cpu",kernelFunc:I9};function C9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=km(i,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}var oR={kernelName:Yp,backendName:"cpu",kernelFunc:C9};function v9(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,i=I.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var sR={kernelName:Qp,backendName:"cpu",kernelFunc:v9};var w9=$e(Un,(r,e)=>{let t=e;return r>t.clipValueMax?t.clipValueMax:r<t.clipValueMin?t.clipValueMin:r}),aR={kernelName:Un,backendName:"cpu",kernelFunc:w9};var S9=r=>{let{x:e}=r.inputs,t=r.backend,n=new Float32Array(b.sizeFromShape(e.shape)),o=t.data.get(e.dataId),s=o.complexTensorInfos.real,a=o.complexTensorInfos.imag,i=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values;for(let l=0;l<i.length;l++){let p=i[l],c=u[l];n[l]=Math.hypot(p,c)}return t.makeOutput(n,e.shape,"float32")},iR={kernelName:Du,backendName:"cpu",kernelFunc:S9};function ai(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var uR={kernelName:Eu,backendName:"cpu",kernelFunc:ai};function sl(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,e[0].shape)[0],a=I.computeOutShape(e.map(h=>h.shape),s);if(b.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let i=e.filter(h=>b.sizeFromShape(h.shape)>0);if(i.length===1)return Xr({inputs:{x:i[0]},backend:t});let u=i.map(h=>h.shape);if(I.assertParamsConsistent(u,s),i[0].dtype==="complex64"){let h=i.map(k=>zs({inputs:{input:k},backend:t})),g=i.map(k=>ai({inputs:{input:k},backend:t})),y=sl({inputs:h,backend:t,attrs:{axis:s}}),x=sl({inputs:g,backend:t,attrs:{axis:s}}),T=vr({inputs:{real:y,imag:x},backend:t});return h.forEach(k=>t.disposeIntermediateTensorInfo(k)),g.forEach(k=>t.disposeIntermediateTensorInfo(k)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),T}let l=i.map(h=>{let g=b.sizeFromShape(h.shape.slice(s));return ot({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}})}),p=l.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));a=I.computeOutShape(l.map(h=>h.shape),1);let c=l[0].shape[0]===1,m=gp(p,a,e[0].dtype,c),f=I.computeOutShape(i.map(h=>h.shape),s),d=t.makeTensorInfo(f,e[0].dtype,m);return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}var lR={kernelName:us,backendName:"cpu",kernelFunc:sl};function Rw(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n;re([o,s],"conv2d");let c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,c),f=m.filterHeight,d=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,y=m.padInfo.left,x=m.padInfo.top,T=m.dataFormat==="channelsLast",k=new xt(m.outShape,o.dtype),w=b.computeStrides(o.shape),P=b.computeStrides(s.shape),A=w[0],F=T?w[1]:w[2],E=T?w[2]:1,$=T?1:w[1],W=k.strides[0],K=T?k.strides[1]:k.strides[2],B=T?k.strides[2]:1,V=T?1:k.strides[1],j=t.data.get(o.dataId).values,H=t.data.get(s.dataId).values,J=k.values;for(let X=0;X<m.batchSize;++X){let ne=X*A,oe=X*W;for(let te=0;te<m.outHeight;++te){let le=oe+te*K,ae=te*m.strideHeight-x;for(let ge=0;ge<f;++ge){let fe=ae+ge*h;if(fe<0||fe>=m.inHeight)continue;let xe=ge*P[0],Se=ne+fe*F;for(let Be=0;Be<m.outWidth;++Be){let Re=le+Be*B,Oe=Be*m.strideWidth-y;for(let rt=0;rt<d;++rt){let gt=Oe+rt*g;if(gt<0||gt>=m.inWidth)continue;let $t=xe+rt*P[1],Bt=Se+gt*E,kt=$t;for(let Je=0;Je<m.inChannels;++Je){let Ct=j[Bt+Je*$];for(let Ht=0;Ht<m.outChannels;++Ht)J[Re+Ht*V]+=Ct*H[kt+Ht];kt+=m.outChannels}}}}}}return t.makeTensorInfo(k.shape,k.dtype,J)}var pR={kernelName:uo,backendName:"cpu",kernelFunc:Rw};function _9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:p}=n;re([o,s],"conv2dBackpropFilter");let c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,p,a,1,i,l,!1,c),{strideHeight:f,strideWidth:d,filterHeight:h,filterWidth:g}=m,y=m.dataFormat==="channelsLast",x=new xt(m.filterShape,"float32"),T=m.padInfo.left,k=m.padInfo.top,w=t.data.get(o.dataId).values,P=t.data.get(s.dataId).values,A=new xt(o.shape,o.dtype,w),F=new xt(s.shape,s.dtype,P);for(let E=0;E<h;++E){let $=Math.max(0,Math.ceil((k-E)/f)),W=Math.min(m.outHeight,(m.inHeight+k-E)/f);for(let K=0;K<g;++K){let B=Math.max(0,Math.ceil((T-K)/d)),V=Math.min(m.outWidth,(m.inWidth+T-K)/d);for(let j=0;j<m.inChannels;++j)for(let H=0;H<m.outChannels;++H){let J=0;for(let X=0;X<m.batchSize;++X)for(let ne=$;ne<W;++ne){let oe=E+ne*f-k;for(let te=B;te<V;++te){let le=K+te*d-T;y?J+=A.get(X,oe,le,j)*F.get(X,ne,te,H):J+=A.get(X,j,oe,le)*F.get(X,H,ne,te)}}x.set(J,E,K,j,H)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}var cR={kernelName:Zp,backendName:"cpu",kernelFunc:_9};function A9(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n;re([o,s],"conv2dBackpropInput");let c=b.computeStrides(s.shape),m=b.computeStrides(o.shape),f=I.convertConv2DDataFormat(l),d=I.computeConv2DInfo(a,s.shape,i,1,u,p,!1,f),h=new xt(d.inShape,"float32"),g=h.values,y=t.data.get(o.dataId).values,x=t.data.get(s.dataId).values,[T,k,w]=c,{batchSize:P,filterHeight:A,filterWidth:F,inChannels:E,inHeight:$,inWidth:W,outChannels:K,outHeight:B,outWidth:V,strideHeight:j,strideWidth:H}=d;f=d.dataFormat;let J=A-1-d.padInfo.top,X=F-1-d.padInfo.left,ne=f==="channelsLast",oe=h.strides[0],te=ne?h.strides[1]:h.strides[2],le=ne?h.strides[2]:1,ae=ne?1:h.strides[1],ge=m[0],fe=ne?m[1]:m[2],xe=ne?m[2]:1,Se=ne?1:m[1];for(let Be=0;Be<P;++Be)for(let Re=0;Re<E;++Re)for(let Oe=0;Oe<$;++Oe){let rt=Oe-J,gt=Math.max(0,Math.ceil(rt/j)),$t=Math.min(B,(A+rt)/j);for(let Bt=0;Bt<W;++Bt){let kt=Bt-X,Je=Math.max(0,Math.ceil(kt/H)),Ct=Math.min(V,(F+kt)/H),Ht=0;for(let gr=gt;gr<$t;++gr){let In=gr*j-rt;for(let zr=Je;zr<Ct;++zr){let Vs=zr*H-kt,rn=ge*Be+fe*gr+xe*zr,Pr=T*(A-1-In)+k*(F-1-Vs)+w*Re;for(let eo=0;eo<K;++eo){let br=y[rn+Se*eo],Cn=x[Pr+eo];Ht+=br*Cn}}}let On=oe*Be+te*Oe+le*Bt+ae*Re;g[On]=Ht}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var mR={kernelName:lo,backendName:"cpu",kernelFunc:A9};function N9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n;re([o,s],"conv3d");let l=I.computeConv3DInfo(o.shape,s.shape,a,u,i),{filterDepth:p,filterHeight:c,filterWidth:m,dilationDepth:f,dilationHeight:d,dilationWidth:h,padInfo:g}=l,y=g.front,x=g.left,T=g.top,k=new xt(l.outShape,o.dtype),w=t.data.get(o.dataId).values,P=t.data.get(s.dataId).values,A=k.values,F=b.computeStrides(o.shape),E=b.computeStrides(s.shape);for(let $=0;$<l.batchSize;++$){let W=$*F[0],K=$*k.strides[0];for(let B=0;B<l.outDepth;++B){let V=K+B*k.strides[1],j=B*l.strideDepth-y;for(let H=0;H<p;++H){let J=j+H*f;if(J<0||J>=l.inDepth)continue;let X=H*E[0],ne=W+J*F[1];for(let oe=0;oe<l.outHeight;++oe){let te=V+oe*k.strides[2],le=oe*l.strideHeight-T;for(let ae=0;ae<c;++ae){let ge=le+ae*d;if(ge<0||ge>=l.inHeight)continue;let fe=X+ae*E[1],xe=ne+ge*F[2];for(let Se=0;Se<l.outWidth;++Se){let Be=te+Se*l.outChannels,Re=Se*l.strideWidth-x;for(let Oe=0;Oe<m;++Oe){let rt=Re+Oe*h;if(rt<0||rt>=l.inWidth)continue;let gt=fe+Oe*E[2],$t=xe+rt*l.inChannels,Bt=gt;for(let kt=0;kt<l.inChannels;++kt){let Je=w[$t+kt];for(let Ct=0;Ct<l.outChannels;++Ct)A[Be+Ct]+=Je*P[Bt+Ct];Bt+=l.outChannels}}}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}var fR={kernelName:Pu,backendName:"cpu",kernelFunc:N9};function D9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:u}=n;re([o,s],"conv3dBackpropFilterV2");let l=b.computeStrides(o.shape),p=b.computeStrides(s.shape),c=I.computeConv3DInfo(o.shape,u,a,1,i),m=c.strideDepth,f=c.strideHeight,d=c.strideWidth,h=c.filterDepth,g=c.filterHeight,y=c.filterWidth,x=new xt(c.filterShape,"float32"),T=x.values,[k,w,P,A]=x.strides,F=t.data.get(s.dataId).values,[E,$,W,K]=p,B=t.data.get(o.dataId).values,[V,j,H,J]=l,X=c.padInfo.front,ne=c.padInfo.left,oe=c.padInfo.top;for(let te=0;te<h;++te){let le=Math.max(0,Math.ceil((X-te)/m)),ae=Math.min(c.outDepth,(c.inDepth+X-te)/m),ge=te*k;for(let fe=0;fe<g;++fe){let xe=Math.max(0,Math.ceil((oe-fe)/f)),Se=Math.min(c.outHeight,(c.inHeight+oe-fe)/f),Be=fe*w+ge;for(let Re=0;Re<y;++Re){let Oe=Math.max(0,Math.ceil((ne-Re)/d)),rt=Math.min(c.outWidth,(c.inWidth+ne-Re)/d),gt=Re*P+Be;for(let $t=0;$t<c.inChannels;++$t){let Bt=$t*A+gt;for(let kt=0;kt<c.outChannels;++kt){let Je=0;for(let Ct=0;Ct<c.batchSize;++Ct){let Ht=Ct*V,On=Ct*E;for(let gr=le;gr<ae;++gr){let zr=(te+gr*m-X)*j+Ht,Vs=gr*$+On;for(let rn=xe;rn<Se;++rn){let eo=(fe+rn*f-oe)*H+zr,br=rn*W+Vs;for(let Cn=Oe;Cn<rt;++Cn){let dl=(Re+Cn*d-ne)*J+eo,hl=Cn*K+br;Je+=B[dl+$t]*F[hl+kt]}}}}T[Bt+kt]=Je}}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}var dR={kernelName:Jp,backendName:"cpu",kernelFunc:D9};function P9(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:u}=n;re([o],"conv3dBackpropInputV2");let l=b.computeStrides(o.shape),p=b.computeStrides(s.shape),c=I.computeConv3DInfo(u,s.shape,i,1,a),m=new xt(c.inShape,"float32"),f=m.values,[d,h,g,y]=m.strides,x=t.data.get(o.dataId).values,[T,k,w,P]=l,A=t.data.get(s.dataId).values,[F,E,$,W]=p,{batchSize:K,filterDepth:B,filterHeight:V,filterWidth:j,inChannels:H,inDepth:J,inHeight:X,inWidth:ne,outChannels:oe,outDepth:te,outHeight:le,outWidth:ae,strideDepth:ge,strideHeight:fe,strideWidth:xe}=c,Se=B-1-c.padInfo.front,Be=V-1-c.padInfo.top,Re=j-1-c.padInfo.left;for(let Oe=0;Oe<K;++Oe)for(let rt=0;rt<H;++rt)for(let gt=0;gt<J;++gt){let $t=gt-Se,Bt=Math.max(0,Math.ceil($t/ge)),kt=Math.min(te,(B+$t)/ge);for(let Je=0;Je<X;++Je){let Ct=Je-Be,Ht=Math.max(0,Math.ceil(Ct/fe)),On=Math.min(le,(V+Ct)/fe);for(let gr=0;gr<ne;++gr){let In=gr-Re,zr=Math.max(0,Math.ceil(In/xe)),Vs=Math.min(ae,(j+In)/xe),rn=0;for(let Pr=Bt;Pr<kt;++Pr){let eo=Pr*ge-$t;for(let br=Ht;br<On;++br){let Cn=br*fe-Ct;for(let zn=zr;zn<Vs;++zn){let dl=zn*xe-In,hl=T*Oe+k*Pr+w*br+P*zn,js=F*(B-1-eo)+E*(V-1-Cn)+$*(j-1-dl)+W*rt;for(let fi=0;fi<oe;++fi){let Gm=x[hl+fi],Rp=A[js+fi];rn+=Gm*Rp}}}}f[d*Oe+h*gt+g*Je+y*gr+rt]=rn}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}var hR={kernelName:ec,backendName:"cpu",kernelFunc:P9};var F9=$e(po,r=>Math.cos(r)),gR={kernelName:po,backendName:"cpu",kernelFunc:F9};var M9=$e(co,r=>Math.cosh(r)),bR={kernelName:co,backendName:"cpu",kernelFunc:M9};function E9(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,[p,c,m,f]=o.shape,d=s.shape[0],[h,g]=i,y=Ce([d,h,g,f],"float32"),x=t.data.get(s.dataId).values,T=t.data.get(a.dataId).values,k=t.data.get(o.dataId).values,w=b.computeStrides(o.shape),P=b.computeStrides(y.shape);for(let A=0;A<d;A++){let F=A*4,E=x[F],$=x[F+1],W=x[F+2],K=x[F+3],B=T[A];if(B>=p)continue;let V=h>1?(W-E)*(c-1)/(h-1):0,j=g>1?(K-$)*(m-1)/(g-1):0;for(let H=0;H<h;H++){let J=h>1?E*(c-1)+H*V:.5*(E+W)*(c-1);if(J<0||J>c-1){for(let X=0;X<g;X++)for(let ne=0;ne<f;ne++){let oe=ne+X*P[2]+H*P[1]+A*P[0];y.values[oe]=l}continue}if(u==="bilinear"){let X=Math.floor(J),ne=Math.ceil(J),oe=J-X;for(let te=0;te<g;te++){let le=g>1?$*(m-1)+te*j:.5*($+K)*(m-1);if(le<0||le>m-1){for(let xe=0;xe<f;xe++){let Se=xe+te*P[2]+H*P[1]+A*P[0];y.values[Se]=l}continue}let ae=Math.floor(le),ge=Math.ceil(le),fe=le-ae;for(let xe=0;xe<f;xe++){let Se=xe+ae*w[2]+X*w[1]+B*w[0],Be=k[Se];Se=xe+ge*w[2]+X*w[1]+B*w[0];let Re=k[Se];Se=xe+ae*w[2]+ne*w[1]+B*w[0];let Oe=k[Se];Se=xe+ge*w[2]+ne*w[1]+B*w[0];let rt=k[Se],gt=Be+(Re-Be)*fe,$t=Oe+(rt-Oe)*fe;Se=xe+te*P[2]+H*P[1]+A*P[0],y.values[Se]=gt+($t-gt)*oe}}}else for(let X=0;X<g;++X){let ne=g>1?$*(m-1)+X*j:.5*($+K)*(m-1);if(ne<0||ne>m-1){for(let le=0;le<f;le++){let ae=le+X*P[2]+H*P[1]+A*P[0];y.values[ae]=l}continue}let oe=Math.round(ne),te=Math.round(J);for(let le=0;le<f;le++){let ae=le+oe*w[2]+te*w[1]+B*w[0],ge=le+X*P[2]+H*P[1]+A*P[0];y.values[ge]=k[ae]}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}var yR={kernelName:Ys,backendName:"cpu",kernelFunc:E9};function R9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;re(o,"cumsum");let u=I.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=lr({inputs:{x:o},backend:t,attrs:{perm:u}}));let p=I.getInnerMostAxes(1,o.shape.length)[0];if(p!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${p}`);let c=Ut(l.dtype,"int32"),m=b.makeZerosTypedArray(b.sizeFromShape(l.shape),c),f=t.data.get(l.dataId).values,d=l.shape[l.shape.length-1],h=i?(y,x)=>y+d-x-1:(y,x)=>y+x;for(let y=0;y<f.length;y+=d)for(let x=0;x<d;x++){let T=h(y,x);if(x===0)m[T]=a?0:f[T];else{let k=h(y,x-1);m[T]=a?f[k]+m[k]:f[T]+m[k]}}let g=t.makeTensorInfo(l.shape,c,m);if(u!=null){let y=I.getUndoAxesPermutation(u),x=lr({inputs:{x:g},backend:t,attrs:{perm:y}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),x}return g}var xR={kernelName:Xs,backendName:"cpu",kernelFunc:R9};function L9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=km(u,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=Ly(u,l,a,i);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var TR={kernelName:tc,backendName:"cpu",kernelFunc:L9};function $9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n;b.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);let i=o.shape[0],u=o.shape[1],l=o.shape[2],p=o.shape[3],c=u*s,m=l*s,f=p/(s*s),d=t.data.get(o.dataId).values,h=new Float32Array(i*c*m*f),g=0;for(let y=0;y<i;++y)for(let x=0;x<c;++x){let T=Math.floor(x/s),k=x%s;for(let w=0;w<m;++w){let P=Math.floor(w/s),A=w%s,F=(k*s+A)*f;for(let E=0;E<f;++E){let W=E+F+p*(P+l*(T+u*y));h[g++]=d[W]}}}return t.makeTensorInfo([i,c,m,f],o.dtype,h)}var kR={kernelName:Qs,backendName:"cpu",kernelFunc:$9};function Lw(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:l}=n;re([o,s],"depthwiseConv2DNative");let p=b.computeStrides(o.shape),c=b.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(a,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${m}'`);let f=I.computeConv2DInfo(o.shape,s.shape,a,m,i,l,!0),{filterHeight:d,filterWidth:h,dilationHeight:g,dilationWidth:y,padInfo:x}=f,T=x.left,k=x.top,w=f.outChannels/f.inChannels,P=new xt(f.outShape,o.dtype),A=t.data.get(o.dataId).values,F=t.data.get(s.dataId).values,E=P.values;for(let $=0;$<f.batchSize;++$){let W=$*p[0],K=$*P.strides[0];for(let B=0;B<f.outHeight;++B){let V=K+B*P.strides[1],j=B*f.strideHeight-k;for(let H=0;H<d;++H){let J=j+H*g;if(J<0||J>=f.inHeight)continue;let X=H*c[0],ne=W+J*p[1];for(let oe=0;oe<f.outWidth;++oe){let te=V+oe*P.strides[2],le=oe*f.strideWidth-T;for(let ae=0;ae<h;++ae){let ge=le+ae*y;if(ge<0||ge>=f.inWidth)continue;let fe=X+ae*c[1],xe=ne+ge*f.inChannels,Se=te,Be=fe;for(let Re=0;Re<f.inChannels;++Re){let Oe=A[xe+Re];for(let rt=0;rt<w;++rt)E[Se+rt]+=Oe*F[Be+rt];Se+=w,Be+=w}}}}}}return t.makeTensorInfo(P.shape,P.dtype,P.values)}var IR={kernelName:mo,backendName:"cpu",kernelFunc:Lw};function B9(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,filterShape:p}=n;re([o,s],"depthwiseConv2dNativeBackpropFilter");let c=I.computeConv2DInfo(o.shape,p,a,i,u,l,!0),{strideHeight:m,strideWidth:f,filterHeight:d,filterWidth:h}=c,g=new xt(c.filterShape,"float32"),y=c.padInfo.left,x=c.padInfo.top,T=c.outChannels/c.inChannels,k=t.data.get(o.dataId).values,w=new xt(o.shape,o.dtype,k),P=t.data.get(s.dataId).values,A=new xt(s.shape,s.dtype,P);for(let F=0;F<d;++F){let E=Math.max(0,Math.ceil((x-F)/m)),$=Math.min(c.outHeight,(c.inHeight+x-F)/m);for(let W=0;W<h;++W){let K=Math.max(0,Math.ceil((y-W)/f)),B=Math.min(c.outWidth,(c.inWidth+y-W)/f);for(let V=0;V<c.outChannels;++V){let j=Math.trunc(V/T),H=V%T,J=0;for(let X=0;X<c.batchSize;++X)for(let ne=E;ne<$;++ne){let oe=F+ne*m-x;for(let te=K;te<B;++te){let le=W+te*f-y;J+=w.get(X,oe,le,j)*A.get(X,ne,te,V)}}g.set(J,F,W,j,H)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var CR={kernelName:rc,backendName:"cpu",kernelFunc:B9};function O9(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,inputShape:p}=n;re([o,s],"depthwiseConv2DNativeBackpropInput");let c=b.computeStrides(o.shape),m=b.computeStrides(s.shape),f=I.computeConv2DInfo(p,s.shape,a,i,u,l,!0),d=new xt(f.inShape,"float32"),h=d.values,[g,y,x]=d.strides,T=t.data.get(o.dataId).values,[k,w,P]=c,A=t.data.get(s.dataId).values,[F,E,$]=m,{batchSize:W,filterHeight:K,filterWidth:B,inChannels:V,inHeight:j,inWidth:H,outChannels:J,outHeight:X,outWidth:ne,strideHeight:oe,strideWidth:te}=f,le=K-1-f.padInfo.top,ae=B-1-f.padInfo.left,ge=J/V;for(let fe=0;fe<W;++fe)for(let xe=0;xe<V;++xe)for(let Se=0;Se<j;++Se){let Be=Se-le,Re=Math.max(0,Math.ceil(Be/oe)),Oe=Math.min(X,(K+Be)/oe);for(let rt=0;rt<H;++rt){let gt=rt-ae,$t=Math.max(0,Math.ceil(gt/te)),Bt=Math.min(ne,(B+gt)/te),kt=0;for(let Je=Re;Je<Oe;++Je){let Ct=Je*oe-Be;for(let Ht=$t;Ht<Bt;++Ht){let On=Ht*te-gt,gr=k*fe+w*Je+P*Ht,In=F*(K-1-Ct)+E*(B-1-On)+$*xe;for(let zr=0;zr<ge;++zr){let Vs=xe*ge+zr,rn=T[gr+Vs],Pr=A[In+zr];kt+=rn*Pr}}}h[g*fe+y*Se+x*rt+xe]=kt}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}var vR={kernelName:nc,backendName:"cpu",kernelFunc:O9};function z9(r){let{inputs:e,backend:t}=r,{x:n}=e,o=b.sizeFromShape(n.shape),s=t.data.get(n.dataId).values,a=Ce([o,o],n.dtype),i=a.values;for(let l=0;l<s.length;l++)i[l*o+l]=s[l];let u=[...n.shape,...n.shape];return t.makeTensorInfo(u,a.dtype,a.values)}var wR={kernelName:oc,backendName:"cpu",kernelFunc:z9};var SR={kernelName:Fu,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o}=r,{strides:s,pad:a,dilations:i}=t,u=e,l=u.data.get(n.dataId).values,p=n.shape.length,c=u.data.get(o.dataId).values,m=o.shape.length,{batchSize:f,inHeight:d,inWidth:h,inChannels:g,outHeight:y,outWidth:x,padInfo:T,strideHeight:k,strideWidth:w,filterHeight:P,filterWidth:A,dilationHeight:F,dilationWidth:E,outShape:$}=I.computeDilation2DInfo(n.shape,o.shape,s,a,"NHWC",i),W=b.sizeFromShape($),K=$.length,B=b.getArrayFromDType(n.dtype,W);for(let j=0;j<f;++j)for(let H=0;H<y;++H){let J=H*k-T.top;for(let X=0;X<x;++X){let ne=X*w-T.left;for(let oe=0;oe<g;++oe){let te=Number.MIN_SAFE_INTEGER;for(let ae=0;ae<P;++ae){let ge=J+ae*F;if(ge>=0&&ge<d)for(let fe=0;fe<A;++fe){let xe=ne+fe*E;if(xe>=0&&xe<h){let Se=b.locToIndex([j,ge,xe,oe],p,b.computeStrides(n.shape)),Be=b.locToIndex([ae,fe,oe],m,b.computeStrides(o.shape)),Re=l[Se]+c[Be];Re>te&&(te=Re)}}}let le=b.locToIndex([j,H,X,oe],K,b.computeStrides($));B[le]=te}}}return{dataId:u.write(b.toTypedArray(B,n.dtype),$,n.dtype),shape:$,dtype:n.dtype}}};var _R={kernelName:of,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=t,l=e,p=b.toNestedArray(n.shape,l.data.get(n.dataId).values),c=b.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:x,strideHeight:T,strideWidth:k,filterHeight:w,filterWidth:P,dilationHeight:A,dilationWidth:F,outShape:E}=I.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);b.assert(s.rank===E.length,()=>`Error in ${of}, dy must have the same rank as output ${E.length}, but got ${s.rank}`);let $=b.toNestedArray(E,l.data.get(s.dataId).values),W=b.makeZerosNestedTypedArray(o.shape,o.dtype);for(let B=0;B<m;++B)for(let V=0;V<g;++V){let j=V*T-x.top;for(let H=0;H<y;++H){let J=H*k-x.left;for(let X=0;X<h;++X){let ne=Number.MIN_SAFE_INTEGER,oe=0,te=0;for(let le=0;le<w;++le){let ae=j+le*A;if(ae>=0&&ae<f)for(let ge=0;ge<P;++ge){let fe=J+ge*F;if(fe>=0&&fe<d){let xe=p[B][ae][fe][X]+c[le][ge][X];xe>ne&&(ne=xe,oe=le,te=ge)}}}W[oe][te][X]+=$[B][V][H][X]}}}return{dataId:l.write(b.toTypedArray(W,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var AR={kernelName:nf,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=t,l=e,p=b.toNestedArray(n.shape,l.data.get(n.dataId).values),c=b.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:f,inWidth:d,inChannels:h,outHeight:g,outWidth:y,padInfo:x,strideHeight:T,strideWidth:k,filterHeight:w,filterWidth:P,dilationHeight:A,dilationWidth:F,outShape:E}=I.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);b.assert(s.rank===E.length,()=>`Error in ${nf}, dy must have the same rank as output ${E.length}, but got ${s.rank}`);let $=b.toNestedArray(E,l.data.get(s.dataId).values),W=b.makeZerosNestedTypedArray(n.shape,n.dtype);for(let B=0;B<m;++B)for(let V=0;V<g;++V){let j=V*T-x.top;for(let H=0;H<y;++H){let J=H*k-x.left;for(let X=0;X<h;++X){let ne=Number.MIN_SAFE_INTEGER,oe=j<0?0:j,te=J<0?0:J;for(let le=0;le<w;++le){let ae=j+le*A;if(ae>=0&&ae<f)for(let ge=0;ge<P;++ge){let fe=J+ge*F;if(fe>=0&&fe<d){let xe=p[B][ae][fe][X]+c[le][ge][X];xe>ne&&(ne=xe,oe=ae,te=fe)}}}W[B][oe][te][X]+=$[B][V][H][X]}}}return{dataId:l.write(b.toTypedArray(W,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function pu(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;re(o,"sum");let i;o.dtype==="bool"?i=Gs({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):i=Xr({inputs:{x:o},backend:t});let u=i.shape.length,l=b.parseAxisParam(s,i.shape),p=I.getAxesPermutation(l,u),c=l,m=i;p!=null&&(m=lr({inputs:{x:i},backend:t,attrs:{perm:p}}),c=I.getInnerMostAxes(c.length,u)),I.assertAxesAreInnerMostDims("sum",c,m.shape.length);let[f,d]=I.computeOutAndReduceShapes(m.shape,c),h=I.upcastType(m.dtype,"int32"),g=xm(t,f,h),y=b.sizeFromShape(d),x=t.data.get(g.dataId).values,T=t.data.get(m.dataId).values;for(let k=0;k<x.length;++k){let w=k*y,P=0;for(let A=0;A<y;++A)P+=T[w+A];x[k]=P}if(a){let k=I.expandShapeToKeepDim(g.shape,l),w=g;g=ot({inputs:{x:g},backend:t,attrs:{shape:k}}),t.disposeIntermediateTensorInfo(w)}return t.disposeIntermediateTensorInfo(i),p!=null&&t.disposeIntermediateTensorInfo(m),g}var NR={kernelName:zo,backendName:"cpu",kernelFunc:pu};function G9(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=I.decodeEinsumEquation(o,s.length);I.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=I.getEinsumComputePath(i,u),c=p.length,m=null,f=a.length,d=[];for(let h=0;h<c;++h){for(let g of p[h]){let{permutationIndices:y,expandDims:x}=I.getEinsumPermutation(f,u[g]),T;I.isIdentityPermutation(y)?T=s[g]:(T=lr({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),d.push(T));let k=T.shape.slice();for(let w=0;w<x.length;++w)k.splice(x[w],0,1);b.arraysEqual(T.shape,k)||(T=ot({inputs:{x:T},backend:t,attrs:{shape:k}}),d.push(T)),m===null?m=T:(m=bp({inputs:{a:T,b:m},backend:t}),d.push(m))}h<c-1&&(l[h]>=0&&(m=pu({inputs:{x:m},backend:t,attrs:{axis:l[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var DR={kernelName:Mu,backendName:"cpu",kernelFunc:G9};function W9(r){let{inputs:e,backend:t}=r,{dy:n,y:o}=e;re([n,o],"eluGrad");let s=new Float32Array(b.sizeFromShape(o.shape)),a=t.data.get(o.dataId).values,i=t.data.get(n.dataId).values;for(let u=0;u<a.length;++u){let l=a[u];l>=1?s[u]=i[u]:s[u]=i[u]*(l+1)}return t.makeTensorInfo(o.shape,"float32",s)}var PR={kernelName:sc,backendName:"cpu",kernelFunc:W9};var U9=I.ERF_P,K9=I.ERF_A1,V9=I.ERF_A2,j9=I.ERF_A3,H9=I.ERF_A4,q9=I.ERF_A5,X9=$e(Si,r=>{let e=Math.sign(r),t=Math.abs(r),n=1/(1+U9*t);return e*(1-((((q9*n+H9)*n+j9)*n+V9)*n+K9)*n*Math.exp(-t*t))}),FR={kernelName:Si,backendName:"cpu",kernelFunc:X9};function _m(r){let{inputs:e,backend:t,attrs:n}=r,{input:o}=e,{dim:s}=n,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(b.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),ot({inputs:{x:o},backend:t,attrs:{shape:i}})}var MR={kernelName:ls,backendName:"cpu",kernelFunc:_m};var Y9=nt((r,e)=>r/e),Fh=it(fo,Y9),Mh={kernelName:fo,backendName:"cpu",kernelFunc:Fh};function Zy(r,e,t){let n=r.shape,o=n[0],s=n[1],a=t.data.get(r.dataId),i=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,l=[o,s],p=b.sizeFromShape(l),c=b.getTypedArrayFromDType("float32",p),m=b.getTypedArrayFromDType("float32",p);for(let g=0;g<o;g++){let y=Us({inputs:{x:i},backend:t,attrs:{begin:[g,0],size:[1,s]}}),x=Us({inputs:{x:u},backend:t,attrs:{begin:[g,0],size:[1,s]}}),T=vr({inputs:{real:y,imag:x},backend:t}),{real:k,imag:w}=Q9(T,e,t),P=I.mergeRealAndImagArrays(k,w);for(let A=0;A<s;A++){let F=I.getComplexWithIndex(P,A);c[g*s+A]=F.real,m[g*s+A]=F.imag}t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(T)}let f=t.makeTensorInfo(l,"float32",c),d=t.makeTensorInfo(l,"float32",m),h=vr({inputs:{real:f,imag:d},backend:t});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),h}function Q9(r,e,t){let n=b.sizeFromShape(r.shape),o=t.data.get(r.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,a=t.data.get(o.complexTensorInfos.imag.dataId).values;if(Z9(n)){let i=$w(s,a,n,e,t),u=[r.shape[0],r.shape[1]];if(e){let l=t.makeTensorInfo(u,"float32",i.real),p=t.makeTensorInfo(u,"float32",i.imag),c=t.makeTensorInfo([],"float32",b.createScalarValue(n,"float32")),m=Xr({inputs:{x:c},backend:t}),f=Mh.kernelFunc({inputs:{a:l,b:c},backend:t}),d=Mh.kernelFunc({inputs:{a:p,b:m},backend:t}),h=t.data.get(f.dataId).values,g=t.data.get(d.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),{real:h,imag:g}}return i}else{let i=I.mergeRealAndImagArrays(s,a),u=J9(i,n,e);return I.splitRealAndImagArrays(u)}}function Z9(r){return(r&r-1)==0}function $w(r,e,t,n,o){if(t===1)return{real:r,imag:e};let s=I.mergeRealAndImagArrays(r,e),a=t/2,i=I.complexWithEvenIndex(s),u=i.real,l=i.imag,p=[u.length],c=o.makeTensorInfo(p,"float32",u),m=o.makeTensorInfo(p,"float32",l),f=vr({inputs:{real:c,imag:m},backend:o}),d=I.complexWithOddIndex(s),h=d.real,g=d.imag,y=[h.length],x=o.makeTensorInfo(y,"float32",h),T=o.makeTensorInfo(y,"float32",g),k=vr({inputs:{real:x,imag:T},backend:o}),w=$w(u,l,a,n,o),P=w.real,A=w.imag,F=[P.length],E=o.makeTensorInfo(F,"float32",P),$=o.makeTensorInfo(F,"float32",A),W=vr({inputs:{real:E,imag:$},backend:o}),K=$w(h,g,a,n,o),B=K.real,V=K.imag,j=[B.length],H=o.makeTensorInfo(j,"float32",B),J=o.makeTensorInfo(j,"float32",V),X=vr({inputs:{real:H,imag:J},backend:o}),ne=I.exponents(t,n),oe=[ne.real.length],te=o.makeTensorInfo(oe,"float32",ne.real),le=o.makeTensorInfo(oe,"float32",ne.imag),ae=vr({inputs:{real:te,imag:le},backend:o}),ge=bp({inputs:{a:ae,b:X},backend:o}),fe=lu({inputs:{a:W,b:ge},backend:o}),xe=Dh({inputs:{a:W,b:ge},backend:o}),Se=zs({inputs:{input:fe},backend:o}),Be=zs({inputs:{input:xe},backend:o}),Re=ai({inputs:{input:fe},backend:o}),Oe=ai({inputs:{input:xe},backend:o}),rt=sl({inputs:[Se,Be],backend:o,attrs:{axis:0}}),gt=sl({inputs:[Re,Oe],backend:o,attrs:{axis:0}}),$t=o.data.get(rt.dataId).values,Bt=o.data.get(gt.dataId).values;return o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(f),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(E),o.disposeIntermediateTensorInfo($),o.disposeIntermediateTensorInfo(W),o.disposeIntermediateTensorInfo(H),o.disposeIntermediateTensorInfo(J),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(te),o.disposeIntermediateTensorInfo(le),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(ge),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(xe),o.disposeIntermediateTensorInfo(Se),o.disposeIntermediateTensorInfo(Re),o.disposeIntermediateTensorInfo(Be),o.disposeIntermediateTensorInfo(Oe),o.disposeIntermediateTensorInfo(rt),o.disposeIntermediateTensorInfo(gt),{real:$t,imag:Bt}}function J9(r,e,t){let n=new Float32Array(e*2);for(let o=0;o<e;o++){let s=0,a=0;for(let i=0;i<e;i++){let u=I.exponent(o*i,e,t),l=I.getComplexWithIndex(r,i);s+=l.real*u.real-l.imag*u.imag,a+=l.real*u.imag+l.imag*u.real}t&&(s/=e,a/=e),I.assignToTypedArray(n,s,a,o)}return n}function eee(r){let{inputs:e,backend:t}=r,{input:n}=e,o=b.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=ot({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),u=Zy(i,!1,t),l=ot({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var ER={kernelName:ac,backendName:"cpu",kernelFunc:eee};function Eh(r){let{backend:e,attrs:t}=r,{shape:n,value:o,dtype:s}=t,a=s||b.inferDtype(o),i=b.getArrayFromDType(a,b.sizeFromShape(n));return tee(i,o,a),e.makeTensorInfo(n,a,i)}var RR={kernelName:Ua,backendName:"cpu",kernelFunc:Eh};function tee(r,e,t){r.fill(e)}var LR={kernelName:ea,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,o=t,s=b.getTypedArrayFromDType(n.dtype,b.sizeFromShape(n.shape)),[a,i,u,l]=n.shape,p=o.data.get(n.dataId).values;for(let m=0;m<a;m++){let f=m*u*i*l;for(let d=0;d<i;d++){let h=d*(u*l);for(let g=0;g<u;g++){let y=g*l;for(let x=0;x<l;x++){let T=Math.round(u-g-1),k=f+h+y+x,w=p[k];if(T>=0&&T<u){let P=T*l,A=f+h+P+x;w=p[A]}s[k]=w}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var ree=nt((r,e)=>Math.floor(r/e)),nee=it(yo,ree,null,"int32"),$R={kernelName:yo,backendName:"cpu",kernelFunc:nee};function oee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=Rw({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m}});if(a){let g=h;h=lu({inputs:{a:h,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=wm(t,h,f,i,d),t.disposeIntermediateTensorInfo(g)}return h}var BR={kernelName:Cs,backendName:"cpu",kernelFunc:oee};function see(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=Lw({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m}});if(a){let g=h;h=lu({inputs:{a:h,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(f){let g=h;h=wm(t,h,f,i,d),t.disposeIntermediateTensorInfo(g)}return h}var OR={kernelName:vs,backendName:"cpu",kernelFunc:see};function aee(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=b.sizeFromShape(n.shape),a=o.shape,i=a[a.length-1],[u,l,p,c]=I.prepareAndValidate(n,o);if(l===0)return t.makeTensorInfo(u,n.dtype,[]);let m=t.data.get(o.dataId).values,f=t.bufferSync(n),d=$y(m,f,n.dtype,l,i,p,c,n.shape,s);return t.makeTensorInfo(u,n.dtype,d.values)}var zR={kernelName:ta,backendName:"cpu",kernelFunc:aee};function iee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n;re([o,s],"gatherV2");let u=b.parseAxisParam(a,o.shape)[0],l=t.data.get(s.dataId).values,p=o.shape[u];for(let k=0;k<l.length;++k){let w=l[k];b.assert(w<=p-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${p-1}]`)}let c=i;i==null&&(c=0);let m=b.sizeFromShape(s.shape),f=I.segment_util.collectGatherOpShapeInfo(o,s,u,c),d=ot({inputs:{x:o},backend:t,attrs:{shape:[f.batchSize,f.outerSize,f.dimSize,f.sliceSize]}}),h=ot({inputs:{x:s},backend:t,attrs:{shape:[f.batchSize,m/f.batchSize]}}),g=[f.batchSize,f.outerSize,m/f.batchSize,f.sliceSize],y=t.bufferSync(h),x=t.bufferSync(d),T=By(x,y,g);return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(f.outputShape,T.dtype,T.values)}var GR={kernelName:ps,backendName:"cpu",kernelFunc:iee};function uee(r){let{inputs:e,backend:t}=r,{input:n}=e,o=b.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=ot({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),u=Zy(i,!0,t),l=ot({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var WR={kernelName:ic,backendName:"cpu",kernelFunc:uee};var lee=$e(_i,r=>Number.isFinite(r)?1:0,"bool"),UR={kernelName:_i,backendName:"cpu",kernelFunc:lee};var pee=$e(Ai,r=>Math.abs(r)===1/0?1:0,"bool"),KR={kernelName:Ai,backendName:"cpu",kernelFunc:pee};var cee=$e(Ni,r=>Number.isNaN(r)?1:0,"bool"),VR={kernelName:Ni,backendName:"cpu",kernelFunc:cee};function mee(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=Oy(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var jR={kernelName:uc,backendName:"cpu",kernelFunc:mee};var fee=$e(Di,r=>Math.log1p(r)),HR={kernelName:Di,backendName:"cpu",kernelFunc:fee};var dee=nt((r,e)=>r&&e),hee=it(aa,dee,null,"bool"),qR={kernelName:aa,backendName:"cpu",kernelFunc:hee};var gee=$e(Pi,r=>r?0:1,"bool"),XR={kernelName:Pi,backendName:"cpu",kernelFunc:gee};var bee=nt((r,e)=>r||e),yee=it(Cl,bee,null,"bool"),YR={kernelName:Cl,backendName:"cpu",kernelFunc:yee};function xee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:u}=n;re(o,"LRN");let l=o.shape[3],p=l-1,c=t.data.get(o.dataId).values,m=b.sizeFromShape(o.shape),f=new Float32Array(m);function d(h){let g=h%l,y=h-g+Math.max(0,g-s),x=h-g+Math.min(g+s,p),T=0;for(;y<=x;y++){let k=c[y];T+=k*k}return T}for(let h=0;h<m;h++){let g=d(h),y=c[h]*Math.pow(a+i*g,-u);f[h]=y}return t.makeTensorInfo(o.shape,o.dtype,f)}var QR={kernelName:Ru,backendName:"cpu",kernelFunc:xee};function Tee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:u,alpha:l,beta:p}=n;re(a,"LRNGrad");let c=b.sizeFromShape(a.shape),m=a.shape[3],f=t.data.get(a.dataId).values,d=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(c),y=c;for(let x=0;x<y;x++){let T=x%m,k=x-T+Math.max(0,T-i),w=x-T+Math.min(m,T+i+1),P=0;for(let A=k;A<w;A++)P+=Math.pow(d[A],2);P=l*P+u;for(let A=k;A<w;A++){let F=-2*l*p*d[A]*h[x]/P;x===A&&(F+=Math.pow(P,-p)),F*=f[x],g[A]+=F}}return t.makeTensorInfo(a.shape,o.dtype,g)}var ZR={kernelName:lc,backendName:"cpu",kernelFunc:Tee};function Bw(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=t,u=o.shape,l=u.length,p=b.parseAxisParam(s,u),c=p,m=I.getAxesPermutation(c,l),f=i.data.get(o.dataId).values;if(m!=null){let k=new Array(l);for(let w=0;w<k.length;w++)k[w]=u[m[w]];f=Im(f,u,o.dtype,m,k),c=I.getInnerMostAxes(c.length,l),u=k}re(o,"max"),I.assertAxesAreInnerMostDims("max",c,l);let[d,h]=I.computeOutAndReduceShapes(u,c),g=b.sizeFromShape(h),y=zy(f,g,d,o.dtype),x=i.write(y,d,o.dtype),T=d;return a&&(T=I.expandShapeToKeepDim(d,p)),{dataId:x,shape:T,dtype:o.dtype}}var JR={kernelName:Io,backendName:"cpu",kernelFunc:Bw};function kee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;re(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,a,l,i,u),c;if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))c=Xr({inputs:{x:o},backend:t});else{let m=t.data.get(o.dataId).values,f=b.computeStrides(o.shape),d=Sm(m,o.shape,o.dtype,f,p,"max");c=t.makeTensorInfo(p.outShape,o.dtype,d.values)}return c}var eL={kernelName:vo,backendName:"cpu",kernelFunc:kee};function Iee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n;re(o,"maxPool3d");let p=I.computePool3DInfo(o.shape,s,a,1,i,u,l),c=t.data.get(o.dataId).values,m=Qy(c,o.shape,o.dtype,b.computeStrides(o.shape),p,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}var tL={kernelName:Lu,backendName:"cpu",kernelFunc:Iee};function Cee(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=n;re([o,s],"maxPool3DGrad");let p=I.computePool3DInfo(s.shape,a,i,1,u,l),c=t.bufferSync(s),m=QE(c,p),f=p.strideDepth,d=p.strideHeight,h=p.strideWidth,g=p.dilationDepth,y=p.dilationHeight,x=p.dilationWidth,T=p.effectiveFilterDepth,k=p.effectiveFilterHeight,w=p.effectiveFilterWidth,P=T-1-p.padInfo.front,A=w-1-p.padInfo.left,F=k-1-p.padInfo.top,E=Ce(s.shape,"float32"),$=t.bufferSync(o);for(let W=0;W<p.batchSize;++W)for(let K=0;K<p.inChannels;++K)for(let B=0;B<p.inDepth;++B)for(let V=0;V<p.inHeight;++V)for(let j=0;j<p.inWidth;++j){let H=B-P,J=V-F,X=j-A,ne=0;for(let oe=0;oe<T;oe+=g){let te=(H+oe)/f;if(!(te<0||te>=p.outDepth||Math.floor(te)!==te))for(let le=0;le<k;le+=y){let ae=(J+le)/d;if(!(ae<0||ae>=p.outHeight||Math.floor(ae)!==ae))for(let ge=0;ge<w;ge+=x){let fe=(X+ge)/h;if(fe<0||fe>=p.outWidth||Math.floor(fe)!==fe)continue;let xe=T*k*w-1-m.get(W,te,ae,fe,K),Se=oe*k*w+le*w+ge,Be=xe===Se?1:0;if(Be===0)continue;ne+=$.get(W,te,ae,fe,K)*Be}}}E.set(ne,W,B,V,j,K)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}var rL={kernelName:cc,backendName:"cpu",kernelFunc:Cee};function vee(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;re([s,a],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:c}=n,m=I.computePool2DInfo(i.shape,u,l,1,p,c),f=t.data.get(i.dataId).values,d=Ce(m.outShape,i.dtype,Yy(f,i.shape,i.dtype,m).values),h=m.strideHeight,g=m.strideWidth,y=m.dilationHeight,x=m.dilationWidth,T=m.effectiveFilterHeight,k=m.effectiveFilterWidth,w=k-1-m.padInfo.left,P=T-1-m.padInfo.top,A=Ce(i.shape,"float32"),F=t.data.get(o.dataId).values,E=Ce(o.shape,"float32",F);for(let $=0;$<m.batchSize;++$)for(let W=0;W<m.inChannels;++W)for(let K=0;K<m.inHeight;++K)for(let B=0;B<m.inWidth;++B){let V=K-P,j=B-w,H=0;for(let J=0;J<T;J+=y){let X=(V+J)/h;if(!(X<0||X>=m.outHeight||Math.floor(X)!==X))for(let ne=0;ne<k;ne+=x){let oe=(j+ne)/g;if(oe<0||oe>=m.outWidth||Math.floor(oe)!==oe)continue;let te=T*k-1-d.get($,X,oe,W),le=J*k+ne,ae=te===le?1:0;if(ae===0)continue;H+=E.get($,X,oe,W)*ae}}A.set(H,$,K,B,W)}return t.makeTensorInfo(A.shape,A.dtype,A.values)}var nL={kernelName:pc,backendName:"cpu",kernelFunc:vee};function oL(r,e,t,n,o){let s=b.computeStrides(e),a=Sm(r,e,t,s,o,"max"),i=Yy(r,e,t,o,!0,n);return[a.values,i.values]}var sL={kernelName:mc,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,u=t;re(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,p=I.computePool2DInfo(n.shape,o,s,[1,1],a),[c,m]=oL(l,n.shape,n.dtype,i,p),f=u.write(c,p.outShape,n.dtype),d=u.write(m,p.outShape,n.dtype);return[{dataId:f,shape:p.outShape,dtype:n.dtype},{dataId:d,shape:p.outShape,dtype:"int32"}]}};function wee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=b.parseAxisParam(s,o.shape),l=I.computeOutAndReduceShapes(o.shape,i)[1],p=b.sizeFromShape(l),c=[],m=t.makeTensorInfo([],"float32",new Float32Array([p]));c.push(m);let f=Gs({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});c.push(f);let d=Fh({inputs:{a:f,b:m},backend:t});c.push(d);let h=pu({inputs:{x:d},backend:t,attrs:{axis:s,keepDims:a}});return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var aL={kernelName:wo,backendName:"cpu",kernelFunc:wee};function See(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;re(o,"min");let i=b.parseAxisParam(s,o.shape),u=i,l=I.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),u=I.getInnerMostAxes(u.length,o.shape.length)),I.assertAxesAreInnerMostDims("min",u,p.shape.length);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),f=b.sizeFromShape(m),d=b.makeZerosTypedArray(b.sizeFromShape(c),p.dtype),h=t.data.get(p.dataId).values;for(let y=0;y<d.length;++y){let x=y*f,T=h[x];for(let k=0;k<f;++k){let w=h[x+k];(Number.isNaN(w)||w<T)&&(T=w)}d[y]=T}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(c,p.dtype,d);if(a){let y=I.expandShapeToKeepDim(c,i),x=ot({inputs:{x:g},backend:t,attrs:{shape:y}});return t.disposeIntermediateTensorInfo(g),x}return g}var iL={kernelName:So,backendName:"cpu",kernelFunc:See};function _ee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,mode:a}=n;re(o,"mirrorPad");let i=s.map((T,k)=>T[0]+o.shape[k]+T[1]),u=s.map(T=>T[0]),l=s.map((T,k)=>T[0]+o.shape[k]),p=a==="reflect"?0:1,c=t.data.get(o.dataId).values,m=o.shape.length,f=b.computeStrides(o.shape),d=b.sizeFromShape(i),h=i.length,g=b.computeStrides(i),y=b.getTypedArrayFromDType(o.dtype,d);for(let T=0;T<d;T++){let k=b.indexToLoc(T,h,g);for(let P=0;P<h;P++)k[P]<u[P]?k[P]=u[P]*2-k[P]-p:k[P]>=l[P]&&(k[P]=(l[P]-1)*2-k[P]+p);k=k.map((P,A)=>P-u[A]);let w=b.locToIndex(k,m,f);y[T]=c[w]}return{dataId:t.write(y,i,o.dtype),shape:i,dtype:o.dtype}}var uL={kernelName:Ao,backendName:"cpu",kernelFunc:_ee};var Aee=nt((r,e)=>{let t=r%e;return r<0&&e<0||r>=0&&e>=0?t:(t+e)%e}),Nee=it(Fi,Aee),lL={kernelName:Fi,backendName:"cpu",kernelFunc:Nee};var cL=Tl(Pf());function Ow(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=o.shape.length,i=s;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let u=b.parseAxisParam([i],o.shape),l=Bw({inputs:{x:o},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),p=I.expandShapeToKeepDim(l.shape,u),c=ot({inputs:{x:l},backend:t,attrs:{shape:p}}),m=Dh({inputs:{a:o,b:c},backend:t}),f=mw({inputs:{x:m},backend:t}),d=pu({inputs:{x:f},backend:t,attrs:{axis:u,keepDims:!1}}),h=ot({inputs:{x:d},backend:t,attrs:{shape:p}}),g=Fh({inputs:{a:f,b:h},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var pL={kernelName:Go,backendName:"cpu",kernelFunc:Ow};function Dee(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n;re(o,"multinomial");let u=i?o:Ow({inputs:{logits:o},backend:t,attrs:{dim:-1}}),l=u.shape[0],p=u.shape[1],c=t.data.get(u.dataId).values,m=[l,s],f=b.makeZerosTypedArray(b.sizeFromShape(m),"int32");for(let d=0;d<l;++d){let h=d*p,g=new Float32Array(p-1);g[0]=c[h];for(let T=1;T<g.length;++T)g[T]=g[T-1]+c[h+T];let y=cL.alea(a.toString()),x=d*s;for(let T=0;T<s;++T){let k=y();f[x+T]=g.length;for(let w=0;w<g.length;w++)if(k<g[w]){f[x+T]=w;break}}}return i||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(m,"int32",f)}var mL={kernelName:fc,backendName:"cpu",kernelFunc:Dee};var Pee=Tr.nonMaxSuppressionV3Impl;function Fee(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n;re(o,"NonMaxSuppression");let l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:c}=Pee(l,p,a,i,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}var fL={kernelName:ua,backendName:"cpu",kernelFunc:Fee};var Mee=Tr.nonMaxSuppressionV4Impl;function Eee(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n;re(o,"NonMaxSuppressionPadded");let p=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,{selectedIndices:m,validOutputs:f}=Mee(p,c,a,i,u,l);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var dL={kernelName:Mi,backendName:"cpu",kernelFunc:Eee};var Ree=Tr.nonMaxSuppressionV5Impl;function Lee(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n;re(o,"NonMaxSuppressionWithScore");let p=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,m=a,f=i,d=u,h=l,{selectedIndices:g,selectedScores:y}=Ree(p,c,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var hL={kernelName:la,backendName:"cpu",kernelFunc:Lee};function $ee(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:a,offValue:i}=n;re(o,"oneHot");let u=b.sizeFromShape(o.shape),l=new Float32Array(u*s);l.fill(i);let p=t.data.get(o.dataId).values;for(let c=0;c<u;++c)p[c]>=0&&p[c]<s&&(l[c*s+p[c]]=a);return t.makeTensorInfo([...o.shape,s],"int32",l)}var gL={kernelName:pa,backendName:"cpu",kernelFunc:$ee};function Rh(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=zs({inputs:{input:n},backend:t}),s=Rh({inputs:{x:o},backend:t}),a=ai({inputs:{input:n},backend:t}),i=Rh({inputs:{x:a},backend:t}),u=vr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Eh({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var bL={kernelName:Ts,backendName:"cpu",kernelFunc:Rh};function yL(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=zs({inputs:{input:n},backend:t}),s=yL({inputs:{x:o},backend:t}),a=ai({inputs:{input:n},backend:t}),i=Rh({inputs:{x:a},backend:t}),u=vr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Eh({backend:t,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var xL={kernelName:ms,backendName:"cpu",kernelFunc:yL};function zw(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return _m({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let c=_m({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(c),c}),l=sl({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var TL={kernelName:fs,backendName:"cpu",kernelFunc:zw};function Bee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;re(o,"pad");let i=s.map((x,T)=>x[0]+o.shape[T]+x[1]),u=s.map(x=>x[0]),l=t.data.get(o.dataId).values,p=b.sizeFromShape(o.shape),c=o.shape.length,m=b.computeStrides(o.shape),f=b.sizeFromShape(i),d=i.length,h=b.computeStrides(i),g=b.getTypedArrayFromDType(o.dtype,f);a!==0&&g.fill(a);for(let x=0;x<p;x++){let k=b.indexToLoc(x,c,m).map((P,A)=>P+u[A]),w=b.locToIndex(k,d,h);g[w]=l[x]}return{dataId:t.write(g,i,o.dtype),shape:i,dtype:o.dtype}}var Jy={kernelName:Do,backendName:"cpu",kernelFunc:Bee};var Oee=nt((r,e)=>Math.pow(r,e)),zee=it(Po,Oee),kL={kernelName:Po,backendName:"cpu",kernelFunc:zee};function Gee(r){let{backend:e,attrs:t}=r,{start:n,stop:o,dtype:s,step:a}=t,i=yp(n,o,a,s);return e.makeTensorInfo([i.length],s,i)}var IL={kernelName:Ka,backendName:"cpu",kernelFunc:Gee};var Wee=$e(Ei,r=>1/r),CL={kernelName:Ei,backendName:"cpu",kernelFunc:Wee};function Uee(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;re(o,"resizeBilinear");let u=b.computeStrides(o.shape),[l,p]=i,[c,m,f,d]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(b.sizeFromShape([c,l,p,d])),y=[s&&l>1?m-1:m,s&&p>1?f-1:f],x=[s&&l>1?l-1:l,s&&p>1?p-1:p],T=0,k=y[0]/x[0],w=y[1]/x[1];for(let P=0;P<c;P++)for(let A=0;A<l;A++){let F;a?F=k*(A+.5)-.5:F=k*A;let E=Math.max(0,Math.floor(F)),$=F-E,W=Math.min(m-1,Math.ceil(F)),K=P*u[0]+E*u[1],B=P*u[0]+W*u[1];for(let V=0;V<p;V++){let j;a?j=w*(V+.5)-.5:j=w*V;let H=Math.max(0,Math.floor(j)),J=j-H,X=Math.min(f-1,Math.ceil(j)),ne=K+H*u[2],oe=B+H*u[2],te=K+X*u[2],le=B+X*u[2];for(let ae=0;ae<d;ae++){let ge=h[ne+ae],fe=h[oe+ae],xe=h[te+ae],Se=h[le+ae],Be=ge+(xe-ge)*J,Re=fe+(Se-fe)*J,Oe=Be+(Re-Be)*$;g[T++]=Oe}}}return t.makeTensorInfo([c,l,p,d],"float32",g)}var vL={kernelName:Eo,backendName:"cpu",kernelFunc:Uee};function Kee(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;re([s,o],"resizeBilinearGrad");let i=b.computeStrides(o.shape),[u,l,p,c]=o.shape,[,m,f]=s.shape,d=new Float32Array(u*l*p*c),h=[a&&m>1?l-1:l,a&&f>1?p-1:p],g=[a&&m>1?m-1:m,a&&f>1?f-1:f],y=h[0]/g[0],x=h[1]/g[1],T=t.data.get(s.dataId).values,k=0;for(let w=0;w<u;w++){let P=w*i[0];for(let A=0;A<m;A++){let F=A*y,E=Math.floor(F),$=Math.min(Math.ceil(F),l-1),W=P+E*i[1],K=P+$*i[1],B=F-E,V=1-B;for(let j=0;j<f;j++){let H=j*x,J=Math.floor(H),X=Math.min(Math.ceil(H),p-1),ne=H-J,oe=1-ne,te=W+J*i[2],le=W+X*i[2],ae=K+J*i[2],ge=K+X*i[2],fe=V*oe,xe=V*ne,Se=B*oe,Be=B*ne;for(let Re=0;Re<c;Re++){let Oe=T[k++];d[te+Re]+=Oe*fe,d[le+Re]+=Oe*xe,d[ae+Re]+=Oe*Se,d[ge+Re]+=Oe*Be}}}}return t.makeTensorInfo([u,p,l,c],"float32",d)}var wL={kernelName:hc,backendName:"cpu",kernelFunc:Kee};function Vee(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;re(o,"resizeNearestNeighbor");let u=b.computeStrides(o.shape),[l,p]=i,[c,m,f,d]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(c*l*p*d),y=[s&&l>1?m-1:m,s&&p>1?f-1:f],x=[s&&l>1?l-1:l,s&&p>1?p-1:p],T=y[0]/x[0],k=y[1]/x[1],w=0;for(let P=0;P<c;P++){let A=P*u[0];for(let F=0;F<l;F++){let E=a?T*(F+.5):T*F,$=Math.min(m-1,s?Math.round(E):Math.floor(E));a&&($=Math.max(0,$));let W=A+$*u[1];for(let K=0;K<p;K++){let B=a?k*(K+.5):k*K,V=Math.min(f-1,s?Math.round(B):Math.floor(B));a&&(V=Math.max(0,V));let j=W+V*u[2];for(let H=0;H<d;H++){let J=h[j+H];g[w++]=J}}}}return t.makeTensorInfo([c,l,p,d],o.dtype,g)}var SL={kernelName:Va,backendName:"cpu",kernelFunc:Vee};function jee(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;re([s,o],"resizeNearestNeighborGrad");let i=b.computeStrides(o.shape),u=b.computeStrides(s.shape),[l,p,c,m]=o.shape,[,f,d]=s.shape,h=new Float32Array(l*p*c*m),g=t.data.get(s.dataId).values,y=[a&&f>1?p-1:p,a&&d>1?c-1:c],x=[a&&f>1?f-1:f,a&&d>1?d-1:d],T=y[0]/x[0],k=y[1]/x[1],w=1/T,P=1/k,A=Math.ceil(w)*2+2,F=Math.ceil(P)*2+2;for(let E=0;E<l;E++){let $=E*i[0];for(let W=0;W<p;W++){let K=$+W*i[1],B=Math.floor(W*w),V=Math.floor(B-A/2);for(let j=0;j<c;j++){let H=K+j*i[2],J=Math.floor(j*P),X=Math.floor(J-F/2);for(let ne=0;ne<m;ne++){let oe=0;for(let te=0;te<A;te++){let le=te+V;if(le<0||le>=f)continue;let ae=$+le*u[1],ge=le*T,fe=Math.min(p-1,a?Math.round(ge):Math.floor(ge));if(W===fe)for(let xe=0;xe<F;xe++){let Se=xe+X;if(Se<0||Se>=d)continue;let Be=ae+Se*u[2],Re=Se*k,Oe=Math.min(c-1,a?Math.round(Re):Math.floor(Re));j===Oe&&(oe+=g[Be+ne])}}h[H+ne]=oe}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var _L={kernelName:dc,backendName:"cpu",kernelFunc:jee};function Hee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n;re(o,"reverse");let a=o.shape.length,i=b.parseAxisParam(s,o.shape);if(a===0)return Xr({inputs:{x:o},backend:t});let u=new xt(o.shape,o.dtype),l=t.bufferSync(o);for(let p=0;p<u.size;p++){let c=u.indexToLoc(p),m=c.slice();i.forEach(f=>m[f]=o.shape[f]-1-m[f]),u.set(l.get(...m),...c)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}var AL={kernelName:ma,backendName:"cpu",kernelFunc:Hee};var NL={kernelName:xa,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=b.getTypedArrayFromDType(n.dtype,b.sizeFromShape(n.shape)),[l,p,c,m]=n.shape,[f,d]=I.getImageCenter(a,p,c),h=255,g=Math.sin(o),y=Math.cos(o),x=i.data.get(n.dataId).values;for(let k=0;k<l;k++){let w=k*c*p*m;for(let P=0;P<p;P++){let A=P*(c*m);for(let F=0;F<c;F++){let E=F*m;for(let $=0;$<m;$++){let W=[l,P,F,$],K=W[2],B=W[1],V=(K-f)*y-(B-d)*g,j=(K-f)*g+(B-d)*y;V=Math.round(V+f),j=Math.round(j+d);let H=s;if(typeof s!="number"&&($===3?H=h:H=s[$]),V>=0&&V<c&&j>=0&&j<p){let X=j*(c*m),ne=V*m,oe=w+X+ne+$;H=x[oe]}let J=w+A+E+$;u[J]=H}}}}return{dataId:i.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var qee=$e(fa,r=>{let e=Math.floor(r);return r-e<.5?Math.floor(r):r-e>.5?Math.ceil(r):e%2==0?e:e+1}),DL={kernelName:fa,backendName:"cpu",kernelFunc:qee};function ex(r,e,t,n,o,s,a,i,u,l){let p=[n/o,o],c=r.values,m=e.values;if(n===0)return Ce(t,e.dtype);let f=Ce(p,e.dtype);f.values.fill(u);for(let d=0;d<s;d++){let h=[],g=0;for(let y=0;y<a;y++){let x=c[d*a+y];h.push(x),g+=x*i[y]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let y=0;y<o;y++)l?f.values[g*o+y]+=m[d*o+y]:f.values[g*o+y]=e.rank===0?m[0]:m[d*o+y]}return f}function Xee(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:c}=I.calculateShapes(s,o,a),m=!0,f=t.bufferSync(o),d=t.bufferSync(s),h=ex(f,d,a,c,l,u,i,p,0,m);return t.makeTensorInfo(a,h.dtype,h.values)}var PL={kernelName:da,backendName:"cpu",kernelFunc:Xee};function Yee(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e;re([n,o,s],"select");let a=n.shape.length,i=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=Ut(o.dtype,s.dtype),c=b.makeZerosTypedArray(b.sizeFromShape(o.shape),p),m=0,f=a===0||a>1||o.shape.length===1?1:b.sizeFromShape(o.shape.slice(1));for(let d=0;d<i.length;d++)for(let h=0;h<f;h++)i[d]===1?c[m++]=u[d]:c[m++]=l[d];return t.makeTensorInfo(o.shape,p,c)}var FL={kernelName:hs,backendName:"cpu",kernelFunc:Yee};var Qee=I.SELU_SCALEALPHA,Zee=I.SELU_SCALE,Jee=$e(Ri,r=>r>=0?Zee*r:Qee*(Math.exp(r)-1)),ML={kernelName:Ri,backendName:"cpu",kernelFunc:Jee};var ete=$e(Li,r=>r<0?-1:r>0?1:0),EL={kernelName:Li,backendName:"cpu",kernelFunc:ete};var tte=$e($o,r=>Math.sin(r)),RL={kernelName:$o,backendName:"cpu",kernelFunc:tte};var rte=$e(ha,r=>Math.sinh(r)),LL={kernelName:ha,backendName:"cpu",kernelFunc:rte};var nte=11920928955078125e-23,$L=Math.log(nte)+2,ote=$e($i,r=>{let e=r>-$L,t=r<$L,n=Math.exp(r),o;return t?o=n:e?o=r:o=Math.log(1+n),o}),BL={kernelName:$i,backendName:"cpu",kernelFunc:ote};function ste(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;re([o],"spaceToBatchND");let i=b.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let P=1+s.length;P<o.shape.length;++P)u.push([0,0]);let l=Jy.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=I.getReshaped(l.shape,s,i,!1),c=I.getPermuted(p.length,s.length,!1),m=I.getReshapedPermuted(l.shape,s,i,!1),h=ot({inputs:{x:l},backend:t,attrs:{shape:p}}),x=lr({inputs:{x:h},backend:t,attrs:{perm:c}}),w=ot({inputs:{x},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(x),w}var OL={kernelName:bs,backendName:"cpu",kernelFunc:ste};function ate(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=t.data.get(a.dataId).values[0],[c,m,f,d,h]=Gy(i,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(m,n.dtype,c),t.makeTensorInfo([m[0]],o.dtype,f),t.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var zL={kernelName:gc,backendName:"cpu",kernelFunc:ate};function ite(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.data.get(o.dataId).values),i=t.data.get(n.dataId).values,u=Array.from(t.data.get(s.dataId).values),[l,p,c]=Wy(i,n.shape,n.dtype,a,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var GL={kernelName:bc,backendName:"cpu",kernelFunc:ite};function ute(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);let a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=Cm(a,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var WL={kernelName:yc,backendName:"cpu",kernelFunc:ute};function lte(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);let a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=Cm(a,n.shape,n.dtype,i,u);return t.makeTensorInfo(p,n.dtype,l)}var UL={kernelName:xc,backendName:"cpu",kernelFunc:lte};function pte(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:c,outputSize:m}=I.calculateShapes(s,o,i),f=!1,d=t.bufferSync(o),h=t.bufferSync(s),g=t.data.get(a.dataId).values[0],y=ex(d,h,i,m,p,l,u,c,g,f);return t.makeTensorInfo(i,y.dtype,y.values)}var KL={kernelName:Bu,backendName:"cpu",kernelFunc:pte};function cte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=b.parseAxisParam(a,o.shape)[0],u=I.prepareSplitSize(o,s,i),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(c=>{let m=[...p];m[i]=c;let f=Us({inputs:{x:o},backend:t,attrs:{begin:l,size:m}});return l[i]+=c,f})}var VL={kernelName:ys,backendName:"cpu",kernelFunc:cte};var jL={kernelName:ja,backendName:"cpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e;re(t,"square");let o=n.data.get(t.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){let u=o[i];s[i]=u*u}return{dataId:n.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};var mte=$e(ks,(r,e)=>{let t=e;return isNaN(r)?NaN:r>0?1:t.alpha}),HL={kernelName:ks,backendName:"cpu",kernelFunc:mte};function fte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n;re(o,"stridedSlice");let{nonStrided:f,$begin:d,$strides:h,size:g,newShape:y,outShape:x}=Xt.sliceInfo(o.shape,s,a,i,u,l,p,c,m),T=ot({inputs:{x:o},backend:t,attrs:{shape:y}}),k;if(f){let P=Us({inputs:{x:T},backend:t,attrs:{begin:d,size:g}});k=ot({inputs:{x:P},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(P)}else if(x.some(P=>P===0))k=t.makeTensorInfo(x,o.dtype,[]);else{let P=t.bufferSync(T),A=Uy(x,P,h,d);k=t.makeTensorInfo(A.shape,A.dtype,A.values)}let w=ot({inputs:{x:k},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(k),w}var qL={kernelName:ga,backendName:"cpu",kernelFunc:fte};function dte(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:c}=e,m=t.data.get(p.dataId).values,f=t.data.get(c.dataId).values,[d,h]=Ky(m,f,o,s,a,i,u,l);return[t.makeTensorInfo([d.length],"string",d),t.makeTensorInfo(c.shape,"int32",h)]}var XL={kernelName:Ou,backendName:"cpu",kernelFunc:dte};function hte(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values[0],[l,p,c]=Vy(i,u,o),m=p.length;return[t.makeTensorInfo([m,2],"int32",l),t.makeTensorInfo([m],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(c))]}var YL={kernelName:Tc,backendName:"cpu",kernelFunc:hte};function gte(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=t.data.get(s.dataId).values,i=jy(a,o);return t.makeTensorInfo(s.shape,"int32",i)}var QL={kernelName:kc,backendName:"cpu",kernelFunc:gte};var bte=$e(ba,r=>Math.tan(r)),ZL={kernelName:ba,backendName:"cpu",kernelFunc:bte};var yte=$e(Ko,r=>Math.tanh(r)),JL={kernelName:Ko,backendName:"cpu",kernelFunc:yte};function xte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;re(o,"tile");let a=Hy(t.bufferSync(o),s);return t.makeTensorInfo(a.shape,a.dtype,a.values)}var e$={kernelName:An,backendName:"cpu",kernelFunc:xte};function Tte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n;re(o,"topk");let i=t.data.get(o.dataId).values,[u,l]=qy(i,o.shape,o.dtype,s,a);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}var t$={kernelName:Bi,backendName:"cpu",kernelFunc:Tte};function kte(r){let{inputs:e,attrs:t,backend:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=t,[p,c,m,f]=o.shape,[d,h]=l??[c,m],g=[p,d,h,f],y=b.computeStrides(o.shape),x=y[0],T=y[1],k=y[2],w=b.getTypedArrayFromDType(o.dtype,b.sizeFromShape(g));w.fill(u);let P=n.data.get(o.dataId).values,A=n.data.get(s.dataId).values;for(let E=0;E<p;++E){let $=s.shape[0]===1?A:A.subarray(E*8,E*8+8);for(let W=0;W<d;++W)for(let K=0;K<h;++K)for(let B=0;B<f;++B){let V,j=$[6]*K+$[7]*W+1;if(j===0)continue;let H=($[0]*K+$[1]*W+$[2])/j,J=($[3]*K+$[4]*W+$[5])/j,X=n$(H,m,i),ne=n$(J,c,i);switch(a){case"nearest":V=Ste(P,c,m,x,T,k,E,ne,X,B,u);break;case"bilinear":V=_te(P,c,m,x,T,k,E,ne,X,B,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let oe=E*x+W*T+K*k+B;w[oe]=V}return n.makeTensorInfo(g,o.dtype,w)}return{dataId:n.write(w,g,o.dtype),shape:o.shape,dtype:o.dtype}}var r$={kernelName:ya,backendName:"cpu",kernelFunc:kte};function n$(r,e,t){switch(t){case"reflect":return Ite(r,e);case"wrap":return Cte(r,e);case"nearest":return wte(r,e);case"constant":default:return vte(r,e)}}function Ite(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{let n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return b.clamp(0,t,e-1)}function Cte(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{let n=e-1;t-=e*Math.trunc(t/n)}return b.clamp(0,t,e-1)}function vte(r,e){return r}function wte(r,e){return b.clamp(0,r,e-1)}function Lh(r,e,t,n,o,s,a,i,u,l,p){let c=a*n+i*o+u*s+l;return 0<=i&&i<e&&0<=u&&u<t?r[c]:p}function Ste(r,e,t,n,o,s,a,i,u,l,p){let c=Math.round(i),m=Math.round(u);return Lh(r,e,t,n,o,s,a,c,m,l,p)}function _te(r,e,t,n,o,s,a,i,u,l,p){let c=Math.floor(i),m=Math.floor(u),f=c+1,d=m+1,h=(d-u)*Lh(r,e,t,n,o,s,a,c,m,l,p)+(u-m)*Lh(r,e,t,n,o,s,a,c,d,l,p),g=(d-u)*Lh(r,e,t,n,o,s,a,f,m,l,p)+(u-m)*Lh(r,e,t,n,o,s,a,f,d,l,p);return(f-i)*h+(i-c)*g}function Ate(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;re(s,"unique");let a=n.data.get(s.dataId).values,{outputValues:i,outputShape:u,indices:l}=Xy(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}var o$={kernelName:Ic,backendName:"cpu",kernelFunc:Ate};function Nte(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape.length,i=o.shape[s],u=new Array(a-1),l=0;for(let f=0;f<a;f++)f!==s&&(u[l++]=o.shape[f]);let p=new Array(a).fill(0),c=o.shape.slice();c[s]=1;let m=new Array(i);for(let f=0;f<m.length;f++){p[s]=f;let d=Us({inputs:{x:o},backend:t,attrs:{begin:p,size:c}});m[f]=ot({inputs:{x:d},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(d)}return m}var s$={kernelName:xs,backendName:"cpu",kernelFunc:Nte};function Dte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n;re(o,"unsortedSegmentSum");let i=o.shape.length,u=s.shape.length,l=[],p=[],c=i-u,m=s;for(let d=0;d<c;++d){let h=_m({inputs:{input:m},backend:t,attrs:{dim:d+1}});m=h,p.push(h)}for(let d=0;d<a;++d){let h=b.createScalarValue(d,"int32"),g=t.makeTensorInfo([],"int32",h),y=pw({inputs:{a:g,b:m},backend:t}),x=Gs({inputs:{x:y},backend:t,attrs:{dtype:"float32"}}),T=bp({inputs:{a:x,b:o},backend:t}),k=pu({inputs:{x:T},backend:t,attrs:{axis:0,keepDims:!1}});l.push(k),p.push(g),p.push(y),p.push(x),p.push(T),p.push(k)}let f=zw({inputs:l,backend:t,attrs:{axis:0}});return p.forEach(d=>t.disposeIntermediateTensorInfo(d)),f}var a$={kernelName:zu,backendName:"cpu",kernelFunc:Dte};var Pte=[BE,ZM,OE,zE,nE,GE,WE,UE,KE,VE,jE,HE,qE,XE,YE,ZE,JE,eR,tR,$E,rR,nR,oR,sR,rE,oE,aR,JM,iR,lR,cR,mR,pR,dR,hR,fR,gR,bR,yR,xR,TR,kR,IR,CR,vR,wR,SR,AR,_R,Mh,DR,PE,PR,sE,FR,aE,MR,iE,ER,RR,LR,uE,$R,BR,OR,zR,GR,lE,pE,eE,WR,uR,UR,KR,VR,FE,cE,mE,jR,fE,HR,qR,XR,YR,QR,ZR,dE,eL,tL,rL,nL,sL,JR,aL,iL,hE,uL,lL,mL,gE,bE,fL,dL,hL,yE,gL,xL,TL,Jy,kL,ME,TE,IL,tE,CL,EE,RE,LE,vL,wL,SL,_L,AL,NL,DL,kE,PL,FL,ML,CE,EL,RL,LL,vE,pL,BL,OL,zL,GL,WL,UL,KL,VL,SE,jL,_E,HL,qL,XL,YL,QL,NE,NR,ZL,JL,e$,t$,xE,r$,o$,s$,a$,bL];for(let r of Pte)Oi(r);var f$={};Qe(f$,{assertNotComplex:()=>Ma,bindCanvasToFramebuffer:()=>Gte,bindColorTextureToFramebuffer:()=>zh,bindTextureToProgramUniformSampler:()=>tS,bindTextureUnit:()=>p$,bindVertexBufferToProgramAttribute:()=>tx,callAndCheck:()=>_e,canBeRepresented:()=>Uw,createFragmentShader:()=>Vw,createFramebuffer:()=>Zw,createProgram:()=>jw,createStaticIndexBuffer:()=>Xw,createStaticVertexBuffer:()=>qw,createTexture:()=>Yw,createVertexShader:()=>Kw,getBatchDim:()=>mu,getExtensionOrThrow:()=>Am,getFramebufferErrorMessage:()=>c$,getMaxTexturesInShader:()=>oS,getNumChannels:()=>Ote,getProgramUniformLocation:()=>eS,getProgramUniformLocationOrThrow:()=>Jw,getRowsCols:()=>fu,getShapeAs3D:()=>Gh,getTextureShapeFromLogicalShape:()=>rS,getWebGLDisjointQueryTimerVersion:()=>sS,getWebGLErrorMessage:()=>l$,getWebGLMaxTextureSize:()=>nS,hasExtension:()=>Zn,isCapableOfRenderingToFloatTexture:()=>aS,isDownloadFloatTextureEnabled:()=>iS,isReshapeFree:()=>il,isWebGLFenceEnabled:()=>lS,isWebGLVersionEnabled:()=>ax,linkProgram:()=>Hw,resetMaxTextureSize:()=>Wte,resetMaxTexturesInShader:()=>Ute,unbindColorTextureFromFramebuffer:()=>rx,unbindTextureUnit:()=>zte,validateFramebuffer:()=>Nm,validateProgram:()=>Oh,validateTextureSize:()=>Qw});var Tp={},Gw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function Ww(r,e){Tp[r]=e}function Jo(r){if(!(r in Tp)){let t=Mte(r);if(t!==null)Tp[r]=t;else return console.log("Could not get context for WebGL version",r),null}let e=Tp[r];return e.isContextLost()?(delete Tp[r],Jo(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Tp[r])}function Fte(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Mte(r){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=Fte(r);return e.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete Tp[r]},!1),r===1?e.getContext("webgl",Gw)||e.getContext("experimental-webgl",Gw):e.getContext("webgl2",Gw)}var al;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(al||(al={}));var Yr;(function(o){o[o.RENDER=0]="RENDER",o[o.UPLOAD=1]="UPLOAD",o[o.PIXELS=2]="PIXELS",o[o.DOWNLOAD=3]="DOWNLOAD"})(Yr||(Yr={}));var Or;(function(s){s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Or||(Or={}));function kp(r,e){return[e,r]}function i$(r,e){return r*e}function $h(r){let e=b.sizeFromShape(r),t=Math.ceil(e/4);return b.sizeToSquarishShape(t)}function ii(r,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(r/2))]}function u$(r,e){let[t,n]=ii(r,e);return t*n*4}function Bh(r,e){let t=r,n,o,s,a,i,u,l,p,c,m;return U().getNumber("WEBGL_VERSION")===2?(n=t.R32F,o=t.R16F,s=t.RGBA16F,a=t.RGBA32F,i=t.RED,l=4,p=1,c=t.HALF_FLOAT,m=t.FLOAT):(n=r.RGBA,o=r.RGBA,s=r.RGBA,a=t.RGBA,i=r.RGBA,l=4,p=4,c=e!=null?e.HALF_FLOAT_OES:null,m=r.FLOAT),u=r.RGBA,{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:p,textureTypeHalfFloat:c,textureTypeFloat:m}}function _e(r,e){let t=e();return U().getBool("DEBUG")&&Ete(r),t}function Ete(r){let e=r.getError();if(e!==r.NO_ERROR)throw new Error("WebGL Error: "+l$(r,e))}var Rte=596e-10,Lte=65504;function Uw(r){return!!(U().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||Rte<Math.abs(r)&&Math.abs(r)<Lte)}function l$(r,e){switch(e){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Am(r,e){return cu(r,()=>r.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Kw(r,e){let t=cu(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(_e(r,()=>r.shaderSource(t,e)),_e(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Vw(r,e){let t=cu(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(_e(r,()=>r.shaderSource(t,e)),_e(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw Bte(e,r.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var $te=/ERROR: [0-9]+:([0-9]+):/g;function Bte(r,e){let t=$te.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(r);return}let n=+t[1],o=r.split(`
`),s=o.length.toString().length+2,a=o.map((c,m)=>b.rightPad((m+1).toString(),s)+c),i=0;for(let c=0;c<a.length;c++)i=Math.max(a[c].length,i);let u=a.slice(0,n-1),l=a.slice(n-1,n),p=a.slice(n);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${b.rightPad(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join(`
`))}function jw(r){return cu(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function Hw(r,e){if(_e(r,()=>r.linkProgram(e)),r.getProgramParameter(e,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Oh(r,e){if(_e(r,()=>r.validateProgram(e)),r.getProgramParameter(e,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function qw(r,e){let t=cu(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return _e(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),_e(r,()=>r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function Xw(r,e){let t=cu(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return _e(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t)),_e(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function Ote(){return U().getNumber("WEBGL_VERSION")===2?1:4}function Yw(r){return cu(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function Qw(r,e){let t=U().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||e<=0){let n=`[${r}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>t||e>t){let n=`[${r}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function Zw(r){return cu(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function tx(r,e,t,n,o,s,a){let i=r.getAttribLocation(e,t);return i===-1?!1:(_e(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),_e(r,()=>r.vertexAttribPointer(i,o,r.FLOAT,!1,s,a)),_e(r,()=>r.enableVertexAttribArray(i)),!0)}function p$(r,e,t){m$(r,t),_e(r,()=>r.activeTexture(r.TEXTURE0+t)),_e(r,()=>r.bindTexture(r.TEXTURE_2D,e))}function zte(r,e){m$(r,e),_e(r,()=>r.activeTexture(r.TEXTURE0+e)),_e(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function Jw(r,e,t){return cu(r,()=>r.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function eS(r,e,t){return r.getUniformLocation(e,t)}function tS(r,e,t,n){_e(r,()=>p$(r,e,n)),_e(r,()=>r.uniform1i(t,n))}function Gte(r){_e(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),_e(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),_e(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function zh(r,e,t){_e(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),_e(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0))}function rx(r,e){_e(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),_e(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function Nm(r){let e=r.checkFramebufferStatus(r.FRAMEBUFFER);if(e!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+c$(r,e))}function c$(r,e){switch(e){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function cu(r,e,t){let n=_e(r,()=>e());if(n==null)throw new Error(t);return n}function m$(r,e){let t=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+r.TEXTURE0;if(n<r.TEXTURE0||n>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function mu(r,e=2){return b.sizeFromShape(r.slice(0,r.length-e))}function fu(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Gh(r){let e=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(e=[mu(r),...fu(r)]),e}function rS(r,e=!1){let t=U().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,r=r.map((o,s)=>s>=r.length-2?b.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=b.squeezeShape(r).newShape);let n=b.sizeFromShape(r);if(r.length<=1&&n<=t)return[1,n];if(r.length===2&&r[0]<=t&&r[1]<=t)return r;if(r.length===3&&r[0]*r[1]<=t&&r[2]<=t)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=t&&r[1]*r[2]<=t)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t)return[r[0],r[1]*r[2]*r[3]];if(e){let o=mu(r),s=2,a=2;return r.length&&([s,a]=fu(r)),n=o*(s/2)*(a/2),b.sizeToSquarishShape(n).map(i=>i*2)}return b.sizeToSquarishShape(n)}function nx(r){return r%2==0}function il(r,e){if(r=r.slice(-2),e=e.slice(-2),b.arraysEqual(r,e)||!r.length||!e.length||r[0]===0||r[1]===0||e[0]===0||e[1]===0)return!0;if(r.length!==e.length){let t=r.slice(-1)[0],n=e.slice(-1)[0];if(t===n||nx(t)&&nx(n)&&(r[0]===1||e[0]===1))return!0}return r[1]===e[1]&&nx(r[0])&&nx(e[0])}var ox,sx;function nS(r){if(ox==null){let e=Jo(r);ox=e.getParameter(e.MAX_TEXTURE_SIZE)}return ox}function Wte(){ox=null}function Ute(){sx=null}function oS(r){if(sx==null){let e=Jo(r);sx=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,sx)}function sS(r){if(r===0)return 0;let e,t=Jo(r);return Zn(t,"EXT_disjoint_timer_query_webgl2")&&r===2?e=2:Zn(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Zn(r,e){return r.getExtension(e)!=null}function ax(r){try{if(Jo(r)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function aS(r){if(r===0)return!1;let e=Jo(r);if(r===1){if(!Zn(e,"OES_texture_float"))return!1}else if(!Zn(e,"EXT_color_buffer_float"))return!1;return uS(e)}function iS(r){if(r===0)return!1;let e=Jo(r);if(r===1){if(!Zn(e,"OES_texture_float")||!Zn(e,"WEBGL_color_buffer_float"))return!1}else{if(Zn(e,"EXT_color_buffer_float"))return uS(e);let n="EXT_color_buffer_half_float";if(Zn(e,n)){let o=e.getExtension(n);return Kte(e,o)}return!1}return uS(e)}function uS(r){let e=Bh(r),t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatFloat,n,o,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(t),r.deleteFramebuffer(s),a}function Kte(r,e){let t=Bh(r,e),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatHalfFloat,o,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(a),i}function lS(r){return r!==2?!1:Jo(r).fenceSync!=null}function Ma(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&b.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var ze=U();ze.registerFlag("HAS_WEBGL",()=>ze.getNumber("WEBGL_VERSION")>0);ze.registerFlag("WEBGL_VERSION",()=>ax(2)?2:ax(1)?1:0);ze.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);ze.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>ze.get("WEBGL_VERSION")===2);ze.registerFlag("WEBGL_CPU_FORWARD",()=>!0);ze.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);ze.registerFlag("WEBGL_PACK",()=>ze.getBool("HAS_WEBGL"));ze.registerFlag("WEBGL_PACK_NORMALIZATION",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_CLIP",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_PACK_REDUCE",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_LAZILY_UNPACK",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_CONV_IM2COL",()=>ze.getBool("WEBGL_PACK"));ze.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>nS(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>oS(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=ze.getNumber("WEBGL_VERSION");return r===0?0:sS(r)});ze.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>ze.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Gi.isMobile());ze.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>aS(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>ze.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:ze.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));ze.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>iS(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_FENCE_API_ENABLED",()=>lS(ze.getNumber("WEBGL_VERSION")));ze.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>ze.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);ze.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});ze.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Gi.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});ze.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);ze.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);ze.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);ze.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function Zt(){let r,e,t,n,o,s,a,i,u,l;return U().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",e="in",t="out",n="in",o="texture",s="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",e="attribute",t="varying",n="varying",o="texture2D",s="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:e,varyingVs:t,varyingFs:n,texture2D:o,output:s,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function Ea(r,e,t="index"){let n=b.computeStrides(e);return n.map((o,s)=>{let a=`int ${r[s]} = ${t} / ${o}`,i=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${a}; ${i};`}).join("")}function Ip(r,e,t="index"){let n=b.computeStrides(e);return n.map((o,s)=>{let a=`int ${r[s]} = ${t} / outShapeStrides[${s}]`,i=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${a}; ${i};`}).join("")}function Vte(r,e){let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function d$(r,e,t="index"){let n=r.map((s,a)=>a),o=Vte(n,e);return o.map((s,a)=>{let i=`int ${r[a]} = ${t} / ${o[a]}`,u=a===o.length-1?`int ${r[a+1]} = ${t} - ${r[a]} * ${o[a]}`:`index -= ${r[a]} * ${o[a]}`;return`${i}; ${u};`}).join("")}function Dm(r){let e=b.computeStrides(r).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Pm(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var ix=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:h$}=I;function g$(r,e,t){let n=[];if(r.forEach(f=>{let d=b.sizeFromShape(f.shapeInfo.logicalShape);if(f.shapeInfo.isUniform?n.push(`uniform float ${f.name}${d>1?`[${d}]`:""};`):(n.push(`uniform sampler2D ${f.name};`),n.push(`uniform int offset${f.name};`)),t.enableShapeUniforms){let{uniformShape:h}=ux(t.packedInputs,f.shapeInfo.logicalShape,f.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${f.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${f.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${f.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${f.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${f.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(f=>{n.push(`uniform ${f.type} ${f.name}${f.arrayIndex?`[${f.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(f=>jte(f,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,i=Zt(),u=Xte(i),l,p,c=Zte(i);return e.isPacked?(l=Hte(e.logicalShape,a,t.enableShapeUniforms),p=Qte(i)):(l=qte(e.logicalShape,a,t.enableShapeUniforms),p=Yte(i)),t.packedInputs&&(c+=rre),[c,u,p,o,l,s,t.userCode].join(`
`)}function Fm(r,e=!1){let t=r.shapeInfo.logicalShape;switch(t.length){case 0:return dre(r,e);case 1:return gre(r,e);case 2:return yre(r,e);case 3:return Tre(r,e);case 4:return Ire(r,e);case 5:return Cre(r);case 6:return vre(r);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function b$(r,e){switch(r.shapeInfo.logicalShape.length){case 0:return fre(r);case 1:return hre(r,e);case 2:return bre(r,e);case 3:return xre(r,e);default:return kre(r,e)}}function jte(r,e,t=!1,n){let o="";t?o+=b$(r,n):o+=Fm(r,n);let s=r.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(t?o+=wre(r,e):o+=Sre(r,e)),o}function Hte(r,e,t){switch(r.length){case 0:return y$();case 1:return nre(r,e,t);case 2:return cre(r,e,t);case 3:return sre(r,e,t);default:return ire(r,e,t)}}function qte(r,e,t){switch(r.length){case 0:return y$();case 1:return ore(r,e,t);case 2:return mre(r,e,t);case 3:return are(r,e,t);case 4:return ure(r,e,t);case 5:return lre(r,e);case 6:return pre(r,e);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function Xte(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function Yte(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function Qte(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function Zte(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Jte}
    ${ere}
    ${tre}
  `}var Jte=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,ere=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,tre=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,rre=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function y$(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function nre(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function ore(r,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function sre(r,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function are(r,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Ip(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=Ea(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function ire(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),a=s,i="",u="b, r, c";for(let l=2;l<r.length-1;l++)a*=r[r.length-l-1],i=`
      int b${l} = index / ${a};
      index -= b${l} * ${a};
    `+i,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${i}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function ure(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Ip(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=Ea(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function lre(r,e){let t=Ea(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function pre(r,e){let t=Ea(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function cre(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(b.arraysEqual(r,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function mre(r,e,t){return b.arraysEqual(r,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:r[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Cp(r){return`offset${r}`}function fre(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=Zt();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function dre(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Cp(t);if(e)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;let[i,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function hre(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape,s=Zt();if(e)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function gre(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${Mm(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],a=o[1];if(a===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Cp(t);return a===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function bre(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=s[0],i=s[1],u=Zt();if(s!=null&&b.arraysEqual(t,s))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function yre(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&b.arraysEqual(t,s)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],f=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${f}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:a,keptDims:i}=b.squeezeShape(t),u=a;if(u.length<t.length){let m=Em(r,u),f=["row","col"];return`
      ${Fm(m,e)}
      float ${o}(int row, int col) {
        return ${o}(${Rm(f,i)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Mm(r)}
      }
    `;let l=s[0],p=s[1],c=Cp(n);return p===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${c};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${c};
    vec2 uv = uvFromFlat(${l}, ${p}, index);
    return sampleTexture(${n}, uv);
  }
`}function xre(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let m=t.slice(1),f=[1,2],d=Em(r,m),h=["b","row","col"];return`
        ${b$(d,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Rm(h,f)});
        }
      `}let i=Zt();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `;let u=a[0],l=a[1],p=Math.ceil(t[2]/2),c=p*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${c}, ${p}, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `}function Tre(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],a=t[2],{newShape:i,keptDims:u}=b.squeezeShape(t),l=i;if(l.length<t.length){let h=Em(r,l),g=["row","col","depth"];return`
        ${Fm(h,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Rm(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${Mm(r)}
      }
    `;let p=r.shapeInfo.texShape,c=p[0],m=p[1],f=r.shapeInfo.flatOffset;if(m===s&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${c}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===a&&f==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${c}.0);
      return sampleTexture(${n}, uv);
    }
  `;let d=Cp(n);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${a} + depth + ${d};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${d};
        vec2 uv = uvFromFlat(${c}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function kre(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=Zt();if(e)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,a=s.length,i=r.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],p=u[1],c=Math.ceil(s[a-1]/2),m=c*Math.ceil(s[a-2]/2),f="int b, int row, int col",d=`b * ${m} + (row / 2) * ${c} + (col / 2)`;for(let h=2;h<a-1;h++)f=`int b${h}, `+f,m*=s[a-h-1],d=`b${h} * ${m} + `+d;return`
    vec4 ${n}(${f}) {
      int index = ${d};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});
      return ${o.texture2D}(${t}, uv);
    }
  `}function Ire(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],a=t[2]*s,i=t[1]*a,{newShape:u,keptDims:l}=b.squeezeShape(t);if(u.length<t.length){let x=Em(r,u),T=["row","col","depth","depth2"];return`
      ${Fm(x,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Rm(T,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${s}, 1)));
        ${Mm(r)}
      }
    `;let p=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,m=c[0],f=c[1],d=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(f===i&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${d}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(f===s&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let y=Cp(n);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${d}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${y});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${f}, index + ${y});
      return sampleTexture(${n}, uv);
    }
  `}function Cre(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,a=e[2]*s,i=e[1]*a,{newShape:u,keptDims:l}=b.squeezeShape(e);if(u.length<e.length){let h=Em(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${Fm(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Rm(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${s}, ${o})) +
          depth3;
        ${Mm(r)}
      }
    `;let p=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,m=c[0],f=c[1];if(f===i&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;let d=Cp(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${s} +
          depth2 * ${o} + depth3 + ${d};
      vec2 uv = uvFromFlat(${m}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function vre(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=b.squeezeShape(e);if(o.length<e.length){let g=Em(r,o),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Fm(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Rm(y,s)});
      }
    `}let a=e[5],i=e[4]*a,u=e[3]*i,l=e[2]*u,p=e[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${l}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Mm(r)}
      }
    `;let c=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,f=m[0],d=m[1];if(d===p&&c==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===a&&c==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${f}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Cp(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${l} + depth * ${u} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${h};
      vec2 uv = uvFromFlat(${f}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Mm(r){let e=r.name,t=b.sizeFromShape(r.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function wre(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=h$(r.shapeInfo.logicalShape,e.logicalShape),u=He(a),l=a-s,p,c=["x","y","z","w","u","v"];s===0?p="":a<2&&i.length>=1?p="coords = 0;":p=i.map(x=>`coords.${c[x+l]} = 0;`).join(`
`);let m="";a<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((x,T)=>`coords.${c[T+l]}`).join(", ");let f="return outputValue;",h=b.sizeFromShape(r.shapeInfo.logicalShape)===1,y=b.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!y)f=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!y)a===1?f=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:f=`
        return vec4(outputValue.x);
      `;else if(i.length){let x=s-2,T=s-1;i.indexOf(x)>-1&&i.indexOf(T)>-1?f="return vec4(outputValue.x);":i.indexOf(x)>-1?f="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(T)>-1&&(f="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${p}
      vec4 outputValue = get${n}(${m});
      ${f}
    }
  `}function Sre(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=e.texShape,a=r.shapeInfo.texShape,i=r.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!r.shapeInfo.isUniform&&i===u&&r.shapeInfo.flatOffset==null&&b.arraysEqual(a,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let l=He(u),p=h$(r.shapeInfo.logicalShape,e.logicalShape),c=u-i,m,f=["x","y","z","w","u","v"];i===0?m="":u<2&&p.length>=1?m="coords = 0;":m=p.map(h=>`coords.${f[h+c]} = 0;`).join(`
`);let d="";return u<2&&i>0?d="coords":d=r.shapeInfo.logicalShape.map((h,g)=>`coords.${f[g+c]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${d});
    }
  `}function He(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function ux(r,e,t){let{newShape:n,keptDims:o}=b.squeezeShape(e),s=e.length,a=r&&s===3&&e[0]===1,i=a?e.slice(1):n,u=!r&&s>1&&!b.arraysEqual(e,t)&&n.length<s||a;return{useSqueezeShape:u,uniformShape:u?i:e,keptDims:o}}function Em(r,e){let t=JSON.parse(JSON.stringify(r));return t.shapeInfo.logicalShape=e,t}function Rm(r,e){return e.map(t=>r[t]).join(", ")}function x$(r,e,t,n){let o=t.map((T,k)=>{let w={logicalShape:T.shape,texShape:T.isUniform?null:T.texData.texShape,isUniform:T.isUniform,isPacked:T.isUniform?!1:T.texData.isPacked,flatOffset:null};return T.texData!=null&&T.texData.slice!=null&&T.texData.slice.flatOffset>0&&(w.flatOffset=T.texData.slice.flatOffset),{name:e.variableNames[k],shapeInfo:w}}),s=o.map(T=>T.shapeInfo),a={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},i=g$(o,a,e),u=r.createProgram(i),l=null,p=r.getUniformLocation(u,"NAN",!1);U().getNumber("WEBGL_VERSION")===1&&(l=r.getUniformLocation(u,"INFINITY",!1));let c=!1,m={},f={},d={};for(let T=0;T<e.variableNames.length;T++){let k=e.variableNames[T];m[k]=r.getUniformLocation(u,k,c),m[`offset${k}`]=r.getUniformLocation(u,`offset${k}`,c),e.enableShapeUniforms&&(f[`${k}Shape`]=r.getUniformLocation(u,`${k}Shape`,c),d[`${k}TexShape`]=r.getUniformLocation(u,`${k}TexShape`,c))}let h,g,y;e.enableShapeUniforms&&(h=r.getUniformLocation(u,"outShape",c),y=r.getUniformLocation(u,"outShapeStrides",c),g=r.getUniformLocation(u,"outTexShape",c));let x=[];return e.customUniforms&&e.customUniforms.forEach((T,k)=>{x[k]=r.getUniformLocation(u,T.name,c)}),{program:e,source:i,webGLProgram:u,uniformLocations:m,customUniformLocations:x,inShapeInfos:s,outShapeInfo:a,infLoc:l,nanLoc:p,inShapesLocations:f,inTexShapesLocations:d,outShapeLocation:h,outShapeStridesLocation:y,outTexShapeLocation:g}}function T$(r,e){if(r.length!==e.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${e.length} inputs`);r.forEach((t,n)=>{let o=t.logicalShape,s=e[n],a=s.shape;if(!b.arraysEqual(o,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${a} must match`);if(t.isUniform&&s.isUniform)return;let i=t.texShape,u=s.isUniform?null:s.texData.texShape;if(!b.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function k$(r,e,t,n,o){e.program.enableShapeUniforms||(T$(e.inShapeInfos,t),T$([e.outShapeInfo],[n]));let s=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s,a[0],a[1]):r.setOutputMatrixTexture(s,a[0],a[1]),r.setProgram(e.webGLProgram),U().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&r.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&r.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,l)=>{let p=e.program.variableNames[l],c=e.uniformLocations[p],m=e.uniformLocations[`offset${p}`],f=e.inShapesLocations[`${p}Shape`],d=e.inTexShapesLocations[`${p}TexShape`];if(f){let{uniformShape:h}=ux(e.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(f,new Int32Array(h));break;case 2:r.gl.uniform2iv(f,new Int32Array(h));break;case 3:r.gl.uniform3iv(f,new Int32Array(h));break;case 4:r.gl.uniform4iv(f,new Int32Array(h));break;default:break}}if(d&&r.gl.uniform2i(d,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(b.sizeFromShape(u.shape)<2)r.gl.uniform1f(c,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(c,h)}return}u.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture,c,l)}});let i=e.outShapeLocation;if(i)switch(n.shape.length){case 1:r.gl.uniform1iv(i,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(i,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(i,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(i,new Int32Array(n.shape));break;default:break}if(e.outShapeStridesLocation){let u=b.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break;default:break}}e.outTexShapeLocation&&r.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&o&&e.program.customUniforms.forEach((u,l)=>{let p=e.customUniformLocations[l],c=o[l];if(u.type==="float")r.gl.uniform1fv(p,c);else if(u.type==="vec2")r.gl.uniform2fv(p,c);else if(u.type==="vec3")r.gl.uniform3fv(p,c);else if(u.type==="vec4")r.gl.uniform4fv(p,c);else if(u.type==="int")r.gl.uniform1iv(p,c);else if(u.type==="ivec2")r.gl.uniform2iv(p,c);else if(u.type==="ivec3")r.gl.uniform3iv(p,c);else if(u.type==="ivec4")r.gl.uniform4iv(p,c);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function I$(r,e,t){let n="";e.concat(t).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!a.isUniform){let u=a.texData.texShape,{useSqueezeShape:l,uniformShape:p,keptDims:c}=ux(r.packedInputs,a.shape,u),m="",f="",d="";if(p.length===1&&r.packedInputs){let w=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${w[0]>1}_${w[1]>1}`}else if(p.length===2&&!r.packedInputs)f=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!r.packedInputs){let w=b.computeStrides(p);d=`${w[0]===u[1]}_${w[w.length-1]===u[1]}`}let h=a.shape.length,g=p.length===2&&b.arraysEqual(a.shape,u),y=b.sizeFromShape(a.shape)===1,x=I.getBroadcastDims(a.shape,t.shape),T=!r.packedInputs&&h===t.shape.length&&b.arraysEqual(u,t.texData.texShape),k=r.packedInputs||p.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${T}_${l?c:""}_${p.length}_${y}_${x}_${g}_${m}_${f}_${d}_${k}_${i}`}else{let u=a.isUniform?"uniform":a.texData.texShape;n+=`${a.shape}_${u}_${i}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${U().getNumber("WEBGL_VERSION")}`,s}function tr(r){return U().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var pS=class{constructor(e){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.outPackingScheme=al.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Zt();this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ip(["r","c","d"],e):Ea(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var cS=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outPackingScheme=al.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Zt();this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Ip(["r","c","d"],e):Ea(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var mS=class{constructor(e){this.variableNames=["A"];this.outTexUsage=Yr.DOWNLOAD;let t=Zt();this.outputShape=e,this.userCode=`
      ${ix}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var fS=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outTexUsage=Yr.DOWNLOAD;let t=Zt();this.outputShape=e,this.userCode=`
      ${ix}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var dS=class{constructor(e,t=!1){this.variableNames=["A"];this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Zt();this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Pm():Dm(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var hS=class{constructor(e,t=!1){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Zt();this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let u=a*2+i;o+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Pm():Dm(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var C$={};Qe(C$,{bindVertexProgramAttributeStreams:()=>vS,createBufferFromOutputTexture:()=>_S,createFloat16MatrixTexture:()=>TS,createFloat16PackedMatrixTexture:()=>CS,createFloat32MatrixTexture:()=>xS,createIndexBuffer:()=>yS,createPackedMatrixTexture:()=>IS,createUnsignedBytesMatrixTexture:()=>kS,createVertexBuffer:()=>bS,createVertexShader:()=>gS,downloadByteEncodedFloatMatrixFromOutputTexture:()=>NS,downloadFloat32MatrixFromBuffer:()=>AS,downloadMatrixFromPackedOutputTexture:()=>PS,downloadPackedMatrixFromBuffer:()=>DS,getInternalFormatForFloat16MatrixTexture:()=>px,getInternalFormatForFloat16PackedMatrixTexture:()=>fx,getInternalFormatForFloat32MatrixTexture:()=>lx,getInternalFormatForPackedMatrixTexture:()=>mx,getInternalFormatForUnsignedBytesMatrixTexture:()=>cx,uploadDenseMatrixToTexture:()=>wS,uploadPixelDataToTexture:()=>SS});function gS(r){let e=Zt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Kw(r,t)}function bS(r){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return qw(r,e)}function yS(r){let e=new Uint16Array([0,1,2,2,1,3]);return Xw(r,e)}function Wh(r,e,t,n,o,s){Qw(e,t);let a=Yw(r),i=r.TEXTURE_2D;return _e(r,()=>r.bindTexture(i,a)),_e(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),_e(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),_e(r,()=>r.texParameteri(i,r.TEXTURE_MIN_FILTER,r.NEAREST)),_e(r,()=>r.texParameteri(i,r.TEXTURE_MAG_FILTER,r.NEAREST)),_e(r,()=>r.texImage2D(i,0,n,e,t,0,o,s,null)),_e(r,()=>r.bindTexture(r.TEXTURE_2D,null)),a}function lx(r){return r.internalFormatFloat}function xS(r,e,t,n){let[o,s]=kp(e,t);return Wh(r,o,s,lx(n),n.textureFormatFloat,r.FLOAT)}function px(r){return r.internalFormatHalfFloat}function TS(r,e,t,n){let[o,s]=kp(e,t);return Wh(r,o,s,px(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function cx(r){return r.downloadTextureFormat}function kS(r,e,t,n){let[o,s]=kp(e,t);return Wh(r,o,s,cx(n),r.RGBA,r.UNSIGNED_BYTE)}function mx(r){return r.internalFormatPackedFloat}function IS(r,e,t,n){let[o,s]=ii(e,t);return Wh(r,o,s,mx(n),r.RGBA,r.FLOAT)}function fx(r){return r.internalFormatPackedHalfFloat}function CS(r,e,t,n){let[o,s]=ii(e,t);return Wh(r,o,s,fx(n),r.RGBA,n.textureTypeHalfFloat)}function vS(r,e,t){let n=0,o=3*4,s=3*4+2*4;return _e(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),tx(r,e,"clipSpacePos",t,3,s,n)&&tx(r,e,"uv",t,2,s,o)}function wS(r,e,t,n,o,s){_e(r,()=>r.bindTexture(r.TEXTURE_2D,e));let a,i,u;o instanceof Uint8Array?(a=new Uint8Array(t*n*4),i=r.UNSIGNED_BYTE,u=r.RGBA):(a=new Float32Array(t*n*4),i=r.FLOAT,u=s.internalFormatPackedFloat),a.set(o),_e(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,t,n,0,r.RGBA,i,a)),_e(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function SS(r,e,t){_e(r,()=>r.bindTexture(r.TEXTURE_2D,e)),t.data instanceof Uint8Array?_e(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,t.data)):_e(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)),_e(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function _S(r,e,t,n){let o=r.createBuffer();_e(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let i=4*4*e*t;return _e(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,i,r.STREAM_READ)),_e(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,0)),_e(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function AS(r,e,t){let n=r,o=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function NS(r,e,t,n){let[o,s]=kp(e,t),a=4,i=new Uint8Array(i$(e*t,a));return _e(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function DS(r,e,t,n,o,s,a,i){let u=r,l=new Float32Array(u$(s,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function PS(r,e,t){let n=new Float32Array(e*t*4);return _e(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,n)),n}var dx=class{constructor(e){this.outputTexture=null;this.program=null;this.disposed=!1;this.vertexAttrsAreBound=!1;this.itemsToPoll=[];let t=U().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,Ww(t,e)):this.gl=Jo(t);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(U().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=Am(this.gl,s),Zn(this.gl,a))this.textureHalfFloatExtension=Am(this.gl,a);else if(U().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Zn(this.gl,o))this.colorBufferHalfFloatExtension=Am(this.gl,o);else if(U().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Zn(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Zn(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=bS(this.gl),this.indexBuffer=yS(this.gl),this.framebuffer=Zw(this.gl),this.textureConfig=Bh(this.gl,this.textureHalfFloatExtension)}get debug(){return U().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;_e(e,()=>e.finish()),_e(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),_e(e,()=>e.deleteFramebuffer(this.framebuffer)),_e(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),_e(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),_e(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),xS(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),TS(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),kS(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),SS(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,o){this.throwIfDisposed(),wS(this.gl,e,t,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),CS(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),IS(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(rx(this.gl,this.framebuffer),this.outputTexture=null),_e(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>NS(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,o,s,a){return DS(this.gl,e,t,n,o,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return AS(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let o=_S(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(U().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=o.clientWaitSync(s,0,0);return a===o.ALREADY_SIGNALED||a===o.CONDITION_SATISFIED},t=s}else U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>PS(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl,n=Vw(t,e);this.vertexShader==null&&(this.vertexShader=gS(t));let o=jw(t);return _e(t,()=>t.attachShader(o,this.vertexShader)),_e(t,()=>t.attachShader(o,n)),Hw(t,o),this.debug&&Oh(t,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=vS(t,this.program,this.vertexBuffer)),o}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&_e(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Oh(this.gl,this.program),_e(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?Jw(this.gl,e,t):eS(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),_e(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),tS(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[o,s]=ii(t,n);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,n,o){this.setOutputMatrixWriteRegionDriver(n,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Oh(this.gl,this.program),Nm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),_e(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),_e(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Am(this.gl,U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await b.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=_re(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&b.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),zh(this.gl,e,this.framebuffer),this.debug&&Nm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(zh(this.gl,this.outputTexture,this.framebuffer),this.debug&&Nm(this.gl)):rx(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let o=this.gl;zh(o,e,this.framebuffer),this.debug&&Nm(o),this.outputTexture=e,_e(o,()=>o.viewport(0,0,t,n)),_e(o,()=>o.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,o){this.throwIfDisposed(),_e(this.gl,()=>this.gl.scissor(e,t,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function _re(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var{addImpl:v$,bincountImpl:hx,bincountReduceImpl:w$,ceilImpl:S$,concatImpl:_$,equalImpl:A$,expImpl:N$,expm1Impl:D$,floorImpl:P$,gatherNdImpl:F$,gatherV2Impl:M$,greaterImpl:E$,greaterEqualImpl:R$,lessImpl:L$,lessEqualImpl:$$,linSpaceImpl:B$,logImpl:O$,maxImpl:z$,maximumImpl:G$,minimumImpl:W$,multiplyImpl:U$,negImpl:K$,notEqualImpl:V$,prodImpl:j$,rangeImpl:H$,rsqrtImpl:q$,sigmoidImpl:X$,simpleAbsImpl:gx,sliceImpl:Y$,sparseFillEmptyRowsImpl:Q$,sparseReshapeImpl:Z$,sparseSegmentReductionImpl:bx,sqrtImpl:J$,stridedSliceImpl:eB,stringNGramsImpl:tB,stringSplitImpl:rB,stringToHashBucketFastImpl:nB,subImpl:oB,tileImpl:sB,topKImpl:aB,transposeImpl:vp,uniqueImpl:iB}=vm;function FS(r,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${r}.${t}`)}function ar(r,e){return e===1?[r]:FS(r,e)}function uB(r,e){if(r===1)return"rc";let t="";for(let n=0;n<r;n++)t+=e[n],n<r-1&&(t+=",");return t}var MS=class{constructor(e){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.outputShape=e;let t=e.length;if(t===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let n=ar("rc",t),o=He(t),s=Nre(t,e,n),a=Dre(t,e[e.length-1],e[e.length-2],n),i=Pre(e,n);this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();

          if(${s}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${i}));
          }
        }
      `}}};function Are(r,e){let t=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let a=2;a<r;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}function Nre(r,e,t){if(r===1)return`rc > ${e[0]}`;let n="";for(let o=r-2;o<r;o++)n+=`${t[o]} >= ${e[o]}`,o<r-1&&(n+="||");return n}function Dre(r,e,t,n){if(r===1)return"";let o=n.slice(-2);return`
    int r = ${o[0]};
    int c = ${o[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${e};
    bool rEdge = rp1 >= ${t};
  `}function Pre(r,e){let t=r.length,n=Are(t,e);return t===1?`getA(rc),
            rc + 1 >= ${r[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${n[0]}),
          cEdge ? 0. : getA(${n[1]}),
          rEdge ? 0. : getA(${n[2]}),
          rEdge || cEdge ? 0. : getA(${n[3]})`}var Uh=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"inputShape",type:"ivec3"}];this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2==1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Fre(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Pm():Dm(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function Fre(r,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?d$(["r","c","d"],"inputShape"):Ea(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var ES=class{constructor(e){this.gpgpu=e;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;this.freeTextures={};this.logEnabled=!1;this.usedTextures={}}acquireTexture(e,t,n){let o=pB(t,n),s=cB(e,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=lB(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let i;return o===Or.PACKED_2X2_FLOAT32?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===Or.PACKED_2X2_FLOAT16?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===Or.UNPACKED_FLOAT32?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===Or.UNPACKED_FLOAT16?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===Or.PACKED_4X1_UNSIGNED_BYTE&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,o){if(this.freeTextures==null)return;let s=pB(n,o),a=cB(t,s,o);a in this.freeTextures||(this.freeTextures[a]=[]);let i=lB(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=U().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[a],p=l.indexOf(e);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(p,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function Mre(r,e){let t=r;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===r.RGBA)return 16;if(e===t.RGBA16F)return 8;throw new Error(`Unknown internal format ${e}`)}function lB(r,e,t,n,o){let s=Ere(e,n),a;if(o){let[u,l]=ii(r[0],r[1]);a=u*l}else{let[u,l]=kp(r[0],r[1]);a=u*l}let i=Mre(t,s);return a*i}function Ere(r,e){switch(r){case Or.PACKED_2X2_FLOAT32:return mx(e);case Or.PACKED_2X2_FLOAT16:return fx(e);case Or.UNPACKED_FLOAT32:return lx(e);case Or.UNPACKED_FLOAT16:return px(e);case Or.PACKED_4X1_UNSIGNED_BYTE:return cx(e);default:throw new Error(`Unknown physical texture type ${r}`)}}function Rre(r){return U().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Or.PACKED_2X2_FLOAT32:Or.UNPACKED_FLOAT32:r?Or.PACKED_2X2_FLOAT16:Or.UNPACKED_FLOAT16}function pB(r,e){if(r===Yr.UPLOAD)return Or.PACKED_2X2_FLOAT32;if(r===Yr.RENDER||r==null)return Rre(e);if(r===Yr.DOWNLOAD||r===Yr.PIXELS)return Or.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function cB(r,e,t){return`${r[0]}_${r[1]}_${e}_${t}`}var $n=class{constructor(e,t){this.variableNames=["A"];this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Dr="if (isnan(x)) return x;",mB="return x;",RS="return abs(x);";var fB="return (x >= 0.0) ? x : (exp(x) - 1.0);",dB=Dr+`
  return (x < 0.0) ? 0.0 : x;
`,hB=Dr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Kh="return x;",gB="return 1.0 / (1.0 + exp(-1.0 * x));";var bB="return x;",yB=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,xB=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,TB=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,kB="return 1.0 / (1.0 + exp(-1.0 * x));",Ra=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var LS=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outputShape=e;let t=e.length,n=ar("rc",t),o=He(t),s=uB(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}};var Lre=Tr.whereImpl,$re=1e-7,Bre=1e-4,yx={};function Ore(r){return r in yx||(yx[r]={}),yx[r]}var zre=U().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Gre=600;function Wre(){return U().global.screen==null?1024:U().global.screen.height*U().global.screen.width*window.devicePixelRatio*Gre/1024/1024}var $S=class extends os{constructor(e){super();this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.dataRefCount=new WeakMap;this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.lastGlFlushTime=0;this.warnedAboutMemory=!1;this.pendingDeletes=0;this.disposed=!1;if(!U().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){let t=Jo(U().getNumber("WEBGL_VERSION"));this.binaryCache=Ore(U().getNumber("WEBGL_VERSION")),this.gpgpu=new dx(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new ES(this.gpgpu),this.numMBBeforeWarning=Wre(),this.texData=new Oa(this,jo())}nextDataId(){return $S.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if((U().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||U().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:t,dtype:n,values:e,usage:Yr.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,o,s){if(U().getBool("DEBUG")&&this.checkNumericalProblems(t),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:o,values:t,usage:Yr.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:s,slice:a,shape:i,isPacked:u}=t;if(a!=null){let m;u?m=new Ra(i,Kh):m=new $n(i,Kh);let f=this.runWebGLProgram(m,[{dataId:e,shape:i,dtype:o}],o),d=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),d}if(n!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return n;let l=this.activeTimers!=null,p;l&&(p=b.now());let c;if(o==="complex64"){let m=this.readSync(s.real.dataId),f=this.readSync(s.imag.dataId);c=I.mergeRealAndImagArrays(m,f)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=b.now()-p),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){let d=this.pendingRead.get(e);return new Promise(h=>d.push(h))}let t=this.texData.get(e),{values:n,shape:o,slice:s,dtype:a,complexTensorInfos:i,isPacked:u}=t;if(s!=null){let d;u?d=new Ra(o,Kh):d=new $n(o,Kh);let h=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:a}],a),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(e);if(!U().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&U().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,p;if(a!=="complex64"&&U().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let d=this.texData.get(p.dataId);l=this.gpgpu.createBufferFromTexture(d.texture,...$h(o))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(a==="complex64"){let d=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),h=d[0],g=d[1];c=I.mergeRealAndImagArrays(h,g)}else if(l==null)c=this.getValuesFromTexture(e);else{let d=b.sizeFromShape(o);c=this.gpgpu.downloadFloat32MatrixFromBuffer(l,d)}if(p!=null&&this.disposeIntermediateTensorInfo(p),l!=null){let d=this.gpgpu.gl;_e(d,()=>d.deleteBuffer(l))}let m=this.convertAndCacheOnCPU(e,c),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(d=>d(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&jo().removeDataId(e,this),this.pendingDeletes--),m}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>b.decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!Uw(n))throw U().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:o}=this.texData.get(e),s=b.sizeFromShape(t);if(U().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(e),f=this.texData.get(m.dataId),d=this.gpgpu.downloadMatrixFromPackedTexture(f.texture,...$h(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),d}let a=U().getBool("WEBGL_PACK")&&o===!0,i=a?Gh(t):t,u=a?new fS(i):new mS(i),l=this.runWebGLProgram(u,[{shape:i,dtype:n,dataId:e}],"float32"),p=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=b.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=b.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);i.kernelMs=b.sum(u),i.getExtraProfileInfo=()=>u.map((l,p)=>({name:a[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:b.now(),endMs:null}}endTimer(e){return U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=b.now(),e)}async getQueryTime(e){if(U().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:o,usage:s,isPacked:a,slice:i}=this.texData.get(e),u=i&&i.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(t,o,s,a)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=zre){return U().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&b.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){I.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return Lre(e.shape,t)}packedUnaryOp(e,t,n){let o=new Ra(e.shape,t),s=this.compileAndRun(o,[e],n);return jo().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let o=gx(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if(U().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,RS,e.dtype);let t=new $n(e.shape,RS),n=this.compileAndRun(t,[e]);return jo().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&b.isString(n[0])){let s=n.map(a=>b.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:t}}makeOutput(e,t,n){let{dataId:o}=this.makeTensorInfo(e,t,n);return jo().makeTensorFromDataId(o,e,t,this)}unpackTensor(e){let t=new LS(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new MS(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[mu(e.shape),...fu(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},s=[mu(t),...fu(t)],a=new Uh(s,n),i=!0,u=[n],l=this.runWebGLProgram(a,[o],e.dtype,u,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e){let t=this.texData.get(e),{isPacked:n,shape:o,dtype:s}=t,a=Gh(o),i,u=$h(a);n?i=new cS(a):i=new pS(a);let l=!0,p=[u],c=this.runWebGLProgram(i,[{shape:a,dtype:s,dataId:e}],s,p,l);return{dtype:s,shape:o,dataId:c.dataId}}runWebGLProgram(e,t,n,o,s=!1){let a=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(a.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===al.DENSE){let g=$h(e.outputShape);i.texShape=g.map(y=>y*2)}if(e.outTexUsage!=null&&(i.usage=e.outTexUsage),b.sizeFromShape(a.shape)===0)return i.values=b.getTypedArrayFromDType(a.dtype,0),a;let u=[],l=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let y=this.texData.get(g.dataId);if(y.texture==null){if(!e.packedInputs&&b.sizeFromShape(g.shape)<=U().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:y.values};e.packedInputs&&(y.isPacked=!0,y.shape=g.shape)}else if(!!y.isPacked!=!!e.packedInputs)g=y.isPacked?this.unpackTensor(g):this.packTensor(g),u.push(g),y=this.texData.get(g.dataId);else if(y.isPacked&&!il(y.shape,g.shape)){let x=g,T=g.shape;g.shape=y.shape,g=this.packedReshape(g,T),u.push(g),y=this.texData.get(g.dataId),x.shape=T}return this.uploadToGPU(g.dataId),{shape:g.shape,texData:y,isUniform:!1}});this.uploadToGPU(a.dataId);let p={shape:a.shape,texData:i,isUniform:!1},c=I$(e,l,p),m=this.getAndSaveBinary(c,()=>x$(this.gpgpu,e,l,p)),f=this.activeTimers!=null,d;f&&(d=this.startTimer()),k$(this.gpgpu,m,l,p,o),u.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(d=this.endTimer(d),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(d)}));let h=U().get("WEBGL_FLUSH_THRESHOLD");if(h>0){let g=b.now();g-this.lastGlFlushTime>h&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!U().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&s===!1){let g=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),g}return a}compileAndRun(e,t,n,o,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,o,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(U().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=G(()=>{if(!U().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=U().getBool("DEBUG");U().set("DEBUG",!1);let t=this.abs(ce(1e-8)).dataSync()[0];if(U().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?$re:Bre}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:o,values:s,texture:a,usage:i,isPacked:u}=t;if(a!=null)return;let l=this.activeTimers!=null,p;l&&(p=b.now());let c=t.texShape;if(c==null&&(c=rS(n,u),t.texShape=c),s!=null){let m=Gh(n),f,d=c[1],h=c[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;u?([d,h]=ii(c[0],c[1]),f=new hS(m,g)):f=new dS(m,g);let y=this.makeTensorInfo([h,d],o);g?this.texData.get(y.dataId).usage=Yr.PIXELS:this.texData.get(y.dataId).usage=Yr.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),d,h,s);let x=[[h,d]],T=!0,k=this.runWebGLProgram(f,[y],o,x,T),w=this.texData.get(k.dataId);t.texture=w.texture,t.texShape=w.texShape,t.isPacked=w.isPacked,t.usage=w.usage,this.disposeIntermediateTensorInfo(y),this.texData.delete(k.dataId),t.values=null,l&&(this.uploadWaitMs+=b.now()-p)}else{let m=this.acquireTexture(c,i,o,u);t.texture=m}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:o}=n;return this.releaseGPUData(e),t!=null&&(n.values=Ure(t,o)),n.values}acquireTexture(e,t,n,o){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,o)}computeBytes(e,t){return e[0]*e[1]*b.bytesPerElement(t)}},Vh=$S;Vh.nextDataId=0;function Ure(r,e){if(e==="float32"||e==="complex64")return r;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<t.length;++n)t[n]=Math.round(r[n]);return t}else throw new Error(`Unknown dtype ${e}`)}var Kre="0.0.0";function IB(){U().set("WEBGL_FORCE_F16_TEXTURES",!0)}Gi.isBrowser()&&Vu("webgl",()=>new Vh,2);var L6t={forceHalfFloat:IB};var xx=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Ks=class{constructor(e,t,n){this.variableNames=["A","B"];this.outputShape=I.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=tr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var ul=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var La=class{constructor(e,t,n,o=!1){this.variableNames=["A","B"];this.supportsBroadcasting=!0;this.packedInputs=!0;this.packedOutput=!0;this.outputShape=I.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=tr(s);let a="";if(o)if(s===0||b.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${He(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=ar("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ir(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var CB={kernelName:Kn,backendName:"webgl",kernelFunc:ir};function Bn(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),a=t.texData.get(s.dataId),i=ir({inputs:{x:n},backend:t}),u=ir({inputs:{x:o},backend:t});return a.complexTensorInfos={real:i,imag:u},s}var vB={kernelName:Nu,backendName:"webgl",kernelFunc:Bn};var BS="return (a < 0.) ? b * a : a;",OS=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Vre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,a=t.makeTensorInfo([],"float32",b.createScalarValue(s,"float32")),i=U().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La(OS,o.shape,a.shape):new Ks(BS,o.shape,a.shape),u=t.runWebGLProgram(i,[o,a],"float32");return t.disposeIntermediateTensorInfo(a),u}var wB={kernelName:na,backendName:"webgl",kernelFunc:Vre};var zS="return (a < 0.) ? b * a : a;",GS=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function jre(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=U().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La(GS,n.shape,o.shape):new Ks(zS,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],"float32")}var SB={kernelName:Fo,backendName:"webgl",kernelFunc:jre};var Tx="if (isnan(x)) return x;",_B=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,AB=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Ae({opSnippet:r,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:o,backend:s})=>{let{x:a}=o,i=s,u=n||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){let c=i.texData.get(a.dataId),m=t(c.values,u);return i.makeTensorInfo(a.shape,u,m)}let l=U().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,p;return l?p=new Ra(a.shape,e):p=new $n(a.shape,r),i.runWebGLProgram(p,[a],u)}}function ft({opSnippet:r,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:a,backend:i})=>{let{a:u,b:l}=a,p=i;if(n&&u.dtype==="complex64"){let d=p.texData.get(u.dataId),h=p.texData.get(l.dataId),[g,y]=[[d.complexTensorInfos.real,h.complexTensorInfos.real],[d.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(T=>{let[k,w]=T,P={dataId:k.dataId,dtype:k.dtype,shape:u.shape},A={dataId:w.dataId,dtype:w.dtype,shape:l.shape},F=new Ks(r,u.shape,l.shape);return p.runWebGLProgram(F,[P,A],Ut(k.dtype,w.dtype))}),x=Bn({inputs:{real:g,imag:y},backend:p});return p.disposeIntermediateTensorInfo(g),p.disposeIntermediateTensorInfo(y),x}let c=s||Ut(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||p.shouldExecuteOnCPU([u,l]))&&o!=null){let d=p.texData.get(u.dataId).values,h=p.texData.get(l.dataId).values,g=u.dtype==="string"?I.fromUint8ToStringArray(d):d,y=u.dtype==="string"?I.fromUint8ToStringArray(h):h,[x,T]=o(u.shape,l.shape,g,y,c),k=p.makeTensorInfo(T,c),w=p.texData.get(k.dataId);return w.values=x,k}let m=U().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,f;return m?f=new La(e,u.shape,l.shape,t):f=new Ks(r,u.shape,l.shape),p.runWebGLProgram(f,[u,l],c)}}function ll(r,e=!1){if(r==="linear")return e?bB:mB;if(r==="relu")return e?xB:dB;if(r==="elu")return e?yB:fB;if(r==="relu6")return e?TB:hB;if(r==="prelu")return e?GS:zS;if(r==="leakyrelu")return e?OS:BS;if(r==="sigmoid")return e?kB:gB;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var jh=class{constructor(e,t,n,o=!1,s=!1,a=!1,i=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=n,this.enableShapeUniforms=tr(this.outputShape.length);let p=o?e[1]:e[2],c=Math.ceil(p/2),m=o?"i * 2, rc.y":"rc.y, i * 2",f=s?"rc.z, i * 2":"i * 2, rc.z",d=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",y="";i&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,y="result = activation(result);");let x=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let T="rc.x",k="rc.x";e[0]<t[0]?T=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(k=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${c}; i++) {
          int batchA = ${T};
          int batchB = ${k};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${f});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${d[0]} * ${h[0]});
          result += (${d[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${y}

        setOutput(result);
      }
    `}};var WS={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},kx=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=I.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var NB="return a * b;";function Hh(r){let{inputs:e,backend:t}=r,{a:n,b:o}=e,s=I.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let i=t.texData.get(n.dataId),u=t.texData.get(o.dataId),l=new kx(WS.REAL,n.shape,o.shape),p=new kx(WS.IMAG,n.shape,o.shape),c=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:n.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],m=t.runWebGLProgram(l,c,"float32"),f=t.runWebGLProgram(p,c,"float32"),d=Bn({inputs:{real:m,imag:f},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}if(t.shouldExecuteOnCPU([n,o])){let i=t.texData.get(n.dataId),u=t.texData.get(o.dataId),[l,p]=U$(n.shape,o.shape,i.values,u.values,s),c=t.makeTensorInfo(p,s),m=t.texData.get(c.dataId);return m.values=l,c}let a;return U().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new La(NB,n.shape,o.shape):a=new Ks(NB,n.shape,o.shape),t.runWebGLProgram(a,[n,o],s)}var DB={kernelName:No,backendName:"webgl",kernelFunc:Hh};function PB(r,e,t){let n=[mu(r.shape),...fu(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[mu(e),...fu(e)],a=new Uh(s,n),i=!0,u=[n],l=t.runWebGLProgram(a,[o],r.dtype,u,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}function ie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=t,i=b.sizeFromShape(o.shape),u=b.inferFromImplicitShape(s,i),l=b.sizeFromShape(u);b.assert(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let p=a.texData.get(o.dataId);return p.isPacked&&!il(o.shape,u)&&!(p.texture!==null&&il(p.shape,u))?PB(o,u,a):(a.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var FB={kernelName:ds,backendName:"webgl",kernelFunc:ie};var Ix=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(t!=null){let c=1/t;l=`sumValue += dot(values * ${b.isInt(c)?c.toPrecision(2):c}, ones);`}let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var US=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i="0.0",u="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",u="min"):t==="max"&&(i="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let p=Math.floor(n/4)*4,c=n%4,m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,f="vec4";t==="all"?(i="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,f="bvec4"):t==="any"&&(i="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,f="bvec4");let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${p};
        if (${c===1}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${c===2}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${c===3}) {
          ${f} values = ${f}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Hre(r){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:r[1],n=I.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function Jn(r,e,t,n){let o=Hre(r.shape),s=r;for(let a=0;a<o.length;a++){let{inSize:i,windowSize:u,outSize:l}=o[a],p,c;t==="mean"?p=a===0?new Ix({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l},i):new Ix({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l}):p=new US({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l},t),c=s,s=n.runWebGLProgram(p,[s],e),c.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(c)}return s}var KS=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let o=He(this.rank),s=qre(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function qre(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let o=0;o<r.length;o++)n[r[o]]=t[o];return n.join()}var VS=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;let n=new Array(e.length);for(let p=0;p<n.length;p++)n[p]=e[t[p]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=He(this.rank),s=FS("rc",this.rank),a=new Array(this.rank);for(let p=0;p<t.length;p++)a[t[p]]=s[p];let i=`vec2(${a.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function pl(r,e,t){let n=U().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new VS(r.shape,e):new KS(r.shape,e);return t.runWebGLProgram(n,[r],r.dtype)}function MB(r,e,t,n){let o=e,s=r.shape.length,a=b.parseAxisParam(o,r.shape),i=a,u=I.getAxesPermutation(i,s),l=u!=null,p=r;l&&(p=pl(r,u,n),i=I.getInnerMostAxes(i.length,s)),I.assertAxesAreInnerMostDims("sum",i,s);let[c,m]=I.computeOutAndReduceShapes(p.shape,i),f=c;t&&(f=I.expandShapeToKeepDim(c,a));let d=b.sizeFromShape(m),g=b.sizeFromShape(r.shape)/d,y=ie({inputs:{x:p},attrs:{shape:[g,d]},backend:n}),x=zi(r.dtype),T=Jn(y,x,"sum",n),k=ie({inputs:{x:T},attrs:{shape:f},backend:n});return n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(T),l&&n.disposeIntermediateTensorInfo(p),k}function wp(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return MB(o,s,a,t)}var EB={kernelName:zo,backendName:"webgl",kernelFunc:wp};function jt(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,a=t,i=o.shape.length,u=new Array(i);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];let l;if(a.shouldExecuteOnCPU([o])){let c=a.texData.get(o.dataId).values,m=vp(c,o.shape,o.dtype,s,u);l=a.makeTensorInfo(u,o.dtype);let f=a.texData.get(l.dataId);f.values=m}else l=pl(o,s,a);return l}var RB={kernelName:Vo,backendName:"webgl",kernelFunc:jt};var jS=1e3;function Sp({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,c=t?r.shape[l-2]:r.shape[l-1],m=n?e.shape[p-1]:e.shape[p-2],f=t?r.shape[l-1]:r.shape[l-2],d=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),y=b.sizeFromShape(h),x=b.sizeFromShape(g),T=y===x||y===1||x===1;b.assert(l>=2&&p>=2&&T,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${g}).`);let w=(y>x?r.shape.slice(0,-2):e.shape.slice(0,-2)).concat([f,d]);b.assert(c===m,()=>`Error in matMul: inner shapes (${c}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let P=t?[y,c,f]:[y,f,c],A=n?[x,d,m]:[x,m,d],F=ie({inputs:{x:r},backend:o,attrs:{shape:P}}),E=ie({inputs:{x:e},backend:o,attrs:{shape:A}}),$=[F,E],W=Math.max(y,x),K=t?F.shape[1]:F.shape[2],B=s!=null,V=a!=null,j=u==="leakyrelu",H=u!=null?ll(u,!0):null,J=B||V||j||H!=null,X;if((f===1||d===1)&&K>jS&&J===!1){let oe=F,te=E;t&&(oe=jt({inputs:{x:F},backend:o,attrs:{perm:[0,2,1]}}),$.push(oe)),n&&(te=jt({inputs:{x:E},backend:o,attrs:{perm:[0,2,1]}}),$.push(te));let le=d!==1,ae=d===1,ge=oe;le&&(ge=ie({inputs:{x:oe},backend:o,attrs:{shape:[W,K,1]}}),$.push(ge));let fe=d===1?2:1,xe=te;ae&&(xe=ie({inputs:{x:te},backend:o,attrs:{shape:[W,1,K]}}),$.push(xe));let Se=Hh({inputs:{a:ge,b:xe},backend:o});X=wp({inputs:{x:Se},backend:o,attrs:{axis:fe,keepDims:!0}}),$.push(Se)}else{let oe=Ut(r.dtype,e.dtype),te=new jh(P,A,[W,f,d],t,n,B,H,V,j),le=[F,E];if(s!=null&&le.push(s),V&&le.push(a),j){let ae=o.makeTensorInfo([],"float32",b.createScalarValue(i,"float32"));le.push(ae),$.push(ae)}X=o.runWebGLProgram(te,le,oe)}let ne=ie({inputs:{x:X},backend:o,attrs:{shape:w}});$.push(X);for(let oe of $)o.disposeIntermediateTensorInfo(oe);return ne}function Xre(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n;return Sp({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:c,activation:p})}var LB={kernelName:Is,backendName:"webgl",kernelFunc:Xre};var $B="return abs(x);";function Yre(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=t.texData.get(n.dataId),a=gx(s.values);return t.makeTensorInfo(n.shape,n.dtype,a)}let o;return U().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Ra(n.shape,$B):o=new $n(n.shape,$B),t.runWebGLProgram(o,[n],n.dtype)}var BB={kernelName:as,backendName:"webgl",kernelFunc:Yre};var Qre=Dr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Zre=Ae({opSnippet:Qre}),OB={kernelName:bi,backendName:"webgl",kernelFunc:Zre};var Jre=Dr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,ene=Ae({opSnippet:Jre}),zB={kernelName:yi,backendName:"webgl",kernelFunc:ene};var GB="return a + b;",tne=ft({opSnippet:GB,packedOpSnippet:GB,supportsComplex:!0,cpuKernelImpl:v$}),WB={kernelName:_n,backendName:"webgl",kernelFunc:tne};var HS=class{constructor(e,t){this.outputShape=[];this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var qS=class{constructor(e,t){this.outputShape=[];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function Cx(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return ir({inputs:{x:n[0]},backend:t});if(n.length>U().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=Cx({inputs:n.slice(0,u),backend:t}),p=Cx({inputs:n.slice(u),backend:t});return Cx({inputs:[l,p],backend:t})}let o=n.map(u=>u.dtype).reduce((u,l)=>Ut(u,l)),s=n.map(u=>u.shape),i=U().getBool("WEBGL_PACK")?new qS(n[0].shape,s):new HS(n[0].shape,s);return t.runWebGLProgram(i,n,o)}var UB={kernelName:no,backendName:"webgl",kernelFunc:Cx};function rne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,i),c=o;p!=null&&(c=jt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=I.getInnerMostAxes(l.length,i)),I.assertAxesAreInnerMostDims("all",l,i);let[m,f]=I.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=ie({inputs:{x:c},backend:t,attrs:{shape:[-1,d]}}),g=Jn(h,h.dtype,"all",t),y;if(a){let x=I.expandShapeToKeepDim(m,u);y=ie({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=ie({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(c),y}var KB={kernelName:xi,backendName:"webgl",kernelFunc:rne};function nne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,i),c=o;p!=null&&(c=jt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=I.getInnerMostAxes(l.length,i)),I.assertAxesAreInnerMostDims("any",l,i);let[m,f]=I.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=ie({inputs:{x:c},backend:t,attrs:{shape:[-1,d]}}),g=Jn(h,h.dtype,"any",t),y;if(a){let x=I.expandShapeToKeepDim(m,u);y=ie({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=ie({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(c),y}var VB={kernelName:Ti,backendName:"webgl",kernelFunc:nne};var XS=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var YS=class{constructor(e,t,n,o){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;b.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),o||this.variableNames.push("bestIndicesA");let i=this.outputShape,u=i.length,l=He(u),p=ar("coords",u),c,m;if(a===1){m=u+1;let F=He(m);c=`
        ${F} sourceLocR = ${F}(${p.join()}, 0);
        ++${p[u-1]};
        ${F} sourceLocG = ${F}(${p.join()}, 0);
        ++${p[u-2]};
        ${F} sourceLocA = ${F}(${p.join()}, 0);
        --${p[u-1]};
        ${F} sourceLocB = ${F}(${p.join()}, 0);
        --${p[u-2]};`}else m=u,c=`
        ${l} sourceLocR = coords;
        ++${p[u-1]};
        ${l} sourceLocG = coords;
        ++${p[u-2]};
        ${l} sourceLocA = coords;
        --${p[u-1]};
        ${l} sourceLocB = coords;
        --${p[u-2]};`;let f=["x","y","z","w","u","v"].slice(0,m),d="."+f[m-1],h=f.map(F=>"int "+F),g=ar("sourceLocR",m-1).concat("inIdx.r"),y=ar("sourceLocG",m-1).concat("inIdx.g"),x=ar("sourceLocB",m-1).concat("inIdx.b"),T=ar("sourceLocA",m-1).concat("inIdx.a"),k=n==="max"?"greaterThan":"lessThan",w=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${T.join()})));`,P=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${T.join()}) : 0.)`,A=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${f.join()}),
                                          vec2(${f.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${f.join()}),
                               vec2(${f.slice(-2).join()}));
      }
      ${A}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${p[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${p[u-2]} < ${i[u-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${d}, sourceLocG${d},
          sourceLocB${d}, sourceLocA${d}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${P};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${P};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function jB(r,e,t,n=null){let o=e.shape[0],s=e.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let a=I.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:o,outSize:Math.ceil(s/a)},u=new XS(i,t,n==null),l=[e];n!=null&&l.push(n);let p=r.runWebGLProgram(u,l,"int32");if(p.shape[1]===1)return p;let c=jB(r,e,t,p);return r.disposeIntermediateTensorInfo(p),c}function HB(r,e,t,n=null){let o=n!=null?n.shape:e.shape,s=o[o.length-1],a=I.computeOptimalWindowSize(s),i=new YS(o,a,t,n==null),u=n==null?[e]:[e,n],l=r.runWebGLProgram(i,u,"int32");if(l.shape.length===e.shape.length){let p=HB(r,e,t,l);return r.disposeIntermediateTensorInfo(l),p}return l}function vx(r,e,t,n){let o=[t];if(I.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.shape.length),!U().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],a=r.texData.get(e.dataId),i=a!==null&&a.isPacked,u=e;i&&(u=r.unpackTensor(e),s.push(u));let[l,p]=I.computeOutAndReduceShapes(u.shape,o),c=b.sizeFromShape(p),m=ie({inputs:{x:u},backend:r,attrs:{shape:[-1,c]}});s.push(m);let f=jB(r,m,n);s.push(f);let d=ie({inputs:{x:f},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),d}return HB(r,e,n)}function one(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=b.parseAxisParam(s,o.shape),i=I.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=jt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=I.getInnerMostAxes(a.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let p=vx(t,u,a[0],"max");return l.forEach(c=>t.disposeIntermediateTensorInfo(c)),p}var qB={kernelName:oo,backendName:"webgl",kernelFunc:one};function sne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=b.parseAxisParam(s,o.shape),i=I.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=jt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=I.getInnerMostAxes(a.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let p=vx(t,u,a[0],"min");return l.forEach(c=>t.disposeIntermediateTensorInfo(c)),p}var XB={kernelName:Wa,backendName:"webgl",kernelFunc:sne};var ane=Dr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,ine=Ae({opSnippet:ane}),YB={kernelName:ki,backendName:"webgl",kernelFunc:ine};var une=Dr+"return log(x + sqrt(x * x + 1.0));",lne=Ae({opSnippet:une}),QB={kernelName:Ii,backendName:"webgl",kernelFunc:lne};var pne=Dr+`
  return atan(x);
`,cne=Ae({opSnippet:pne}),ZB={kernelName:Ci,backendName:"webgl",kernelFunc:cne};var mne=_B+`
  return atan(a, b);
`,fne=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+AB+`
  return result;
`,dne=ft({opSnippet:mne,packedOpSnippet:fne}),JB={kernelName:wi,backendName:"webgl",kernelFunc:dne};var hne=Dr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,gne=Ae({opSnippet:hne}),eO={kernelName:vi,backendName:"webgl",kernelFunc:gne};var ui=class{constructor(e,t,n,o=!1,s=!1){this.variableNames=["x"];if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,p=e.dilationWidth,c=e.effectiveFilterHeight,m=e.effectiveFilterWidth,f=e.padInfo.top,d=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,x="0.0";if(h||(x="-1.0 / 1e-20"),n){let F=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${f}, ${d});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${F} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:y:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let T="max",k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / count");let w=Math.floor(a/4)*4,P=a%4,A=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${f}, ${d});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${A}
          }

          int xC = xCCorner + ${w};
          if (${P===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${P===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${A}
          } else if (${P===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${A}
          }
        }
        setOutput(${k});
      }
    `}},_p=class{constructor(e,t,n,o=!1,s=!1){this.variableNames=["x"];if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,u=e.strideHeight,l=e.strideWidth,p=e.dilationDepth,c=e.dilationHeight,m=e.dilationWidth,f=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,y=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;let T=t==="avg",k="0.0";if(T||(k="-1.0 / 1e-20"),n){let $=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${y}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${f};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${d};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${$} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${d} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let w="max",P=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(P="avgValue / count");let A=Math.floor(a/4)*4,F=a%4,E=`
      if (${T}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${y}, ${x});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${A}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${E}
            }

            int xC = xCCorner + ${A};
            if (${F===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${F===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${E}
            } else if (${F===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${E}
            }
          }
          setOutput(${P});
        }
      }
    `}};function bne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;Ma(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,a,l,i,u);if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))return ir({inputs:{x:o},backend:t});let c=new ui(p,"avg",!1);return t.runWebGLProgram(c,[o],"float32")}var tO={kernelName:so,backendName:"webgl",kernelFunc:bne};function yne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n,p=[1,1,1],c=I.computePool3DInfo(o.shape,s,a,p,i,u,l),m=new _p(c,"avg",!1);return t.runWebGLProgram(m,[o],"float32")}var rO={kernelName:Au,backendName:"webgl",kernelFunc:yne};var QS=class{constructor(e){this.variableNames=["dy"];this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=u-1-e.padInfo.top,c=l-1-e.padInfo.left,m=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${p}, ${c});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},ZS=class{constructor(e){this.variableNames=["dy"];this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,c=e.effectiveFilterDepth,m=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=c-1-e.padInfo.front,h=m-1-e.padInfo.top,g=f-1-e.padInfo.left,y=1/(t*n*o);this.userCode=`
      const ivec3 pads = ivec3(${d}, ${h}, ${g});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function xne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:p}=n,c=[1,1,1],m=I.computePool3DInfo(a.shape,i,u,c,l,p),f=new ZS(m);return t.runWebGLProgram(f,[o],a.dtype)}var nO={kernelName:Xp,backendName:"webgl",kernelFunc:xne};function Tne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;Ma([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=n,p=I.computePool2DInfo(a.shape,i,u,1,l),c=new QS(p);return t.runWebGLProgram(c,[o],a.dtype)}var oO={kernelName:qp,backendName:"webgl",kernelFunc:Tne};function kne(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;return Sp({a:o,b:s,transposeA:a,transposeB:i,backend:t})}var sO={kernelName:ao,backendName:"webgl",kernelFunc:kne};var JS=class{constructor(e,t,n,o,s,a){this.outputShape=[];this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,n);let i="0.0";o!=null&&(I.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var e_=class{constructor(e,t,n,o,s,a){this.packedInputs=!0;this.packedOutput=!0;this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";o!=null&&(I.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Ine=({inputs:r,backend:e,attrs:t})=>{let{x:n,mean:o,variance:s,offset:a,scale:i}=r;b.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);let l=[n,o,s],p=null;a!=null&&(p=a.shape,l.push(a));let c=null;i!=null&&(c=i.shape,l.push(i));let m=U().getBool("WEBGL_PACK_NORMALIZATION")?new e_(n.shape,o.shape,s.shape,p,c,u):new JS(n.shape,o.shape,s.shape,p,c,u);return e.runWebGLProgram(m,l,l[0].dtype)},aO={kernelName:xo,backendName:"webgl",kernelFunc:Ine};var t_=class{constructor(e){this.variableNames=["source"];this.outputShape=e,this.rank=e.length;let t=He(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=Cne(this.rank),o,s=e.map((a,i)=>`sourceLoc.${r_[i]} = start[${i}] + coords.${r_[i]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},r_=["x","y","z","w","u","v"];function Cne(r){if(r===1)return"sourceLoc";if(r<=6)return r_.slice(0,r).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var n_=class{constructor(e){this.variableNames=["source"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=He(this.rank),n=ar("coords",this.rank),o=ar("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,a=`getChannel(getSource(${o.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${a};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((p,c)=>`start[${c}]`).join()});`:e.map((p,c)=>`${o[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}};function vne(r,e,t,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(t,r.dtype),a=n.texData.get(s.dataId);Object.assign(a,o),a.refCount=1,a.shape=t,a.dtype=r.dtype;let i=Xt.computeFlatOffset(e,b.computeStrides(r.shape));o.slice&&(i+=o.slice.flatOffset),a.slice={flatOffset:i,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,u+1),s}function $a(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n,[i,u]=Xt.parseSliceParams(o,s,a);if(Xt.assertParamsValid(o,i,u),b.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let c=t.texData.get(o.dataId),m=Y$(c.values,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,m)}let{isPacked:l}=t.texData.get(o.dataId),p=Xt.isSliceContinous(o.shape,i,u);if(l||!p){let c=U().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new n_(u):new t_(u),m=[i];return t.runWebGLProgram(c,[o],o.dtype,m)}return t.uploadToGPU(o.dataId),vne(o,i,u,t)}var iO={kernelName:gs,backendName:"webgl",kernelFunc:$a};var wne=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((x,T)=>x*T),u=I.getReshaped(o.shape,s,i),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,i),c=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(p,a,s.length),f=[],d=ie({inputs:{x:o},backend:t,attrs:{shape:u}}),h=jt({inputs:{x:d},backend:t,attrs:{perm:l}}),g=ie({inputs:{x:h},backend:t,attrs:{shape:p}}),y=$a({inputs:{x:g},backend:t,attrs:{begin:c,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(x=>t.disposeIntermediateTensorInfo(x)),y},uO={kernelName:is,backendName:"webgl",kernelFunc:wne};function Sne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.readSync(o.dataId),u=t.readSync(s.dataId),l=hx(i,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}var lO={kernelName:Yp,backendName:"webgl",kernelFunc:Sne};function _ne(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.readSync(n.dataId),a=t.readSync(o.dataId),i=I.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var pO={kernelName:Qp,backendName:"webgl",kernelFunc:_ne};var Ane="return float(a != b);",o_=ft({opSnippet:Ane,cpuKernelImpl:V$,dtype:"bool"}),cO={kernelName:ia,backendName:"webgl",kernelFunc:o_};function du(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ir({inputs:{x:o.complexTensorInfos.real},backend:t})}var mO={kernelName:$u,backendName:"webgl",kernelFunc:du};var Nne="return float(int(x));";function fO(r,e){let t=new $n(r.shape,Nne),n=e.runWebGLProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function s_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return ir({inputs:{x:o},backend:t});let a=Tt(o.shape),i=s_({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=Bn({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),u}if(o.dtype==="complex64"){let a=du({inputs:{input:o},backend:t}),i=s_({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),i}if(!b.hasEncodingLoss(o.dtype,s)){let a=ir({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(s==="int32")return fO(o,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),u=o_({inputs:{a:o,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var dO={kernelName:Wn,backendName:"webgl",kernelFunc:s_};var hO="return ceil(x);",Dne=Ae({opSnippet:hO,packedOpSnippet:hO,cpuKernelImpl:S$}),gO={kernelName:io,backendName:"webgl",kernelFunc:Dne};var a_=class{constructor(e){this.variableNames=["A"];this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var i_=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function Pne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i;U().getBool("WEBGL_PACK_CLIP")?i=new i_(o.shape):i=new a_(o.shape);let u=[[s],[a]];return t.runWebGLProgram(i,[o],o.dtype,u)}var bO={kernelName:Un,backendName:"webgl",kernelFunc:Pne};var u_=class{constructor(e){this.variableNames=["real","imag"];this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function yO(r,e){return{dataId:e.dataId,dtype:e.dtype,shape:r.shape}}function Fne(r){let{inputs:e,backend:t}=r,{x:n}=e,o=t.texData.get(n.dataId),s=new u_(n.shape),a=[yO(n,o.complexTensorInfos.real),yO(n,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,a,a[0].dtype)}var xO={kernelName:Du,backendName:"webgl",kernelFunc:Fne};var l_=class{constructor(e){this.outputShape=[];this.outputShape=I.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let o=t.length,s=t[t.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var p_=class{constructor(e,t){this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];this.outputShape=I.computeOutShape(e,t);let n=this.outputShape,o=n.length,s=He(o),a=ar("coords",o),i=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let u=new Array(e.length-1);u[0]=e[0][t];for(let h=1;h<u.length;h++)u[h]=u[h-1]+e[h][t];let l=i[t],p=i.slice(-2),c=i.join(),m=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${c}), vec2(${p.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];m+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${wx(i,l,g)}),
            vec2(${wx(p,l,g)}));
        }`}let f=u.length,d=u[u.length-1];m+=`
        return getChannel(
          getT${f}(${wx(i,l,d)}),
          vec2(${wx(p,l,d)}));`,this.userCode=`
      float getValue(${i.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[o-1]} = ${a[o-1]} + 1;
        if (${a[o-1]} < ${n[o-1]}) {
          result.g = getValue(${a});
        }

        ${a[o-2]} = ${a[o-2]} + 1;
        if (${a[o-2]} < ${n[o-2]}) {
          result.a = getValue(${a});
        }

        ${a[o-1]} = ${a[o-1]} - 1;
        if (${a[o-2]} < ${n[o-2]} &&
            ${a[o-1]} < ${n[o-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function wx(r,e,t){let n=r.indexOf(e);return r.map((s,a)=>a===n?`${s} - ${t}`:s).join()}function Ap(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ir({inputs:{x:o.complexTensorInfos.imag},backend:t})}var TO={kernelName:Eu,backendName:"webgl",kernelFunc:Ap};function Np(r,e,t){let n=r[0].dtype;if(n==="complex64"){let p=r.map(h=>du({inputs:{input:h},backend:t})),c=r.map(h=>Ap({inputs:{input:h},backend:t})),m=Np(p,e,t),f=Np(c,e,t),d=Bn({inputs:{real:m,imag:f},backend:t});return p.forEach(h=>t.disposeIntermediateTensorInfo(h)),c.forEach(h=>t.disposeIntermediateTensorInfo(h)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let p=r.map(y=>{let x=b.sizeFromShape(y.shape.slice(e));return ie({inputs:{x:y},backend:t,attrs:{shape:[-1,x]}})}),c=p.map(y=>({vals:t.readSync(y.dataId),shape:y.shape})),m=I.computeOutShape(p.map(y=>y.shape),1),f=p[0].shape[0]===1,d=_$(c,m,n,f),h=I.computeOutShape(r.map(y=>y.shape),e),g=t.makeTensorInfo(h,n,d);return p.forEach(y=>t.disposeIntermediateTensorInfo(y)),g}if(r.length>U().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let p=Math.floor(r.length/2),c=Np(r.slice(0,p),e,t),m=Np(r.slice(p),e,t),f=Np([c,m],e,t);return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),f}if(U().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let p=new p_(r.map(c=>c.shape),e);return t.runWebGLProgram(p,r,n)}let{tensors2D:s,outShape:a}=Mne(r,e,t),i=new l_(s.map(p=>p.shape)),u=t.runWebGLProgram(i,s,n);s.forEach(p=>t.disposeIntermediateTensorInfo(p));let l=ie({inputs:{x:u},attrs:{shape:a},backend:t});return t.disposeIntermediateTensorInfo(u),l}function Mne(r,e,t){let n=I.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>ie({inputs:{x:s},attrs:{shape:[-1,b.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:n}}function c_(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,e[0].shape)[0],a=I.computeOutShape(e.map(l=>l.shape),s);if(b.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let i=e.filter(l=>b.sizeFromShape(l.shape)>0);if(i.length===1)return ir({inputs:{x:i[0]},backend:t});let u=i.map(l=>l.shape);return I.assertParamsConsistent(u,s),Np(i,s,t)}var kO={kernelName:us,backendName:"webgl",kernelFunc:c_};var qh=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,p=e.dilationHeight,c=e.dilationWidth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",y=g?1:2,x=g?2:3,T=g?3:1,k="",w="";n&&(o?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:k=`
          float activation(float x) {
            ${n}
          }
        `,w="result = activation(result);");let P=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${T}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${f}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${d}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${d}) *
                    getW(wR, wC, ${d}, d2);
              } else {
                dotProd +=
                    getX(batch, ${d}, xR, xC) *
                    getW(wR, wC, ${d}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${d}, d2),
                getW(wR, wC, ${d} + 1, d2),
                getW(wR, wC, ${d} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${d}),
                  getX(batch, xR, xC, ${d} + 1),
                  getX(batch, xR, xC, ${d} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${d}, xR, xC),
                  getX(batch, ${d} + 1, xR, xC),
                  getX(batch, ${d} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${P}
        ${w}
        setOutput(result);
      }
    `}},m_=class{constructor(e){this.variableNames=["x","W"];this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,c=e.filterDepth,m=e.filterHeight,f=e.filterWidth,d=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${d}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${d}) *
                  getW(wF, wR, wC, ${d}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${d}),
                  getX(batch, xF, xR, xC, ${d} + 1),
                  getX(batch, xF, xR, xC, ${d} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${d}, d2),
                  getW(wF, wR, wC, ${d} + 1, d2),
                  getW(wF, wR, wC, ${d} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var f_=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}];this.outputShape=e,this.enableShapeUniforms=tr(this.outputShape.length);let{dataFormat:n}=t,o=Zt(),s=n==="channelsLast",a=s?0:1,i=s?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`,l="";for(let p=0;p<=1;p++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.y + ${c};
          pos = rc.x + ${p};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${p*2+c}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${p*2+c}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function Sx({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=r.shape,l=n.texData.get(r.dataId),p=t.inChannels,c=u[0]*u[1]*u[2],m=t.outChannels,f=t.dataFormat==="channelsLast",d=!1,h=!1,g,y=[];if(!((c===1||m===1)&&p>jS)&&l.isPacked&&f&&l.texture!=null&&u[2]%2!=0&&b.arraysEqual(l.shape.slice(-3),u.slice(-3))){let k=u[0]*u[1]*(u[2]+1),w={dataId:r.dataId,shape:[1,k,t.inChannels],dtype:r.dtype},P=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,b.assert(il(l.shape,w.shape),()=>`packed reshape ${l.shape} to ${w.shape} isn't free`);let A=ie({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});y.push(A);let F=Sp({a:w,b:A,backend:n,transposeA:d,transposeB:h,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),E=n.texData.get(F.dataId);b.assert(E.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=P,E.shape=t.outShape,g=ir({inputs:{x:F},backend:n}),g.shape=t.outShape,y.push(F)}else{let k=f?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],w=ie({inputs:{x:r},backend:n,attrs:{shape:[1,k,t.inChannels]}}),P=ie({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),A=Sp({a:w,b:P,transposeA:d,transposeB:h,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});g=ie({inputs:{x:A},backend:n,attrs:{shape:t.outShape}}),y.push(w),y.push(P),y.push(A)}for(let k of y)n.disposeIntermediateTensorInfo(k);return g}function _x({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:p,outWidth:c,outHeight:m,dataFormat:f}=t,d=f==="channelsLast",h=u*l*p,g=m*c,y=[h,g],x=!0,T=!1,k=[],w=ie({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),P=ie({inputs:{x:e},backend:n,attrs:{shape:[1,h,b.sizeFromShape(e.shape)/h]}});k.push(w),k.push(P);let A=new f_(y,t),F=[w.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],E=n.runWebGLProgram(A,[w],"float32",F),$=ie({inputs:{x:E},backend:n,attrs:{shape:[1,y[0],y[1]]}});k.push(E),k.push($);let W=o!=null,K=s!=null,B=i==="leakyrelu",V=i?ll(i,!0):null,j=new jh($.shape,P.shape,[1,g,t.outChannels],x,T,W,V,K,B),H=[$,P];if(o&&H.push(o),K&&H.push(s),B){let oe=n.makeTensorInfo([],"float32",b.createScalarValue(a,"float32"));H.push(oe),k.push(oe)}let J=n.runWebGLProgram(j,H,"float32"),X=d?[1,m,c,t.outChannels]:[1,t.outChannels,m,c],ne=ie({inputs:{x:J},backend:n,attrs:{shape:X}});k.push(J);for(let oe of k)n.disposeIntermediateTensorInfo(oe);return ne}function Ene(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n,c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,c),f;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))f=Sx({x:o,filter:s,convInfo:m,backend:t});else if(U().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)f=_x({x:o,filter:s,convInfo:m,backend:t});else{let h=new qh(m);f=t.runWebGLProgram(h,[o,s],"float32")}let d=ie({inputs:{x:f},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(f),d}var IO={kernelName:uo,backendName:"webgl",kernelFunc:Ene};var d_=class{constructor(e){this.variableNames=["x","dy"];this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},h_=class{constructor(e){this.variableNames=["dy","W"];this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,u=n-1-e.padInfo.left,l=a?1:2,p=a?2:3,c=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},g_=class{constructor(e){this.variableNames=["x","dy"];this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},b_=class{constructor(e){this.variableNames=["dy","W"];this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=t-1-e.padInfo.front,l=n-1-e.padInfo.top,p=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Rne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:p}=n,c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,p,a,1,i,l,!1,c),f=new d_(m);return t.runWebGLProgram(f,[o,s],"float32")}var CO={kernelName:Zp,backendName:"webgl",kernelFunc:Rne};function Lne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n,c=I.convertConv2DDataFormat(l),m=I.computeConv2DInfo(a,s.shape,i,1,u,p,!1,c),f=new h_(m);return t.runWebGLProgram(f,[o,s],"float32")}var vO={kernelName:lo,backendName:"webgl",kernelFunc:Lne};function $ne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n,l=I.computeConv3DInfo(o.shape,s.shape,a,u,i),p=new m_(l);return t.runWebGLProgram(p,[o,s],"float32")}var wO={kernelName:Pu,backendName:"webgl",kernelFunc:$ne};function Bne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:u}=n,l=I.computeConv3DInfo(o.shape,u,a,1,i),p=new g_(l);return t.runWebGLProgram(p,[o,s],"float32")}var SO={kernelName:Jp,backendName:"webgl",kernelFunc:Bne};function One(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:u}=n,l=I.computeConv3DInfo(u,s.shape,i,1,a),p=new b_(l);return t.runWebGLProgram(p,[o,s],"float32")}var _O={kernelName:ec,backendName:"webgl",kernelFunc:One};var zne=Tx+`
  return cos(x);
`,Gne=Ae({opSnippet:zne}),AO={kernelName:po,backendName:"webgl",kernelFunc:Gne};var Wne=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,Une=Ae({opSnippet:Wne}),NO={kernelName:co,backendName:"webgl",kernelFunc:Une};var y_=class{constructor(e,t,n,o,s){this.variableNames=["Image","Boxes","BoxInd"];this.outputShape=[];let[a,i,u,l]=e,[p]=t,[c,m]=n;this.outputShape=[p,c,m,l];let f=o==="bilinear"?1:0,[d,h]=[`${i-1}.0`,`${u-1}.0`],[g,y,x]=c>1?[`${(i-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${d} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${d}`],[T,k,w]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${T});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${k};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${d} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${f} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Kne=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,p=new y_(o.shape,s.shape,i,u,l);return t.runWebGLProgram(p,[o,s,a],"float32")},DO={kernelName:Ys,backendName:"webgl",kernelFunc:Kne};var Ax=class{constructor(e,t,n){this.variableNames=["x"];this.customUniforms=[{name:"index",type:"float"}];this.outputShape=e;let o=e.length,s=t?"0.0":`getX(${PO(o,"coords")})`,a=e[e.length-1],i="",u="";t?(i=n?`end != ${a-1}`:"end != 0",u=n?"end + 1":"end - 1"):(i=n?`end + pow2 < ${a}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${He(o)} coords = getOutputCoords();
        int end = ${FO(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${i}) {
          int idx = ${u};
          ${FO(o,"coords")} = idx;
          val += getX(${PO(o,"coords")});
        }
        setOutput(val);
      }
    `}};function PO(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function FO(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function Vne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length,l=I.getAxesPermutation([s],u),p=o;l!=null&&(p=jt({inputs:{x:o},backend:t,attrs:{perm:l}}));let c=I.getInnerMostAxes(1,u)[0];if(c!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=p.shape[c],f=ir({inputs:{x:p},backend:t});for(let d=0;d<=Math.ceil(Math.log2(m))-1;d++){let h=new Ax(p.shape,!1,i),g=[[d]],y=f;f=t.runWebGLProgram(h,[f],f.dtype,g),t.disposeIntermediateTensorInfo(y)}if(a){let d=new Ax(p.shape,a,i),h=f;f=t.runWebGLProgram(d,[f],f.dtype),t.disposeIntermediateTensorInfo(h)}if(l!=null){let d=I.getUndoAxesPermutation(l),h=jt({inputs:{x:f},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(p),h}return f}var MO={kernelName:Xs,backendName:"webgl",kernelFunc:Vne};function jne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=hx(u,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=w$(u,l,a,i);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var EO={kernelName:tc,backendName:"webgl",kernelFunc:jne};var x_=class{constructor(e,t,n){this.variableNames=["x"];this.outputShape=[];this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Hne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],c=u*s,m=l*s,f=p/(s*s),d=a==="NHWC"?[i,c,m,f]:[i,f,c,m],h=new x_(d,s,a);return t.runWebGLProgram(h,[o],o.dtype)}var RO={kernelName:Qs,backendName:"webgl",kernelFunc:Hne};var Xh=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=e.outShape,this.enableShapeUniforms=tr(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,u=e.outChannels/e.inChannels,l="",p="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,p="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${p}
        setOutput(result);
      }
    `}};var Yh=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=e.outShape,this.enableShapeUniforms=tr(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,p=e.filterHeight,c=e.filterWidth,m=c,f=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<c;y++)f+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;f+=`
    for (int r = 0; r < ${p}; r++) {
      `;for(let y=0;y<c;y++)f+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;f+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(m+1)/2;y++){let x=y*2;if(f+=`
          xC = xCCorner + ${x*l};
          `,u===1){if(x<c&&(i%2==1?(f+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,l===1&&x>0?f+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:f+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):f+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<c)){let T=i%2==0?b.nearestLargerEven(l):l;l%2==0&&i%2==1||l%2!=0&&i%2!=1?(f+=`
                  xCOffset = xC + imod(pads[1], 2) + ${T};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,l>1&&(f+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                      xTexelC${x} = getX(batch, xR, xCOffset, d1);
                      xTexelC${x}Ready = 1;
                    }
                    `),f+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                  `):T===1?f+=`
                    xC${x+1} = xTexelC${x};
                    `:f+=`
                    xCOffset = xC + ${T};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<c&&(i%2==1?(f+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<c&&(f+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(f+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<c&&(f+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<c&&(f+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<c&&(f+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}f+=`
    }
  `,f+=`
      }
    `;let d="",h="";n&&(o?d=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?d=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:d=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${d}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${f}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function qne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:l}=n,p=u;p==null&&(p=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(a,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let c=I.computeConv2DInfo(o.shape,s.shape,a,p,i,l,!0),m;U().getBool("WEBGL_PACK_DEPTHWISECONV")&&c.strideWidth<=2&&c.outChannels/c.inChannels==1?m=new Yh(c):m=new Xh(c);let f=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];return t.runWebGLProgram(m,[o,s],"float32",f)}var LO={kernelName:mo,backendName:"webgl",kernelFunc:qne};var T_=class{constructor(e){this.variableNames=["x","dy"];this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},k_=class{constructor(e){this.variableNames=["dy","W"];this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Xne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,filterShape:p}=n,c=I.computeConv2DInfo(o.shape,p,a,i,u,l,!0),m=new T_(c);return t.runWebGLProgram(m,[o,s],"float32")}var $O={kernelName:rc,backendName:"webgl",kernelFunc:Xne};function Yne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,inputShape:p}=n,c=I.computeConv2DInfo(p,s.shape,a,i,u,l,!0),m=new k_(c);return t.runWebGLProgram(m,[o,s],"float32")}var BO={kernelName:nc,backendName:"webgl",kernelFunc:Yne};var I_=class{constructor(e){this.variableNames=["X"];this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Qne(r){let{inputs:e,backend:t}=r,{x:n}=e,o=[...n.shape,...n.shape],s=b.sizeFromShape(n.shape),a=ie({inputs:{x:n},backend:t,attrs:{shape:[s]}}),i=new I_(s),u=t.runWebGLProgram(i,[a],a.dtype),l=ie({inputs:{x:u},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),l}var OO={kernelName:oc,backendName:"webgl",kernelFunc:Qne};var C_=class{constructor(e){this.variableNames=["x","W"];this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:o,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:u,dilationHeight:l,dilationWidth:p}=e,{top:c,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${c}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Zne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n,l=I.computeDilation2DInfo(o.shape,s.shape,a,i,"NHWC",u),p,c=new C_(l);p=t.runWebGLProgram(c,[o,s],"float32");let m=ie({inputs:{x:p},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(p),m}var zO={kernelName:Fu,backendName:"webgl",kernelFunc:Zne};function Jne(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=I.decodeEinsumEquation(o,s.length);I.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=I.getEinsumComputePath(i,u),c=p.length,m=null,f=a.length,d=[];for(let h=0;h<c;++h){for(let g of p[h]){let{permutationIndices:y,expandDims:x}=I.getEinsumPermutation(f,u[g]),T;I.isIdentityPermutation(y)?T=s[g]:(T=jt({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),d.push(T));let k=T.shape.slice();for(let w=0;w<x.length;++w)k.splice(x[w],0,1);b.arraysEqual(T.shape,k)||(T=ie({inputs:{x:T},backend:t,attrs:{shape:k}}),d.push(T)),m===null?m=T:(m=Hh({inputs:{a:T,b:m},backend:t}),d.push(m))}h<c-1&&(l[h]>=0&&(m=wp({inputs:{x:m},backend:t,attrs:{axis:l[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var GO={kernelName:Mu,backendName:"webgl",kernelFunc:Jne};var eoe="return (x >= 0.0) ? x : (exp(x) - 1.0);",toe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,roe=Ae({opSnippet:eoe,packedOpSnippet:toe}),WO={kernelName:ho,backendName:"webgl",kernelFunc:roe};var noe="return (b >= 1.0) ? a : a * (b + 1.0);",ooe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,soe=r=>{let{inputs:e,backend:t}=r,{dy:n,y:o}=e,s=U().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new La(ooe,n.shape,o.shape):new Ks(noe,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)},UO={kernelName:sc,backendName:"webgl",kernelFunc:soe};var aoe=`
  return vec4(equal(a, b));
`,ioe="return float(a == b);",uoe=ft({opSnippet:ioe,packedOpSnippet:aoe,dtype:"bool",cpuKernelImpl:A$}),KO={kernelName:Zs,backendName:"webgl",kernelFunc:uoe};var loe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${I.ERF_P};
  float a1 = ${I.ERF_A1};
  float a2 = ${I.ERF_A2};
  float a3 = ${I.ERF_A3};
  float a4 = ${I.ERF_A4};
  float a5 = ${I.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,poe=Ae({opSnippet:loe}),VO={kernelName:Si,backendName:"webgl",kernelFunc:poe};var jO="return exp(x);",v_=Ae({opSnippet:jO,packedOpSnippet:jO,cpuKernelImpl:N$,dtype:"float32"}),HO={kernelName:go,backendName:"webgl",kernelFunc:v_};function Nx(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(b.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),ie({inputs:{x:s},backend:n,attrs:{shape:i}})}var qO={kernelName:ls,backendName:"webgl",kernelFunc:Nx};var XO="return exp(x) - 1.0;",coe=Ae({opSnippet:XO,packedOpSnippet:XO,cpuKernelImpl:D$}),YO={kernelName:Js,backendName:"webgl",kernelFunc:coe};var Dx=class{constructor(e,t,n){this.variableNames=["real","imag"];let o=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${o}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Px(r,e,t){let n=t.texData.get(r.dataId),o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=o/s,i=ie({inputs:{x:r},backend:t,attrs:{shape:[a,s]}}),u=i.shape,l=new Dx("real",u,e),p=new Dx("imag",u,e),c=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=t.runWebGLProgram(l,c,"float32"),f=t.runWebGLProgram(p,c,"float32"),d=Bn({inputs:{real:m,imag:f},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f);let h=ie({inputs:{x:d},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(d),h}function moe(r){let{inputs:e,backend:t}=r,{input:n}=e;return Px(n,!1,t)}var QO={kernelName:ac,backendName:"webgl",kernelFunc:moe};var w_=class{constructor(e,t){this.outputShape=[];this.customUniforms=[{name:"value",type:"float"}];this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function hu(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||b.inferDtype(o),s==="string"){let a=b.getArrayFromDType(s,b.sizeFromShape(n));return a.fill(o),e.makeTensorInfo(n,s,a)}else{let a=new w_(n,o),i=[[o]];return e.runWebGLProgram(a,[],s,i)}}var ZO={kernelName:Ua,backendName:"webgl",kernelFunc:hu};var S_=class{constructor(e){this.variableNames=["Image"];this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var JO={kernelName:ea,backendName:"webgl",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new S_(t.shape);return n.runWebGLProgram(o,[t],t.dtype)}};var ez="return floor(x);",foe=Ae({opSnippet:ez,packedOpSnippet:ez,cpuKernelImpl:P$}),tz={kernelName:bo,backendName:"webgl",kernelFunc:foe};var doe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,hoe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,goe=ft({opSnippet:doe,packedOpSnippet:hoe,dtype:"int32"}),rz={kernelName:yo,backendName:"webgl",kernelFunc:goe};var __=class{constructor(e){this.variableNames=["A"];let t=Zt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var A_=class{constructor(e){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;let t=Zt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var nz={kernelName:vl,backendName:"webgl",kernelFunc:boe},Lm;function boe(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n,a=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[u,l]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],p=[l,u],c=[l,u,s];(i||a)&&(Lm==null&&(Lm=document.createElement("canvas").getContext("2d")),Lm.canvas.width=u,Lm.canvas.height=l,Lm.drawImage(o,0,0,u,l),o=Lm.canvas);let m=t.makeTensorInfo(p,"int32");t.texData.get(m.dataId).usage=Yr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),o);let f=U().getBool("WEBGL_PACK")?new A_(c):new __(c),d=t.runWebGLProgram(f,[m],"int32");return t.disposeData(m.dataId),d}function yoe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=I.convertConv2DDataFormat(p),g=I.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!1,h),y,x=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))y=Sx({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:d});else if(U().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)y=_x({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:d});else{let k=a!=null,w=i!=null,P=f==="leakyrelu",A=f?ll(f,!1):null,F=new qh(g,k,A,w,P),E=[o,s];if(a&&E.push(a),i&&E.push(i),P){let $=t.makeTensorInfo([],"float32",b.createScalarValue(d,"float32"));E.push($),x.push($)}y=t.runWebGLProgram(F,E,"float32")}let T=ie({inputs:{x:y},backend:t,attrs:{shape:g.outShape}});return x.push(y),x.forEach(k=>t.disposeIntermediateTensorInfo(k)),T}var oz={kernelName:Cs,backendName:"webgl",kernelFunc:yoe};function xoe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:c,activation:m,leakyreluAlpha:f}=n,d=[],h=p;h==null&&(h=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=I.computeConv2DInfo(o.shape,s.shape,u,h,l,c,!0),y=U().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,x=m?ll(m,y):null,T=[o,s],k=a!=null,w=i!=null,P=m==="leakyrelu";if(k&&T.push(a),w&&T.push(i),P){let $=t.makeTensorInfo([],"float32",b.createScalarValue(f,"float32"));T.push($),d.push($)}let A;y?A=new Yh(g,k,x,w,P):A=new Xh(g,k,x,w,P);let F=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],E=t.runWebGLProgram(A,T,"float32",F);return d.forEach($=>t.disposeIntermediateTensorInfo($)),E}var sz={kernelName:vs,backendName:"webgl",kernelFunc:xoe};var N_=class{constructor(e,t,n){this.sliceDim=e;this.strides=t;this.variableNames=["x","indices"];this.outputShape=n;let o=He(t.length),s=He(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function Toe(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,a=s[s.length-1],i=b.sizeFromShape(n.shape),[u,l,p,c]=I.prepareAndValidate(n,o),m=ie({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),f=ie({inputs:{x:n},backend:t,attrs:{shape:[b.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let y=t.readSync(o.dataId),x=t.bufferSync(n),T=F$(y,x,n.dtype,l,a,p,c,n.shape,i);return t.makeTensorInfo(u,n.dtype,T.values)}let d=new N_(a,c,[l,p]),h=t.runWebGLProgram(d,[f,m],f.dtype),g=ie({inputs:{x:h},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var az={kernelName:ta,backendName:"webgl",kernelFunc:Toe};var D_=class{constructor(e,t){this.variableNames=["A","indices"];this.outputShape=t,this.rank=t.length;let n=He(this.rank),o=koe(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function koe(r,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("int(getIndices(resRC.x, resRC.z))"):n.push(`${t[o]}`);return n.join()}function P_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,u=b.parseAxisParam(a,o.shape)[0],l=t.readSync(s.dataId),p=o.shape[u];for(let k=0;k<l.length;++k){let w=l[k];b.assert(w<=p-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${p-1}]`)}let c=I.segment_util.collectGatherOpShapeInfo(o,s,u,i),m=b.sizeFromShape(s.shape),f=[],d=ie({inputs:{x:o},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),h=ie({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,m/c.batchSize]}});f.push(d),f.push(h);let g=[c.batchSize,c.outerSize,m/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let k=t.bufferSync(h),w=t.bufferSync(d),P=M$(w,k,g);return f.forEach(A=>t.disposeIntermediateTensorInfo(A)),t.makeTensorInfo(c.outputShape,P.dtype,P.values)}let y=new D_(d.shape,g),x=t.runWebGLProgram(y,[d,h],d.dtype);f.push(x);let T=ie({inputs:{x},backend:t,attrs:{shape:c.outputShape}});return f.forEach(k=>t.disposeIntermediateTensorInfo(k)),T}var iz={kernelName:ps,backendName:"webgl",kernelFunc:P_};var Ioe="return float(a > b);",Coe=`
  return vec4(greaterThan(a, b));
`,voe=ft({opSnippet:Ioe,packedOpSnippet:Coe,cpuKernelImpl:E$,dtype:"bool"}),uz={kernelName:ra,backendName:"webgl",kernelFunc:voe};var woe="return float(a >= b);",Soe=`
  return vec4(greaterThanEqual(a, b));
`,_oe=ft({opSnippet:woe,packedOpSnippet:Soe,dtype:"bool",cpuKernelImpl:R$}),lz={kernelName:To,backendName:"webgl",kernelFunc:_oe};function Aoe(r){let{inputs:e,backend:t}=r,{input:n}=e;return Px(n,!0,t)}var pz={kernelName:ic,backendName:"webgl",kernelFunc:Aoe};var Noe="return float(!isnan(x) && !isinf(x));",Doe=Ae({opSnippet:Noe,dtype:"bool"}),cz={kernelName:_i,backendName:"webgl",kernelFunc:Doe};var Poe="return float(isinf(x));",Foe=Ae({opSnippet:Poe,dtype:"bool"}),mz={kernelName:Ai,backendName:"webgl",kernelFunc:Foe};var Moe="return float(isnan(x));",Eoe=Ae({opSnippet:Moe,dtype:"bool"}),fz={kernelName:Ni,backendName:"webgl",kernelFunc:Eoe};var Roe="return float(a < b);",Loe=`
  return vec4(lessThan(a, b));
`,$oe=ft({opSnippet:Roe,packedOpSnippet:Loe,cpuKernelImpl:L$,dtype:"bool"}),dz={kernelName:oa,backendName:"webgl",kernelFunc:$oe};var Boe="return float(a <= b);",Ooe=`
  return vec4(lessThanEqual(a, b));
`,zoe=ft({opSnippet:Boe,packedOpSnippet:Ooe,cpuKernelImpl:$$,dtype:"bool"}),hz={kernelName:sa,backendName:"webgl",kernelFunc:zoe};function Goe(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=B$(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var gz={kernelName:uc,backendName:"webgl",kernelFunc:Goe};var Woe=`if (x < 0.0) return NAN;
  return log(x);`,Uoe=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,Koe=Ae({opSnippet:Woe,packedOpSnippet:Uoe,cpuKernelImpl:O$}),bz={kernelName:ko,backendName:"webgl",kernelFunc:Koe};var Voe="return log(1.0 + x);",joe=Ae({opSnippet:Voe}),yz={kernelName:Di,backendName:"webgl",kernelFunc:joe};var Hoe="return float(a >= 1.0 && b >= 1.0);",qoe=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Xoe=ft({opSnippet:Hoe,packedOpSnippet:qoe,dtype:"bool"}),xz={kernelName:aa,backendName:"webgl",kernelFunc:Xoe};var Yoe="return float(!(x >= 1.0));",Qoe=Ae({opSnippet:Yoe}),Tz={kernelName:Pi,backendName:"webgl",kernelFunc:Qoe};var Zoe="return float(a >= 1.0 || b >= 1.0);",Joe=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,ese=ft({opSnippet:Zoe,packedOpSnippet:Joe,dtype:"bool"}),kz={kernelName:Cl,backendName:"webgl",kernelFunc:ese};var F_=class{constructor(e,t,n,o,s){this.variableNames=["x"];this.outputShape=[];let a=t,i=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var M_=class{constructor(e,t,n,o,s){this.variableNames=["x"];this.outputShape=[];this.packedInputs=!0;this.packedOutput=!0;let a=t,i=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var tse=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:u}=n,l=U().getBool("WEBGL_PACK_NORMALIZATION")?new M_(o.shape,s,a,i,u):new F_(o.shape,s,a,i,u);return t.runWebGLProgram(l,[o],o.dtype)},Iz={kernelName:Ru,backendName:"webgl",kernelFunc:tse};var E_=class{constructor(e,t,n,o,s){this.variableNames=["inputImage","outputImage","dy"];this.outputShape=[];this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var rse=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:u,alpha:l,beta:p}=n,c=new E_(o.shape,i,u,l,p);return t.runWebGLProgram(c,[o,s,a],o.dtype)},Cz={kernelName:lc,backendName:"webgl",kernelFunc:rse};function vz(r,e,t,n){let o=b.sizeFromShape(e),a=b.sizeFromShape(r.shape)/o,i=ie({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=Jn(i,r.dtype,"max",n),l=ie({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}function R_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,i),c=p!=null,m=t.shouldExecuteOnCPU([o]),f=o;if(c){if(m){let T=t.texData.get(f.dataId).values,k=new Array(i);for(let A=0;A<k.length;A++)k[A]=o.shape[p[A]];let w=vp(T,o.shape,o.dtype,p,k);f=t.makeTensorInfo(k,o.dtype);let P=t.texData.get(f.dataId);P.values=w}else f=pl(o,p,t);l=I.getInnerMostAxes(l.length,i)}I.assertAxesAreInnerMostDims("max",l,i);let[d,h]=I.computeOutAndReduceShapes(f.shape,l),g=d;a&&(g=I.expandShapeToKeepDim(d,u));let y;if(m){let T=t.texData.get(f.dataId).values,k=z$(T,b.sizeFromShape(h),g,o.dtype);y=t.makeTensorInfo(g,o.dtype);let w=t.texData.get(y.dataId);w.values=k}else y=vz(f,h,g,t);return c&&t.disposeIntermediateTensorInfo(f),y}var wz={kernelName:Io,backendName:"webgl",kernelFunc:R_};var nse=xx+`
  return max(a, b);
`,ose=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+ul+`
  return result;
`,sse=ft({opSnippet:nse,packedOpSnippet:ose,cpuKernelImpl:G$}),Sz={kernelName:Co,backendName:"webgl",kernelFunc:sse};function ase(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;Ma(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,a,l,i,u);if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))return ir({inputs:{x:o},backend:t});let c=new ui(p,"max",!1);return t.runWebGLProgram(c,[o],o.dtype)}var _z={kernelName:vo,backendName:"webgl",kernelFunc:ase};function ise(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dataFormat:u,dimRoundingMode:l}=n,p=[1,1,1],c=I.computePool3DInfo(o.shape,s,a,p,i,l,u),m=new _p(c,"max",!1);return t.runWebGLProgram(m,[o],o.dtype)}var Az={kernelName:Lu,backendName:"webgl",kernelFunc:ise};var L_=class{constructor(e){this.variableNames=["dy","maxPos"];this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,u=a-1-e.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},$_=class{constructor(e){this.variableNames=["dy","maxPos"];this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,c=u-1-e.padInfo.front,m=l-1-e.padInfo.top,f=p-1-e.padInfo.left,d=u*l*p-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${m}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${d} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function use(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:p}=n,c=[1,1,1],m=I.computePool3DInfo(a.shape,i,u,c,l,p),f=new _p(m,"max",!0),d=t.runWebGLProgram(f,[a],a.dtype),h=new $_(m),g=t.runWebGLProgram(h,[o,d],a.dtype);return t.disposeIntermediateTensorInfo(d),g}var Nz={kernelName:cc,backendName:"webgl",kernelFunc:use};function lse(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;Ma([s,a],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:c}=n,m=I.computePool2DInfo(i.shape,u,l,1,p,c),f=!0,d=new ui(m,"max",f),h=t.runWebGLProgram(d,[i],i.dtype),g=new L_(m),y=t.runWebGLProgram(g,[o,h],i.dtype);return t.disposeIntermediateTensorInfo(h),y}var Dz={kernelName:pc,backendName:"webgl",kernelFunc:lse};function Pz(r,e,t,n){let o=new ui(t,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new ui(t,"max",!0,!0,e);let a=n.runWebGLProgram(o,[r],"float32");return[s,a]}var Fz={kernelName:mc,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,u=t;b.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];b.assert(I.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let p=I.computePool2DInfo(n.shape,o,s,l,a),[c,m]=Pz(n,i,p,u);return[c,m]}};function Mz(r,e,t,n){let o=b.sizeFromShape(e),a=b.sizeFromShape(r.shape)/o,i=ie({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=Jn(i,"float32","mean",n),l=ie({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}var Ez={kernelName:wo,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{keepDims:o,axis:s}=e,a=t,i=n.shape.length,u=b.parseAxisParam(s,n.shape),l=u,p=I.getAxesPermutation(l,i),c=p!=null,m=a.shouldExecuteOnCPU([n]),f=[],d=n;if(c){if(m){let k=a.texData.get(d.dataId).values,w=new Array(i);for(let F=0;F<w.length;F++)w[F]=n.shape[p[F]];let P=vp(k,n.shape,n.dtype,p,w);d=a.makeTensorInfo(w,n.dtype);let A=a.texData.get(d.dataId);A.values=P}else d=pl(n,p,a);f.push(d),l=I.getInnerMostAxes(l.length,i)}I.assertAxesAreInnerMostDims("sum",l,i);let[h,g]=I.computeOutAndReduceShapes(d.shape,l),y=h;o&&(y=I.expandShapeToKeepDim(h,u));let x=Mz(d,g,y,a);for(let T of f)a.disposeIntermediateTensorInfo(T);return x}};function pse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,i),c=o;p!=null&&(c=jt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=I.getInnerMostAxes(l.length,o.shape.length)),I.assertAxesAreInnerMostDims("min",l,i);let[m,f]=I.computeOutAndReduceShapes(c.shape,l),d=b.sizeFromShape(f),h=ie({inputs:{x:c},backend:t,attrs:{shape:[-1,d]}}),g=Jn(h,h.dtype,"min",t),y;if(a){let x=I.expandShapeToKeepDim(m,u);y=ie({inputs:{x:g},backend:t,attrs:{shape:x}})}else y=ie({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(c),y}var Rz={kernelName:So,backendName:"webgl",kernelFunc:pse};var cse=xx+`
  return min(a, b);
`,mse=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+ul+`
  return result;
`,fse=ft({opSnippet:cse,packedOpSnippet:mse,cpuKernelImpl:W$}),Lz={kernelName:_o,backendName:"webgl",kernelFunc:fse};var B_=class{constructor(e,t,n){this.variableNames=["x"];this.outputShape=t.map((p,c)=>p[0]+e[c]+p[1]);let o=e.length,s=He(o),a=t.map(p=>p[0]).join(","),i=t.map((p,c)=>p[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var O_=class{constructor(e,t,n){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=t.map((d,h)=>d[0]+e[h]+d[1]);let o=e.length,s=He(o),a=t.map(d=>d[0]).join(","),i=t.map((d,h)=>d[0]+e[h]).join(","),u=ar("rc",o),l=ar("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,c=o===1?"source":`vec2(${l.slice(-2).join()})`,m=n==="reflect"?0:1,f="";if(o===1){let d=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${u[o-1]} += 1;
        if(${p}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let d=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;f=`
        ${s} rc = outputLoc;
        ${d}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${u[o-1]} += 1;
        if(${p}) {
          ${d}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${d}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${u[o-1]} += 1;
          if(${p}) {
            ${d}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var dse=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{paddings:o,mode:s}=t,a=U().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new O_(n.shape,o,s):new B_(n.shape,o,s);return e.runWebGLProgram(a,[n],n.dtype)},$z={kernelName:Ao,backendName:"webgl",kernelFunc:dse};var hse=`if (b == 0.0) return NAN;
  return mod(a, b);`,gse=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+ul+`
  return result;
`,bse=ft({opSnippet:hse,packedOpSnippet:gse}),Bz={kernelName:Fi,backendName:"webgl",kernelFunc:bse};var z_=class{constructor(e,t,n){this.variableNames=["probs"];this.customUniforms=[{name:"seed",type:"float"}];this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};var yse=`
if (a == b) {
  return 1.0;
};
return a / b;`,xse=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,G_=ft({opSnippet:yse,packedOpSnippet:xse,checkOutOfBounds:!0}),Oz={kernelName:fo,backendName:"webgl",kernelFunc:G_};var zz="return a - b;",W_=ft({opSnippet:zz,packedOpSnippet:zz,supportsComplex:!0,cpuKernelImpl:oB}),Gz={kernelName:Uo,backendName:"webgl",kernelFunc:W_};function U_(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=b.parseAxisParam([s],o.shape),i=R_({inputs:{x:o},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=I.expandShapeToKeepDim(i.shape,a),l=ie({inputs:{x:i},backend:t,attrs:{shape:u}}),p=W_({inputs:{a:o,b:l},backend:t}),c=v_({inputs:{x:p},backend:t}),m=wp({inputs:{x:c},backend:t,attrs:{axis:a,keepDims:!1}}),f=ie({inputs:{x:m},backend:t,attrs:{shape:u}}),d=G_({inputs:{a:c,b:f},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(f),d}var Wz={kernelName:Go,backendName:"webgl",kernelFunc:U_};function Tse(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n,u=i?o:U_({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),l=u.shape[0],p=u.shape[1],c=new z_(l,p,s),m=[[a]],f=t.runWebGLProgram(c,[u],"int32",m);return i||t.disposeIntermediateTensorInfo(u),f}var Uz={kernelName:fc,backendName:"webgl",kernelFunc:Tse};var Kz="return -x;";function kse(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.texData.get(n.dataId),[a,i]=K$(s.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,a)}let o;return U().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Ra(n.shape,Kz):o=new $n(n.shape,Kz),t.runWebGLProgram(o,[n],n.dtype)}var Vz={kernelName:cs,backendName:"webgl",kernelFunc:kse};var Ise=Tr.nonMaxSuppressionV3Impl;function Cse(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:c}=Ise(l,p,a,i,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}var jz={kernelName:ua,backendName:"webgl",kernelFunc:Cse};var vse=Tr.nonMaxSuppressionV4Impl;function wse(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n,p=t.readSync(o.dataId),c=t.readSync(s.dataId),{selectedIndices:m,validOutputs:f}=vse(p,c,a,i,u,l);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([f]))]}var Hz={kernelName:Mi,backendName:"webgl",kernelFunc:wse};var Sse=Tr.nonMaxSuppressionV5Impl;function _se(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),c=t.readSync(s.dataId),m=a,f=i,d=u,h=l,{selectedIndices:g,selectedScores:y}=Sse(p,c,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var qz={kernelName:la,backendName:"webgl",kernelFunc:_se};var K_=class{constructor(e,t,n,o){this.variableNames=["indices"];this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var Ase=r=>{let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:a,offValue:i}=n,u=b.sizeFromShape(o.shape),l=new K_(u,s,a,i),p=ie({inputs:{x:o},backend:t,attrs:{shape:[u]}}),c=t.runWebGLProgram(l,[p],o.dtype);t.disposeIntermediateTensorInfo(p);let m=[...o.shape,s],f=ie({inputs:{x:c},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(c),f},Xz={kernelName:pa,backendName:"webgl",kernelFunc:Ase};function Qh(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=du({inputs:{input:n},backend:t}),s=Qh({inputs:{x:o},backend:t}),a=Ap({inputs:{input:n},backend:t}),i=Qh({inputs:{x:a},backend:t}),u=Bn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return hu({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var Yz={kernelName:Ts,backendName:"webgl",kernelFunc:Qh};function Qz(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=du({inputs:{input:n},backend:t}),s=Qz({inputs:{x:o},backend:t}),a=Ap({inputs:{input:n},backend:t}),i=Qh({inputs:{x:a},backend:t}),u=Bn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return hu({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var Zz={kernelName:ms,backendName:"webgl",kernelFunc:Qz};function Nse(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return Nx({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let c=Nx({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(c),c}),l=c_({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var Jz={kernelName:fs,backendName:"webgl",kernelFunc:Nse};var V_=class{constructor(e,t,n){this.variableNames=["x"];this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map((l,p)=>l[0]+e[p]+l[1]);let o=e.length,s=He(o),a=t.map(l=>l[0]).join(","),i=t.map((l,p)=>l[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var j_=class{constructor(e,t,n){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=He(o),a=t.map(h=>h[0]).join(","),i=t.map((h,g)=>h[0]+e[g]).join(","),u=ar("rc",o),l=ar("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,c=o===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${p}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${p}) {`],f=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",d="";for(let h=0,g=o===1?2:4;h<g;h++)d+=`
        ${m[h]}
        if (${f}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${c});
        }
      `;d+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var H_=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;if(b.sizeFromShape(o.shape)===0){let l=s.map((p,c)=>p[0]+o.shape[c]+p[1]);return hu({backend:t,attrs:{shape:l,value:a,dtype:o.dtype}})}let i=U().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new j_(o.shape,s,a):new V_(o.shape,s,a),u=[[a]];return t.runWebGLProgram(i,[o],o.dtype,u)},e3={kernelName:Do,backendName:"webgl",kernelFunc:H_};var Dse=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Pse=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+ul+`
  return result;
`,Fse=ft({opSnippet:Dse,packedOpSnippet:Pse}),t3={kernelName:Po,backendName:"webgl",kernelFunc:Fse};function Mse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=[],l=b.parseAxisParam(s,o.shape),p=l,c=I.getAxesPermutation(p,i),m=o;c!=null&&(m=jt({inputs:{x:o},backend:t,attrs:{perm:c}}),p=I.getInnerMostAxes(p.length,i),u.push(m)),I.assertAxesAreInnerMostDims("prod",p,i);let f;if(t.shouldExecuteOnCPU([m])){let d=t.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:y}=j$(m.shape,m.dtype,d,p);f=t.makeTensorInfo(g,y,h)}else{let[d,h]=I.computeOutAndReduceShapes(m.shape,p),g=b.sizeFromShape(h),y=ie({inputs:{x:m},backend:t,attrs:{shape:[-1,g]}}),x=zi(o.dtype),T=Jn(y,x,"prod",t);f=ie({inputs:{x:T},backend:t,attrs:{shape:d}}),u.push(y),u.push(T)}if(a){u.push(f);let d=I.expandShapeToKeepDim(f.shape,l);f=ie({inputs:{x:f},backend:t,attrs:{shape:d}})}return u.forEach(d=>t.disposeIntermediateTensorInfo(d)),f}var r3={kernelName:ca,backendName:"webgl",kernelFunc:Mse};var q_=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=H$(n,o,s,a);return e.makeTensorInfo([i.length],a,i)},n3={kernelName:Ka,backendName:"webgl",kernelFunc:q_};var Ese="return 1.0 / x;",Rse=Ae({opSnippet:Ese}),o3={kernelName:Ei,backendName:"webgl",kernelFunc:Rse};var Lse=Dr+`
  return (x < 0.0) ? 0.0 : x;
`,$se=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bse=Ae({opSnippet:Lse,packedOpSnippet:$se}),s3={kernelName:Mo,backendName:"webgl",kernelFunc:Bse};var Ose=Dr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,zse=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Gse=Ae({opSnippet:Ose,packedOpSnippet:zse}),a3={kernelName:Ro,backendName:"webgl",kernelFunc:Gse};var X_=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.outputShape=[];let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/c[0]},
          ${p[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var Y_=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/c[0]},
          ${p[1]/c[1]},
          ${p[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Wse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=U().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Y_(o.shape,u,l,s,a):new X_(o.shape,u,l,s,a);return t.runWebGLProgram(p,[o],"float32")}var i3={kernelName:Eo,backendName:"webgl",kernelFunc:Wse};var Q_=class{constructor(e,t,n){this.variableNames=["dy"];this.outputShape=[];this.outputShape=t;let[,o,s]=t,[,a,i]=e,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],p=u[0]/l[0],c=u[1]/l[1],m=1/p,f=1/c,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${c});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Use(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new Q_(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var u3={kernelName:hc,backendName:"webgl",kernelFunc:Use};var Z_=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.outputShape=[];let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/c[0]},
          ${p[1]/c[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var J_=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m=o?"0.5":"0.0",f;s?f="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/c[0]},
          ${p[1]/c[1]},
          ${p[1]/c[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Kse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=U().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new J_(o.shape,u,l,s,a):new Z_(o.shape,u,l,s,a);return t.runWebGLProgram(p,[o],o.dtype)}var l3={kernelName:Va,backendName:"webgl",kernelFunc:Kse};var eA=class{constructor(e,t,n){this.variableNames=["dy"];this.outputShape=[];this.outputShape=t;let[,o,s]=t,[,a,i]=e,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],p=u[0]/l[0],c=u[1]/l[1],m=1/p,f=1/c,d=Math.ceil(m)*2+2,h=Math.ceil(f)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${c});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${f});

        const int winHeight = int(${d});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Vse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new eA(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var p3={kernelName:dc,backendName:"webgl",kernelFunc:Vse};var tA=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,u)=>o(u)).join(","),a=He(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var rA=class{constructor(e,t){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let o=ar("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,i=He(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${a}) {
            result.b = ${p(o.slice())};
            if(${s}) {
              result.a = ${c(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(d){return m(d)}function l(d){return d[n-1]="("+d[n-1]+" + 1)",m(d)}function p(d){return d[n-2]="("+d[n-2]+" + 1)",m(d)}function c(d){return d[n-1]="("+d[n-1]+" + 1)",d[n-2]="("+d[n-2]+" + 1)",m(d)}function m(d){let h=e.map((x,T)=>f(T,d)),g=h.join(","),y=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${y}))`}function f(d,h){return t.indexOf(d)!==-1&&e[d]!==1?`${e[d]} - ${h[d]} - 1`:`${h[d]}`}}};function jse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=o.shape.length,i=b.parseAxisParam(s,o.shape);if(a===0)return ir({inputs:{x:o},backend:t});let u=U().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rA(o.shape,i):new tA(o.shape,i);return t.runWebGLProgram(u,[o],o.dtype)}var c3={kernelName:ma,backendName:"webgl",kernelFunc:jse};var nA=class{constructor(e,t){this.variableNames=["Image"];this.outputShape=[];this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var m3={kernelName:xa,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=new nA(n.shape,s),[l,p]=I.getImageCenter(a,n.shape[1],n.shape[2]),c=[[l,p,Math.sin(o),Math.cos(o)]];return i.runWebGLProgram(u,[n],n.dtype,c)}};var Hse=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,qse=Ae({opSnippet:Hse}),f3={kernelName:fa,backendName:"webgl",kernelFunc:qse};var Xse="return inversesqrt(x);",Yse=Ae({opSnippet:Xse,cpuKernelImpl:q$}),d3={kernelName:Lo,backendName:"webgl",kernelFunc:Yse};var Zh=class{constructor(e,t,n,o,s,a,i=!0){this.variableNames=["updates","indices","defaultValue"];this.outputShape=a;let u=He(s.length),l=He(a.length),p="";n===1?p="i":n===2&&(p="i, j");let c=`getIndices(${p})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let f=`getUpdates(${m})`,d=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c});
              flattenedIndex += index * ${d};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${f};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Qse(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:c}=I.calculateShapes(s,o,a),m=[c/l,l];if(c===0)return t.makeTensorInfo(a,o.dtype);let f=ie({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),d=ie({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new Zh(u,i,f.shape.length,d.shape.length,p,m),y=t.runWebGLProgram(g,[d,f,h],d.dtype),x=ie({inputs:{x:y},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(h),x}var h3={kernelName:da,backendName:"webgl",kernelFunc:Qse};var oA=class{constructor(e,t,n){this.variableNames=["c","a","b"];this.outputShape=t;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let p=0;p<t.length;p++)l.push(`${i[p]}`),p<e&&u.push(`${i[p]}`);o=u.join(),s=l.join()}let a=He(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Zse(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=new oA(n.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(a,[n,o,s],Ut(o.dtype,s.dtype))}var g3={kernelName:hs,backendName:"webgl",kernelFunc:Zse};var Jse=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${I.SELU_SCALEALPHA};
  float scale = ${I.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,eae=Ae({opSnippet:Jse}),b3={kernelName:Ri,backendName:"webgl",kernelFunc:eae};var y3="return 1.0 / (1.0 + exp(-1.0 * x));",tae=Ae({opSnippet:y3,packedOpSnippet:y3,cpuKernelImpl:X$}),x3={kernelName:Bo,backendName:"webgl",kernelFunc:tae};var rae=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,nae=Ae({opSnippet:rae}),T3={kernelName:Li,backendName:"webgl",kernelFunc:nae};var oae=Tx+`
  return sin(x);
`,sae=Ae({opSnippet:oae}),k3={kernelName:$o,backendName:"webgl",kernelFunc:sae};var aae=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,iae=Ae({opSnippet:aae}),I3={kernelName:ha,backendName:"webgl",kernelFunc:iae};var uae=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,lae=Ae({opSnippet:uae}),C3={kernelName:$i,backendName:"webgl",kernelFunc:lae};var pae=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((y,x)=>y*x),u=[[0,0]];u.push(...a);for(let y=1+s.length;y<o.shape.length;++y)u.push([0,0]);let l=[],p=H_({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),c=I.getReshaped(p.shape,s,i,!1),m=I.getPermuted(c.length,s.length,!1),f=I.getReshapedPermuted(p.shape,s,i,!1),d=ie({inputs:{x:p},backend:t,attrs:{shape:c}}),h=jt({inputs:{x:d},backend:t,attrs:{perm:m}}),g=ie({inputs:{x:h},backend:t,attrs:{shape:f}});return l.push(p),l.push(d),l.push(h),l.forEach(y=>t.disposeIntermediateTensorInfo(y)),g},v3={kernelName:bs,backendName:"webgl",kernelFunc:pae};function cae(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.readSync(n.dataId),u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=t.readSync(a.dataId)[0],[c,m,f,d,h]=Q$(i,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(m,n.dtype,c),t.makeTensorInfo([m[0]],o.dtype,f),t.makeTensorInfo([d.length],"bool",new Uint8Array(d.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var w3={kernelName:gc,backendName:"webgl",kernelFunc:cae};function mae(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.readSync(o.dataId)),i=t.readSync(n.dataId),u=Array.from(t.readSync(s.dataId)),[l,p,c]=Z$(i,n.shape,n.dtype,a,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var S3={kernelName:bc,backendName:"webgl",kernelFunc:mae};function fae(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=bx(a,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var _3={kernelName:yc,backendName:"webgl",kernelFunc:fae};function dae(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=bx(a,n.shape,n.dtype,i,u);return t.makeTensorInfo(p,n.dtype,l)}var A3={kernelName:xc,backendName:"webgl",kernelFunc:dae};function hae(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,strides:p,outputSize:c}=I.calculateShapes(s,o,i),m=!1,f=new Zh(l,u,o.shape.length,s.shape.length,p,[c,1],m),d=t.runWebGLProgram(f,[s,o,a],s.dtype),h=ie({inputs:{x:d},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(d),h}var N3={kernelName:Bu,backendName:"webgl",kernelFunc:hae};function gae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=b.parseAxisParam(a,o.shape)[0],u=I.prepareSplitSize(o,s,i),l=o.shape.length,p=new Array(l).fill(0),c=o.shape.slice();return u.map(m=>{let f=[...c];f[i]=m;let d=$a({inputs:{x:o},backend:t,attrs:{begin:p,size:f}});return p[i]+=m,d})}var D3={kernelName:ys,backendName:"webgl",kernelFunc:gae};var P3="return sqrt(x);",bae=Ae({opSnippet:P3,packedOpSnippet:P3,cpuKernelImpl:J$}),F3={kernelName:Oo,backendName:"webgl",kernelFunc:bae};var yae="return x * x;",xae=Ae({opSnippet:yae}),M3={kernelName:ja,backendName:"webgl",kernelFunc:xae};var E3="return (a - b) * (a - b);",Tae=ft({opSnippet:E3,packedOpSnippet:E3}),R3={kernelName:Wo,backendName:"webgl",kernelFunc:Tae};function kae({inputs:r,attrs:e,backend:t}){let{x:n}=r,o=Dr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new $n(n.shape,o);return t.runWebGLProgram(s,[n],n.dtype)}var L3={kernelName:ks,backendName:"webgl",kernelFunc:kae};var sA=class{constructor(e,t,n){this.variableNames=["x"];this.outputShape=n;let o=n.length,s=He(n.length),a=He(n.length),i="";if(o===1)i="coords * strides + begin";else{let u=0;i=n.map((l,p)=>(u++,n.length===1?`coords * strides[${p}] + begin[${p}]`:`coords[${u-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function Iae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n,{nonStrided:f,$begin:d,$strides:h,size:g,newShape:y,outShape:x}=Xt.sliceInfo(o.shape,s,a,i,u,l,p,c,m),T=ie({inputs:{x:o},backend:t,attrs:{shape:y}}),k;if(f){let P=$a({inputs:{x:T},backend:t,attrs:{begin:d,size:g}});k=ie({inputs:{x:P},backend:t,attrs:{shape:x}}),t.disposeIntermediateTensorInfo(P)}else if(x.some(P=>P===0))k=t.makeTensorInfo(x,o.dtype,[]);else if(t.shouldExecuteOnCPU([T])){let F=t.texData.get(T.dataId).values,E=Ce(T.shape,T.dtype,F),$=eB(x,E,h,d);k=t.makeTensorInfo(x,T.dtype,$.values)}else{let A=new sA(d,h,x);k=t.runWebGLProgram(A,[T],T.dtype)}let w=ie({inputs:{x:k},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(k),w}var $3={kernelName:ga,backendName:"webgl",kernelFunc:Iae};function Cae(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:c}=e,m=t.readSync(p.dataId),f=t.readSync(c.dataId),[d,h]=tB(m,f,o,s,a,i,u,l);return[t.makeTensorInfo([d.length],"string",d),t.makeTensorInfo(c.shape,"int32",h)]}var B3={kernelName:Ou,backendName:"webgl",kernelFunc:Cae};function vae(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.readSync(s.dataId),u=t.readSync(a.dataId)[0],[l,p,c]=rB(i,u,o),m=p.length;return[t.makeTensorInfo([m,2],"int32",l),t.makeTensorInfo([m],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(c))]}var O3={kernelName:Tc,backendName:"webgl",kernelFunc:vae};function wae(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=t.readSync(s.dataId),i=nB(a,o);return t.makeTensorInfo(s.shape,"int32",i)}var z3={kernelName:kc,backendName:"webgl",kernelFunc:wae};var Sae="return tan(x);",_ae=Ae({opSnippet:Sae}),G3={kernelName:ba,backendName:"webgl",kernelFunc:_ae};var Aae=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Nae=Ae({opSnippet:Aae}),W3={kernelName:Ko,backendName:"webgl",kernelFunc:Nae};var aA=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let o=He(this.rank),s=Dae(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Dae(r){let e=r.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${r[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${t[o]}, ${r[o]})`);return n.join()}function iA(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>b.decodeString(m)):u,p=Ce(o.shape,o.dtype,l),c=sB(p,s);return t.makeTensorInfo(c.shape,c.dtype,c.values)}let a=new aA(o.shape,s);return t.runWebGLProgram(a,[o],o.dtype)}var U3={kernelName:An,backendName:"webgl",kernelFunc:iA};var uA=class{constructor(e){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}];this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},lA=class{constructor(e){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}];this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function Dp(r,e){e!==null&&r.disposeIntermediateTensorInfo(e)}function K3(r){let e=1;for(;e<r;)e*=2;return e}function Pae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n,i=U().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=U().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,p=l[l.length-1];if(t.shouldExecuteOnCPU([o])||p<i||s>u){let $=t.readSync(o.dataId),[W,K]=aB($,l,o.dtype,s,a);return[t.makeTensorInfo(W.shape,W.dtype,W.values),t.makeTensorInfo(K.shape,K.dtype,K.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,o.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(p===1)return[o,hu({attrs:{shape:l,dtype:"int32",value:0},backend:t})];let c=t.texData.get(o.dataId),m=c!==null&&c.isPacked,f=m?t.unpackTensor(o):o,h=b.sizeFromShape(l)/p,g=ie({inputs:{x:f},attrs:{shape:[h,p]},backend:t});m&&Dp(t,f);let y=K3(s),x=K3(p),T=null,k=()=>T===null?[g,g]:[g,T],w=($,W,K)=>{let B=k(),V=new uA(K),H=[[p],[T===null?1:0],[Number.NEGATIVE_INFINITY],[$],[W]],J=T;T=t.runWebGLProgram(V,B,"int32",H),Dp(t,J)};for(let $=1;$<y;$*=2){let W=$*2;for(let K=$;K>=1;K/=2)w(W,K,[h,x])}for(let $=x;$>y;$/=2){let W=k(),K=new lA([h,$/2]),V=[[p],[T===null?1:0],[y]],j=T;T=t.runWebGLProgram(K,W,"int32",V),Dp(t,j);let H=y/2,J=H*2;for(let X=H;X>=1;X/=2)w(J,X,T.shape)}let P=T;T=$a({inputs:{x:T},backend:t,attrs:{begin:0,size:[h,s]}}),Dp(t,P);let A=P_({inputs:{x:g,indices:T},backend:t,attrs:{axis:1,batchDims:1}});Dp(t,g);let F=l.slice(0,-1);F.push(s),P=T,T=ie({inputs:{x:T},attrs:{shape:F},backend:t}),Dp(t,P);let E=A;return A=ie({inputs:{x:A},attrs:{shape:F},backend:t}),Dp(t,E),[A,T]}var V3={kernelName:Bi,backendName:"webgl",kernelFunc:Pae};var pA=class{constructor(e,t,n,o,s,a){this.variableNames=["Image","Transforms"];this.outputShape=a;let i=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Fae(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,c,m,f]=o.shape,[d,h]=l??[c,m],g=[p,d,h,f],y=new pA(c,m,a,i,u,g);return t.runWebGLProgram(y,[o,s],"float32")}var j3={kernelName:ya,backendName:"webgl",kernelFunc:Fae};function Mae(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;Ma(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=n.readSync(s.dataId),{outputValues:i,outputShape:u,indices:l}=iB(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}var H3={kernelName:Ic,backendName:"webgl",kernelFunc:Mae};function Eae(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],l=new Array(i-1),p=0;for(let h=0;h<i;h++)h!==s&&(l[p++]=a.shape[h]);let c=[],m=new Array(i).fill(0),f=a.shape.slice();f[s]=1;let d=new Array(u);for(let h=0;h<d.length;h++){m[s]=h;let g=$a({inputs:{x:a},backend:t,attrs:{begin:m,size:f}}),y=ie({inputs:{x:g},backend:t,attrs:{shape:l}});d[h]=y,c.push(g)}return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),d}var q3={kernelName:xs,backendName:"webgl",kernelFunc:Eae};var cA=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,o=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[o,i];let u="0.0",l="sumValue",p=Math.floor(n/4)*4,c=n%4,m=`
        sumValue += dot(values, segFilter);
    `,f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${d}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${p};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Rae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n,i=o.shape.length,u=[],l=0,p=I.getAxesPermutation([l],i),c=o;p!=null&&(c=jt({inputs:{x:o},backend:t,attrs:{perm:p}}),u.push(c),l=I.getInnerMostAxes(1,i)[0]);let m=I.segment_util.computeOutShape(c.shape,l,a),f=b.sizeFromShape([c.shape[l]]),d=ie({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}});u.push(d);let h=zi(o.dtype),g=(k,w,P,A,F)=>{let E=k.shape[0],$=k.shape[1],W=I.segment_util.segOpComputeOptimalWindowSize($,F),K={windowSize:W,inSize:$,batchSize:E,numSegments:F},B=new cA(K,w),V=t.compileAndRun(B,[k,P],A);if(u.push(V),V.shape[1]===F)return V;let j=q_({backend:t,attrs:{start:0,stop:F,step:1,dtype:"float32"}}),H=iA({inputs:{x:j},backend:t,attrs:{reps:[$/W]}});return u.push(j),u.push(H),g(V,w,H,A,F)},y=g(d,"unsortedSegmentSum",s,h,a),x=ie({inputs:{x:y},backend:t,attrs:{shape:m}}),T=x;if(p!=null){u.push(x);let k=I.getUndoAxesPermutation(p);T=jt({inputs:{x:T},backend:t,attrs:{perm:k}})}return u.forEach(k=>t.disposeIntermediateTensorInfo(k)),T}var X3={kernelName:zu,backendName:"webgl",kernelFunc:Rae};var Lae=[Iz,Cz,LB,BB,OB,zB,WB,UB,KB,VB,qB,XB,YB,QB,JB,ZB,eO,rO,tO,nO,oO,sO,aO,uO,lO,pO,dO,gO,bO,xO,vB,kO,CO,vO,IO,SO,_O,wO,AO,NO,DO,MO,EO,RO,$O,BO,LO,OO,zO,GO,WO,UO,KO,VO,HO,qO,YO,QO,ZO,JO,tz,rz,nz,oz,sz,az,iz,uz,lz,CB,pz,TO,cz,mz,fz,wB,dz,hz,gz,yz,bz,xz,Tz,kz,wz,Az,_z,Nz,Dz,Fz,Sz,Ez,Rz,Lz,$z,Bz,Uz,DB,Vz,jz,Hz,qz,cO,Xz,Zz,Jz,e3,t3,SB,r3,n3,mO,Oz,o3,a3,s3,FB,i3,u3,l3,p3,c3,m3,f3,d3,h3,g3,b3,x3,T3,k3,I3,iO,Wz,C3,v3,w3,S3,_3,A3,N3,D3,F3,M3,R3,L3,$3,B3,O3,z3,Gz,EB,G3,W3,U3,V3,j3,RB,H3,q3,X3,Yz];for(let r of Lae)Oi(r);var li=U();li.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);li.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);li.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD",()=>4);li.registerFlag("WEBGPU_USE_NAIVE_CONV2D",()=>!1);li.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1);li.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);li.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);li.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);li.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);li.registerFlag("WEBGPU_USE_IMPORT",()=>!1);function Y3(r,e){if(Math.max(...r)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function Mt(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";throw Error(`GPU for rank ${r} is not yet supported`)}function Fx(r,e){return r==="float32"?e?"vec4<f32>":"f32":r==="int32"||r==="bool"?e?"vec4<i32>":"i32":r}function ke(){return`
  let index = getGlobalIndex(globalId, localId);
`}function he(){return`
  [[stage(compute), workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)]]
  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>, [[builtin(global_invocation_id)]] globalId : vec3<u32>)
`}function Q3(r,e,t,n=!1){let o=`
    let workGroupSizeX = ${t.workGroupSize[0]}u;
    let workGroupSizeY = ${t.workGroupSize[1]}u;
    let workGroupSizeZ = ${t.workGroupSize[2]}u;`;if(n===!0){let f=eG(e.shape),d=`
      [[block]] struct Matrix0 {
        numbers: array<${Fx(e.dtype,t.isVec4)}>;
      };
      [[block]] struct Uniform {
        size            : i32;
        numChannels     : i32;
        outShapeStrides : vec2<i32>;
        dispatchSize    : vec3<u32>;
      };

      [[group(0), binding(0)]] var<storage, write> result : Matrix0;
      [[group(0), binding(2)]] var<uniform> uniforms: Uniform;
    `;return[Z3,d,o,J3,f,t.getUserCode()].join(`
`)}let s=[],a="[[block]] struct Uniforms { NAN : f32; ";t.variableNames.forEach((f,d)=>{a+=`${f.charAt(0).toLowerCase()+f.slice(1)}Shape : ${Mt(r[d].shape.length)}; `}),a+=`outShape : ${Mt(e.shape.length)} ; `;let i=e.shape.length-1;a+=`
       outShapeStrides: ${Mt(i)}; `,t.size!=null&&(a+="size : i32; "),a+="dispatchSize : vec3<u32>; ",t.uniforms&&(a+=t.uniforms),a+="};",s.push(a),t.atomic?s.push(`
    [[block]] struct Matrix0 {
        numbers: array<atomic<i32>>;
    };

    [[group(0), binding(0)]] var<storage, read_write> result : Matrix0;
  `):s.push(`
    [[block]] struct Matrix0 {
        numbers: array<${Fx(e.dtype,t.isVec4)}>;
    };

    [[group(0), binding(0)]] var<storage, write> result : Matrix0;
  `),t.variableNames.forEach((f,d)=>{s.push(`
    [[block]] struct Matrix${1+d} {
      numbers: array<${Fx(r[d].dtype,t.isVec4)}>;
    };
    [[group(0), binding(${1+d})]] var<storage, read> ${f} : Matrix${1+d};
    `)}),a!==""&&s.push(`
    [[group(0), binding(${1+t.variableNames.length})]] var<uniform> uniforms : Uniforms;
    `),s.push(o);let[u,l]=Wae(e.shape,t.dispatchLayout),p=eG(e.shape),c=[Z3,s.join(`
`),J3,p,u,$ae(e.shape.length)];if(t.atomic||c.push(Bae(e.shape,e.dtype,t.isVec4)),l===e.shape.length){let f=r.map(d=>Oae(d,e.shape,t.isVec4,t.dispatchLayout.x.length===e.shape.length)).join(`
`);c.push(f)}return c.push(t.getUserCode()),c.join(`
`)}var Z3=`
  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let mod: i32 = a % b;
    if (sign < 0. && mod != 0) {
      res = res - 1;
    }
    return res;
  }

  fn isNanCustom(val : f32) -> bool {
    if (val > 0.0) {
      return false;
    }
    if (val < 0.0) {
      return false;
    }
    if (val == 0.0) {
      return false;
    }
    return true;
  }

  fn isNanCustomVec4F32(val : vec4<f32>) -> vec4<f32> {
    var res = vec4<f32> (0.0);
    for (var i = 0u; i < 4u; i = i + 1u) {
      if (isNanCustom(val[i])) {
        res[i] = 1.0;
      } else {
        res[i] = 0.0;
      }
    }
    return res;
  }

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) &&
        all(coord < shape);
  }
  `,J3=`
  fn getFlatIndex1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }

  fn getFlatIndex2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return i32(dot(vec2<f32>(coords), vec2<f32>(f32(shape.y), 1.0)));
  }

  fn getFlatIndex3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return i32(dot(vec3<f32>(coords), vec3<f32>(f32(shape.y) * f32(shape.z), f32(shape.z), 1.0)));
  }

  fn getFlatIndex4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return i32(dot(vec4<f32>(coords), vec4<f32>(
        f32(shape.y) * f32(shape.z) * f32(shape.w), f32(shape.z) * f32(shape.w), f32(shape.w), 1.0)));
  }

  // Only used when the y/z dimension of workgroup size is 1.
  fn getGlobalIndex(globalId : vec3<u32>, localId : vec3<u32>) -> i32 {
    if (uniforms.dispatchSize.y == 1u && uniforms.dispatchSize.z == 1u) {
      return i32(globalId.x);
    }
    let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
      localId.y * workGroupSizeX + localId.x;
    let workGroupID = (globalId - localId)/vec3<u32>(
      workGroupSizeX, workGroupSizeY, workGroupSizeZ);
    return i32((workGroupID.z * uniforms.dispatchSize.x * uniforms.dispatchSize.y +
      workGroupID.y * uniforms.dispatchSize.x + workGroupID.x) *
      (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
      localInvocationIndex);
  }
`;function $ae(r){let e="";switch(r){case 0:case 1:e+=`
        fn getOutputFlatIndex(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputFlatIndex(coords : vec2<i32>) -> i32 {
          return i32(dot(vec2<f32>(coords), vec2<f32>(f32(uniforms.outShapeStrides), 1.0)));
        }
        `;break;case 3:e+=`
        fn getOutputFlatIndex(coords : vec3<i32>) -> i32 {
          return i32(dot(vec3<f32>(coords), vec3<f32>(f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), 1.0)));
        }
        `;break;case 4:e+=`
        fn getOutputFlatIndex(coords : vec4<i32>) -> i32 {
          return i32(dot(vec4<f32>(coords), vec4<f32>(
            f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), f32(uniforms.outShapeStrides.z), 1.0)));
        }
        `;break;default:b.assert(!1,()=>`Unsupported ${r}D shape`);break}return e}function Bae(r,e,t){let n=r.length,o=Fx(e,t),s;if(t?s=`fn setOutputFlat(flatIndex : i32, value : vec4<f32>) {
      result.numbers[flatIndex] = ${o}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : vec4<i32>) {
      result.numbers[flatIndex] = ${o}(value);
    }`:s=`fn setOutputFlat(flatIndex : i32, value : f32) {
      result.numbers[flatIndex] = ${o}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : i32) {
      result.numbers[flatIndex] = ${o}(value);
    }`,n>=2){let a=["d0","d1","d2","d3"].slice(0,n),i=Mt(n);t?s+=`
      fn setOutput(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputFlatIndex(${i}(${a.join(", ")}));
        setOutputFlat(flatIndex / 4, value);
      }
      fn setOutputI32(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputFlatIndex(${i}(${a.join(", ")}));
        setOutputFlatI32(flatIndex / 4, value);
      }
    `:s+=`
      fn setOutput(${a.map(u=>`${u} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputFlatIndex(${i}(${a.join(", ")}));
        setOutputFlat(flatIndex, value);
      }
      fn setOutputI32(${a.map(u=>`${u} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputFlatIndex(${i}(${a.join(", ")}));
        setOutputFlatI32(flatIndex, value);
      }
    `}return s}function Oae(r,e,t,n){let o=zae(r,t);return r.shape.length<=e.length&&(o+=Gae(r,e,t,n)),o}function zae(r,e){let t=r.name,n=r.shape.length,o=Mt(n),s="get"+t.charAt(0).toUpperCase()+t.slice(1),a=["d0","d1","d2","d3"].slice(0,n),i=a.map(p=>`${p} : i32`).join(", ");if(n<1)return e?`
        fn ${s}() -> vec4<f32> {
          return vec4<f32>(${t}.numbers[0]);
        }
      `:`
      fn ${s}() ->f32 {
        return f32(${t}.numbers[0]);
      }
    `;let u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`,l=`${n}D`;return n===0&&(l="1D"),e?`
      fn ${s}(${i}) -> vec4<f32> {
        return vec4<f32>(${t}.numbers[getFlatIndex${l}(${o}(${a.join(",")}),
          ${u}) / 4]);
      }
      `:`
    fn ${s}(${i}) -> f32 {
      return f32(${t}.numbers[getFlatIndex${l}(${o}(${a.join(",")}),
        ${u})]);
    }
   `}function Gae(r,e,t,n){let o=r.name,s=o.charAt(0).toUpperCase()+o.slice(1),a="get"+s+"AtOutCoords",i=r.shape.length,u=e.length,l=Mt(u);if(b.arraysEqual(r.shape,e)&&n)return t?`
        fn ${a}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
          return vec4<f32>(${o}.numbers[globalIndex]);
        }

        fn ${a}ByCoords(coords : ${l}) -> vec4<f32> {
          return vec4<f32>(${o}.numbers[${u>1?"getOutputFlatIndex(coords)":"coords"} / 4]);
        }
        `:`
      fn ${a}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> f32 {
        return f32(${o}.numbers[globalIndex]);
      }

      fn ${a}ByCoords(coords : ${l}) -> f32 {
        return f32(${o}.numbers[${u>1?"getOutputFlatIndex(coords)":"coords"}]);
      }
      `;let p=I.getBroadcastDims(r.shape,e),c=u-i,m="";if(i===0)return t?`
      fn ${a}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
        return get${s}();
      }

      fn ${a}ByCoords(coords : ${l}) -> vec4<f32> {
        return get${s}();
      }
    `:`
      fn ${a}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> f32{
        return get${s}();
      }

      fn ${a}ByCoords(coords : ${l}) -> f32{
        return get${s}();
      }
    `;u<2&&p.length>=1?m="coords = 0;":m=p.map(g=>`coords[${g+c}] = 0;`).join(`
`);let f="";if(u<2&&i>0)f="coords";else if(u>1){let g=Mt(i),y=r.shape.map((x,T)=>`coords[${T+c}]`).join(", ");f=`${g}(${y})`}else f="coords";let d=`uniforms.${o.charAt(0).toLowerCase()+o.slice(1)}Shape`,h=`${i}D`;return t?`
      fn ${a}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
        var coords = getOutputCoords(globalId, globalIndex);
        ${m}
        return ${o}.numbers[getFlatIndex${h}(${f}, ${d}) / 4];
      }

      fn ${a}ByCoords(coordsIn : ${l}) -> vec4<f32> {
        var coords = coordsIn;
        ${m}
        return ${o}.numbers[getFlatIndex${h}(${f}, ${d}) / 4];
      }
    `:`
    fn ${a}ByGlobalId(globalId : vec3<u32>, globalIndex : i32) -> f32 {
      var coords = getOutputCoords(globalId, globalIndex);
      ${m}
      return f32(${o}.numbers[getFlatIndex${h}(${f}, ${d})]);
    }

    fn ${a}ByCoords(coordsIn : ${l}) -> f32 {
      var coords = coordsIn;
      ${m}
      return f32(${o}.numbers[getFlatIndex${h}(${f}, ${d})]);
    }
  `}function Wae(r,e){let{x:t,y:n=[],z:o=[]}=e,s=r.length;if(t.length===s)return[`fn getOutputCoords(globalId : vec3<u32>, globalIndex : i32) -> ${Mt(s)}{
      return getCoordsFromFlatIndex(i32(globalIndex));
    }
    `,s];let a="",i=[t,n,o],u=0;for(let m=0;m<i.length;m++){let f=i[m];if(f.length!==0)if(u+=f.length,f.length===1)a+=`let d${f[0]} = i32(globalId[${m}]);`;else{let d=Y3(f,"uniforms.outShape");a+=`var index${m} = i32(globalId[${m}]);`;for(let h=0;h<d.length;h++)a+=`let d${f[h]} = index${m} / ${d[h]};`,h===d.length-1?a+=`let d${f[h+1]} = index${m} - d${f[h]} * ${d[h]};`:a+=`index${m} = index${m} - d${f[h]} * ${d[h]};`}}let l=[];for(let m=0;m<u;m++)l.push(`d${m}`);let p=Mt(u),c=`fn getOutputCoords(globalId : vec3<u32>, globalIndex : i32) -> ${p} {
    ${a}
  `;return l.length===0?c+=`return ${p}(0); }`:c+=`return ${p}(${l.join(",")}); }`,[c,u]}function eG(r){let e=r.length;if(e<=1)return"fn getCoordsFromFlatIndex(index : i32) -> i32 { return index; }";let t=b.computeStrides(r),n=Mt(e),o=[];for(let a=0;a<e;a++)o.push(`d${a}`);if(t.length===1)return`    fn getCoordsFromFlatIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let s="var index2 = index;"+t.map((a,i)=>{let u=`let ${o[i]} = index2 / uniforms.outShapeStrides[${i}]`,l=i===t.length-1?`let ${o[i+1]} = index2 - ${o[i]} * uniforms.outShapeStrides[${i}]`:`index2 = index2 - ${o[i]} * uniforms.outShapeStrides[${i}]`;return`${u}; ${l};`}).join("");return`
    fn getCoordsFromFlatIndex(index : i32) -> ${n} {
      ${s}
      return ${n}(${o.join(",")});
    }
  `}var fA={};Qe(fA,{ArrayBufferToTypedArray:()=>mA,GPUBytesPerElement:()=>Mx,computeDispatch:()=>de,computeWorkGroupSizeForConv2d:()=>Jh,computeWorkGroupSizeForMatMul:()=>eg,computeWorkPerThreadForConv2d:()=>tg,flatDispatchLayout:()=>ve,isWebGPUSupported:()=>rg,tilesFitEvenlyIntoShape:()=>es});var Pp=65535;var Fp=r=>{let e=1;for(let t=0;t<r.length;t++)e*=r[t];return e};function es(r,e){if(r.length!==e.length)throw new Error(`Cannot compute whether rank ${r.length} tiles fit evenly into rank ${e.length} shape - ranks must match.`);return e.every((t,n)=>t%r[n]==0)}function de(r,e,t=[1,1,1],n=[1,1,1]){let[o,s,a]=[Math.ceil(Fp(r.x.map(u=>e[u]))/(t[0]*n[0])),r.y?Math.ceil(Fp(r.y.map(u=>e[u]))/(t[1]*n[1])):1,r.z?Math.ceil(Fp(r.z.map(u=>e[u]))/(t[2]*n[2])):1];if(o<=Pp&&s<=Pp&&a<=Pp)return[o,s,a];b.assert(o>Pp&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let i=Math.ceil(Math.sqrt(o));return i>Pp?(i=Math.ceil(Math.cbrt(o)),b.assert(i<=Pp,()=>"Total dispatch size exceeds WebGPU maximum."),[i,i,i]):[i,i,1]}function Jh(r,e){let t=Fp(r.x.map(o=>e[o])),n=Fp(r.y.map(o=>e[o]));return t<=4?[4,16,1]:n<=4?[16,4,1]:[16,16,1]}function eg(r,e,t){return r===1?[32,1,1]:t===1?[1,32,1]:[8,8,1]}function tg(r,e){let t=Fp(r.x.map(o=>e[o])),n=Fp(r.y.map(o=>e[o]));return t<=4?[1,2,1]:n<=4?[2,1,1]:[2,2,1]}function ve(r){return{x:r.map((e,t)=>t)}}function Mx(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function mA(r,e){if(e==="float32")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"||e==="string"){let t=new Int32Array(r),n=new ArrayBuffer(t.length),o=new Uint8Array(n);for(let s=0;s<t.length;s++)o[s]=t[s];return o}else throw new Error(`Unknown dtype ${e}`)}function rg(){return!!navigator.gpu}var Le;(function(T){T[T.MUL=0]="MUL",T[T.ADD=1]="ADD",T[T.SUB=2]="SUB",T[T.DIV=3]="DIV",T[T.EQUAL=4]="EQUAL",T[T.GREATER=5]="GREATER",T[T.GREATER_EQUAL=6]="GREATER_EQUAL",T[T.LESS=7]="LESS",T[T.LESS_EQUAL=8]="LESS_EQUAL",T[T.LOGICAL_AND=9]="LOGICAL_AND",T[T.NOT_EQUAL=10]="NOT_EQUAL",T[T.SQUARED_DIFFERENCE=11]="SQUARED_DIFFERENCE",T[T.INT_DIV=12]="INT_DIV",T[T.POW=13]="POW",T[T.PRELU=14]="PRELU",T[T.MAX=15]="MAX",T[T.MIN=16]="MIN",T[T.COMPLEX_MULTIPLY_REAL=17]="COMPLEX_MULTIPLY_REAL",T[T.COMPLEX_MULTIPLY_IMAG=18]="COMPLEX_MULTIPLY_IMAG"})(Le||(Le={}));var Uae="return a + b;",Kae="return areal * breal - aimag * bimag;",Vae="return areal * bimag + aimag * breal;",jae="return a / b;",Hae="return a * b;",qae="return (a - b) * (a - b);",Xae="return a - b;",Yae="return f32(a == b);",Qae="return vec4<f32>(a == b);",Zae="return f32(a > b);",Jae="return vec4<f32>(a > b);",eie="return f32(a >= b);",tie="return vec4<f32>(a >= b);",rie="return f32(a < b);",nie="return vec4<f32>(a < b);",oie="return f32(a <= b);",sie="return vec4<f32>(a <= b);",aie="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",iie=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,uie=`
  if (isNanCustom(a)) { return a; }
  if (isNanCustom(b)) { return b; }
  `,tG=`
  if (isNaN.r > 0.) {
    resultTemp.r = uniforms.NAN;
  }
  if (isNaN.g > 0.) {
    resultTemp.g = uniforms.NAN;
  }
  if (isNaN.b > 0.) {
    resultTemp.b = uniforms.NAN;
  }
  if (isNaN.a > 0.) {
    resultTemp.a = uniforms.NAN;
  }
  `,lie=`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `,pie=`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `,cie="return f32(a != b);",mie="return vec4<f32>(a != b);",fie=`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `,die=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = vec4<f32>(a < vec4<f32>(0.0)) * vec4<f32>(floor(b) < b);
  ${tG}
  return resultTemp;
  `,hie="if (a < 0.0) { return b * a; }  return a;",gie=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `;function rG(r,e){let t=e?tG:uie;return e?`
    var resultTemp = vec4<f32>(${r}(a, b));
    let isNaN = min(vec4<f32>(isNanCustomVec4F32(a)) + vec4<f32>(isNanCustomVec4F32(b)), vec4<f32>(1.0));
    `+t+`
    return resultTemp;
  `:t+`
    return ${r}(a, b);
  `}function pi(r,e){switch(r){case 0:return Hae;case 1:return Uae;case 2:return Xae;case 3:return jae;case 4:return e?Qae:Yae;case 5:return e?Jae:Zae;case 6:return e?tie:eie;case 7:return e?nie:rie;case 8:return e?sie:oie;case 9:return e?iie:aie;case 10:return e?mie:cie;case 11:return qae;case 12:return e?pie:lie;case 14:return e?gie:hie;case 15:return rG("max",e);case 16:return rG("min",e);case 13:return e?die:fie;case 17:return Kae;case 18:return Vae;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var we;(function(A){A[A.ABS=0]="ABS",A[A.CEIL=1]="CEIL",A[A.COS=2]="COS",A[A.COSH=3]="COSH",A[A.ELU=4]="ELU",A[A.EXP=5]="EXP",A[A.EXPM1=6]="EXPM1",A[A.FLOOR=7]="FLOOR",A[A.LINEAR=8]="LINEAR",A[A.LOG=9]="LOG",A[A.LOGICAL_NOT=10]="LOGICAL_NOT",A[A.NEG=11]="NEG",A[A.PRELU=12]="PRELU",A[A.RELU=13]="RELU",A[A.RELU6=14]="RELU6",A[A.RSQRT=15]="RSQRT",A[A.SIN=16]="SIN",A[A.SINH=17]="SINH",A[A.SIGMOID=18]="SIGMOID",A[A.SQRT=19]="SQRT",A[A.SQUARE=20]="SQUARE",A[A.TANH=21]="TANH",A[A.TO_INT=22]="TO_INT"})(we||(we={}));var bie="return abs(a);",yie="return ceil(a);",xie="return cos(a);",Tie=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,kie="return exp(a) - 1.0;",Iie="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Cie=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,vie="return exp(a);",wie="return floor(a);",Sie="return a;",_ie=`if (a < 0.0) { return 1.0/0.0; }
  return log(a);`,Aie="return f32(!(a >= 1.0));",Nie="return -a;",Die="return (a < 0.0) ? b * a : a;",Pie="return max(a, 0.0);",Fie="return clamp(a, 0.0, 6.0);",Mie="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",Eie=`
  var resFloat = a * vec4<f32>(a >= vec4<f32>(0.0));
  let isNaN = isNan(a);

  if (isNaN.r) {
    resFloat.r = a.r;
  }
  if (isNaN.g) {
    resFloat.g = a.g;
  }
  if (isNaN.b) {
    resFloat.b = a.b;
  }
  if (isNaN.a) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Rie="return 1.0/sqrt(a);",Lie="return 1.0 / (1.0 + exp(-1.0 * a));",$ie="return sin(a);",Bie=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,Oie="return sqrt(a);",zie="return a * a;",Gie=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Wie="return f32(i32((a)));";function cl(r,e){switch(r){case 0:return bie;case 2:return xie;case 3:return Tie;case 1:return yie;case 4:return e?Cie:Iie;case 5:return vie;case 6:return kie;case 7:return wie;case 8:return Sie;case 9:return _ie;case 10:return Aie;case 11:return Nie;case 12:return Die;case 13:return e?Eie:Pie;case 14:return e?Mie:Fie;case 15:return Rie;case 18:return Lie;case 16:return $ie;case 17:return Bie;case 19:return Oie;case 20:return zie;case 21:return Gie;case 22:return Wie;default:throw new Error(`BinaryType ${r} is not implemented!`)}}function Tn(r,e=!1){if(r===null)return null;if(r==="linear")return cl(we.LINEAR);if(r==="relu")return cl(we.RELU,e);if(r==="elu")return cl(we.ELU,e);if(r==="relu6")return cl(we.RELU6,e);if(r==="prelu")return pi(Le.PRELU,e);if(r==="sigmoid")return cl(we.SIGMOID);throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`)}function dA(r,e){let t={RowPerThread:r[1],ColPerThread:r[0],TileAOuter:e[1]*r[1],TileBOuter:e[0]*r[0],TileInner:e[0]*r[0]};return`
  var<workgroup> mm_Asub : array<array<vec4<f32>, ${t.TileInner/t.ColPerThread}>, ${t.TileAOuter}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${t.TileBOuter/t.ColPerThread}>, ${t.TileInner}>;

  let RowPerThread = ${t.RowPerThread};
  let ColPerThread = ${t.ColPerThread}; // only support ColPerThread = 4
  let TileAOuter = ${t.TileAOuter};
  let TileBOuter = ${t.TileBOuter};
  let TileInner = ${t.TileInner};

  ${he()} {

    let tileRow = i32(localId.y) * RowPerThread;
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * RowPerThread;
    let globalCol = i32(globalId.x);
    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;

    var acc: array<vec4<f32>, ${t.RowPerThread}>;
    var ACached : vec4<f32>;
    var BCached : array<vec4<f32>, 4>;

    // Loop over shared dimension.
    var globalColA = tileCol;
    let RowPerThreadB = TileInner / ${e[1]};
    let tileRowB = i32(localId.y) * RowPerThreadB;
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);
        }
        globalColA = globalColA + TileInner / ColPerThread;

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / ColPerThread; k = k + 1) {
            BCached[0] = mm_Bsub[k * ColPerThread][tileCol];
            BCached[1] = mm_Bsub[k * ColPerThread + 1][tileCol];
            BCached[2] = mm_Bsub[k * ColPerThread + 2][tileCol];
            BCached[3] = mm_Bsub[k * ColPerThread + 3][tileCol];

            for (var i = 0; i < RowPerThread; i = i + 1) {
                ACached = mm_Asub[tileRow + i][k];
                acc[i] = BCached[0] * ACached.x + acc[i];
                acc[i] = BCached[1] * ACached.y + acc[i];
                acc[i] = BCached[2] * ACached.z + acc[i];
                acc[i] = BCached[3] * ACached.w + acc[i];
            }
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(globalRow + innerRow,
                 globalCol,
                 acc[innerRow], globalId);
    }
}`}function Uie(r){return`
  var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;
  let tileSize = ${r[0]*4};
  ${he()} {
    let tileCol = i32(localId.x);
    let globalCol = i32(globalId.x);
    let globalRow = i32(globalId.y);

    let numTiles = (uniforms.dimInner - 1) / tileSize + 1;

    // Without this initialization strange values show up in acc.
    var acc = vec4<f32>(0.0);

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      let colA = t * tileSize / 4 + tileCol;
      mm_Asub[tileCol] = mm_readA(globalRow, colA, globalId);

      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileSize / 4; k = k + 1) {
        let rowB = t * tileSize + k * 4;
        let BCached0 = mm_readB(rowB, globalCol, globalId);
        let BCached1 = mm_readB(rowB + 1, globalCol, globalId);
        let BCached2 = mm_readB(rowB + 2, globalCol, globalId);
        let BCached3 = mm_readB(rowB + 3, globalCol, globalId);

        let ACached = mm_Asub[k];
        acc = acc + BCached0 * ACached.x;
        acc = acc + BCached1 * ACached.y;
        acc = acc + BCached2 * ACached.z;
        acc = acc + BCached3 * ACached.w;
      }

      workgroupBarrier();
    }

    if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
      mm_write(globalRow, globalCol, acc, globalId);
    }
  }
`}var hA=class{constructor(e,t,n,o=null,s=null,a=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.workGroupSize=[16,16,1];this.isVec4=!0;this.vecSize=4;this.outputShape=t,this.workGroupSize=eg(t[1],e[2],t[2]),this.dispatchLayout={x:[2],y:[1],z:[0]},t[1]===1&&(n=1),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.vecSize,n,1]);let i=o!=null,u=a!=null;i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=u,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`matMulPackedVec4_${n}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(){let e=this.aShape[2],t=this.outputShape[2],n=[this.outputShape[0],e,t],o=this.workGroupSize[1]*this.workPerThread,s=this.workGroupSize[0]*this.vecSize,a=s,i=[o,a],u=[a,s];return[es(i,this.aShape.slice(1)),es(u,n.slice(1))]}getUserCode(){let e=this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col]":`if (coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
            return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col];
        }
        return vec4<f32>(0.0)`,t=this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col]":`if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col];
        }
        return vec4<f32>(0.0)`,n="",o="";if(this.activation){let i=Tn(this.activation,this.isVec4);this.hasPreluActivationWeights?n=`fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${i}
                }`:n=`
            fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
              ${i}
            }`,o="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}
      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${e};
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${t};
      }

      fn mm_write(row : i32, col : i32, valueIn : vec4<f32>, globalId : vec3<u32>) {
        if (row < uniforms.aShape[1] && col * 4 < uniforms.bShape[2])
        {
          var value = valueIn;
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col * 4);
          ${s}
          ${o}
          setOutput(outCoord[0], outCoord[1], outCoord[2], value);
        }
      }
      ${this.outputShape[1]>1?dA([this.vecSize,this.workPerThread,1],this.workGroupSize):Uie(this.workGroupSize)}

    `}};function ng(r,e){let t=e[1]*r[1],n=e[0]*r[0],o=t>n?t:n;return`
    var<workgroup> mm_Asub : array<array<f32, ${o}>, ${t}>;
    var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${o}>;
    ${he()} {
      let tileRow = i32(localId.y) * ${r[1]};
      let tileCol = i32(localId.x) * ${r[0]};

      let globalRow = i32(globalId.y) * ${r[1]};
      let globalCol = i32(globalId.x) * ${r[0]};

      let numTiles = (uniforms.dimInner - 1) / ${o} + 1;

      var acc : array<array<f32, ${r[0]}>, ${r[1]}>;
      var ACached : f32;
      var BCached : array<f32, ${r[0]}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let ColPerThreadA = ${o} / ${e[0]};
      let tileColA = i32(localId.x) * ColPerThreadA;
      let RowPerThreadB = ${o} / ${e[1]};
      let tileRowB = i32(localId.y) * RowPerThreadB;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThreadA; innerCol = innerCol + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileColA + innerCol;

            mm_Asub[inputRow][inputCol] = mm_readA(
                globalRow + innerRow,
                t * ${o} + inputCol, globalId);
          }
        }
        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;

            mm_Bsub[inputRow][inputCol] = mm_readB(
              t * ${o} + inputRow,
              globalCol + innerCol, globalId);
          }
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${o}; k = k + 1) {
          for (var inner = 0; inner < ${r[0]}; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
            ACached = mm_Asub[tileRow + innerRow][k];
            for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {

          if ((globalCol + innerCol) < uniforms.dimBOuter &&
              (globalRow + innerRow) < uniforms.dimAOuter) {
            mm_write(globalRow + innerRow,
                     globalCol + innerCol,
                     acc[innerRow][innerCol], globalId);
          }
        }
      }
    }
  `}function Kie(r){return`
    let TileSize = ${r[0]*4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${he()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;

      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),
                                mm_readA(globalRow, colA + 1, globalId),
                                mm_readA(globalRow, colA + 2, globalId),
                                mm_readA(globalRow, colA + 3, globalId));
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),
                              mm_readB(rowB + 1, globalCol, globalId),
                              mm_readB(rowB + 2, globalCol, globalId),
                              mm_readB(rowB + 3, globalCol, globalId));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
        mm_write(globalRow, globalCol, acc, globalId);
      }
    }
  `}var og=class{constructor(e,t,n,o=!1,s=!1,a=null,i=null,u=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.workGroupSize=[16,16,1];this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};let l=o?e[1]:e[2];this.workGroupSize=eg(t[1],l,t[2]),(t[1]===1||t[2]===1)&&(n=1),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]),b.arraysEqual(this.dispatch,[1,1,1])&&(n=1,this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]));let p=a!=null,c=u!=null;p&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.transposeA=o,this.transposeB=s,this.addBias=p,this.activation=i,this.hasPreluActivationWeights=c;let m=this.outputShape[2],f=this.transposeB?[this.outputShape[0],m,l]:[this.outputShape[0],l,m];[this.fitA,this.fitB]=this.getShapeFit(f),this.shaderKey=`matMulPacked_${this.workPerThread}_${o}_${s}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(e){let t=this.workGroupSize[1]*this.workPerThread,n=this.workGroupSize[0]*this.workPerThread,o=t>n?t:n;this.outputShape[1]===1&&(o*=4),b.assert(o%this.workGroupSize[0]==0&&o%this.workGroupSize[1]==0,()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y");let s=[t,o],a=[o,n];return[es(s,this.aShape.slice(1)),es(a,e.slice(1))]}getUserCode(){let e;this.transposeA===!1?e=this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
           }
           return 0.0;`:e=this.fitA?"return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch* batchASize + col * uniforms.dimAOuter + row];
           }
           return 0.0;`;let t;this.transposeB===!1?t=this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
           }
           return 0.0;`:t=this.fitB?"return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];
           }
           return 0.0;`;let n="",o="";if(this.activation){let i=Tn(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${i}
            }`:n=`
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${i}
              }
            `,o="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }

      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        var value = valueIn;
        let batch = i32(globalId.z);
        let outCoord = vec3<i32>(batch, row, col);
        ${s}
        ${o}
        setOutput(batch, row, col, value);
      }
      ${this.outputShape[1]>1?ng([this.workPerThread,this.workPerThread,1],this.workGroupSize):Kie(this.workGroupSize)}
    `}};function Vie(r){let e=r[1]/2,t=r[0],n=e>t?e:t;return`
  var<workgroup> mm_Asub1 : array<array<f32, ${n}>, ${e}>;
  var<workgroup> mm_Bsub1 : array<array<f32, ${t}>, ${n}>;
  var<workgroup> mm_Asub2 : array<array<f32, ${n}>, ${e}>;
  var<workgroup> mm_Bsub2 : array<array<f32, ${t}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Introduces two shared memory buffers, some logical threads could handle
  // arithmetic operations and others handle IO operations between barrier api,
  // makes ALUs and load/store units work simultaneously, could improves
  // the performance.
  ${he()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = tileRow;
    for (var t = 0; t < numTiles; t = t + 1) {
      if (t == 0) {
        if (tileRow < ${e}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${n};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${n};
        }
      } else {
        if (tileRow < ${e}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${n};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${n};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${n}; k = k + 1) {
            let subRow = tileRow - ${e};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub2[subRow][k] * mm_Bsub2[k][tileCol];
          }
        }
      }
      workgroupBarrier();
      if (t != 0) {
        t = t + 1;
      }

      if (t < numTiles) {
        if (tileRow < ${e}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub2[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${n};
          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${n};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${n}; k = k + 1) {
            let subRow = tileRow - ${e};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub1[subRow][k] * mm_Bsub1[k][tileCol];
          }
        }
      }
      workgroupBarrier();
    }
    let writeCol = (globalRow - tileRow) / 2 + tileRow - ${e};
    if (tileRow >= ${e} && writeCol >= 0) {
      mm_write(writeCol, globalCol, acc, globalId);
    }
  }
  `}var gA=class{constructor(e,t,n,o=null,s=null,a=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.workGroupSize=[8,16,1];b.assert(e[1]<=16||t[2]<=16,()=>"This program can be only used when A width or B Height are small"),this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]*2/this.workGroupSize[1]),n[0]];let i=o!=null;i&&this.variableNames.push("bias");let u=a!=null;u&&this.variableNames.push("preluActivationWeights"),this.addBias=i,this.activation=s,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}`}getUserCode(){let e=`if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
          return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
        }
        return 0.0;`,t=`if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
         }
         return 0.0;`,n="",o="";if(this.activation){let i=Tn(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
            ${i}
            }`:n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            ${i}
        }`,o="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }
      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }
      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimBOuter))) {
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col);
          var value = valueIn;
          ${s}
          ${o}
          setOutput(batch, row, col, value);
        }
      }
      ${Vie(this.workGroupSize)}
    `}};function Ue(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=b.sizeFromShape(n.shape),a=b.inferFromImplicitShape(o,s),i=b.sizeFromShape(a);return b.assert(s===i,()=>`The new shape (${a}) has ${i} elements and the old shape (${n.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var nG={kernelName:ds,backendName:"webgpu",kernelFunc:Ue};function $m({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,c=t?r.shape[l-2]:r.shape[l-1],m=n?e.shape[p-1]:e.shape[p-2],f=t?r.shape[l-1]:r.shape[l-2],d=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),y=b.sizeFromShape(h),x=b.sizeFromShape(g),T=y===x||y===1||x===1;b.assert(l>=2&&p>=2&&T,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${h}) and (${g}).`);let w=(y>x?r.shape.slice(0,-2):e.shape.slice(0,-2)).concat([f,d]);b.assert(c===m,()=>`Error in matMul: inner shapes (${c}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let P=t?[y,c,f]:[y,f,c],A=n?[x,d,m]:[x,m,d],F=Ue({inputs:{x:r},backend:o,attrs:{shape:P}}),E=Ue({inputs:{x:e},backend:o,attrs:{shape:A}}),$=[F,E],W=Math.max(y,x),K=c%4==0&&d%4==0&&!t&&!n&&d>=32,B;!t&&!n&&(f<=16&&(d<=512||m>=2*d)||d<=16&&(f<=512||c>=2*f))?B=new gA(P,A,[W,f,d],s,u,a):K?B=new hA(P,[W,f,d],U().get("WEBGPU_MATMUL_WORK_PER_THREAD"),s,u,a):B=new og(P,[W,f,d],U().get("WEBGPU_MATMUL_WORK_PER_THREAD"),t,n,s,u,a);let V=[F,E];s&&V.push(s),a&&V.push(a);let j=[{type:"int32",data:[f]},{type:"int32",data:[d]},{type:"int32",data:[c]}],H=o.runWebGPUProgram(B,V,r.dtype,j),J=Ue({inputs:{x:H},backend:o,attrs:{shape:w}});$.push(H);for(let X of $)o.disposeData(X.dataId);return J}function jie(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n;return $m({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:c,activation:p})}var oG={kernelName:Is,backendName:"webgpu",kernelFunc:jie};var Ex=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.workGroupSize=[128,1,1];this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e,this.size=b.sizeFromShape(this.outputShape)}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${pi(this.op,!1)}
      }

      ${he()} {
        ${ke()}
        if(index < uniforms.size) {
          let areal = getARealAtOutCoordsByGlobalId(globalId, index);
          let aimag = getAImagAtOutCoordsByGlobalId(globalId, index);
          let breal = getBRealAtOutCoordsByGlobalId(globalId, index);
          let bimag = getBImagAtOutCoordsByGlobalId(globalId, index);
          setOutputFlat(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};var bA=class{constructor(e,t,n,o){this.variableNames=["A","B"];let s=256;this.workGroupSize=[s,1,1],this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ve(this.outputShape),this.lastDimensionSize=o?n[0]:t[0],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4,this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.useSharedMemoryWithB=o,this.op=e,this.size=b.sizeFromShape(this.outputShape),this.sizeFit=this.size%(this.workGroupSize[0]*this.workPerThread)==0,this.shaderKey=`binaryShared_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}_${this.sizeFit}`}getUserCode(){let e=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",t=this.useSharedMemoryWithB?`let a = getAAtOutCoordsByCoords(coords);
         let b = sharedBuf[${e}];`:`let a = sharedBuf[${e}];
         let b = getBAtOutCoordsByCoords(coords);`,n=this.sizeFit?`let coords = getCoordsFromFlatIndex(flatIndex);

         ${t}
         setOutputFlat(flatIndex, binaryOperation(a, b));`:`if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);

            ${t}
            setOutputFlat(flatIndex, binaryOperation(a, b));
          }`;return`
        fn binaryOperation(a : f32, b : f32) -> f32 {
          ${pi(this.op,!1)}
        }
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${he()} {
          ${ke()}

          // Fill in the shared memory buffer. Here we need a loop to make sure
          // that all data in A|B are uploaded when |sharedMemorySize| is larger
          // than work group size.
          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}.numbers[localIndex]);
          }
          workgroupBarrier();

          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
            let flatIndex = index * ${this.workPerThread} + i;

            ${n}
          }
        }
        `}};var yA=class{constructor(e,t,n){this.variableNames=["A","B"];this.workPerThread=4;this.isVec4=!0;let o=128;this.workGroupSize=[o,1,1],this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.op=e,this.fitShape=this.size%this.workGroupSize[0]==0,this.shaderKey=`binaryVec4_${e}_${this.fitShape}`,this.size=b.sizeFromShape(this.outputShape)/this.workPerThread}getUserCode(){let e,n=`fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
          ${pi(this.op,this.isVec4)}
        }`;return this.fitShape?e=`
      ${n}
      ${he()} {
        ${ke()}
        let a = vec4<f32>(A.numbers[index]);
        let b = vec4<f32>(B.numbers[index]);
        setOutputFlat(index, binaryOperation(a, b));
      }
    `:e=`
      ${n}
      ${he()} {
        ${ke()}
        if (index < uniforms.size) {
          let a = vec4<f32>(A.numbers[index]);
          let b = vec4<f32>(B.numbers[index]);
          setOutputFlat(index, binaryOperation(a, b));
        }
      }
    `,e}};var sg=class{constructor(e,t,n){this.variableNames=["A","B"];let o=128;this.workGroupSize=[o,1,1],this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ve(this.outputShape),this.size=b.sizeFromShape(this.outputShape),this.sizeFit=this.size%o==0,this.shapesFit=b.arraysEqual(t,n)&&this.sizeFit,this.workPerThread=this.sizeFit||this.shapesFit?1:2,this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey=`binary_${e}_${this.sizeFit}_${this.shapesFit}`,this.op=e}getUserCode(){let e,n=`          fn binaryOperation(a : f32, b : f32) -> f32 {
      ${pi(this.op,!1)}
    }`;return this.shapesFit?e=`
          ${n}
          ${he()} {
            ${ke()}

            let a = f32(A[index]);
            let b = f32(B[index]);
            setOutputFlat(index, binaryOperation(a, b));
          }
        `:this.sizeFit?e=`
      ${n}
      ${he()} {
        ${ke()}

        let coords = getCoordsFromFlatIndex(index);

        let a = getAAtOutCoordsByCoords(coords);
        let b = getBAtOutCoordsByCoords(coords);
        setOutputFlat(index, binaryOperation(a, b));
      }
      `:e=`
      ${n}
      ${he()} {
        ${ke()}
        for (var i = 0; i < ${this.workPerThread}; i = i + 1 ) {
          let flatIndex = index * ${this.workPerThread} + i;

          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);

            let a = getAAtOutCoordsByCoords(coords);
            let b = getBAtOutCoordsByCoords(coords);
            setOutputFlat(flatIndex, binaryOperation(a, b));
          }
        }
      }
      `,e}};function xA(r,e,t){if(b.arraysEqual(e,t)&&b.sizeFromShape(e)%4==0)return new yA(r,e,t);let o=e.length===1&&t.length>1&&e[0]<1024,s=t.length===1&&e.length>1&&t[0]<1024;return o||s?new bA(r,e,t,s):new sg(r,e,t)}function wr(r){let{inputs:e}=r,{x:t}=e;return r.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var sG={kernelName:Kn,backendName:"webgpu",kernelFunc:wr};function Ba(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),a=t.tensorMap.get(s.dataId),i=wr({inputs:{x:n},backend:t}),u=wr({inputs:{x:o},backend:t});return a.complexTensorInfos={real:i,imag:u},s}var aG={kernelName:Nu,backendName:"webgpu",kernelFunc:Ba};var gu=class{constructor(e,t){this.variableNames=["A"];let n=128;this.workGroupSize=[n,1,1],this.outputShape=e,this.size=b.sizeFromShape(this.outputShape),this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${cl(this.op,!1)}
      }
      ${he()} {
        ${ke()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalId(globalId, index);
          setOutputFlat(index, unaryOperation(a));
        }
      }
      `}};function dt({opType:r,cpuKernelImpl:e,dtype:t}){return({inputs:n,backend:o})=>{let{x:s}=n,a=o,i=t||s.dtype;if(a.shouldExecuteOnCPU([s])&&e!=null){let l=a.tensorMap.get(s.dataId),p=e(l.values,i);return a.makeTensorInfo(s.shape,i,p)}let u=new gu(s.shape,r);return a.runWebGPUProgram(u,[s],i)}}function _t({opSnippet:r,cpuKernelImpl:e,supportsComplex:t=!1,dtype:n}){return({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(t&&a.dtype==="complex64"){let c=u.tensorMap.get(a.dataId),m=u.tensorMap.get(i.dataId),f,d;if(r!==Le.MUL)[f,d]=[[c.complexTensorInfos.real,m.complexTensorInfos.real],[c.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(g=>{let[y,x]=g,T={dataId:y.dataId,dtype:y.dtype,shape:a.shape},k={dataId:x.dataId,dtype:x.dtype,shape:i.shape},w=xA(r,a.shape,i.shape);return u.runWebGPUProgram(w,[T,k],Ut(y.dtype,x.dtype))});else{let g=new Ex(Le.COMPLEX_MULTIPLY_REAL,a.shape,i.shape),y=new Ex(Le.COMPLEX_MULTIPLY_IMAG,a.shape,i.shape),x=[{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:a.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:i.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:i.shape}];f=u.runWebGPUProgram(g,x,"float32"),d=u.runWebGPUProgram(y,x,"float32")}let h=Ba({inputs:{real:f,imag:d},backend:u});return u.disposeData(f.dataId),u.disposeData(d.dataId),h}let l=n||Ut(a.dtype,i.dtype);if((a.dtype==="string"||i.dtype==="string"||u.shouldExecuteOnCPU([a,i]))&&e!=null){let c=u.tensorMap.get(a.dataId).values,m=u.tensorMap.get(i.dataId).values,f=a.dtype==="string"?I.fromUint8ToStringArray(c):c,d=a.dtype==="string"?I.fromUint8ToStringArray(m):m,[h,g]=e(a.shape,i.shape,f,d,l);return u.makeTensorInfo(g,l,h)}let p=xA(r,a.shape,i.shape);return u.runWebGPUProgram(p,[a,i],l)}}var{addImpl:iG,ceilImpl:uG,concatImpl:lG,equalImpl:pG,expImpl:cG,expm1Impl:mG,floorImpl:fG,gatherNdImpl:dG,gatherV2Impl:hG,greaterEqualImpl:gG,greaterImpl:bG,lessEqualImpl:yG,lessImpl:xG,logImpl:TG,maxImpl:kG,maximumImpl:IG,minimumImpl:CG,multiplyImpl:vG,negImpl:wG,notEqualImpl:SG,prodImpl:_G,rangeImpl:AG,rsqrtImpl:NG,simpleAbsImpl:DG,sliceImpl:PG,stridedSliceImpl:FG,stringNGramsImpl:MG,subImpl:EG,tileImpl:RG,transposeImpl:LG,uniqueImpl:KIr}=vm;var Hie=dt({opType:we.ABS,cpuKernelImpl:DG}),$G={kernelName:as,backendName:"webgpu",kernelFunc:Hie};var qie=_t({opSnippet:Le.ADD,cpuKernelImpl:iG,supportsComplex:!0}),BG={kernelName:_n,backendName:"webgpu",kernelFunc:qie};var TA=class{constructor(e){this.workPerThread=4;this.workGroupSize=[64,1,1];this.outputShape=e[0],this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=[];this.variableNames.forEach(o=>{e.push(`let v${o} = get${o}AtOutCoordsByCoords(coords);`)});let t=this.variableNames.map(o=>`v${o}`).join(" + ");return`
      ${he()} {
        ${ke()}
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputFlat(flatIndex, ${t});
          }
        }
      }
    `}};function Xie(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return wr({inputs:{x:n[0]},backend:t});let o=n.map(i=>i.dtype).reduce((i,u)=>Ut(i,u)),s=n.map(i=>i.shape),a=new TA(s);return t.runWebGPUProgram(a,n,o)}var OG={kernelName:no,backendName:"webgpu",kernelFunc:Xie};var ag=class{constructor(e,t,n){this.variableNames=["x"];this.uniforms="axis : i32;";let o=[t];I.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.length),this.op=n==="min"?"<":">";let[s,a]=I.computeOutAndReduceShapes(e,o);this.outputShape=s.length===0?[1]:s;let i=b.sizeFromShape(a);this.reductionFactor=2;let u=256,l=Math.min(Math.ceil(i/this.reductionFactor),u);this.workGroupSize=[l,1,1],this.dispatchLayout={x:[],y:this.outputShape.map((p,c)=>c)},this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.inputShape=e,this.shaderKey=`argMinMax${this.op}`}getUserCode(){let e=this.workGroupSize[0]>1,t=`
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `,n=`
      xBestIndices[localId.x] = bestIndex;
      xBestValues[localId.x] = bestValue;

      for(var currentSize = WorkGroupSize; currentSize > 1; currentSize = DIV_CEIL(currentSize, ${this.reductionFactor})) {
        workgroupBarrier();

        for (var w = 0; w < ${this.reductionFactor}; w = w + 1) {
          let i = i32(localId.x) * ${this.reductionFactor} + w;
          if (i < currentSize) {
            let candidateIndex = xBestIndices[i];
            let candidate = xBestValues[i];
            if(candidate ${this.op} bestValue && !isNanCustom(candidate)) {
              bestValue = candidate;
              bestIndex = candidateIndex;
            }
          }
        }

        xBestIndices[localId.x] = bestIndex;
        xBestValues[localId.x] = bestValue;
      }

      if (localId.x == 0u) {
        setOutputFlatI32(flatOutputIndex, i32(bestIndex));
      }
    `,o=Mt(this.outputShape.length),s=(u,l)=>this.outputShape.length===1?u:`${u}[${l}]`,a=u=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape[${u}]`;return`
      fn DIV_CEIL(a : i32, b : i32) -> i32 {
        return ((a - 1) / b + 1);
      }

      let WorkGroupSize = ${this.workGroupSize[0]};

      ${e?t:""}

      // In order to get a flattened index into the input tensor, we need to
      // add back the index along the reduced dimension to |outputCoords|.
      // This function outputs the offset to the first value along
      // |axis| and the stride to get the next value of the input along |axis|.
      fn getInputCoordInfo(globalId : vec3<u32>, globalIndex : i32) -> vec2<i32>{
        let outputCoords : ${o} = getOutputCoords(globalId, globalIndex);
        var i = ${this.outputShape.length-1};

        var stride = 1;
        var inputStride = 1;
        var offset = 0;

        for (var r = 1; r <= ${this.inputShape.length}; r = r + 1) {
          let length = ${a(`${this.inputShape.length} - r`)};
          if (${this.inputShape.length} - r == uniforms.axis) {
            inputStride = stride;
          } else {
            offset = offset + ${s("outputCoords","i")} * stride;
            i = i - 1;
          }
          stride = stride * length;
        }

        return vec2<i32>(offset, inputStride);
      }

      fn getInputIndex(coordInfo : vec2<i32>, index : i32) -> i32{
        return coordInfo[0] + coordInfo[1] * index;
      }

      ${he()} {
        ${ke()}
        let coordInfo = getInputCoordInfo(globalId, index);

        var bestIndex = 0;
        var bestValue = x.numbers[getInputIndex(coordInfo, bestIndex)];

        let Length = ${a("uniforms.axis")};
        let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);

        for (var w = 0; w < WorkPerThread; w = w + 1) {
          let i = i32(globalId.x) * WorkPerThread + w;
          if (i < Length) {
            let candidate = x.numbers[getInputIndex(coordInfo, i)];
            if (candidate ${this.op} bestValue && !isNanCustom(f32(candidate))) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
        }

        let flatOutputIndex = i32(globalId.y);
        ${e?n:"setOutputFlatI32(flatOutputIndex, bestIndex);"}
      }
    `}};var kA=class{constructor(e,t){this.variableNames=["A"];this.workGroupSize=[16,16,1];let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`
      let TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;
      ${he()} {
        ${ke()}
        let workGroupID = (globalId - localId)/vec3<u32>(${this.workGroupSize[0]}u, ${this.workGroupSize[1]}u, ${this.workGroupSize[2]}u);
        var x = i32(workGroupID.x) * TILE_DIM + i32(localId.x);
        var y = i32(workGroupID.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] =
              A.numbers[y * width + x];
        }
        workgroupBarrier();

        x = i32(workGroupID.y) * TILE_DIM + i32(localId.x);
        y = i32(workGroupID.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputFlat((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}};var IA=class{constructor(e,t){this.variableNames=["A"];this.workPerThread=4;this.workGroupSize=[64,1,1];let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`,this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=Mt(this.outputShape.length),t=Yie(this.newDim);return`
      ${he()} {
        ${ke()}

        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromFlatIndex(flatIndex);
            setOutputFlat(flatIndex, A.numbers[getFlatIndex${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function Yie(r){let e=r.length;if(e>4)throw Error(`Transpose for rank ${e} is not yet supported`);let t=new Array(e);for(let n=0;n<r.length;n++)t[r[n]]=`resRC[${n}]`;return t.join()}function ts(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,a=t,i=o.shape.length,u=new Array(i);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];if(t.shouldExecuteOnCPU([o])){let c=a.tensorMap.get(o.dataId).values,m=LG(c,o.shape,o.dtype,s,u);return t.makeTensorInfo(u,o.dtype,m)}if(o.shape.length===2&&b.arraysEqual(s,[1,0])){let p=new kA(o.shape,s);return a.runWebGPUProgram(p,[o],o.dtype)}let l=new IA(o.shape,s);return a.runWebGPUProgram(l,[o],o.dtype)}var zG={kernelName:Vo,backendName:"webgpu",kernelFunc:ts};function Qie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=b.parseAxisParam(s,o.shape),i=I.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=ts({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=I.getInnerMostAxes(a.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let p=new ag(u.shape,a[0],"max"),c=[{type:"int32",data:[a[0]]}],m=t.runWebGPUProgram(p,[u],"int32",c);return l.forEach(f=>t.disposeData(f.dataId)),m}var GG={kernelName:oo,backendName:"webgpu",kernelFunc:Qie};function Zie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=b.parseAxisParam(s,o.shape),i=I.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=ts({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=I.getInnerMostAxes(a.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let p=new ag(u.shape,a[0],"min"),c=[{type:"int32",data:[a[0]]}],m=t.runWebGPUProgram(p,[u],"int32",c);return l.forEach(f=>t.disposeData(f.dataId)),m}var WG={kernelName:Wa,backendName:"webgpu",kernelFunc:Zie};var ig=class{constructor(e,t){this.variableNames=["x"];this.uniforms="stride : vec2<i32>; pad : vec2<i32>; dilation : vec2<i32>; convDims : vec2<i32>; filterDims : vec2<i32>;";this.workGroupSize=[128,1,1];this.outputShape=e.outShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";this.poolType==="avg"&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return this.poolType==="avg"&&(t="resultValue / count"),`
      ${he()} {
        ${ke()}
        let coords = getOutputCoords(globalId, index);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutput(batch, coords[1], coords[2], coords[3], ${t});
        }
      }
    `}};var ug=class{constructor(e){this.variableNames=["x"];this.uniforms="stride : vec2<i32>;";this.workGroupSize=[256,1,1];this.outputShape=e.outShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${he()} {
        ${ke()}
        let coords = getOutputCoords(globalId, index);
        let batch = coords[0];
        let d = coords[3];

        if (all(coords < uniforms.outShape)) {
          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutput(batch, coords[1], coords[2], d, value);
        }
      }
    `}};function Jie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1,p=I.computePool2DInfo(o.shape,s,a,l,i,u);if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))return wr({inputs:{x:o},backend:t});let c,m=[{type:"int32",data:[p.strideHeight,p.strideWidth]}];return p.filterHeight===1&&p.filterWidth===1?c=new ug(p):(c=new ig(p,"avg"),m.push({type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]})),t.runWebGPUProgram(c,[o],o.dtype,m)}var UG={kernelName:so,backendName:"webgpu",kernelFunc:Jie};function eue(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;return $m({a:o,b:s,transposeA:a,transposeB:i,backend:t})}var KG={kernelName:ao,backendName:"webgpu",kernelFunc:eue};var CA=class{constructor(e,t){this.variableNames=["source"];this.workPerThread=1;this.workGroupSize=[64,1,1];this.outputShape=t,this.rank=t.length,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Mt(e.length)}; `,this.shaderKey="slice",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=Mt(this.rank),t=tue(this.rank),n;return this.start.length===1?n=this.outputShape.map((s,a)=>"sourceLoc = uniforms.start + coords;"):n=this.outputShape.map((s,a)=>`sourceLoc.${vA[a]} = uniforms.start[${a}] + coords.${vA[a]};`),`
      ${he()} {
        ${ke()}
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getOutputCoords(globalId, index);
          ${n.join(`
`)}
          setOutputFlat(index, getSource(${t}));
        }
      }
    `}},vA=["x","y","z","w","u","v"];function tue(r){if(r===1)return"sourceLoc";if(r<=6)return vA.slice(0,r).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}function bu(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n,[i,u]=Xt.parseSliceParams(o,s,a);if(Xt.assertParamsValid(o,i,u),t.shouldExecuteOnCPU([o])||o.dtype==="string"){let c=t.tensorMap.get(o.dataId),m=PG(c.values,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,m)}if(b.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);let l=new CA(i,u),p=[{type:"int32",data:i}];return t.runWebGPUProgram(l,[o],o.dtype,p)}var VG={kernelName:gs,backendName:"webgpu",kernelFunc:bu};var rue=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((x,T)=>x*T),u=I.getReshaped(o.shape,s,i),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,i),c=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(p,a,s.length),f=[],d=Ue({inputs:{x:o},backend:t,attrs:{shape:u}}),h=ts({inputs:{x:d},backend:t,attrs:{perm:l}}),g=Ue({inputs:{x:h},backend:t,attrs:{shape:p}}),y=bu({inputs:{x:g},backend:t,attrs:{begin:c,size:m}});return f.push(d),f.push(h),f.push(g),f.forEach(x=>t.disposeData(x.dataId)),y},jG={kernelName:is,backendName:"webgpu",kernelFunc:rue};var wA=_t({opSnippet:Le.NOT_EQUAL,dtype:"bool",cpuKernelImpl:SG}),HG={kernelName:ia,backendName:"webgpu",kernelFunc:wA};function yu(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return wr({inputs:{x:o.complexTensorInfos.real},backend:t})}var qG={kernelName:$u,backendName:"webgpu",kernelFunc:yu};function XG(r,e){let t=new gu(r.shape,we.TO_INT),n=e.runWebGPUProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function SA(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return wr({inputs:{x:o},backend:t});let a=Tt(o.shape),i=SA({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=Ba({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeData(i.dataId),u}if(o.dtype==="complex64"){let a=yu({inputs:{input:o},backend:t}),i=SA({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeData(a.dataId),i}if(!b.hasEncodingLoss(o.dtype,s)){let a=wr({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(s==="int32")return XG(o,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),u=wA({inputs:{a:o,b:a},backend:t});return t.disposeData(a.dataId),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var YG={kernelName:Wn,backendName:"webgpu",kernelFunc:SA};var nue=dt({opType:we.CEIL,cpuKernelImpl:uG}),QG={kernelName:io,backendName:"webgpu",kernelFunc:nue};var _A=class{constructor(e){this.variableNames=["A"];this.uniforms="minVal : f32; maxVal : f32;";this.workPerThread=4;this.workGroupSize=[64,1,1];this.isVec4=!0;this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4",this.size=b.sizeFromShape(this.outputShape)/4}getUserCode(){return`
      ${he()} {
        ${ke()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalId(globalId, index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isNanCustom(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputFlat(index, clampedValue);
        }
      }
    `}};var AA=class{constructor(e){this.variableNames=["A"];this.uniforms="minVal : f32; maxVal : f32;";this.workGroupSize=[64,1,1];this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){return`
      ${he()} {
        ${ke()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalId(globalId, index);
          if (isNanCustom(value)) {
            setOutputFlat(index, value);
            return;
          }
          setOutputFlat(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function oue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i,u=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return b.sizeFromShape(o.shape)%4==0?i=new _A(o.shape):i=new AA(o.shape),t.runWebGPUProgram(i,[o],o.dtype,u)}var ZG={kernelName:Un,backendName:"webgpu",kernelFunc:oue};var NA=class{constructor(e){this.workPerThread=4;this.workGroupSize=[64,1,1];this.outputShape=I.computeOutShape(e,1),this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shapes=e,this.shaderKey=`concat${e}`,this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=new Array(this.shapes.length-1),t=[];if(e.length>0){e[0]=this.shapes[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+this.shapes[a][1];t.push(`if (yC < ${e[0]}){ setOutput(coords.x, coords.y, getT0(yR, yC)); }`);for(let a=1;a<e.length;a++){let i=e[a-1];t.push(`elseif (yC < ${e[a]}){ setOutput(coords.x, coords.y, getT${a}(yR, yC - ${i})); }`)}let o=e.length,s=e[e.length-1];t.push(`else { setOutput(coords.x, coords.y, getT${o}(yR, yC - ${s})); }`)}else t.push("setOutput(coords.x, coords.y, getT0(yR, yC));");return`
      ${he()} {
        ${ke()}
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${t.join(`
        `)}
          }
        }
      }
    `}};function Mp(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return wr({inputs:{x:o.complexTensorInfos.imag},backend:t})}var JG={kernelName:Eu,backendName:"webgpu",kernelFunc:Mp};function Rx(r,e,t){let n=r[0].dtype;if(n==="complex64"){let p=r.map(h=>yu({inputs:{input:h},backend:t})),c=r.map(h=>Mp({inputs:{input:h},backend:t})),m=Rx(p,e,t),f=Rx(c,e,t),d=Ba({inputs:{real:m,imag:f},backend:t});return p.forEach(h=>t.disposeData(h.dataId)),c.forEach(h=>t.disposeData(h.dataId)),t.disposeData(m.dataId),t.disposeData(f.dataId),d}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let p=r.map(y=>{let x=b.sizeFromShape(y.shape.slice(e));return Ue({inputs:{x:y},backend:t,attrs:{shape:[-1,x]}})}),c=p.map(y=>({vals:t.readSync(y.dataId),shape:y.shape})),m=I.computeOutShape(p.map(y=>y.shape),1),f=p[0].shape[0]===1,d=lG(c,m,n,f),h=I.computeOutShape(r.map(y=>y.shape),e),g=t.makeTensorInfo(h,n,d);return p.forEach(y=>t.disposeData(y.dataId)),g}let{tensors2D:s,outShape:a}=sue(r,e,t),i=new NA(s.map(p=>p.shape)),u=t.runWebGPUProgram(i,s,s[0].dtype);s.forEach(p=>t.disposeData(p.dataId));let l=Ue({inputs:{x:u},backend:t,attrs:{shape:a}});return t.disposeData(u.dataId),l}function sue(r,e,t){let n=I.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>Ue({inputs:{x:s},backend:t,attrs:{shape:[b.sizeFromShape(s.shape.slice(0,e)),b.sizeFromShape(s.shape.slice(e))]}})),outShape:n}}function DA(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,e[0].shape)[0],a=I.computeOutShape(e.map(l=>l.shape),s);if(b.sizeFromShape(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);let i=e.filter(l=>b.sizeFromShape(l.shape)>0);if(i.length===1)return wr({inputs:{x:i[0]},backend:t});let u=i.map(l=>l.shape);return I.assertParamsConsistent(u,s),Rx(i,s,t)}var eW={kernelName:us,backendName:"webgpu",kernelFunc:DA};var PA=class{constructor(e,t){this.variableNames=["A"];this.uniforms=`pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; outWidth : i32; itemsPerBlockRow : i32;
      inChannels : i32;`;this.workPerThread=4;this.workGroupSize=[64,1,1];this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`,this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=this.isChannelsLast?0:1,t=this.isChannelsLast?1:2;return`
    ${he()} {
      ${ke()}

      for(var i = 0; i<${this.workPerThread}; i = i + 1) {
        let flatIndex = index * ${this.workPerThread} + i;

        let rc = getCoordsFromFlatIndex(flatIndex);

        if(flatIndex < uniforms.size) {
          let blockIndex = rc[0];
          let pos = rc[1];

          let offsetY = blockIndex / uniforms.outWidth * uniforms.stride[1] - uniforms.pad[1];
          let d0 = offsetY + uniforms.dilation[1] * pos / uniforms.itemsPerBlockRow;
          var value = 0.0;
          if(d0 < uniforms.aShape[${e}] && d0 >= 0) {
            let offsetX = (blockIndex % uniforms.outWidth) * uniforms.stride[0] -
              uniforms.pad[0];
            let d1 = offsetX + uniforms.dilation[0] * ((pos %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
            let ch = pos % uniforms.inChannels;
            if(d1 < uniforms.aShape[${t}] && d1 >= 0) {
              value = getA(d0, d1, ch);
            }
          }
          setOutputFlat(flatIndex, value);
        }
      }
    }
  `}};function Lx({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=r.shape,l=t.dataFormat==="channelsLast",p=!1,c=!1,m=l?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],f=Ue({inputs:{x:r},backend:n,attrs:{shape:[1,m,t.inChannels]}}),d=Ue({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),h=$m({a:f,b:d,transposeA:p,transposeB:c,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),g=Ue({inputs:{x:h},backend:n,attrs:{shape:t.outShape}});return n.disposeData(f.dataId),n.disposeData(d.dataId),n.disposeData(h.dataId),g}function tW({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:p,strideWidth:c,strideHeight:m,padInfo:f,outWidth:d,outHeight:h,dilationWidth:g,dilationHeight:y,dataFormat:x}=t,T=x==="channelsLast",k=u*l*p,w=h*d,P=[w,k],A=!1,F=!1,E=[],$=Ue({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),W=Ue({inputs:{x:e},backend:n,attrs:{shape:[1,k,-1]}});E.push($),E.push(W);let K=new PA(P,T),B=[{type:"int32",data:[f.left,f.top]},{type:"int32",data:[c,m]},{type:"int32",data:[g,y]},{type:"int32",data:[d]},{type:"int32",data:[p*u]},{type:"int32",data:[p]}],V=n.runWebGPUProgram(K,[$],$.dtype,B),j=Ue({inputs:{x:V},backend:n,attrs:{shape:[1,P[0],P[1]]}});E.push(V),E.push(j);let H=[1,P[0],P[1]],J=new og(H,[1,w,t.outChannels],U().get("WEBGPU_MATMUL_WORK_PER_THREAD"),A,F),X=H[1],ne=H[2],oe=t.outChannels,te=[{type:"int32",data:[X]},{type:"int32",data:[oe]},{type:"int32",data:[ne]}],le=n.runWebGPUProgram(J,[j,W],j.dtype,te),ae=T?[1,h,d,t.outChannels]:[1,t.outChannels,h,d],ge=Ue({inputs:{x:le},backend:n,attrs:{shape:ae}});E.push(le);for(let fe of E)n.disposeData(fe.dataId);return ge}var lg=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.uniforms=`filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      dimAOuter : i32; dimBOuter : i32; dimInner : i32;`;this.isVec4=!0;this.outputShape=e.outShape,b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=[8,8,1];let a=[4,4,1];this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,a),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,this.hasLeakyreluAlpha=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.hasLeakyreluAlpha&&this.variableNames.push("leakyreluAlpha"),[this.fitA,this.fitB]=this.getShapeFit(a),this.shaderKey=`conv2DMMVec4_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(e){let t=this.workGroupSize[1]*e[1],n=this.workGroupSize[0]*e[0],o=n,s=[t,o],a=[o,n],i=this.outputShape[1]*this.outputShape[2],u=this.outputShape[3],l=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[es(s,[i,l]),es(a,[l,u])]}getSampleAWithRemainder(e){return`let flatIndex${e} = getFlatIndex4D(coord, uniforms.xShape);
    let divBy4Remainder${e} = flatIndex${e} % 4;
    let divBy4Index${e} = flatIndex${e} / 4;
    let curData${e} = x.numbers[divBy4Index${e}];
    if (divBy4Remainder${e} == 0) {
      temp = curData${e};
    } else {
      // TODO: This could end up being a redundant load with another one in
      // the same shader invocation. Perhaps there's an opportunity for
      // optimization
      let nextData${e} = x.numbers[divBy4Index${e} + 1];
      if (divBy4Remainder${e} == 1) {
        temp = vec4<f32>(curData${e}.yzw, nextData${e}.x);
      } elseif (divBy4Remainder${e} == 2) {
        temp = vec4<f32>(curData${e}.zw, nextData${e}.xy);
      } elseif (divBy4Remainder${e} == 3) {
        temp = vec4<f32>(curData${e}.w, nextData${e}.xyz);
      }
    }
    `}getUserCode(){let t=dA([4,4,1],this.workGroupSize),s=`let outRow = r / uniforms.outShape[2];
        let outCol = r % uniforms.outShape[2];
        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);
        let WCol = c / uniforms.xShape[3] % uniforms.filterDims[1];
        let inChCoord = c % uniforms.xShape[3];
        var coord = vec4<i32>(
            batch,
            outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
            outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
            inChCoord);
        var resData = vec4<f32>(0.0);
        ${this.convInfo.inChannels%4===0?`// The bounds checking is always needed since we use it to pad zero for
          // the 'same' padding type.
          if (coordsInBounds4D(coord, uniforms.xShape)) {
            resData = x.numbers[getFlatIndex4D(coord, uniforms.xShape) / 4];
          } else {
            resData = vec4<f32>(0.0); }`:`var temp = vec4<f32>(0.0);
          ${this.getSampleAWithRemainder(1)}
          resData = temp;
          if (WCol == (uniforms.filterDims[1] - 1)) {
            coord = vec4<i32>(
              coord.x, coord.y + 1, coord.z + 1 - uniforms.filterDims[1], 0);
              ${this.getSampleAWithRemainder(2)}
            if (inChCoord == 0) {
              resData = vec4<f32>(resData.xyz, temp.x);
            } elseif (inChCoord == 1) {
              resData = vec4<f32>(resData.xy, temp.xy);
            } else {
              resData = vec4<f32>(resData.x, temp.xyz);
            }
          }
          `}
        return resData;`,a=this.fitA?`${s}`:`if (r < uniforms.dimAOuter && c < uniforms.dimInner) {
          ${s}
         }
         return vec4<f32>(0.0);
        `,i=this.fitB?"return W.numbers[row * uniforms.dimBOuter / 4 + col];":`if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter / 4 + col];
         }
         return vec4<f32>(0.0);
        `,u="",l="";if(this.activation){let m=Tn(this.activation,this.isVec4);if(this.hasPreluActivationWeights)u=`fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${m}
        }`;else{if(this.hasLeakyreluAlpha)throw u=`fn activation(a: vec4<f32>) -> vec4<f32> {
          let b = getLeakyreluAlphaAtOutCoords();
          ${m}
        }`,new Error("Leakyrelu is not supported.");u=`
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          ${m}
        }`}l="value = activation(value, outCoord);"}let p=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
        ${u}
        fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          let r = row;
          let c = col * 4;
          var batch = i32(globalId.z);
          ${a}
        }

        fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          ${i}
        }

        fn mm_write(row : i32, col : i32, valueInput : vec4<f32>, globalId : vec3<u32>) {
          var batch = i32(globalId.z);
          var value = valueInput;
          if (row < uniforms.dimAOuter && col * 4 < uniforms.dimBOuter)
          {
            let outCoord = vec4<i32>(
              batch,
              row / uniforms.outShape[2],
              row % uniforms.outShape[2],
              col * 4);
            ${p}
            ${l}
            setOutput(outCoord[0], outCoord[1], outCoord[2], outCoord[3],
              value);
          }
        }
        ${t}
      `}};var pg=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.outputShape=e.outShape,b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=Jh(this.dispatchLayout,this.outputShape),this.elementsPerThread=tg(this.dispatchLayout,this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(){let e=this.workGroupSize[1]*this.elementsPerThread[1],t=this.workGroupSize[0]*this.elementsPerThread[0],n=e>t?e:t;b.assert(n%this.workGroupSize[0]==0&&n%this.workGroupSize[1]==0,()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y");let o=[e,n],s=[n,t],a=this.outputShape[1]*this.outputShape[2],i=this.outputShape[3],u=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[es(o,[a,u]),es(s,[u,i])]}getUserCode(){let e=ng(this.elementsPerThread,this.workGroupSize),t=`
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.xShape[3]);
    let WCol = col / uniforms.xShape[3] % uniforms.filterDims[1];
    let coord = vec4<i32>(
        batch,
        outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
        outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
        col % uniforms.xShape[3]);
    // The bounds checking is always needed since we use it to pad zero for the
    // 'same' padding type.
    if(coordsInBounds4D(coord, uniforms.xShape)) {
      return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];
    }
    return 0.0;`,n=this.fitA?`${t}`:`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${t}
    }
    return 0.0;
    `,o=this.fitB?"return W.numbers[row * uniforms.dimBOuter + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter + col];
	 }
	 return 0.0;
	 `,s="",a="";if(this.activation){let l=Tn(this.activation,!1);this.hasPreluActivationWeights?s=`fn activation(a: f32, outCoord : vec4<i32>) -> f32 {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${l}
                }`:s=`
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
                    ${l}
                  }
                `,a="value = activation(value, outCoord);"}let i=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
    ${s}
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      ${n}
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      ${o}
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      ${i}
      ${a}
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }
    ${e}
  `}};var cg=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;";this.workGroupSize=[128,1,1];this.outputShape=e.outShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,this.shaderKey=`conv2DNaive_${this.activation}`}getUserCode(){let e="",t="";if(this.activation){let s=Tn(this.activation);this.hasPreluActivationWeights?e=`fn activation(a : f32, outCoord : vec4<i32>) -> f32{
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${s}
             }`:e=`
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32{
                    ${s}
                  }
                `,t="value = activation(value, outCoord);"}let n=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${e}
      fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32 {
        let coord = vec4<i32>(batch, row, col, chan);
        if(coordsInBounds4D(coord, uniforms.xShape)) {
          return getX(batch, row, col, chan);
        }
        return 0.0;
      }

      fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
        let coord = vec4<i32>(row, col, xChannel, outChannel);
        if(coordsInBounds4D(coord, uniforms.wShape)) {
          return getW(row, col, xChannel, outChannel);
        }
        return 0.0;
      }

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          ${n}
          ${t}
          setOutput(batch, row, col, chan, value);
        }
      }

      ${he()} {
        ${ke()}
        let coords = getOutputCoords(globalId, index);
        let batch = coords[0];
        let outChannel = coords[3];

        var acc = 0.0;

        for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
          for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
            for (var xChannel = 0; xChannel < uniforms.xShape[3]; xChannel = xChannel + 1) {
              let coordRow = coords[1] * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
              let coordCol = coords[2] * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
              let v = readInp(batch, coordRow, coordCol, xChannel);
              let f = readFilt(row, col, xChannel, outChannel);
              acc = acc + v * f;
            }
          }
        }

        writeResult(batch, coords[1], coords[2], outChannel, acc);
      }
    `}};function aue(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=t,c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,c);if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))return Lx({x:o,filter:s,convInfo:m,backend:n});if(U().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")&&o.shape[0]===1)return tW({x:o,filter:s,convInfo:m,backend:n});let f,d=[m.padInfo.top,m.padInfo.left],h=[{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[...d]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]}],g=U().getBool("WEBGPU_USE_NAIVE_CONV2D");if(g?f=new cg(m):(m.inChannels%4==0||m.inChannels===3&&m.padInfo.type==="VALID")&&m.outChannels%4==0&&m.outChannels>=64?f=new lg(m):f=new pg(m),!g){let y=m.outShape[1]*m.outShape[2],x=m.outShape[3],T=m.filterHeight*m.filterWidth*m.inShape[3];h.push({type:"int32",data:[y]},{type:"int32",data:[x]},{type:"int32",data:[T]})}return n.runWebGPUProgram(f,[o,s],o.dtype,h)}var rW={kernelName:uo,backendName:"webgpu",kernelFunc:aue};var FA=class{constructor(e){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.outputShape=e.inShape,b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=Jh(this.dispatchLayout,this.outputShape),this.elementsPerThread=tg(this.dispatchLayout,this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.shaderKey=`conv2DDerInputMM_${this.elementsPerThread}`}getUserCode(){return`
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
    let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
    let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
      return 0.0;
    }
    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
      return 0.0;
    }
    let coord = vec4<i32>(
        batch,
        i32(xR),
        i32(xC),
        col % uniforms.outBackprop[3]);
    return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];
    }
    return 0.0;
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      let coordX = uniforms.filterDims.x - 1 -
          row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let coordY = uniforms.filterDims.y - 1 -
          (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
          coordX >= 0 && coordY >= 0) {
        let coord = vec4<i32>(coordX, coordY, col,
            row % uniforms.outBackprop[3]);
        return W.numbers[getFlatIndex4D(coord, uniforms.wShape)];
      }
      return 0.0;
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }

    ${ng(this.elementsPerThread,this.workGroupSize)}
  `}};var MA=class{constructor(e){this.variableNames=["dy","W"];this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>;";this.workGroupSize=[64,1,1];this.outputShape=e.inShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`
    ${he()} {
      ${ke()}
      let coords = getOutputCoords(globalId, index);
      if (coordsInBounds4D(coords, uniforms.outShape)) {
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}]), coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = dyR;

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = dyC;

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutput(coords[0], coords[1], coords[2], coords[3], dotProd);
      }
    }
  `}};function iue(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n,c=I.convertConv2DDataFormat(l),m=I.computeConv2DInfo(a,s.shape,i,1,u,p,!1,c),f=[{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[m.filterHeight-1-m.padInfo.top,m.filterWidth-1-m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.batchSize,m.outHeight,m.outWidth,m.outChannels]}],d;if(U().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))d=new MA(m);else{d=new FA(m);let h=m.inShape[1]*m.inShape[2],g=m.inShape[3],y=m.filterHeight*m.filterWidth*m.outChannels;f.push({type:"uint32",data:[h]},{type:"uint32",data:[g]},{type:"uint32",data:[y]})}return t.runWebGPUProgram(d,[o,s],"float32",f)}var nW={kernelName:lo,backendName:"webgpu",kernelFunc:iue};var uue=dt({opType:we.COS}),oW={kernelName:po,backendName:"webgpu",kernelFunc:uue};var lue=dt({opType:we.COSH}),sW={kernelName:co,backendName:"webgpu",kernelFunc:lue};var EA=class{constructor(e,t,n,o){this.variableNames=["Image","Boxes","BoxInd"];this.uniforms="extrapolationValue : f32;";this.workGroupSize=[64,1,1];let[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId=o==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,o,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,i,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
      fn writeResult(coords : vec4<i32>, value : f32) {
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutput(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
      ${he()} {
        ${ke()}
        let height_ratio = f32(${n});
        let width_ratio = f32(${a});
        let coords = getOutputCoords(globalId, index);
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${o};
        let width_scale = ${i};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          writeResult(coords, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          writeResult(coords, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          writeResult(coords, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          writeResult(coords,newValue);
        }
      }
    `}};var pue=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,p=new EA(o.shape[3],s.shape,i,u),c=[{type:"float32",data:[l]}];return t.runWebGPUProgram(p,[o,s,a],"float32",c)},aW={kernelName:Ys,backendName:"webgpu",kernelFunc:pue};var RA=class{constructor(e,t){this.variableNames=["x"];this.workGroupSize=[64,1,1];this.uniforms="blockSize : i32;";this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.size=b.sizeFromShape(this.outputShape),this.dataFormat=t}getUserCode(){return`
      ${he()} {
        ${ke()}
        if (index < uniforms.size) {
          let coords = getOutputCoords(globalId, index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputFlat(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function cue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],c=u*s,m=l*s,f=p/(s*s),d=a==="NHWC"?[i,c,m,f]:[i,f,c,m],h=[{type:"int32",data:[s]}],g=new RA(d,a);return t.runWebGPUProgram(g,[o],o.dtype,h)}var iW={kernelName:Qs,backendName:"webgpu",kernelFunc:cue};var mg=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;";this.workGroupSize=[4,4,4];this.isVec4=!0;this.outputShape=e.outShape,this.dispatchLayout={x:[0,1],y:[2],z:[3]},this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,4,4]),b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise3x3_${n}`}getUserCode(){let e="",t="";if(this.activation){let s=Tn(this.activation,this.isVec4);this.hasPreluActivation?e=`fn activation(a : vec4<f32>, globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByGlobalId(globalId, globalIndex);
          ${s}
        }`:e=`
        fn activation(a : vec4<f32>, globalId : vec3<u32>, globalIndex : i32) -> vec4<f32> {
            ${s}
          }
        `,t="dotProd[i] = activation(dotProd[i], globalId, index);"}let n=this.addBias?"dotProd[i] = dotProd[i] + getBiasAtOutCoordsByCoords(coords);":"";return`
      ${e}

      ${he()} {
        ${ke()}
        let batch = 0;
        let r = i32(globalId.x);
        let c = i32(globalId.y) * 4;
        let d2 = i32(globalId.z) * 4;
        let xRCCorner = vec2<i32>(r, c) * uniforms.stride - uniforms.pad;
        let d1 = d2;
        let q = 0;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;

        var wVals : array<vec4<f32>, 9>;
        wVals[0] = getW(0, 0, d1, q);
        wVals[1] = getW(0, 1, d1, q);
        wVals[2] = getW(0, 2, d1, q);
        wVals[3] = getW(1, 0, d1, q);
        wVals[4] = getW(1, 1, d1, q);
        wVals[5] = getW(1, 2, d1, q);
        wVals[6] = getW(2, 0, d1, q);
        wVals[7] = getW(2, 1, d1, q);
        wVals[8] = getW(2, 2, d1, q);

        var xVals : array<array<vec4<f32>, 6>, 3>;
        for (var wR = 0; wR < 3; wR = wR + 1) {
          let xR = xRCorner + wR * uniforms.dilation[0];
          for (var wC = 0; wC < 6; wC = wC + 1) {
            let xC = xCCorner + wC * uniforms.dilation[1];
            if (xR < 0 || xR >= uniforms.inDims[0] || xC < 0 || xC >= uniforms.inDims[1]) {
              xVals[wR][wC] = vec4<f32>(0.0);
            } else {
              xVals[wR][wC] = getX(batch, xR, xC, d1);
            }
          }
        }

        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        for (var wR = 0; wR < 3; wR = wR + 1) {
          for (var wC = 0; wC < 3; wC = wC + 1) {
            let indexW = wR * 3 + wC;
            dotProd[0] = dotProd[0] + xVals[wR][0 + wC] * wVals[indexW];
            dotProd[1] = dotProd[1] + xVals[wR][1 + wC] * wVals[indexW];
            dotProd[2] = dotProd[2] + xVals[wR][2 + wC] * wVals[indexW];
            dotProd[3] = dotProd[3] + xVals[wR][3 + wC] * wVals[indexW];
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d2);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            ${n}
            ${t}
            setOutput(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
          }
        }
      }
    `}};var fg=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;";this.workGroupSize=[256,1,1];this.outputShape=e.outShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.activation}_${this.convInfo.outChannels/this.convInfo.inChannels}`}getUserCode(){let e=this.convInfo.outChannels/this.convInfo.inChannels,t="",n="";if(this.activation){let a=Tn(this.activation,!1);this.hasPreluActivation?t=`fn activation(a : f32, globalId : vec3<u32>, index : i32) -> f32 {
          let b = getPreluActivationWeightsAtOutCoordsByGlobalId(globalId, index);
          ${a}
        }`:t=`
          fn activation(a : f32, globalId : vec3<u32>, index : i32) -> f32 {
            ${a}
          }
        `,n="dotProd = activation(dotProd, globalId, index);"}let o=this.addBias?"dotProd = dotProd + getBiasAtOutCoordsByGlobalId(globalId, index);":"";return`
      ${t}

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          setOutput(batch, row, col, chan, value);
        }
      }

      ${he()} {
        ${ke()}
        let coords = getOutputCoords(globalId, index);
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
        let d2 = coords[3];
        let d1 = d2 / ${e};
        let q = d2 - d1 * ${e};

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + ${this.convInfo.filterHeight} * uniforms.dilation[0];
        let inputColEnd = inputColStart + ${this.convInfo.filterWidth} * uniforms.dilation[1];

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] && inputColEnd < uniforms.inDims[1]) {
            // Here using a constant value |this.convInfo.filterHeight| instead
            // of uniform value is in order to loop unrolling.
            for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          }

        ${o}
        ${n}
        writeResult(batch, coords[1], coords[2], d2, dotProd);
      }
    `}};function mue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:l}=n,p=u;p==null&&(p=[1,1]);let c=I.computeConv2DInfo(o.shape,s.shape,a,p,i,l,!0),m;c.batchSize===1&&c.inHeight===c.outHeight&&c.inWidth===c.outWidth&&c.strideHeight===1&&c.strideWidth===1&&c.filterHeight===c.filterWidth&&c.inChannels===c.outChannels&&c.filterHeight===3&&c.inChannels%4==0?m=new mg(c):m=new fg(c);let f=[{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]}];return t.runWebGPUProgram(m,[o,s],o.dtype,f)}var uW={kernelName:mo,backendName:"webgpu",kernelFunc:mue};var LA=_t({opSnippet:Le.MUL,cpuKernelImpl:vG,supportsComplex:!0}),lW={kernelName:No,backendName:"webgpu",kernelFunc:LA};var $A=class{constructor(e,t,n){this.variableNames=["x"];this.uniforms="reduceSize : i32;";this.inputShape=[e.batchSize,e.inSize];let[o]=I.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=o.length===0?[1]:o,this.reductionFactor=2;let s=256,a=Math.min(Math.ceil(e.inSize/this.reductionFactor),s);this.workGroupSize=[a,1,1],this.dispatchLayout={x:[],y:this.outputShape.map((i,u)=>u)},this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.reduceType=t,this.shaderKey=`reduce_${t}_${n}`}getUserCode(){let e=this.workGroupSize[0]>1,t="",n="0.0";this.reduceType==="min"||this.reduceType==="max"?(t=`
         if (isNanCustom(candidate)) {
          bestValue = uniforms.NAN;
         } elseif (candidate ${this.reduceType==="min"?"<":">"}
           bestValue)
           {  bestValue = candidate; }`,n="f32(x.numbers[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?t=" bestValue = bestValue + candidate; ":this.reduceType==="prod"&&(t=" bestValue = bestValue * candidate; ",n="1.0");let o=this.reduceType==="mean"?"setOutputFlat(flatOutputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputFlat(flatOutputIndex, bestValue);",s=`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `,a=`
       xBestValues[localId.x] = bestValue;
       ${this.reduceType==="sum"||this.reduceType==="mean"||this.reduceType==="prod"?`bestValue = ${n};`:" "}
       var currentSize = WorkGroupSize;
       for(; currentSize > 1;) {
         workgroupBarrier();
         for (var w = 0; w < ${this.reductionFactor}; w = w + 1) {
           let i = i32(localId.x) * ${this.reductionFactor} + w;
           if (i < currentSize) {
             let candidate = xBestValues[i];
             ${t}
           }
         }
         workgroupBarrier();
         xBestValues[localId.x] = bestValue;
         currentSize = DIV_CEIL(currentSize, ${this.reductionFactor});
         ${this.reduceType==="sum"||this.reduceType==="mean"||this.reduceType==="prod"?`if(currentSize > 1) { bestValue = ${n}; }`:""}
       }
       if (localId.x == 0u) {
         ${o}
       }
     `;return`
       fn DIV_CEIL(a : i32, b : i32) -> i32 {
        return ((a - 1) / b + 1);
       }
       let WorkGroupSize = ${this.workGroupSize[0]};
       ${e?s:""}
       fn getOffset(globalId : vec3<u32>, index : i32) -> i32 {
         let outputCoords = getOutputCoords(globalId, index);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
         return offset;
       }
       ${he()} {
         ${ke()}
         let offset= getOffset(globalId, index);
         var bestValue = ${n};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);
         for (var w = 0; w < WorkPerThread; w = w + 1) {
           let i = i32(globalId.x) * WorkPerThread + w;
           if (i < Length) {
             let candidate = f32(x.numbers[offset + i]);
             ${t}
           }
         }
         let flatOutputIndex = i32(globalId.y);
         ${e?a:o}
       }
     `}};function ci(r,e,t,n,o){let s=r.shape.length,a=[],i=b.parseAxisParam(e,r.shape),u=i,l=I.getAxesPermutation(u,s),p=r;l!=null&&(p=ts({inputs:{x:r},attrs:{perm:l},backend:o}),u=I.getInnerMostAxes(u.length,s),a.push(p)),I.assertAxesAreInnerMostDims(n,u,s);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),f=c;t&&(f=I.expandShapeToKeepDim(c,i));let d;if((n==="max"||n==="prod")&&o.shouldExecuteOnCPU([p])){let h=o.tensorMap.get(p.dataId).values;switch(n){case"max":let g=kG(h,b.sizeFromShape(m),f,r.dtype);d=o.makeTensorInfo(f,r.dtype,g);break;case"prod":let{outVals:y,outShape:x,outDtype:T}=_G(p.shape,p.dtype,h,u);d=o.makeTensorInfo(x,T,y);break;default:throw new Error(`${n} CPU implementation is not yet supported.`)}}else{let h=b.sizeFromShape(m),y=b.sizeFromShape(p.shape)/h,x={windowSize:h,inSize:h,batchSize:y,outSize:1},T=n==="mean"?"float32":zi(r.dtype),k=[{type:"int32",data:[h]}],w=new $A(x,n,T),P=o.runWebGPUProgram(w,[p],T,k);a.push(P),d=Ue({inputs:{x:P},attrs:{shape:f},backend:o})}return a.forEach(h=>o.disposeData(h.dataId)),d}function dg(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return ci(o,s,a,"sum",t)}var pW={kernelName:zo,backendName:"webgpu",kernelFunc:dg};function fue(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=I.decodeEinsumEquation(o,s.length);I.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=I.getEinsumComputePath(i,u),c=p.length,m=null,f=a.length,d=[];for(let h=0;h<c;++h){for(let g of p[h]){let{permutationIndices:y,expandDims:x}=I.getEinsumPermutation(f,u[g]),T;I.isIdentityPermutation(y)?T=s[g]:(T=ts({inputs:{x:s[g]},backend:t,attrs:{perm:y}}),d.push(T));let k=T.shape.slice();for(let w=0;w<x.length;++w)k.splice(x[w],0,1);b.arraysEqual(T.shape,k)||(T=Ue({inputs:{x:T},backend:t,attrs:{shape:k}}),d.push(T)),m===null?m=T:(m=LA({inputs:{a:T,b:m},backend:t}),d.push(m))}h<c-1&&(l[h]>=0&&(m=dg({inputs:{x:m},backend:t,attrs:{axis:l[h]-(a.length-f),keepDims:!1}}),d.push(m)),f--)}for(let h of d)h!==m&&t.disposeData(h.dataId);return m}var cW={kernelName:Mu,backendName:"webgpu",kernelFunc:fue};var due=dt({opType:we.ELU}),mW={kernelName:ho,backendName:"webgpu",kernelFunc:due};var hue=_t({opSnippet:Le.EQUAL,dtype:"bool",cpuKernelImpl:pG}),fW={kernelName:Zs,backendName:"webgpu",kernelFunc:hue};var BA=dt({opType:we.EXP,cpuKernelImpl:cG,dtype:"float32"}),dW={kernelName:go,backendName:"webgpu",kernelFunc:BA};function $x(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(b.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),Ue({inputs:{x:s},backend:n,attrs:{shape:i}})}var hW={kernelName:ls,backendName:"webgpu",kernelFunc:$x};var gue=dt({opType:we.EXPM1,cpuKernelImpl:mG}),gW={kernelName:Js,backendName:"webgpu",kernelFunc:gue};var OA=class{constructor(e){this.variableNames=[];this.outputShape=[];this.uniforms="value : f32;";this.workGroupSize=[64,1,1];this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){return`
    ${he()} {
      ${ke()}
      if (index < uniforms.size) {
        setOutputFlat(index, uniforms.value);
      }
    }
  `}};function xu(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||b.inferDtype(o),s==="string"){let a=b.getArrayFromDType(s,b.sizeFromShape(n));return a.fill(o),e.makeTensorInfo(n,s,a)}else{let a=new OA(n),i=[{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],s,i)}}var bW={kernelName:Ua,backendName:"webgpu",kernelFunc:xu};var zA=class{constructor(e){this.outputShape=[];this.variableNames=["x"];this.workGroupSize=[64,1,1];this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){return`
      ${he()} {
        ${ke()}

        if (index < uniforms.size) {
          let coords = getOutputCoords(globalId, index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputFlat(index, outputValue);
        }
      }
    `}};var yW={kernelName:ea,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new zA(t.shape);return n.runWebGPUProgram(o,[t],t.dtype)}};var bue=dt({opType:we.FLOOR,cpuKernelImpl:fG}),xW={kernelName:bo,backendName:"webgpu",kernelFunc:bue};var yue=_t({opSnippet:Le.INT_DIV,dtype:"int32"}),TW={kernelName:yo,backendName:"webgpu",kernelFunc:yue};var kW=(r,e,t,n,o)=>{let s=[n,...t];return o&&s.push(o),r.createBindGroup({layout:e,entries:s.map((a,i)=>({binding:i,resource:a}))})},Bx=(r,e,t,n,o,s=!1)=>{let a={dtype:o.dtype,shape:o.shape},i=Q3(n,a,e,s),u=r.createShaderModule({code:i});return r.createComputePipeline({layout:t,compute:{module:u,entryPoint:"main"}})};function Ox(r,e,t,n="",o=""){return(r.workGroupSize?r.workGroupSize.join(","):"")+e.map(a=>a.length).join(",")+t.join(",")+r.variableNames.join(",")+n+o+r.shaderKey}function GA(r){let{externalImage:e,backend:t,attrs:n,outShape:o,useImport:s}=r,{numChannels:a}=n,i=b.sizeFromShape(o),u=b.computeStrides(o),l=t.makeTensorInfo(o,"int32"),p=t.getFromPixelsProgram(s?"import":"copyExternal");p.updateOutputShape(o);let c=[l.shape],m=[l.dtype,s?"import":"copyExternal"],f=Ox(p,c,m),d=p.getLayout(t.device),h=t.getAndSavePipeline(f,()=>Bx(t.device,p,d.pipelineLayout,[],l,!0));p.setPipeline(h),s||t.queue.copyExternalImageToTexture({source:e,origin:{x:0,y:0}},{texture:p.makeInputTexture(t.device,o[1],o[0])},[o[1],o[0]]);let g=t.tensorMap.get(l.dataId);g.bufferInfo.buffer=t.acquireBuffer(g.bufferInfo.byteSize);let y=[i,a,...u,...p.dispatch];p.setUniform(t.device,y);let x;if(s){let T={source:e};x=t.device.importExternalTexture(T)}else x=p.inputTexture.createView();return t.runFromPixelsProgram(p,g.bufferInfo.buffer,d,x,l.dataId),l}var IW={kernelName:vl,backendName:"webgpu",kernelFunc:xue},Bm;function xue(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n;if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let a=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,u=typeof HTMLCanvasElement!="undefined"&&o instanceof HTMLCanvasElement,l=typeof ImageBitmap!="undefined"&&o instanceof ImageBitmap,[p,c]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],m=[c,p,s];if(U().getBool("WEBGPU_USE_IMPORT")&&a)return GA({externalImage:o,backend:t,attrs:n,outShape:m,useImport:!0});if((a||i)&&(Bm==null&&(Bm=document.createElement("canvas").getContext("2d")),Bm.canvas.width=p,Bm.canvas.height=c,Bm.drawImage(o,0,0,p,c),o=Bm.canvas),l||u||a||i)return GA({externalImage:o,backend:t,attrs:n,outShape:m,useImport:!1});let f=o.data,d=f;if(s!=null&&s!==4){d=new Uint8Array(o.width*o.height*s);let y=f.length,x=0;for(let T=0;T<y;T++)T%4<s&&(d[x++]=f[T])}let h=t.makeTensorInfo(m,"int32"),g=t.tensorMap.get(h.dataId);return g.values=new Int32Array(d),t.maybeReleaseBuffer(h.dataId),t.uploadToGPU(h.dataId),h}var WA=class{constructor(e,t,n,o,s){this.uniforms="varianceEpsilon : f32;";this.workGroupSize=[128,1,1];this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),o!=null&&(I.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset")),s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale")),this.offsetShape=o,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetAtOutCoordsByGlobalId(globalId, index)");let t="1.0";this.scaleShape!=null&&(t="getScaleAtOutCoordsByGlobalId(globalId, index)");let n=this.outputShape.length,o=Mt(n),s="setOutput(coords[0], coords[1], coords[2], coords[3], value);";return n===2&&(s="setOutput(coords[0], coords[1], value);"),n===3&&(s="setOutput(coords[0], coords[1], coords[2], value);"),`
      fn writeResult(coords : ${o}, value : f32) {
        if (coordsInBounds${n}D(coords, uniforms.outShape)) {
          ${s}
        }
      }
      ${he()} {
        ${ke()}
        let coords = getOutputCoords(globalId, index);
        let xValue = getXAtOutCoordsByGlobalId(globalId, index);
        let meanValue = getMeanAtOutCoordsByGlobalId(globalId, index);
        let varianValue = getVarianceAtOutCoordsByGlobalId(globalId, index);
        let offsetValue = ${e};
        let scaleValue = ${t};
        let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
        writeResult(coords,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
      }
  `}};var CW={kernelName:xo,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n,scale:o,offset:s,mean:a,variance:i}=r,{varianceEpsilon:u}=e,l=t,p=[n,a,i],c=null;s!=null&&(c=s.shape,p.push(s));let m=null;o!=null&&(m=o.shape,p.push(o));let f=new WA(n.shape,a.shape,i.shape,c,m),d=[{type:"float32",data:[u]}];return l.runWebGPUProgram(f,p,n.dtype,d)}};function Tue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=n,h=I.convertConv2DDataFormat(p),g=I.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!1,h),y=a!=null,x=i!=null,T;if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))return Lx({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:f,preluActivationWeights:i,leakyreluAlpha:d});let k=U().getBool("WEBGPU_USE_NAIVE_CONV2D"),w=g.inChannels%4==0&&g.outChannels%4==0,P=[g.padInfo.top,g.padInfo.left],A=[{type:"int32",data:[g.filterHeight,g.filterWidth]},{type:"int32",data:[...P]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]}];if(k)T=new cg(g,y,f,x);else{w?T=new lg(g,y,f,x):T=new pg(g,y,f,x);let E=g.outShape[1]*g.outShape[2],$=g.outShape[3],W=g.filterHeight*g.filterWidth*g.inShape[3];A.push({type:"int32",data:[E]},{type:"int32",data:[$]},{type:"int32",data:[W]})}let F=[o,s];return y&&F.push(a),x&&F.push(i),t.runWebGPUProgram(T,F,o.dtype,A)}var vW={kernelName:Cs,backendName:"webgpu",kernelFunc:Tue};function kue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:c,activation:m}=n,f=p;f==null&&(f=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(u,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`);let d=I.computeConv2DInfo(o.shape,s.shape,u,f,l,c,!0),h=[o,s],g=a!=null,y=i!=null;g&&h.push(a),y&&h.push(i);let x;d.batchSize===1&&d.inHeight===d.outHeight&&d.inWidth===d.outWidth&&d.strideHeight===1&&d.strideWidth===1&&d.filterHeight===d.filterWidth&&d.inChannels===d.outChannels&&d.filterHeight===3&&d.inChannels%4==0?x=new mg(d,g,m,y):x=new fg(d,g,m,y);let T=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]}];return t.runWebGPUProgram(x,h,"float32",T)}var wW={kernelName:vs,backendName:"webgpu",kernelFunc:kue};var UA=class{constructor(e,t){this.variableNames=["A","indices"];this.workGroupSize=[64,1,1];this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.size=b.sizeFromShape(this.outputShape),this.sliceDim=e,this.uniforms=`sliceDim : i32; strides : ${Mt(e)};`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
        ${he()} {
          ${ke()}
          let coords = getOutputCoords(globalId, index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }
          if (index < uniforms.size) {
            setOutputFlat(index, getA(flattenIndex, coords[1]));
          }
        }
      `}};function Iue(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,a=s[s.length-1],i=b.sizeFromShape(n.shape),[u,l,p,c]=I.prepareAndValidate(n,o),m=Ue({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),f=Ue({inputs:{x:n},backend:t,attrs:{shape:[b.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let x=t.readSync(o.dataId),T=t.bufferSync(n),k=dG(x,T,n.dtype,l,a,p,c,n.shape,i);return t.makeTensorInfo(u,n.dtype,k.values)}let d=new UA(a,[l,p]),h=[{type:"int32",data:[a]},{type:"int32",data:c}],g=t.runWebGPUProgram(d,[f,m],f.dtype,h),y=Ue({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeData(m.dataId),t.disposeData(f.dataId),t.disposeData(g.dataId),y}var SW={kernelName:ta,backendName:"webgpu",kernelFunc:Iue};var KA=class{constructor(e,t){this.variableNames=["A","indices"];this.workGroupSize=[64,1,1];this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=Cue(this.aShape,"i32");return`
      ${he()} {
        ${ke()}
        let resRC = getOutputCoords(globalId, index);
        if (index < uniforms.size) {
          setOutputFlat(index, getA(${e}));
        }
      }
    `}};function Cue(r,e="int"){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push(`${e}(getIndices(resRC.x, resRC.z))`):n.push(`${t[o]}`);return n.join()}function vue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,u=b.parseAxisParam(a,o.shape)[0],l=t.readSync(s.dataId),p=o.shape[u];for(let k=0;k<l.length;++k){let w=l[k];b.assert(w<=p-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${p-1}]`)}let c=I.segment_util.collectGatherOpShapeInfo(o,s,u,i),m=b.sizeFromShape(s.shape),f=[],d=Ue({inputs:{x:o},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),h=Ue({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,m/c.batchSize]}});f.push(d),f.push(h);let g=[c.batchSize,c.outerSize,m/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([o,s])){let w=t.tensorMap.get(h.dataId).values,P=Ce(h.shape,h.dtype,w),F=t.tensorMap.get(d.dataId).values,E=Ce(d.shape,d.dtype,F),$=hG(E,P,g);return f.forEach(W=>t.disposeData(W.dataId)),t.makeTensorInfo(c.outputShape,$.dtype,$.values)}let y=new KA(d.shape,g),x=t.runWebGPUProgram(y,[d,h],d.dtype);f.push(x);let T=Ue({inputs:{x},backend:t,attrs:{shape:c.outputShape}});return f.forEach(k=>t.disposeData(k.dataId)),T}var _W={kernelName:ps,backendName:"webgpu",kernelFunc:vue};var wue=_t({opSnippet:Le.GREATER,cpuKernelImpl:bG,dtype:"bool"}),AW={kernelName:ra,backendName:"webgpu",kernelFunc:wue};var Sue=_t({opSnippet:Le.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:gG}),NW={kernelName:To,backendName:"webgpu",kernelFunc:Sue};var _ue=_t({opSnippet:Le.LESS,dtype:"bool",cpuKernelImpl:xG}),DW={kernelName:oa,backendName:"webgpu",kernelFunc:_ue};var Aue=_t({opSnippet:Le.LESS_EQUAL,dtype:"bool",cpuKernelImpl:yG}),PW={kernelName:sa,backendName:"webgpu",kernelFunc:Aue};var Nue=dt({opType:we.LOG,cpuKernelImpl:TG}),FW={kernelName:ko,backendName:"webgpu",kernelFunc:Nue};var Due=_t({opSnippet:Le.LOGICAL_AND,dtype:"bool"}),MW={kernelName:aa,backendName:"webgpu",kernelFunc:Due};var Pue=dt({opType:we.LOGICAL_NOT}),EW={kernelName:Pi,backendName:"webgpu",kernelFunc:Pue};function VA(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n;return ci(o,s,a,"max",t)}var RW={kernelName:Io,backendName:"webgpu",kernelFunc:VA};var Fue=_t({opSnippet:Le.MAX,cpuKernelImpl:IG}),LW={kernelName:Co,backendName:"webgpu",kernelFunc:Fue};function Mue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1,p=I.computePool2DInfo(o.shape,s,a,l,i,u),c,m=[];if(p.filterHeight===1&&p.filterWidth===1){if(b.arraysEqual(p.inShape,p.outShape))return wr({inputs:{x:o},backend:t});c=new ug(p),m.push({type:"int32",data:[p.strideHeight,p.strideWidth]})}else c=new ig(p,"max"),m.push({type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]});return t.runWebGPUProgram(c,[o],o.dtype,m)}var $W={kernelName:vo,backendName:"webgpu",kernelFunc:Mue};function Eue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:a}=n;return ci(o,a,s,"mean",t)}var BW={kernelName:wo,backendName:"webgpu",kernelFunc:Eue};function Rue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return ci(o,s,a,"min",t)}var OW={kernelName:So,backendName:"webgpu",kernelFunc:Rue};var Lue=_t({opSnippet:Le.MIN,cpuKernelImpl:CG}),zW={kernelName:_o,backendName:"webgpu",kernelFunc:Lue};var jA=class{constructor(e,t,n){this.uniforms="";this.variableNames=["x"];this.workGroupSize=[64,1,1];this.outputShape=t.map((o,s)=>o[0]+e[s]+o[1]),this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map((o,s)=>{this.uniforms+=` pad${s} : vec2<i32>;`}),this.offset=n==="reflect"?0:1,this.shaderKey=`mirrorPad_${n}`,this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=this.xShape.length,t=this.xShape.map((l,p)=>`uniforms.pad${p}[0]`).join(","),n=this.xShape.map((l,p)=>`uniforms.pad${p}[0] + uniforms.xShape${e>1?`[${p}]`:""}`).join(","),o=e===1?"start":"start[i]",s=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",i=Mt(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${he()} {
        ${ke()}
        let start = ${i}(${t});
        let end = ${i}(${n});
        var outC = getOutputCoords(globalId, index);
        if (index < uniforms.size) {
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${o}) {
              ${a} = ${o} * 2 - ${a} - ${this.offset};
            } elseif(${a} >= ${s}) {
              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputFlat(index, getX(${u}));
        }
      }
    `}};var GW={kernelName:Ao,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{paddings:o,mode:s}=e,a=t,i=o.map(p=>({type:"int32",data:[p[0],p[1]]})),u=new jA(n.shape,o,s);return a.runWebGPUProgram(u,[n],n.dtype,i)}};function $ue(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.tensorMap.get(n.dataId),[a,i]=wG(s.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,a)}let o=new gu(n.shape,we.NEG);return t.runWebGPUProgram(o,[n],n.dtype)}var WW={kernelName:cs,backendName:"webgpu",kernelFunc:$ue};function Bue(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:c}=Tr.nonMaxSuppressionV3Impl(l,p,a,i,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}var UW={kernelName:ua,backendName:"webgpu",kernelFunc:Bue};function Oue(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),c=t.readSync(s.dataId),m=a,f=i,d=u,h=l,{selectedIndices:g,selectedScores:y}=Tr.nonMaxSuppressionV5Impl(p,c,m,f,d,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([y.length],"float32",new Float32Array(y))]}var KW={kernelName:la,backendName:"webgpu",kernelFunc:Oue};function hg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=yu({inputs:{input:n},backend:t}),s=hg({inputs:{x:o},backend:t}),a=Mp({inputs:{input:n},backend:t}),i=hg({inputs:{x:a},backend:t}),u=Ba({inputs:{real:s,imag:i},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),u}else return xu({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var VW={kernelName:Ts,backendName:"webgpu",kernelFunc:hg};function jW(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=yu({inputs:{input:n},backend:t}),s=jW({inputs:{x:o},backend:t}),a=Mp({inputs:{input:n},backend:t}),i=hg({inputs:{x:a},backend:t}),u=Ba({inputs:{real:s,imag:i},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),u}else return xu({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var HW={kernelName:ms,backendName:"webgpu",kernelFunc:jW};function zue(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return $x({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let c=$x({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(c),c}),l=DA({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeData(p.dataId)),l}var qW={kernelName:fs,backendName:"webgpu",kernelFunc:zue};var HA=class{constructor(e,t){this.variableNames=["x"];this.uniforms="constantValue : f32;";this.workGroupSize=[64,1,1];this.outputShape=t.map((n,o)=>n[0]+e[o]+n[1]),this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map((n,o)=>{this.uniforms+=` pad${o} : vec2<i32>;`}),this.xShape=e,this.shaderKey="pad",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=this.xShape.length,t=Mt(e),n=this.xShape.map((c,m)=>`uniforms.pad${m}[0]`).join(","),o=this.xShape.map((c,m)=>`uniforms.pad${m}[0] + uniforms.xShape${e>1?`[${m}]`:""}`).join(","),s=e>1?`${t}(${n})`:`${n}`,a=e>1?`${t}(${o})`:`${o}`,i=e>1?"any(outC < start)":"outC < start",u=e>1?"any(outC >= end)":"outC >= end",l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${he()} {
        ${ke()}
        let start = ${s};
        let end = ${a};
        if (index < uniforms.size) {
          let outC = getOutputCoords(globalId, index);

          if (${i} || ${u}) {
            setOutputFlat(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputFlat(index, getX(${l}));
          }
        }
      }
    `}};var qA=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;if(s.every(l=>b.arraysEqual(l,[0,0])))return wr({inputs:{x:o},backend:t});if(b.sizeFromShape(o.shape)===0){let l=s.map((p,c)=>p[0]+o.shape[c]+p[1]);return xu({backend:t,attrs:{shape:l,value:a,dtype:o.dtype}})}let i=[{type:"float32",data:[a]}];s.map(l=>i.push({type:"int32",data:[l[0],l[1]]}));let u=new HA(o.shape,s);return t.runWebGPUProgram(u,[o],o.dtype,i)},XW={kernelName:Do,backendName:"webgpu",kernelFunc:qA};var Gue=_t({opSnippet:Le.POW}),YW={kernelName:Po,backendName:"webgpu",kernelFunc:Gue};function Wue(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=new sg(Le.PRELU,n.shape,o.shape);return t.runWebGPUProgram(s,[n,o],"float32")}var QW={kernelName:Fo,backendName:"webgpu",kernelFunc:Wue};function Uue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return ci(o,s,a,"prod",t)}var ZW={kernelName:ca,backendName:"webgpu",kernelFunc:Uue};var Kue=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=AG(n,o,s,a);return e.makeTensorInfo([i.length],a,i)},JW={kernelName:Ka,backendName:"webgpu",kernelFunc:Kue};var XA=_t({opSnippet:Le.DIV}),eU={kernelName:fo,backendName:"webgpu",kernelFunc:XA};var Vue=dt({opType:we.RELU}),tU={kernelName:Mo,backendName:"webgpu",kernelFunc:Vue};var jue=dt({opType:we.RELU6}),rU={kernelName:Ro,backendName:"webgpu",kernelFunc:jue};var YA=class{constructor(e,t,n,o,s){this.variableNames=["x"];this.workGroupSize=[64,1,1];this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.alignCorners=o,this.halfPixelCenters=s,this.shaderKey=`resizeBilinear_${o}_${s}_${this.outputShape[1]>1}_${this.outputShape[2]>1}`}getUserCode(){let e=this.alignCorners&&this.outputShape[1]>1,t=this.alignCorners&&this.outputShape[2]>1;return`
      ${he()} {
        ${ke()}
        let coords = getOutputCoords(globalId, index);
        if (all(coords < uniforms.outShape)) {
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            ${e?"f32(uniforms.xShape.y) - 1.0":"f32(uniforms.xShape.y)"},
            ${t?"f32(uniforms.xShape.z) - 1.0":"f32(uniforms.xShape.z)"});

          let effectiveOutSize = vec2<f32>(
            ${e?"f32(uniforms.outShape.y) - 1.0":"f32(uniforms.outShape.y)"},
            ${t?"f32(uniforms.outShape.z) - 1.0":"f32(uniforms.outShape.z)"});

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${this.halfPixelCenters?"(vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC - vec2<f32>(0.5)":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC"};

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutput(b, coords[1], coords[2], d, newValue);
        }
      }
    `}};function Hue(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,size:a,halfPixelCenters:i}=n,[u,l]=a,p=new YA(o.shape,u,l,s,i);return t.runWebGPUProgram(p,[o],"float32")}var nU={kernelName:Eo,backendName:"webgpu",kernelFunc:Hue};var QA=class{constructor(e,t,n,o,s){this.variableNames=["x"];this.workGroupSize=[64,1,1];this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.alignCorners=o,this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${o}_${this.outputShape[1]>1}_${this.outputShape[2]>1}_${s}`}getUserCode(){let e=this.alignCorners?"0.5":"0.0",t;this.halfPixelCenters?t="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":t="vec2<f32>(rc) * effectiveInputOverOutputRatioRC";let n=this.alignCorners&&this.outputShape[1]>1,o=this.alignCorners&&this.outputShape[2]>1;return`
      ${he()} {
        ${ke()}
        let coords = getOutputCoords(globalId, index);
        if (all(coords < uniforms.outShape)) {
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            ${n?"f32(uniforms.xShape.y) - 1.0":"f32(uniforms.xShape.y)"},
            ${o?"f32(uniforms.xShape.z) - 1.0":"f32(uniforms.xShape.z)"});

          let effectiveOutSize = vec2<f32>(
            ${n?"f32(uniforms.outShape.y) - 1.0":"f32(uniforms.outShape.y)"},
            ${o?"f32(uniforms.outShape.z) - 1.0":"f32(uniforms.outShape.z)"});

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${t};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${e})));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutput(b, coords[1], coords[2], d, newValue);
        }
      }
    `}};function que(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=new QA(o.shape,u,l,s,a);return t.runWebGPUProgram(p,[o],o.dtype)}var oU={kernelName:Va,backendName:"webgpu",kernelFunc:que};var ZA=class{constructor(e,t){this.outputShape=[];this.variableNames=["x"];this.workGroupSize=[64,1,1];this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`centerX : f32; centerY : f32; sinRadians : f32;
          cosRadians : f32;`,this.shaderKey="rotate",this.size=b.sizeFromShape(this.outputShape),this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32;",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>;",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${he()} {
          ${ke()}

          if (index < uniforms.size) {
            let coords = getOutputCoords(globalId, index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputFlat(index, outputValue);
          }
        }
      `}};var sU={kernelName:xa,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=new ZA(n.shape,s),[l,p]=I.getImageCenter(a,n.shape[1],n.shape[2]),c=[{type:"float32",data:[l]},{type:"float32",data:[p]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return typeof s=="number"?c.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):c.push({type:"float32",data:s}),i.runWebGPUProgram(u,[n],n.dtype,c)}};var Xue=dt({opType:we.RSQRT,cpuKernelImpl:NG}),aU={kernelName:Lo,backendName:"webgpu",kernelFunc:Xue};var JA=class{constructor(e,t,n,o,s,a,i){this.variableNames=["updates","indices"];this.workGroupSize=[64,1,1];this.atomic=!0;this.outputShape=a,this.type=i,this.dispatchLayout=ve(e),this.dispatch=de(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${o}_${this.sliceDimGreaterThanOne}_${i}`,this.size=b.sizeFromShape(e);let u=Mt(s.length);this.uniforms=`sliceDim : i32; strides: ${u};`,this.updatesRank=o,this.indicesRank=n}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");let t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",o="",s="",a="";this.updatesRank===1?(o="coords[0]",s="flattenedIndex",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.updatesRank===2&&(o="coords[0], coords[1]",s="vec2<i32>(flattenedIndex, coords[1])",a=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        let d0 = index / uniforms.updatesShape[1];
        let d1 = index - d0 * uniforms.updatesShape[1];
        return vec2<i32>(d0, d1);
      }
      `);let i=`getUpdates(${o})`,u=this.type==="int32"?"ignore(atomicAdd(&(result.numbers[flatIndex]), i32(updateValue)));":`
     var oldI32 = atomicLoad(&(result.numbers[flatIndex]));
     var assumed = oldI32 - 1;
     for (; assumed != oldI32;) {
       assumed = oldI32;
       let new = bitcast<f32>(assumed) + updateValue;
       let newI32 = bitcast<i32>(new);
       oldI32 = atomicCompareExchangeWeak(&(result.numbers[flatIndex]), assumed, newI32)[0];
     }
     `;return`
    ${a}

      ${he()} {
        ${ke()}

        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue = ${i};
          let flatIndex = getOutputFlatIndex(${s});

         ${u}
        }
      }`}};function Yue(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:c}=I.calculateShapes(s,o,a),m=[c/l,l];if(c===0)return t.makeTensorInfo(a,o.dtype);let f=Ue({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),d=Ue({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=d.dtype,g=xu({backend:t,attrs:{shape:m,value:0,dtype:h}}),y=[{type:"int32",data:[i]},{type:"int32",data:p}],x=new JA(d.shape,i,f.shape.length,d.shape.length,p,m,h),T=t.runWebGPUProgram(x,[d,f],h,y,g),k=Ue({inputs:{x:T},backend:t,attrs:{shape:a}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(T.dataId),k}var iU={kernelName:da,backendName:"webgpu",kernelFunc:Yue};var eN=class{constructor(e,t,n){this.variableNames=["c","a","b"];this.workGroupSize=[64,1,1];this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let i=0;i<this.outputShape.length;i++)a.push(`${o[i]}`),i<this.cRank&&s.push(`${o[i]}`);e=s.join(),t=a.join()}return`
      ${he()} {
        ${ke()}
        if (index < uniforms.size) {
          let resRC = getOutputCoords(globalId, index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputFlat(index, getA(${t}));
          } else {
            setOutputFlat(index, getB(${t}));
          }
        }
      }
    `}};function Que(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=new eN(n.shape.length,o.shape,o.shape.length);return t.runWebGPUProgram(a,[n,o,s],Ut(o.dtype,s.dtype))}var uU={kernelName:hs,backendName:"webgpu",kernelFunc:Que};var Zue=dt({opType:we.SIGMOID}),lU={kernelName:Bo,backendName:"webgpu",kernelFunc:Zue};var Jue=dt({opType:we.SIN}),pU={kernelName:$o,backendName:"webgpu",kernelFunc:Jue};var ele=dt({opType:we.SINH}),cU={kernelName:ha,backendName:"webgpu",kernelFunc:ele};var tN=_t({opSnippet:Le.SUB,cpuKernelImpl:EG,supportsComplex:!0}),mU={kernelName:Uo,backendName:"webgpu",kernelFunc:tN};function tle(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=b.parseAxisParam([s],o.shape),i=VA({inputs:{x:o},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=I.expandShapeToKeepDim(i.shape,a),l=Ue({inputs:{x:i},backend:t,attrs:{shape:u}}),p=tN({inputs:{a:o,b:l},backend:t}),c=BA({inputs:{x:p},backend:t}),m=dg({inputs:{x:c},backend:t,attrs:{axis:a,keepDims:!1}}),f=Ue({inputs:{x:m},backend:t,attrs:{shape:u}}),d=XA({inputs:{a:c,b:f},backend:t});return t.disposeData(i.dataId),t.disposeData(l.dataId),t.disposeData(p.dataId),t.disposeData(c.dataId),t.disposeData(m.dataId),t.disposeData(f.dataId),d}var fU={kernelName:Go,backendName:"webgpu",kernelFunc:tle};var rle=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((y,x)=>y*x),u=[[0,0]];u.push(...a);for(let y=1+s.length;y<o.shape.length;++y)u.push([0,0]);let l=[],p=qA({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),c=I.getReshaped(p.shape,s,i,!1),m=I.getPermuted(c.length,s.length,!1),f=I.getReshapedPermuted(p.shape,s,i,!1),d=Ue({inputs:{x:p},backend:t,attrs:{shape:c}}),h=ts({inputs:{x:d},backend:t,attrs:{perm:m}}),g=Ue({inputs:{x:h},backend:t,attrs:{shape:f}});return l.push(p),l.push(d),l.push(h),l.forEach(y=>t.disposeData(y.dataId)),g},dU={kernelName:bs,backendName:"webgpu",kernelFunc:rle};var rN=class{constructor(e,t,n,o,s,a,i=!0){this.variableNames=["updates","indices","defaultValue"];this.workGroupSize=[64,1,1];this.workPerThread=4;this.outputShape=a,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let u=t>1;this.shaderKey=`scatter_${n}_${o}_${u}`,this.size=b.sizeFromShape(this.outputShape);let l=Mt(s.length);this.uniforms=`updateSize : i32; sliceDim : i32; strides: ${l};`;let p="";n===1?p="i":n===2&&(p="i, j"),this.indicesSnippet=`getIndices(${p})`;let c="";o===1?c="i":o===2&&(c="i, coords[1]"),this.updatesSnippet=`getUpdates(${c})`,this.strideString=u?"uniforms.strides[j]":"uniforms.strides"}getUserCode(){return`
      ${he()} {
        ${ke()}

        let globalIndex = index * ${this.workPerThread};
        if (globalIndex < uniforms.size) {
          var sum = vec4<f32>(0.0);
          var found = vec4<bool>(false);
          for (var i = 0; i < uniforms.updateSize; i = i + 1) {
            var flattenedIndex = 0;
            for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
              let indexInside = i32(round(${this.indicesSnippet}));
              flattenedIndex = flattenedIndex + indexInside * ${this.strideString};
            }
            for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
              let curIndex = globalIndex + innerIndex;
              let coords = getCoordsFromFlatIndex(curIndex);
              if (flattenedIndex == coords[0]) {
                sum[innerIndex] = sum[innerIndex] + ${this.updatesSnippet};
                found[innerIndex] = true;
              }
            }
          }
          for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
            let curIndex = globalIndex + innerIndex;
            if (curIndex < uniforms.size)
            {
              setOutputFlat(curIndex, mix(getDefaultValue(), sum[innerIndex], f32(found[innerIndex])));
            }
          }
        }
      }`}};function nle(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,strides:p,outputSize:c}=I.calculateShapes(s,o,i),m=!1,f=[{type:"int32",data:[l]},{type:"int32",data:[u]},{type:"int32",data:p}],d=new rN(l,u,o.shape.length,s.shape.length,p,[c,1],m),h=t.runWebGPUProgram(d,[s,o,a],s.dtype,f),g=Ue({inputs:{x:h},backend:t,attrs:{shape:i}});return t.disposeData(h.dataId),g}var hU={kernelName:Bu,backendName:"webgpu",kernelFunc:nle};function ole(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=b.parseAxisParam(a,o.shape)[0],u=I.prepareSplitSize(o,s,i),l=o.shape.length,p=new Array(l).fill(0),c=o.shape.slice();return u.map(m=>{let f=[...c];f[i]=m;let d=bu({inputs:{x:o},backend:t,attrs:{begin:p,size:f}});return p[i]+=m,d})}var gU={kernelName:ys,backendName:"webgpu",kernelFunc:ole};var sle=dt({opType:we.SQRT}),bU={kernelName:Oo,backendName:"webgpu",kernelFunc:sle};var yU={kernelName:ja,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e,o=new gu(t.shape,we.SQUARE);return n.runWebGPUProgram(o,[t],t.dtype)}};var ale=_t({opSnippet:Le.SQUARED_DIFFERENCE}),xU={kernelName:Wo,backendName:"webgpu",kernelFunc:ale};var nN=class{constructor(e){this.variableNames=["x"];this.workPerThread=1;this.workGroupSize=[64,1,1];this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let t=Mt(this.outputShape.length);this.uniforms=`begin : ${t};  strides : ${t}; `,this.shaderKey="stridedSlice",this.size=b.sizeFromShape(this.outputShape)}getUserCode(){let e=this.outputShape.length,t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let o=0;t=this.outputShape.map((s,a)=>(o++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${o-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${he()} {
         ${ke()}
         if (index < uniforms.size) {
           let coords = getOutputCoords(globalId, index);
           setOutputFlat(index, getX(${t}));
         }
       }
     `}};function ile(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n,{nonStrided:f,$begin:d,$strides:h,size:g,newShape:y,outShape:x}=Xt.sliceInfo(o.shape,s,a,i,u,l,p,c,m),T=Ue({inputs:{x:o},backend:t,attrs:{shape:y}}),k;if(f){let P=bu({inputs:{x:T},backend:t,attrs:{begin:d,size:g}});k=Ue({inputs:{x:P},backend:t,attrs:{shape:x}}),t.disposeData(P.dataId)}else if(x.some(P=>P===0))k=t.makeTensorInfo(x,o.dtype,[]);else if(t.shouldExecuteOnCPU([T])){let F=t.tensorMap.get(T.dataId).values,E=Ce(T.shape,T.dtype,F),$=FG(x,E,h,d);k=t.makeTensorInfo(x,T.dtype,$.values)}else{let A=new nN(x),F=[{type:"int32",data:d},{type:"int32",data:h}];k=t.runWebGPUProgram(A,[T],T.dtype,F)}let w=Ue({inputs:{x:k},backend:t,attrs:{shape:x}});return t.disposeData(T.dataId),t.disposeData(k.dataId),w}var TU={kernelName:ga,backendName:"webgpu",kernelFunc:ile};function ule(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:c}=e,m=t.readSync(p.dataId),f=t.readSync(c.dataId),[d,h]=MG(m,f,o,s,a,i,u,l);return[t.makeTensorInfo([d.length],"string",d),t.makeTensorInfo(c.shape,"int32",h)]}var kU={kernelName:Ou,backendName:"webgpu",kernelFunc:ule};var lle=dt({opType:we.TANH}),IU={kernelName:Ko,backendName:"webgpu",kernelFunc:lle};var oN=class{constructor(e,t){this.variableNames=["A"];this.workGroupSize=[64,1,1];let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.size=b.sizeFromShape(this.outputShape),this.shaderKey="tile"}getUserCode(){let e=ple(this.rank,"uniforms.");return`
      ${he()} {
        ${ke()}
        if (index < uniforms.size) {
          let resRC = getOutputCoords(globalId, index);
          setOutputFlat(index, getA(${e}));
        }
      }
    `}};function ple(r,e=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${e}aShape)`;let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r;o++)n.push(`(${t[o]} % ${e}aShape[${o}])`);return n.join()}function cle(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(t.shouldExecuteOnCPU([o])||o.dtype==="string"||o.shape.length>=5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>b.decodeString(m)):u,p=Ce(o.shape,o.dtype,l),c=RG(p,s);return t.makeTensorInfo(c.shape,c.dtype,c.values)}let a=new oN(o.shape,s);return t.runWebGPUProgram(a,[o],o.dtype)}var CU={kernelName:An,backendName:"webgpu",kernelFunc:cle};var sN=class{constructor(e){this.variableNames=["Image","Transforms"];this.uniforms="interpolationModeId : i32; fillModeId : i32; fillValue : f32;";this.workGroupSize=[64,1,1];this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${he()} {
            ${ke()}
            let coords = getOutputCoords(globalId, index);
            if (coordsInBounds4D(coords, uniforms.outShape)) {
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(coords[0], coords[1], coords[2], coords[3], outputValue);
            }
          }
        `}};function mle(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,c,m,f]=o.shape,[d,h]=l??[c,m],g=[p,d,h,f],y=new sN(g),x=a==="nearest"?1:2,T;switch(i){case"constant":T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4;break;default:T=1;break}let k=[{type:"int32",data:[x]},{type:"int32",data:[T]},{type:"float32",data:[u]}];return t.runWebGPUProgram(y,[o,s],"float32",k)}var vU={kernelName:ya,backendName:"webgpu",kernelFunc:mle};function fle(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],l=new Array(i-1),p=0;for(let h=0;h<i;h++)h!==s&&(l[p++]=a.shape[h]);let c=[],m=new Array(i).fill(0),f=a.shape.slice();f[s]=1;let d=new Array(u);for(let h=0;h<d.length;h++){m[s]=h;let g=bu({inputs:{x:a},backend:t,attrs:{begin:m,size:f}}),y=Ue({inputs:{x:g},backend:t,attrs:{shape:l}});d[h]=y,c.push(g)}return c.forEach(h=>t.disposeData(h.dataId)),d}var wU={kernelName:xs,backendName:"webgpu",kernelFunc:fle};var dle=[oG,$G,BG,OG,GG,WG,UG,KG,jG,YG,QG,ZG,aG,eW,rW,nW,oW,sW,aW,iW,uW,cW,mW,fW,hW,dW,gW,bW,yW,IW,xW,TW,CW,vW,wW,SW,_W,AW,NW,sG,JG,DW,PW,FW,MW,EW,RW,LW,$W,BW,OW,zW,GW,lW,WW,UW,KW,HG,HW,qW,XW,QW,ZW,YW,JW,qG,eU,tU,rU,nG,nU,oU,sU,aU,iU,uU,lU,pU,cU,VG,TU,kU,fU,dU,gU,hU,bU,yU,xU,mU,pW,IU,CU,vU,zG,wU,VW];for(let r of dle)Oi(r);var aN=class{constructor(e){this.device=e;this.numUsedBuffers=0;this.numFreeBuffers=0;this.freeBuffers=new Map;this.usedBuffers=new Map;this.numBytesUsed=0;this.numBytesAllocated=0}acquireBuffer(e,t){let n=SU(e,t);if(this.freeBuffers.has(n)||this.freeBuffers.set(n,[]),this.usedBuffers.has(n)||this.usedBuffers.set(n,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(n).length>0){this.numFreeBuffers--;let s=this.freeBuffers.get(n).shift();return this.usedBuffers.get(n).push(s),s}this.numBytesAllocated+=e;let o=this.device.createBuffer({size:e,usage:t});return this.usedBuffers.get(n).push(o),o}releaseBuffer(e,t,n){if(this.freeBuffers==null)return;let o=SU(t,n);this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).push(e),this.numFreeBuffers++,this.numUsedBuffers--;let s=this.usedBuffers.get(o),a=s.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(a,1),this.numBytesUsed-=t}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}reset(){this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}dispose(){this.freeBuffers==null&&this.usedBuffers==null||(this.freeBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeBuffers=null,this.usedBuffers=null,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0)}};function SU(r,e){return`${r}_${e}`}var gg=class{constructor(){this.outputShape=[0];this.variableNames=[];this.workGroupSize=[256,1,1];this.lastUniformData=[];this.inputTexture=null;this.layout=null;this.lastPixelSize={width:0,height:0};this.disposed=!1;this.shaderKey="fromPixels",this.useImport=!1}updateOutputShape(e){b.arraysEqual(this.outputShape,e)||(this.outputShape=e,this.workPerThread=e[2],this.dispatchLayout=ve(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]))}makeFromPixelsSource(){let e=this.useImport?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      [[binding(1), group(0)]] var src: ${this.useImport?"texture_external":"texture_2d<f32>"};

      ${he()} {
        ${ke()}
        let flatIndexBase = index * uniforms.numChannels;
        let coords = getCoordsFromFlatIndex(flatIndexBase);
        let values = ${e};
        for (var i = 0; i < uniforms.numChannels; i = i + 1) {
          let flatIndex = flatIndexBase + i;
          if (flatIndex < uniforms.size) {
            result.numbers[flatIndex] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}getUserCode(){return this.makeFromPixelsSource()}setPipeline(e){this.pipeline=e}setUniform(e,t){if(!this.uniform){let n=e.createBuffer({size:t.length*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.uniform=n}!t||t.length===this.lastUniformData.length&&t.every((n,o)=>n===this.lastUniformData[o])||(e.queue.writeBuffer(this.uniform,0,new Uint32Array(t)),this.lastUniformData=t)}makeInputTexture(e,t,n){return(!this.inputTexture||this.lastPixelSize.width!==t||this.lastPixelSize.height!==n)&&(this.inputTexture&&this.inputTexture.destroy(),this.inputTexture=e.createTexture({size:[t,n],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),this.lastPixelSize.width=t,this.lastPixelSize.height=n),this.inputTexture}dispose(){this.disposed||(this.uniform&&this.uniform.destroy(),this.inputTexture&&this.inputTexture.destroy(),this.disposed=!0)}getLayout(e){return this.layout===null&&(this.layout=this.createTextureLayout(e)),this.layout}createTextureLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});let n=e.createBindGroupLayout({entries:t}),o=e.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:o}}};var iN=class extends gg{constructor(){super(...arguments);this.layout=null;this.useImport=!0}getUserCode(){return this.makeFromPixelsSource()}getLayout(e){return this.layout===null&&(this.layout=this.createTextureImportLayout(e)),this.layout}createTextureImportLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,externalTexture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});let n=e.createBindGroupLayout({entries:t}),o=e.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:o}}};var hle=U().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),uN=class extends os{constructor(e,t=!1){super();this.commandQueueOwnedIds=new WeakSet;this.tensorDisposalQueue=[];this.uniformDisposalQueue=[];this.disposed=!1;this.uploadWaitMs=0;this.downloadWaitMs=0;this.dispatchNumberInEncoder=0;if(!rg())throw new Error("WebGPU is not supported on this device");this.layoutCache={},this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=t,this.bufferManager=new aN(this.device),this.tensorMap=new Oa(this,jo()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),U().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return uN.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}flushDisposalQueue(){this.tensorDisposalQueue.forEach(e=>{this.maybeReleaseBuffer(e),this.tensorMap.delete(e)}),this.uniformDisposalQueue.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.byteSize,e.usage)),this.tensorDisposalQueue=[],this.uniformDisposalQueue=[]}disposeData(e,t=!1){if(this.tensorMap.has(e)){let n=this.tensorMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDisposalQueue.push(e),!1;this.maybeReleaseBuffer(e);let{complexTensorInfos:o}=this.tensorMap.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.tensorMap.delete(e)}return!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}getBufferManager(){return this.bufferManager}acquireBuffer(e,t=this.defaultGpuBufferUsage()){return this.bufferManager.acquireBuffer(e,t)}maybeReleaseBuffer(e){let t=this.tensorMap.get(e);t!=null&&t.bufferInfo.buffer!=null&&(this.bufferManager.releaseBuffer(t.bufferInfo.buffer,t.bufferInfo.byteSize,t.bufferInfo.usage),t.bufferInfo.buffer=null)}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);t.refCount--}}write(e,t,n){if(n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()},s=b.sizeFromShape(t)*Mx(n);return n==="bool"&&e instanceof Uint8Array&&(e=Int32Array.from(e)),this.tensorMap.set(o,{dtype:n,values:e,bufferInfo:{byteSize:s,usage:this.defaultGpuBufferUsage()},refCount:1}),o}move(e,t,n,o,s){if(o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let a=b.sizeFromShape(n)*Mx(o);this.tensorMap.set(e,{dtype:o,values:t,bufferInfo:{byteSize:a,usage:this.defaultGpuBufferUsage()},refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.flushDisposalQueue()}getBuffer(e){return this.uploadToGPU(e),this.tensorMap.get(e).bufferInfo.buffer}getFromPixelsProgram(e){switch(e){case"copyExternal":return this.fromPixelProgram||(this.fromPixelProgram=new gg),this.fromPixelProgram;case"import":return this.fromPixelImportProgram||(this.fromPixelImportProgram=new iN),this.fromPixelImportProgram;default:b.assert(!1,()=>"Unsupported fromPixels shape");return}}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.endPass(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e){if(e.values!=null)return e.values;let t=this.acquireBuffer(e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e.bufferInfo.buffer,0,t,0,e.bufferInfo.byteSize),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);let n=t.getMappedRange().slice(0);return t.unmap(),t!=null&&this.bufferManager.releaseBuffer(t,e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),U().getBool("WEBGPU_USE_PROFILE_TOOL")&&(b.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),n}convertAndCacheOnCPU(e,t){let n=this.tensorMap.get(e);return this.maybeReleaseBuffer(e),n.values=t,n.values}readSync(e){let t=this.tensorMap.get(e),{values:n}=t;if(n==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let t=this.tensorMap.get(e),{values:n}=t;if(n!=null)return this.convertAndCacheOnCPU(e,n);let o;if(t.dtype==="complex64"){let s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),a=s[0],i=s[1];o=I.mergeRealAndImagArrays(a,i)}else{let s=await this.getBufferData(t);o=mA(s,t.dtype)}return this.convertAndCacheOnCPU(e,o),o}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>b.decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}async time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=b.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=b.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(s);return i.kernelMs=b.sum(u),i.getExtraProfileInfo=()=>u.map((l,p)=>({name:a[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,i}getAndSavePipeline(e,t){return e in this.pipelineCache||(this.pipelineCache[e]=t()),this.pipelineCache[e]}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&b.isString(n[0])){let s=n.map(a=>b.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;let t=this.tensorMap.get(e.dataId);return{offset:0,size:t.bufferInfo.byteSize,buffer:t.bufferInfo.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){let t=this.tensorMap.get(e);t.bufferInfo.buffer==null&&(t.bufferInfo.buffer=this.acquireBuffer(t.bufferInfo.byteSize),t.values&&this.queue.writeBuffer(t.bufferInfo.buffer,0,t.values))}makeUniformsDataView(e){let t=this.acquireBuffer(e.byteLength,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(t,0,e),{offset:0,size:e.byteLength,buffer:t}}arrayToDataView(e,t){let n=4,o=new DataView(new ArrayBuffer(t*n)),s=0;return e.forEach(a=>{let i=a.data;if(a.type!=="int32"&&a.type!=="float32"&&a.type!=="uint32")throw new Error(`${a.type} not supported!`);a.type==="int32"?i.forEach(u=>{o.setInt32(s*n,u,!0),s++}):a.type==="uint32"?i.forEach(u=>{o.setUint32(s*n,u,!0),s++}):i.forEach(u=>{o.setFloat32(s*n,u,!0),s++})}),o}computePadding(e){let t=0,n=0,o=0,s=[];return e.forEach((a,i)=>{a.data.length===0&&(a.data=[1]);let u;switch(a.data.length){case 0:u=1;break;case 1:u=1;break;case 2:u=2;break;case 3:u=4;break;case 4:u=4;break;default:b.assert(!1,()=>`Unsupported ${a.data.length}D shape`)}n=Math.ceil(t/u)*u-t;for(let l=0;l<n;++l)s.push({type:a.type,data:[0]}),o++;s.push({type:a.type,data:a.data}),o=o+a.data.length,t+=a.data.length+n}),this.arrayToDataView(s,o)}createLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}});for(let s=0;s<e;s++)t.push({binding:s+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}});t.push({binding:e+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}});let n=this.device.createBindGroupLayout({entries:t}),o=this.device.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:o}}getCachedOrCreateLayout(e){return e in this.layoutCache||(this.layoutCache[e]=this.createLayout(e)),this.layoutCache[e]}runWebGPUProgram(e,t,n,o,s){if(!s){if(s=this.makeTensorInfo(e.outputShape,n),b.sizeFromShape(s.shape)===0){let E=this.tensorMap.get(s.dataId);return E.values=b.getTypedArrayFromDType(s.dtype,0),s}this.uploadToGPU(s.dataId)}let a=[{type:"float32",data:[NaN]}],i=t.concat(s).map(E=>E.shape),u="int32";i.map(E=>{a.push({type:u,data:E})});let l=b.computeStrides(s.shape);a.push({type:u,data:l}),e.size!=null&&a.push({type:u,data:[e.size]}),a.push({type:"uint32",data:e.dispatch}),o&&(a=[...a,...o]);let p=null,c=this.computePadding(a),m=c.byteLength;p=this.makeUniformsDataView(c);let f=t.map((E,$)=>{if(E.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(E.dataId),{dtype:this.tensorMap.get(E.dataId).dtype,shape:E.shape,name:e.variableNames[$]}}),d=f.map(E=>E.dtype).concat(s.dtype),h=f.map(E=>I.getBroadcastDims(E.shape,s.shape)),g=f.map(E=>b.arraysEqual(E.shape,s.shape)).join("_"),y=h.map(E=>E.join("_")).join(";"),x=Ox(e,i,d,y,g),{bindGroupLayout:T,pipelineLayout:k}=this.getCachedOrCreateLayout(e.variableNames.length),w=this.getAndSavePipeline(x,()=>Bx(this.device,e,k,f,s)),P=this.activeTimers!=null,A=kW(this.device,T,t.map(E=>this.tensorToBinding(E)),this.tensorToBinding(s),p);this.ensureCommandEncoderReady();let F=this.getComputePass();if(P&&this.supportTimeQuery&&F.writeTimestamp(this.querySet,0),F.setPipeline(w),F.setBindGroup(0,A),F.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),P&&this.supportTimeQuery&&F.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(E=>{this.commandQueueOwnedIds.add(E.dataId)}),this.commandQueueOwnedIds.add(s.dataId),p){let E={byteSize:m,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:p.buffer};this.uniformDisposalQueue.push(E)}return U().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),P&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}runFromPixelsProgram(e,t,n,o,s){let a=this.device.createBindGroup({layout:n.bindGroupLayout,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:o},{binding:2,resource:{buffer:e.uniform}}]});this.ensureCommandEncoderReady();let i=this.getComputePass(),u=this.activeTimers!=null;u&&this.supportTimeQuery&&i.writeTimestamp(this.querySet,0),i.setPipeline(e.pipeline),i.setBindGroup(0,a),i.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),u&&this.supportTimeQuery&&i.writeTimestamp(this.querySet,1),this.commandQueueOwnedIds.add(s),this.submitQueue(),u&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)})}async getTimeFromQuerySet(e){let t=this.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);let o=new BigUint64Array(n.getMappedRange()),s=Number(o[1]-o[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,t=hle){return U().getBool("WEBGPU_CPU_FORWARD")&&e.every(n=>this.tensorMap.get(n.dataId).bufferInfo.buffer==null&&b.sizeFromShape(n.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDisposalQueue.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.fromPixelProgram&&this.fromPixelProgram.dispose(),this.fromPixelImportProgram&&this.fromPixelImportProgram.dispose(),this.disposed=!0)}},Om=uN;Om.nextDataId=0;var _U={};Qe(_U,{WebGPUBackend:()=>Om,webgpu_util:()=>fA});Gi.isBrowser()&&rg()&&Vu("webgpu",async()=>{U().set("CHECK_COMPUTATION_FOR_ERRORS",!1);let r={powerPreference:U().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(r),t={},n=e.features.has("timestamp-query");n?t={requiredFeatures:["timestamp-query"]}:console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU.");let o=await e.requestDevice(t);return new Om(o,n)},3);var at;(function(s){s[s.float32=0]="float32",s[s.int32=1]="int32",s[s.bool=2]="bool",s[s.string=3]="string",s[s.complex64=4]="complex64"})(at||(at={}));var ml;(function(i){i[i.linear=0]="linear",i[i.relu=1]="relu",i[i.relu6=2]="relu6",i[i.prelu=3]="prelu",i[i.leakyrelu=4]="leakyrelu",i[i.sigmoid=5]="sigmoid",i[i.elu=6]="elu"})(ml||(ml={}));var AU;function gle(r){AU=r.wasm.cwrap(Is,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function ble(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n,m=t.dataIdMap.get(o.dataId).id,f=t.dataIdMap.get(s.dataId).id,d=0;if(a!=null){let F=t.dataIdMap.get(a.dataId);if(F.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${F.shape.length}.`);d=F.id}let h=i==null?0:t.dataIdMap.get(i.dataId).id,g=ml[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let y=u?o.shape[2]:o.shape[1],x=l?s.shape[1]:s.shape[2],T=o.shape[0],k=t.makeOutput([T,y,x],o.dtype),w=t.dataIdMap.get(k.dataId).id,P=new Uint8Array(new Int32Array(o.shape).buffer),A=new Uint8Array(new Int32Array(s.shape).buffer);return AU(m,P,o.shape.length,f,A,s.shape.length,u,l,g,d,h,c||0,w),k}var NU={kernelName:Is,backendName:"wasm",setupFunc:gle,kernelFunc:ble};function ht(r,e){let t;function n(s){t=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:a,inputs:{x:i}}=s,u=a.dataIdMap.get(i.dataId).id,l=a.makeOutput(i.shape,e||i.dtype),p=a.dataIdMap.get(l.dataId).id;return b.sizeFromShape(l.shape)===0||t(u,at[i.dtype],p),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var DU=ht(as);function At(r,e,t){let n;function o(a){n=a.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(a){let{backend:i,inputs:u}=a,{a:l,b:p}=u,c=i.dataIdMap.get(l.dataId).id,m=i.dataIdMap.get(p.dataId).id,f=t??l.dtype,d=I.assertAndGetBroadcastShape(l.shape,p.shape),h=i.makeOutput(d,f);if(b.sizeFromShape(d)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),y=new Uint8Array(new Int32Array(p.shape).buffer),x=i.dataIdMap.get(h.dataId).id,T=()=>n(c,g,l.shape.length,m,y,p.shape.length,at[l.dtype],x);if(e&&l.dtype==="float32")return T(),h;let k=I.getBroadcastDims(l.shape,d),w=I.getBroadcastDims(p.shape,d),P=k.every((F,E)=>F===E),A=w.every((F,E)=>F===E);if(P&&A)return T(),h;throw new Error(`Broadcasting along outer dims is not yet supported for ${l.dtype} ${r}.`)}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var yle=!0,PU=At(_n,yle);var FU;function xle(r){FU=r.wasm.cwrap(no,null,["array","number","number","number"])}function Tle(r){let{inputs:e,backend:t}=r,n=t.makeOutput(e[0].shape,e[0].dtype);if(b.sizeFromShape(n.shape)===0)return n;let o=e.map(i=>t.dataIdMap.get(i.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),a=t.dataIdMap.get(n.dataId).id;return FU(s,o.length,at[n.dtype],a),n}var MU={kernelName:no,backendName:"wasm",setupFunc:xle,kernelFunc:Tle};function Ep(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype),o=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(n).set(o),n}var EU={kernelName:Kn,backendName:"wasm",kernelFunc:Ep};var RU;function kle(r){RU=r.wasm.cwrap(Vo,null,["number","array","number","number","number","array","number"])}function mi(r){let{inputs:e,backend:t,attrs:n}=r,[o,s]=Cle(e.x.shape,n.perm),a=!0;for(let d=0;d<s.length;d++)s[d]!==d&&(a=!1);let i=Ile(e.x.shape,n.perm),u={dataId:e.x.dataId,shape:o,dtype:e.x.dtype};if(a){let d=Ep({inputs:e,backend:t});return d.shape=i,d}let l=t.makeOutput(i,u.dtype),p=t.dataIdMap.get(u.dataId).id,c=t.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),f=new Uint8Array(new Int32Array(u.shape).buffer);return RU(p,f,u.shape.length,at[u.dtype],c,m,s.length),l}function Ile(r,e){let t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=r[e[n]];return t}function Cle(r,e){let t=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&t.push(r[o]),r[e[o]]!==1&&n.push(e[o]);for(let o=0;o<n.length;++o){let s=-1;for(let a=0;a<n.length;++a)n[a]>=o&&(s===-1||n[s]>n[a])&&(s=a);n[s]=o}return[t,n]}var LU={kernelName:Vo,backendName:"wasm",kernelFunc:mi,setupFunc:kle};function kn(r,e,t){let n=r.shape,o=r.shape.length,s=b.parseAxisParam(e,n),a=s,i=I.getAxesPermutation(a,o),u=null,l=!1;if(i!=null){let p=new Array(o);for(let f=0;f<p.length;f++)p[f]=n[i[f]];a=I.getInnerMostAxes(a.length,o),u=mi({inputs:{x:r},attrs:{perm:i},backend:t});let c=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(u.dataId).id!==c&&(l=!0)}return{transposed:u,originalAxes:s,axes:a,inputWasTransposed:l}}var $U;function vle(r){$U=r.wasm.cwrap(xi,null,["number, number, number"])}function wle(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=kn(a,o,e);if(f){let T=e.dataIdMap.get(p.dataId).id;l=p,u=T}let d=l.shape.length;I.assertAxesAreInnerMostDims("all",c,d);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),y=b.sizeFromShape(g),x=e.makeOutput(h,a.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(x.dataId).id;$U(u,y,T)}if(f&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(x.shape,m);x.shape=T}return x}var BU={kernelName:xi,backendName:"wasm",setupFunc:vle,kernelFunc:wle};var OU;function Sle(r){OU=r.wasm.cwrap(Ti,null,["number, number, number"])}function _le(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=kn(a,o,e);if(f){let T=e.dataIdMap.get(p.dataId).id;l=p,u=T}let d=l.shape.length;I.assertAxesAreInnerMostDims("any",c,d);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),y=b.sizeFromShape(g),x=e.makeOutput(h,a.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(x.dataId).id;OU(u,y,T)}if(f&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(x.shape,m);x.shape=T}return x}var zU={kernelName:Ti,backendName:"wasm",setupFunc:Sle,kernelFunc:_le};var GU;function Ale(r){GU=r.wasm.cwrap(oo,null,["number","number","number","number","number"])}function Nle(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=a,u=s,{transposed:l,axes:p,inputWasTransposed:c}=kn(s,o,e);if(c){let y=e.dataIdMap.get(l.dataId).id;y!==a&&(u=l,i=y)}let m=u.shape.slice(0,-1),f=e.makeOutput(m,"int32"),d=e.dataIdMap.get(f.dataId).id,h=b.sizeFromShape(f.shape),g=u.shape[p[0]];return GU(i,at[u.dtype],h,g,d),c&&e.disposeData(l.dataId),f}var WU={kernelName:oo,backendName:"wasm",kernelFunc:Nle,setupFunc:Ale};var UU;function Dle(r){UU=r.wasm.cwrap(so,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ple(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=t,p=I.computePool2DInfo(o.shape,a,i,1,u,l),c=p.filterHeight,m=p.filterWidth,f=p.padInfo.top,d=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,y=p.strideHeight,x=p.strideWidth,T=p.inChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(p.dilationWidth!==1||p.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let k=n.makeOutput(p.outShape,"float32"),w=n.dataIdMap.get(k.dataId).id;return UU(s,o.shape[0],o.shape[1],o.shape[2],c,m,f,d,h,g,y,x,T,w),k}var KU={kernelName:so,backendName:"wasm",setupFunc:Dle,kernelFunc:Ple};function hr(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=b.sizeFromShape(n.shape),a=b.inferFromImplicitShape(o,s);return b.assert(s===b.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var VU={kernelName:ds,backendName:"wasm",kernelFunc:hr};var jU;function Fle(r){jU=r.wasm.cwrap(ao,null,["number","array","number","number","array","number","number","number","number"])}function Mle(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,p=a?o.shape[u-2]:o.shape[u-1],c=i?s.shape[l-1]:s.shape[l-2],m=a?o.shape[u-1]:o.shape[u-2],f=i?s.shape[l-2]:s.shape[l-1],d=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=b.sizeFromShape(d),y=b.sizeFromShape(h),x=g===y||g===1||y===1;b.assert(u>=2&&l>=2&&x,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${d}) and (${h}).`);let k=(g>y?o.shape.slice(0,-2):s.shape.slice(0,-2)).concat([m,f]);b.assert(p===c,()=>`Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let w=a?[g,p,m]:[g,m,p],P=i?[y,f,c]:[y,c,f],A=hr({inputs:{x:o},backend:t,attrs:{shape:w}}),F=hr({inputs:{x:s},backend:t,attrs:{shape:P}}),E=t.dataIdMap.get(A.dataId).id,$=t.dataIdMap.get(F.dataId).id,W=a?A.shape[2]:A.shape[1],K=i?F.shape[1]:F.shape[2],B=Math.max(g,y),V=t.makeOutput([B,W,K],A.dtype),j=t.dataIdMap.get(V.dataId).id,H=new Uint8Array(new Int32Array(A.shape).buffer),J=new Uint8Array(new Int32Array(F.shape).buffer);return jU(E,H,A.shape.length,$,J,F.shape.length,a,i,j),t.disposeData(A.dataId),t.disposeData(F.dataId),V.shape=k,V}var HU={kernelName:ao,backendName:"wasm",setupFunc:Fle,kernelFunc:Mle};function Tu(r){let{inputs:{x:e},attrs:{begin:t,size:n},backend:o}=r,[s,a]=Xt.parseSliceParams(e,t,n),i=Xt.isSliceContinous(e.shape,s,a),u=o.readSync(e.dataId),l=o.makeOutput(a,e.dtype),p=b.computeStrides(e.shape),c=o.dataIdMap.get(l.dataId);if(i){let d=Xt.computeFlatOffset(s,p);return e.dtype==="string"?c.stringBytes=u.slice(d,d+b.sizeFromShape(a)):o.typedArrayFromHeap(l).set(u.subarray(d,d+b.sizeFromShape(a))),l}if(e.dtype==="string"){let d=xp(u,s,a,e.shape,e.dtype);return c.stringBytes=d,l}let m=o.typedArrayFromHeap(l),f=e.shape.length;if(f===2)Ele(u,p[0],m,s,a);else if(f===3)Rle(u,p[0],p[1],m,s,a);else if(f===4)Lle(u,p[0],p[1],p[2],m,s,a);else{let d=xp(u,s,a,e.shape,e.dtype);m.set(d)}return l}function Ele(r,e,t,n,o){let s=0,a=n[0],i=n[1],u=a+o[0];for(let l=a;l<u;l++){let p=l*e+i;t.set(r.subarray(p,p+o[1]),s),s+=o[1]}}function Rle(r,e,t,n,o,s){let a=0,i=o[0],u=o[1],l=o[2],p=i+s[0],c=u+s[1];for(let m=i;m<p;m++)for(let f=u;f<c;f++){let d=m*e+f*t+l;n.set(r.subarray(d,d+s[2]),a),a+=s[2]}}function Lle(r,e,t,n,o,s,a){let i=0,u=s[0],l=s[1],p=s[2],c=u+a[0],m=l+a[1],f=p+a[2],d=s[3];for(let h=u;h<c;h++)for(let g=l;g<m;g++)for(let y=p;y<f;y++){let x=h*e+g*t+y*n+d;o.set(r.subarray(x,x+a[3]),i),i+=a[3]}}var qU={kernelName:gs,backendName:"wasm",kernelFunc:Tu};function $le(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n,i=s.reduce((y,x)=>y*x),u=I.getReshaped(o.shape,s,i),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,i),c=I.getSliceBeginCoords(a,s.length),m=I.getSliceSize(p,a,s.length),f=hr({inputs:{x:o},backend:t,attrs:{shape:u}}),d=mi({inputs:{x:f},backend:t,attrs:{perm:l}}),h=hr({inputs:{x:d},backend:t,attrs:{shape:p}}),g=Tu({inputs:{x:h},backend:t,attrs:{begin:c,size:m}});return t.disposeData(f.dataId),t.disposeData(d.dataId),t.disposeData(f.dataId),g}var XU={kernelName:is,backendName:"wasm",kernelFunc:$le};function ku(r){let{inputs:{x:e},attrs:{dtype:t},backend:n}=r,o=n.makeOutput(e.shape,t),s=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(o).set(s),o}var YU={kernelName:Wn,backendName:"wasm",kernelFunc:ku};var QU=ht(io);var ZU;function Ble(r){ZU=r.wasm.cwrap(Un,null,["number","number","number","number"])}function Ole(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i=t.dataIdMap.get(o.dataId).id,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(u.dataId).id;return ZU(i,s,a,l),u}var JU={kernelName:Un,backendName:"wasm",setupFunc:Ble,kernelFunc:Ole};function lN(r){let{inputs:e,backend:t}=r,n=b.parseAxisParam(r.attrs.axis,e[0].shape)[0],o=I.computeOutShape(e.map(f=>f.shape),n),s=e.filter(f=>b.sizeFromShape(f.shape)>0);if(s.length===1)return Ep({inputs:{x:s[0]},backend:t});let a=t.makeOutput(o,e[0].dtype);if(b.sizeFromShape(o)===0)return a;let i=s.map(f=>f.shape);if(I.assertParamsConsistent(i,n),s[0].dtype==="string"){let f=s.map(T=>{let k=b.sizeFromShape(T.shape.slice(n));return hr({inputs:{x:T},backend:t,attrs:{shape:[-1,k]}})}),d=f.map(T=>({vals:t.readSync(T.dataId),shape:T.shape}));o=I.computeOutShape(f.map(T=>T.shape),1);let h=f[0].shape[0]===1,g=gp(d,o,e[0].dtype,h),y=I.computeOutShape(s.map(T=>T.shape),n);a.shape=y;let x=t.dataIdMap.get(a.dataId);return x.stringBytes=I.fromStringArrayToUint8(g),f.forEach(T=>t.disposeData(T.dataId)),a}let u=b.sizeFromShape(s[0].shape.slice(0,n)),l=0,p=s.map(f=>{let d=b.sizeFromShape(f.shape.slice(n));return l+=d,d}),c=s.map(f=>t.typedArrayFromHeap(f)),m=t.typedArrayFromHeap(a);for(let f=0;f<u;f++){let d=f*l;for(let h=0;h<c.length;h++){let g=p[h],y=f*g,x=c[h].subarray(y,y+g);m.set(x,d),d+=g}}return a}var eK={kernelName:us,backendName:"wasm",kernelFunc:lN};var tK;function zle(r){tK=r.wasm.cwrap(uo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Gle(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:c,dataFormat:m}=t,f=I.convertConv2DDataFormat(m),d=I.computeConv2DInfo(o.shape,s.shape,u,l,p,c,!1,f),h=d.filterHeight,g=d.filterWidth,y=d.padInfo.top,x=d.padInfo.right,T=d.padInfo.bottom,k=d.padInfo.left,w=d.dilationHeight,P=d.dilationWidth,A=d.strideHeight,F=d.strideWidth,E=d.inChannels,$=d.outChannels,W=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let K=n.makeOutput(d.outShape,"float32"),B=n.dataIdMap.get(K.dataId).id;return tK(a,o.shape[0],o.shape[1],o.shape[2],i,h,g,y,x,T,k,W,w,P,A,F,E,$,B),K}var rK={kernelName:uo,backendName:"wasm",setupFunc:zle,kernelFunc:Gle};var nK;function Wle(r){nK=r.wasm.cwrap(lo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ule(r){let{backend:e,inputs:t,attrs:n}=r,{dy:o,filter:s}=t,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,inputShape:p}=n,c=1,m=I.convertConv2DDataFormat(u),f=I.computeConv2DInfo(p,s.shape,a,c,i,l,!1,m),{batchSize:d,filterHeight:h,filterWidth:g,inChannels:y,inHeight:x,inWidth:T,outChannels:k,outHeight:w,outWidth:P,strideHeight:A,strideWidth:F}=f,E=h-1-f.padInfo.top,$=g-1-f.padInfo.left,W=f.dataFormat==="channelsLast",K=b.computeStrides(f.inShape),B=b.computeStrides(o.shape),[V,j,H]=b.computeStrides(s.shape),J=K[0],X=W?K[1]:K[2],ne=W?K[2]:1,oe=W?1:K[1],te=B[0],le=W?B[1]:B[2],ae=W?B[2]:1,ge=W?1:B[1],fe=e.makeOutput(f.inShape,"float32"),xe=e.dataIdMap.get(fe.dataId).id,Se=e.dataIdMap.get(o.dataId).id,Be=e.dataIdMap.get(s.dataId).id;return nK(Se,Be,d,h,g,x,T,y,w,P,k,A,F,E,$,V,j,H,J,X,ne,oe,te,le,ae,ge,xe),fe}var oK={kernelName:lo,backendName:"wasm",setupFunc:Wle,kernelFunc:Ule};var sK=ht(po);var aK=ht(co);var pN;(function(t){t[t.bilinear=0]="bilinear",t[t.nearest=1]="nearest"})(pN||(pN={}));var iK;function Kle(r){iK=r.wasm.cwrap(Ys,null,["number","number","number","number","array","number","number","number","number","number"])}function Vle(r){let{backend:e,inputs:t,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:a}=n,{image:i,boxes:u,boxInd:l}=t,p=u.shape[0],[c,m]=a,f=[p,c,m,i.shape[3]],d=e.dataIdMap.get(i.dataId),h;i.dtype!=="float32"&&(h=ku({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),d=e.dataIdMap.get(h.dataId));let g=d.id,y=e.dataIdMap.get(u.dataId).id,x=e.dataIdMap.get(l.dataId).id,T=e.makeOutput(f,"float32"),k=e.dataIdMap.get(T.dataId).id,w=new Uint8Array(new Int32Array(i.shape).buffer);return iK(g,y,x,p,w,c,m,pN[o],s,k),h!=null&&e.disposeData(h.dataId),T}var uK={kernelName:Ys,backendName:"wasm",setupFunc:Kle,kernelFunc:Vle};var lK;function jle(r){lK=r.wasm.cwrap(Xs,null,["number","number","number","number","number","number"])}function Hle(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length;b.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=I.getAxesPermutation([s],u),p=o;l!==null&&(p=mi({inputs:{x:o},attrs:{perm:l},backend:t}));let c=I.getInnerMostAxes(1,u)[0];I.assertAxesAreInnerMostDims("cumsum",[c],u);let m=t.makeOutput(p.shape,p.dtype),f=p.shape[c],d=t.dataIdMap.get(p.dataId).id,h=t.dataIdMap.get(m.dataId).id;lK(d,a?1:0,i?1:0,f,h,at[o.dtype]);let g=m;if(l!==null){let y=I.getUndoAxesPermutation(l);g=mi({inputs:{x:m},attrs:{perm:y},backend:t}),t.disposeData(p.dataId),t.disposeData(m.dataId)}return g}var pK={kernelName:Xs,backendName:"wasm",setupFunc:jle,kernelFunc:Hle};var cK;function qle(r){cK=r.wasm.cwrap(Qs,null,["number","number","number","array","number","array","array","number","number"])}function Xle(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],c=u*s,m=l*s,f=p/(s*s),d=a==="NHWC"?[i,c,m,f]:[i,f,c,m],h=e.makeOutput(d,"float32"),y=e.dataIdMap.get(o.dataId).id,x=new Uint8Array(new Int32Array(b.computeStrides(o.shape)).buffer),T=new Uint8Array(new Int32Array(d).buffer),k=new Uint8Array(new Int32Array(b.computeStrides(d)).buffer),w=e.dataIdMap.get(h.dataId).id;return cK(y,s,a==="NHWC"?1:0,x,o.shape.length-1,T,k,d.length,w),h}var mK={kernelName:Qs,backendName:"wasm",setupFunc:qle,kernelFunc:Xle};var fK;function Yle(r){fK=r.wasm.cwrap(mo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Qle(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:c}=t,m=l??[1,1],f=I.computeConv2DInfo(o.shape,s.shape,u,m,p,c,!0),d=f.filterHeight,h=f.filterWidth,g=f.padInfo.top,y=f.padInfo.right,x=f.padInfo.bottom,T=f.padInfo.left,k=f.dilationHeight,w=f.dilationWidth,P=f.strideHeight,A=f.strideWidth,F=f.inChannels,E=f.outChannels,$=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let W=n.makeOutput(f.outShape,"float32"),K=n.dataIdMap.get(W.dataId).id;return fK(a,o.shape[0],o.shape[1],o.shape[2],i,d,h,g,y,x,T,$,k,w,P,A,F,E,K),W}var dK={kernelName:mo,backendName:"wasm",setupFunc:Yle,kernelFunc:Qle};var hK=ht(ho);var Zle=!1,gK=At(Zs,Zle,"bool");var bK=ht(go,"float32");function zx(r){let{inputs:e,attrs:t,backend:n}=r,{input:o}=e,{dim:s}=t,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(b.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),hr({inputs:{x:o},backend:n,attrs:{shape:i}})}var yK={kernelName:ls,backendName:"wasm",kernelFunc:zx};function cN(r){let{attrs:{shape:e,value:t,dtype:n},backend:o}=r,s=o.makeOutput(e,n);return o.typedArrayFromHeap(s).fill(t),s}var xK={kernelName:Ua,backendName:"wasm",kernelFunc:cN};var TK;function Jle(r){TK=r.wasm.cwrap(ea,null,["number","number","number","number","number","number"])}function epe(r){let{inputs:e,backend:t}=r,{image:n}=e,o=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,[i,u,l,p]=n.shape;return TK(s,i,u,l,p,a),o}var kK={kernelName:ea,backendName:"wasm",kernelFunc:epe,setupFunc:Jle};var IK=ht(bo);var tpe=!1,CK=At(yo,tpe);var vK;function rpe(r){vK=r.wasm.cwrap(xo,null,["number","number","number","number","number","number","number"])}function npe(r){let{backend:e,inputs:t,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:a,variance:i,offset:u,scale:l}=t,p=e.dataIdMap.get(s.dataId).id,c=e.dataIdMap.get(a.dataId).id,m=e.dataIdMap.get(i.dataId).id,f=u!=null?e.dataIdMap.get(u.dataId).id:0,d=l!=null?e.dataIdMap.get(l.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(b.sizeFromShape(s.shape)===0)return h;let g=e.dataIdMap.get(h.dataId).id;return vK(p,c,m,f,d,o,g),h}var wK={kernelName:xo,backendName:"wasm",setupFunc:rpe,kernelFunc:npe};var SK;function ope(r){SK=r.wasm.cwrap(Cs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function spe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dataFormat:c,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=I.computeConv2DInfo(o.shape,s.shape,u,p,l,m),g=ml[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,x=n.dataIdMap.get(s.dataId).id,T=h.outChannels,k=0;if(a!=null){let ae=n.dataIdMap.get(a.dataId);if(ae.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==T)throw new Error(`FusedConv2D bias shape (${ae.shape}) does not match the number of output channels (${T})`);k=ae.id}let w=h.filterHeight,P=h.filterWidth,A=h.padInfo.top,F=h.padInfo.right,E=h.padInfo.bottom,$=h.padInfo.left,W=h.dilationHeight,K=h.dilationWidth,B=h.strideHeight,V=h.strideWidth,j=h.inChannels,H=h.padInfo.type==="SAME"?1:0,J=h.batchSize,X=h.inHeight,ne=h.inWidth;if(c!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let oe=n.makeOutput(h.outShape,"float32"),te=n.dataIdMap.get(oe.dataId).id,le=i==null?0:n.dataIdMap.get(i.dataId).id;return SK(y,J,X,ne,x,w,P,k,A,F,E,$,H,W,K,B,V,j,T,g,le,d||0,te),oe}var _K={kernelName:Cs,backendName:"wasm",setupFunc:ope,kernelFunc:spe};var AK;function ape(r){AK=r.wasm.cwrap(vs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ipe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dataFormat:c,dimRoundingMode:m,activation:f,leakyreluAlpha:d}=t,h=I.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!0),g=ml[f];if(g==null)throw new Error(`${f} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let y=n.dataIdMap.get(o.dataId).id,x=n.dataIdMap.get(s.dataId).id,T=h.outChannels,k=0;if(a!=null){let ae=n.dataIdMap.get(a.dataId);if(ae.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==T)throw new Error(`FusedDepthwiseConv2D bias shape (${ae.shape}) does not match the number of output channels (${T})`);k=ae.id}let w=h.filterHeight,P=h.filterWidth,A=h.padInfo.top,F=h.padInfo.right,E=h.padInfo.bottom,$=h.padInfo.left,W=h.dilationHeight,K=h.dilationWidth,B=h.strideHeight,V=h.strideWidth,j=h.inChannels,H=h.padInfo.type==="SAME"?1:0,J=h.batchSize,X=h.inHeight,ne=h.inWidth;if(c!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let oe=n.makeOutput(h.outShape,"float32"),te=n.dataIdMap.get(oe.dataId).id,le=i==null?0:n.dataIdMap.get(i.dataId).id;return AK(y,J,X,ne,x,w,P,k,A,F,E,$,H,W,K,B,V,j,T,g,le,d||0,te),oe}var NK={kernelName:vs,backendName:"wasm",setupFunc:ape,kernelFunc:ipe};var DK;function upe(r){DK=r.wasm.cwrap(ta,null,["number","number","number","number","number","number","array","number"])}function lpe(r){let{backend:e,inputs:t}=r,{params:n,indices:o}=t,[s,a,i,u]=lb.prepareAndValidate(n,o),l=e.makeOutput(s,n.dtype);if(a===0)return l;let p=o.shape,c=p[p.length-1],f=e.dataIdMap.get(n.dataId).id,h=e.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),y=e.dataIdMap.get(l.dataId).id;return DK(f,at[n.dtype],h,a,c,i,g,y),l}var PK={kernelName:ta,backendName:"wasm",setupFunc:upe,kernelFunc:lpe};var FK;function ppe(r){FK=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function cpe(r){let{backend:e,inputs:t,attrs:n}=r,{x:o,indices:s}=t,{axis:a,batchDims:i}=n,u=b.parseAxisParam(a,o.shape)[0],l=e.readSync(s.dataId),p=o.shape[u];for(let E=0;E<l.length;++E){let $=l[E];b.assert($<=p-1&&$>=0,()=>`GatherV2: the index value ${$} is not in [0, ${p-1}]`)}let c=I.segment_util.collectGatherOpShapeInfo(o,s,u,i),m=hr({inputs:{x:o},attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]},backend:e}),f=b.sizeFromShape(s.shape),d=hr({inputs:{x:s},attrs:{shape:[c.batchSize,f/c.batchSize]},backend:e}),h=[c.batchSize,c.outerSize,f/c.batchSize,c.sliceSize],g=e.makeOutput(h,o.dtype);if(b.sizeFromShape(o.shape)===0)return g;let y=m.shape.length-1,T=e.dataIdMap.get(m.dataId).id,w=e.dataIdMap.get(d.dataId).id,P=e.dataIdMap.get(g.dataId).id,A=new Uint8Array(new Int32Array(b.computeStrides(m.shape)).buffer),F=new Uint8Array(new Int32Array(b.computeStrides(h)).buffer);return FK(T,at[o.dtype],A,y,w,c.batchSize,F,P),e.disposeData(m.dataId),e.disposeData(d.dataId),g.shape=c.outputShape,g}var MK={kernelName:ps,backendName:"wasm",setupFunc:ppe,kernelFunc:cpe};var mpe=!1,EK=At(ra,mpe,"bool");var fpe=!1,RK=At(To,fpe,"bool");var LK;function dpe(r){LK=r.wasm.cwrap(na,null,["number","number","number","number"])}function hpe(r){let{inputs:{x:e},attrs:{alpha:t},backend:n}=r,o=n.dataIdMap.get(e.dataId).id,s=n.makeOutput(e.shape,"float32");if(b.sizeFromShape(e.shape)!==0){let a=n.dataIdMap.get(s.dataId).id;LK(o,at[e.dtype],t,a)}return s}var $K={kernelName:na,backendName:"wasm",setupFunc:dpe,kernelFunc:hpe};var gpe=!1,BK=At(oa,gpe,"bool");var bpe=!1,OK=At(sa,bpe,"bool");var zK=ht(ko);var ype=!1,GK=At(aa,ype,"bool");var WK;function xpe(r){WK=r.wasm.cwrap(Io,null,["number","number","number","number"])}function Tpe(r){let{backend:e,inputs:t,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=kn(a,o,e);if(f){let T=e.dataIdMap.get(p.dataId).id;l=p,u=T}let d=l.shape.length;I.assertAxesAreInnerMostDims("max",c,d);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),y=b.sizeFromShape(g),x=e.makeOutput(h,a.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(x.dataId).id;WK(u,at[a.dtype],y,T)}if(f&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(x.shape,m);x.shape=T}return x}var UK={kernelName:Io,backendName:"wasm",setupFunc:xpe,kernelFunc:Tpe};var kpe=!1,KK=At(Co,kpe);var VK;function Ipe(r){VK=r.wasm.cwrap(vo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Cpe(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id;b.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=t,p=I.computePool2DInfo(o.shape,a,i,1,u,l),c=p.filterHeight,m=p.filterWidth,f=p.padInfo.top,d=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,y=p.dilationHeight,x=p.dilationWidth,T=p.strideHeight,k=p.strideWidth,w=p.inChannels,P=p.outChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let A=n.makeOutput(p.outShape,"float32"),F=n.dataIdMap.get(A.dataId).id;return VK(s,o.shape[0],o.shape[1],o.shape[2],c,m,f,d,h,g,y,x,T,k,w,P,F),A}var jK={kernelName:vo,backendName:"wasm",setupFunc:Ipe,kernelFunc:Cpe};var HK;function vpe(r){HK=r.wasm.cwrap(wo,null,["number, number, number"])}function wpe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=kn(a,o,e),d=c;if(f){let k=e.dataIdMap.get(p.dataId).id;k!==i&&(l=p,u=k,d=I.getInnerMostAxes(d.length,l.shape.length))}I.assertAxesAreInnerMostDims("mean",d,l.shape.length);let[h,g]=I.computeOutAndReduceShapes(l.shape,d),y=b.sizeFromShape(g),x=l;l.dtype!=="float32"&&(x=ku({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),u=e.dataIdMap.get(x.dataId).id);let T=e.makeOutput(h,"float32");if(b.sizeFromShape(l.shape)!==0){let k=e.dataIdMap.get(T.dataId).id;HK(u,y,k)}if(f&&e.disposeData(p.dataId),s){let k=I.expandShapeToKeepDim(T.shape,m);T.shape=k}return l.dtype!=="float32"&&e.disposeData(x.dataId),T}var qK={kernelName:wo,backendName:"wasm",setupFunc:vpe,kernelFunc:wpe};var XK;function Spe(r){XK=r.wasm.cwrap(So,null,["number","number","number","number"])}function _pe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=kn(a,o,e);if(f){let T=e.dataIdMap.get(p.dataId).id;T!==i&&(l=p,u=T)}let d=l.shape.length;I.assertAxesAreInnerMostDims("min",c,d);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),y=b.sizeFromShape(g),x=e.makeOutput(h,l.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(x.dataId).id;XK(u,at[a.dtype],y,T)}if(f&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(x.shape,m);x.shape=T}return x}var YK={kernelName:So,backendName:"wasm",setupFunc:Spe,kernelFunc:_pe};var Ape=!1,QK=At(_o,Ape);var mN;(function(t){t[t.reflect=0]="reflect",t[t.symmetric=1]="symmetric"})(mN||(mN={}));var ZK;function Npe(r){ZK=r.wasm.cwrap(Ao,null,["number","array","number","number","array","array","number","number"])}function Dpe(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,mode:o}}=r,s=n.map((d,h)=>d[0]+e.shape[h]+d[1]),a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),u=t.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),p=n.map(d=>d[0]),c=n.map(d=>d[1]),m=new Uint8Array(new Int32Array(p).buffer),f=new Uint8Array(new Int32Array(c).buffer);return ZK(a,l,e.shape.length,at[e.dtype],m,f,mN[o],u),i}var JK={kernelName:Ao,backendName:"wasm",kernelFunc:Dpe,setupFunc:Npe};var Ppe=!0,eV=At(No,Ppe);var tV=ht(cs);function zm(r,e){let t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),n=t[0],o=t[1],s=t[2],a=t[3];return r.wasm._free(e),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:a}}var rV;function Fpe(r){rV=r.wasm.cwrap(ua,"number",["number","number","number","number","number"])}function Mpe(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a}=n,{boxes:i,scores:u}=t,l=e.dataIdMap.get(i.dataId).id,p=e.dataIdMap.get(u.dataId).id,c=rV(l,p,s,o,a),{pSelectedIndices:m,selectedSize:f,pSelectedScores:d,pValidOutputs:h}=zm(e,c);return e.wasm._free(d),e.wasm._free(h),e.makeOutput([f],"int32",m)}var nV={kernelName:ua,backendName:"wasm",setupFunc:Fpe,kernelFunc:Mpe};var oV;function Epe(r){oV=r.wasm.cwrap(Mi,"number",["number","number","number","number","number","bool"])}function Rpe(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,padToMaxOutputSize:i}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,c=e.dataIdMap.get(l.dataId).id,m=oV(p,c,s,o,a,i),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=zm(e,m);e.wasm._free(h);let y=e.makeOutput([d],"int32",f),x=e.makeOutput([],"int32",g);return[y,x]}var sV={kernelName:Mi,backendName:"wasm",setupFunc:Epe,kernelFunc:Rpe};var aV;function Lpe(r){aV=r.wasm.cwrap(la,"number",["number","number","number","number","number","number"])}function $pe(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,softNmsSigma:i}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,c=e.dataIdMap.get(l.dataId).id,m=aV(p,c,s,o,a,i),{pSelectedIndices:f,selectedSize:d,pSelectedScores:h,pValidOutputs:g}=zm(e,m);e.wasm._free(g);let y=e.makeOutput([d],"int32",f),x=e.makeOutput([d],"float32",h);return[y,x]}var iV={kernelName:la,backendName:"wasm",setupFunc:Lpe,kernelFunc:$pe};var Bpe=!1,uV=At(ia,Bpe,"bool");var lV;function Ope(r){lV=r.wasm.cwrap(pa,null,["number","number","number","number","number"])}function zpe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:a,offValue:i}=n,u=t.makeOutput([...o.shape,s],"int32"),l=t.dataIdMap.get(u.dataId).id,c=t.dataIdMap.get(o.dataId).id;return lV(c,s,a,i,l),u}var pV={kernelName:pa,backendName:"wasm",setupFunc:Ope,kernelFunc:zpe};function Gpe(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(1),n}var cV={kernelName:ms,backendName:"wasm",kernelFunc:Gpe};function Wpe(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return zx({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let c=zx({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(c),c}),l=lN({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeData(p.dataId)),l}var mV={kernelName:fs,backendName:"wasm",kernelFunc:Wpe};var fV;function Upe(r){fV=r.wasm.cwrap(Do,null,["number","array","number","number","array","array","number","number"])}function Kpe(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+e.shape[g]+h[1]);if(b.sizeFromShape(e.shape)===0)return cN({backend:t,attrs:{shape:s,value:o,dtype:e.dtype}});let a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),l=t.dataIdMap.get(i.dataId).id,p=new Uint8Array(new Int32Array(e.shape).buffer),c=n.map(h=>h[0]),m=n.map(h=>h[1]),f=new Uint8Array(new Int32Array(c).buffer),d=new Uint8Array(new Int32Array(m).buffer);return fV(a,p,e.shape.length,at[e.dtype],f,d,o,l),i}var Gx={kernelName:Do,backendName:"wasm",kernelFunc:Kpe,setupFunc:Upe};var Vpe=!1,dV=At(Po,Vpe);var hV;function jpe(r){hV=r.wasm.cwrap(Fo,null,["number","number","number"])}function Hpe(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,i=s,u=n,l=u;u.dtype!=="float32"&&(l=ku({backend:t,inputs:{x:n},attrs:{dtype:"float32"}}),i=t.dataIdMap.get(l.dataId).id);let p=t.makeOutput(n.shape,"float32"),c=t.dataIdMap.get(p.dataId).id;return hV(i,a,c),u.dtype!=="float32"&&t.disposeData(l.dataId),p}var gV={kernelName:Fo,backendName:"wasm",setupFunc:jpe,kernelFunc:Hpe};var bV;function qpe(r){bV=r.wasm.cwrap(ca,null,["number","number","number","number"])}function Xpe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=kn(a,o,e),d=c;if(f){let T=e.dataIdMap.get(p.dataId).id;T!==i&&(l=p,u=T,d=I.getInnerMostAxes(d.length,l.shape.length))}I.assertAxesAreInnerMostDims("prod",d,l.shape.length);let[h,g]=I.computeOutAndReduceShapes(l.shape,d),y=b.sizeFromShape(g),x=e.makeOutput(h,l.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(x.dataId).id;bV(u,y,at[x.dtype],T)}if(f&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(x.shape,m);x.shape=T}return x}var yV={kernelName:ca,backendName:"wasm",setupFunc:qpe,kernelFunc:Xpe};var Ype=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=yp(n,o,s,a),u=e.makeOutput([i.length],a);return e.typedArrayFromHeap(u).set(i),u},xV={kernelName:Ka,backendName:"wasm",kernelFunc:Ype};var Qpe=!0,TV=At(fo,Qpe);var kV=ht(Mo);var IV=ht(Ro);var CV;function Zpe(r){CV=r.wasm.cwrap(Eo,null,["number","number","number","number","number","number","number","number","number","number"])}function Jpe(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,[p,c,m,f]=o.shape,d=[p,u,l,f],h=e.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=ku({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(g.dataId));let y=h.id,x=e.makeOutput(d,"float32");if(b.sizeFromShape(o.shape)===0)return x;let T=e.dataIdMap.get(x.dataId).id;return CV(y,p,c,m,f,u,l,s?1:0,a?1:0,T),g!=null&&e.disposeData(g.dataId),x}var vV={kernelName:Eo,backendName:"wasm",setupFunc:Zpe,kernelFunc:Jpe};var wV;function ece(r){wV=r.wasm.cwrap(ma,null,["number","array","number","array","number","number"])}function tce(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=b.parseAxisParam(s,o.shape);if(o.shape.length===0)return Ep({inputs:{x:o},backend:t});let i=t.makeOutput(o.shape,o.dtype),u=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(i.dataId).id,p=new Uint8Array(new Int32Array(a).buffer),c=new Uint8Array(new Int32Array(o.shape).buffer);wV(u,p,a.length,c,o.shape.length,l);let m=hr({inputs:{x:i},attrs:{shape:o.shape},backend:t});return t.disposeData(i.dataId),m}var SV={kernelName:ma,backendName:"wasm",kernelFunc:tce,setupFunc:ece};var _V;function rce(r){_V=r.wasm.cwrap(xa,null,["number","number","number","number","number","number","number","number","array","number","number"])}function nce(r){let{inputs:e,backend:t,attrs:n}=r,{image:o}=e,{radians:s,fillValue:a,center:i}=n,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(u.dataId).id,[c,m,f,d]=o.shape,[h,g]=I.getImageCenter(i,m,f),y=a===0,x=255,T=typeof a=="number"?[a,a,a,y?0:x]:[...a,x],k=new Uint8Array(new Int32Array(T).buffer);return _V(l,c,m,f,d,s,h,g,k,T.length,p),u}var AV={kernelName:xa,backendName:"wasm",kernelFunc:nce,setupFunc:rce};var NV=ht(fa);var DV=ht(Lo);var PV;function oce(r){PV=r.wasm.cwrap(da,null,["number","number","number","number","number","number","array","number","number"])}function sce(r){let{backend:e,inputs:t,attrs:n}=r,{indices:o,updates:s}=t,{shape:a}=n,i=e.makeOutput(a,s.dtype);if(b.sizeFromShape(a)===0)return i;let{sliceRank:u,numUpdates:l,sliceSize:p,strides:c,outputSize:m}=cb.calculateShapes(s,o,a),d=e.dataIdMap.get(o.dataId).id,g=e.dataIdMap.get(s.dataId).id,y=new Uint8Array(new Int32Array(c).buffer),x=e.dataIdMap.get(i.dataId).id;return PV(d,g,at[s.dtype],u,l,p,y,m,x),i}var FV={kernelName:da,backendName:"wasm",setupFunc:oce,kernelFunc:sce};var MV;function ace(r){MV=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function ice(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=t.makeOutput(o.shape,o.dtype),p=t.dataIdMap.get(l.dataId).id,c=n.shape.length,m=o.shape.length,f=c===0||c>1||m===1?1:b.sizeFromShape(o.shape.slice(1));return MV(a,i,u,f,p),l}var EV={kernelName:hs,backendName:"wasm",kernelFunc:ice,setupFunc:ace};var RV;function uce(r){RV=r.wasm.cwrap(Bo,null,["number","number"])}function lce(r){let{backend:e,inputs:{x:t}}=r,n=e.dataIdMap.get(t.dataId).id,o=e.makeOutput(t.shape,t.dtype),s=e.dataIdMap.get(o.dataId).id;return b.sizeFromShape(o.shape)===0||RV(n,s),o}var LV={kernelName:"Sigmoid",backendName:"wasm",setupFunc:uce,kernelFunc:lce};var $V=ht($o);var BV;function pce(r){BV=r.wasm.cwrap(Go,null,["number","number","number","number"])}function cce(r){let{backend:e,inputs:{logits:t},attrs:{dim:n}}=r,o=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),a=e.dataIdMap.get(s.dataId).id,i=t.shape[n],u=b.sizeFromShape(t.shape)/i;return b.sizeFromShape(s.shape)===0||BV(o,a,i,u),s}var OV={kernelName:Go,backendName:"wasm",setupFunc:pce,kernelFunc:cce};function mce(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n,i=b.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let P=1+s.length;P<o.shape.length;++P)u.push([0,0]);let l=Gx.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=I.getReshaped(l.shape,s,i,!1),c=I.getPermuted(p.length,s.length,!1),m=I.getReshapedPermuted(l.shape,s,i,!1),h=hr({inputs:{x:l},backend:t,attrs:{shape:p}}),x=mi({inputs:{x:h},backend:t,attrs:{perm:c}}),w=hr({inputs:{x},backend:t,attrs:{shape:m}});return t.disposeData(l.dataId),t.disposeData(h.dataId),t.disposeData(x.dataId),w}var zV={kernelName:bs,backendName:"wasm",kernelFunc:mce};function fce(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=t,i=b.parseAxisParam(a,o.shape)[0],u=I.prepareSplitSize(o,s,i),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(c=>{let m=[...p];m[i]=c;let f=Tu({inputs:{x:o},attrs:{begin:l,size:m},backend:n});return l[i]+=c,f})}var GV={kernelName:ys,backendName:"wasm",kernelFunc:fce};var WV=ht(Oo);var UV=ht(ja);var dce=!0,KV=At(Wo,dce);var VV;function hce(r){VV=r.wasm.cwrap(ks,null,["number","number","number","number"])}function gce(r){let{backend:e,inputs:t,attrs:n}=r,{alpha:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=e.makeOutput(s.shape,s.dtype),u=e.dataIdMap.get(i.dataId).id;return VV(a,o,at[s.dtype],u),i}var jV={kernelName:ks,backendName:"wasm",setupFunc:hce,kernelFunc:gce};var HV;function bce(r){HV=r.wasm.cwrap(ga,null,["number","array","number","array","array","array","array","array","number","number"])}function yce(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{begin:s,end:a,strides:i}=n;i==null&&(i=new Array(s.length));let{beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n,f=I.slice_util.maskToAxes(p);if(f.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(p!==0&&c!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(p!==0&&m!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let d=o.shape.length-s.length,h=I.slice_util.maskToAxes(c),g=o.shape.slice();h.forEach(W=>{s[W]=0,a[W]=1,g.splice(W,0,1)});let y=hr({inputs:{x:o},attrs:{shape:g},backend:e}),{begin:x,end:T,strides:k}=I.slice_util.getNormalizedAxes(y.shape,f,d,s,a,i,u,l,p);s=x,a=T,i=k;let w=I.slice_util.maskToAxes(m);w.forEach(W=>{a[W]=s[W]+1,i[W]=1});let P=I.slice_util.computeOutShape(s,a,i),A=P.filter((W,K)=>w.indexOf(K)===-1);if(i.every(W=>W===1)){let W=Tu({inputs:{x:y},attrs:{begin:s,size:P},backend:e});e.disposeData(y.dataId);let K=hr({inputs:{x:W},attrs:{shape:A},backend:e});return e.disposeData(W.dataId),K}let E=e.makeOutput(A,"float32");if(!A.some(W=>W===0)){let W=e.dataIdMap.get(y.dataId).id,K=new Uint8Array(new Int32Array(b.computeStrides(y.shape)).buffer),B=new Uint8Array(new Int32Array(s).buffer),V=new Uint8Array(new Int32Array(a).buffer),j=new Uint8Array(new Int32Array(i).buffer),H=new Uint8Array(new Int32Array(A).buffer),J=new Uint8Array(new Int32Array(b.computeStrides(A)).buffer),X=e.dataIdMap.get(E.dataId).id;HV(W,K,y.shape.length,B,V,j,H,J,A.length,X)}e.disposeData(y.dataId);let $=hr({inputs:{x:E},attrs:{shape:A},backend:e});return e.disposeData(E.dataId),$}var qV={kernelName:ga,backendName:"wasm",setupFunc:bce,kernelFunc:yce};var xce=!0,XV=At(Uo,xce);var YV;function Tce(r){YV=r.wasm.cwrap(zo,null,["number","number","number","number"])}function kce(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:f}=kn(a,o,e),d=c;if(f){let T=e.dataIdMap.get(p.dataId).id;T!==i&&(l=p,u=T,d=I.getInnerMostAxes(d.length,l.shape.length))}I.assertAxesAreInnerMostDims("sum",d,l.shape.length);let[h,g]=I.computeOutAndReduceShapes(l.shape,d),y=b.sizeFromShape(g),x=e.makeOutput(h,l.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(x.dataId).id;console.log("reduceshape",g),YV(u,y,at[x.dtype],T)}if(f&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(x.shape,m);x.shape=T}return x}var QV={kernelName:zo,backendName:"wasm",setupFunc:Tce,kernelFunc:kce};var ZV=ht(ba);var JV=ht(Ko);var e4;function Ice(r){e4=r.wasm.cwrap(An,null,["number","array","number","array","number","number"])}function Cce(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,s=t.dataIdMap.get(o.dataId).id,{reps:a}=n,i=new Array(o.shape.length);for(let m=0;m<i.length;m++)i[m]=o.shape[m]*a[m];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(i).buffer),p=t.makeOutput(i,o.dtype),c=t.dataIdMap.get(p.dataId).id;return e4(s,u,o.shape.length,l,i.length,at[p.dtype],c),p}var t4={kernelName:An,backendName:"wasm",setupFunc:Ice,kernelFunc:Cce};var r4;function vce(r){r4=r.wasm.cwrap(Bi,null,["number","array","number","number","number","bool","number","number"])}var wce=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{k:o,sorted:s}=t,a=e.dataIdMap.get(n.dataId).id,i=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=e.makeOutput(u,n.dtype),p=e.dataIdMap.get(l.dataId).id,c=e.makeOutput(u,"int32"),m=e.dataIdMap.get(c.dataId).id;return r4(a,i,n.shape.length,at[n.dtype],o,s,p,m),[l,c]},n4={kernelName:Bi,backendName:"wasm",setupFunc:vce,kernelFunc:wce};var o4;function Sce(r){o4=r.wasm.cwrap(ya,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function _ce(r){let{backend:e,inputs:t,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,c,m,f]=o.shape,[d,h]=l??[c,m],g=[p,d,h,f],y=new Uint8Array(new Int32Array(b.computeStrides(o.shape)).buffer),x=e.makeOutput(g,o.dtype),T=e.dataIdMap.get(x.dataId).id,w=e.dataIdMap.get(o.dataId).id,A=e.dataIdMap.get(s.dataId).id,F=a==="nearest"?1:2,E;switch(i){case"constant":E=1;break;case"reflect":E=2;break;case"wrap":E=3;break;case"nearest":E=4;break;default:E=1;break}return o4(w,A,s.shape[0]>1,p,d,h,f,m,c,y,o.shape.length-1,F,E,u,T),x}var s4={kernelName:ya,backendName:"wasm",setupFunc:Sce,kernelFunc:_ce};function Ace(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape[s],i=o.shape.length,u=new Array(i-1),l=0;for(let f=0;f<i;f++)f!==s&&(u[l++]=o.shape[f]);let p=new Array(a),c=new Array(i).fill(0),m=o.shape.slice();m[s]=1;for(let f=0;f<p.length;f++)c[s]=f,p[f]=Tu({inputs:{x:o},attrs:{begin:c,size:m},backend:t});return p.map(({dataId:f,dtype:d})=>({dataId:f,dtype:d,shape:u}))}var a4={kernelName:xs,backendName:"wasm",kernelFunc:Ace};function Nce(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(0),n}var i4={kernelName:Ts,backendName:"wasm",kernelFunc:Nce};var Dce=[DU,PU,MU,BU,zU,WU,KU,HU,XU,YU,QU,JU,eK,rK,oK,sK,aK,uK,pK,mK,dK,hK,gK,bK,yK,xK,kK,IK,CK,NU,wK,_K,NK,PK,MK,EK,RK,EU,$K,BK,OK,zK,GK,UK,KK,jK,qK,YK,QK,JK,eV,tV,nV,sV,iV,uV,pV,cV,mV,Gx,dV,gV,yV,xV,TV,kV,IV,VU,vV,SV,AV,DV,NV,FV,EV,LV,$V,qU,OV,zV,GV,WV,UV,KV,jV,qV,XV,QV,ZV,JV,t4,n4,s4,LU,a4,i4];for(let r of Dce)Oi(r);var fN=U();fN.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));fN.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(fN.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(r){return!1}});var yN=Tl(u4());var l4='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}';var c4=Tl(p4());var Kx=class extends os{constructor(e){super();this.wasm=e;this.dataIdNextNumber=1;this.wasm.tfjs.initWithThreadsCount(d4),TN=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new Oa(this,jo())}write(e,t,n){let o={id:this.dataIdNextNumber++};return this.move(o,e,t,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=b.now();return e(),{kernelMs:b.now()-t}}move(e,t,n,o,s){let a=this.dataIdNextNumber++;if(o==="string"){let p=t;this.dataIdMap.set(e,{id:a,stringBytes:p,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let i=b.sizeFromShape(n),u=i*b.bytesPerElement(o),l=this.wasm._malloc(u);this.dataIdMap.set(e,{id:a,memoryOffset:l,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(a,i,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),l)}async read(e){return this.readSync(e)}readSync(e){let{memoryOffset:t,dtype:n,shape:o,stringBytes:s}=this.dataIdMap.get(e);if(n==="string")return s;let a=this.wasm.HEAPU8.slice(t,t+b.sizeFromShape(o)*b.bytesPerElement(n));return Fce(a.buffer,n)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let o;if(n==null)o=this.write(null,e,t);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let a=b.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,a,n)}return{dataId:o,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),a=b.sizeFromShape(e);switch(t){case"float32":return new Float32Array(o,s,a);case"int32":return new Int32Array(o,s,a);case"bool":return new Uint8Array(o,s,a);default:throw new Error(`Unknown dtype ${t}`)}}};function Pce(r){return(e,t)=>(b.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||e.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,e).then(s=>{t(s.instance,s.module)})})}),{})}function m4(r,e,t){if(Vx!=null)return Vx;let n="tfjs-backend-wasm.wasm";return r&&e?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),yg!=null&&yg[n]!=null?yg[n]:t+n}async function f4(){let[r,e]=await Promise.all([U().getAsync("WASM_HAS_SIMD_SUPPORT"),U().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,n)=>{let o={};o.locateFile=(i,u)=>{if(i.endsWith(".worker.js")){let l=l4,p=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(p)}return i.endsWith(".wasm")?m4(r,e,bg??u):u+i},xN&&(o.instantiateWasm=Pce(m4(r,e,bg??"")));let s=!1;o.onAbort=()=>{if(s||xg)return;xg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;e&&r&&Vx==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+yN.default.toString()],{type:"text/javascript"}),a=(0,yN.default)(o)):a=(0,c4.default)(o),a.then(i=>{s=!0,xg=!1;let u=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",u,["number"]),dispose:i.cwrap("dispose",u,[])},t({wasm:i})})})}function Fce(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}var Mce=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Vx=null,bg=null,yg={},xg=!1,xN=!1;function Ece(r,e=!1){if(nI("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),xg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Vx=r,xN=e}function Rce(r,e=!1){if(xg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")bg=r;else{yg=r;let t=Mce.filter(n=>yg[n]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}xN=e}var d4=-1,TN=-1;function Lce(r){d4=r}function $ce(){if(TN===-1)throw new Error("WASM backend not initialized.");return TN}var Bce="0.0.0";var Oce=2;Vu("wasm",async()=>{let{wasm:r}=await f4();return new Kx(r)},Oce);var fl="3.9.0-20211016",V5r={tfjs:fl,"tfjs-core":fl,"tfjs-data":fl,"tfjs-layers":fl,"tfjs-converter":fl,"tfjs-backend-cpu":fl,"tfjs-backend-webgl":fl,"tfjs-backend-wasm":fl};export{as as Abs,bi as Acos,yi as Acosh,Jl as AdadeltaOptimizer,ep as AdagradOptimizer,tp as AdamOptimizer,rp as AdamaxOptimizer,_n as Add,no as AddN,xi as All,Ti as Any,oo as ArgMax,Wa as ArgMin,ki as Asin,Ii as Asinh,Ci as Atan,wi as Atan2,vi as Atanh,so as AvgPool,Au as AvgPool3D,Xp as AvgPool3DGrad,qp as AvgPoolGrad,Kx as BackendWasm,ao as BatchMatMul,is as BatchToSpaceND,Yp as Bincount,Qp as BroadcastArgs,GN as BroadcastTo,yv as Callback,SC as CallbackList,Wn as Cast,io as Ceil,Un as ClipByValue,Nu as Complex,Du as ComplexAbs,us as Concat,uo as Conv2D,Zp as Conv2DBackpropFilter,lo as Conv2DBackpropInput,Pu as Conv3D,Jp as Conv3DBackpropFilterV2,ec as Conv3DBackpropInputV2,po as Cos,co as Cosh,Ys as CropAndResize,Xs as Cumsum,AC as CustomCallback,Oa as DataStorage,tc as DenseBincount,Qs as DepthToSpace,mo as DepthwiseConv2dNative,rc as DepthwiseConv2dNativeBackpropFilter,nc as DepthwiseConv2dNativeBackpropInput,oc as Diag,Fu as Dilation2D,of as Dilation2DBackpropFilter,nf as Dilation2DBackpropInput,xk as ENV,xv as EarlyStopping,Mu as Einsum,ho as Elu,sc as EluGrad,jg as Environment,Zs as Equal,Si as Erf,go as Exp,ls as ExpandDims,Js as Expm1,ac as FFT,Ua as Fill,ea as FlipLeftRight,bo as Floor,yo as FloorDiv,vl as FromPixels,xo as FusedBatchNorm,Cs as FusedConv2D,vs as FusedDepthwiseConv2D,dx as GPGPUContext,ta as GatherNd,ps as GatherV2,Xv as GraphModel,ra as Greater,To as GreaterEqual,_C as History,ic as IFFT,Kn as Identity,Eu as Imag,Ft as InputSpec,_i as IsFinite,Ai as IsInf,Ni as IsNan,os as KernelBackend,Ru as LRN,lc as LRNGrad,Xb as LayerVariable,Zo as LayersModel,na as LeakyRelu,oa as Less,sa as LessEqual,uc as LinSpace,ko as Log,Di as Log1p,WN as LogSoftmax,aa as LogicalAnd,Pi as LogicalNot,Cl as LogicalOr,Ah as MathBackendCPU,Vh as MathBackendWebGL,Io as Max,vo as MaxPool,Lu as MaxPool3D,cc as MaxPool3DGrad,pc as MaxPoolGrad,mc as MaxPoolWithArgmax,Co as Maximum,wo as Mean,So as Min,_o as Minimum,Ao as MirrorPad,Fi as Mod,np as MomentumOptimizer,fc as Multinomial,No as Multiply,cs as Neg,ua as NonMaxSuppressionV3,Mi as NonMaxSuppressionV4,la as NonMaxSuppressionV5,ia as NotEqual,bD as OP_SCOPE_SUFFIX,pa as OneHot,ms as OnesLike,Zr as Optimizer,fs as Pack,Do as PadV2,Xce as Pool,Po as Pow,Fo as Prelu,ca as Prod,op as RMSPropOptimizer,Bs as RNN,Ka as Range,Nk as Rank,$u as Real,fo as RealDiv,Ei as Reciprocal,or as Reduction,Mo as Relu,Ro as Relu6,ds as Reshape,Eo as ResizeBilinear,hc as ResizeBilinearGrad,Va as ResizeNearestNeighbor,dc as ResizeNearestNeighborGrad,ma as Reverse,xa as RotateWithOffset,fa as Round,Lo as Rsqrt,ru as SGDOptimizer,da as ScatterNd,hs as Select,Ri as Selu,im as Sequential,Bo as Sigmoid,Li as Sign,$o as Sin,ha as Sinh,gs as Slice,Go as Softmax,$i as Softplus,bs as SpaceToBatchND,gc as SparseFillEmptyRows,bc as SparseReshape,yc as SparseSegmentMean,xc as SparseSegmentSum,Bu as SparseToDense,ys as SplitV,Oo as Sqrt,ja as Square,Wo as SquaredDifference,ks as Step,ga as StridedSlice,Ou as StringNGrams,Tc as StringSplit,kc as StringToHashBucketFast,Uo as Sub,zo as Sum,hn as SymbolicTensor,ba as Tan,Ko as Tanh,Ye as Tensor,xt as TensorBuffer,An as Tile,Bi as TopK,ya as Transform,Vo as Transpose,Ic as Unique,xs as Unpack,zu as UnsortedSegmentSum,Uu as Variable,Ts as ZerosLike,Is as _FusedMatMul,Ot as abs,oI as acos,sI as acosh,Y as add,aI as addN,bf as all,Ec as any,qi as argMax,iI as argMin,uI as asin,lI as asinh,pI as atan,cI as atan2,mI as atanh,Ml as avgPool,yf as avgPool3d,h0 as backend,I as backend_util,Eq as basicLSTMCell,Xa as batchNorm,gI as batchNorm2d,bI as batchNorm3d,yI as batchNorm4d,El as batchToSpaceND,xf as bincount,JRe as booleanMaskAsync,xI as broadcastArgs,Rl as broadcastTo,ub as browser,Ce as buffer,YZ as callbacks,Q as cast,TI as ceil,Lr as clipByValue,Nn as clone,Hn as complex,lt as concat,kI as concat1d,II as concat2d,CI as concat3d,vI as concat4d,FP as constraints,Tf as conv1d,qn as conv2d,kf as conv2dTranspose,If as conv3d,wI as conv3dTranspose,rme as copyRegisteredKernels,Ll as cos,Cf as cosh,_b as cosineWindow,vf as cumsum,pn as customGrad,QM as data,SI as denseBincount,nI as deprecationWarn,_I as depthToSpace,Yi as depthwiseConv2d,ZZ as deregisterOp,Gi as device_util,l6 as diag,AI as dilation2d,Xge as disableDeprecationWarnings,Ee as dispose,Yge as disposeVariables,pe as div,NI as divNoNan,b6 as dot,G0 as dropout,DI as einsum,Qi as elu,qge as enableDebugMode,Hge as enableProdMode,W0 as enclosingPowerOfTwo,jo as engine,U as env,Kr as equal,PI as erf,cr as exp,_r as expandDims,FI as expm1,$c as eye,jl as fft,Ia as fill,rbe as findBackend,nbe as findBackendFactory,Zi as floor,gf as floorDiv,IB as forceHalfFloat,Ds as fused,Ya as gather,O0 as gatherND,lb as gather_util,ebe as getBackend,Ik as getGradient,af as getKernel,Hg as getKernelsForBackend,$ce as getThreadsCount,C$ as gpgpu_util,W6 as grad,U6 as grads,nr as greater,qo as greaterEqual,Hu as ifft,$l as imag,Mn as image,d$e as inTopKAsync,ZP as initializers,$C as input,Ur as io,zf as irfft,F6 as isFinite,E6 as isInf,MI as isNaN,Kt as keep,Tr as kernel_impls,MF as layers,Bl as leakyRelu,wf as less,Xo as lessEqual,N2 as linalg,EI as linspace,SJ as loadGraphModel,lQ as loadLayersModel,RI as localResponseNormalization,$r as log,Ol as log1p,X6 as logSigmoid,Sf as logSoftmax,OI as logSumExp,jr as logicalAnd,zl as logicalNot,Af as logicalOr,i5 as logicalXor,YKe as losses,Ve as matMul,QD as math,Qr as max,Gl as maxPool,Nf as maxPool3d,zI as maxPoolWithArgmax,Xn as maximum,Rt as mean,hf as memory,f5 as meshgrid,EF as metrics,Bc as min,Ji as minimum,GI as mirrorPad,WI as mod,iQ as model,RF as models,Oc as moments,wLe as movingAverage,R as mul,k5 as multiRNNCell,UI as multinomial,et as neg,uC as nextFrame,wb as norm,Za as notEqual,ji as oneHot,mr as ones,Ar as onesLike,_ as op,S5 as outerProduct,Pn as pad,N5 as pad1d,P5 as pad2d,M5 as pad3d,R5 as pad4d,z5 as pool,Fn as pow,Ul as prelu,qk as print,Df as prod,Qge as profile,V5 as rand,J5 as randomGamma,kb as randomNormal,Ca as randomUniform,eu as range,Jge as ready,ju as real,ZI as reciprocal,Vu as registerBackend,pQ as registerCallbackConstructor,UN as registerGradient,Oi as registerKernel,QZ as registerOp,LF as regularizers,Hr as relu,Ff as relu6,tbe as removeBackend,L as reshape,xr as reverse,u8 as reverse1d,p8 as reverse2d,m8 as reverse3d,d8 as reverse4d,Hl as rfft,Mf as round,Ef as rsqrt,ce as scalar,$0 as scatterND,cb as scatter_util,Rf as selu,JI as separableConv2d,uQ as sequential,ee as serialization,rq as setBackend,obe as setPlatform,Lce as setThreadsCount,Ece as setWasmPath,Rce as setWasmPaths,Ww as setWebGLContext,eC as setdiff1dAsync,vm as shared,ln as sigmoid,tC as sign,CKe as signal,Lf as sin,$f as sinh,We as slice,Bf as slice1d,Ib as slice2d,Of as slice3d,Gc as slice4d,Xt as slice_util,Vl as softmax,Qa as softplus,Wl as spaceToBatchND,Uf as sparse,Sb as sparseToDense,yKe as spectral,Ir as split,Lt as sqrt,Xe as square,Gf as squaredDifference,cn as squeeze,fr as stack,tu as step,rC as stridedSlice,Rb as string,ue as sub,me as sum,zi as sumOutType,nC as tan,Xi as tanh,Er as tensor,Gt as tensor1d,Ja as tensor2d,Zk as tensor3d,z8 as tensor4d,G8 as tensor5d,W8 as tensor6d,As as tensor_util,d0 as test_util,G as tidy,Vr as tile,Zge as time,oC as topk,sp as train,qe as transpose,ql as truncatedNormal,Cb as unique,tme as unregisterGradient,eme as unregisterKernel,sC as unsortedSegmentSum,Br as unstack,Ut as upcastType,b as util,K6 as valueAndGrad,V6 as valueAndGrads,aC as variable,bb as variableGrads,V5r as version,_J as version_converter,tq as version_core,t9 as version_cpu,dd as version_layers,Bce as version_wasm,Kre as version_webgl,L6t as webgl,f$ as webgl_util,_U as webgpu,zt as where,Wf as whereAsync,Tt as zeros,De as zerosLike};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
//# sourceMappingURL=tfjs.min.esm.js.map
