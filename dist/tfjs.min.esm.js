var d6=Object.create;var db=Object.defineProperty;var f6=Object.getOwnPropertyDescriptor;var h6=Object.getOwnPropertyNames;var g6=Object.getPrototypeOf,b6=Object.prototype.hasOwnProperty;var y6=(r,e,t)=>e in r?db(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var fb=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var Nr=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),qe=(r,e)=>{for(var t in e)db(r,t,{get:e[t],enumerable:!0})},T6=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of h6(e))!b6.call(r,o)&&o!==t&&db(r,o,{get:()=>e[o],enumerable:!(n=f6(e,o))||n.enumerable});return r};var Wl=(r,e,t)=>(t=r!=null?d6(g6(r)):{},T6(e||!r||!r.__esModule?db(t,"default",{value:r,enumerable:!0}):t,r));var K=(r,e,t)=>(y6(r,typeof e!="symbol"?e+"":e,t),t);var m_=Nr((Vbe,p_)=>{p_.exports=Yt;var Bs=null;try{Bs=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Yt(r,e,t){this.low=r|0,this.high=e|0,this.unsigned=!!t}Yt.prototype.__isLong__;Object.defineProperty(Yt.prototype,"__isLong__",{value:!0});function qn(r){return(r&&r.__isLong__)===!0}Yt.isLong=qn;var t_={},r_={};function ql(r,e){var t,n,o;return e?(r>>>=0,(o=0<=r&&r<256)&&(n=r_[r],n)?n:(t=Zt(r,(r|0)<0?-1:0,!0),o&&(r_[r]=t),t)):(r|=0,(o=-128<=r&&r<128)&&(n=t_[r],n)?n:(t=Zt(r,r<0?-1:0,!1),o&&(t_[r]=t),t))}Yt.fromInt=ql;function Os(r,e){if(isNaN(r))return e?Hl:zs;if(e){if(r<0)return Hl;if(r>=a_)return l_}else{if(r<=-o_)return Hn;if(r+1>=o_)return u_}return r<0?Os(-r,e).neg():Zt(r%Ym|0,r/Ym|0,e)}Yt.fromNumber=Os;function Zt(r,e,t){return new Yt(r,e,t)}Yt.fromBits=Zt;var yb=Math.pow;function Nv(r,e,t){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return zs;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return Nv(r.substring(1),e,t).neg();for(var o=Os(yb(t,8)),s=zs,a=0;a<r.length;a+=8){var i=Math.min(8,r.length-a),u=parseInt(r.substring(a,a+i),t);if(i<8){var l=Os(yb(t,i));s=s.mul(l).add(Os(u))}else s=s.mul(o),s=s.add(Os(u))}return s.unsigned=e,s}Yt.fromString=Nv;function Qa(r,e){return typeof r=="number"?Os(r,e):typeof r=="string"?Nv(r,e):Zt(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}Yt.fromValue=Qa;var n_=1<<16,U6=1<<24,Ym=n_*n_,a_=Ym*Ym,o_=a_/2,s_=ql(U6),zs=ql(0);Yt.ZERO=zs;var Hl=ql(0,!0);Yt.UZERO=Hl;var Xm=ql(1);Yt.ONE=Xm;var i_=ql(1,!0);Yt.UONE=i_;var wv=ql(-1);Yt.NEG_ONE=wv;var u_=Zt(-1,2147483647,!1);Yt.MAX_VALUE=u_;var l_=Zt(-1,-1,!0);Yt.MAX_UNSIGNED_VALUE=l_;var Hn=Zt(0,-2147483648,!1);Yt.MIN_VALUE=Hn;var Ce=Yt.prototype;Ce.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ce.toNumber=function(){return this.unsigned?(this.high>>>0)*Ym+(this.low>>>0):this.high*Ym+(this.low>>>0)};Ce.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Hn)){var t=Os(e),n=this.div(t),o=n.mul(t).sub(this);return n.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=Os(yb(e,6),this.unsigned),a=this,i="";;){var u=a.div(s),l=a.sub(u.mul(s)).toInt()>>>0,p=l.toString(e);if(a=u,a.isZero())return p+i;for(;p.length<6;)p="0"+p;i=""+p+i}};Ce.getHighBits=function(){return this.high};Ce.getHighBitsUnsigned=function(){return this.high>>>0};Ce.getLowBits=function(){return this.low};Ce.getLowBitsUnsigned=function(){return this.low>>>0};Ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Hn)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};Ce.isZero=function(){return this.high===0&&this.low===0};Ce.eqz=Ce.isZero;Ce.isNegative=function(){return!this.unsigned&&this.high<0};Ce.isPositive=function(){return this.unsigned||this.high>=0};Ce.isOdd=function(){return(this.low&1)===1};Ce.isEven=function(){return(this.low&1)===0};Ce.equals=function(e){return qn(e)||(e=Qa(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Ce.eq=Ce.equals;Ce.notEquals=function(e){return!this.eq(e)};Ce.neq=Ce.notEquals;Ce.ne=Ce.notEquals;Ce.lessThan=function(e){return this.comp(e)<0};Ce.lt=Ce.lessThan;Ce.lessThanOrEqual=function(e){return this.comp(e)<=0};Ce.lte=Ce.lessThanOrEqual;Ce.le=Ce.lessThanOrEqual;Ce.greaterThan=function(e){return this.comp(e)>0};Ce.gt=Ce.greaterThan;Ce.greaterThanOrEqual=function(e){return this.comp(e)>=0};Ce.gte=Ce.greaterThanOrEqual;Ce.ge=Ce.greaterThanOrEqual;Ce.compare=function(e){if(qn(e)||(e=Qa(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Ce.comp=Ce.compare;Ce.negate=function(){return!this.unsigned&&this.eq(Hn)?Hn:this.not().add(Xm)};Ce.neg=Ce.negate;Ce.add=function(e){qn(e)||(e=Qa(e));var t=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,a=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,p=0,m=0,c=0,d=0;return d+=s+l,c+=d>>>16,d&=65535,c+=o+u,m+=c>>>16,c&=65535,m+=n+i,p+=m>>>16,m&=65535,p+=t+a,p&=65535,Zt(c<<16|d,p<<16|m,this.unsigned)};Ce.subtract=function(e){return qn(e)||(e=Qa(e)),this.add(e.neg())};Ce.sub=Ce.subtract;Ce.multiply=function(e){if(this.isZero())return zs;if(qn(e)||(e=Qa(e)),Bs){var t=Bs.mul(this.low,this.high,e.low,e.high);return Zt(t,Bs.get_high(),this.unsigned)}if(e.isZero())return zs;if(this.eq(Hn))return e.isOdd()?Hn:zs;if(e.eq(Hn))return this.isOdd()?Hn:zs;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(s_)&&e.lt(s_))return Os(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,a=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,p=e.low&65535,m=0,c=0,d=0,f=0;return f+=a*p,d+=f>>>16,f&=65535,d+=s*p,c+=d>>>16,d&=65535,d+=a*l,c+=d>>>16,d&=65535,c+=o*p,m+=c>>>16,c&=65535,c+=s*l,m+=c>>>16,c&=65535,c+=a*u,m+=c>>>16,c&=65535,m+=n*p+o*l+s*u+a*i,m&=65535,Zt(d<<16|f,m<<16|c,this.unsigned)};Ce.mul=Ce.multiply;Ce.divide=function(e){if(qn(e)||(e=Qa(e)),e.isZero())throw Error("division by zero");if(Bs){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Bs.div_u:Bs.div_s)(this.low,this.high,e.low,e.high);return Zt(t,Bs.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Hl:zs;var n,o,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Hl;if(e.gt(this.shru(1)))return i_;s=Hl}else{if(this.eq(Hn)){if(e.eq(Xm)||e.eq(wv))return Hn;if(e.eq(Hn))return Xm;var a=this.shr(1);return n=a.div(e).shl(1),n.eq(zs)?e.isNegative()?Xm:wv:(o=this.sub(e.mul(n)),s=n.add(o.div(e)),s)}else if(e.eq(Hn))return this.unsigned?Hl:zs;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=zs}for(o=this;o.gte(e);){n=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:yb(2,i-48),l=Os(n),p=l.mul(e);p.isNegative()||p.gt(o);)n-=u,l=Os(n,this.unsigned),p=l.mul(e);l.isZero()&&(l=Xm),s=s.add(l),o=o.sub(p)}return s};Ce.div=Ce.divide;Ce.modulo=function(e){if(qn(e)||(e=Qa(e)),Bs){var t=(this.unsigned?Bs.rem_u:Bs.rem_s)(this.low,this.high,e.low,e.high);return Zt(t,Bs.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Ce.mod=Ce.modulo;Ce.rem=Ce.modulo;Ce.not=function(){return Zt(~this.low,~this.high,this.unsigned)};Ce.and=function(e){return qn(e)||(e=Qa(e)),Zt(this.low&e.low,this.high&e.high,this.unsigned)};Ce.or=function(e){return qn(e)||(e=Qa(e)),Zt(this.low|e.low,this.high|e.high,this.unsigned)};Ce.xor=function(e){return qn(e)||(e=Qa(e)),Zt(this.low^e.low,this.high^e.high,this.unsigned)};Ce.shiftLeft=function(e){return qn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Zt(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Zt(0,this.low<<e-32,this.unsigned)};Ce.shl=Ce.shiftLeft;Ce.shiftRight=function(e){return qn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Zt(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Zt(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Ce.shr=Ce.shiftRight;Ce.shiftRightUnsigned=function(e){if(qn(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return Zt(n>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Zt(t,0,this.unsigned):Zt(t>>>e-32,0,this.unsigned)};Ce.shru=Ce.shiftRightUnsigned;Ce.shr_u=Ce.shiftRightUnsigned;Ce.toSigned=function(){return this.unsigned?Zt(this.low,this.high,!1):this};Ce.toUnsigned=function(){return this.unsigned?this:Zt(this.low,this.high,!0)};Ce.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Ce.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Ce.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Yt.fromBytes=function(e,t,n){return n?Yt.fromBytesLE(e,t):Yt.fromBytesBE(e,t)};Yt.fromBytesLE=function(e,t){return new Yt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Yt.fromBytesBE=function(e,t){return new Yt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});var Y_=Nr(()=>{});var Z_=Nr(()=>{});var S2=Nr((k2,dA)=>{(function(r,e,t){function n(i){var u=this,l=a();u.next=function(){var p=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=p-(u.c=p|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(i),u.s0<0&&(u.s0+=1),u.s1-=l(i),u.s1<0&&(u.s1+=1),u.s2-=l(i),u.s2<0&&(u.s2+=1),l=null}function o(i,u){return u.c=i.c,u.s0=i.s0,u.s1=i.s1,u.s2=i.s2,u}function s(i,u){var l=new n(i),p=u&&u.state,m=l.next;return m.int32=function(){return l.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&o(p,l),m.state=function(){return o(l,{})}),m}function a(){var i=4022871197,u=function(l){l=String(l);for(var p=0;p<l.length;p++){i+=l.charCodeAt(p);var m=.02519603282416938*i;i=m>>>0,m-=i,m*=i,i=m>>>0,m-=i,i+=m*4294967296}return(i>>>0)*23283064365386963e-26};return u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(k2,typeof dA=="object"&&dA,typeof define=="function"&&define)});var A2=Nr((v2,fA)=>{(function(r,e,t){function n(a){var i=this,u="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var p=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^p^p>>>8},a===(a|0)?i.x=a:u+=a;for(var l=0;l<u.length+64;l++)i.x^=u.charCodeAt(l)|0,i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(v2,typeof fA=="object"&&fA,typeof define=="function"&&define)});var N2=Nr((w2,hA)=>{(function(r,e,t){function n(a){var i=this,u="";i.next=function(){var p=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(p^p<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:u+=a;for(var l=0;l<u.length+64;l++)i.x^=u.charCodeAt(l)|0,l==u.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(w2,typeof hA=="object"&&hA,typeof define=="function"&&define)});var _2=Nr((D2,gA)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var l=i.x,p=i.i,m,c,d;return m=l[p],m^=m>>>7,c=m^m<<24,m=l[p+1&7],c^=m^m>>>10,m=l[p+3&7],c^=m^m>>>3,m=l[p+4&7],c^=m^m<<7,m=l[p+7&7],m=m^m<<13,c^=m^m<<9,l[p]=c,i.i=p+1&7,c};function u(l,p){var m,c,d=[];if(p===(p|0))c=d[0]=p;else for(p=""+p,m=0;m<p.length;++m)d[m&7]=d[m&7]<<15^p.charCodeAt(m)+d[m+1&7]<<13;for(;d.length<8;)d.push(0);for(m=0;m<8&&d[m]===0;++m);for(m==8?c=d[7]=-1:c=d[m],l.x=d,l.i=0,m=256;m>0;--m)l.next()}u(i,a)}function o(a,i){return i.x=a.x.slice(),i.i=a.i,i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(l.x&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(D2,typeof gA=="object"&&gA,typeof define=="function"&&define)});var R2=Nr((M2,bA)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var l=i.w,p=i.X,m=i.i,c,d;return i.w=l=l+1640531527|0,d=p[m+34&127],c=p[m=m+1&127],d^=d<<13,c^=c<<17,d^=d>>>15,c^=c>>>12,d=p[m]=d^c,i.i=m,d+(l^l>>>16)|0};function u(l,p){var m,c,d,f,h,g=[],b=128;for(p===(p|0)?(c=p,p=null):(p=p+"\0",c=0,b=Math.max(b,p.length)),d=0,f=-32;f<b;++f)p&&(c^=p.charCodeAt((f+32)%p.length)),f===0&&(h=c),c^=c<<10,c^=c>>>15,c^=c<<4,c^=c>>>13,f>=0&&(h=h+1640531527|0,m=g[f&127]^=c+h,d=m==0?d+1:0);for(d>=128&&(g[(p&&p.length||0)&127]=-1),d=127,f=4*128;f>0;--f)c=g[d+34&127],m=g[d=d+1&127],c^=c<<13,m^=m<<17,c^=c>>>15,m^=m>>>12,g[d]=c^m;l.w=h,l.X=g,l.i=d}u(i,a)}function o(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(l.X&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(M2,typeof bA=="object"&&bA,typeof define=="function"&&define)});var E2=Nr((P2,yA)=>{(function(r,e,t){function n(a){var i=this,u="";i.next=function(){var p=i.b,m=i.c,c=i.d,d=i.a;return p=p<<25^p>>>7^m,m=m-c|0,c=c<<24^c>>>8^d,d=d-p|0,i.b=p=p<<20^p>>>12^m,i.c=m=m-c|0,i.d=c<<16^m>>>16^d,i.a=d-p|0},i.a=0,i.b=0,i.c=-1640531527,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):u+=a;for(var l=0;l<u.length+20;l++)i.b^=u.charCodeAt(l)|0,i.next()}function o(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(P2,typeof yA=="object"&&yA,typeof define=="function"&&define)});var F2=Nr(()=>{});var $2=Nr((L2,fy)=>{(function(r,e,t){var n=256,o=6,s=52,a="random",i=t.pow(n,o),u=t.pow(2,s),l=u*2,p=n-1,m;function c(x,I,k){var w=[];I=I==!0?{entropy:!0}:I||{};var _=g(h(I.entropy?[x,T(e)]:x??b(),3),w),M=new d(w),R=function(){for(var E=M.g(o),O=i,G=0;E<u;)E=(E+G)*n,O*=n,G=M.g(1);for(;E>=l;)E/=2,O/=2,G>>>=1;return(E+G)/O};return R.int32=function(){return M.g(4)|0},R.quick=function(){return M.g(4)/4294967296},R.double=R,g(T(M.S),e),(I.pass||k||function(E,O,G,W){return W&&(W.S&&f(W,M),E.state=function(){return f(M,{})}),G?(t[a]=E,O):E})(R,_,"global"in I?I.global:this==t,I.state)}function d(x){var I,k=x.length,w=this,_=0,M=w.i=w.j=0,R=w.S=[];for(k||(x=[k++]);_<n;)R[_]=_++;for(_=0;_<n;_++)R[_]=R[M=p&M+x[_%k]+(I=R[_])],R[M]=I;(w.g=function(E){for(var O,G=0,W=w.i,H=w.j,U=w.S;E--;)O=U[W=p&W+1],G=G*n+U[p&(U[W]=U[H=p&H+O])+(U[H]=O)];return w.i=W,w.j=H,G})(n)}function f(x,I){return I.i=x.i,I.j=x.j,I.S=x.S.slice(),I}function h(x,I){var k=[],w=typeof x,_;if(I&&w=="object")for(_ in x)try{k.push(h(x[_],I-1))}catch{}return k.length?k:w=="string"?x:x+"\0"}function g(x,I){for(var k=x+"",w,_=0;_<k.length;)I[p&_]=p&(w^=I[p&_]*19)+k.charCodeAt(_++);return T(I)}function b(){try{var x;return m&&(x=m.randomBytes)?x=x(n):(x=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(x)),T(x)}catch{var I=r.navigator,k=I&&I.plugins;return[+new Date,r,k,r.screen,T(e)]}}function T(x){return String.fromCharCode.apply(0,x)}if(g(t.random(),e),typeof fy=="object"&&fy.exports){fy.exports=c;try{m=F2()}catch{}}else typeof define=="function"&&define.amd?define(function(){return c}):t["seed"+a]=c})(typeof self<"u"?self:L2,[],Math)});var _h=Nr((LLe,B2)=>{var jY=S2(),XY=A2(),YY=N2(),ZY=_2(),QY=R2(),JY=E2(),ap=$2();ap.alea=jY;ap.xor128=XY;ap.xorwow=YY;ap.xorshift7=ZY;ap.xor4096=QY;ap.tychei=JY;B2.exports=ap});var Rw=Nr(()=>{});var yx=Nr(()=>{});var Eg=Nr(()=>{});var kj=Nr(()=>{});var Sj=Nr(()=>{});var vj=Nr(()=>{});var Aj=Nr((_k,x0)=>{"use strict";var T0=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e){e=e||{};function t(){return ie.buffer!=Je&&rr(ie.buffer),Rt}function n(){return ie.buffer!=Je&&rr(ie.buffer),Tt}function o(){return ie.buffer!=Je&&rr(ie.buffer),$t}function s(){return ie.buffer!=Je&&rr(ie.buffer),On}function a(){return ie.buffer!=Je&&rr(ie.buffer),dr}function i(){return ie.buffer!=Je&&rr(ie.buffer),so}function u(){return ie.buffer!=Je&&rr(ie.buffer),Wr}var l=typeof e<"u"?e:{},p,m;l.ready=new Promise(function(L,q){p=L,m=q});var c;typeof process<"u"&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d=Object.assign({},l),f=[],h="./this.program",g=(L,q)=>{throw q},b=typeof window=="object",T=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",I=l.ENVIRONMENT_IS_PTHREAD||!1,k="";function w(L){return l.locateFile?l.locateFile(L,k):k+L}var _,M,R,E;function O(L){if(L instanceof zl)return;Y("exiting due to exception: "+L)}if(x){T?k=Eg().dirname(k)+"/":k=__dirname+"/";var G,W;typeof fb=="function"&&(G=yx(),W=Eg()),_=(q,pe)=>(q=W.normalize(q),G.readFileSync(q,pe?void 0:"utf8")),R=q=>{var pe=_(q,!0);return pe.buffer||(pe=new Uint8Array(pe)),pe},M=(q,pe,ke)=>{q=W.normalize(q),G.readFile(q,function(Be,mt){Be?ke(Be):pe(mt.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),f=process.argv.slice(2),process.on("uncaughtException",function(q){if(!(q instanceof zl))throw q}),process.on("unhandledRejection",function(q){throw q}),g=(q,pe)=>{if(da())throw process.exitCode=q,pe;O(pe),process.exit(q)},l.inspect=function(){return"[Emscripten Module object]"};let L;try{L=kj()}catch(q){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),q}global.Worker=L.Worker}else(b||T)&&(T?k=self.location.href:typeof document<"u"&&document.currentScript&&(k=document.currentScript.src),r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",x||(_=L=>{var q=new XMLHttpRequest;return q.open("GET",L,!1),q.send(null),q.responseText},T&&(R=L=>{var q=new XMLHttpRequest;return q.open("GET",L,!1),q.responseType="arraybuffer",q.send(null),new Uint8Array(q.response)}),M=(L,q,pe)=>{var ke=new XMLHttpRequest;ke.open("GET",L,!0),ke.responseType="arraybuffer",ke.onload=()=>{if(ke.status==200||ke.status==0&&ke.response){q(ke.response);return}pe()},ke.onerror=pe,ke.send(null)}),E=L=>document.title=L);x&&typeof performance>"u"&&(global.performance=Sj().performance);var H=console.log.bind(console),U=console.warn.bind(console);x&&(H=L=>G.writeSync(1,L+`
`),U=L=>G.writeSync(2,L+`
`));var V=l.print||H,Y=l.printErr||U;Object.assign(l,d),d=null,l.arguments&&(f=l.arguments),l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit);var j=4,te=Atomics.load,ne=Atomics.store,oe=Atomics.compareExchange,ae;l.wasmBinary&&(ae=l.wasmBinary);var se=l.noExitRuntime||!0;typeof WebAssembly!="object"&&cm("no native wasm support detected");var ie,he,ye=!1,ve;function Fe(L,q){L||cm(q)}var $e=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function je(L,q,pe){for(var ke=q+pe,Be=q;L[Be]&&!(Be>=ke);)++Be;if(Be-q>16&&L.buffer&&$e)return $e.decode(L.buffer instanceof SharedArrayBuffer?L.slice(q,Be):L.subarray(q,Be));for(var mt="";q<Be;){var Xe=L[q++];if(!(Xe&128)){mt+=String.fromCharCode(Xe);continue}var et=L[q++]&63;if((Xe&224)==192){mt+=String.fromCharCode((Xe&31)<<6|et);continue}var kr=L[q++]&63;if((Xe&240)==224?Xe=(Xe&15)<<12|et<<6|kr:Xe=(Xe&7)<<18|et<<12|kr<<6|L[q++]&63,Xe<65536)mt+=String.fromCharCode(Xe);else{var lo=Xe-65536;mt+=String.fromCharCode(55296|lo>>10,56320|lo&1023)}}return mt}function J(L,q){return L?je(n(),L,q):""}function gt(L,q,pe,ke){if(!(ke>0))return 0;for(var Be=pe,mt=pe+ke-1,Xe=0;Xe<L.length;++Xe){var et=L.charCodeAt(Xe);if(et>=55296&&et<=57343){var kr=L.charCodeAt(++Xe);et=65536+((et&1023)<<10)|kr&1023}if(et<=127){if(pe>=mt)break;q[pe++]=et}else if(et<=2047){if(pe+1>=mt)break;q[pe++]=192|et>>6,q[pe++]=128|et&63}else if(et<=65535){if(pe+2>=mt)break;q[pe++]=224|et>>12,q[pe++]=128|et>>6&63,q[pe++]=128|et&63}else{if(pe+3>=mt)break;q[pe++]=240|et>>18,q[pe++]=128|et>>12&63,q[pe++]=128|et>>6&63,q[pe++]=128|et&63}}return q[pe]=0,pe-Be}function St(L,q,pe){return gt(L,n(),q,pe)}var Je,Rt,Tt,$t,Xt,On,dr,so,Wr;I&&(Je=l.buffer);function rr(L){Je=L,l.HEAP8=Rt=new Int8Array(L),l.HEAP16=$t=new Int16Array(L),l.HEAP32=On=new Int32Array(L),l.HEAPU8=Tt=new Uint8Array(L),l.HEAPU16=Xt=new Uint16Array(L),l.HEAPU32=dr=new Uint32Array(L),l.HEAPF32=so=new Float32Array(L),l.HEAPF64=Wr=new Float64Array(L)}var Ur=l.INITIAL_MEMORY||16777216;if(I)ie=l.wasmMemory,Je=l.buffer;else if(l.wasmMemory)ie=l.wasmMemory;else if(ie=new WebAssembly.Memory({initial:Ur/65536,maximum:32768,shared:!0}),!(ie.buffer instanceof SharedArrayBuffer))throw Y("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");ie&&(Je=ie.buffer),Ur=Je.byteLength,rr(Je);var Kr,ao=[],io=[],tn=[],Hi=!1;function da(){return se}function Eu(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)Yf(l.preRun.shift());Jf(ao)}function Lr(){Hi=!0,!I&&Jf(io)}function qi(){if(!I){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)w0(l.postRun.shift());Jf(tn)}}function Yf(L){ao.unshift(L)}function Zf(L){io.unshift(L)}function w0(L){tn.unshift(L)}var Fu=0,mm=null,ji=null;function N0(L){Fu++,l.monitorRunDependencies&&l.monitorRunDependencies(Fu)}function D0(L){if(Fu--,l.monitorRunDependencies&&l.monitorRunDependencies(Fu),Fu==0&&(mm!==null&&(clearInterval(mm),mm=null),ji)){var q=ji;ji=null,q()}}function cm(L){I?postMessage({cmd:"onAbort",arg:L}):l.onAbort&&l.onAbort(L),L="Aborted("+L+")",Y(L),ye=!0,ve=1,L+=". Build with -sASSERTIONS for more info.";var q=new WebAssembly.RuntimeError(L);throw m(q),q}var Pk="data:application/octet-stream;base64,";function Og(L){return L.startsWith(Pk)}function zg(L){return L.startsWith("file://")}var cn;cn="tfjs-backend-wasm-threaded-simd.wasm",Og(cn)||(cn=w(cn));function Gg(L){try{if(L==cn&&ae)return new Uint8Array(ae);if(R)return R(L);throw"both async and sync fetching of the wasm failed"}catch(q){cm(q)}}function Ek(){if(!ae&&(b||T)){if(typeof fetch=="function"&&!zg(cn))return fetch(cn,{credentials:"same-origin"}).then(function(L){if(!L.ok)throw"failed to load wasm binary file at '"+cn+"'";return L.arrayBuffer()}).catch(function(){return Gg(cn)});if(M)return new Promise(function(L,q){M(cn,function(pe){L(new Uint8Array(pe))},q)})}return Promise.resolve().then(function(){return Gg(cn)})}function Wg(){var L={env:tb,wasi_snapshot_preview1:tb};function q(Xe,et){var kr=Xe.exports;if(l.asm=kr,Kk(l.asm._emscripten_tls_init),Kr=l.asm.__indirect_function_table,Zf(l.asm.__wasm_call_ctors),he=et,!I){var lo=Ze.unusedWorkers.length;Ze.unusedWorkers.forEach(function(Yi){Ze.loadWasmModuleToWorker(Yi,function(){--lo||D0("wasm-instantiate")})})}}I||N0("wasm-instantiate");function pe(Xe){q(Xe.instance,Xe.module)}function ke(Xe){return Ek().then(function(et){return WebAssembly.instantiate(et,L)}).then(function(et){return et}).then(Xe,function(et){Y("failed to asynchronously prepare wasm: "+et),cm(et)})}function Be(){return!ae&&typeof WebAssembly.instantiateStreaming=="function"&&!Og(cn)&&!zg(cn)&&!x&&typeof fetch=="function"?fetch(cn,{credentials:"same-origin"}).then(function(Xe){var et=WebAssembly.instantiateStreaming(Xe,L);return et.then(pe,function(kr){return Y("wasm streaming compile failed: "+kr),Y("falling back to ArrayBuffer instantiation"),ke(pe)})}):ke(pe)}if(l.instantiateWasm)try{var mt=l.instantiateWasm(L,q);return mt}catch(Xe){Y("Module.instantiateWasm callback failed with error: "+Xe),m(Xe)}return Be().catch(m),{}}var _0,M0,Fk={};function zl(L){this.name="ExitStatus",this.message="Program terminated with exit("+L+")",this.status=L}function Lk(L){var q=Ze.pthreads[L];delete Ze.pthreads[L],q.terminate(),dv(L),Ze.runningWorkers.splice(Ze.runningWorkers.indexOf(q),1),q.pthread_ptr=0}function Ug(L){var q=Ze.pthreads[L];q.postMessage({cmd:"cancel"})}function Kg(L){var q=Ze.pthreads[L];Fe(q),Ze.returnWorkerToPool(q)}function Vg(L){var q=Ze.getNewWorker();if(!q)return 6;Ze.runningWorkers.push(q),Ze.pthreads[L.pthread_ptr]=q,q.pthread_ptr=L.pthread_ptr;var pe={cmd:"run",start_routine:L.startRoutine,arg:L.arg,pthread_ptr:L.pthread_ptr};return q.runPthread=()=>{pe.time=performance.now(),q.postMessage(pe,L.transferList)},q.loaded&&(q.runPthread(),delete q.runPthread),0}var Qf={varargs:void 0,get:function(){Qf.varargs+=4;var L=s()[Qf.varargs-4>>2];return L},getStr:function(L){var q=J(L);return q}};function $k(L){if(I)return Lu(1,1,L);ve=L,da()||(Ze.terminateAllThreads(),l.onExit&&l.onExit(L),ye=!0),g(L,new zl(L))}function Bk(L,q){if(ve=L,!q&&I)throw qg(L),"unwind";$k(L)}var Hg=Bk;function Ok(L){if(L instanceof zl||L=="unwind")return ve;g(1,L)}var Ze={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){I?Ze.initWorker():Ze.initMainThread()},initMainThread:function(){for(var L=8;L--;)Ze.allocateUnusedWorker()},initWorker:function(){se=!1},setExitStatus:function(L){ve=L},terminateAllThreads:function(){for(var L of Object.values(Ze.pthreads))Ze.returnWorkerToPool(L);for(var L of Ze.unusedWorkers)L.terminate();Ze.unusedWorkers=[]},returnWorkerToPool:function(L){var q=L.pthread_ptr;delete Ze.pthreads[q],Ze.unusedWorkers.push(L),Ze.runningWorkers.splice(Ze.runningWorkers.indexOf(L),1),L.pthread_ptr=0,dv(q)},receiveObjectTransfer:function(L){},threadInitTLS:function(){Ze.tlsInitFunctions.forEach(L=>L())},loadWasmModuleToWorker:function(L,q){L.onmessage=pe=>{var ke=pe.data,Be=ke.cmd;if(L.pthread_ptr&&(Ze.currentProxiedOperationCallerThread=L.pthread_ptr),ke.targetThread&&ke.targetThread!=ib()){var mt=Ze.pthreads[ke.targetThread];mt?mt.postMessage(ke,ke.transferList):Y('Internal error! Worker sent a message "'+Be+'" to target pthread '+ke.targetThread+", but that thread no longer exists!"),Ze.currentProxiedOperationCallerThread=void 0;return}Be==="processProxyingQueue"?eh(ke.queue):Be==="spawnThread"?Vg(ke):Be==="cleanupThread"?Kg(ke.thread):Be==="killThread"?Lk(ke.thread):Be==="cancelThread"?Ug(ke.thread):Be==="loaded"?(L.loaded=!0,q&&q(L),L.runPthread&&(L.runPthread(),delete L.runPthread)):Be==="print"?V("Thread "+ke.threadId+": "+ke.text):Be==="printErr"?Y("Thread "+ke.threadId+": "+ke.text):Be==="alert"?alert("Thread "+ke.threadId+": "+ke.text):ke.target==="setimmediate"?L.postMessage(ke):Be==="onAbort"?l.onAbort&&l.onAbort(ke.arg):Be&&Y("worker sent an unknown command "+Be),Ze.currentProxiedOperationCallerThread=void 0},L.onerror=pe=>{var ke="worker sent an error!";throw Y(ke+" "+pe.filename+":"+pe.lineno+": "+pe.message),pe},x&&(L.on("message",function(pe){L.onmessage({data:pe})}),L.on("error",function(pe){L.onerror(pe)}),L.on("detachedExit",function(){})),L.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:ie,wasmModule:he})},allocateUnusedWorker:function(){var L=w("tfjs-backend-wasm-threaded-simd.worker.js");Ze.unusedWorkers.push(new Worker(L))},getNewWorker:function(){return Ze.unusedWorkers.length==0&&(Ze.allocateUnusedWorker(),Ze.loadWasmModuleToWorker(Ze.unusedWorkers[0])),Ze.unusedWorkers.pop()}};l.PThread=Ze;function Jf(L){for(;L.length>0;)L.shift()(l)}function zk(L){var q=fv(),pe=L();return ub(q),pe}function R0(L){return L}function P0(L){var q=/\b_Z[\w\d_]+/g;return L.replace(q,function(pe){var ke=pe;return pe===ke?pe:ke+" ["+pe+"]"})}function Gk(){var L=ib(),q=s()[L+44>>2],pe=s()[L+48>>2],ke=q-pe;z0(q,ke),ub(q)}l.establishStackSpace=Gk;function qg(L){if(I)return Lu(2,0,L);try{Hg(L)}catch(q){Ok(q)}}var dm=[];function Wk(L){var q=dm[L];return q||(L>=dm.length&&(dm.length=L+1),dm[L]=q=Kr.get(L)),q}function Uk(L,q){var pe=Wk(L)(q);da()?Ze.setExitStatus(pe):O0(pe)}l.invokeEntryPoint=Uk;function E0(){var L=new Error;if(!L.stack){try{throw new Error}catch(q){L=q}if(!L.stack)return"(no stack trace available)"}return L.stack.toString()}function Kk(L){Ze.tlsInitFunctions.push(L)}function Vk(L,q){t().set(L,q)}function Hk(L){L0(L,!T,1,!b),Ze.threadInitTLS()}function qk(L){I?postMessage({cmd:"cleanupThread",thread:L}):Kg(L)}function jg(L,q,pe,ke){return I?Lu(3,1,L,q,pe,ke):Xg(L,q,pe,ke)}function Xg(L,q,pe,ke){if(typeof SharedArrayBuffer>"u")return Y("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Be=[],mt=0;if(I&&(Be.length===0||mt))return jg(L,q,pe,ke);if(mt)return mt;var Xe={startRoutine:pe,pthread_ptr:L,arg:ke,transferList:Be};return I?(Xe.cmd="spawnThread",postMessage(Xe,Be),0):Vg(Xe)}function jk(){return 2097152}var Xk=!0;function Yk(){return Xk}function eh(L){Atomics.store(s(),L>>2,1),ib()&&B0(L),Atomics.compareExchange(s(),L>>2,1,0)}l.executeNotifiedProxyingQueue=eh;function Zk(L,q,pe,ke){if(L==q)setTimeout(()=>eh(ke));else if(I)postMessage({targetThread:L,cmd:"processProxyingQueue",queue:ke});else{var Be=Ze.pthreads[L];if(!Be)return;Be.postMessage({cmd:"processProxyingQueue",queue:ke})}return 1}function Qk(L,q,pe){return-1}function Jk(){cm("")}function Gl(L){Gl.shown||(Gl.shown={}),Gl.shown[L]||(Gl.shown[L]=1,x&&(L="warning: "+L),Y(L))}function eS(){x||T||Gl("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function tS(){return Date.now()}function Yg(){return 2147483648}function rS(){return Yg()}var fm;x?fm=()=>{var L=process.hrtime();return L[0]*1e3+L[1]/1e6}:I?fm=()=>performance.now()-l.__performance_now_clock_drift:fm=()=>performance.now();function nS(L,q,pe){n().copyWithin(L,q,q+pe)}function oS(){return x?vj().cpus().length:navigator.hardwareConcurrency}function Lu(L,q){var pe=arguments.length-2,ke=arguments;return zk(()=>{for(var Be=pe,mt=lb(Be*8),Xe=mt>>3,et=0;et<pe;et++){var kr=ke[2+et];u()[Xe+et]=kr}return $0(L,Be,mt,q)})}var th=[];function sS(L,q,pe){th.length=q;for(var ke=pe>>3,Be=0;Be<q;Be++)th[Be]=u()[ke+Be];var mt=L<0,Xe=mt?Fk[-L-1]:dS[L];return Xe.apply(null,th)}function aS(L){try{return ie.grow(L-Je.byteLength+65535>>>16),rr(ie.buffer),1}catch{}}function iS(L){var q=n().length;if(L=L>>>0,L<=q)return!1;var pe=Yg();if(L>pe)return!1;let ke=(kr,lo)=>kr+(lo-kr%lo)%lo;for(var Be=1;Be<=4;Be*=2){var mt=q*(1+.2/Be);mt=Math.min(mt,L+100663296);var Xe=Math.min(pe,ke(Math.max(L,mt),65536)),et=aS(Xe);if(et)return!0}return!1}function uS(){throw"unwind"}function Zg(L){return I?Lu(4,1,L):52}function Qg(L,q,pe,ke,Be){return I?Lu(5,1,L,q,pe,ke,Be):70}var lS=[null,[],[]];function pS(L,q){var pe=lS[L];q===0||q===10?((L===1?V:Y)(je(pe,0)),pe.length=0):pe.push(q)}function Jg(L,q,pe,ke){if(I)return Lu(6,1,L,q,pe,ke);for(var Be=0,mt=0;mt<pe;mt++){var Xe=a()[q>>2],et=a()[q+4>>2];q+=8;for(var kr=0;kr<et;kr++)pS(L,n()[Xe+kr]);Be+=et}return a()[ke>>2]=Be,0}function eb(L){var q=l["_"+L];return q}function mS(L,q,pe,ke,Be){var mt={string:zn=>{var ym=0;if(zn!=null&&zn!==0){var U0=(zn.length<<2)+1;ym=lb(U0),St(zn,ym,U0)}return ym},array:zn=>{var ym=lb(zn.length);return Vk(zn,ym),ym}};function Xe(zn){return q==="string"?J(zn):q==="boolean"?Boolean(zn):zn}var et=eb(L),kr=[],lo=0;if(ke)for(var Yi=0;Yi<ke.length;Yi++){var W0=mt[pe[Yi]];W0?(lo===0&&(lo=fv()),kr[Yi]=W0(ke[Yi])):kr[Yi]=ke[Yi]}var hv=et.apply(null,kr);function c6(zn){return lo!==0&&ub(lo),Xe(zn)}return hv=c6(hv),hv}function cS(L,q,pe,ke){pe=pe||[];var Be=pe.every(Xe=>Xe==="number"||Xe==="boolean"),mt=q!=="string";return mt&&Be&&!ke?eb(L):function(){return mS(L,q,pe,arguments,ke)}}Ze.init();var dS=[null,$k,qg,jg,Zg,Qg,Jg],tb={__emscripten_init_main_thread_js:Hk,__emscripten_thread_cleanup:qk,__pthread_create_js:Xg,_emscripten_default_pthread_stack_size:jk,_emscripten_get_now_is_monotonic:Yk,_emscripten_notify_task_queue:Zk,_emscripten_set_offscreencanvas_size:Qk,abort:Jk,emscripten_check_blocking_allowed:eS,emscripten_date_now:tS,emscripten_get_heap_max:rS,emscripten_get_now:fm,emscripten_memcpy_big:nS,emscripten_num_logical_cores:oS,emscripten_receive_on_main_thread_js:sS,emscripten_resize_heap:iS,emscripten_unwind_to_js_event_loop:uS,exit:Hg,fd_close:Zg,fd_seek:Qg,fd_write:Jg,memory:ie||l.wasmMemory},F0=Wg(),fS=l.___wasm_call_ctors=function(){return(fS=l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},hS=l._init=function(){return(hS=l._init=l.asm.init).apply(null,arguments)},gS=l._init_with_threads_count=function(){return(gS=l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},bS=l._get_threads_count=function(){return(bS=l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},yS=l._register_tensor=function(){return(yS=l._register_tensor=l.asm.register_tensor).apply(null,arguments)},TS=l._dispose_data=function(){return(TS=l._dispose_data=l.asm.dispose_data).apply(null,arguments)},xS=l._dispose=function(){return(xS=l._dispose=l.asm.dispose).apply(null,arguments)},IS=l._Abs=function(){return(IS=l._Abs=l.asm.Abs).apply(null,arguments)},CS=l._Add=function(){return(CS=l._Add=l.asm.Add).apply(null,arguments)},kS=l._AddN=function(){return(kS=l._AddN=l.asm.AddN).apply(null,arguments)},SS=l._All=function(){return(SS=l._All=l.asm.All).apply(null,arguments)},vS=l._Any=function(){return(vS=l._Any=l.asm.Any).apply(null,arguments)},AS=l._ArgMax=function(){return(AS=l._ArgMax=l.asm.ArgMax).apply(null,arguments)},wS=l._AvgPool=function(){return(wS=l._AvgPool=l.asm.AvgPool).apply(null,arguments)},NS=l._BatchMatMul=function(){return(NS=l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},DS=l._Ceil=function(){return(DS=l._Ceil=l.asm.Ceil).apply(null,arguments)},_S=l._ClipByValue=function(){return(_S=l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},MS=l._Conv2D=function(){return(MS=l._Conv2D=l.asm.Conv2D).apply(null,arguments)},RS=l._Conv2DBackpropInput=function(){return(RS=l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},PS=l._Cos=function(){return(PS=l._Cos=l.asm.Cos).apply(null,arguments)},ES=l._Cosh=function(){return(ES=l._Cosh=l.asm.Cosh).apply(null,arguments)},FS=l._CropAndResize=function(){return(FS=l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},LS=l._Cumprod=function(){return(LS=l._Cumprod=l.asm.Cumprod).apply(null,arguments)},$S=l._Cumsum=function(){return($S=l._Cumsum=l.asm.Cumsum).apply(null,arguments)},BS=l._DepthToSpace=function(){return(BS=l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},OS=l._DepthwiseConv2dNative=function(){return(OS=l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},zS=l._Elu=function(){return(zS=l._Elu=l.asm.Elu).apply(null,arguments)},GS=l._Equal=function(){return(GS=l._Equal=l.asm.Equal).apply(null,arguments)},WS=l._Exp=function(){return(WS=l._Exp=l.asm.Exp).apply(null,arguments)},US=l._FlipLeftRight=function(){return(US=l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},KS=l._Floor=function(){return(KS=l._Floor=l.asm.Floor).apply(null,arguments)},VS=l._FloorDiv=function(){return(VS=l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},HS=l._FusedBatchNorm=function(){return(HS=l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},qS=l._FusedConv2D=function(){return(qS=l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},jS=l._FusedDepthwiseConv2D=function(){return(jS=l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},XS=l._Gather=function(){return(XS=l._Gather=l.asm.Gather).apply(null,arguments)},YS=l._GatherNd=function(){return(YS=l._GatherNd=l.asm.GatherNd).apply(null,arguments)},ZS=l._Greater=function(){return(ZS=l._Greater=l.asm.Greater).apply(null,arguments)},QS=l._GreaterEqual=function(){return(QS=l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},JS=l._IsNan=function(){return(JS=l._IsNan=l.asm.IsNan).apply(null,arguments)},ev=l._LeakyRelu=function(){return(ev=l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},tv=l._Less=function(){return(tv=l._Less=l.asm.Less).apply(null,arguments)},rv=l._LessEqual=function(){return(rv=l._LessEqual=l.asm.LessEqual).apply(null,arguments)},nv=l._Log=function(){return(nv=l._Log=l.asm.Log).apply(null,arguments)},ov=l._LogicalAnd=function(){return(ov=l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},sv=l._LogicalNot=function(){return(sv=l._LogicalNot=l.asm.LogicalNot).apply(null,arguments)},av=l._LogicalOr=function(){return(av=l._LogicalOr=l.asm.LogicalOr).apply(null,arguments)},iv=l._LogicalXor=function(){return(iv=l._LogicalXor=l.asm.LogicalXor).apply(null,arguments)},uv=l._Max=function(){return(uv=l._Max=l.asm.Max).apply(null,arguments)},rb=l._MaxPool=function(){return(rb=l._MaxPool=l.asm.MaxPool).apply(null,arguments)},nb=l._Maximum=function(){return(nb=l._Maximum=l.asm.Maximum).apply(null,arguments)},rh=l._Mean=function(){return(rh=l._Mean=l.asm.Mean).apply(null,arguments)},lv=l._Min=function(){return(lv=l._Min=l.asm.Min).apply(null,arguments)},pv=l._Minimum=function(){return(pv=l._Minimum=l.asm.Minimum).apply(null,arguments)},hm=l._MirrorPad=function(){return(hm=l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},ob=l._Multiply=function(){return(ob=l._Multiply=l.asm.Multiply).apply(null,arguments)},gm=l._Neg=function(){return(gm=l._Neg=l.asm.Neg).apply(null,arguments)},bm=l._NonMaxSuppressionV3=function(){return(bm=l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},mv=l._NonMaxSuppressionV4=function(){return(mv=l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},X=l._NonMaxSuppressionV5=function(){return(X=l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},le=l._NotEqual=function(){return(le=l._NotEqual=l.asm.NotEqual).apply(null,arguments)},Le=l._OneHot=function(){return(Le=l._OneHot=l.asm.OneHot).apply(null,arguments)},ut=l._PadV2=function(){return(ut=l._PadV2=l.asm.PadV2).apply(null,arguments)},nr=l._Pow=function(){return(nr=l._Pow=l.asm.Pow).apply(null,arguments)},or=l._Prelu=function(){return(or=l._Prelu=l.asm.Prelu).apply(null,arguments)},it=l._Prod=function(){return(it=l._Prod=l.asm.Prod).apply(null,arguments)},at=l._RealDiv=function(){return(at=l._RealDiv=l.asm.RealDiv).apply(null,arguments)},Cr=l._Reciprocal=function(){return(Cr=l._Reciprocal=l.asm.Reciprocal).apply(null,arguments)},uo=l._Relu=function(){return(uo=l._Relu=l.asm.Relu).apply(null,arguments)},Xi=l._Relu6=function(){return(Xi=l._Relu6=l.asm.Relu6).apply(null,arguments)},sb=l._ResizeBilinear=function(){return(sb=l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},nh=l._ResizeNearestNeighbor=function(){return(nh=l._ResizeNearestNeighbor=l.asm.ResizeNearestNeighbor).apply(null,arguments)},cv=l._Reverse=function(){return(cv=l._Reverse=l.asm.Reverse).apply(null,arguments)},dn=l._RotateWithOffset=function(){return(dn=l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},$u=l._Round=function(){return($u=l._Round=l.asm.Round).apply(null,arguments)},ab=l._Rsqrt=function(){return(ab=l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},Pj=l._ScatterNd=function(){return(Pj=l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},Ej=l._SelectV2=function(){return(Ej=l._SelectV2=l.asm.SelectV2).apply(null,arguments)},Fj=l._Sigmoid=function(){return(Fj=l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},Lj=l._Sin=function(){return(Lj=l._Sin=l.asm.Sin).apply(null,arguments)},$j=l._Softmax=function(){return($j=l._Softmax=l.asm.Softmax).apply(null,arguments)},Bj=l._SparseFillEmptyRows=function(){return(Bj=l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},Oj=l._SparseReshape=function(){return(Oj=l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},zj=l._SparseSegmentReduction=function(){return(zj=l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},Gj=l._Sqrt=function(){return(Gj=l._Sqrt=l.asm.Sqrt).apply(null,arguments)},Wj=l._Square=function(){return(Wj=l._Square=l.asm.Square).apply(null,arguments)},Uj=l._SquaredDifference=function(){return(Uj=l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},Kj=l._Step=function(){return(Kj=l._Step=l.asm.Step).apply(null,arguments)},Vj=l._StridedSlice=function(){return(Vj=l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},Hj=l._Sub=function(){return(Hj=l._Sub=l.asm.Sub).apply(null,arguments)},qj=l._Sum=function(){return(qj=l._Sum=l.asm.Sum).apply(null,arguments)},jj=l._Tan=function(){return(jj=l._Tan=l.asm.Tan).apply(null,arguments)},Xj=l._Tanh=function(){return(Xj=l._Tanh=l.asm.Tanh).apply(null,arguments)},Yj=l._Tile=function(){return(Yj=l._Tile=l.asm.Tile).apply(null,arguments)},Zj=l._TopK=function(){return(Zj=l._TopK=l.asm.TopK).apply(null,arguments)},Qj=l._Transform=function(){return(Qj=l._Transform=l.asm.Transform).apply(null,arguments)},Jj=l._Transpose=function(){return(Jj=l._Transpose=l.asm.Transpose).apply(null,arguments)},e6=l.__FusedMatMul=function(){return(e6=l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},t6=l._malloc=function(){return(t6=l._malloc=l.asm.malloc).apply(null,arguments)},r6=l._free=function(){return(r6=l._free=l.asm.free).apply(null,arguments)},n6=l.__emscripten_tls_init=function(){return(n6=l.__emscripten_tls_init=l.asm._emscripten_tls_init).apply(null,arguments)},ib=l._pthread_self=function(){return(ib=l._pthread_self=l.asm.pthread_self).apply(null,arguments)},o6=l.___errno_location=function(){return(o6=l.___errno_location=l.asm.__errno_location).apply(null,arguments)},L0=l.__emscripten_thread_init=function(){return(L0=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)},s6=l.__emscripten_thread_crashed=function(){return(s6=l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},a6=l._emscripten_main_thread_process_queued_calls=function(){return(a6=l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},i6=l._emscripten_main_browser_thread_id=function(){return(i6=l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)},$0=l._emscripten_run_in_main_runtime_thread_js=function(){return($0=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},u6=l._emscripten_dispatch_to_thread_=function(){return(u6=l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},B0=l.__emscripten_proxy_execute_task_queue=function(){return(B0=l.__emscripten_proxy_execute_task_queue=l.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},dv=l.__emscripten_thread_free_data=function(){return(dv=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},O0=l.__emscripten_thread_exit=function(){return(O0=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},z0=l._emscripten_stack_set_limits=function(){return(z0=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},fv=l.stackSave=function(){return(fv=l.stackSave=l.asm.stackSave).apply(null,arguments)},ub=l.stackRestore=function(){return(ub=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},lb=l.stackAlloc=function(){return(lb=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)},l6=l.dynCall_iijjiiii=function(){return(l6=l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},p6=l.dynCall_jiji=function(){return(p6=l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)};l.keepRuntimeAlive=da,l.wasmMemory=ie,l.cwrap=cS,l.ExitStatus=zl,l.PThread=Ze;var pb;ji=function L(){pb||G0(),pb||(ji=L)};function G0(L){if(L=L||f,Fu>0)return;if(I){p(l),Lr(),postMessage({cmd:"loaded"});return}if(Eu(),Fu>0)return;function q(){pb||(pb=!0,l.calledRun=!0,!ye&&(Lr(),p(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),qi()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),q()},1)):q()}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();G0();var mb;c&&(mb={uncaughtException:process.listeners("uncaughtException").filter(function(L){return!c.uncaughtException.indexOf(L)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(L){return!c.unhandledRejection.indexOf(L)>-1})});var cb;if(typeof WasmBackendModule<"u")cb=WasmBackendModule;else if(typeof e<"u")cb=e;else throw new Error("Could not find wasm module in post.js");if(mb){var m6=cb._dispose;cb._dispose=function(){m6(),mb.uncaughtException.forEach(function(L){process.removeListener("uncaughtException",L)}),mb.unhandledRejection.forEach(function(L){process.removeListener("unhandledRejection",L)})}}return e.ready}})();typeof _k=="object"&&typeof x0=="object"?x0.exports=T0:typeof define=="function"&&define.amd?define([],function(){return T0}):typeof _k=="object"&&(_k.WasmBackendModuleThreadedSimd=T0)});var Nj=Nr((Mk,C0)=>{"use strict";var I0=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e){e=e||{};var t=typeof e<"u"?e:{},n,o;t.ready=new Promise(function(X,le){n=X,o=le});var s;typeof process<"u"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var a=Object.assign({},t),i=[],u="./this.program",l=(X,le)=>{throw le},p=typeof window=="object",m=typeof importScripts=="function",c=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",d="";function f(X){return t.locateFile?t.locateFile(X,d):d+X}var h,g,b,T;function x(X){if(X instanceof mm)return;_("exiting due to exception: "+X)}if(c){m?d=Eg().dirname(d)+"/":d=__dirname+"/";var I,k;typeof fb=="function"&&(I=yx(),k=Eg()),h=(X,le)=>(X=k.normalize(X),I.readFileSync(X,le?void 0:"utf8")),b=X=>{var le=h(X,!0);return le.buffer||(le=new Uint8Array(le)),le},g=(X,le,Le)=>{X=k.normalize(X),I.readFile(X,function(ut,nr){ut?Le(ut):le(nr.buffer)})},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),i=process.argv.slice(2),process.on("uncaughtException",function(X){if(!(X instanceof mm))throw X}),process.on("unhandledRejection",function(X){throw X}),l=(X,le)=>{if(Tt())throw process.exitCode=X,le;x(le),process.exit(X)},t.inspect=function(){return"[Emscripten Module object]"}}else(p||m)&&(m?d=self.location.href:typeof document<"u"&&document.currentScript&&(d=document.currentScript.src),r&&(d=r),d.indexOf("blob:")!==0?d=d.substr(0,d.replace(/[?#].*/,"").lastIndexOf("/")+1):d="",h=X=>{var le=new XMLHttpRequest;return le.open("GET",X,!1),le.send(null),le.responseText},m&&(b=X=>{var le=new XMLHttpRequest;return le.open("GET",X,!1),le.responseType="arraybuffer",le.send(null),new Uint8Array(le.response)}),g=(X,le,Le)=>{var ut=new XMLHttpRequest;ut.open("GET",X,!0),ut.responseType="arraybuffer",ut.onload=()=>{if(ut.status==200||ut.status==0&&ut.response){le(ut.response);return}Le()},ut.onerror=Le,ut.send(null)},T=X=>document.title=X);var w=t.print||console.log.bind(console),_=t.printErr||console.warn.bind(console);Object.assign(t,a),a=null,t.arguments&&(i=t.arguments),t.thisProgram&&(u=t.thisProgram),t.quit&&(l=t.quit);var M=4,R;t.wasmBinary&&(R=t.wasmBinary);var E=t.noExitRuntime||!0;typeof WebAssembly!="object"&&tn("no native wasm support detected");var O,G=!1,W;function H(X,le){X||tn(le)}var U=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function V(X,le,Le){for(var ut=le+Le,nr=le;X[nr]&&!(nr>=ut);)++nr;if(nr-le>16&&X.buffer&&U)return U.decode(X.subarray(le,nr));for(var or="";le<nr;){var it=X[le++];if(!(it&128)){or+=String.fromCharCode(it);continue}var at=X[le++]&63;if((it&224)==192){or+=String.fromCharCode((it&31)<<6|at);continue}var Cr=X[le++]&63;if((it&240)==224?it=(it&15)<<12|at<<6|Cr:it=(it&7)<<18|at<<12|Cr<<6|X[le++]&63,it<65536)or+=String.fromCharCode(it);else{var uo=it-65536;or+=String.fromCharCode(55296|uo>>10,56320|uo&1023)}}return or}function Y(X,le){return X?V(ae,X,le):""}function j(X,le,Le,ut){if(!(ut>0))return 0;for(var nr=Le,or=Le+ut-1,it=0;it<X.length;++it){var at=X.charCodeAt(it);if(at>=55296&&at<=57343){var Cr=X.charCodeAt(++it);at=65536+((at&1023)<<10)|Cr&1023}if(at<=127){if(Le>=or)break;le[Le++]=at}else if(at<=2047){if(Le+1>=or)break;le[Le++]=192|at>>6,le[Le++]=128|at&63}else if(at<=65535){if(Le+2>=or)break;le[Le++]=224|at>>12,le[Le++]=128|at>>6&63,le[Le++]=128|at&63}else{if(Le+3>=or)break;le[Le++]=240|at>>18,le[Le++]=128|at>>12&63,le[Le++]=128|at>>6&63,le[Le++]=128|at&63}}return le[Le]=0,Le-nr}function te(X,le,Le){return j(X,ae,le,Le)}var ne,oe,ae,se,ie,he,ye,ve,Fe;function $e(X){ne=X,t.HEAP8=oe=new Int8Array(X),t.HEAP16=se=new Int16Array(X),t.HEAP32=he=new Int32Array(X),t.HEAPU8=ae=new Uint8Array(X),t.HEAPU16=ie=new Uint16Array(X),t.HEAPU32=ye=new Uint32Array(X),t.HEAPF32=ve=new Float32Array(X),t.HEAPF64=Fe=new Float64Array(X)}var je=t.INITIAL_MEMORY||16777216,J,gt=[],St=[],Je=[],Rt=!1;function Tt(){return E}function $t(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)dr(t.preRun.shift());ji(gt)}function Xt(){Rt=!0,ji(St)}function On(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)Wr(t.postRun.shift());ji(Je)}function dr(X){gt.unshift(X)}function so(X){St.unshift(X)}function Wr(X){Je.unshift(X)}var rr=0,Ur=null,Kr=null;function ao(X){rr++,t.monitorRunDependencies&&t.monitorRunDependencies(rr)}function io(X){if(rr--,t.monitorRunDependencies&&t.monitorRunDependencies(rr),rr==0&&(Ur!==null&&(clearInterval(Ur),Ur=null),Kr)){var le=Kr;Kr=null,le()}}function tn(X){t.onAbort&&t.onAbort(X),X="Aborted("+X+")",_(X),G=!0,W=1,X+=". Build with -sASSERTIONS for more info.";var le=new WebAssembly.RuntimeError(X);throw o(le),le}var Hi="data:application/octet-stream;base64,";function da(X){return X.startsWith(Hi)}function Eu(X){return X.startsWith("file://")}var Lr;Lr="tfjs-backend-wasm.wasm",da(Lr)||(Lr=f(Lr));function qi(X){try{if(X==Lr&&R)return new Uint8Array(R);if(b)return b(X);throw"both async and sync fetching of the wasm failed"}catch(le){tn(le)}}function Yf(){if(!R&&(p||m)){if(typeof fetch=="function"&&!Eu(Lr))return fetch(Lr,{credentials:"same-origin"}).then(function(X){if(!X.ok)throw"failed to load wasm binary file at '"+Lr+"'";return X.arrayBuffer()}).catch(function(){return qi(Lr)});if(g)return new Promise(function(X,le){g(Lr,function(Le){X(new Uint8Array(Le))},le)})}return Promise.resolve().then(function(){return qi(Lr)})}function Zf(){var X={env:Qf,wasi_snapshot_preview1:Qf};function le(it,at){var Cr=it.exports;t.asm=Cr,O=t.asm.memory,$e(O.buffer),J=t.asm.__indirect_function_table,so(t.asm.__wasm_call_ctors),io("wasm-instantiate")}ao("wasm-instantiate");function Le(it){le(it.instance)}function ut(it){return Yf().then(function(at){return WebAssembly.instantiate(at,X)}).then(function(at){return at}).then(it,function(at){_("failed to asynchronously prepare wasm: "+at),tn(at)})}function nr(){return!R&&typeof WebAssembly.instantiateStreaming=="function"&&!da(Lr)&&!Eu(Lr)&&!c&&typeof fetch=="function"?fetch(Lr,{credentials:"same-origin"}).then(function(it){var at=WebAssembly.instantiateStreaming(it,X);return at.then(Le,function(Cr){return _("wasm streaming compile failed: "+Cr),_("falling back to ArrayBuffer instantiation"),ut(Le)})}):ut(Le)}if(t.instantiateWasm)try{var or=t.instantiateWasm(X,le);return or}catch(it){_("Module.instantiateWasm callback failed with error: "+it),o(it)}return nr().catch(o),{}}var w0,Fu;function mm(X){this.name="ExitStatus",this.message="Program terminated with exit("+X+")",this.status=X}function ji(X){for(;X.length>0;)X.shift()(t)}function N0(X){return X}function D0(X){var le=/\b_Z[\w\d_]+/g;return X.replace(le,function(Le){var ut=Le;return Le===ut?Le:ut+" ["+Le+"]"})}function cm(){var X=new Error;if(!X.stack){try{throw new Error}catch(le){X=le}if(!X.stack)return"(no stack trace available)"}return X.stack.toString()}function Pk(X,le){oe.set(X,le)}function Og(){tn("")}function zg(X,le,Le){ae.copyWithin(X,le,le+Le)}function cn(){return 2147483648}function Gg(X){try{return O.grow(X-ne.byteLength+65535>>>16),$e(O.buffer),1}catch{}}function Ek(X){var le=ae.length;X=X>>>0;var Le=cn();if(X>Le)return!1;let ut=(Cr,uo)=>Cr+(uo-Cr%uo)%uo;for(var nr=1;nr<=4;nr*=2){var or=le*(1+.2/nr);or=Math.min(or,X+100663296);var it=Math.min(Le,ut(Math.max(X,or),65536)),at=Gg(it);if(at)return!0}return!1}var Wg={varargs:void 0,get:function(){Wg.varargs+=4;var X=he[Wg.varargs-4>>2];return X},getStr:function(X){var le=Y(X);return le}};function _0(X){return 52}function M0(X,le,Le,ut,nr){return 70}var Fk=[null,[],[]];function zl(X,le){var Le=Fk[X];le===0||le===10?((X===1?w:_)(V(Le,0)),Le.length=0):Le.push(le)}function Lk(X,le,Le,ut){for(var nr=0,or=0;or<Le;or++){var it=ye[le>>2],at=ye[le+4>>2];le+=8;for(var Cr=0;Cr<at;Cr++)zl(X,ae[it+Cr]);nr+=at}return ye[ut>>2]=nr,0}function Ug(X){var le=t["_"+X];return le}function Kg(X,le,Le,ut,nr){var or={string:dn=>{var $u=0;if(dn!=null&&dn!==0){var ab=(dn.length<<2)+1;$u=rh(ab),te(dn,$u,ab)}return $u},array:dn=>{var $u=rh(dn.length);return Pk(dn,$u),$u}};function it(dn){return le==="string"?Y(dn):le==="boolean"?Boolean(dn):dn}var at=Ug(X),Cr=[],uo=0;if(ut)for(var Xi=0;Xi<ut.length;Xi++){var sb=or[Le[Xi]];sb?(uo===0&&(uo=rb()),Cr[Xi]=sb(ut[Xi])):Cr[Xi]=ut[Xi]}var nh=at.apply(null,Cr);function cv(dn){return uo!==0&&nb(uo),it(dn)}return nh=cv(nh),nh}function Vg(X,le,Le,ut){Le=Le||[];var nr=Le.every(it=>it==="number"||it==="boolean"),or=le!=="string";return or&&nr&&!ut?Ug(X):function(){return Kg(X,le,Le,arguments,ut)}}var Qf={abort:Og,emscripten_memcpy_big:zg,emscripten_resize_heap:Ek,fd_close:_0,fd_seek:M0,fd_write:Lk},$k=Zf(),Bk=t.___wasm_call_ctors=function(){return(Bk=t.___wasm_call_ctors=t.asm.__wasm_call_ctors).apply(null,arguments)},Hg=t._init=function(){return(Hg=t._init=t.asm.init).apply(null,arguments)},Ok=t._init_with_threads_count=function(){return(Ok=t._init_with_threads_count=t.asm.init_with_threads_count).apply(null,arguments)},Ze=t._get_threads_count=function(){return(Ze=t._get_threads_count=t.asm.get_threads_count).apply(null,arguments)},Jf=t._register_tensor=function(){return(Jf=t._register_tensor=t.asm.register_tensor).apply(null,arguments)},zk=t._dispose_data=function(){return(zk=t._dispose_data=t.asm.dispose_data).apply(null,arguments)},R0=t._dispose=function(){return(R0=t._dispose=t.asm.dispose).apply(null,arguments)},P0=t._Abs=function(){return(P0=t._Abs=t.asm.Abs).apply(null,arguments)},Gk=t._Add=function(){return(Gk=t._Add=t.asm.Add).apply(null,arguments)},qg=t._AddN=function(){return(qg=t._AddN=t.asm.AddN).apply(null,arguments)},dm=t._All=function(){return(dm=t._All=t.asm.All).apply(null,arguments)},Wk=t._Any=function(){return(Wk=t._Any=t.asm.Any).apply(null,arguments)},Uk=t._ArgMax=function(){return(Uk=t._ArgMax=t.asm.ArgMax).apply(null,arguments)},E0=t._AvgPool=function(){return(E0=t._AvgPool=t.asm.AvgPool).apply(null,arguments)},Kk=t._BatchMatMul=function(){return(Kk=t._BatchMatMul=t.asm.BatchMatMul).apply(null,arguments)},Vk=t._Ceil=function(){return(Vk=t._Ceil=t.asm.Ceil).apply(null,arguments)},Hk=t._ClipByValue=function(){return(Hk=t._ClipByValue=t.asm.ClipByValue).apply(null,arguments)},qk=t._Conv2D=function(){return(qk=t._Conv2D=t.asm.Conv2D).apply(null,arguments)},jg=t._Conv2DBackpropInput=function(){return(jg=t._Conv2DBackpropInput=t.asm.Conv2DBackpropInput).apply(null,arguments)},Xg=t._Cos=function(){return(Xg=t._Cos=t.asm.Cos).apply(null,arguments)},jk=t._Cosh=function(){return(jk=t._Cosh=t.asm.Cosh).apply(null,arguments)},Xk=t._CropAndResize=function(){return(Xk=t._CropAndResize=t.asm.CropAndResize).apply(null,arguments)},Yk=t._Cumprod=function(){return(Yk=t._Cumprod=t.asm.Cumprod).apply(null,arguments)},eh=t._Cumsum=function(){return(eh=t._Cumsum=t.asm.Cumsum).apply(null,arguments)},Zk=t._DepthToSpace=function(){return(Zk=t._DepthToSpace=t.asm.DepthToSpace).apply(null,arguments)},Qk=t._DepthwiseConv2dNative=function(){return(Qk=t._DepthwiseConv2dNative=t.asm.DepthwiseConv2dNative).apply(null,arguments)},Jk=t._Elu=function(){return(Jk=t._Elu=t.asm.Elu).apply(null,arguments)},Gl=t._Equal=function(){return(Gl=t._Equal=t.asm.Equal).apply(null,arguments)},eS=t._Exp=function(){return(eS=t._Exp=t.asm.Exp).apply(null,arguments)},tS=t._FlipLeftRight=function(){return(tS=t._FlipLeftRight=t.asm.FlipLeftRight).apply(null,arguments)},Yg=t._Floor=function(){return(Yg=t._Floor=t.asm.Floor).apply(null,arguments)},rS=t._FloorDiv=function(){return(rS=t._FloorDiv=t.asm.FloorDiv).apply(null,arguments)},fm=t._FusedBatchNorm=function(){return(fm=t._FusedBatchNorm=t.asm.FusedBatchNorm).apply(null,arguments)},nS=t._FusedConv2D=function(){return(nS=t._FusedConv2D=t.asm.FusedConv2D).apply(null,arguments)},oS=t._FusedDepthwiseConv2D=function(){return(oS=t._FusedDepthwiseConv2D=t.asm.FusedDepthwiseConv2D).apply(null,arguments)},Lu=t._Gather=function(){return(Lu=t._Gather=t.asm.Gather).apply(null,arguments)},th=t._GatherNd=function(){return(th=t._GatherNd=t.asm.GatherNd).apply(null,arguments)},sS=t._Greater=function(){return(sS=t._Greater=t.asm.Greater).apply(null,arguments)},aS=t._GreaterEqual=function(){return(aS=t._GreaterEqual=t.asm.GreaterEqual).apply(null,arguments)},iS=t._IsNan=function(){return(iS=t._IsNan=t.asm.IsNan).apply(null,arguments)},uS=t._LeakyRelu=function(){return(uS=t._LeakyRelu=t.asm.LeakyRelu).apply(null,arguments)},Zg=t._Less=function(){return(Zg=t._Less=t.asm.Less).apply(null,arguments)},Qg=t._LessEqual=function(){return(Qg=t._LessEqual=t.asm.LessEqual).apply(null,arguments)},lS=t._Log=function(){return(lS=t._Log=t.asm.Log).apply(null,arguments)},pS=t._LogicalAnd=function(){return(pS=t._LogicalAnd=t.asm.LogicalAnd).apply(null,arguments)},Jg=t._LogicalNot=function(){return(Jg=t._LogicalNot=t.asm.LogicalNot).apply(null,arguments)},eb=t._LogicalOr=function(){return(eb=t._LogicalOr=t.asm.LogicalOr).apply(null,arguments)},mS=t._LogicalXor=function(){return(mS=t._LogicalXor=t.asm.LogicalXor).apply(null,arguments)},cS=t._Max=function(){return(cS=t._Max=t.asm.Max).apply(null,arguments)},dS=t._MaxPool=function(){return(dS=t._MaxPool=t.asm.MaxPool).apply(null,arguments)},tb=t._Maximum=function(){return(tb=t._Maximum=t.asm.Maximum).apply(null,arguments)},F0=t._Mean=function(){return(F0=t._Mean=t.asm.Mean).apply(null,arguments)},fS=t._Min=function(){return(fS=t._Min=t.asm.Min).apply(null,arguments)},hS=t._Minimum=function(){return(hS=t._Minimum=t.asm.Minimum).apply(null,arguments)},gS=t._MirrorPad=function(){return(gS=t._MirrorPad=t.asm.MirrorPad).apply(null,arguments)},bS=t._Multiply=function(){return(bS=t._Multiply=t.asm.Multiply).apply(null,arguments)},yS=t._Neg=function(){return(yS=t._Neg=t.asm.Neg).apply(null,arguments)},TS=t._NonMaxSuppressionV3=function(){return(TS=t._NonMaxSuppressionV3=t.asm.NonMaxSuppressionV3).apply(null,arguments)},xS=t._NonMaxSuppressionV4=function(){return(xS=t._NonMaxSuppressionV4=t.asm.NonMaxSuppressionV4).apply(null,arguments)},IS=t._NonMaxSuppressionV5=function(){return(IS=t._NonMaxSuppressionV5=t.asm.NonMaxSuppressionV5).apply(null,arguments)},CS=t._NotEqual=function(){return(CS=t._NotEqual=t.asm.NotEqual).apply(null,arguments)},kS=t._OneHot=function(){return(kS=t._OneHot=t.asm.OneHot).apply(null,arguments)},SS=t._PadV2=function(){return(SS=t._PadV2=t.asm.PadV2).apply(null,arguments)},vS=t._Pow=function(){return(vS=t._Pow=t.asm.Pow).apply(null,arguments)},AS=t._Prelu=function(){return(AS=t._Prelu=t.asm.Prelu).apply(null,arguments)},wS=t._Prod=function(){return(wS=t._Prod=t.asm.Prod).apply(null,arguments)},NS=t._RealDiv=function(){return(NS=t._RealDiv=t.asm.RealDiv).apply(null,arguments)},DS=t._Reciprocal=function(){return(DS=t._Reciprocal=t.asm.Reciprocal).apply(null,arguments)},_S=t._Relu=function(){return(_S=t._Relu=t.asm.Relu).apply(null,arguments)},MS=t._Relu6=function(){return(MS=t._Relu6=t.asm.Relu6).apply(null,arguments)},RS=t._ResizeBilinear=function(){return(RS=t._ResizeBilinear=t.asm.ResizeBilinear).apply(null,arguments)},PS=t._ResizeNearestNeighbor=function(){return(PS=t._ResizeNearestNeighbor=t.asm.ResizeNearestNeighbor).apply(null,arguments)},ES=t._Reverse=function(){return(ES=t._Reverse=t.asm.Reverse).apply(null,arguments)},FS=t._RotateWithOffset=function(){return(FS=t._RotateWithOffset=t.asm.RotateWithOffset).apply(null,arguments)},LS=t._Round=function(){return(LS=t._Round=t.asm.Round).apply(null,arguments)},$S=t._Rsqrt=function(){return($S=t._Rsqrt=t.asm.Rsqrt).apply(null,arguments)},BS=t._ScatterNd=function(){return(BS=t._ScatterNd=t.asm.ScatterNd).apply(null,arguments)},OS=t._SelectV2=function(){return(OS=t._SelectV2=t.asm.SelectV2).apply(null,arguments)},zS=t._Sigmoid=function(){return(zS=t._Sigmoid=t.asm.Sigmoid).apply(null,arguments)},GS=t._Sin=function(){return(GS=t._Sin=t.asm.Sin).apply(null,arguments)},WS=t._Softmax=function(){return(WS=t._Softmax=t.asm.Softmax).apply(null,arguments)},US=t._SparseFillEmptyRows=function(){return(US=t._SparseFillEmptyRows=t.asm.SparseFillEmptyRows).apply(null,arguments)},KS=t._SparseReshape=function(){return(KS=t._SparseReshape=t.asm.SparseReshape).apply(null,arguments)},VS=t._SparseSegmentReduction=function(){return(VS=t._SparseSegmentReduction=t.asm.SparseSegmentReduction).apply(null,arguments)},HS=t._Sqrt=function(){return(HS=t._Sqrt=t.asm.Sqrt).apply(null,arguments)},qS=t._Square=function(){return(qS=t._Square=t.asm.Square).apply(null,arguments)},jS=t._SquaredDifference=function(){return(jS=t._SquaredDifference=t.asm.SquaredDifference).apply(null,arguments)},XS=t._Step=function(){return(XS=t._Step=t.asm.Step).apply(null,arguments)},YS=t._StridedSlice=function(){return(YS=t._StridedSlice=t.asm.StridedSlice).apply(null,arguments)},ZS=t._Sub=function(){return(ZS=t._Sub=t.asm.Sub).apply(null,arguments)},QS=t._Sum=function(){return(QS=t._Sum=t.asm.Sum).apply(null,arguments)},JS=t._Tan=function(){return(JS=t._Tan=t.asm.Tan).apply(null,arguments)},ev=t._Tanh=function(){return(ev=t._Tanh=t.asm.Tanh).apply(null,arguments)},tv=t._Tile=function(){return(tv=t._Tile=t.asm.Tile).apply(null,arguments)},rv=t._TopK=function(){return(rv=t._TopK=t.asm.TopK).apply(null,arguments)},nv=t._Transform=function(){return(nv=t._Transform=t.asm.Transform).apply(null,arguments)},ov=t._Transpose=function(){return(ov=t._Transpose=t.asm.Transpose).apply(null,arguments)},sv=t.__FusedMatMul=function(){return(sv=t.__FusedMatMul=t.asm._FusedMatMul).apply(null,arguments)},av=t._malloc=function(){return(av=t._malloc=t.asm.malloc).apply(null,arguments)},iv=t._free=function(){return(iv=t._free=t.asm.free).apply(null,arguments)},uv=t.___errno_location=function(){return(uv=t.___errno_location=t.asm.__errno_location).apply(null,arguments)},rb=t.stackSave=function(){return(rb=t.stackSave=t.asm.stackSave).apply(null,arguments)},nb=t.stackRestore=function(){return(nb=t.stackRestore=t.asm.stackRestore).apply(null,arguments)},rh=t.stackAlloc=function(){return(rh=t.stackAlloc=t.asm.stackAlloc).apply(null,arguments)},lv=t.dynCall_iijjiiii=function(){return(lv=t.dynCall_iijjiiii=t.asm.dynCall_iijjiiii).apply(null,arguments)},pv=t.dynCall_jiji=function(){return(pv=t.dynCall_jiji=t.asm.dynCall_jiji).apply(null,arguments)};t.cwrap=Vg;var hm;Kr=function X(){hm||ob(),hm||(Kr=X)};function ob(X){if(X=X||i,rr>0||($t(),rr>0))return;function le(){hm||(hm=!0,t.calledRun=!0,!G&&(Xt(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),On()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),le()},1)):le()}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();ob();var gm;s&&(gm={uncaughtException:process.listeners("uncaughtException").filter(function(X){return!s.uncaughtException.indexOf(X)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(X){return!s.unhandledRejection.indexOf(X)>-1})});var bm;if(typeof e<"u")bm=e;else if(typeof WasmBackendModuleThreadedSimd<"u")bm=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(gm){var mv=bm._dispose;bm._dispose=function(){mv(),gm.uncaughtException.forEach(function(X){process.removeListener("uncaughtException",X)}),gm.unhandledRejection.forEach(function(X){process.removeListener("unhandledRejection",X)})}}return e.ready}})();typeof Mk=="object"&&typeof C0=="object"?C0.exports=I0:typeof define=="function"&&define.amd?define([],function(){return I0}):typeof Mk=="object"&&(Mk.WasmBackendModule=I0)});var x6=1e-7,I6=1e-4,fa=class{constructor(e,t){this.backend=e;this.dataMover=t}data=new WeakMap;dataIdsCount=0;get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},po=class{refCount(e){return Gn("refCount")}incRef(e){return Gn("incRef")}timerAvailable(){return!0}time(e){return Gn("time")}read(e){return Gn("read")}readSync(e){return Gn("readSync")}readToGPU(e,t){return Gn("readToGPU")}numDataIds(){return Gn("numDataIds")}disposeData(e,t){return Gn("disposeData")}write(e,t,n){return Gn("write")}move(e,t,n,o,s){return Gn("move")}createTensorFromTexture(e,t,n){return Gn("createTensorFromTexture")}memory(){return Gn("memory")}floatPrecision(){return Gn("floatPrecision")}epsilon(){return this.floatPrecision()===32?x6:I6}dispose(){return Gn("dispose")}};function Gn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function K0(r){let e=r.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,hb(r,e,t)}function C6(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,hb(r,t,n),hb(e,t,n)}function Tm(r,e,t){return Math.max(r,Math.min(e,t))}function k6(r){return r%2===0?r:r+1}function hb(r,e,t){let n=r[e];r[e]=r[t],r[t]=n}function S6(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function v6(r,e){let t=Math.random();return e*t+(1-t)*r}function A6(r,e){let t=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(e[n]);t+=o*o}return t}function D(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Bt(r,e,t=""){D(Wn(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function mo(r){D(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ha(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||Sr(r)&&!t)for(let n=0;n<r.length;++n)ha(r[n],e,t);else e.push(r);return e}function nt(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function w6(r){return r.length===0}function Wn(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Zi(r){return r%1===0}function N6(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let e=Math.exp(2*r);return(e-1)/(e+1)}}function D6(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function _6(r){let e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return K0(e),e}function Kl(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function M6(r,e=o=>0,t,n){return new Promise((o,s)=>{let a=0,i=()=>{if(r()){o();return}a++;let u=e(a);if(t!=null&&a>=t){s();return}n!=null?n(i,u):setTimeout(i,u)};i()})}function R6(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=r.slice();return o[n]=e/t,o}function gr(r,e){let t=e.length;return r=r==null?e.map((n,o)=>o):[].concat(r),D(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),D(r.every(n=>Zi(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function gv(r,e){let t=[],n=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:gr(e,r).sort(),a=0;for(let i=0;i<r.length;++i){if(s!=null){if(s[a]===i&&r[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${r[i]}' is not 1`);(s[a]==null||s[a]>i)&&r[i]===1&&(t.push(r[i]),n.push(i)),s[a]<=i&&a++}r[i]!==1&&(t.push(r[i]),n.push(i))}return{newShape:t,keptDims:n}}function bv(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function yv(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Tv(r,e){for(let t=0;t<r.length;t++){let n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function xv(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function P6(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function Sr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function gb(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function Iv(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function ga(r){return typeof r=="string"||r instanceof String}function V0(r){return typeof r=="boolean"}function H0(r){return typeof r=="number"}function xm(r){return Array.isArray(r)?xm(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":H0(r)?"float32":ga(r)?"string":V0(r)?"bool":"float32"}function Ci(r){return!!(r&&r.constructor&&r.call&&r.apply)}function Im(r,e){for(let t=e;t<r;++t)if(r%t===0)return t;return r}function ki(r){let e=r.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function q0(r,e,t,n=!1){let o=new Array;if(e.length===1){let s=e[0]*(n?2:1);for(let a=0;a<s;a++)o[a]=t[r+a]}else{let s=e[0],a=e.slice(1),i=a.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=q0(r+u*i,a,t,n)}return o}function Ul(r,e,t=!1){if(r.length===0)return e[0];let n=r.reduce((o,s)=>o*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return q0(0,r,e,t)}function oh(r,e){let t=Cm(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function Cm(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function E6(r,e){let t=r.reduce((n,o)=>n*o,1);if(e==null||e==="float32")return Ul(r,new Float32Array(t));if(e==="int32")return Ul(r,new Int32Array(t));if(e==="bool")return Ul(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Ut(r){r.forEach(e=>{D(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function F6(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=t[o]*r[o];return n}function L6(r,e,t){if(e===0)return[];if(e===1)return[r];let n=new Array(e);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/t[o]),r-=n[o]*t[o];return n[n.length-1]=r,n}function sh(r){return r&&r.then&&typeof r.then=="function"}var j0="tfjsflags",ah=class{constructor(e){this.global=e;this.populateURLFlags()}flags={};flagRegistry={};urlFlags={};platformName;platform;getQueryParams=B6;setPlatform(e,t){this.platform!=null&&($().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let o=this.urlFlags[e];$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(sh(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);j0 in e&&e[j0].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=z6(o,s)})}};function B6(r){let e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(O6(e,n[0],n[1]),n.join("="))),e}function O6(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function z6(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function $(){return Cv}var Cv=null;function X0(r){Cv=r}var kv;function Sv(){if(kv==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");kv=r}return kv}function G6(){let r=Sv();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function ih(r,e){let t=G6();if(t.has(r))return t.get(r);{let n=e();return t.set(r,n),t.get(r)}}var Ts="Abs",ba="Acos",ya="Acosh",Nn="Add",co="AddN",Ta="All",xa="Any",fo="ArgMax",Si="ArgMin",Ia="Asin",Ca="Asinh",ka="Atan",Sa="Atanh",va="Atan2",ho="AvgPool",km="AvgPoolGrad",Bu="AvgPool3D",Sm="AvgPool3DGrad",go="BatchMatMul",xs="BatchToSpaceND",Ou="Bincount",Y0="BroadcastTo",vm="BroadcastArgs",Un="Cast",bo="Ceil",Kn="ClipByValue",zu="Complex",Gu="ComplexAbs",Is="Concat",yo="Conv2D",Am="Conv2DBackpropFilter",To="Conv2DBackpropInput",Wu="Conv3D",wm="Conv3DBackpropFilterV2",Nm="Conv3DBackpropInputV2",xo="Cos",Io="Cosh",Aa="Cumprod",Co="Cumsum",wa="CropAndResize",Uu="DenseBincount",Na="DepthToSpace",ko="DepthwiseConv2dNative",Dm="DepthwiseConv2dNativeBackpropFilter",_m="DepthwiseConv2dNativeBackpropInput",Mm="Diag",Ku="Dilation2D",uh="Dilation2DBackpropInput",lh="Dilation2DBackpropFilter",So="RealDiv",Vu="Einsum",vo="Elu",Rm="EluGrad",Da="Erf",_a="Equal",Ao="Exp",Cs="ExpandDims",Ma="Expm1",Pm="FFT",vi="Fill",Ra="FlipLeftRight",wo="Floor",No="FloorDiv",Do="FusedBatchNorm",ks="GatherV2",Pa="GatherNd",Ea="Greater",_o="GreaterEqual",Vn="Identity",Em="IFFT",Hu="Imag",Fa="IsFinite",La="IsInf",Mo="IsNan",Ro="LeakyRelu",$a="Less",Ba="LessEqual",Fm="LinSpace",Po="Log",Qi="Log1p",Oa="LogicalAnd",za="LogicalNot",Ji="LogicalOr",Z0="LogicalXor",Q0="LogSoftmax",Ebe="LowerBound",qu="LRN",Lm="LRNGrad",Eo="Max",Fo="Maximum",Lo="MaxPool",$m="MaxPoolGrad",ju="MaxPool3D",Bm="MaxPool3DGrad",Om="MaxPoolWithArgmax",$o="Mean",Bo="Min",Oo="Minimum",zo="MirrorPad",Ga="Mod",zm="Multinomial",Go="Multiply",Ss="Neg",Wa="NotEqual",Ua="NonMaxSuppressionV3",eu="NonMaxSuppressionV4",Ka="NonMaxSuppressionV5",vs="OnesLike",Wo="OneHot",As="Pack",Uo="PadV2",Fbe="Pool",Ko="Pow",Vo="Prelu",Ho="Prod",Gm="RaggedGather",Wm="RaggedRange",Um="RaggedTensorToTensor",Ai="Range",Xu="Real",qo="Reciprocal",jo="Relu",ws="Reshape",Xo="ResizeNearestNeighbor",Km="ResizeNearestNeighborGrad",Yo="ResizeBilinear",Vm="ResizeBilinearGrad",Zo="Relu6",Qo="Reverse",Va="Round",Jo="Rsqrt",Ha="ScatterNd",Hm="SearchSorted",Ns="Select",tu="Selu",Ds="Slice",es="Sin",qa="Sinh",ru="Sign",ts="Sigmoid",nu="Softplus",rs="Sqrt",ns="Sum",_s="SpaceToBatchND",Ms="SplitV",os="Softmax",Yu="SparseFillEmptyRows",ou="SparseReshape",Zu="SparseSegmentMean",Qu="SparseSegmentSum",Ju="SparseToDense",ss="SquaredDifference",wi="Square",ja="StridedSlice",Ni="StringNGrams",el="StringSplit",tl="StringToHashBucketFast",as="Sub",is="Tan",us="Tanh",Dn="Tile",Xa="TopK",Ya="Transform",_n="Transpose",qm="Unique",Rs="Unpack",rl="UnsortedSegmentSum",Lbe="UpperBound",Ps="ZerosLike",Es="Step",Vl="FromPixels",Za="RotateWithOffset",Fs="_FusedMatMul",Ls="FusedConv2D",$s="FusedDepthwiseConv2D";function Di(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(...r)}function W6(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.log(...r)}var jm=ih("kernelRegistry",()=>new Map),ph=ih("gradRegistry",()=>new Map);function mh(r,e){let t=Av(r,e);return jm.get(t)}function vv(r){return ph.get(r)}function bb(r){let e=jm.entries(),t=[];for(;;){let{done:n,value:o}=e.next();if(n)break;let[s,a]=o,[i]=s.split("_");i===r&&t.push(a)}return t}function su(r){let{kernelName:e,backendName:t}=r,n=Av(e,t);jm.has(n)&&Di(`The kernel '${e}' for backend '${t}' is already registered`),jm.set(n,r)}function e_(r){let{kernelName:e}=r;ph.has(e)&&$().getBool("DEBUG")&&Di(`Overriding the gradient for '${e}'`),ph.set(e,r)}function Gbe(r,e){let t=Av(r,e);if(!jm.has(t))throw new Error(`The kernel '${r}' for backend '${e}' is not registered`);jm.delete(t)}function Wbe(r){if(!ph.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);ph.delete(r)}function Ube(r,e){bb(r).forEach(n=>{let o=Object.assign({},n,{backendName:e});su(o)})}function Av(r,e){return`${e}_${r}`}var y={};qe(y,{arraysEqual:()=>Wn,assert:()=>D,assertNonNegativeIntegerDimensions:()=>Ut,assertNonNull:()=>mo,assertShapesMatch:()=>Bt,bytesFromStringArray:()=>Iv,bytesPerElement:()=>gb,checkConversionForErrors:()=>Tv,clamp:()=>Tm,computeStrides:()=>ki,createScalarValue:()=>X6,createShuffledIndices:()=>_6,decodeString:()=>Qm,distSquared:()=>A6,encodeString:()=>ol,fetch:()=>Z6,fingerPrint64:()=>j6,flatten:()=>ha,getArrayFromDType:()=>yv,getTypedArrayFromDType:()=>bv,hasEncodingLoss:()=>P6,hexToLong:()=>ch,indexToLoc:()=>L6,inferDtype:()=>xm,inferFromImplicitShape:()=>R6,isBoolean:()=>V0,isFunction:()=>Ci,isInt:()=>Zi,isNumber:()=>H0,isPromise:()=>sh,isScalarShape:()=>w6,isString:()=>ga,isTypedArray:()=>Sr,isValidDtype:()=>xv,locToIndex:()=>F6,makeOnesTypedArray:()=>oh,makeZerosNestedTypedArray:()=>E6,makeZerosTypedArray:()=>Cm,nearestDivisor:()=>Im,nearestLargerEven:()=>k6,now:()=>Yl,parseAxisParam:()=>gr,randUniform:()=>v6,repeatedTry:()=>M6,rightPad:()=>Kl,shuffle:()=>K0,shuffleCombo:()=>C6,sizeFromShape:()=>nt,sizeToSquarishShape:()=>D6,squeezeShape:()=>gv,sum:()=>S6,swap:()=>hb,tanh:()=>N6,toNestedArray:()=>Ul,toTypedArray:()=>Zm});var _v=Wl(m_());var Xl=_v.default||_v;function ch(r){return Xl.fromString(r,!0,16)}var d_=ch("c3a5c85c97cb3127"),jl=ch("b492b66fbe98f273"),fn=ch("9ae16a3b2f90404f");function Dv(r){return r.xor(r.shru(47))}function f_(r,e,t){let n=r.slice(e,e+t);return Xl.fromBytes(Array.from(n),!0,!0)}function Kt(r,e){return f_(r,e,8)}function c_(r,e){return f_(r,e,4)}function $r(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function nl(r,e,t=ch("9ddfea08eb382d69")){let n=r.xor(e).mul(t);n=n.xor(n.shru(47));let o=e.xor(n).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function K6(r,e,t,n,o,s){o=o.add(r),s=$r(s.add(o).add(n),21);let a=o;return o=o.add(e),o=o.add(t),s=s.add($r(o,44)),[o.add(n),s.add(a)]}function Tb(r,e,t,n){return K6(Kt(r,e),Kt(r,e+8),Kt(r,e+16),Kt(r,e+24),t,n)}function V6(r,e=r.length){if(e>=8){let t=fn.add(e*2),n=Kt(r,0).add(fn),o=Kt(r,e-8),s=$r(o,37).mul(t).add(n),a=$r(n,25).add(o).mul(t);return nl(s,a,t)}if(e>=4){let t=fn.add(e*2),n=c_(r,0);return nl(n.shl(3).add(e),c_(r,e-4),t)}if(e>0){let t=r[0],n=r[e>>1],o=r[e-1],s=t+(n<<8),a=e+(o<<2);return Dv(fn.mul(s).xor(d_.mul(a))).mul(fn)}return fn}function H6(r,e=r.length){let t=fn.add(e*2),n=Kt(r,0).mul(jl),o=Kt(r,8),s=Kt(r,e-8).mul(t),a=Kt(r,e-16).mul(fn);return nl($r(n.add(o),43).add($r(s,30)).add(a),n.add($r(o.add(fn),18)).add(s),t)}function q6(r,e=r.length){let t=fn.add(e*2),n=Kt(r,0).mul(fn),o=Kt(r,8),s=Kt(r,e-8).mul(t),a=Kt(r,e-16).mul(fn),i=$r(n.add(o),43).add($r(s,30)).add(a),u=nl(i,n.add($r(o.add(fn),18)).add(s),t),l=Kt(r,16).mul(t),p=Kt(r,24),m=i.add(Kt(r,e-32)).mul(t),c=u.add(Kt(r,e-24)).mul(t);return nl($r(l.add(p),43).add($r(m,30)).add(c),l.add($r(p.add(n),18)).add(m),t)}function j6(r,e=r.length){let t=Xl.fromNumber(81,!0);if(e<=32)return e<=16?V6(r,e):H6(r,e);if(e<=64)return q6(r,e);let n=t,o=t.mul(jl).add(113),s=Dv(o.mul(fn).add(113)).mul(fn),a=[Xl.UZERO,Xl.UZERO],i=[Xl.UZERO,Xl.UZERO];n=n.mul(fn).add(Kt(r,0));let u=0,l=(e-1>>6)*64,p=l+(e-1&63)-63;do n=$r(n.add(o).add(a[0]).add(Kt(r,u+8)),37).mul(jl),o=$r(o.add(a[1]).add(Kt(r,u+48)),42).mul(jl),n=n.xor(i[1]),o=o.add(a[0]).add(Kt(r,u+40)),s=$r(s.add(i[0]),33).mul(jl),a=Tb(r,u,a[1].mul(jl),n.add(i[0])),i=Tb(r,u+32,s.add(i[1]),o.add(Kt(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let m=jl.add(s.and(255).shl(1));return u=p,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),n=$r(n.add(o).add(a[0]).add(Kt(r,u+8)),37).mul(m),o=$r(o.add(a[1]).add(Kt(r,u+48)),42).mul(m),n=n.xor(i[1].mul(9)),o=o.add(a[0].mul(9).add(Kt(r,u+40))),s=$r(s.add(i[0]),33).mul(m),a=Tb(r,u,a[1].mul(m),n.add(i[0])),i=Tb(r,u+32,s.add(i[1]),o.add(Kt(r,u+16))),[s,n]=[n,s],nl(nl(a[0],i[0],m).add(Dv(o).mul(d_)).add(s),nl(a[1],i[1],m).add(n),m)}function X6(r,e){return e==="string"?ol(r):Zm([r],e)}function Y6(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Zm(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=ha(r)),$().getBool("DEBUG")&&Tv(r,e),Y6(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){let t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Yl(){return $().platform.now()}function Z6(r,e){return $().platform.fetch(r,e)}function ol(r,e="utf-8"){return e=e||"utf-8",$().platform.encode(r,e)}function Qm(r,e="utf-8"){return e=e||"utf-8",$().platform.decode(r,e)}var xb=class{constructor(e,t){this.backendTimer=e;this.logger=t;t==null&&(this.logger=new Mv)}profileKernel(e,t,n){let o,s=()=>{o=n()},a,i=Yl();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();a=Promise.resolve({kernelMs:Yl()-i})}if($().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let p=o[l];p.data().then(m=>{Q6(m,p.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:o,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),o,a]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],s,u[2])})})}};function Q6(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var Mv=class{logKernelProfile(e,t,n,o,s,a){let i=typeof o=="number"?Kl(`${o}ms`,9):o.error,u=Kl(e,25),l=t.rank,p=t.size,m=Kl(t.shape.toString(),14),c="";for(let d in s){let f=s[d];if(f!=null){let h=f.shape||t.shape,g=h.length;c+=`${d}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${m}	%c${p}	%c${c}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function h_(r,e,t){let n={},o={};for(let u=0;u<e.length;u++)n[e[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],p=l.inputs;for(let m in p){let c=p[m],d=!1;for(let f=0;f<e.length;f++)if(n[c.id]){l.outputs.forEach(h=>n[h.id]=!0),d=!0,o[l.id]=!0;break}if(d)break}}let s={};s[t.id]=!0;let a={};for(let u=r.length-1;u>=0;u--){let l=r[u],p=l.inputs;for(let m=0;m<l.outputs.length;m++)if(s[l.outputs[m].id]){for(let c in p)s[p[c].id]=!0,a[l.id]=!0;break}}let i=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&a[l.id]){let p={};for(let c in l.inputs){let d=l.inputs[c];n[d.id]&&(p[c]=d)}let m=Object.assign({},l);m.inputs=p,m.outputs=l.outputs,i.push(m)}}return i}function g_(r,e,t,n){for(let o=e.length-1;o>=0;o--){let s=e[o],a=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?a.push(l):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let i=s.gradient(a);for(let u in s.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);let l=t(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let p=s.inputs[u];if(!Wn(l.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${p.shape}'`);if(r[p.id]==null)r[p.id]=l;else{let m=r[p.id];r[p.id]=n(m,l),m.dispose()}}}}var b_=20,dh=3,Rv=7;function y_(r,e,t,n){let o=ki(e),s=J6(r,e,t,o),a=e.length,i=Ib(r,e,t,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function J6(r,e,t,n){let o=nt(e),s=n[n.length-1],a=new Array(s).fill(0),i=e.length,u=t==="complex64"?hh(r):r;if(i>1)for(let l=0;l<o/s;l++){let p=l*s;for(let m=0;m<s;m++)a[m]=Math.max(a[m],fh(u[p+m],0,t).length)}return a}function fh(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(Rv))} + ${parseFloat(r[1].toFixed(Rv))}j`:ga(r)?n=`'${r}'`:t==="bool"?n=T_(r):n=parseFloat(r.toFixed(Rv)).toString(),Kl(n,e)}function T_(r){return r===0?"false":"true"}function Ib(r,e,t,n,o,s=!0){let a=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){let h=hh(r);return[fh(h[0],0,t)]}return t==="bool"?[T_(r[0])]:[r[0].toString()]}if(u===1){if(i>b_){let g=dh*a,b=Array.from(r.slice(0,g)),T=Array.from(r.slice((i-dh)*a,i*a));return t==="complex64"&&(b=hh(b),T=hh(T)),["["+b.map((x,I)=>fh(x,o[I],t)).join(", ")+", ..., "+T.map((x,I)=>fh(x,o[i-dh+I],t)).join(", ")+"]"]}let h=t==="complex64"?hh(r):Array.from(r);return["["+h.map((g,b)=>fh(g,o[b],t)).join(", ")+"]"]}let l=e.slice(1),p=n.slice(1),m=n[0]*a,c=[];if(i>b_){for(let h=0;h<dh;h++){let g=h*m,b=g+m;c.push(...Ib(r.slice(g,b),l,t,p,o,!1))}c.push("...");for(let h=i-dh;h<i;h++){let g=h*m,b=g+m;c.push(...Ib(r.slice(g,b),l,t,p,o,h===i-1))}}else for(let h=0;h<i;h++){let g=h*m,b=g+m;c.push(...Ib(r.slice(g,b),l,t,p,o,h===i-1))}let d=u===2?",":"";c[0]="["+c[0]+d;for(let h=1;h<c.length-1;h++)c[h]=" "+c[h]+d;let f=`,
`;for(let h=2;h<u;h++)f+=`
`;return c[c.length-1]=" "+c[c.length-1]+"]"+(s?"":f),c}function hh(r){let e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}var bt=class{constructor(e,t,n){this.dtype=t;if(this.shape=e.slice(),this.size=nt(e),n!=null){let o=n.length;D(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||yv(t,this.size),this.strides=ki(e)}size;shape;strides;values;set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let o=0;o<e.length-1;++o)n+=this.strides[o]*e[o];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ja().makeTensor(this.values,this.shape,this.dtype)}},Ja=null,Jm=null,e8=null;function x_(r){Ja=r}function I_(r){Jm=r}function C_(r){e8=r}var We=class{id;dataId;shape;size;dtype;rankType;kept=!1;scopeId;strides;constructor(e,t,n,o){this.shape=e.slice(),this.dtype=t||"float32",this.size=nt(e),this.strides=ki(e),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Jm.buffer(this.shape,this.dtype,e)}bufferSync(){return Jm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Ul(this.shape,e,this.dtype==="complex64")}arraySync(){return Ul(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=Ja().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Qm(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ja().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=Ja().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Qm(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await Ja().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ja().disposeTensor(this),this.isDisposedInternal=!0)}isDisposedInternal=!1;get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Jm.print(this,e)}clone(){return this.throwIfDisposed(),Jm.clone(this)}toString(e=!1){let t=this.dataSync();return y_(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Jm.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),Ja().makeVariable(this,e,t,n)}};Object.defineProperty(We,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function t8(){return ih("Tensor",()=>We)}t8();var au=class extends We{constructor(t,n,o,s){super(t.shape,t.dtype,t.dataId,s);this.trainable=n;this.name=o}name;assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Wn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);Ja().disposeTensor(this),this.dataId=t.dataId,Ja().incRef(this,null)}dispose(){Ja().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(au,Symbol.hasInstance,{value:r=>r instanceof We&&r.assign!=null&&r.assign instanceof Function});var Gs={};qe(Gs,{assertTypesMatch:()=>Pv,getTensorsInContainer:()=>gh,isTensorInList:()=>n8,makeTypesMatch:()=>Ye});var k_=(i=>(i.R0="R0",i.R1="R1",i.R2="R2",i.R3="R3",i.R4="R4",i.R5="R5",i.R6="R6",i))(k_||{}),S_=(o=>(o.float32="float32",o.int32="int32",o.bool="int32",o.complex64="complex64",o))(S_||{}),v_=(o=>(o.float32="float32",o.int32="int32",o.bool="bool",o.complex64="complex64",o))(v_||{}),A_=(o=>(o.float32="float32",o.int32="float32",o.bool="float32",o.complex64="complex64",o))(A_||{}),w_=(o=>(o.float32="complex64",o.int32="complex64",o.bool="complex64",o.complex64="complex64",o))(w_||{}),r8={float32:A_,int32:S_,bool:v_,complex64:w_};function Pt(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return r8[r][e]}function iu(r){return Pt(r,"int32")}function Ye(r,e){if(r.dtype===e.dtype)return[r,e];let t=Pt(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function Pv(r,e){D(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function n8(r,e){return e.some(t=>t.id===r.id)}function gh(r){let e=[];return N_(r,e,new Set),e}function N_(r,e,t){if(r==null)return;if(r instanceof We){e.push(r);return}if(!o8(r))return;let n=r;for(let o in n){let s=n[o];t.has(s)||(t.add(s),N_(s,e,t))}}function o8(r){return Array.isArray(r)||typeof r=="object"}function Ev(r){return r.kernelName!=null}var Cb=class{registeredVariables={};nextTapeNodeId=0;numBytes=0;numTensors=0;numStringTensors=0;numDataBuffers=0;activeTape;gradientDepth=0;kernelDepth=0;activeScope;scopeStack=[];numDataMovesStack=[];nextScopeId=0;tensorInfo=new WeakMap;profiling=!1;activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}};dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},kb=class{constructor(e){this.ENV=e;this.state=new Cb}state;backendName;registry={};registryFactory={};profiler;backendInstance;pendingBackendInit;pendingBackendInitId=0;async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(Di(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new xb(this.backendInstance),!0}setupRegisteredKernels(){bb(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){bb(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof po)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(a=>o<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,Di(`Initialization of backend ${e} failed`),Di(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return Di(`Initialization of backend ${e} failed`),Di(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),o=n.backend,s=this.readSync(t),a=o.refCount(t);o.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=t(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,t,n){e();try{let o=n();return t(),o}catch(o){throw t(),o}}nextTensorId(){return kb.nextTensorId++}nextVariableId(){return kb.nextVariableId++}clone(e){let t=N.runKernel(Vn,{x:e}),n={x:e},o=a=>({x:()=>{let i="float32",u={x:a},l={dtype:i};return N.runKernel(Un,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],o,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(mh(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=o-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],o=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u,l=Ev(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Ev(e)){let{kernelName:f,inputs:h,attrs:g}=e;this.backendName==null&&this.backend;let b=mh(f,this.backendName);D(b!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{let T=this.backend.numDataIds();u=b.kernelFunc({inputs:h,attrs:g,backend:this.backend});let x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,T,x);let I=x.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(o){let k=this.getTensorsForGradient(f,h,I);n=this.saveTensorsForBackwardMode(k)}return I}}else{let{forwardFunc:f}=e,h=g=>{!o||(n=g.map(b=>this.keep(this.clone(b))))};i=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,h));let b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,b),b}}let{inputs:p,attrs:m}=e,c=Ev(e)?null:e.backwardsFunc,d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(d=this.profiler.profileKernel(l,p,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),o&&this.addTapeNode(l,p,t,c,n,m),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(f=>p[f]!=null?p[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let o=vv(e);if(o!=null){let s=o.inputsToSave||[],a=o.outputsToSave||[],i;o.saveAllInputs?(D(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=s.map(l=>t[l]);let u=n.filter((l,p)=>a[p]);return i.concat(u)}return[]}makeTensor(e,t,n,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=e;n==="string"&&ga(e[0])&&(s=e.map(u=>ol(u)));let a=o.write(s,t,n),i=new We(t,n,a,this.nextTensorId());if(this.trackTensor(i,o),n==="string"){let u=this.state.tensorInfo.get(a),l=Iv(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,t,n,o){n=n||"float32";let s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,o)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:o,dtype:s}=e,a=new We(o,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));let s=new au(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*gb(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof au||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*gb(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,o,s,a){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},u=vv(e);u!=null&&(o=u.gradFunc),o!=null&&(i.gradient=l=>(l=l.map((p,m)=>{if(p==null){let c=n[m],d=Cm(c.size,c.dtype);return this.makeTensor(d,c.shape,c.dtype)}return p}),o(l.length>1?l:l[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=gh(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(e,t,n,o=!1){if(D(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(s instanceof We,()=>"The result y returned by f() must be a tensor.");let a=h_(this.state.activeTape,t,s);if(!o&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[s.id]=n??s8(s.shape),g_(i,a,l=>this.tidy(l),a8);let u=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let p of l.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(e){return D(Ci(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{D(t.every(i=>i instanceof We),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};t.forEach((i,u)=>{o[u]=i});let s=(i,u)=>(n=e(...t,u),D(n.value instanceof We,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(Ci(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(i,u)=>{let l=n.gradFunc(i,u),p=Array.isArray(l)?l:[l];D(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(p.every(c=>c instanceof We),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let m={};return p.forEach((c,d)=>{m[d]=()=>c}),m};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=Yl(),n=await this.backend.time(e);return n.wallMs=Yl()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Cb;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},bh=kb;K(bh,"nextTensorId",0),K(bh,"nextVariableId",0);function s8(r){let e=oh(nt(r),"float32");return N.makeTensor(e,r,"float32")}function Fv(){let r=Sv();if(r._tfengine==null){let e=new ah(r);r._tfengine=new bh(e)}return X0(r._tfengine.ENV),x_(()=>r._tfengine),r._tfengine}var N=Fv();function a8(r,e){let t={a:r,b:e};return N.runKernel(Nn,t)}var sl={};qe(sl,{isBrowser:()=>$v,isMobile:()=>l8,mockIsMobile:()=>u8});function i8(){return typeof navigator<"u"&&navigator!=null}var Lv;function u8(r){Lv=r}function l8(r){if(Lv!==void 0)return Lv;if(r||i8()){if(r||(r=navigator),r.product==="ReactNative")return!0;let e=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");if(!e){let t=r;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function $v(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var ls=$();ls.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ls.registerFlag("IS_BROWSER",()=>$v());ls.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ls.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ls.registerFlag("PROD",()=>!1);ls.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ls.getBool("DEBUG"));ls.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ls.registerFlag("IS_TEST",()=>!1);ls.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ls.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ls.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ls.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Vr(r,e){let t=r;if(Sr(r))return e==="string"?[]:[r.length];if(typeof r=="object"&&"texture"in r){let o=r.channels||"RGBA";return[r.height,r.width*o.length]}if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(t)||Sr(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&$().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&__(r,n,[]),n}function __(r,e,t){if(t=t||[],!Array.isArray(r)&&!Sr(r)){D(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}D(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),D(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);let n=e.slice(1);for(let o=0;o<r.length;++o)__(r[o],n,t.concat(o))}function D_(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function v(r,e,t,n="numeric"){if(r instanceof We)return D_(n,r.dtype,e,t),r;let o=xm(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),D_(n,o,e,t),r==null||!Sr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Vr(r,o);!Sr(r)&&!Array.isArray(r)&&(r=[r]);let i=o!=="string"?Zm(r,o):ha(r,[],!0);return N.makeTensor(i,s,o)}function uu(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,a)=>v(s,`${e}[${a}]`,t,n))}var Bv="__op";function A(r){let e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Bv;let o=(...s)=>{N.startScope(t);try{let a=n(...s);return sh(a)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(a),a}catch(a){throw N.endScope(null),a}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}function p8(r,e){let t=v(r,"real","complex"),n=v(e,"imag","complex");Bt(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:t,imag:n};return N.runKernel(zu,o)}var Mn=A({complex_:p8});function hn(r,e,t,n){if(n==null&&(n=xm(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof r=="object"&&"texture"in r){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return r.channels=r.channels||"RGBA",N.backend.createTensorFromTexture(r,e||t,n)}if(!Sr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ut(e);let o=nt(e),s=nt(t);D(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let a=0;a<t.length;++a){let i=t[a],u=a===t.length-1?i!==nt(e.slice(a)):!0;D(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Sr(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Zm(r,n):ha(r,[],!0),N.makeTensor(r,e,n)}function mr(r,e,t){let n=Vr(r,t);return hn(r,e,n,t)}var yh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var Sb=4;async function R_(r,e){let t=[],n=[],o=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<o.length;++a){let i=o[a],u=Array.isArray(r)?r[a].tensor:r[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);let l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let p=new Promise(async m=>{let c=await u.bytes(),d=c.reduce((g,b)=>g+b.length,0)+Sb*c.length,f=new Uint8Array(d),h=0;for(let g=0;g<c.length;g++){let b=c[g],T=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(T,h),h+=Sb,f.set(b,h),h+=b.length}m(f)});n.push(p)}else n.push(u.data());e!=null&&(l.group=e),t.push(l)}let s=await Promise.all(n);return{data:m8(s),specs:t}}function vb(r,e){let t={},n,o=0;for(let s of e){let a=s.name,i=s.dtype,u=s.shape,l=nt(u),p;if("quantization"in s){let m=s.quantization;if(m.dtype==="uint8"||m.dtype==="uint16"){if(!("min"in m&&"scale"in m))throw new Error(`Weight ${s.name} with quantization ${m.dtype} doesn't have corresponding metadata min and scale.`)}else if(m.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${s.name} is quantized with ${m.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${m.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=yh[m.dtype],d=r.slice(o,o+l*c),f=m.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(i==="float32")if(m.dtype==="uint8"||m.dtype==="uint16"){p=new Float32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];p[h]=g*m.scale+m.min}}else if(m.dtype==="float16")n===void 0&&(n=h8()),p=n(f);else throw new Error(`Unsupported quantization type ${m.dtype} for weight type float32.`);else if(i==="int32"){if(m.dtype!=="uint8"&&m.dtype!=="uint16")throw new Error(`Unsupported quantization type ${m.dtype} for weight type int32.`);p=new Int32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];p[h]=Math.round(g*m.scale+m.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=l*c}else if(i==="string"){let m=nt(s.shape);p=[];for(let c=0;c<m;c++){let d=new Uint32Array(r.slice(o,o+Sb))[0];o+=Sb;let f=new Uint8Array(r.slice(o,o+d));p.push(f),o+=d}}else{let m=yh[i],c=r.slice(o,o+l*m);if(i==="float32")p=new Float32Array(c);else if(i==="int32")p=new Int32Array(c);else if(i==="bool")p=new Uint8Array(c);else if(i==="complex64"){p=new Float32Array(c);let d=new Float32Array(p.length/2),f=new Float32Array(p.length/2);for(let b=0;b<d.length;b++)d[b]=p[b*2],f[b]=p[b*2+1];let h=mr(d,u,"float32"),g=mr(f,u,"float32");t[a]=Mn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=l*m}i!=="complex64"&&(t[a]=mr(p,u,i))}return t}function m8(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0,t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(e),o=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var Ov=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function M_(r){return Ov?Buffer.byteLength(r):new Blob([r]).size}function P_(r){if(Ov)return Buffer.from(r).toString("base64");let e=new Uint8Array(r),t="";for(let n=0,o=e.length;n<o;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function E_(r){if(Ov){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function ec(r){if(r.length===1)return r[0];let e=0;r.forEach(o=>{e+=o.byteLength});let t=new Uint8Array(e),n=0;return r.forEach(o=>{t.set(new Uint8Array(o),n),n+=o.byteLength}),t.buffer}function zv(r){let e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);let t=r.split(e);return t[t.length-1]}function Ab(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(t.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}function Gv(r,e,t){let n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(n.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=e,n.weightData=t}return r.signature!=null&&(n.signature=r.signature),r.userDefinedMetadata!=null&&(n.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(n.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(n.initializerSignature=r.initializerSignature),n}async function tc(r,e){let t,n;return r.weightsManifest!=null&&([t,n]=await e(r.weightsManifest)),Gv(r,t,n)}function _i(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:M_(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:M_(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function wb(r){let e=[];for(let t of r)e.push(...t.weights);return e}function c8(){let r=t=>{let n=t<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function d8(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function f8(){let r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function h8(){let r=c8(),e=d8(),t=f8();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let a=0;a<n.length;a++){let i=n[a],u=r[t[i>>10]+(i&1023)]+e[i>>10];s[a]=u}return new Float32Array(o)}}var Ws=class{saveRouters;loadRouters;constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Ws.instance==null&&(Ws.instance=new Ws),Ws.instance}static registerSaveRouter(e){Ws.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Ws.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Ws.getHandlers(e,"save")}static getLoadHandlers(e,t){return Ws.getHandlers(e,"load",t)}static getHandlers(e,t,n){let o=[];return(t==="load"?Ws.getInstance().loadRouters:Ws.getInstance().saveRouters).forEach(a=>{let i=a(e,n);i!==null&&o.push(i)}),o}},vr=Ws;K(vr,"instance");var F_=r=>vr.registerSaveRouter(r),L_=r=>vr.registerLoadRouter(r),$_=r=>vr.getSaveHandlers(r),B_=(r,e)=>vr.getLoadHandlers(r,e);var Wv="tensorflowjs",Uv=1,Zl="models_store",al="model_info_store";function O_(){if(!$().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window>"u"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Kv(r){let e=r.result;e.createObjectStore(Zl,{keyPath:"modelPath"}),e.createObjectStore(al,{keyPath:"modelPath"})}var Mi=class{indexedDB;modelPath;constructor(e){if(this.indexedDB=O_(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,o)=>{let s=this.indexedDB.open(Wv,Uv);s.onupgradeneeded=()=>Kv(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(Zl,"readonly"),l=i.objectStore(Zl).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=p=>(a.close(),o(l.error)),i.oncomplete=()=>a.close()}else{let i=_i(t),u=a.transaction(al,"readwrite"),l=u.objectStore(al),p=l.put({modelPath:this.modelPath,modelArtifactsInfo:i}),m;p.onsuccess=()=>{m=a.transaction(Zl,"readwrite");let d=m.objectStore(Zl).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});d.onsuccess=()=>n({modelArtifactsInfo:i}),d.onerror=f=>{l=u.objectStore(al);let h=l.delete(this.modelPath);h.onsuccess=()=>(a.close(),o(d.error)),h.onerror=g=>(a.close(),o(d.error))}},p.onerror=c=>(a.close(),o(p.error)),u.oncomplete=()=>{m==null?a.close():m.oncomplete=()=>a.close()}}},s.onerror=a=>o(s.error)})}};K(Mi,"URL_SCHEME","indexeddb://");var z_=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Mi.URL_SCHEME)?g8(r.slice(Mi.URL_SCHEME.length)):null;vr.registerSaveRouter(z_);vr.registerLoadRouter(z_);function g8(r){return new Mi(r)}function b8(r){return r.startsWith(Mi.URL_SCHEME)?r.slice(Mi.URL_SCHEME.length):r}var Nb=class{indexedDB;constructor(){this.indexedDB=O_()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Wv,Uv);n.onupgradeneeded=()=>Kv(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(al,"readonly"),i=s.objectStore(al).getAll();i.onsuccess=()=>{let u={};for(let l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(o.close(),t(i.error)),s.oncomplete=()=>o.close()},n.onerror=o=>t(n.error)})}async removeModel(e){return e=b8(e),new Promise((t,n)=>{let o=this.indexedDB.open(Wv,Uv);o.onupgradeneeded=()=>Kv(o),o.onsuccess=()=>{let s=o.result,a=s.transaction(al,"readwrite"),i=a.objectStore(al),u=i.get(e),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let p=i.delete(e),m=()=>{l=s.transaction(Zl,"readwrite");let d=l.objectStore(Zl).delete(e);d.onsuccess=()=>t(u.result.modelArtifactsInfo),d.onerror=f=>n(u.error)};p.onsuccess=m,p.onerror=c=>(m(),s.close(),n(u.error))}},u.onerror=p=>(s.close(),n(u.error)),a.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var lu="/",rc="tensorflowjs_models",G_="info",y8="model_topology",T8="weight_specs",x8="weight_data",I8="model_metadata";function W_(r){return{info:[rc,r,G_].join(lu),topology:[rc,r,y8].join(lu),weightSpecs:[rc,r,T8].join(lu),weightData:[rc,r,x8].join(lu),modelMetadata:[rc,r,I8].join(lu)}}function U_(r){for(let e of Object.values(r))window.localStorage.removeItem(e)}function C8(r){let e=r.split(lu);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(lu)}function k8(r){return r.startsWith(Ri.URL_SCHEME)?r.slice(Ri.URL_SCHEME.length):r}var Ri=class{LS;modelPath;keys;constructor(e){if(!$().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=W_(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),o=_i(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,P_(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch{throw U_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=E_(a),t}};K(Ri,"URL_SCHEME","localstorage://");var K_=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ri.URL_SCHEME)?S8(r.slice(Ri.URL_SCHEME.length)):null;vr.registerSaveRouter(K_);vr.registerLoadRouter(K_);function S8(r){return new Ri(r)}var Db=class{LS;constructor(){D($().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=rc+lu,n=lu+G_;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(n)){let a=C8(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=k8(e);let t=W_(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return U_(t),n}};var nc="://",pu=class{managers;constructor(){this.managers={}}static getInstance(){return pu.instance==null&&(pu.instance=new pu),pu.instance}static registerManager(e,t){D(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(nc)&&(e=e.slice(0,e.indexOf(nc))),D(e.length>0,()=>"scheme must not be an empty string.");let n=pu.getInstance();D(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=pu.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(pu.getInstance().managers)}},Us=pu;K(Us,"instance");function _b(r){if(r.indexOf(nc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Us.getSchemes().join(",")}`);return{scheme:r.split(nc)[0],path:r.split(nc)[1]}}async function V_(r,e,t=!1){D(r!==e,()=>`Old path and new path are the same: '${r}'`);let n=vr.getLoadHandlers(r);D(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),D(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=vr.getSaveHandlers(e);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),D(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);let a=s[0],i=_b(r).scheme,u=_b(r).path,l=i===_b(r).scheme,p=await o.load();t&&l&&await Us.getManager(i).removeModel(u);let m=await a.save(p);return t&&!l&&await Us.getManager(i).removeModel(u),m.modelArtifactsInfo}async function H_(){let r=Us.getSchemes(),e={};for(let t of r){let n=await Us.getManager(t).listModels();for(let o in n){let s=t+nc+o;e[s]=n[o]}}return e}async function q_(r){let e=_b(r);return Us.getManager(e.scheme).removeModel(e.path)}async function j_(r,e){return V_(r,e,!1)}async function X_(r,e){return V_(r,e,!0)}var Vv=class{textEncoder;messageName="setTimeoutCustom";functionRefs=[];handledMessageCount=0;hasEventListener=!1;fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!$().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let o=this.functionRefs[n.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}};if($().get("IS_BROWSER")){$().setPlatform("browser",new Vv);try{Us.registerManager(Ri.URL_SCHEME,new Db)}catch{}try{Us.registerManager(Mi.URL_SCHEME,new Nb)}catch{}}var v8={importFetch:()=>Y_()},Hv;var qv=class{textEncoder;util;constructor(){this.util=Z_(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return $().global.fetch!=null?$().global.fetch(e,t):(Hv==null&&(Hv=v8.importFetch()),Hv(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};$().get("IS_NODE")&&!$().get("IS_BROWSER")&&$().setPlatform("node",new qv);function Ie(r,e="float32",t){return e=e||"float32",Ut(r),new bt(r,e,t)}function A8(r,e){let t=v(r,"x","cast");if(!xv(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:t},o={dtype:e};return N.runKernel(Un,n,o)}var re=A({cast_:A8});function w8(r){let t={x:v(r,"x","clone","string_or_numeric")};return N.runKernel(Vn,t)}var gn=A({clone_:w8});function Mb(r,e=!1){console.log(r.toString(e))}Fv();var N8={buffer:Ie,cast:re,clone:gn,print:Mb};I_(N8);var Br={};qe(Br,{browserFiles:()=>J_,browserHTTPRequest:()=>r1,concatenateArrayBuffers:()=>ec,copyModel:()=>j_,decodeWeights:()=>vb,encodeWeights:()=>R_,fromMemory:()=>n1,fromMemorySync:()=>Jv,getLoadHandlers:()=>B_,getModelArtifactsForJSON:()=>tc,getModelArtifactsForJSONSync:()=>Gv,getModelArtifactsInfoForJSON:()=>_i,getSaveHandlers:()=>$_,getWeightSpecs:()=>wb,http:()=>Eb,isHTTPScheme:()=>Pb,listModels:()=>H_,loadWeights:()=>e1,moveModel:()=>X_,registerLoadRouter:()=>L_,registerSaveRouter:()=>F_,removeModel:()=>q_,weightsLoaderFactory:()=>Zv,withSaveHandler:()=>o1,withSaveHandlerSync:()=>s1});var D8="model",_8=".json",M8=".weights.bin";function Q_(r){return new Promise(e=>setTimeout(e)).then(r)}var Rb=class{modelJsonFileName;weightDataFileName;modelJsonAnchor;weightDataAnchor;constructor(e){if(!$().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Rb.URL_SCHEME)&&(e=e.slice(Rb.URL_SCHEME.length)),(e==null||e.length===0)&&(e=D8),this.modelJsonFileName=e+_8,this.weightDataFileName=e+M8}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=Ab(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await Q_(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await Q_(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:_i(e)}}}},oc=Rb;K(oc,"URL_SCHEME","downloads://");var jv=class{jsonFile;weightsFiles;constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let u=tc(s,l=>this.loadWeights(l));e(u)},n.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let o=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,o[a]));return Promise.all(s).then(a=>[t,ec(a)])}loadWeightsFile(e,t){return new Promise((n,o)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>o(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>zv(s.name)),o={};for(let s of e)s.paths.forEach(a=>{let i=zv(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);o[a]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},R8=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(oc.URL_SCHEME)?P8(r.slice(oc.URL_SCHEME.length)):null;vr.registerSaveRouter(R8);function P8(r="model"){return new oc(r)}function J_(r){return new jv(r)}function Xv(r,e,t,n){a(r),t=t??0,n=n??1,i(t,n);let o=0,s=u=>(u.then(l=>{let p=t+ ++o/r.length*(n-t);return e(p),l}),u);function a(u){D(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),D(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function Yv(r,e){e==null&&(e={});let t=e.fetchFunc==null?$().platform.fetch:e.fetchFunc,n=r.map(m=>t(m,e.requestInit,{isBinary:!0})),o=0,s=.5,i=(e.onProgress==null?await Promise.all(n):await Xv(n,e.onProgress,o,s)).map(m=>m.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(i):await Xv(i,e.onProgress,u,l)}async function e1(r,e="",t,n){return Zv(a=>Yv(a,{requestInit:n}))(r,e,t)}function Zv(r){return async(e,t="",n)=>{let o=e.map(()=>!1),s={},a=n!=null?n.map(()=>!1):[],i=[];if(e.forEach((d,f)=>{let h=0;d.weights.forEach(g=>{let b="quantization"in g?g.quantization.dtype:g.dtype,T=yh[b]*nt(g.shape),x=()=>{o[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:h,sizeBytes:T})};n!=null?n.forEach((I,k)=>{I===g.name&&(x(),a[k]=!0)}):x(),i.push(g.name),h+=T})}),!a.every(d=>d)){let d=n.filter((f,h)=>!a[h]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let u=o.reduce((d,f,h)=>(f&&d.push(h),d),[]),l=[];u.forEach(d=>{e[d].paths.forEach(f=>{let h=t+(t.endsWith("/")?"":"/")+f;l.push(h)})});let p=await r(l),m={},c=0;return u.forEach(d=>{let f=e[d].paths.length,h=0;for(let I=0;I<f;I++)h+=p[c+I].byteLength;let g=new ArrayBuffer(h),b=new Uint8Array(g),T=0;for(let I=0;I<f;I++){let k=new Uint8Array(p[c+I]);b.set(k,T),T+=k.byteLength}s[d].forEach(I=>{let k=g.slice(I.groupOffset,I.groupOffset+I.sizeBytes),w=vb(k,[I.manifestEntry]);for(let _ in w)m[_]=w[_]}),c+=f}),m}}var E8="application/octet-stream",F8="application/json",Th=class{path;requestInit;fetch;weightUrlConverter;DEFAULT_METHOD="POST";weightPathPrefix;onProgress;constructor(e,t){if(t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(D(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=$().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o=Ab(e,n);t.body.append("model.json",new Blob([JSON.stringify(o)],{type:F8}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:E8}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:_i(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,o=t.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return tc(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=L8(t),s=this.weightPathPrefix||n,a=wb(e),i=[],u=[];for(let p of e)for(let m of p.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(m)):i.push(s+m+o);this.weightUrlConverter&&i.push(...await Promise.all(u));let l=await Yv(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,ec(l)]}};K(Th,"URL_SCHEME_REGEX",/^https?:\/\//);function L8(r){let e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),o=t>e?r.substring(t):"";return[n+"/",o]}function Pb(r){return r.match(Th.URL_SCHEME_REGEX)!=null}var t1=(r,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>Pb(n)):t=Pb(r),t)return Eb(r,e)}return null};vr.registerSaveRouter(t1);vr.registerLoadRouter(t1);function Eb(r,e){return new Th(r,e)}function r1(r,e){return Eb(r,e)}var xh=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},Fb=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},Qv=class{load;save;constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function n1(r,e,t,n){let o=arguments;return new Qv(Jv(...o))}function Jv(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new xh(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new xh({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new xh({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function o1(r){return new Fb(r)}function s1(r){return new Fb(r)}var u1={};qe(u1,{confusionMatrix:()=>i1});function $8(r,e,t=!1,n=!1){let o=v(r,"a","matMul"),s=v(e,"b","matMul");[o,s]=Ye(o,s);let a={a:o,b:s},i={transposeA:t,transposeB:n};return N.runKernel(go,a,i)}var Ue=A({matMul_:$8});function B8(r,e,t=1,n=0,o="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let a={indices:v(r,"indices","oneHot","int32")},i={dtype:o,depth:e,onValue:t,offValue:n};return N.runKernel(Wo,a,i)}var il=A({oneHot_:B8});function OIe(){$().set("PROD",!0)}function zIe(){$().set("DEBUG",!0)}function GIe(){$().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function eA(r){$().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}C_(eA);function WIe(){N.disposeVariables()}function rn(){return N}function Ih(){return N.memory()}function UIe(r){return N.profile(r)}function z(r,e){return N.tidy(r,e)}function _e(r){gh(r).forEach(t=>t.dispose())}function Et(r){return N.keep(r)}function KIe(r){return N.time(r)}function O8(r){return N.setBackend(r)}function VIe(){return N.ready()}function HIe(){return N.backendName}function qIe(r){N.removeBackend(r)}function jIe(r){return N.findBackend(r)}function XIe(r){return N.findBackendFactory(r)}function ul(r,e,t=1){return N.registerBackend(r,e,t)}function a1(){return N.backend}function YIe(r,e){$().setPlatform(r,e)}function z8(r){let t={input:v(r,"input","imag")};return N.runKernel(Hu,t)}var ll=A({imag_:z8});function G8(r){let t={x:v(r,"x","neg")};return N.runKernel(Ss,t)}var tt=A({neg_:G8});function W8(r){let t={input:v(r,"input","real")};return N.runKernel(Xu,t)}var mu=A({real_:W8});function U8(r,e,t){let n=v(r,"x","transpose");if(e==null&&(e=n.shape.map((a,i)=>i).reverse()),D(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(a=>{D(a>=0&&a<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();let o={x:n},s={perm:e};return n.dtype==="complex64"?z(()=>{let a=mu(n),i=ll(n);return a=N.runKernel(_n,{x:a},s),i=N.runKernel(_n,{x:i},s),t&&(i=tt(i)),Mn(a,i)}):N.runKernel(_n,o,s)}var Ge=A({transpose_:U8});function K8(r,e,t){let n=v(r,"labels","confusionMatrix"),o=v(e,"predictions","confusionMatrix");D(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),D(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),D(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),D(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),D(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=il(re(n,"int32"),t),a=il(re(o,"int32"),t),i=Ge(s),u=Ue(i,a);return re(u,"int32")}var i1=A({confusionMatrix_:K8});var Dr={};qe(Dr,{assertAndGetBroadcastShape:()=>Oe,getBroadcastDims:()=>l1,getReductionAxes:()=>vt});function l1(r,e){let t=r.length,n=[];for(let o=0;o<t;o++){let s=t-1-o,a=r[s]||1;(e[e.length-1-o]||1)>1&&a===1&&n.unshift(s)}return n}function vt(r,e){let t=[];for(let n=0;n<e.length;n++){let o=r[r.length-n-1],s=e.length-n-1,a=e[s];(o==null||o===1&&a>1)&&t.unshift(s)}return t}function Oe(r,e){let t=[],n=Math.max(r.length,e.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let a=e[e.length-o-1];if(a==null&&(a=1),s===1)t.unshift(a);else if(a===1)t.unshift(s);else if(s!==a){let i=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(i)}else t.unshift(s)}return t}var $b={};qe($b,{fromPixels:()=>Z8,fromPixelsAsync:()=>X8,toPixels:()=>Y8});function Lb(r,e,t){if(mo(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Vr(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return hn(r,e,n,t)}var Ql;function p1(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,o=!1,s=!1,a=!1,i=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(mh(Vl,N.backendName)!=null){let f={pixels:r},h={numChannels:e};return N.runKernel(Vl,f,h)}let[l,p]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],m;if(a)m=r.getContext("2d").getImageData(0,0,l,p).data;else if(n||t)m=r.data;else if(s||o||i){if(Ql==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Ql=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ql=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Ql.canvas.width=l,Ql.canvas.height=p,Ql.drawImage(r,0,0,l,p),m=Ql.getImageData(0,0,l,p).data}let c;if(e===4)c=new Int32Array(m);else{let f=l*p;c=new Int32Array(f*e);for(let h=0;h<f;h++)for(let g=0;g<e;++g)c[h*e+g]=m[h*4+g]}return Lb(c,[p,l,e],"int32")}function V8(r){return r!=null&&r.data instanceof Uint8Array}function H8(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function q8(r){return r!=null&&r.width!==0&&r.height!==0}function j8(r){return H8()&&!(r instanceof ImageBitmap)&&q8(r)&&!V8(r)}async function X8(r,e=3){let t=null;if($().getBool("WRAP_TO_IMAGEBITMAP")&&j8(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===r.width&&n.height===r.height?t=n:t=r}else t=r;return p1(t,e)}async function Y8(r,e){let t=v(r,"img","toPixels");if(!(r instanceof We)){let l=t;t=re(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let[n,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);let a=await t.data(),i=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let p=[0,0,0,255];for(let c=0;c<s;c++){let d=a[l*s+c];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(p[0]=d*i,p[1]=d*i,p[2]=d*i):p[c]=d*i}let m=l*4;u[m+0]=Math.round(p[0]),u[m+1]=Math.round(p[1]),u[m+2]=Math.round(p[2]),u[m+3]=Math.round(p[3])}if(e!=null){e.width=o,e.height=n;let l=e.getContext("2d"),p=new ImageData(u,o,n);l.putImageData(p,0,0)}return t!==r&&t.dispose(),u}var Z8=A({fromPixels_:p1});var Bb={};qe(Bb,{prepareAndValidate:()=>m1});function m1(r,e){let t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(nt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=e.shape,s=o[o.length-1],a=1;for(let m=0;m<o.length-1;++m)a*=o[m];let i=r.shape,u=o.slice();u.pop();let l=1;for(let m=s;m<t;++m)l*=i[m],u.push(i[m]);let p=[...ki(r.shape).map(m=>m/l),1].slice(0,s);return[u,a,l,p]}var Ch={};qe(Ch,{calculateShapes:()=>c1,validateInput:()=>Ob,validateUpdateShape:()=>tA});function tA(r,e,t){let n=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(t.rank-o))throw new Error(s+` Output shape length < ${n+(t.rank-o)}`);if(t.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let a=0;a<o;++a)if(t.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-o;++a)if(t.shape[a+o]!==r[a+n])throw new Error(s+` updates.shape[${a+o}] (${t.shape[a+o]}) != shape[${a+o}] (${r[a+o]})`)}function Ob(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}tA(t,e,r)}function c1(r,e,t){let n=e.shape.length,o=n>1?e.shape[n-1]:1,s=t.length,a=1;for(let m=o;m<s;++m)a*=t[m];let i=o<1?1:o,u=nt(e.shape)/i,l=[...ki(t.slice(0,o)),1],p=nt(t);return{sliceRank:o,numUpdates:u,sliceSize:a,strides:l,outputSize:p}}var It={};qe(It,{assertParamsValid:()=>J8,computeFlatOffset:()=>o5,computeOutShape:()=>t5,getNormalizedAxes:()=>r5,isSliceContinous:()=>n5,maskToAxes:()=>e5,parseSliceParams:()=>nA,sliceInfo:()=>s5,startForAxis:()=>x1,startIndicesWithElidedDims:()=>b1,stopForAxis:()=>I1,stopIndicesWithElidedDims:()=>y1,stridesForAxis:()=>T1,stridesWithElidedDims:()=>f1});var rA=-2,Q8=-1;function J8(r,e,t){let n=r.shape.length;D(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),D(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)D(e[o]+t[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function e5(r){let e=[],t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function t5(r,e,t){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((e[o]-r[o])/t[o]);return n}function f1(r,e,t,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function h1(r,e,t){return t<=r?t:t-(e-1)}function g1(r,e){let t=[];for(let n=0;n<r;n++)t.push(e+n);return t}function r5(r,e,t,n,o,s,a,i,u){let l=r.length,p=new Array(l),m=new Array(l),c=new Array(l);if(e.length&&t>0){let d=e[0],f=t+1;p=b1(a,d,f,n,r),m=y1(i,d,f,o,r),c=f1(s,d,f,r)}else for(let d=0;d<l;d++)p[d]=x1(a,n,s,r,d,u),m[d]=I1(i,o,s,r,d,u),c[d]=T1(s,d,u);return{begin:p,end:m,strides:c}}function b1(r,e,t,n,o){let s=[...o],a=g1(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{let u=h1(e,t,i),l=n[u];r&1<<u&&(l=0),s[i]=l}return s}function y1(r,e,t,n,o){let s=[...o],a=g1(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{let u=h1(e,t,i),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[i]=l}for(let i=0;i<s.length;i++){let u=o[i];s[i]<0&&(s[i]+=u),s[i]=Tm(0,s[i],o[i])}return s}function T1(r,e,t){let n=r[e];return(t&1<<e||n==null)&&(n=1),n}function x1(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),a=Tm(0,a,u-1),a}function I1(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),i>0?a=Tm(0,a,u):a=Tm(-1,a,u-1),a}function n5(r,e,t){let n=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){n=o;break}for(let o=n+1;o<t.length;o++)if(e[o]>0||t[o]!==r[o])return!1;return!0}function o5(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function nA(r,e,t){let n,o=r.shape.length;typeof e=="number"?n=[e,...new Array(o-1).fill(0)]:e.length<o?n=e.concat(new Array(o-e.length).fill(0)):n=e.slice(),n.forEach(a=>{D(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((a,i)=>a>=0?a:(D(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),r.shape[i]-n[i])),[n,s]}function s5(r,e,t,n,o,s,a,i,u){let l;if(n==null?(l=new Array(e.length),l.fill(1)):l=n,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1,m={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};for(let x=0;x<m.dims;x++)p&&(1<<x&i)!==0&&m.numAddAxisAfterEllipsis++,1<<x&a&&(p=!0);p||(m.ellipsisMask|=1<<m.dims,m.dims++);let c={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};a5(m,c);let d=!0,f=!0,h=!0,g=[],b=[];for(let x=0;x<r.length;++x){if(c.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);let I=!!(c.shrinkAxisMask&1<<x),k=r[x];if(k===-1){g.push(I?1:-1);continue}let w=[c.beginMask&1<<x,c.endMask&1<<x],_=[c.strides[x]>0?0:-1,c.strides[x]>0?k:k-1];if(I&&c.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&c.strides[x]===1;let M=!!(c.beginMask&1<<x&&c.endMask&1<<x);if(c.beginValid&&c.endValid){if(I){let G=c.begin[x]<0?k+c.begin[x]:c.begin[x];if(c.begin[x]=G,c.end[x]=c.begin[x]+1,G<0||G>=k)throw Error(`slice index ${c.begin[x]} of dimension ${x} out of bounds.`)}else c.begin[x]=d1(c.begin[x],0,c.strides[x],k,w,_),c.end[x]=d1(c.end[x],1,c.strides[x],k,w,_);let O=c.strides[x]===1&&c.begin[x]===0&&c.end[x]===k;d=d&&O,f=f&&(x===0&&c.strides[x]===1||O)}else d=d&&c.strides[x]===1&&M,f=f&&(x===0&&c.strides[x]===1||M);let R,E=!1;if(c.beginValid&&c.endValid?(R=c.end[x]-c.begin[x],E=!0):I?(R=1,E=!0):M&&k>=0&&(c.strides[x]<0?R=-k:R=k,E=!0),E){let O;R===0||R<0!=c.strides[x]<0?O=0:O=Math.trunc(R/c.strides[x])+(R%c.strides[x]!==0?1:0),g.push(O)}else g.push(-1)}for(let x=0;x<c.finalShapeGatherIndices.length;++x){let I=c.finalShapeGatherIndices[x];I>=0?b.push(g[I]):I===rA&&b.push(1)}return{finalShapeSparse:b.filter((x,I)=>c.finalShapeGatherIndices[I]!==rA),finalShape:b,isIdentity:d,sliceDim0:f,isSimpleSlice:h,begin:c.begin,end:c.end,strides:c.strides}}function a5(r,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=r.begin!=null,e.endValid=r.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(e.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,e.dims);for(;t<o;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&r.newAxisMask)e.finalShapeGatherIndices.push(rA),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);r.begin!=null&&(e.begin[t]=r.begin[n]),r.end!=null&&(e.end[t]=r.end[n]),e.strides[t]=r.strides[n],r.beginMask&1<<n&&(e.beginMask|=1<<t),r.endMask&1<<n&&(e.endMask|=1<<t),r.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(Q8),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function d1(r,e,t,n,o,s){if(o[e])return t>0?s[e]:s[e+1&1];{let a=r<0?n+r:r;return a<s[0]?s[0]:a>s[1]?s[1]:a}}var Q={};qe(Q,{Serializable:()=>Sh,SerializationMap:()=>kh,registerClass:()=>Rn});var Sh=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},Jl=class{classNameMap;constructor(){this.classNameMap={}}static getMap(){return Jl.instance==null&&(Jl.instance=new Jl),Jl.instance}static register(e){Jl.getMap().classNameMap[e.className]=[e,e.fromConfig]}},kh=Jl;K(kh,"instance");function Rn(r){D(r.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),D(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),kh.register(r)}var v1={};qe(v1,{TEST_EPSILON_FLOAT16:()=>C1,createVideoElement:()=>d5,encodeStrings:()=>S1,expectArrayBuffersEqual:()=>c5,expectArraysClose:()=>u5,expectArraysEqual:()=>p5,expectNumbersClose:()=>k1,expectPromiseToFail:()=>l5,expectValuesInRange:()=>m5,play:()=>f5,testEpsilon:()=>zb});var i5=.001,C1=.1;function u5(r,e,t){return t==null&&(t=zb()),oA(r,e,(n,o)=>sA(n,o,t))}function zb(){return N.backend.floatPrecision()===32?i5:C1}function oA(r,e,t){let n=!0;if((Sr(r)||Sr(e))&&(n=!1),Sr(r)&&Sr(e)&&(n=!0),n){let a=r.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(r)&&Array.isArray(e)){let a=Vr(r),i=Vr(e);if(!Wn(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let o=Sr(r)?r:ha(r),s=Sr(e)?e:ha(e);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){let i=o[a],u=s[a];if(!t(i,u))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function l5(r,e){r().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function p5(r,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return ga(r)||ga(r[0])||ga(e)||ga(e[0])?oA(r,t,(n,o)=>n==o):oA(r,e,(n,o)=>sA(n,o,0))}function k1(r,e,t){if(t==null&&(t=zb()),!sA(r,e,t))throw new Error(`Numbers differ: actual === ${r}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function sA(r,e,t){return!isFinite(r)&&!isFinite(e)?!0:!(isNaN(r)||isNaN(e)||Math.abs(r-e)>t)}function m5(r,e,t){for(let n=0;n<r.length;n++)if(r[n]<e||r[n]>t)throw new Error(`Value out of range:${r[n]} low: ${e}, high: ${t}`)}function c5(r,e){let t=new Float32Array(r),n=new Float32Array(e);if(t.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${t.length}`);for(let o=0;o<n.length;o++)if(t[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${n[o]} but got ${t[o]} instead`)}function S1(r){for(let e=0;e<r.length;e++){let t=r[e];Array.isArray(t)?S1(t):r[e]=ol(t)}return r}function d5(r){let e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(r),new Promise(t=>{e.addEventListener("loadeddata",n=>t(e)),e.load()})}async function f5(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(e=>{r.requestVideoFrameCallback(e)})}var h5="0.0.0";function g5(r,e){let t=v(r,"a","add"),n=v(e,"b","add");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Nn,o)}var Z=A({add_:g5});function b5(r,e){let t=v(r,"a","floorDiv"),n=v(e,"b","floorDiv");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(No,o)}var Gb=A({floorDiv_:b5});function y5(r,e){let t=v(r,"a","div"),n=v(e,"b","div");if([t,n]=Ye(t,n),t.dtype==="int32"&&n.dtype==="int32")return Gb(t,n);let o={a:t,b:n},s={};return N.runKernel(So,o,s)}var fe=A({div_:y5});function T5(r,e){let t=v(r,"a","mul"),n=v(e,"b","mul");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Go,o)}var P=A({mul_:T5});function x5(r){let e=v(r,"x","abs");if(e.dtype==="complex64"){let t={x:e};return N.runKernel(Gu,t)}else{let t={x:e};return N.runKernel(Ts,t)}}var Ot=A({abs_:x5});function I5(r){let t={x:v(r,"x","acos")};return N.runKernel(ba,t)}var A1=A({acos_:I5});function C5(r){let t={x:v(r,"x","acosh")};return N.runKernel(ya,t)}var w1=A({acosh_:C5});function k5(r){D(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),D(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let e=r.map((o,s)=>v(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!Wn(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=e;return N.runKernel(co,n)}var N1=A({addN_:k5});function S5(r,e=null,t=!1){let o={x:v(r,"x","all","bool")},s={axis:e,keepDims:t};return N.runKernel(Ta,o,s)}var Wb=A({all_:S5});function v5(r,e=null,t=!1){let o={x:v(r,"x","any","bool")},s={axis:e,keepDims:t};return N.runKernel(xa,o,s)}var vh=A({any_:v5});function A5(r,e=0){let n={x:v(r,"x","argMax")},o={axis:e};return N.runKernel(fo,n,o)}var pl=A({argMax_:A5});function w5(r,e=0){let n={x:v(r,"x","argMin")},o={axis:e};return N.runKernel(Si,n,o)}var D1=A({argMin_:w5});function N5(r){let t={x:v(r,"x","asin")};return N.runKernel(Ia,t)}var _1=A({asin_:N5});function D5(r){let t={x:v(r,"x","asinh")};return N.runKernel(Ca,t)}var M1=A({asinh_:D5});function _5(r){let t={x:v(r,"x","atan")};return N.runKernel(ka,t)}var R1=A({atan_:_5});function M5(r,e){let t=v(r,"a","atan2"),n=v(e,"b","atan2");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(va,o)}var P1=A({atan2_:M5});function R5(r){let t={x:v(r,"x","atanh")};return N.runKernel(Sa,t)}var E1=A({atanh_:R5});function P5(r,e,t,n,o="NHWC",s){let a=r[3],i=[...e,a],u=L1(o);return tp(r,i,t,s,n,null,null,u)}function iA(r,e,t,n,o,s,a="channelsLast"){let[i,u]=Ub(e),l;if(a==="channelsLast")l=[i,u,r[3],r[3]];else if(a==="channelsFirst")l=[i,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return tp(r,l,t,n,o,s,!1,a)}function E5(r,e,t,n,o,s,a="NDHWC"){let[i,u,l]=aA(e),p,m;if(a==="NDHWC")m="channelsLast",p=[i,u,l,r[4],r[4]];else if(a==="NCDHW")m="channelsFirst",p=[i,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return F1(r,p,t,n,o,!1,m,s)}function tp(r,e,t,n,o,s,a=!1,i="channelsLast"){let[u,l,p,m]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,p,m]=r;else if(i==="channelsFirst")[u,m,l,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[c,d,,f]=e,[h,g]=Ub(t),[b,T]=Ub(n),x=sc(c,b),I=sc(d,T),{padInfo:k,outHeight:w,outWidth:_}=$5(o,l,p,h,g,x,I,s,i),M=a?f*m:f,R;return i==="channelsFirst"?R=[u,M,w,_]:i==="channelsLast"&&(R=[u,w,_,M]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:p,inChannels:m,outHeight:w,outWidth:_,outChannels:M,padInfo:k,strideHeight:h,strideWidth:g,filterHeight:c,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:I,dilationHeight:b,dilationWidth:T,inShape:r,outShape:R,filterShape:e}}function F1(r,e,t,n,o,s=!1,a="channelsLast",i){let[u,l,p,m,c]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,l,p,m,c]=r;else if(a==="channelsFirst")[u,c,l,p,m]=r;else throw new Error(`Unknown dataFormat ${a}`);let[d,f,h,,g]=e,[b,T,x]=aA(t),[I,k,w]=aA(n),_=sc(d,I),M=sc(f,k),R=sc(h,w),{padInfo:E,outDepth:O,outHeight:G,outWidth:W}=B5(o,l,p,m,b,T,x,_,M,R,i),H=s?g*c:g,U;return a==="channelsFirst"?U=[u,H,O,G,W]:a==="channelsLast"&&(U=[u,O,G,W,H]),{batchSize:u,dataFormat:a,inDepth:l,inHeight:p,inWidth:m,inChannels:c,outDepth:O,outHeight:G,outWidth:W,outChannels:H,padInfo:E,strideDepth:b,strideHeight:T,strideWidth:x,filterDepth:d,filterHeight:f,filterWidth:h,effectiveFilterDepth:_,effectiveFilterHeight:M,effectiveFilterWidth:R,dilationDepth:I,dilationHeight:k,dilationWidth:w,inShape:r,outShape:U,filterShape:e}}function F5(r,e,t,n,o){n==null&&(n=uA(r,e,t));let s=r[0],a=r[1],i=ep((s-e+2*n)/t+1,o),u=ep((a-e+2*n)/t+1,o);return[i,u]}function L5(r,e,t,n,o,s){o==null&&(o=uA(r,e,n));let a=r[0],i=r[1],u=r[2],l=ep((a-e+2*o)/n+1,s),p=ep((i-e+2*o)/n+1,s),m=ep((u-e+2*o)/n+1,s);return[l,p,m,t]}function uA(r,e,t,n=1){let o=sc(e,n);return Math.floor((r[0]*(t-1)-t+o)/2)}function Ub(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function aA(r){return typeof r=="number"?[r,r,r]:r}function sc(r,e){return e<=1?r:r+(r-1)*(e-1)}function $5(r,e,t,n,o,s,a,i,u){let l,p,m;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let d=F5([e,t],s,n,r,i);p=d[0],m=d[1]}else if(r==="same"){p=Math.ceil(e/n),m=Math.ceil(t/o);let c=Math.max(0,(p-1)*n+s-e),d=Math.max(0,(m-1)*o+a-t),f=Math.floor(c/2),h=c-f,g=Math.floor(d/2),b=d-g;l={top:f,bottom:h,left:g,right:b,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-s+1)/n),m=Math.ceil((t-a+1)/o);else if(typeof r=="object"){let c=u==="channelsLast"?r[1][0]:r[2][0],d=u==="channelsLast"?r[1][1]:r[2][1],f=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:c,bottom:d,left:f,right:h,type:c===0&&d===0&&f===0&&h===0?"VALID":"EXPLICIT"},p=ep((e-s+c+d)/n+1,i),m=ep((t-a+f+h)/o+1,i)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:p,outWidth:m}}function B5(r,e,t,n,o,s,a,i,u,l,p){let m,c,d,f;if(typeof r=="number"){m={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=L5([e,t,n,1],i,1,o,r,p);c=g[0],d=g[1],f=g[2]}else if(r==="same"){c=Math.ceil(e/o),d=Math.ceil(t/s),f=Math.ceil(n/a);let h=(c-1)*o+i-e,g=(d-1)*s+u-t,b=(f-1)*a+l-n,T=Math.floor(h/2),x=h-T,I=Math.floor(g/2),k=g-I,w=Math.floor(b/2),_=b-w;m={top:I,bottom:k,left:w,right:_,front:T,back:x,type:"SAME"}}else if(r==="valid")m={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},c=Math.ceil((e-i+1)/o),d=Math.ceil((t-u+1)/s),f=Math.ceil((n-l+1)/a);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:m,outDepth:c,outHeight:d,outWidth:f}}function ep(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function ps(r){let[e,t,n]=Ub(r);return e===1&&t===1&&n===1}function Or(r,e){return ps(r)||ps(e)}function L1(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function _t(r,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")D(Zi(e),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(o=>{D(Zi(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${e}`)}}function O5(r,e){let n={x:v(r,"x","reshape","string_or_numeric")},o={shape:e};return N.runKernel(ws,n,o)}var F=A({reshape_:O5});function z5(r,e,t,n,o){let s=v(r,"x","avgPool","float32"),a=1;D(Or(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=s,u=!1;s.rank===3&&(u=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),_t("avgPool",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},m=N.runKernel(ho,l,p);return m=re(m,s.dtype),u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var ac=A({avgPool_:z5});function G5(r,e,t,n,o,s="NDHWC"){let a=v(r,"x","avgPool3d","float32"),i=a,u=!1;a.rank===4&&(u=!0,i=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),_t("avgPool3d",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},m=N.runKernel(Bu,l,p);return m=re(m,i.dtype),u?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Kb=A({avgPool3d_:G5});function W5(r,e=0){D(r.length>=1,()=>"Pass at least one tensor to concat");let t=uu(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return gn(t[0]);let n=t,o={axis:e};return N.runKernel(Is,n,o)}var ct=A({concat_:W5});function U5(r){let t={x:v(r,"x","sigmoid","float32")};return N.runKernel(ts,t)}var Pn=A({sigmoid_:U5});function K5(r,e,t){let n=v(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:e,size:t};return N.runKernel(Ds,o,s)}var ze=A({slice_:K5});function V5(r){let t={x:v(r,"x","tanh","float32")};return N.runKernel(us,t)}var ml=A({tanh_:V5});function H5(r,e,t,n,o,s){let a=v(r,"forgetBias","basicLSTMCell"),i=v(e,"lstmKernel","basicLSTMCell"),u=v(t,"lstmBias","basicLSTMCell"),l=v(n,"data","basicLSTMCell"),p=v(o,"c","basicLSTMCell"),m=v(s,"h","basicLSTMCell"),c=ct([l,m],1),d=Ue(c,i),f=Z(d,u),h=f.shape[0],g=f.shape[1]/4,b=[h,g],T=ze(f,[0,0],b),x=ze(f,[0,g],b),I=ze(f,[0,g*2],b),k=ze(f,[0,g*3],b),w=Z(P(Pn(T),ml(x)),P(p,Pn(Z(a,I)))),_=P(ml(w),Pn(k));return[w,_]}var $1=A({basicLSTMCell_:H5});function q5(r,e,t){let n=v(r,"x","batchToSpaceND"),o=e.reduce((i,u)=>i*u);D(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),D(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),D(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:n},a={blockShape:e,crops:t};return N.runKernel(xs,s,a)}var ic=A({batchToSpaceND_:q5});function B1(r){let e;return r.rank===0||r.rank===1?e=F(r,[1,1,1,r.size]):r.rank===2?e=F(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}function j5(r,e,t,n,o,s){s==null&&(s=.001);let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;n!=null&&(p=v(n,"offset","batchNorm")),D(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(p==null||i.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let c={x:B1(a),scale:l,offset:p,mean:i,variance:u},d={varianceEpsilon:s},f=N.runKernel(Do,c,d);return F(f,a.shape)}var cl=A({batchNorm_:j5});function X5(r,e,t,n,o,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),D(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),cl(a,i,u,p,l,s)}var Vb=A({batchNorm2d_:X5});function Y5(r,e,t,n,o,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),D(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),cl(a,i,u,p,l,s)}var Hb=A({batchNorm3d_:Y5});function Z5(r,e,t,n,o,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),D(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),cl(a,i,u,p,l,s)}var qb=A({batchNorm4d_:Z5});function Q5(r,e,t){let n=v(r,"x","bincount"),o=v(e,"weights","bincount");D(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},a={size:t};return N.runKernel(Ou,s,a)}var jb=A({bincount_:Q5});function J5(r,e){let t=v(r,"s0","broadcastArgs","int32"),n=v(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:t,s1:n};return N.runKernel(vm,o)}var O1=A({broadcastArgs_:J5});function eX(r,e){let t=v(r,"broadcastTo","x"),n=t.shape;if(Ut(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=F(t,l)}let o=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(o[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((l,p)=>l>1?p:-1).filter(l=>l>=0).length===0)return gn(t);let i={x:t},u={reps:s};return N.runKernel(Dn,i,u)}var dl=A({broadcastTo_:eX});function tX(r){let t={x:v(r,"x","ceil","float32")};return N.runKernel(bo,t)}var z1=A({ceil_:tX});function Ks(r,e,t){Ut(r);let n={shape:r,value:e,dtype:t};return N.runKernel(vi,{},n)}function rX(r,e,t){let n=v(r,"x","clipByValue");if(D(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Ks(n.shape,e,n.dtype);let o={x:n},s={clipValueMin:e,clipValueMax:t};return N.runKernel(Kn,o,s)}var Hr=A({clipByValue_:rX});function nX(r){return ct(r,0)}var Xb=A({concat1d_:nX});function oX(r,e){return ct(r,e)}var Yb=A({concat2d_:oX});function sX(r,e){return ct(r,e)}var Zb=A({concat3d_:sX});function aX(r,e){return ct(r,e)}var Qb=A({concat4d_:aX});function iX(r,e,t,n,o="NHWC",s=[1,1],a){let i=v(r,"x","conv2d","float32"),u=v(e,"filter","conv2d","float32"),l=i,p=!1;i.rank===3&&(p=!0,l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),_t("conv2d",n,a);let m=o==="NHWC"?l.shape[3]:l.shape[1];D(m===u.shape[2],()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${u.shape[2]}.`),D(Or(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let c={x:l,filter:u},d={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=N.runKernel(yo,c,d);return p?F(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var cs=A({conv2d_:iX});function uX(r,e,t,n,o="NWC",s=1,a){let i=v(r,"x","conv1d"),u=v(e,"filter","conv1d"),l=i,p=!1;i.rank===2&&(p=!0,l=F(i,[1,i.shape[0],i.shape[1]])),D(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),D(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),_t("conv1d",n,a),D(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),D(Or(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),D(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let m=F(u,[1,u.shape[0],u.shape[1],u.shape[2]]),c=F(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=cs(c,m,[1,t],n,"NHWC",[1,s],a);return p?F(g,[g.shape[2],g.shape[3]]):F(g,[g.shape[0],g.shape[2],g.shape[3]])}var Jb=A({conv1d_:uX});function lX(r,e,t,n,o,s="NHWC",a){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let i=r,u=e,l=!1;e.rank===3&&(l=!0,u=F(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,r[0],r[1],r[2]]),D(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),D(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),D(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let p=s==="NHWC"?i[3]:i[1],m=s==="NHWC"?u.shape[3]:u.shape[1];D(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),D(m===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${t.shape[3]}.`),_t("conv2dDerInput",o,a);let c={dy:u,filter:t},d={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,inputShape:i},f=N.runKernel(To,c,d);return l?F(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var uc=A({conv2DBackpropInput_:lX});function pX(r,e,t,n,o,s){let a=v(r,"x","conv2dTranspose"),i=v(e,"filter","conv2dTranspose");return uc(t,a,i,n,o,"NHWC",s)}var ey=A({conv2dTranspose_:pX});function mX(r,e,t,n,o="NDHWC",s=[1,1,1]){let a=v(r,"x","conv3d"),i=v(e,"filter","conv3d"),u=a,l=!1;a.rank===4&&(l=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),D(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),D(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),D(Or(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let p={x:u,filter:i},m={strides:t,pad:n,dataFormat:o,dilations:s},c=N.runKernel(Wu,p,m);return l?F(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var ty=A({conv3d_:mX});function cX(r,e,t,n,o){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,a=e,i=!1;e.rank===4&&(i=!0,a=F(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=a.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),D(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),D(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),D(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);let p={dy:a,filter:t},m={pad:o,strides:n,inputShape:s},c=N.runKernel(Nm,p,m);return i?F(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var ry=A({conv3DBackpropInput_:cX});function dX(r,e,t,n,o){let s=v(r,"x","conv3dTranspose"),a=v(e,"filter","conv3dTranspose");return ry(t,s,a,n,o)}var ny=A({conv3dTranspose_:dX});function fX(r){let t={x:v(r,"x","cos","float32")};return N.runKernel(xo,t)}var lc=A({cos_:fX});function hX(r){let t={x:v(r,"x","cosh","float32")};return N.runKernel(Io,t)}var oy=A({cosh_:hX});function gX(r,e=0,t=!1,n=!1){let s={x:v(r,"x","cumprod")},a={axis:e,exclusive:t,reverse:n};return N.runKernel(Aa,s,a)}var Ah=A({cumprod_:gX});function bX(r,e=0,t=!1,n=!1){let s={x:v(r,"x","cumsum")},a={axis:e,exclusive:t,reverse:n};return N.runKernel(Co,s,a)}var sy=A({cumsum_:bX});function yX(r,e,t,n=!1){let o=v(r,"x","denseBincount"),s=v(e,"weights","denseBincount");D(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),D(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let a={x:o,weights:s},i={size:t,binaryOutput:n};return N.runKernel(Uu,a,i)}var wh=A({denseBincount_:yX});function TX(r,e,t="NHWC"){let n=v(r,"x","depthToSpace","float32"),o=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];D(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),D(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${n.shape}`),D(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),D(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${n.shape}`);let i={x:n},u={blockSize:e,dataFormat:t};return N.runKernel(Na,i,u)}var G1=A({depthToSpace_:TX});function xX(r,e,t,n,o="NHWC",s=[1,1],a){let i=v(r,"x","depthwiseConv2d","float32"),u=v(e,"filter","depthwiseConv2d","float32"),l=i,p=!1;i.rank===3&&(p=!0,l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let m=o==="NHWC"?l.shape[3]:l.shape[1];D(m===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${m}) must match the inChannels dimension in filter ${u.shape[2]}.`),_t("depthwiseConv2d",n,a);let c={x:l,filter:u},d={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=N.runKernel(ko,c,d);return p?F(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var fl=A({depthwiseConv2d_:xX});function IX(r){let t={x:v(r,"x","diag")};return N.runKernel(Mm,t)}var W1=A({diag_:IX});function CX(r,e,t,n,o=[1,1],s="NHWC"){let a=v(r,"x","dilation2d"),i=v(e,"filter","dilation2d");D(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),D(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=a,l=!1;a.rank===3&&(u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=!0);let p={x:u,filter:i},m={strides:t,pad:n,dilations:o},c=N.runKernel(Ku,p,m);return l?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var U1=A({dilation2d_:CX});function kX(r,e){let t=v(r,"a","equal","string_or_numeric"),n=v(e,"b","equal","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(_a,o)}var nn=A({equal_:kX});function SX(r,e,t){let n=v(e,"a","where"),o=v(t,"b","where"),s=v(r,"condition","where","bool"),a=Oe(Oe(s.shape,n.shape),o.shape),i=dl(s,a),u=dl(n,a),l=dl(o,a),p={condition:i,t:u,e:l};return N.runKernel(Ns,p)}var zt=A({where_:SX});function vX(r){let t={x:v(r,"x","zerosLike")};return N.runKernel(Ps,t)}var we=A({zerosLike_:vX});function AX(r,e){let t=v(r,"a","div"),n=v(e,"b","div");[t,n]=Ye(t,n);let o=fe(t,n),s=we(o),a=nn(n,s);return zt(a,s,o)}var K1=A({divNoNan_:AX});function wX(r,e){let t=v(r,"t1","dot"),n=v(e,"t2","dot");D((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=n.rank===1?n.size:n.shape[0];if(D(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&n.rank===1){let a=F(t,[1,-1]),i=F(n,[-1,1]),u=Ue(a,i);return F(u,[])}else if(t.rank===1&&n.rank===2){let a=F(t,[1,-1]),i=F(n,[n.shape[0],n.shape[1]]),u=Ue(a,i);return F(u,[u.size])}else if(t.rank===2&&n.rank===1){let a=F(n,[-1,1]),i=Ue(t,a);return F(i,[i.size])}else{let a=F(n,[n.shape[0],n.shape[1]]);return Ue(t,a)}}var V1=A({dot_:wX});function NX(r,...e){let t=e.map((o,s)=>v(o,`tensors${s}`,"einsum")),n={equation:r};return N.runKernel(Vu,t,n)}var H1=A({einsum_:NX});function DX(r){let t={x:v(r,"x","elu","float32")};return N.runKernel(vo,t)}var hl=A({elu_:DX});function _X(r){let e=v(r,"x","erf");D(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=re(e,"float32"));let t={x:e};return N.runKernel(Da,t)}var q1=A({erf_:_X});function lA(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function j1(r,e,t){let n=r.length+e.length,o=[],s=0,a=0;for(let i=0;i<n;i++)t.indexOf(i)===-1?o.push(r[s++]):o.push(e[a++]);return o}function pA(r,e){let t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);let o=e.map(s=>r[s]);return[t,o]}function Vs(r,e){let t=e.map(n=>1);return j1(r,t,e)}function MX(r,e,t){D(lA(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function mA(r,e){if(lA(r,e))return null;let t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function Nh(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function RX(r,e){let t=[];for(let n=e-r;n<e;++n)t.push(n);return t}function PX(r,e=null,t=!1){let o={x:v(r,"x","max")},s={reductionIndices:e,keepDims:t};return N.runKernel(Eo,o,s)}var qr=A({max_:PX});function EX(r,e=null,t=!1){let o={x:v(r,"x","min")},s={axis:e,keepDims:t};return N.runKernel(Bo,o,s)}var rp=A({min_:EX});function FX(r,e){let t=v(r,"base","pow"),n=v(e,"exp","pow");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Ko,o)}var jn=A({pow_:FX});function ge(r,e){if((Sr(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Sr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return hn(r,[],[],e)}function LX(r){let t={x:v(r,"x","sqrt","float32")};return N.runKernel(rs,t)}var Ft=A({sqrt_:LX});function $X(r){let e=v(r,"x","square"),t={};return N.runKernel("Square",{x:e},t)}var He=A({square_:$X});function BX(r,e=null,t=!1){let n=v(r,"x","sum");n.dtype==="bool"&&(n=re(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(ns,o,s)}var be=A({sum_:BX});function OX(r,e="euclidean",t=null,n=!1){r=v(r,"x","norm");let o=X1(r,e,t),s=o.shape;if(n){let a=gr(t,r.shape);s=Vs(o.shape,a)}return F(o,s)}function X1(r,e,t=null){if(r.rank===0)return Ot(r);if(r.rank!==1&&t===null)return X1(F(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return be(Ot(r),t);if(e===1/0)return qr(Ot(r),t);if(e===-1/0)return rp(Ot(r),t);if(e==="euclidean"||e===2)return Ft(be(jn(Ot(r),ge(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return qr(be(Ot(r),t[0]),t[1]-1);if(e===1/0)return qr(be(Ot(r),t[1]),t[0]);if(e===-1/0)return rp(be(Ot(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ft(be(He(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var np=A({norm_:OX});function zX(r,e=null,t=!1){return np(r,"euclidean",e,t)}var Y1=A({euclideanNorm_:zX});function GX(r){let t={x:v(r,"x","exp")};return N.runKernel(Ao,t)}var br=A({exp_:GX});function WX(r,e=0){let t=v(r,"x","expandDims","string_or_numeric");D(e<=t.rank,()=>"Axis must be <= rank of the tensor");let n={input:t},o={dim:e};return N.runKernel(Cs,n,o)}var yr=A({expandDims_:WX});function UX(r){let t={x:v(r,"x","expm1")};return N.runKernel(Ma,t)}var Z1=A({expm1_:UX});function KX(r,e){let t=v(r,"x","tile","string_or_numeric");D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let n={x:t},o={reps:e};return N.runKernel(Dn,n,o)}var on=A({tile_:KX});function VX(r,e,t,n="float32"){e==null&&(e=r);let o=Ie([r,e],n),s=r<=e?r:e;for(let i=0;i<s;++i)o.set(1,i,i);let a=F(o.toTensor(),[r,e]);if(t==null)return a;if(t.length===1)return on(yr(a,0),[t[0],1,1]);if(t.length===2)return on(yr(yr(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return on(yr(yr(yr(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var op=A({eye_:VX});function HX(r){let t={x:v(r,"x","floor","float32")};return N.runKernel(wo,t)}var gl=A({floor_:HX});function qX(r,e,t=0,n=0){let o=v(r,"x","gather"),s=v(e,"indices","gather","int32"),a={x:o,indices:s},i={axis:t,batchDims:n};return N.runKernel(ks,a,i)}var bl=A({gather_:qX});function jX(r,e){let t=v(r,"a","greater","string_or_numeric"),n=v(e,"b","greater","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ea,o)}var Qt=A({greater_:jX});function XX(r,e){let t=v(r,"a","greaterEqual","string_or_numeric"),n=v(e,"b","greaterEqual","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(_o,o)}var Xn=A({greaterEqual_:XX});function YX(r){let t={x:v(r,"x","isFinite")};return N.runKernel(Fa,t)}var Q1=A({isFinite_:YX});function ZX(r){let t={x:v(r,"x","isInf")};return N.runKernel(La,t)}var J1=A({isInf_:ZX});function QX(r){let t={x:v(r,"x","isNaN")};return N.runKernel(Mo,t)}var e2=A({isNaN_:QX});function JX(r,e=.2){let n={x:v(r,"x","leakyRelu")},o={alpha:e};return N.runKernel(Ro,n,o)}var pc=A({leakyRelu_:JX});function eY(r,e){let t=v(r,"a","less","string_or_numeric"),n=v(e,"b","less","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel($a,o)}var ay=A({less_:eY});function tY(r,e){let t=v(r,"a","lessEqual","string_or_numeric"),n=v(e,"b","lessEqual","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ba,o)}var Hs=A({lessEqual_:tY});function t2(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:e,num:t};return N.runKernel(Fm,{},n)}function rY(r,e=5,t=1,n=1,o=.5){let s=v(r,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(Zi(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,i=!1;s.rank===3&&(i=!0,a=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:a},l={depthRadius:e,bias:t,alpha:n,beta:o},p=N.runKernel(qu,u,l);return i?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var r2=A({localResponseNormalization_:rY});function nY(r){let t={x:v(r,"x","log","float32")};return N.runKernel(Po,t)}var jr=A({log_:nY});function oY(r){let t={x:v(r,"x","log1p")};return N.runKernel(Qi,t)}var mc=A({log1p_:oY});function sY(r){return D(Ci(r),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let n=v(e,"x","tf.grad","string_or_numeric"),o=t!=null?v(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(n),[n],o);return o!=null&&Bt(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),uy(a),a[0]})}}function aY(r){return D(Ci(r),()=>"The f passed in grads(f) must be a function"),(e,t)=>{D(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=uu(e,"args","tf.grads","string_or_numeric"),o=t!=null?v(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(...n),n,o);return o!=null&&Bt(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),uy(a),a})}}function iY(r){return D(Ci(r),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{D(e instanceof We,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(t==null||t instanceof We,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=N.gradients(()=>r(e),[e],t);return uy(n),{grad:n[0],value:o}}}function uY(r){return D(Ci(r),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{D(Array.isArray(e)&&e.every(o=>o instanceof We),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(t==null||t instanceof We,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=N.gradients(()=>r(...e),e,t);return t!=null&&Bt(n.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),uy(n.grads),n}}function iy(r,e){D(Ci(r),()=>"The f passed in variableGrads(f) must be a function"),D(e==null||Array.isArray(e)&&e.every(l=>l instanceof au),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let l in N.registeredVariables)e.push(N.registeredVariables[l])}let n=t?e.filter(l=>!l.trainable):null,o=e.length;e=e.filter(l=>l.trainable),D(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:a,grads:i}=N.gradients(r,e,null,s);D(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let u={};return e.forEach((l,p)=>{i[p]!=null&&(u[l.name]=i[p])}),n?.forEach(l=>u[l.name]=null),{value:a,grads:u}}function bn(r){return N.customGrad(r)}function uy(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function lY(r){let t={x:v(r,"x","softplus")};return N.runKernel(nu,t)}var cu=A({softplus_:lY});function pY(r){let e=v(r,"x","logSigmoid");return bn(n=>({value:tt(cu(tt(n))),gradFunc:a=>P(a,Pn(tt(n)))}))(e)}var n2=A({logSigmoid_:pY});function mY(r,e){let t=v(r,"a","sub"),n=v(e,"b","sub");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(as,o)}var me=A({sub_:mY});function cY(r,e=-1){let t=v(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return bn((o,s)=>{let i=qr(o,e,!0),u=me(o,i),l=me(re(u,"float32"),jr(be(br(u),e,!0)));return s([l]),{value:l,gradFunc:(m,c)=>{let[d]=c,f=!0,h=br(d);return me(m,P(be(m,e,f),h))}}})(t)}var ly=A({logSoftmax_:cY});function dY(r,e=null,t=!1){let n=v(r,"x","logSumExp"),o=gr(e,n.shape),s=qr(n,o,!0),a=me(n,s),i=br(a),u=be(i,o),l=jr(u),p=Z(F(s,l.shape),l);if(t){let m=Vs(p.shape,o);return F(p,m)}return p}var py=A({logSumExp_:dY});function fY(r,e){let t=v(r,"a","logicalAnd","bool"),n=v(e,"b","logicalAnd","bool");Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Oa,o)}var sn=A({logicalAnd_:fY});function hY(r){let t={x:v(r,"x","logicalNot","bool")};return N.runKernel(za,t)}var cc=A({logicalNot_:hY});function gY(r,e){let t=v(r,"a","logicalOr","bool"),n=v(e,"b","logicalOr","bool");Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ji,o)}var my=A({logicalOr_:gY});function bY(r,e){let t=v(r,"a","logicalXor","bool"),n=v(e,"b","logicalXor","bool");return Oe(t.shape,n.shape),sn(my(r,e),cc(sn(r,e)))}var o2=A({logicalXor_:bY});var cy=2147483648;function yY(r,e,t="left"){let n=v(r,"sortedSequence","searchSorted"),o=v(e,"values","searchSorted"),s=n.shape[n.shape.length-1],a=o.shape[o.shape.length-1],i=F(n,[-1,s]),u=F(o,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(nt(u.shape)>=cy)throw new Error(`values tensor size must less than ${cy}`);if(i.shape[1]>=cy)throw new Error(`trailing dim_size must less than ${cy} for int32 output type, was ${i.shape[1]}`);let l={sortedSequence:i,values:u},p={side:t};return N.runKernel(Hm,l,p)}var Dh=A({searchSorted_:yY});function s2(r,e){return Dh(r,e,"left")}function TY(r,e,t,n,o){let s=v(r,"x","maxPool"),a=1,i=s,u=!1;s.rank===3&&(u=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),D(Or(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),_t("maxPool",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},m=N.runKernel(Lo,l,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var dc=A({maxPool_:TY});function xY(r,e=[1,1,1],t,n,o,s="NDHWC"){let a=v(r,"x","maxPool3d"),i=a,u=!1;a.rank===4&&(u=!0,i=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),_t("maxPool3d",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},m=N.runKernel(ju,l,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var dy=A({maxPool3d_:xY});function IY(r,e,t,n,o=!1){let a={x:v(r,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:n,includeBatchInIndex:o},u=N.runKernel(Om,a,i);return{result:u[0],indexes:u[1]}}var a2=A({maxPoolWithArgmax_:IY});function CY(r,e){let t=v(r,"a","maximum"),n=v(e,"b","maximum");[t,n]=Ye(t,n),t.dtype==="bool"&&(t=re(t,"int32"),n=re(n,"int32")),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Fo,o)}var ds=A({maximum_:CY});function kY(r,e=null,t=!1){let o={x:v(r,"x","mean")},s={axis:e,keepDims:t};return N.runKernel($o,o,s)}var Lt=A({mean_:kY});function Ct(r,e="float32"){if(Ut(r),e==="complex64"){let n=Ct(r,"float32"),o=Ct(r,"float32");return Mn(n,o)}let t=Cm(nt(r),e);return N.makeTensor(t,r,e)}function Tr(r,e="float32"){if(Ut(r),e==="complex64"){let n=Tr(r,"float32"),o=Ct(r,"float32");return Mn(n,o)}let t=oh(nt(r),e);return N.makeTensor(t,r,e)}function i2(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=v(r,"x","meshgrid",r instanceof We?r.dtype:"float32");if(e===void 0)return[n];let o=v(e,"y","meshgrid",e instanceof We?e.dtype:"float32"),s=nt(n.shape),a=nt(o.shape);return t==="xy"?(n=F(n,[1,-1]),o=F(o,[-1,1]),[Ue(Tr([a,1],n.dtype),n),Ue(o,Tr([1,s],o.dtype))]):(n=F(n,[-1,1]),o=F(o,[1,-1]),[Ue(n,Tr([1,a],n.dtype)),Ue(Tr([s,1],o.dtype),o)])}function SY(r,e){let t=v(r,"a","minimum"),n=v(e,"b","minimum");[t,n]=Ye(t,n),t.dtype==="bool"&&(t=re(t,"int32"),n=re(n,"int32")),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Oo,o)}var yl=A({minimum_:SY});function vY(r,e,t){D(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let n=v(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let i=0;i<n.rank;i++)D(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(e[i][0]>=0&&e[i][0]<=n.shape[i]-o&&e[i][1]>=0&&e[i][1]<=n.shape[i]-o,()=>`Padding in dimension ${i} cannot be greater than or equal to ${n.shape[i]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:e,mode:t},a={x:n};return N.runKernel(zo,a,s)}var u2=A({mirrorPad_:vY});function AY(r,e){let t=v(r,"a","mod"),n=v(e,"b","mod");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Ga,o)}var l2=A({mod_:AY});function wY(r,e=null,t=!1){r=v(r,"x","moments");let n=gr(e,r.shape),o=Lt(r,n,t),s=o.shape;t||(s=Vs(o.shape,n));let a=He(me(re(r,"float32"),F(o,s))),i=Lt(a,n,t);return{mean:o,variance:i}}var sp=A({moments_:wY});function NY(r,e,t,n){let o=v(e,"data","multiRNNCell"),s=uu(t,"c","multiRNNCell"),a=uu(n,"h","multiRNNCell"),i=o,u=[];for(let m=0;m<r.length;m++){let c=r[m](i,s[m],a[m]);u.push(c[0]),u.push(c[1]),i=c[1]}let l=[],p=[];for(let m=0;m<u.length;m+=2)l.push(u[m]),p.push(u[m+1]);return[l,p]}var p2=A({multiRNNCell_:NY});function DY(r,e,t,n=!1){let o=v(r,"logits","multinomial"),s=o.size,a=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();let u={logits:a===1?F(o,[1,-1]):o},l={numSamples:e,seed:t,normalized:n},p=N.runKernel(zm,u,l);return a===1?F(p,[p.size]):p}var m2=A({multinomial_:DY});function _Y(r,e){let t=v(r,"a","notEqual","string_or_numeric"),n=v(e,"b","notEqual","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Wa,o)}var du=A({notEqual_:_Y});function MY(r){let t={x:v(r,"x","onesLike")};return N.runKernel(vs,t)}var zr=A({onesLike_:MY});function RY(r,e){let t=v(r,"v1","outerProduct"),n=v(e,"v2","outerProduct");D(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);let o=F(t,[-1,1]),s=F(n,[1,-1]);return Ue(o,s)}var c2=A({outerProduct_:RY});function PY(r,e,t=0){let n=v(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:n};return N.runKernel(Uo,s,o)}var Yn=A({pad_:PY});function EY(r,e,t=0){return D(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Yn(r,[e],t)}var d2=A({pad1d_:EY});function FY(r,e,t=0){return D(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yn(r,e,t)}var f2=A({pad2d_:FY});function LY(r,e,t=0){return D(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yn(r,e,t)}var h2=A({pad3d_:LY});function $Y(r,e,t=0){return D(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yn(r,e,t)}var g2=A({pad4d_:$Y});function BY(r,e,t){let n=v(r,"x","spaceToBatchND");D(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),D(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),D(n.shape.reduce((a,i,u)=>u>0&&u<=e.length?a&&(i+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:n},s={blockShape:e,paddings:t};return N.runKernel(_s,o,s)}var fc=A({spaceToBatchND_:BY});function OY(r,e,t,n,o,s,a){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let i=v(r,"x","maxPool"),u=i,l=!1;i.rank===3&&(l=!0,u=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(Or(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let p=iA(u.shape,e,s,o,n),m=[p.dilationHeight,p.dilationWidth],c;n==="same"?c=GY([p.filterHeight,p.filterWidth],m):c=[[0,0],[0,0]];let d=m[0]===1&&m[1]===1,[f,h]=zY([p.inHeight,p.inWidth],m,c),g=d?n:"valid",b=d?u:fc(u,m,f),x=(t==="avg"?()=>ac(b,e,s,g,a):()=>dc(b,e,s,g,a))(),I=d?x:ic(x,m,h);return l?F(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function zY(r,e,t){let n=t.map(p=>p[0]),o=t.map(p=>p[1]),s=r.concat(n,o),a=e.map((p,m)=>(p-s[m]%p)%p),i=o.map((p,m)=>p+a[m]),u=e.map((p,m)=>[n[m],i[m]]),l=e.map((p,m)=>[0,a[m]]);return[u,l]}function GY(r,e){let n=r.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),o=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-o[i]);return n.map((a,i)=>[o[i],s[i]])}var b2=A({pool_:OY});function WY(r,e){let t=v(r,"x","prelu"),n=v(e,"alpha","prelu"),o={x:t,alpha:n};return N.runKernel(Vo,o)}var hc=A({prelu_:WY});function UY(r,e=null,t=!1){let n=v(r,"x","prod");n.dtype==="bool"&&(n=re(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(Ho,o,s)}var y2=A({prod_:UY});function KY(r,e,t,n){let o=r.map((p,m)=>v(p,`tensors${m}`,"raggedGather","int32")),s=v(e,"paramsDenseValues","raggedGather"),a=v(t,"indices","raggedGather","int32"),i={paramsNestedSplits:o,paramsDenseValues:s,indices:a},u={outputRaggedRank:n},l=N.runKernel(Gm,i,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}var T2=A({raggedGather_:KY});function VY(r,e,t){let n=v(r,"starts","raggedRange"),o=v(e,"limits","raggedRange",n.dtype),s=v(t,"deltas","raggedRange",n.dtype),a={starts:n,limits:o,deltas:s},i=N.runKernel(Wm,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}var x2=A({raggedRange_:VY});function HY(r,e,t,n,o){let s=v(r,"shape","raggedTensorToTensor","int32"),a=v(e,"values","raggedTensorToTensor"),i=v(t,"defaultValue","raggedTensorToTensor",a.dtype),u=n.map((m,c)=>v(m,`tensors${c}`,"raggedTensorToTensor","int32")),l={shape:s,values:a,defaultValue:i,rowPartitionTensors:u},p={rowPartitionTypes:o};return N.runKernel(Um,l,p)}var I2=A({raggedTensorToTensor_:HY});function qY(r,e,t){Ut(r);let n=nt(r),o=null;if(t==null||t==="float32")o=new Float32Array(n);else if(t==="int32")o=new Int32Array(n);else if(t==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<n;s++)o[s]=e();return N.makeTensor(o,r,t)}var C2=A({rand_:qY});var by=Wl(_h());var ip=class{mean;stdDev;nextVal;dtype;truncated;upper;lower;random;constructor(e,t,n,o,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=by.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,n=!1;for(;!n;){let o,s,a;do o=2*this.random()-1,s=2*this.random()-1,a=o*o+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*o*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},hy=class{alpha;beta;d;c;dtype;randu;randn;constructor(e,t,n,o){this.alpha=e,this.beta=1/t,this.dtype=n;let s=o||Math.random();this.randu=by.alea(s.toString()),this.randn=new ip(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,o,s,a;for(;;){do o=this.randn.nextValue(),a=1+this.c*o;while(a<=0);if(a*=a*a,e=o*o,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},gy=class{min;range;random;dtype;constructor(e=0,t=1,n,o){if(this.min=e,this.range=t-e,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=by.alea(o)}canReturnFloat=()=>this.dtype==null||this.dtype==="float32";convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function eZ(r,e,t=1,n="float32",o){if(Ut(r),t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new hy(e,t,n,o),a=Ie(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var O2=A({randomGamma_:eZ});function tZ(r,e=0,t=1,n,o){if(Ut(r),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new ip(e,t,n,!1,o),a=Ie(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var up=A({randomNormal_:tZ});function rZ(r,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return up(r,0,1,e,t)}var z2=A({randomStandardNormal_:rZ});function nZ(r,e=0,t=1,n="float32",o){Ut(r);let s=Ie(r,n),a=new gy(e,t,null,o);for(let i=0;i<s.values.length;i++)s.values[i]=a.nextValue();return s.toTensor()}var Pi=A({randomUniform_:nZ});function Ei(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:e,step:t,dtype:n};return N.runKernel(Ai,{},o)}function oZ(r){let t={x:v(r,"x","reciprocal")};return N.runKernel(qo,t)}var G2=A({reciprocal_:oZ});function sZ(r){let t={x:v(r,"x","relu")};return N.runKernel(jo,t)}var an=A({relu_:sZ});function aZ(r){let t={x:v(r,"x","relu6")};return N.runKernel(Zo,t)}var yy=A({relu6_:aZ});function iZ(r,e){let n={x:v(r,"x","reverse")},o={dims:e};return N.runKernel(Qo,n,o)}var _r=A({reverse_:iZ});function uZ(r){let e=v(r,"x","reverse");return D(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),_r(e,0)}var W2=A({reverse1d_:uZ});function lZ(r,e){let t=v(r,"x","reverse");return D(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),_r(t,e)}var U2=A({reverse2d_:lZ});function pZ(r,e){let t=v(r,"x","reverse");return D(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),_r(t,e)}var K2=A({reverse3d_:pZ});function mZ(r,e){let t=v(r,"x","reverse");return D(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),_r(t,e)}var V2=A({reverse4d_:mZ});function cZ(r){let t={x:v(r,"x","round")};return N.runKernel(Va,t)}var Ty=A({round_:cZ});function dZ(r){let t={x:v(r,"x","rsqrt","float32")};return N.runKernel(Jo,t)}var xy=A({rsqrt_:dZ});function fZ(r){let t={x:v(r,"x","selu")};return N.runKernel(tu,t)}var Iy=A({selu_:fZ});function hZ(r,e,t,n,o,s=[1,1],a="NHWC"){let i=v(r,"x","separableConv2d"),u=v(e,"depthwiseFilter","separableConv2d"),l=v(t,"pointwiseFilter","separableConv2d"),p=i,m=!1;if(i.rank===3&&(m=!0,p=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),D(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let c=u.shape[2],d=u.shape[3];D(l.shape[2]===c*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${c*d}, but got ${l.shape[2]}.`);let f=fl(p,u,n,o,a,s),g=cs(f,l,1,"valid",a);return m?F(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Cy=A({separableConv2d_:hZ});async function gZ(r,e){let t=v(r,"x","setdiff1d"),n=v(e,"y","setdiff1d");D(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),D(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),D(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await t.data(),s=await n.data(),a=new Set(s),i=0;for(let p=0;p<o.length;p++)a.has(o[p])||i++;let u=new bt([i],t.dtype),l=new bt([i],"int32");for(let p=0,m=0;p<o.length;p++)a.has(o[p])||(u.values[m]=o[p],l.values[m]=p,m++);return[u.toTensor(),l.toTensor()]}var H2=gZ;function bZ(r){let t={x:v(r,"x","sign")};return N.runKernel(ru,t)}var q2=A({sign_:bZ});function yZ(r){let t={x:v(r,"x","sin","float32")};return N.runKernel(es,t)}var ky=A({sin_:yZ});function TZ(r){let t={x:v(r,"x","sinh")};return N.runKernel(qa,t)}var Sy=A({sinh_:TZ});function xZ(r,e,t){let n=v(r,"x","slice1d");return D(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),ze(n,[e],[t])}var gc=A({slice1d_:xZ});function IZ(r,e,t){let n=v(r,"x","slice2d");return D(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var Mh=A({slice2d_:IZ});function CZ(r,e,t){let n=v(r,"x","slice3d");return D(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var bc=A({slice3d_:CZ});function kZ(r,e,t){let n=v(r,"x","slice4d");return D(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var lp=A({slice4d_:kZ});function SZ(r,e=-1){let t=v(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let n={logits:t},o={dim:e};return N.runKernel(os,n,o)}var yc=A({softmax_:SZ});function vZ(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(Pm,e)}var Tc=A({fft_:vZ});function AZ(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(Em,e)}var pp=A({ifft_:AZ});function wZ(r){let e=r.shape[r.shape.length-1],t=r.size/e,n;if(e<=2){let o=F(r,[t,e]);n=pp(o)}else{let o=[t,2*(e-1)],s=F(mu(r),[t,e]),a=F(ll(r),[t,e]),i=_r(ze(s,[0,1],[t,e-2]),1),u=P(_r(ze(a,[0,1],[t,e-2]),1),ge(-1)),l=ct([s,i],1),p=ct([a,u],1),m=F(Mn(l,p),[o[0],o[1]]);n=pp(m)}if(n=mu(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=F(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var vy=A({irfft_:wZ});function NZ(r,e,t=0){let o={x:v(r,"x","split")},s={numOrSizeSplits:e,axis:t};return N.runKernel(Ms,o,s)}var Mr=A({split_:NZ});function DZ(r,e){D(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1],n=r.size/t,o;if(e!=null&&e<t){let f=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=e,o=ze(r,f,h),t=e}else if(e!=null&&e>t){let f=r.shape.map(h=>h);f[r.shape.length-1]=e-t,o=ct([r,Ct(f)],r.shape.length-1),t=e}else o=r;let s=we(o),a=F(Mn(o,s),[n,t]),i=Tc(a),u=Math.floor(t/2)+1,l=mu(i),p=ll(i),m=Mr(l,[u,t-u],l.shape.length-1),c=Mr(p,[u,t-u],p.shape.length-1),d=o.shape.slice();return d[o.shape.length-1]=u,F(Mn(m[0],c[0]),d)}var xc=A({rfft_:DZ});function _Z(r,e){let t=v(r,"a","squaredDifference"),n=v(e,"b","squaredDifference");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n},s={};return N.runKernel(ss,o,s)}var Ay=A({squaredDifference_:_Z});function MZ(r,e){let t=v(r,"x","squeeze","string_or_numeric");return F(t,gv(t.shape,e).newShape)}var qs=A({squeeze_:MZ});function RZ(r,e=0){let t=uu(r,"tensors","stack","string_or_numeric");D(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&D(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let n=t,o={axis:e};return N.runKernel(As,n,o)}var cr=A({stack_:RZ});function PZ(r,e=0){let n={x:v(r,"x","step")},o={alpha:e};return N.runKernel(Es,n,o)}var Fi=A({step_:PZ});function EZ(r,e,t,n,o=0,s=0,a=0,i=0,u=0){let p={x:v(r,"x","stridedSlice","string_or_numeric")},m={begin:e,end:t,strides:n,beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};return N.runKernel(ja,p,m)}var j2=A({stridedSlice_:EZ});function FZ(r){let t={x:v(r,"x","tan","float32")};return N.runKernel(is,t)}var X2=A({tan_:FZ});function Jt(r,e){mo(r);let t=Vr(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return hn(r,null,t,e)}function ei(r,e,t){if(mo(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Vr(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return hn(r,e,n,t)}function Y2(r,e,t){if(mo(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Vr(r,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return hn(r,e,n,t)}function Z2(r,e,t){if(mo(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Vr(r,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return hn(r,e,n,t)}function Q2(r,e,t){if(mo(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Vr(r,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,hn(r,e,n,t)}function LZ(r,e=1,t=!0){let n=v(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:n},a={k:e,sorted:t},[i,u]=N.runKernel(Xa,s,a);return{values:i,indices:u}}var J2=A({topk_:LZ});function $Z(r,e=0,t=1,n,o){if(Ut(r),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new ip(e,t,n,!0,o),a=Ie(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var Ic=A({truncatedNormal_:$Z});function BZ(r,e=0){let t=v(r,"x","unique","string_or_numeric");D(t.rank>0,()=>"The input tensor must be at least 1D");let n={x:t},o={axis:e},[s,a]=N.runKernel(qm,n,o);return{values:s,indices:a}}var eM=A({unique_:BZ});function OZ(r,e,t){let n=v(r,"x","unsortedSegmentSum"),o=v(e,"segmentIds","unsortedSegmentSum","int32");D(Zi(t),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},a={numSegments:t};return N.runKernel(rl,s,a)}var wy=A({unsortedSegmentSum_:OZ});function zZ(r,e=0){let t=v(r,"x","unstack","string_or_numeric");D(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let n={value:t},o={axis:e};return N.runKernel(Rs,n,o)}var Rr=A({unstack_:zZ});function tM(r,e){return Dh(r,e,"right")}function Ny(r,e=!0,t,n){return N.makeVariable(r,e,t,n)}function Dy(r,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let n=Ie(r,"int32"),o=Ie([t.length,r.length],"int32");for(let s=0;s<t.length;s++){let a=n.indexToLoc(t[s]),i=s*r.length;o.values.set(a,i)}return o.toTensor()}async function GZ(r){let e=v(r,"condition","whereAsync","bool"),t=await e.data(),n=Dy(e.shape,t);return r!==e&&e.dispose(),n}var _y=GZ;async function WZ(r,e,t){let n=v(r,"tensor","boolMask"),o=v(e,"mask","boolMask","bool"),s=t??0,a=o.rank,i=n.shape;D(a>0,()=>"mask cannot be scalar"),Bt(i.slice(s,s+a),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+a;h++)u*=i[h];let l=i.slice(0,s).concat([u],i.slice(s+a)),p=F(n,l),m=F(o,[-1]),c=await _y(m),d=qs(c,[1]),f=bl(p,d,s);return r!==n&&n.dispose(),e!==o&&o.dispose(),d.dispose(),p.dispose(),m.dispose(),c.dispose(),f}var UZ=WZ;function KZ(r,e,t,n,o=!0){let s=v(r,"v","movingAverage"),a=v(e,"x","movingAverage"),i=v(t,"decay","movingAverage");Pv(s,a),D(Wn(s.shape,a.shape),()=>"Shape mismatch in v and x");let u=ge(1),l=me(u,i),p=P(me(a,s),l);if(o){D(n!=null,()=>"When using zeroDebias: true, step is required.");let m=v(n,"step","movingAverage");p=fe(p,me(u,jn(i,m)))}return Z(s,p)}var VZ=A({movingAverage_:KZ});function HZ(r,e,t){Ut(t);let n=v(r,"indices","scatterND","int32"),o=v(e,"updates","scatterND");Ob(o,n,t);let s={indices:n,updates:o},a={shape:t};return N.runKernel(Ha,s,a)}var qZ=A({scatterND_:HZ});function rM(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let a=e.size;if(!(e.rank===0||e.rank===1&&a===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function XZ(r,e,t,n=0){Ut(t);let o=v(r,"sparseIndices","sparseToDense","int32"),s=v(e,"sparseValues","sparseToDense","string_or_numeric"),a=v(n,"defaultValue","sparseToDense",s.dtype);rM(o,s,t,a);let i={sparseIndices:o,sparseValues:s,defaultValue:a},u={outputShape:t};return N.runKernel(Ju,i,u)}var YZ=A({sparseToDense_:XZ});function ZZ(r,e){let t=v(e,"indices","gatherND","int32"),o={params:v(r,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(Pa,o)}var QZ=A({gatherND_:ZZ});function nM(r,e){if(e==null)return r.shape.slice();if(Wn(r.shape,e))return e;if(r.shape.length===e.length){let t=[];for(let n=0;n<r.shape.length;n++)e[n]==null&&r.shape[n]!=null?t.push(r.shape[n]):t.push(e[n]);return t}return e}function JZ(r,e,t,n){let o=v(r,"x","dropout");if(D(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),D(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof We?o.clone():o;let s=nM(o,t),a=1-e,i=fe(gl(Z(Pi(s,0,1,"float32",n),a)),a);return P(o,i)}var TA=A({dropout_:JZ});function xA(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Rh(r,e,t){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let a=2*Math.PI*s/(r+n-1);o[s]=e-t*Math.cos(a)}return Jt(o,"float32")}async function eQ(r,e,t=1){let n=v(r,"predictions","inTopK"),o=v(e,"targets","inTopK");D(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),D(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Bt(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];D(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let a=await n.data(),i=await o.data(),[u,l]=[a.length/s,s],p=bv("bool",u);for(let m=0;m<u;m++){let c=m*l,d=a.subarray(c,c+l),f=[];for(let h=0;h<d.length;h++)f.push({value:d[h],index:h});f.sort((h,g)=>g.value-h.value),p[m]=0;for(let h=0;h<t;h++)if(f[h].index===i[m]){p[m]=1;break}}return r!==n&&n.dispose(),e!==o&&o.dispose(),mr(p,o.shape,"bool")}var tQ=eQ;var Tl={};qe(Tl,{conv2d:()=>oM,depthwiseConv2d:()=>sM,matMul:()=>aM});function rQ(r,e,t,n,o,s="NHWC",a){let i=r;r.rank===3&&(i=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=F(e,[1,e.shape[0],e.shape[1],e.shape[2]])),D(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),D(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),D(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let l=s==="NHWC"?i.shape[3]:i.shape[1],p=s==="NHWC"?u.shape[3]:u.shape[1];D(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),D(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),_t("conv2dDerFilter",o,a);let m={x:i,dy:u},c={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,filterShape:t};return N.runKernel(Am,m,c)}var Cc=A({conv2DBackpropFilter_:rQ});function mp(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return P(r,Fi(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function cp(r,e){let t=e,n=vt(r.shape,e.shape);return n.length>0&&(t=be(t,n)),F(t,r.shape)}function dp(r,e,t,n){if(e==="linear")return r;if(e==="relu")return an(r);if(e==="elu")return hl(r);if(e==="relu6")return yy(r);if(e==="prelu")return hc(r,t);if(e==="leakyrelu")return pc(r,n);if(e==="sigmoid")return Pn(r);throw new Error(`Unknown fused activation ${e}.`)}var fp=(r,e)=>!(r>0)||e==="linear";function nQ({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(u=u||"linear",fp(N.state.gradientDepth,u)===!1){D(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let w=cs(r,e,t,n,o,s,a);return i!=null&&(w=Z(w,i)),dp(w,u,l,p)}let m=v(r,"x","conv2d","float32"),c=v(e,"filter","conv2d","float32"),d=m,f=!1;m.rank===3&&(f=!0,d=F(m,[1,m.shape[0],m.shape[1],m.shape[2]])),D(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),D(c.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${c.rank}.`),_t("fused conv2d",n,a);let h=o==="NHWC"?d.shape[3]:d.shape[1];D(c.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${c.shape[2]}.`),D(Or(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let g=tp(d.shape,c.shape,t,s,n,a),b;i!=null&&(b=v(i,"bias","fused conv2d"),[b]=Ye(b,m),o==="NHWC"?Oe(g.outShape,b.shape):(D(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),D(b.shape.length===0||b.shape[0]===g.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let T;if(l!=null){let w=l.shape;if(D(w.length<=1||w.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${w.length}.`),w.length===1)D(w[0]===1||w[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the number of output channels (${g.outChannels}).`);else if(w.length===3)try{Oe(w,g.outShape)}catch{let M=`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(M)}T=v(l,"prelu weights","fused conv2d")}let x=(w,_)=>{D(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[M,R,E,O]=_,G=mp(w,E,u);D(ps(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let W=uc(R.shape,G,M,t,n),H=Cc(R,G,M.shape,t,n),U=[W,H];if(O!=null){let V=cp(O,G);U.push(V)}return U},I={x:d,filter:c,bias:b,preluActivationWeights:T},k={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return i==null?bn((_,M,R)=>{let E=N.runKernel(Ls,I,k);return R([M,_,E]),f&&(E=F(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(d,c):bn((_,M,R,E)=>{let O=N.runKernel(Ls,I,k);return E([M,_,O,R]),f&&(O=F(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:x}})(d,c,b)}var oM=A({fusedConv2d_:nQ});function oQ(r,e,t,n,o,s=[1,1],a){let i=r;r.rank===3&&(i=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=F(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={x:i,dy:u},p={strides:n,pad:o,dimRoundingMode:a,dilations:s,filterShape:t};return N.runKernel(Dm,l,p)}var My=A({depthwiseConv2dNativeBackpropFilter_:oQ});function sQ(r,e,t,n,o,s=[1,1],a){let i=e,u=!1;e.rank===3&&(u=!0,i=F(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={dy:i,filter:t},p={strides:n,pad:o,dimRoundingMode:a,dilations:s,inputShape:r},m=N.runKernel(_m,l,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Ry=A({depthwiseConv2dNativeBackpropInput_:sQ});function aQ({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(fp(N.state.gradientDepth,u)===!1){let k=fl(r,e,t,n,o,s,a);return i!=null&&(k=Z(k,i)),dp(k,u,l,p)}let m=v(r,"x","depthwiseConv2d","float32"),c=v(e,"filter","depthwiseConv2d","float32"),d=m,f=!1;m.rank===3&&(f=!0,d=F(m,[1,m.shape[0],m.shape[1],m.shape[2]])),D(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),D(c.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`),D(d.shape[3]===c.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),s==null&&(s=[1,1]),D(Or(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),_t("fused depthwiseConv2d",n,a);let h=tp(d.shape,c.shape,t,s,n,a,!0),g;i!=null&&(g=v(i,"bias","fused conv2d"),[g]=Ye(g,m),Oe(h.outShape,g.shape));let b;l!=null&&(b=v(l,"prelu weights","fused depthwiseConv2d"));let T=(k,w)=>{D(ps(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[_,M,R,E]=w,O=mp(k,R,u),G=Ry(M.shape,O,_,t,n,s,a),W=My(M,O,_.shape,t,n,s,a);if(E!=null){let H=cp(g,O);return[G,W,H]}return[G,W]},x={x:d,filter:c,bias:g,preluActivationWeights:b},I={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return i==null?bn((w,_,M)=>{let R=N.runKernel($s,x,I);return M([_,w,R]),f&&(R=F(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:T}})(d,c):bn((w,_,M,R)=>{let E=N.runKernel($s,x,I);return R([_,w,E,M]),f&&(E=F(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:T}})(d,c,g)}var sM=A({fusedDepthwiseConv2d_:aQ});function iQ({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(fp(N.state.gradientDepth,s)===!1){let O=Ue(r,e,t,n);return o!=null&&(O=Z(O,o)),dp(O,s,a,i)}let u=v(r,"a","fused matMul"),l=v(e,"b","fused matMul");[u,l]=Ye(u,l);let p=t?u.shape[u.rank-2]:u.shape[u.rank-1],m=n?l.shape[l.rank-1]:l.shape[l.rank-2],c=t?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=nt(f),b=nt(h);D(p===m,()=>`Error in fused matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${n} must match.`);let x=Oe(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([c,d]),I=t?F(u,[g,p,c]):F(u,[g,c,p]),k=n?F(l,[b,d,m]):F(l,[b,m,d]),w;o!=null&&(w=v(o,"bias","fused matMul"),[w]=Ye(w,u),Oe(x,w.shape));let _;a!=null&&(_=v(a,"prelu weights","fused matMul"));let M=(O,G)=>{let[W,H,U,V]=G,Y=mp(F(O,U.shape),U,s),j,te;if(!t&&!n?(j=Ue(Y,H,!1,!0),te=Ue(W,Y,!0,!1)):!t&&n?(j=Ue(Y,H,!1,!1),te=Ue(Y,W,!0,!1)):t&&!n?(j=Ue(H,Y,!1,!0),te=Ue(W,Y,!1,!1)):(j=Ue(H,Y,!0,!0),te=Ue(Y,W,!0,!0)),o!=null){let ne=cp(V,Y);return[j,te,ne]}else return[j,te]},R={a:I,b:k,bias:w,preluActivationWeights:_},E={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:i};return o==null?bn((G,W,H)=>{let U=N.runKernel(Fs,R,E);return H([G,W,U]),{value:F(U,x),gradFunc:M}})(I,k):bn((G,W,H,U)=>{let V=N.runKernel(Fs,R,E);return U([G,W,V,H]),{value:F(V,x),gradFunc:M}})(I,k,w)}var aM=A({fusedMatMul_:iQ});function uQ(r){return Rh(r,.54,.46)}var iM=A({hammingWindow_:uQ});function lQ(r){return Rh(r,.5,.5)}var Py=A({hannWindow_:lQ});function pQ(r,e,t,n=!1,o=0){let s=0,a=[];for(;s+e<=r.size;)a.push(ze(r,s,e)),s+=t;if(n)for(;s<r.size;){let i=s+e-r.size,u=ct([ze(r,s,e-i),Ks([i],o)]);a.push(u),s+=t}return a.length===0?ei([],[0,e]):F(ct(a),[a.length,e])}var Ey=A({frame_:pQ});function mQ(r,e,t,n,o=Py){n==null&&(n=xA(e));let s=Ey(r,e,t),a=P(s,o(e));return xc(a,n)}var uM=A({stft_:mQ});function cQ(r,e,t,n,o="bilinear",s=0){let a=v(r,"image","cropAndResize"),i=v(e,"boxes","cropAndResize","float32"),u=v(t,"boxInd","cropAndResize","int32"),l=i.shape[0];D(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),D(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),D(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),D(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),D(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),D(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let p={image:a,boxes:i,boxInd:u},m={method:o,extrapolationValue:s,cropSize:n};return N.runKernel(wa,p,m)}var lM=A({cropAndResize_:cQ});function dQ(r){let e=v(r,"image","flipLeftRight","float32");D(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return N.runKernel(Ra,t,{})}var pM=A({flipLeftRight_:dQ});function fQ(r){let e=v(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];D(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),D(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,on(e,o)}var mM=A({grayscaleToRGB_:fQ});function hQ(r,e,t=0,n=.5){let o=v(r,"image","rotateWithOffset","float32");D(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},a={radians:e,fillValue:t,center:n};return N.runKernel(Za,s,a)}var cM=A({rotateWithOffset_:hQ});function js(r,e,t,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let a=r.shape[0];return t=Math.min(t,a),D(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),D(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),D(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),D(e.rank===1,()=>"scores must be a 1D tensor"),D(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function gQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppression","float32"),a=v(e,"scores","nonMaxSuppression","float32"),i=js(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u={maxOutputSize:t,iouThreshold:n,scoreThreshold:o};return N.runKernel(Ua,{boxes:s,scores:a},u)}var dM=A({nonMaxSuppression_:gQ});function fM(r,e,t){let n=bQ(r,e,t),o=n<0?-(n+1):n;r.splice(o,0,e)}function bQ(r,e,t){return TQ(r,e,t||yQ)}function yQ(r,e){return r>e?1:r<e?-1:0}function TQ(r,e,t){let n=0,o=r.length,s=0,a=!1;for(;n<o;){s=n+(o-n>>>1);let i=t(e,r[s]);i>0?n=s+1:(o=s,a=!i)}return a?n:-n-1}function Fy(r,e,t,n,o){return IA(r,e,t,n,o,0)}function Ly(r,e,t,n,o,s){return IA(r,e,t,n,o,0,!1,s,!0)}function $y(r,e,t,n,o,s){return IA(r,e,t,n,o,s,!0)}function IA(r,e,t,n,o,s,a=!1,i=!1,u=!1){let l=[];for(let g=0;g<e.length;g++)e[g]>o&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(hM);let p=s>0?-.5/s:0,m=[],c=[];for(;m.length<t&&l.length>0;){let g=l.pop(),{score:b,boxIndex:T,suppressBeginIndex:x}=g;if(b<o)break;let I=!1;for(let k=m.length-1;k>=x;--k){let w=xQ(r,T,m[k]);if(w>=n){I=!0;break}if(g.score=g.score*IQ(n,p,w),g.score<=o)break}g.suppressBeginIndex=m.length,I||(g.score===b?(m.push(T),c.push(g.score)):g.score>o&&fM(l,g,hM))}let d=m.length,f=t-d;i&&f>0&&(m.push(...new Array(f).fill(0)),c.push(...new Array(f).fill(0)));let h={selectedIndices:m};return a&&(h.selectedScores=c),u&&(h.validOutputs=d),h}function xQ(r,e,t){let n=r.subarray(e*4,e*4+4),o=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),i=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),p=Math.min(o[1],o[3]),m=Math.max(o[0],o[2]),c=Math.max(o[1],o[3]),d=(i-s)*(u-a),f=(m-l)*(c-p);if(d<=0||f<=0)return 0;let h=Math.max(s,l),g=Math.max(a,p),b=Math.min(i,m),T=Math.min(u,c),x=Math.max(b-h,0)*Math.max(T-g,0);return x/(d+f-x)}function IQ(r,e,t){let n=Math.exp(e*t*t);return t<=r?n:0}function hM(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}async function CQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppressionAsync"),a=v(e,"scores","nonMaxSuppressionAsync"),i=js(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u=await Promise.all([s.data(),a.data()]),l=u[0],p=u[1],{selectedIndices:m}=Fy(l,p,t,n,o);return s!==r&&s.dispose(),a!==e&&a.dispose(),Jt(m,"int32")}var gM=CQ;function kQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=v(r,"boxes","nonMaxSuppression"),i=v(e,"scores","nonMaxSuppression"),u=js(a,i,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:a,scores:i},p={maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},m=N.runKernel(Ka,l,p);return{selectedIndices:m[0],selectedScores:m[1]}}var bM=A({nonMaxSuppressionWithScore_:kQ});async function SQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),u=js(a,i,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([a.data(),i.data()]),p=l[0],m=l[1],{selectedIndices:c,selectedScores:d}=$y(p,m,t,n,o,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Jt(c,"int32"),selectedScores:Jt(d)}}var yM=SQ;function vQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=v(r,"boxes","nonMaxSuppression"),i=v(e,"scores","nonMaxSuppression"),u=js(a,i,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,m=u.scoreThreshold,c={boxes:a,scores:i},d={maxOutputSize:l,iouThreshold:p,scoreThreshold:m,padToMaxOutputSize:s},f=N.runKernel(eu,c,d);return{selectedIndices:f[0],validOutputs:f[1]}}var TM=A({nonMaxSuppressionPadded_:vQ});async function AQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),u=js(a,i,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,m=u.scoreThreshold,[c,d]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:h}=Ly(c,d,l,p,m,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Jt(f,"int32"),validOutputs:ge(h,"int32")}}var xM=AQ;function wQ(r,e,t=!1,n=!1){let o=v(r,"images","resizeBilinear");D(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),D(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(Yo,i,u);return a?F(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var IM=A({resizeBilinear_:wQ});function NQ(r,e,t=!1,n=!1){let o=v(r,"images","resizeNearestNeighbor");D(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),D(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(Xo,i,u);return a?F(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var CM=A({resizeNearestNeighbor_:NQ});function DQ(r,e="binary",t=!1,n=.5){let o=v(r,"image","threshold"),s=.2989,a=.587,i=.114,u=o.shape[0]*o.shape[1],l=P(Jt([n]),255),p,m,c,d;if(D(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),D(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),D(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),D(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[p,m,c]=Mr(o,[1,1,1],-1);let g=P(p,s),b=P(m,a),T=P(c,i);d=Z(Z(g,b),T)}else d=r;if(e==="otsu"){let g=jb(re(Ty(d),"int32"),mr([]),256);l=_Q(g,u)}let f=t?Hs(d,l):Qt(d,l);return re(P(f,255),"int32")}function _Q(r,e){let t=Jt([-1]),n=Jt([0]),o=Jt([0]),s,a,i,u,l,p;for(let m=0;m<r.size-1;m++){s=ze(r,0,m+1),a=ze(r,m+1),l=fe(be(s),e),p=fe(be(a),e);let c=be(P(s,Ei(0,s.size)));i=fe(c,be(s));let d=Ks(a.shape,s.size),f=Z(Ei(0,a.size),d),h=P(a,f);u=fe(be(h),be(a));let g=me(i,u),b=me(i,u),T=P(l,p);o=P(P(T,g),b);let x=Qt(o,n);n=zt(x,o,n),t=zt(x,Jt([m]),t)}return t}var kM=A({threshold_:DQ});function MQ(r,e,t="nearest",n="constant",o=0,s){let a=v(r,"image","transform","float32"),i=v(e,"transforms","transform","float32");D(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),D(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:a,transforms:i},l={interpolation:t,fillMode:n,fillValue:o,outputShape:s};return N.runKernel(Ya,u,l)}var SM=A({transform_:MQ});function RQ(r,e,t){D(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),D(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);let n=v(r,"a","bandPart");D(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,a]=n.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=s),t<0&&(t=a);let i=F(Ei(0,s,1,"int32"),[-1,1]),u=Ei(0,a,1,"int32"),l=me(i,u),p=sn(Hs(l,ge(+e,"int32")),Xn(l,ge(-t,"int32"))),m=Ct([s,a],n.dtype);return F(cr(Rr(F(n,[-1,s,a])).map(c=>zt(p,c,m))),o)}var vM=A({bandPart_:RQ});function PQ(r){let e;if(Array.isArray(r)){e=!1,D(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)D(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else e=!0,r=Mr(r,r.shape[0],0).map(o=>qs(o,[0]));D(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let t=[],n=r;for(let o=0;o<r.length;++o)t.push(N.tidy(()=>{let s=n[o];if(o>0)for(let a=0;a<o;++a){let i=P(be(P(t[a],s)),t[a]);s=me(s,i)}return fe(s,np(s,"euclidean"))}));return e?cr(t,0):t}var AM=A({gramSchmidt_:PQ});function EQ(r,e=!1){if(D(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return wM(r,e);{let t=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=Rr(F(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,p]=wM(u,e);o.push(l),s.push(p)});let a=F(cr(o,0),r.shape),i=F(cr(s,0),r.shape);return[a,i]}}function wM(r,e=!1){return N.tidy(()=>{D(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let t=r.shape[0],n=r.shape[1],o=op(t),s=gn(r),a=ei([[1]],[1,1]),i=gn(a),u=t>=n?n:t;for(let l=0;l<u;++l){let p=s,m=i,c=o;[i,s,o]=N.tidy(()=>{let d=ze(s,[l,l],[t-l,1]),f=np(d),h=ze(s,[l,l],[1,1]),g=zt(Qt(h,0),ei([[-1]]),ei([[1]])),b=me(h,P(g,f)),T=fe(d,b);T.shape[0]===1?i=gn(a):i=ct([a,ze(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);let x=tt(fe(Ue(g,b),f)),I=ze(s,[l,0],[t-l,n]),k=P(x,i),w=Ge(i);if(l===0)s=me(I,Ue(k,Ue(w,I)));else{let R=me(I,Ue(k,Ue(w,I)));s=ct([ze(s,[0,0],[l,n]),R],0)}let _=Ge(k),M=ze(o,[0,l],[t,o.shape[1]-l]);if(l===0)o=me(M,Ue(Ue(M,i),_));else{let R=me(M,Ue(Ue(M,i),_));o=ct([ze(o,[0,0],[t,l]),R],1)}return[i,s,o]}),_e([p,m,c])}return!e&&t>n&&(o=ze(o,[0,0],[t,n]),s=ze(s,[0,0],[n,n])),[o,s]})}var NM=A({qr_:EQ});var ti=(o=>(o[o.NONE=0]="NONE",o[o.MEAN=1]="MEAN",o[o.SUM=2]="SUM",o[o.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",o))(ti||{});function FQ(r,e,t=3){let n=v(r,"losses","computeWeightedLoss"),o=null;e!=null&&(o=v(e,"weights","computeWeightedLoss"));let s=o==null?n:P(n,o);if(t===0)return s;if(t===2)return be(s);if(t===1){if(o==null)return Lt(s);{let a=n.size/o.size,i=fe(be(s),be(o));return a>1?fe(i,ge(a)):i}}if(t===3){if(o==null)return fe(be(s),ge(n.size));{let a=P(o,Tr(n.shape)),i=re(be(du(a,ge(0))),"float32");return fe(be(s),i)}}throw Error(`Unknown reduction: ${t}`)}var Xr=A({computeWeightedLoss_:FQ});function LQ(r,e,t,n=3){let o=v(r,"labels","absoluteDifference"),s=v(e,"predictions","absoluteDifference"),a=null;t!=null&&(a=v(t,"weights","absoluteDifference")),Bt(o.shape,s.shape,"Error in absoluteDifference: ");let i=Ot(me(o,s));return Xr(i,a,n)}var DM=A({absoluteDifference_:LQ});function $Q(r,e,t,n,o=3){let s=v(r,"labels","cosineDistance"),a=v(e,"predictions","cosineDistance"),i=null;n!=null&&(i=v(n,"weights","cosineDistance")),Bt(s.shape,a.shape,"Error in cosineDistance: ");let u=ge(1),l=me(u,be(P(s,a),t,!0));return Xr(l,i,o)}var _M=A({cosineDistance_:$Q});function BQ(r,e,t,n=3){let o=v(r,"labels","hingeLoss"),s=v(e,"predictions","hingeLoss"),a=null;t!=null&&(a=v(t,"weights","hingeLoss")),Bt(o.shape,s.shape,"Error in hingeLoss: ");let i=ge(1);o=me(P(ge(2),o),i);let u=an(me(i,P(o,s)));return Xr(u,a,n)}var MM=A({hingeLoss_:BQ});function OQ(r,e,t,n=1,o=3){let s=v(r,"labels","huberLoss"),a=v(e,"predictions","huberLoss"),i=null;t!=null&&(i=v(t,"weights","huberLoss")),Bt(s.shape,a.shape,"Error in huberLoss: ");let u=ge(n),l=Ot(me(a,s)),p=yl(l,u),m=me(l,p),c=Z(P(ge(.5),He(p)),P(u,m));return Xr(c,i,o)}var RM=A({huberLoss_:OQ});function zQ(r,e,t,n=1e-7,o=3){let s=v(r,"labels","logLoss"),a=v(e,"predictions","logLoss"),i=null;t!=null&&(i=v(t,"weights","logLoss")),Bt(s.shape,a.shape,"Error in logLoss: ");let u=ge(1),l=ge(n),p=tt(P(s,jr(Z(a,l)))),m=P(me(u,s),jr(Z(me(u,a),l))),c=me(p,m);return Xr(c,i,o)}var PM=A({logLoss_:zQ});function GQ(r,e,t,n=3){let o=v(r,"labels","meanSquaredError"),s=v(e,"predictions","meanSquaredError"),a=null;t!=null&&(a=v(t,"weights","meanSquaredError")),Bt(o.shape,s.shape,"Error in meanSquaredError: ");let i=Ay(o,s);return Xr(i,a,n)}var EM=A({meanSquaredError_:GQ});function WQ(r,e){let t=v(r,"labels","sigmoidCrossEntropyWithLogits"),n=v(e,"logits","sigmoidCrossEntropyWithLogits");Bt(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=an(n),s=P(n,t),a=mc(br(tt(Ot(n))));return Z(me(o,s),a)}function UQ(r,e,t,n=0,o=3){let s=v(r,"multiClassLabels","sigmoidCrossEntropy"),a=v(e,"logits","sigmoidCrossEntropy"),i=null;if(t!=null&&(i=v(t,"weights","sigmoidCrossEntropy")),Bt(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=ge(n),p=ge(1),m=ge(.5);s=Z(P(s,me(p,l)),P(m,l))}let u=WQ(s,a);return Xr(u,i,o)}var FM=A({sigmoidCrossEntropy_:UQ});function KQ(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return bn((o,s,a)=>{let u=py(s,[t],!0),l=me(re(s,"float32"),u);a([o,l]);let p=tt(P(l,o));return{value:be(p,[t]),gradFunc:(d,f)=>{let[h,g]=f,b=Vs(d.shape,[t]);return[P(F(d,b),me(re(h,"float32"),br(g))),P(F(d,b),me(br(g),re(h,"float32")))]}}})(r,e)}function VQ(r,e,t,n=0,o=3){let s=v(r,"onehotLabels","softmaxCrossEntropy"),a=v(e,"logits","softmaxCrossEntropy"),i=null;if(t!=null&&(i=v(t,"weights","softmaxCrossEntropy")),Bt(s.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){let l=ge(n),p=ge(1),m=ge(s.shape[1]);s=Z(P(s,me(p,l)),fe(l,m))}let u=KQ(s,a);return Xr(u,i,o)}var LM=A({softmaxCrossEntropy_:VQ});function HQ(r,e,t,n){let o=v(r,"indices","sparseFillEmptyRows","int32"),s=v(e,"values","sparseFillEmptyRows"),a=v(t,"denseShape","sparseFillEmptyRows","int32"),i=v(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let u={indices:o,values:s,denseShape:a,defaultValue:i},l=N.runKernel(Yu,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var $M=A({sparseFillEmptyRows_:HQ});function qQ(r,e,t){let n=v(r,"inputIndices","sparseReshape","int32"),o=v(e,"inputShape","sparseReshape","int32"),s=v(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let a={inputIndices:n,inputShape:o,newShape:s},i=N.runKernel(ou,a);return{outputIndices:i[0],outputShape:i[1]}}var BM=A({sparseReshape_:qQ});function jQ(r,e,t){let n=v(r,"data","sparseSegmentMean"),o=v(e,"indices","sparseSegmentMean","int32"),s=v(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return N.runKernel(Zu,a)}var OM=A({sparseSegmentMean_:jQ});function XQ(r,e,t){let n=v(r,"data","sparseSegmentSum"),o=v(e,"indices","sparseSegmentSum","int32"),s=v(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return N.runKernel(Qu,a)}var zM=A({sparseSegmentSum_:XQ});function YQ(r,e,t,n,o,s,a,i){let u=v(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=v(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let p={separator:t,nGramWidths:n,leftPad:o,rightPad:s,padWidth:a,preserveShortSequences:i},m={data:u,dataSplits:l},c=N.runKernel(Ni,m,p);return{nGrams:c[0],nGramsSplits:c[1]}}var GM=A({stringNGrams_:YQ});function ZQ(r,e,t=!0){let n=v(r,"input","stringSplit","string"),o=v(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},a={input:n,delimiter:o},i=N.runKernel(el,a,s);return{indices:i[0],values:i[1],shape:i[2]}}var WM=A({stringSplit_:ZQ});function QQ(r,e){let t=v(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return N.runKernel(tl,o,n)}var UM=A({stringToHashBucketFast_:QQ});var JQ={fft:Tc,ifft:pp,rfft:xc,irfft:vy},e7={hammingWindow:iM,hannWindow:Py,frame:Ey,stft:uM},fs={flipLeftRight:pM,grayscaleToRGB:mM,resizeNearestNeighbor:CM,resizeBilinear:IM,rotateWithOffset:cM,cropAndResize:lM,nonMaxSuppression:dM,nonMaxSuppressionAsync:gM,nonMaxSuppressionWithScore:bM,nonMaxSuppressionWithScoreAsync:yM,nonMaxSuppressionPadded:TM,nonMaxSuppressionPaddedAsync:xM,threshold:kM,transform:SM},CA={bandPart:vM,gramSchmidt:AM,qr:NM},t7={absoluteDifference:DM,computeWeightedLoss:Xr,cosineDistance:_M,hingeLoss:MM,huberLoss:RM,logLoss:PM,meanSquaredError:EM,sigmoidCrossEntropy:FM,softmaxCrossEntropy:LM},r7={sparseFillEmptyRows:$M,sparseReshape:BM,sparseSegmentMean:OM,sparseSegmentSum:zM},n7={stringNGrams:GM,stringSplit:WM,stringToHashBucketFast:UM};var Yr=class extends Sh{iterations_;minimize(e,t=!1,n){let{value:o,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return _e(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return iy(e,t)}dispose(){this.iterations_!=null&&_e(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ge(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Yr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var xl=class extends Yr{constructor(t,n,o=null){super();this.learningRate=t;this.rho=n;this.epsilon=o;o==null&&(this.epsilon=N.backend.epsilon())}accumulatedGrads=[];accumulatedUpdates=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${o}/accum_grad`,variable:z(()=>we(a).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${o}/accum_var`,variable:z(()=>we(a).variable(i))});let u=Array.isArray(t)?t[s].tensor:t[o];if(u==null)return;let l=this.accumulatedGrads[s].variable,p=this.accumulatedUpdates[s].variable;z(()=>{let m=Z(P(l,this.rho),P(He(u),1-this.rho)),c=P(fe(Ft(Z(p,this.epsilon)),Ft(Z(l,this.epsilon))),u),d=Z(P(p,this.rho),P(He(c),1-this.rho));l.assign(m),p.assign(d);let f=Z(P(c,-this.learningRate),a);a.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_e(this.accumulatedGrads.map(t=>t.variable)),_e(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=t.length/2,o=!1;this.accumulatedGrads=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedUpdates=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}};K(xl,"className","Adadelta");Rn(xl);var Il=class extends Yr{constructor(t,n=.1){super();this.learningRate=t;this.initialAccumulatorValue=n}accumulatedGrads=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${o}/accumulator`,variable:z(()=>Ks(a.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[s].tensor:t[o];if(i==null)return;let u=this.accumulatedGrads[s].variable;z(()=>{let l=Z(u,He(i));u.assign(l);let p=Z(P(fe(i,Ft(Z(l,N.backend.epsilon()))),-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_e(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=!1;this.accumulatedGrads=t.map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}};K(Il,"className","Adagrad");Rn(Il);var Cl=class extends Yr{constructor(t,n,o,s=null){super();this.learningRate=t;this.beta1=n;this.beta2=o;this.epsilon=s;z(()=>{this.accBeta1=ge(n).variable(),this.accBeta2=ge(o).variable()}),s==null&&(this.epsilon=N.backend.epsilon())}accBeta1;accBeta2;accumulatedFirstMoment=[];accumulatedSecondMoment=[];applyGradients(t){let n=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);z(()=>{let o=me(1,this.accBeta1),s=me(1,this.accBeta2);n.forEach((a,i)=>{let u=N.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:z(()=>we(u).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:z(()=>we(u).variable(l))});let p=Array.isArray(t)?t[i].tensor:t[a];if(p==null)return;let m=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,d=Z(P(m,this.beta1),P(p,1-this.beta1)),f=Z(P(c,this.beta2),P(He(p),1-this.beta2)),h=fe(d,o),g=fe(f,s);m.assign(d),c.assign(f);let b=Z(P(fe(h,Z(Ft(g),this.epsilon)),-this.learningRate),u);u.assign(b)}),this.accBeta1.assign(P(this.accBeta1,this.beta1)),this.accBeta2.assign(P(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&_e(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),z(()=>{this.accBeta1.assign(jn(this.beta1,this.iterations_+1)),this.accBeta2.assign(jn(this.beta2,this.iterations_+1))});let n=t.length/2,o=!1;this.accumulatedFirstMoment=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}};K(Cl,"className","Adam");Rn(Cl);var kl=class extends Yr{constructor(t,n,o,s=null,a=0){super();this.learningRate=t;this.beta1=n;this.beta2=o;this.epsilon=s;this.decay=a;z(()=>{this.iteration=ge(0).variable(),this.accBeta1=ge(n).variable()}),s==null&&(this.epsilon=N.backend.epsilon())}accBeta1;iteration;accumulatedFirstMoment=[];accumulatedWeightedInfNorm=[];applyGradients(t){let n=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);z(()=>{let o=me(1,this.accBeta1),s=fe(-this.learningRate,Z(P(this.iteration,this.decay),1));n.forEach((a,i)=>{let u=N.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:we(u).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:we(u).variable(l)});let p=Array.isArray(t)?t[i].tensor:t[a];if(p==null)return;let m=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,d=Z(P(m,this.beta1),P(p,1-this.beta1)),f=P(c,this.beta2),h=Ot(p),g=ds(f,h);m.assign(d),c.assign(g);let b=Z(P(fe(s,o),fe(d,Z(g,this.epsilon))),u);u.assign(b)}),this.iteration.assign(Z(this.iteration,1)),this.accBeta1.assign(P(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&_e(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}};K(kl,"className","Adamax");Rn(kl);var Li=class extends Yr{constructor(t){super();this.learningRate=t;this.setLearningRate(t)}c;applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=Array.isArray(t)?t[s].tensor:t[o];if(a==null)return;let i=N.registeredVariables[o];z(()=>{let u=Z(P(this.c,a),i);i.assign(u)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Et(ge(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}};K(Li,"className","SGD");Rn(Li);var Sl=class extends Li{constructor(t,n,o=!1){super(t);this.learningRate=t;this.momentum=n;this.useNesterov=o;this.m=ge(this.momentum)}m;accumulations=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${o}/momentum`,variable:z(()=>we(a).variable(!1))});let i=this.accumulations[s].variable,u=Array.isArray(t)?t[s].tensor:t[o];u!=null&&z(()=>{let l,p=Z(P(this.m,i),u);this.useNesterov?l=Z(P(this.c,Z(u,P(p,this.m))),a):l=Z(P(this.c,p),a),i.assign(p),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_e(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=!1;this.accumulations=t.map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}};K(Sl,"className","Momentum");Rn(Sl);var vl=class extends Yr{constructor(t,n=.9,o=0,s=null,a=!1){super();this.learningRate=t;this.decay=n;this.momentum=o;this.epsilon=s;if(this.centered=a,s==null&&(this.epsilon=N.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}centered;accumulatedMeanSquares=[];accumulatedMoments=[];accumulatedMeanGrads=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${o}/rms`,variable:z(()=>we(a).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${o}/momentum`,variable:z(()=>we(a).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${o}/mg`,variable:z(()=>we(a).variable(i))});let u=Array.isArray(t)?t[s].tensor:t[o];if(u==null)return;let l=this.accumulatedMeanSquares[s].variable,p=this.accumulatedMoments[s].variable;z(()=>{let m=Z(P(l,this.decay),P(He(u),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[s].variable,d=Z(P(c,this.decay),P(u,1-this.decay)),f=fe(P(u,this.learningRate),Ft(me(m,Z(He(d),this.epsilon)))),h=Z(P(p,this.momentum),f);l.assign(m),c.assign(d),p.assign(h);let g=me(a,h);a.assign(g)}else{let c=Z(P(l,this.decay),P(He(u),1-this.decay)),d=Z(P(p,this.momentum),fe(P(u,this.learningRate),Ft(Z(c,this.epsilon))));l.assign(c),p.assign(d);let f=me(a,d);a.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_e(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_e(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&_e(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=this.centered?t.length/3:t.length/2,o=!1;this.accumulatedMeanSquares=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedMoments=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}};K(vl,"className","RMSProp");Rn(vl);var ri=class{static sgd(e){return new Li(e)}static momentum(e,t,n=!1){return new Sl(e,t,n)}static rmsprop(e,t=.9,n=0,o=null,s=!1){return new vl(e,t,n,o,s)}static adam(e=.001,t=.9,n=.999,o=null){return new Cl(e,t,n,o)}static adadelta(e=.001,t=.95,n=null){return new xl(e,t,n)}static adamax(e=.002,t=.9,n=.999,o=null,s=0){return new kl(e,t,n,o,s)}static adagrad(e,t=.1){return new Il(e,t)}};var hp={sgd:ri.sgd,momentum:ri.momentum,adadelta:ri.adadelta,adagrad:ri.adagrad,rmsprop:ri.rmsprop,adamax:ri.adamax,adam:ri.adam};var o7=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r())();function Ph(){return new Promise(r=>o7(()=>r()))}var C={};qe(C,{ERF_A1:()=>T7,ERF_A2:()=>x7,ERF_A3:()=>I7,ERF_A4:()=>C7,ERF_A5:()=>k7,ERF_P:()=>y7,PARALLELIZE_THRESHOLD:()=>By,RowPartitionType:()=>KM,SELU_SCALE:()=>SA,SELU_SCALEALPHA:()=>kA,applyActivation:()=>dp,assertAndGetBroadcastShape:()=>Oe,assertAxesAreInnerMostDims:()=>MX,assertParamsConsistent:()=>s7,assignToTypedArray:()=>D7,axesAreInnerMostDims:()=>lA,calculateShapes:()=>c1,checkEinsumDimSizes:()=>F7,checkPadOnDimRoundingMode:()=>_t,combineLocations:()=>j1,combineRaggedTensorToTensorShapes:()=>i7,complexWithEvenIndex:()=>A7,complexWithOddIndex:()=>w7,computeConv2DInfo:()=>tp,computeConv3DInfo:()=>F1,computeDefaultPad:()=>uA,computeDilation2DInfo:()=>P5,computeOptimalWindowSize:()=>m7,computeOutAndReduceShapes:()=>pA,computeOutShape:()=>a7,computePool2DInfo:()=>iA,computePool3DInfo:()=>E5,convertConv2DDataFormat:()=>L1,decodeEinsumEquation:()=>P7,eitherStridesOrDilationsAreOne:()=>Or,expandShapeToKeepDim:()=>Vs,exponent:()=>M7,exponents:()=>_7,fromStringArrayToUint8:()=>rJ,fromUint8ToStringArray:()=>tJ,getAxesPermutation:()=>mA,getBroadcastDims:()=>l1,getComplexWithIndex:()=>N7,getEinsumComputePath:()=>L7,getEinsumPermutation:()=>E7,getFusedBiasGradient:()=>cp,getFusedDyActivation:()=>mp,getImageCenter:()=>c7,getInnerMostAxes:()=>RX,getPermuted:()=>f7,getRaggedRank:()=>l7,getReductionAxes:()=>vt,getReshaped:()=>d7,getReshapedPermuted:()=>h7,getRowPartitionTypesHelper:()=>u7,getSliceBeginCoords:()=>g7,getSliceSize:()=>b7,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>z7,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>G7,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>W7,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>V7,getSparseReshapeInputOutputMismatchErrorMessage:()=>q7,getSparseReshapeInputOutputMultipleErrorMessage:()=>H7,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>U7,getSparseReshapeNegativeOutputDimErrorMessage:()=>K7,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Z7,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>j7,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>X7,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Y7,getUndoAxesPermutation:()=>Nh,isIdentityPermutation:()=>$7,log:()=>W6,mergeRealAndImagArrays:()=>S7,prepareAndValidate:()=>m1,prepareSplitSize:()=>O7,segment_util:()=>AA,shouldFuse:()=>fp,slice_util:()=>It,splitRealAndImagArrays:()=>v7,tupleValuesAreOne:()=>ps,upcastType:()=>Pt,validateDefaultValueShape:()=>p7,validateInput:()=>Ob,validateUpdateShape:()=>tA,warn:()=>Di});function s7(r,e){let t=r[0].length;r.forEach((o,s)=>{D(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),D(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let n=r[0];r.forEach((o,s)=>{for(let a=0;a<t;a++)D(a===e||o[a]===n[a],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function a7(r,e){let t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}var KM=(a=>(a[a.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",a[a.VALUE_ROWIDS=1]="VALUE_ROWIDS",a[a.ROW_LENGTHS=2]="ROW_LENGTHS",a[a.ROW_SPLITS=3]="ROW_SPLITS",a[a.ROW_LIMITS=4]="ROW_LIMITS",a[a.ROW_STARTS=5]="ROW_STARTS",a))(KM||{});function i7(r,e,t){let n=new Array;if(t==null&&e==null)return n;if(e==null)for(;n.length<r+t.length;)n.push(-1);else n=e.slice();if(t==null)return n;if(r+t.length!==n.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${r+t.length}, but shape.rank = ${n.length}`);for(let o=1;o<t.length;++o){let s=t[o],a=n[n.length-t.length+o],i=n[a];if(s>=0)if(i>=0){if(i!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${o+r}] = ${s} but shape[${o+r}] = ${i}`)}else n[a]=s}return n}function u7(r){let e={FIRST_DIM_SIZE:0,VALUE_ROWIDS:1,ROW_LENGTHS:2,ROW_SPLITS:3,ROW_LIMITS:4,ROW_STARTS:5},t=[];for(let n of r)if(n in e)t.push(e[n]);else break;return t}function l7(r){return r.length===0?0:r[0]===0?r.length-1:r.length}function p7(r,e){if(r==null||e==null)return;let t=r.length,n=e.length;if(t>=n)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${n})`);for(let o=0;o<Math.min(t,n-1);++o){let s=r[o],a=e[o+1];if(s>=0&&a>=0&&s!==1&&s!==a)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${o-r.length}] = ${s} but ragged tensor input.flatValues.shape[${o-r.length}] = ${a}`)}}var By=30;function m7(r){return r<=By?r:Im(r,Math.floor(Math.sqrt(r)))}function c7(r,e,t){let n=t*(typeof r=="number"?r:r[0]),o=e*(typeof r=="number"?r:r[1]);return[n,o]}function d7(r,e,t,n=!0){let o=[];if(n)o=o.concat(e.slice(0)),o.push(r[0]/t),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=e.length;for(let a=0;a<s;++a)o=o.concat([r[a+1]/e[a],e[a]]);o=o.concat(r.slice(s+1))}return o}function f7(r,e,t=!0){let n=[];if(t){n.push(e);for(let o=e+1;o<r;++o)o<=2*e?(n.push(o),n.push(o-(e+1))):n.push(o)}else{let o=[],s=[];for(let a=1;a<r;++a)a>=e*2+1||a%2===1?s.push(a):o.push(a);n.push(...o),n.push(0),n.push(...s)}return n}function h7(r,e,t,n=!0){let o=[];n?o.push(r[0]/t):o.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?o.push(e[s-1]*r[s]):o.push(r[s]/e[s-1]):o.push(r[s]);return o}function g7(r,e){let t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function b7(r,e,t){let n=r.slice(0,1);for(let o=0;o<t;++o)n.push(r[o+1]-e[o][0]-e[o][1]);return n}var kA=1.7580993408473768,SA=1.0507009873554805;var y7=.3275911,T7=.254829592,x7=-.284496736,I7=1.421413741,C7=-1.453152027,k7=1.061405429;function S7(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);let t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}function v7(r){let e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)e[n/2]=r[n],t[n/2]=r[n+1];return{real:e,imag:t}}function A7(r){let e=Math.ceil(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=0;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function w7(r){let e=Math.floor(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=2;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function N7(r,e){let t=r[e*2],n=r[e*2+1];return{real:t,imag:n}}function D7(r,e,t,n){r[n*2]=e,r[n*2+1]=t}function _7(r,e){let t=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(e?2:-2)*Math.PI*(o/r);t[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:t,imag:n}}function M7(r,e,t){let n=(t?2:-2)*Math.PI*(r/e),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var vA="->",R7=/->/g,VM=",",HM="...";function P7(r,e){r=r.replace(/\s/g,"");let t=(r.length-r.replace(R7,"").length)/vA.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${vA}").`);let[n,o]=r.split(vA);D(n.indexOf(HM)===-1,()=>`The ellipsis notation ("${HM}") is not supported yet.`);let s=n.split(VM),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let c=0;c<o.length;++c){let d=o[c];if(!s.some(f=>f.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);i.indexOf(d)===-1&&i.push(d)}for(let c=0;c<n.length;++c){let d=n[c];i.indexOf(d)===-1&&d!==VM&&i.push(d)}let u=new Array(s.length);for(let c=0;c<a;++c){if(new Set(s[c].split("")).size!==s[c].length)throw new Error(`Found duplicate axes in input component ${s[c]}. Support for duplicate axes in input is not implemented yet.`);u[c]=[];for(let d=0;d<s[c].length;++d)u[c].push(i.indexOf(s[c][d]))}let l=i.length,p=o.length,m=[];for(let c=p;c<l;++c)m.push(c);return{allDims:i,summedDims:m,idDims:u}}function E7(r,e){let t=new Array(r);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let n=[];for(let o=0;o<r;++o)t[o]===-1&&n.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:n}}function F7(r,e,t){let n=new Array(r);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let a=0;a<e[o].length;++a)n[e[o][a]]===void 0?n[e[o][a]]=s[a]:D(n[e[o][a]]===s[a],()=>`Expected dimension ${n[e[o][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function L7(r,e){let t=r,n=[],o=0;r.length===0&&t.push(-1),o=r.length+1;for(let a=0;a<o;++a)n.push([]);let s=[];for(let a=0;a<t.length;++a){let i=t[a],u=B7(e,i);for(let l of u)s.indexOf(l)===-1&&(n[a].push(l),s.push(l))}return{path:t,steps:n}}function $7(r){return r.every((e,t)=>e===t)}function B7(r,e){let t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function O7(r,e,t=0){let n=[];if(typeof e=="number")D(r.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{let o=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);D(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let a=e.reduce((i,u)=>u>0?i+u:i);e[s]=r.shape[t]-a}D(r.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}function z7(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function G7(r,e){return`indices(${r}, 0) is invalid: ${e} < 0`}function W7(r,e,t){return`indices(${r}, 0) is invalid: ${e} >= ${t}`}function U7(r,e){return`only one output dimension may be -1, not both ${r} and ${e}`}function K7(r,e){return`size ${r} must be non-negative, not ${e}`}function V7(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function H7(r,e){let t=nt(r),n=nt(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${e}`}function q7(r,e){let t=nt(r),n=nt(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${e}`}function j7(){return"segment ids must be >= 0"}function X7(){return"segment ids are not increasing"}function Y7(r,e){return`Segment id ${r} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Z7(r,e,t){return`Bad: indices[${r}] == ${e} out of range [0, ${t})`}var AA={};qe(AA,{collectGatherOpShapeInfo:()=>eJ,computeOutShape:()=>J7,segOpComputeOptimalWindowSize:()=>Q7});function Q7(r,e){let t=!1,n;for(r<=By?(n=r,t=!0):n=Im(r,Math.floor(Math.sqrt(r)));!t;)n>e||n===r?t=!0:n=Im(r,n+1);return n}function J7(r,e,t){let n=[],o=r.length;for(let s=0;s<o;s++)s!==e?n.push(r[s]):n.push(t);return n}function eJ(r,e,t,n){let o=e.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let m=0;m<n;++m)if(r.shape[m]!==e.shape[m])throw new Error(`x.shape[${m}]: ${r.shape[m]} should be equal to indices.shape[${m}]: ${e.shape[m]}.`);let a=r.shape[t],i=[],u=1,l=1,p=1;for(let m=0;m<n;++m)i.push(r.shape[m]),u*=r.shape[m];for(let m=n;m<t;m++)i.push(r.shape[m]),l*=r.shape[m];for(let m=n;m<o;m++)i.push(e.shape[m]);for(let m=t+1;m<s;m++)i.push(r.shape[m]),p*=r.shape[m];return{batchSize:u,sliceSize:p,outerSize:l,dimSize:a,outputShape:i}}function tJ(r){try{return r.map(e=>Qm(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function rJ(r){return r.map(e=>ol(e))}var xr={};qe(xr,{nonMaxSuppressionV3Impl:()=>Fy,nonMaxSuppressionV4Impl:()=>Ly,nonMaxSuppressionV5Impl:()=>$y,whereImpl:()=>Dy});var En=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,En.prototype)}},Zr=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Zr.prototype)}},B=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,B.prototype)}},Ne=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ne.prototype)}},kc=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,kc.prototype)}};var Eh=class{cache;maxEntries;constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Ys(r,e){if(Array.isArray(r)){let t=[];for(let n=0;n<e;n++)t=t.concat(r);return t}else{let t=new Array(e);return t.fill(r),t}}function hs(r,e){if(!r)throw new kc(e)}function NA(r,e){let t=0;for(let n of r)n===e&&t++;return t}function Pr(r){return r.length===1?r[0]:r}function At(r){return Array.isArray(r)?r:[r]}function Zs(r){let t=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function fu(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}var Xs={};function Sc(r){if(r==null)return null;let e={};return e.className=r.getClassName(),e.config=r.getConfig(),e}function wA(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(e=>wA(e));else{let e=Object.keys(r);for(let t of e){let n=r[t];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[t]=n.value:wA(n))}}}function $i(r,e={},t={},n="object",o=!1){if(typeof r=="string"){let s=r,a;if(s in t)a=t[s];else if(s in Xs)a=Xs[s];else if(a=e[s],a==null)throw new B(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let s=r;if(s.className==null||s.config==null)throw new B(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let a=s.className,i,u;if(a in t?[i,u]=t[a]:a in Xs?[i,u]=Xs.className:a in e&&([i,u]=e[a]),i==null)throw new B(`Unknown ${n}: ${a}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let d of Object.keys(Xs))l[d]=Xs[d];for(let d of Object.keys(t))l[d]=t[d];let p=s.config;p.customObjects=l;let m={...Xs};for(let d of Object.keys(t))Xs[d]=t[d];wA(s.config);let c=u(i,s.config,t,o);return Xs={...m},c}else{let l={...Xs};for(let m of Object.keys(t))Xs[m]=t[m];let p=new i(s.config);return Xs={...l},p}}}function nJ(r,e){return r<e?-1:r>e?1:0}function Fh(r,e){return-1*nJ(r,e)}function Qs(r){if(r==null)return r;let e=[];for(let t of r)e.indexOf(t)===-1&&e.push(t);return e}function qM(r){if(r==null)throw new B(`Invalid value in obj: ${JSON.stringify(r)}`);for(let e in r)if(r.hasOwnProperty(e))return!1;return!0}function Bi(r,e,t){if(t!=null&&r.indexOf(t)<0)throw new B(`${t} is not a valid ${e}.  Valid values are ${r} or null/undefined.`)}function Oy(r,e,t=0,n=1/0){return hs(t>=0),hs(n>=t),Array.isArray(r)&&r.length>=t&&r.length<=n&&r.every(o=>typeof o===e)}function sr(r,e){Array.isArray(r)?(y.assert(r.length>0,()=>`${e} is unexpectedly an empty array.`),r.forEach((t,n)=>sr(t,`element ${n+1} of ${e}`))):y.assert(Number.isInteger(r)&&r>0,()=>`Expected ${e} to be a positive integer, but got ${jM(r)}.`)}function jM(r){return r===null?"null":Array.isArray(r)?"["+r.map(e=>jM(e)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function XM(r,e,t){let n=t!=null?t():y.now(),o;return(...a)=>{let i=t!=null?t():y.now();return i-n<e||(n=i,o=r(...a)),o}}function zy(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var oJ=0;function Wy(){return oJ++}var Gy={};function Al(r=""){return r in Gy||(Gy[r]=0),Gy[r]+=1,r+Gy[r].toString()}var YM=["channelsFirst","channelsLast"],ZM=["nearest","bilinear"],QM=["valid","same","causal"],JM=["max","avg"],eR=["sum","mul","concat","ave"];var vc=new Map;function Gt(r){Bi(YM,"DataFormat",r)}function rR(r){Bi(ZM,"InterpolationFormat",r)}function yn(r){Bi(QM,"PaddingMode",r)}function DA(r){Bi(JM,"PoolMode",r)}var Lh=[],tR="/";function oi(r,e){Lh.push(r);try{let t=e();return Lh.pop(),t}catch(t){throw Lh.pop(),t}}function sJ(){return Lh.length===0?"":Lh.join(tR)+tR}function Uy(r){if(!nR(r))throw new Error("Not a valid tensor name: '"+r+"'");return sJ()+r}function Ky(r){if(!nR(r))throw new Error("Not a valid tensor name: '"+r+"'");vc.has(r)||vc.set(r,0);let e=vc.get(r);if(vc.set(r,vc.get(r)+1),e>0){let t=`${r}_${e}`;return vc.set(t,1),t}else return r}var aJ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function nR(r){return!!r.match(aJ)}function oR(r){return r===parseInt(r.toString(),10)}function Js(r,e,t){e==null&&(e=0),t==null&&(t=r.length);let n=1;for(let o=e;o<t;++o)n*=r[o];return n}function gp(r){if(r.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n<e&&(e=n)}return e}function si(r){if(r.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n>e&&(e=n)}return e}function Tn(r,e){if(e<r)throw new B(`end (${e}) < begin (${r}) is forbidden.`);let t=[];for(let n=r;n<e;++n)t.push(n);return t}var _A;function fr(){return _A==null&&(_A=a1().epsilon()),_A}function xn(){return"channelsLast"}function un(r,e){return re(r,e)}function gu(r,e=-1){let t=r.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),F(r,t)}function sR(r,e){return z(()=>{if(r.shape.length!==2)throw new B(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let t=gu(r,1);return Hy(t,[1,e,1])})}function aR(r){let e=[Js(r.shape)];return F(r,e)}function iR(r){if(r.rank<=1)throw new B(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let e=[r.shape[0],Js(r.shape,1)];return F(r,e)}function hu(r,e,t){return z(()=>{switch(r.rank){case 1:return gc(r,e,t);case 2:return Mh(r,[e,0],[t,r.shape[1]]);case 3:return bc(r,[e,0,0],[t,r.shape[1],r.shape[2]]);case 4:return lp(r,[e,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3]]);case 5:return ze(r,[e,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return ze(r,[e,0,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new B(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function MA(r,e,t){return z(()=>{switch(r.rank){case 1:return gc(r,e,t);case 2:return Mh(r,[0,e],[r.shape[0],t]);case 3:return bc(r,[0,0,e],[r.shape[0],r.shape[1],t]);case 4:return lp(r,[0,0,0,e],[r.shape[0],r.shape[1],r.shape[2],t]);default:throw new B(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function $h(r,e,t,n){return z(()=>{switch(r.rank){case 1:return gc(r,e,t);case 2:switch(n){case 1:return hu(r,e,t);case 2:return MA(r,e,t);default:throw new B(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return hu(r,e,t);case 2:return bc(r,[0,e,0],[r.shape[0],t,r.shape[2]]);case 3:return MA(r,e,t);default:throw new B(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return hu(r,e,t);case 2:return lp(r,[0,e,0,0],[r.shape[0],t,r.shape[2],r.shape[3]]);case 3:return lp(r,[0,0,e,0],[r.shape[0],r.shape[1],t,r.shape[3]]);case 4:return MA(r,e,t);default:throw new B(`The axis is not within the rank of the tensor ${n}`)}default:throw new B(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Ac(r,e=-1){let t;return e<0&&(t=r[0].rank,t!==0?e=t:e=0),e===r[0].rank&&(e=-1),ct(r,e)}function PA(r,e){switch(r.rank){case 1:return Xb([r,e]);case 2:return Yb([r,e],0);case 3:return Zb([r,e],0);case 4:return Qb([r,e],0);default:throw new B(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function Hy(r,e){if(Array.isArray(e)||(e=[e]),r.rank!==e.length)throw new B(`The length of input n (${e.length}) does not match the number of dimensions in input x (${r.rank})`);return on(r,e)}function wc(r,e=0,t=1,n,o){return up(r,e,t,n,o)}function ea(r,e,t,n){if(r.rank<2||e.rank<2)throw new Ne(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${e.shape}`);if(e.rank>=3){let o=r.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(o!==s)throw new Ne(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${e.shape}`)}if(r.rank===2&&e.rank===2)return Tl.matMul({a:r,b:e,transposeA:!1,transposeB:!1,bias:n?RA(r.rank,n,xn()):null,activation:t});{let o=r.shape.slice(),s=o.pop();r=F(r,[-1,s]);let a=e.shape.slice(),i=a.pop(),u=a.pop(),l=[...a,i],p=Array.from({length:e.rank},(f,h)=>h===0?e.rank-2:h<=e.rank-2?h-1:h);e=F(Ge(e,p),[u,-1]);let m=[...o,...l],c=!1,d=!1;return F(Tl.matMul({a:r,b:e,transposeA:c,transposeB:d,bias:n?RA(r.rank,n,xn()):null,activation:t}),m)}}function qy(r,e,t){return z(()=>(Array.isArray(e)?e=Jt(e,"int32"):e=re(e,"int32"),bl(r,e,t)))}function bp(r){return P(r,r)}function RA(r,e,t){let n=e.shape;if(e.rank!==1&&e.rank!==r)throw new B(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${r}`);if(r===5){if(t==="channelsFirst")return n.length===1?F(e,[1,n[0],1,1,1]):F(e,[1,n[3],n[0],n[1],n[2]]);if(t==="channelsLast")return n.length===1?F(e,[1,1,1,1,n[0]]):F(e,[1].concat(n))}else if(r===4){if(t==="channelsFirst")return n.length===1?F(e,[1,n[0],1,1]):F(e,[1,n[2],n[0],n[1]]);if(t==="channelsLast")return n.length===1?F(e,[1,1,1,n[0]]):F(e,[1].concat(n))}else if(r===3){if(t==="channelsFirst")return n.length===1?F(e,[1,n[0],1]):F(e,[1,n[1],n[0]]);if(t==="channelsLast")return n.length===1?F(e,[1,1,n[0]]):F(e,[1].concat(n))}else if(r<3)return e;throw new B(`Unsupported input rank by biasAdd: ${e.rank}`)}function In(r,e,t){return z(()=>(t==null&&(t=xn()),Gt(t),Z(r,RA(r.rank,e,t))))}function uR(r,e=1){if(e!==1)throw new Ne(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return hl(r)}function lR(r){return z(()=>fe(r,Z(Ot(r),1)))}function jy(r,e,t,n){return z(()=>TA(r,e,t,n))}function pR(r){return z(()=>{let e=Z(.5,P(.2,r));return Hr(e,0,1)})}function wl(r,e,t=!1){return t?r():e()}var mR=["fanIn","fanOut","fanAvg"],cR=["normal","uniform","truncatedNormal"];function iJ(r){Bi(mR,"FanMode",r)}function uJ(r){Bi(cR,"Distribution",r)}var Cn=class extends Q.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Nc=class extends Cn{apply(e,t){return Ct(e,t)}};K(Nc,"className","Zeros");Q.registerClass(Nc);var Nl=class extends Cn{apply(e,t){return Tr(e,t)}};K(Nl,"className","Ones");Q.registerClass(Nl);var Dc=class extends Cn{value;constructor(e){if(super(),typeof e!="object")throw new B(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new B(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return z(()=>P(ge(this.value),Tr(e,t)))}getConfig(){return{value:this.value}}};K(Dc,"className","Constant");Q.registerClass(Dc);var _c=class extends Cn{DEFAULT_MINVAL=-.05;DEFAULT_MAXVAL=.05;minval;maxval;seed;constructor(e){super(),this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Pi(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};K(_c,"className","RandomUniform");Q.registerClass(_c);var Mc=class extends Cn{DEFAULT_MEAN=0;DEFAULT_STDDEV=.05;mean;stddev;seed;constructor(e){super(),this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ne(`randomNormal does not support dType ${t}.`);return wc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};K(Mc,"className","RandomNormal");Q.registerClass(Mc);var Rc=class extends Cn{DEFAULT_MEAN=0;DEFAULT_STDDEV=.05;mean;stddev;seed;constructor(e){super(),this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ne(`truncatedNormal does not support dType ${t}.`);return Ic(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};K(Rc,"className","TruncatedNormal");Q.registerClass(Rc);var Pc=class extends Cn{gain;constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return z(()=>{if(e.length!==2||e[0]!==e[1])throw new B("Identity matrix initializer can only be used for 2D square matrices.");return P(this.gain,op(e[0]))})}getConfig(){return{gain:this.gain}}};K(Pc,"className","Identity");Q.registerClass(Pc);function lJ(r,e="channelsLast"){let t,n;if(Gt(e),r.length===2)t=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(e==="channelsFirst"){let o=Js(r,2);t=r[1]*o,n=r[0]*o}else if(e==="channelsLast"){let o=Js(r,0,r.length-2);t=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=Js(r);t=Math.sqrt(o),n=Math.sqrt(o)}return[t,n]}var Qr=class extends Cn{scale;mode;distribution;seed;constructor(e){if(super(),e.scale<0)throw new B(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,iJ(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,uJ(this.distribution),this.seed=e.seed}apply(e,t){let n=lJ(e),o=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,o):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(o+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ne(`${this.getClassName()} does not support dType ${t}.`);return Ic(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return Pi(e,-i,i,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};K(Qr,"className","VarianceScaling");Q.registerClass(Qr);var yp=class extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(yp,"className","GlorotUniform");Q.registerClass(yp);var Tp=class extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(Tp,"className","GlorotNormal");Q.registerClass(Tp);var xp=class extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(xp,"className","HeNormal");Q.registerClass(xp);var Ip=class extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(Ip,"className","HeUniform");Q.registerClass(Ip);var Cp=class extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(Cp,"className","LeCunNormal");Q.registerClass(Cp);var kp=class extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(kp,"className","LeCunNormal");Q.registerClass(kp);var Ec=class extends Cn{DEFAULT_GAIN=1;gain;seed;constructor(e){if(super(),this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Ne("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return z(()=>{if(e.length<2)throw new Ne("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,o=wc(n,0,1,"float32"),s=CA.gramSchmidt(o);return e[0]>e[1]&&(s=Ge(s)),P(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};K(Ec,"className","Orthogonal");Q.registerClass(Ec);var dR={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function fR(r,e={}){return $i(r,Q.SerializationMap.getMap().classNameMap,e,"initializer")}function Mt(r){return Sc(r)}function kt(r){if(typeof r=="string"){let e=r in dR?dR[r]:r;if(e==="GlorotNormal")return new Tp;if(e==="GlorotUniform")return new yp;if(e==="HeNormal")return new xp;if(e==="HeUniform")return new Ip;if(e==="LeCunNormal")return new Cp;if(e==="LeCunUniform")return new kp;{let t={};return t.className=e,t.config={},fR(t)}}else return r instanceof Cn?r:fR(r)}function Xy(r){return Array.isArray(r)&&Array.isArray(r[0])}function Fc(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function De(r){let e;if(Array.isArray(r)){if(r.length!==1)throw new B(`Expected Tensor length to be 1; got ${r.length}`);e=r[0]}else e=r;return e}function Ke(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new B(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function Lc(r){let e=0;for(let t of r)t.shape.length===0?e+=1:e+=t.shape.reduce((n,o)=>n*o);return e}var gR="Variable",Bh=class{dtype;shape;id;name;originalName;trainable_;val;constraint;constructor(e,t="float32",n=gR,o=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Wy(),n=n??gR,this.originalName=Uy(n),this.name=Ky(this.originalName),this.trainable_=o,this.constraint=s,this.val=Ny(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),mJ(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function mJ(r,e){if(r.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(e.shape))}function Oh(r){return r.map(e=>e.read())}function $c(r){r.forEach(e=>{e[0].write(e[1])})}var wt=class{dtype;shape;ndim;maxNDim;minNDim;axes;constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},ln=class{constructor(e,t,n,o,s,a,i){this.dtype=e;this.shape=t;this.sourceLayer=n;this.inputs=o;this.callArgs=s;this.outputTensorIndex=i;this.id=Wy(),a!=null&&(this.originalName=Uy(a),this.name=Ky(this.originalName)),this.rank=t.length}id;name;originalName;rank;nodeIndex;tensorIndex},cJ=0,bu=class{constructor(e,t){this.callArgs=t;this.id=cJ++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}outboundLayer;inboundLayers;nodeIndices;tensorIndices;inputTensors;outputTensors;inputMasks;outputMasks;inputShapes;outputShapes;id;getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},dJ=0,Re=class extends Q.Serializable{name;inputSpec;supportsMasking;trainable_;batchInputShape;dtype;initialWeights;inboundNodes;outboundNodes;activityRegularizer;_trainableWeights;_nonTrainableWeights;_losses;_updates;_built;_callHook=null;_addedWeightNames=[];id;_stateful=!1;_refCount;fastWeightInitDuringBuild;constructor(e={}){super(),this.id=dJ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Zs(n)+"_"+Al(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let o=e.dtype;o==null&&(o=e.inputDType),o==null&&(o="float32"),this.dtype=o}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Zr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new B(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Pr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Pr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} is not connected, no input to return.`);return Pr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Pr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=At(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=At(this.inputSpec);if(e.length!==t.length)throw new B(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let o=e[n],s=t[n];if(s==null)continue;let a=o.rank;if(s.ndim!=null&&a!==s.ndim)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new B(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let i=o.shape;for(let u in s.axes){let l=Number(u),p=s.axes[u],m=l>=0?i[l]:i[i.length+l];if(p!=null&&[p,null].indexOf(m)===-1)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${p} but got shape ${i}.`)}}if(s.shape!=null)for(let i=0;i<s.shape.length;++i){let u=s.shape[i],l=o.shape[i];if(u!=null&&l!=null&&u!==l)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=At(e),o=!0;for(let a of n)if(!(a instanceof ln)){o=!1;break}let s=!0;for(let a of n)if(a instanceof ln){s=!1;break}if(o===s)throw new B("Arguments to apply() must be all SymbolicTensors or all Tensors");return oi(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of At(e))a.push(i.shape);this.build(Pr(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t),i=At(a),u=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(a=Pr(u),this.activityRegularizer!=null)throw new Ne("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=fJ(e),i=this.computeOutputShape(a),u,l=hJ(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?u=i.map((p,m)=>new ln(l,p,this,At(e),t,this.name,m)):u=new ln(l,i,this,At(e),t,this.name),this.addInboundNode(e,u,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new Ne("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&e[o]!=null&&e[o]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new En(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new En(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Zr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Lc(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Oh(e?this.trainableWeights:this.weights)}setWeights(e){z(()=>{let t=this.weights;if(t.length!==e.length)throw new B(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],o=Oh(t);for(let s=0;s<o.length;++s){let a=o[s],i=t[s],u=e[s];if(!y.arraysEqual(a.shape,u.shape))throw new B(`Layer weight shape ${a.shape} not compatible with provided weight shape ${u.shape}`);n.push([i,u])}$c(n)})}addWeight(e,t,n,o,s,a,i,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new B(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():kt("zeros"));let l=o.apply(t,n),p=new Bh(l,n,e,a,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(p.read())),a==null&&(a=!0),a?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=At(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,o,s,a,i=null){let u=At(e);t=At(t),n=At(n),o=At(o),s=Fc(s),a=Fc(a);let l=[],p=[],m=[];for(let c of u)l.push(c.sourceLayer),p.push(c.nodeIndex),m.push(c.tensorIndex);new bu({outboundLayer:this,inboundLayers:l,nodeIndices:p,tensorIndices:m,inputTensors:u,outputTensors:t,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:a},i);for(let c=0;c<t.length;c++)t[c].sourceLayer=this,t[c].nodeIndex=this.inboundNodes.length-1,t[c].tensorIndex=c}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function fJ(r){r=At(r);let e=[];for(let t of r)e.push(t.shape);return Pr(e)}function hJ(r){return"float32"}function EA(r,e,t){if((e==null||t!=null&&t>0)&&(e=r.sourceLayer,t=r.nodeIndex),e.inboundNodes.length===0)return[r];{let n=e.inboundNodes[t];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let a=n.inputTensors[s],i=n.inboundLayers[s],u=n.nodeIndices[s],l=EA(a,i,u);for(let p of l)o.indexOf(p)===-1&&o.push(p)}return o}}}var ai=class extends Re{sparse;constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Al("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new B("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new B("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new B("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let o=new ln(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new bu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new B(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};K(ai,"className","InputLayer");Q.registerClass(ai);function Yy(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new B("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=r.batchShape;r.shape!=null&&e==null&&(e=[null].concat(r.shape));let t=r.dtype;return t==null&&(t="float32"),new ai({batchInputShape:e,name:r.name,dtype:t,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function gJ(r,e){if(r.dtype==null||r.dtype===e.dtype)return e;try{return re(e,r.dtype)}catch{throw new B(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var ta=class{id2Value={};id2Mask={};name2Id={};constructor(e){if(e instanceof ta)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=gJ(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new B(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ln){if(this.id2Value[e.id]==null)throw new B(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new B(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ln){if(this.id2Value[e.id]==null)throw new B(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new B(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&_e(this.id2Mask)}},Zy=new Eh,Qy=new Eh;function yR(r){Zy?.setMaxEntries(r),Qy?.setMaxEntries(r)}function Sp(r,e,t,n){let o=t==null?!1:t.training,s=Array.isArray(r),a=s?r:[r],i=a.map(f=>f.name),u=[],l=e.names();for(let f of i)l.indexOf(f)!==-1?u.push(e.getValue(f)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let p=i.join(",")+"|"+e.names().sort().join(","),m=Zy.get(p),c;if(m==null){let f=bJ(a,e);m=f.sorted,c=f.recipientCounts,Zy.put(p,m),Qy.put(p,c)}c={},o||Object.assign(c,Qy.get(p));let d=new ta(e);for(let f=0;f<m.length;++f){if(n!=null){let R=Ih().numTensors;R>n.maxNumTensors&&(n.maxNumTensors=R),R<n.minNumTensors&&(n.minNumTensors=R)}let h=m[f],g=h.sourceLayer;if(g instanceof ai)continue;let b=[],T=[],x=[],I=!1;for(let R of h.inputs){let E=d.getValue(R),O=d.getMask(R);b.push(E),T.push(O),O!=null&&(I=!0),o||(c[R.name]--,c[R.name]===0&&!e.hasKey(R)&&i.indexOf(R.name)===-1&&!E.isDisposed&&R.sourceLayer.stateful!==!0&&x.push(E))}I&&(t=t||{},t.mask=T[0]);let k=At(g.apply(b,t)),w=null;g.supportsMasking&&(w=g.computeMask(b,T));let _=TJ(h),M=Array.isArray(_)?_:[_];for(let R=0;R<M.length;++R){d.hasKey(M[R])||d.add(M[R],k[R],Array.isArray(w)?w[0]:w);let E=i.indexOf(M[R].name);E!==-1&&(u[E]=k[R])}o||_e(x)}return d.disposeMasks(),s?u:u[0]}function bJ(r,e){y.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let t=[],n={};if(r.length===1){let o=bR(r[0],e);t=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:a,recipientMap:i}=bR(s,e);for(let u of a)o.has(u.name)||(t.push(u),o.add(u.name));for(let u in i)n[u]==null&&(n[u]=new Set),i[u].forEach(l=>n[u].add(l))}}return{sorted:t,recipientCounts:yJ(n)}}function yJ(r){let e={};for(let t in r)e[t]=r[t].size;return e}function bR(r,e){let t=new Set,n=[],o={};for(let i of e.names())t.add(i);let s=[],a=[];for(s.push(r);s.length>0;){let i=s[s.length-1];if(t.has(i.name)){s.pop();continue}let u=a[a.length-1]===s.length-1;if(i.inputs.length===0||u)s.pop(),n.push(i),t.add(i.name),u&&a.pop();else{a.push(s.length-1);for(let l of i.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(i.name),!t.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function TJ(r){let e;if(r.sourceLayer.inboundNodes.length===1)e=r.sourceLayer.output;else{let t=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){t=n;break}e=r.sourceLayer.getOutputAt(t)}return e}var xJ=$();xJ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,yR);var Jy={kernelName:Ts,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,Fi(re(t,"float32"),-1))}}};var TR={kernelName:ba,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=He(re(t,"float32")),o=Ft(me(ge(1),n));return tt(fe(r,o))}}}};var xR={kernelName:ya,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Ft(me(He(re(t,"float32")),1));return fe(r,n)}}}};var IR={kernelName:Nn,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=r,u=vt(t.shape,o);return u.length>0&&(i=be(i,u)),F(i,t.shape)},b:()=>{let i=r,u=vt(n.shape,o);return u.length>0&&(i=be(i,u)),F(i,n.shape)}}}};var CR={kernelName:co,saveAllInputs:!0,gradFunc:(r,e)=>{let t={};return e.forEach((n,o)=>{t[o]=()=>r.clone()}),t}};var kR={kernelName:fo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>we(t)}}};var SR={kernelName:Si,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>we(t)}}};var vR={kernelName:Ia,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,Ft(me(ge(1),He(re(t,"float32")))))}}};var AR={kernelName:Ca,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Ft(Z(ge(1),He(re(t,"float32"))));return fe(r,n)}}}};var wR={kernelName:va,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=Z(He(t),He(n)),u=P(r,fe(n,i)),l=vt(t.shape,o);return l.length>0&&(u=be(u,l)),F(u,t.shape)},b:()=>{let i=Z(He(t),He(n)),u=tt(P(r,fe(t,i))),l=vt(n.shape,o);return l.length>0&&(u=be(u,l)),F(u,n.shape)}}}};var NR={kernelName:ka,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,Z(He(re(t,"float32")),1))}}};var DR={kernelName:Sa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,me(ge(1),He(re(t,"float32"))))}}};function IJ(r,e,t,n,o,s){let a=v(r,"dy","avgPool3dGrad"),i=v(e,"input","avgPool3dGrad"),u=a,l=i,p=!1;i.rank===4&&(p=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),l=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),D(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),_t("avgPool3dGrad",o,s);let m={dy:u,input:l},c={filterSize:t,strides:n,pad:o,dimRoundingMode:s},d=N.runKernel(Sm,m,c);return p?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var _R=A({avgPool3dGrad_:IJ});var MR={kernelName:Bu,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a,dimRoundingMode:i}=t;return{x:()=>_R(r,n,o,s,a,i)}}};function CJ(r,e,t,n,o){let s=v(r,"dy","avgPoolGrad"),a=v(e,"input","avgPoolGrad");D(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let i=a,u=s,l=!1;a.rank===3&&(l=!0,i=F(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),D(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let p={dy:u,input:i},m={filterSize:t,strides:n,pad:o},c=N.runKernel(km,p,m);return l?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var RR=A({avgPoolGrad_:CJ});var PR={kernelName:ho,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a}=t;return{x:()=>RR(r,n,o,s,a)}}};var ER={kernelName:go,inputsToSave:["a","b"],gradFunc:(r,e,t)=>{let[n,o]=e,{transposeA:s,transposeB:a}=t;return!s&&!a?{a:()=>Ue(r,o,!1,!0),b:()=>Ue(n,r,!0,!1)}:!s&&a?{a:()=>Ue(r,o,!1,!1),b:()=>Ue(r,n,!0,!1)}:s&&!a?{a:()=>Ue(o,r,!1,!0),b:()=>Ue(n,r,!1,!1)}:{a:()=>Ue(o,r,!0,!0),b:()=>Ue(r,n,!0,!0)}}};var FR={kernelName:xs,gradFunc:(r,e,t)=>{let{blockShape:n,crops:o}=t;return{x:()=>fc(r,n,o)}}};var LR={kernelName:Y0,gradFunc:(r,e,t)=>{let n=t,o=n.inputShape,s=n.shape,a=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])a[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let i=[];for(let u=0;u<a.length;u++)a[u]>1&&i.push(u);return{x:()=>be(r,i,!0)}}};var $R={kernelName:Un,gradFunc:r=>({x:()=>r.clone()})};var BR={kernelName:bo,gradFunc:r=>({x:()=>we(r)})};var OR={kernelName:Kn,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{clipValueMin:o,clipValueMax:s}=t;return{x:()=>zt(sn(Xn(n,o),Hs(n,s)),r,we(r))}}};var zR={kernelName:Gu,inputsToSave:["x"],gradFunc:Jy.gradFunc};var GR={kernelName:Is,saveAllInputs:!0,gradFunc:(r,e,t)=>{let n=e.map(u=>u.shape),{axis:o}=t,s=gr(o,e[0].shape)[0],a=n.map(u=>u[s]);return Mr(r,a,s).map(u=>()=>u)}};var WR={kernelName:yo,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{dilations:s,strides:a,pad:i,dataFormat:u}=t;return D(ps(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>uc(n.shape,r,o,a,i,u),filter:()=>Cc(n,r,o.shape,a,i,u)}}};var UR={kernelName:To,inputsToSave:["dy","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{strides:s,pad:a,dataFormat:i,dimRoundingMode:u}=t;return{dy:()=>cs(r,o,s,a,i,1,u),filter:()=>Cc(r,n,o.shape,s,a,i,u)}}};function kJ(r,e,t,n,o){let s=r;r.rank===4&&(s=F(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let a=e;a.rank===4&&(a=F(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),D(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),D(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),D(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),D(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),D(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);let i={x:s,dy:a},u={strides:n,pad:o,filterShape:t};return N.runKernel(wm,i,u)}var KR=A({conv3DBackpropFilter_:kJ});var VR={kernelName:Wu,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s}=t;D(ps(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[a,i]=e;return{x:()=>ry(a.shape,r,i,o,s),filter:()=>KR(a,r,i.shape,o,s)}}};var HR={kernelName:xo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(tt(ky(re(t,"float32"))),r)}}};var qR={kernelName:Io,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(Sy(re(t,"float32")),r)}}};var jR={kernelName:Co,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o,exclusive:s,reverse:a}=t;return{x:()=>{let i=mA([o],n.rank),u=sy(r,o,s,!a);return i!=null&&(u=Ge(u,i)),u}}}};var XR={kernelName:ko,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:a}=t,i=n??[1,1];D(ps(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[u,l]=e;return D(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),D(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),D(Or(o,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${i}'.`),_t("depthwiseConv2d",s,a),{x:()=>Ry(u.shape,r,l,o,s,i,a),filter:()=>My(u,r,l.shape,o,s,i,a)}}};var YR={kernelName:Ku,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,s={x:n,filter:o,dy:r},a={x:n,filter:o,dy:r};return{x:()=>N.runKernel(uh,s,t),filter:()=>N.runKernel(lh,a,t)}}};var ZR={kernelName:vo,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e,n={dy:r,y:t};return{x:()=>N.runKernel(Rm,n)}}};var QR={kernelName:Da,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=P(br(tt(He(t))),2/Math.sqrt(Math.PI));return{x:()=>P(r,n)}}};var JR={kernelName:Ao,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,t)}}};var eP={kernelName:Cs,inputsToSave:["input"],gradFunc:(r,e)=>{let[t]=e;return{input:()=>F(r,t.shape)}}};var tP={kernelName:Ma,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,br(t))}}};var rP={kernelName:wo,gradFunc:r=>({x:()=>we(r)})};var nP={kernelName:No,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=fe(r,re(n,"float32")),u=vt(t.shape,o);return u.length>0?F(be(i,u),t.shape):i},b:()=>{let i=P(r,re(t,"float32")),u=vt(n.shape,o);u.length>0&&(i=F(be(i,u),n.shape));let l=He(n);return tt(fe(i,re(l,"float32")))}}}};var oP={kernelName:Do,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,e,t)=>{let{varianceEpsilon:n}=t,[o,s,a,i]=e,u=i??ge(1),l=vt(s.shape,o.shape),p=[];if(s.rank===1){for(let I=0;I<o.shape.length-1;++I)p.push(o.shape[I]);p.push(1)}let m=me(o,s),c=P(r,u),d=xy(Z(a,ge(n))),f=P(P(P(d,d),d),ge(-.5));return{x:()=>s.rank===1?F(P(P(r,on(F(d,[1,1,1,s.shape[0]]),p)),u),o.shape):F(P(P(r,d),u),o.shape),mean:()=>{let I=P(P(d,ge(-1)),c);return s.rank===1&&(I=be(I,l)),F(I,s.shape)},variance:()=>{let I=P(P(f,m),c);return s.rank===1&&(I=be(I,l)),F(I,s.shape)},scale:()=>{let I=P(m,d),k=P(r,I);return s.rank===1&&(k=be(k,l)),F(k,s.shape)},offset:()=>{let I=r;return s.rank===1&&(I=be(I,l)),F(I,s.shape)}}}};var iP={kernelName:ks,inputsToSave:["x","indices"],gradFunc:(r,e,t)=>{let[n,o]=e,{axis:s}=t,a=gr(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,p=u.slice(0,a),m=p.length,c=u.slice(s,u.length).slice(1),d=c.length,f=sP(0,m),h=sP(m+1,m+1+d),g=aP([p,[l],c]),b=F(r,g),T=F(o,[l]),x=aP([[m],f,h]),I=Ge(b,x),k=wy(I,T,n.shape[a]),w=Nh(x);return k=Ge(k,w),k},indices:()=>o}}};function sP(r,e){let t=[];for(let n=r;n<e;++n)t.push(n);return t}function aP(r){let e=[];for(let t=0;t<r.length;++t)for(let n=0;n<r[t].length;++n)e.push(r[t][n]);return e}var uP={kernelName:_o,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>we(t),b:()=>we(n)}}};var lP={kernelName:Vn,gradFunc:r=>({x:()=>re(r,"float32")})};var pP={kernelName:Fa,gradFunc:r=>({x:()=>we(r)})};var mP={kernelName:La,gradFunc:r=>({x:()=>we(r)})};var cP={kernelName:Mo,gradFunc:r=>({x:()=>we(r)})};var dP={kernelName:Ro,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{alpha:o}=t,s=Qt(n,0);return{x:()=>zt(s,r,P(r,o))}}};var fP={kernelName:Qi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,Z(t,1))}}};var hP={kernelName:Po,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,re(t,"float32"))}}};var gP={kernelName:Q0,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t;return{logits:()=>{let a=br(n);return me(r,P(be(r,o,!0),a))}}}};function SJ(r,e,t,n=5,o=1,s=1,a=.5){let i={x:r,y:e,dy:t},u={depthRadius:n,bias:o,alpha:s,beta:a};return N.runKernel(Lm,i,u)}var bP=A({localResponseNormalizationBackprop_:SJ});var yP={kernelName:qu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{depthRadius:s,bias:a,alpha:i,beta:u}=t;return{x:()=>bP(n,o,r,s,a,i,u)}}};function eT(r,e,t,n){return e.rank<t.rank&&(e=F(e,Vs(e.shape,n))),r.rank<t.rank&&(r=F(r,Vs(r.shape,n))),{x:()=>P(r,re(nn(t,e),r.dtype))}}var FA={kernelName:Eo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{reductionIndices:o}=n,s=e[0],a=e[1],i=gr(o,s.shape),u=eT(r,a,s,i);return{x:()=>u.x()}}};var TP={kernelName:Fo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>P(r,re(Xn(t,n),"float32")),b:()=>P(r,re(ay(t,n),"float32"))}}};function vJ(r,e,t,n,o,s,a){let i=v(r,"dy","maxPool3dGrad"),u=v(e,"input","maxPool3dGrad"),l=v(t,"output","maxPool3dGrad"),p=i,m=u,c=l,d=!1;u.rank===4&&(d=!0,p=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),m=F(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),c=F(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),D(p.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),D(m.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${m.rank}.`),D(c.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${c.rank}.`),_t("maxPool3dGrad",s,a);let f={dy:p,input:m,output:c},h={filterSize:n,strides:o,pad:s,dimRoundingMode:a},g=N.runKernel(Bm,f,h);return d?F(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var xP=A({maxPool3dGrad_:vJ});var IP={kernelName:ju,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=t;return{x:()=>xP(r,n,o,s,a,i,u)}}};function AJ(r,e,t,n,o,s,a){let i=v(r,"dy","maxPoolGrad"),u=v(e,"input","maxPoolGrad"),l=v(t,"output","maxPoolGrad");D(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),D(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),D(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),_t("maxPoolGrad",s,a);let p={dy:i,input:u,output:l},m={filterSize:n,strides:o,pad:s,dimRoundingMode:a};return N.runKernel($m,p,m)}var CP=A({maxPoolGrad_:AJ});var kP={kernelName:Lo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i}=t;return{x:()=>CP(r,n,o,s,a,i)}}};var SP={kernelName:$o,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t,s=gr(o,n.shape),i=pA(n.shape,s)[1],u=nt(i);return{x:()=>{let p=n.shape.slice();s.forEach(d=>{p[d]=1});let m=F(r,p);return fe(P(m,Tr(n.shape,"float32")),u)}}}};var vP={kernelName:Bo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{axis:o}=n,[s,a]=e,i=gr(o,s.shape),u=eT(r,a,s,i);return{x:()=>u.x()}}};var AP={kernelName:Oo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>P(r,re(Hs(t,n),"float32")),b:()=>P(r,re(Qt(t,n),"float32"))}}};var wP={kernelName:zo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>ze(r,s,n.shape)}}};var NP={kernelName:Ga,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=vt(t.shape,o);return i.length>0?F(be(r,i),t.shape):r},b:()=>{let i=P(r,tt(gl(fe(t,n)))),u=vt(n.shape,o);return u.length>0?F(be(i,u),n.shape):i}}}};var DP={kernelName:Go,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=P(r,re(n,"float32")),u=vt(t.shape,o);return u.length>0?F(be(i,u),t.shape):i},b:()=>{let i=P(r,re(t,"float32")),u=vt(n.shape,o);return u.length>0?F(be(i,u),n.shape):i}}}};var _P={kernelName:Ss,gradFunc:r=>({x:()=>tt(r)})};var MP={kernelName:Wo,inputsToSave:["indices"],gradFunc:(r,e)=>{let t=e[0];return{indices:()=>Ct(t.shape,"float32")}}};var RP={kernelName:vs,gradFunc:r=>({x:()=>we(r)})};var PP={kernelName:As,saveAllInputs:!0,gradFunc:(r,e,t)=>{let{axis:n}=t;return Rr(r,n).map(s=>()=>s)}};var LA={kernelName:Uo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>ze(r,s,n.shape)}}};var EP={kernelName:Ko,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,e)=>{let[t,n,o]=e,s=t,a=n,i=Oe(s.shape,a.shape);return{a:()=>{let p=re(a,"float32"),m=P(r,P(p,jn(s,me(p,ge(1))))),c=vt(s.shape,i);return c.length>0&&(m=be(m,c)),F(m,s.shape)},b:()=>{let p=Qt(s,0),m=zt(p,jr(s),we(s)),c=P(r,P(o,m)),d=vt(a.shape,i);return d.length>0&&(c=be(c,d)),F(c,a.shape)}}}};var FP={kernelName:Vo,inputsToSave:["x","alpha"],gradFunc:(r,e)=>{let[t,n]=e,o=Qt(t,0);return{x:()=>zt(o,r,P(r,n)),alpha:()=>{let s=zt(o,we(r),P(r,t)),a=vt(n.shape,r.shape);return a.length>0&&(s=be(s,a)),F(s,n.shape)}}}};function wJ(r,e,t){let n=r.shape.slice();n[t]=1;let o=F(e,n),s=Ah(r,t,!0,!1),a=Ah(r,t,!0,!0),i=P(s,a);return P(o,i)}function NJ(r,e,t){let n=r.shape.length,o=n-t.length,s=C.getAxesPermutation(t,n),a=r;s!=null&&(a=Ge(r,s));let i=a.shape.slice(),l=i.splice(n-t.length,t.length).reduce((c,d)=>c*d,1);i.push(l);let p=a.reshape(i),m=wJ(p,e,o);if(m=m.reshape(a.shape),s!=null){let c=C.getUndoAxesPermutation(s);m=Ge(m,c)}return m}var LP={kernelName:Ho,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t,s=[];return o==null?s=n.shape.map((a,i)=>i):typeof o=="number"?s=[o]:s=o,{x:()=>NJ(n,r,s)}}};var $P={kernelName:So,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=fe(r,re(n,"float32")),u=vt(t.shape,o);return u.length>0?F(be(i,u),t.shape):i},b:()=>{let i=P(r,re(t,"float32")),u=vt(n.shape,o);u.length>0&&(i=F(be(i,u),n.shape));let l=He(n);return tt(fe(i,re(l,"float32")))}}}};var BP={kernelName:qo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,tt(He(t)))}}};var OP={kernelName:Zo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=P(Hs(t,6),Fi(t));return{x:()=>P(r,re(n,"float32"))}}};var zP={kernelName:jo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,re(Fi(t),"float32"))}}};var GP={kernelName:ws,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>F(r,t.shape)}}};var WP={kernelName:Yo,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(Vm,o,t)}}};var UP={kernelName:Xo,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(Km,o,t)}}};var KP={kernelName:Qo,gradFunc:(r,e,t)=>{let{dims:n}=t,o=gr(n,r.shape);return{x:()=>_r(r,o)}}};var VP={kernelName:Va,gradFunc:r=>({x:()=>we(r)})};var HP={kernelName:Jo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>tt(fe(r,P(jn(t,1.5),2)))}}};var qP={kernelName:Ns,inputsToSave:["condition"],gradFunc:(r,e)=>{let[t]=e;return{condition:()=>re(we(t),"float32"),t:()=>P(r,re(t,r.dtype)),e:()=>P(r,re(cc(t),r.dtype))}}};var jP={kernelName:tu,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Qt(t,ge(0)),o=ge(kA),s=ge(SA),a=P(r,s),i=P(P(r,o),br(re(t,"float32")));return zt(n,a,i)}}}};var XP={kernelName:ts,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,P(t,me(ge(1),t)))}}};var YP={kernelName:ru,gradFunc:r=>({x:()=>we(r)})};var ZP={kernelName:es,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(lc(re(t,"float32")),r)}}};var QP={kernelName:qa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(oy(re(t,"float32")),r)}}};var JP={kernelName:Ds,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{begin:o,size:s}=t,a=n.shape,[i,u]=nA(n,o,s),l=[];for(let p=0;p<r.rank;p++)l.push([i[p],a[p]-i[p]-u[p]]);return{x:()=>Yn(r,l)}}};var eE={kernelName:os,outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{dim:o}=t,s=!0,a=P(r,n);return{logits:()=>me(a,P(be(a,[o],s),n))}}};var tE={kernelName:nu,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,Pn(t))}}};var $A={kernelName:_s,gradFunc:(r,e,t)=>{let{blockShape:n,paddings:o}=t;return{x:()=>ic(r,n,o)}}};var BA={kernelName:Ms,gradFunc:(r,e,t)=>{let{axis:n}=t;return{x:()=>ct(r,n)}}};var rE={kernelName:rs,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,P(Ft(re(t,"float32")),2))}}};var nE={kernelName:wi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,P(re(t,"float32"),2))}}};var oE={kernelName:ss,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=ge(2);return{a:()=>P(r,P(o,me(t,n))),b:()=>P(r,P(o,me(n,t)))}}};var sE={kernelName:Es,gradFunc:r=>({x:()=>we(r)})};var aE={kernelName:as,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=r,u=vt(t.shape,o);return u.length>0&&(i=be(i,u)),F(i,t.shape)},b:()=>{let i=r,u=vt(n.shape,o);return u.length>0&&(i=be(i,u)),F(tt(i),n.shape)}}}};var iE={kernelName:ns,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,o=n.shape.slice(),{axis:s}=t;gr(s,n.shape).forEach(l=>{o[l]=1});let i=F(r,o),u=P(i,Tr(n.shape,"float32"));return{x:()=>u}}};var uE={kernelName:is,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,He(lc(t)))}}};var lE={kernelName:us,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(me(ge(1),He(t)),r)}}};var pE={kernelName:Dn,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{reps:o}=t;return{x:()=>{let a=we(n);if(n.rank===1)for(let i=0;i<o[0];++i)a=Z(a,ze(r,[i*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)a=Z(a,ze(r,[i*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)a=Z(a,ze(r,[i*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let p=0;p<o[3];++p)a=Z(a,ze(r,[i*n.shape[0],u*n.shape[1],l*n.shape[2],p*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return a}}}};var mE={kernelName:_n,gradFunc:(r,e,t)=>{let n=t,{perm:o}=n,s=Nh(o);return{x:()=>Ge(r,s)}}};var cE={kernelName:Rs,gradFunc:(r,e,t)=>{let n=t,{axis:o}=n;return{value:()=>cr(r,o)}}};var dE={kernelName:rl,inputsToSave:["segmentIds"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>DJ(r,t)}}};function DJ(r,e){let t=ds(e,we(e)),n=bl(r,t),o=Xn(e,ge(0,"int32")),s=n.rank-o.rank;for(let i=0;i<s;++i)o=yr(o,i+1);o=sn(o,Tr(n.shape,"bool"));let a=we(n);return zt(o,n,a)}var fE={kernelName:Ps,gradFunc:r=>({x:()=>we(r)})};var _J=[Jy,TR,xR,IR,CR,kR,SR,vR,AR,wR,NR,DR,MR,PR,ER,FR,LR,$R,BR,OR,zR,GR,UR,WR,VR,HR,qR,jR,XR,YR,$P,ZR,QR,JR,eP,tP,nP,rP,oP,iP,uP,lP,pP,mP,cP,dP,fP,hP,gP,yP,FA,FA,TP,IP,kP,SP,vP,AP,wP,NP,DP,_P,MP,RP,PP,LA,LA,EP,FP,LP,BP,OP,zP,GP,WP,UP,KP,VP,HP,qP,jP,XP,YP,ZP,QP,JP,eE,tE,$A,$A,BA,BA,rE,oE,nE,sE,aE,iE,uE,lE,pE,mE,cE,dE,fE];for(let r of _J)e_(r);var bE={};qe(bE,{maxNorm:()=>MJ,minMaxNorm:()=>EJ,nonNeg:()=>PJ,unitNorm:()=>RJ});function OA(r,e){return z(()=>Ft(be(P(r,r),e,!0)))}var vp=class extends Q.Serializable{getConfig(){return{}}},Bc=class extends vp{maxValue;axis;defaultMaxValue=2;defaultAxis=0;constructor(e){super(),this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return z(()=>{let t=OA(e,this.axis),n=Hr(t,0,this.maxValue);return P(e,fe(n,Z(fr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};K(Bc,"className","MaxNorm");Q.registerClass(Bc);var Oc=class extends vp{axis;defaultAxis=0;constructor(e){super(),this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return z(()=>fe(e,Z(fr(),OA(e,this.axis))))}getConfig(){return{axis:this.axis}}};K(Oc,"className","UnitNorm");Q.registerClass(Oc);var zc=class extends vp{apply(e){return an(e)}};K(zc,"className","NonNeg");Q.registerClass(zc);var Gc=class extends vp{minValue;maxValue;rate;axis;defaultMinValue=0;defaultMaxValue=1;defaultRate=1;defaultAxis=0;constructor(e){super(),this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return z(()=>{let t=OA(e,this.axis),n=Z(P(this.rate,Hr(t,this.minValue,this.maxValue)),P(1-this.rate,t));return P(e,fe(n,Z(fr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};K(Gc,"className","MinMaxNorm");Q.registerClass(Gc);var hE={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Vt(r){return Sc(r)}function gE(r,e={}){return $i(r,Q.SerializationMap.getMap().classNameMap,e,"constraint")}function Ht(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in hE?hE[r]:r,config:{}};return gE(t)}else return r instanceof vp?r:gE(r)}function MJ(r){return new Bc(r)}function RJ(r){return new Oc(r)}function PJ(){return new zc}function EJ(r){return new Gc(r)}var yE={};qe(yE,{constant:()=>$J,glorotNormal:()=>KJ,glorotUniform:()=>UJ,heNormal:()=>VJ,heUniform:()=>HJ,identity:()=>GJ,leCunNormal:()=>qJ,leCunUniform:()=>jJ,ones:()=>LJ,orthogonal:()=>XJ,randomNormal:()=>OJ,randomUniform:()=>BJ,truncatedNormal:()=>zJ,varianceScaling:()=>WJ,zeros:()=>FJ});function FJ(){return new Nc}function LJ(){return new Nl}function $J(r){return new Dc(r)}function BJ(r){return new _c(r)}function OJ(r){return new Mc(r)}function zJ(r){return new Rc(r)}function GJ(r){return new Pc(r)}function WJ(r){return new Qr(r)}function UJ(r){return new yp(r)}function KJ(r){return new Tp(r)}function VJ(r){return new xp(r)}function HJ(r){return new Ip(r)}function qJ(r){return new Cp(r)}function jJ(r){return new kp(r)}function XJ(r){return new Ec(r)}var YE={};qe(YE,{Layer:()=>Re,RNN:()=>gs,RNNCell:()=>xu,activation:()=>mee,add:()=>xee,alphaDropout:()=>nte,average:()=>Iee,averagePooling1d:()=>nw,averagePooling2d:()=>ow,averagePooling3d:()=>sw,avgPool1d:()=>_ee,avgPool2d:()=>Ree,avgPool3d:()=>Eee,avgPooling1d:()=>Mee,avgPooling2d:()=>Pee,avgPooling3d:()=>Fee,batchNormalization:()=>wee,bidirectional:()=>Xee,categoryEncoding:()=>ute,centerCrop:()=>ate,concatenate:()=>Cee,conv1d:()=>ree,conv2d:()=>nee,conv2dTranspose:()=>oee,conv3d:()=>see,conv3dTranspose:()=>aee,convLstm2d:()=>Vee,convLstm2dCell:()=>Hee,cropping2D:()=>uee,dense:()=>cee,depthwiseConv2d:()=>pee,dot:()=>Aee,dropout:()=>dee,elu:()=>Y9,embedding:()=>Tee,flatten:()=>hee,gaussianDropout:()=>rte,gaussianNoise:()=>tte,globalAveragePooling1d:()=>Lee,globalAveragePooling2d:()=>$ee,globalMaxPool1d:()=>Zee,globalMaxPool2d:()=>Qee,globalMaxPooling1d:()=>HE,globalMaxPooling2d:()=>qE,gru:()=>Oee,gruCell:()=>zee,input:()=>qA,inputLayer:()=>X9,layerNormalization:()=>Nee,leakyReLU:()=>Q9,lstm:()=>Gee,lstmCell:()=>Wee,masking:()=>ote,maxPool1d:()=>Jee,maxPool2d:()=>ete,maxPooling1d:()=>jE,maxPooling2d:()=>XE,maxPooling3d:()=>Bee,maximum:()=>kee,minimum:()=>See,multiply:()=>vee,permute:()=>yee,prelu:()=>J9,reLU:()=>Z9,repeatVector:()=>gee,rescaling:()=>ste,reshape:()=>bee,resizing:()=>ite,rnn:()=>qee,separableConv2d:()=>iee,simpleRNN:()=>Uee,simpleRNNCell:()=>Kee,softmax:()=>eee,spatialDropout1d:()=>fee,stackedRNNCells:()=>jee,thresholdedReLU:()=>tee,timeDistributed:()=>Yee,upSampling2d:()=>lee,zeroPadding2d:()=>Dee});async function Oi(r){if(r==null)return;let e=[],t=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let a=s;e.push(a.data()),t.push(o),n.push(a)}}if(e.length>0){let o=await Promise.all(e);for(let s=0;s<o.length;++s)r[t[s]]=o[s][0];_e(n)}}function tT(r){if(r!=null)for(let e in r){let t=r[e];typeof t!="number"&&t.dispose()}}var YJ=125,yu=class{validationData=null;params;setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},rT=class{callbacks;queueLength;constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},zA=class extends yu{seen;totals;constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let o in t){let s=t[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let a;o in this.totals?a=this.totals[o]:this.totals[o]=0;let i=z(()=>Z(this.totals[o],P(s,n)));this.totals[o]=i,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:z(()=>{let o=P(fe(1,this.seen),this.totals[n]);t[n]=o,this.totals[n].dispose(),Et(t[n])}))}},nT=class extends yu{epoch;history;async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let u=a[i];e.push(u.data()),t.push(s),n.push(i)}}let o=await Promise.all(e);for(let s=0;s<o.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=o[s][0]}},oT=class extends yu{trainBegin;trainEnd;epochBegin;epochEnd;batchBegin;batchEnd;yield;yieldEvery;currentEpoch=0;nowFunc;nextFrameFunc;constructor(e,t){if(super(),this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Ph,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=YJ),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");y.isNumber(this.yieldEvery)&&(this.maybeWait=XM(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let o=[];this.yield!=null&&(await Oi(n),o.push(this.yield(e,t,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Oi(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await Oi(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Oi(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await Oi(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):y.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await Oi(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Oi(e),await this.trainEnd(e))}};function sT(r,e){return r==null&&(r={}),r instanceof yu?[r]:Array.isArray(r)&&r[0]instanceof yu?r:At(r).map(n=>new oT(n,e))}var ii=class{constructor(){}static registerCallbackConstructor(e,t){y.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),ii.checkForDuplicate(t),ii.constructors[e]==null&&(ii.constructors[e]=[]),ii.constructors[e].push(t)}static checkForDuplicate(e){for(let t in ii.constructors)ii.constructors[+t].forEach(o=>{if(o===e)throw new B("Duplicate callback constructor.")})}static clear(){ii.constructors={}}static createCallbacks(e){let t=[];for(let n in ii.constructors){let o=+n;e>=o&&t.push(...ii.constructors[o])}return t.map(n=>new n)}},Wc=ii;K(Wc,"constructors",{});function aT(r,e,t,n,o,s,a,i,u){let l=new nT,p=[new zA,...Wc.createCallbacks(e)];r!=null&&p.push(...r),p.push(l);let m=new rT(p);return m.setParams({epochs:t,initialEpoch:n,samples:o,steps:s,batchSize:a,verbose:e,doValidation:i,metrics:u}),{callbackList:m,history:l}}function kn(r,e={},t=!1){return $i(r,Q.SerializationMap.getMap().classNameMap,e,"layer",t)}function zh(r,e){return z(()=>{r.dtype!=="float32"&&(r=re(r,"float32"));let t=be(bp(r),e,!0),n=Ks(t.shape,fr()),o=Ft(ds(t,n));return fe(r,o)})}function zi(r,e){return z(()=>Lt(bp(me(e,r)),-1))}function Uc(r,e){return z(()=>Lt(Ot(me(e,r)),-1))}function Dl(r,e){return z(()=>{let t=me(r,e),n=Hr(Ot(r),fr(),Number.MAX_VALUE),o=Ot(fe(t,n));return P(100,Lt(o,-1))})}function ZJ(r,e){return z(()=>{let t=Hr(e,fr(),Number.MAX_VALUE),n=jr(Z(1,t)),o=Hr(r,fr(),Number.MAX_VALUE),s=jr(Z(1,o));return Lt(bp(me(n,s)),-1)})}function QJ(r,e){return z(()=>{let t=ds(0,me(1,P(r,e)));return Lt(bp(t),-1)})}function JJ(r,e){return z(()=>{let t=ds(0,me(1,P(r,e)));return Lt(t,-1)})}function e9(r,e){return z(()=>{let t=be(P(r,e),-1),n=qr(P(me(1,r),e),-1);return ds(0,Z(1,me(n,t)))})}function t9(r,e){return z(()=>{let t=Math.log(2),n=me(e,r),o=me(Z(n,cu(P(-2,n))),t);return Lt(o,-1)})}function Ap(r,e,t=!1){return z(()=>{if(t)e=yc(e);else{let n=be(e,e.shape.length-1,!0);e=fe(e,n)}return e=Hr(e,fr(),1-fr()),tt(be(P(re(r,"float32"),jr(e)),e.shape.length-1))})}function Kc(r,e,t=!1){return z(()=>{let n=re(gl(aR(r)),"int32");e=Hr(e,fr(),1-fr());let o=e.shape,s=F(il(n,o[o.length-1]),o);return Ap(s,e,t)})}function r9(r,e){if(!y.arraysEqual(r.shape,e.shape))throw new B(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(e.shape)}`);return z(()=>{let t=an(e),n=tt(Ot(e));return Z(me(t,P(e,r)),mc(br(n)))})}function Vc(r,e){return z(()=>{let t;return t=Hr(e,fr(),1-fr()),t=jr(fe(t,me(1,t))),Lt(r9(r,t),-1)})}function n9(r,e){return z(()=>{let t=Hr(r,fr(),1),n=Hr(e,fr(),1);return be(P(r,jr(fe(t,n))),-1)})}function o9(r,e){return z(()=>{let t=jr(Z(fr(),e));return Lt(me(e,P(r,t)),-1)})}function Wh(r,e){return z(()=>{let t=zh(r,-1),n=zh(e,-1),o=P(t,n);return tt(be(o,-1))})}var Gh={meanSquaredError:zi,meanAbsoluteError:Uc,meanAbsolutePercentageError:Dl,meanSquaredLogarithmicError:ZJ,squaredHinge:QJ,hinge:JJ,categoricalHinge:e9,logcosh:t9,categoricalCrossentropy:Ap,sparseCategoricalCrossentropy:Kc,binaryCrossentropy:Vc,kullbackLeiblerDivergence:n9,poisson:o9,cosineProximity:Wh};function iT(r){if(typeof r=="string"){if(r in Gh)return Gh[r];let e=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new B(e)}else return r}function Uh(r,e){return z(()=>{let t=P(.5,zr(e)),n=un(Qt(e,t),r.dtype);return Lt(nn(r,n),-1)})}function Kh(r,e){return z(()=>un(nn(pl(r,-1),pl(e,-1)),"float32"))}function xE(r,e){return z(()=>re(be(sn(nn(r,1),nn(e,1))),"float32"))}function s9(r,e){return z(()=>re(be(sn(nn(r,1),nn(e,0))),"float32"))}function a9(r,e){return z(()=>re(be(sn(nn(r,0),nn(e,1))),"float32"))}function GA(r,e){return z(()=>{let t=xE(r,e),n=a9(r,e),o=Z(t,n);return re(zt(Qt(o,0),fe(t,o),0),"float32")})}function IE(r,e){return z(()=>{let t=xE(r,e),n=s9(r,e),o=Z(t,n);return re(zt(Qt(o,0),fe(t,o),0),"float32")})}function lT(r,e){return Vc(r,e)}function pT(r,e){return r.rank===e.rank&&(r=qs(r,[r.rank-1])),e=pl(e,-1),e.dtype!==r.dtype&&(e=re(e,r.dtype)),re(nn(r,e),"float32")}var i9=zi,u9=zi,l9=Uc,p9=Uc,m9=Dl,c9=Dl,Vh=Ap,d9=Wh,WA=Kc,uT={binaryAccuracy:Uh,categoricalAccuracy:Kh,precision:GA,categoricalCrossentropy:Vh,sparseCategoricalCrossentropy:WA,mse:i9,MSE:u9,mae:l9,MAE:p9,mape:m9,MAPE:c9,cosine:d9};function CE(r){if(typeof r=="string"&&r in uT)return uT[r];if(typeof r!="string"&&r!=null)return r;throw new B(`Unknown metric ${r}`)}function Hh(r){if(hs(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let e;for(let t of Object.keys(Gh))if(Gh[t]===r){e=t;break}if(e!==void 0)return e;for(let t of Object.keys(uT))if(uT[t]===r){e=t;break}return e!==void 0?e:r.name}}function SE(r){let e={Adagrad:()=>hp.adagrad(.01),Adadelta:()=>hp.adadelta(1,.95,fr()),Adam:()=>hp.adam(.001,.9,.999,fr()),Adamax:()=>hp.adamax(.002,.9,.999,fr(),0),RMSProp:()=>hp.rmsprop(.001,.9,0,fr()),SGD:()=>hp.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,r in e)return e[r]();throw new B(`Unknown Optimizer ${r}`)}function KA(r,e,t=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!UA(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function UA(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let e=Object.keys(r);for(let t of e)if(typeof t!="string"||!UA(r[t]))return!1;return!0}else if(Array.isArray(r)){for(let e of r)if(!UA(e))return!1;return!0}else return!1;else{let e=typeof r;return e==="string"||e==="number"||e==="boolean"}}function vE(r,e,t,n=console.log){let o=g9(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(p=>Math.floor(e*p)));let a;if(!o){s.push("Receives inputs"),a=[];for(let p in r.nodesByDepth)a.push(...r.nodesByDepth[p])}n("_".repeat(e)),mT(s,t,n),n("=".repeat(e));let i=r.layers;for(let p=0;p<i.length;++p)o?b9(i[p],t,n):y9(i[p],t,a,n),n((p===i.length-1?"=":"_").repeat(e));r.checkTrainableWeightsConsistency();let u=h9(r),l=Lc(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(e))}function h9(r){let e;return r.collectedTrainableWeights!=null?e=Lc(r.collectedTrainableWeights):e=Lc(r.trainableWeights),e}function g9(r){let e=!0,t=[],n=[];for(let o in r.nodesByDepth)t.push(r.nodesByDepth[o]);for(let o of t){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){e=!1;break}n.push(...o)}if(e)for(let o of r.layers){let s=!1;for(let a of o.inboundNodes)if(n.indexOf(a)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function mT(r,e,t=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,e[o]),n+=" ".repeat(e[o]-n.length);t(n)}function b9(r,e,t){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{o="multiple"}try{n=JSON.stringify(r.outputShape)}catch{n="multiple"}let s=r.name,a=r.getClassName(),i=[`${s} (${a})`,o,n,r.countParams().toString()];mT(i,e,t)}function y9(r,e,t,n){let o,s;try{s=r.inboundNodes.map(m=>JSON.stringify(m.inputShapes)).join(",")}catch{s="multiple"}try{o=JSON.stringify(r.outputShape)}catch{o="multiple"}let a=[];for(let m of r.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(m)===-1))for(let c=0;c<m.inboundLayers.length;++c){let d=m.inboundLayers[c].name,f=m.nodeIndices[c],h=m.tensorIndices[c];a.push(`${d}[${f}][${h}]`)}let i=r.name,u=r.getClassName(),l=a.length===0?"":a[0],p=[`${i} (${u})`,s,o,r.countParams().toString(),l];mT(p,e,n);for(let m=1;m<a.length;++m)mT(["","","","",a[m]],e,n)}function AE(r,e,t){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&e===0&&typeof t=="string"}function wp(r,e){if(r===null)return null;if(typeof r=="string")return fu(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];AE(e,o,s)?t.push(s):t.push(wp(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")t[n]=o;else{let s=fu(n);t[s]=wp(o,s)}}return t}}function cT(r,e){if(r==null)return null;if(typeof r=="string")return Zs(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];AE(e,o,s)?t.push(s):t.push(cT(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n],s=Zs(n);(n==="name"||n==="className")&&typeof o=="string"?t[s]=o:t[s]=cT(o,n)}return t}}var qh="0.0.0";var Zn=class extends Re{inputs;outputs;inputLayers;inputLayersNodeIndices;inputLayersTensorIndices;outputLayers;outputLayersNodeIndices;outputLayersTensorIndices;layers;layersByDepth;nodesByDepth;internalContainerRefs;containerNodes=new Set;inputNames;outputNames;feedInputShapes;internalInputShapes;internalOutputShapes;feedInputNames;feedOutputNames;constructor(e){if(super({}),this.name=e.name,this.name==null){let T=this.getClassName().toLowerCase();this.name=Al(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Qs(this.inputs).length!==this.inputs.length)throw new B(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Qs(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let T of this.outputs){let x=T.sourceLayer,I=T.nodeIndex,k=T.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(I),this.outputLayersTensorIndices.push(k)}for(let T of this.inputs){let x=T.sourceLayer,I=T.nodeIndex,k=T.tensorIndex;hs(I===0,"input layer has >1 nodes"),hs(k===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(I),this.inputLayersTensorIndices.push(k)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){let x=this.inputLayers[T];if(!(x instanceof ai))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${T} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);let t={},n={},o={},s={},a={},i=[],u=(T,x,I,k,w,_)=>{(k==null||w==null||_==null)&&(k=T.sourceLayer,w=T.nodeIndex,_=T.tensorIndex);let M=k.inboundNodes[w];if(I.indexOf(M)!==-1)throw new Zr(`The tensor ${T.name} at layer "${k.name}" is part of a cycle.`);if(x.indexOf(M)!==-1)return;this.containerNodes.add(Zn.nodeKey(k,w)),k.id in a||(a[k.id]=Object.keys(a).length),I.indexOf(M)===-1&&I.push(M);let R=M.inboundLayers.length;for(let E=0;E<R;E++){let O=M.inputTensors[E],G=M.inboundLayers[E],W=M.nodeIndices[E],H=M.tensorIndices[E];u(O,x,I,G,W,H)}for(x.push(M);I.indexOf(M)>=0;)I.splice(I.indexOf(M),1);i.push(M)},l=[],p=[];for(let T of this.outputs)u(T,l,p);let m=i.slice().reverse();for(let T of m){n[T.id]=T,T.id in t||(t[T.id]=0);let x=t[T.id],I=o[T.outboundLayer.id]==null?0:o[T.outboundLayer.id];x=Math.max(x,I),o[T.outboundLayer.id]=x,s[T.outboundLayer.id]=T.outboundLayer,t[T.id]=x;for(let k=0;k<T.inboundLayers.length;k++){let w=T.inboundLayers[k],_=T.nodeIndices[k],M=w.inboundNodes[_],R=t[M.id]==null?0:t[M.id];t[M.id]=Math.max(x+1,R),n[M.id]=M}}let c={};for(let T in t){let x=t[T];x in c||(c[x]=[]),c[x].push(n[T])}let d={};for(let T in o){let x=o[T];x in d||(d[x]=[]),d[x].push(s[T])}let f=Object.keys(d).map(T=>parseInt(T,10)).sort(Fh);this.layers=[];for(let T of f){let x=d[T];x.sort((I,k)=>{let w=a[I.id],_=a[k.id];return w<_?-1:w>_?1:0});for(let I of x)I instanceof Zn&&this.internalContainerRefs.push(I),this.layers.push(I)}this.layersByDepth=d,f=Object.keys(c).map(T=>parseInt(T,10)).sort(Fh);let h=this.inputs.slice(),g=[];for(let T of f)for(let x of c[T]){let I=x.outboundLayer;if(I!=null){for(let k of x.inputTensors)if(h.indexOf(k)===-1)throw new Zr(`Graph disconnected: cannot obtain value for tensor ${k} at layer "${I.name}". The following previous layers were accessed without issue: ${g}`);for(let k of x.outputTensors)h.push(k);g.push(I.name)}}this.nodesByDepth=c;let b=this.layers.map(T=>T.name);for(let T of b){let x=b.filter(I=>I===T).length;if(x!==1)throw new Zr(`The name "${T}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new bu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new B("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},o=0;for(let a of this.layers)for(let i of a.weights){if(n[i.originalName]!=null)throw new B(`Duplicate weight name: ${i.originalName}`);n[i.originalName]=i,o++}let s=[];for(let a in e){let i=a;if(n[a]==null){let u=a.split("/");i=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[i]!=null)s.push([n[i],e[a]]);else if(t)throw new B(`Provided weight data has no target variable: ${a}`);delete n[i]}if(t){let a=[];for(let i in n)a.push(i);if(a.length>0)throw new B(`${a.length} of ${o} weights are not set: ${a}`)}$c(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${qh}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=cT(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return z(()=>{e=At(e);let n=new ta;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],e[o]);return Sp(this.outputs,n,t)})}computeMask(e,t){return z(()=>{e=At(e);let n;return t==null?n=Ys(null,e.length):n=At(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=Fc(e);if(t.length!==this.inputLayers.length)throw new B(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let u=this.inputLayers[i],l=t[i],p=u.name+"_0_0";n[p]=l}let o=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(Fh);if(o.length>1)for(let i of o){let u=this.nodesByDepth[i];for(let l of u){let p=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(p.id)!==-1)continue;let m=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],b=l.nodeIndices[h],T=l.tensorIndices[h],x=`${g.name}_${b}_${T}`,I=n[x];m.push(I)}let c=p.computeOutputShape(Pr(m)),d=Fc(c),f=p.inboundNodes.indexOf(l);for(let h=0;h<d.length;h++){let g=`${p.name}_${f}_${h}`;n[g]=d[h]}}}let s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){let u=this.outputLayers[i],l=this.outputLayersNodeIndices[i],p=this.outputLayersTensorIndices[i],m=`${u.name}_${l}_${p}`;a.push(m)}for(let i=0;i<a.length;i++){let u=a[i];hs(u in n),s.push(n[u])}return Pr(s)}runInternalGraph(e,t){t==null&&(t=Ys(null,e.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],p=e[u],m=t[u];n[l.id]=[p,m]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Fh);for(let u of o){let l=this.nodesByDepth[u];for(let p of l){let m=p.outboundLayer,c=p.inputTensors,d=p.outputTensors,f=new Array;for(let h of c)h.id in n&&f.push(n[h.id]);if(f.length===c.length){let h={},g,b,T,x;if(p.callArgs!=null&&(h=p.callArgs),f.length===1){let[I,k]=f[0];h.mask==null&&(h.mask=k),T=At(m.call(I,h)),x=At(m.computeMask(I,k)),g=[I],b=[k]}else g=f.map(I=>I[0]),b=f.map(I=>I[1]),h.mask==null&&(h.mask=b),T=At(m.call(g,h)),x=At(m.computeMask(g,b));if(m.activityRegularizer)throw new Ne("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let I=0;I<d.length;++I){let k=d[I],w=T[I],_=x[I];n[k.id]=[w,_]}}}}let s=[],a=[],i=[];for(let u of this.outputs){hs(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,p]=n[u.id];i.push(l.shape),s.push(l),a.push(p)}return[s,a,i]}buildNodeConversionMap(e){let t={},n;for(let o of this.layers){n=o instanceof Zn?1:0;for(let s=0;s<o.inboundNodes.length;s++){let a=Zn.nodeKey(o,s);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new B(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new B("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new B(`No such layer: ${e}`)}calculateLosses(){return z(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let o=Zn.nodeKey(t,n);this.containerNodes.has(o)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let i=a.getClassName(),u=a.getConfig(),l=[];for(let m=0;m<a.inboundNodes.length;m++){let c=a.inboundNodes[m],d=Zn.nodeKey(a,m),f={};if(this.containerNodes.has(d)){if(c.callArgs)try{JSON.stringify(c.callArgs),f=c.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${c.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(c.inboundLayers.length>0){let h=[];for(let g=0;g<c.inboundLayers.length;g++){let b=c.inboundLayers[g],T=c.nodeIndices[g],x=c.tensorIndices[g],I=Zn.nodeKey(b,T),k=t[I];k==null&&(k=0),h.push([b.name,k,x,f])}l.push(h)}}}let p={};p.name=a.name,p.className=i,p.config=u,p.inboundNodes=l,n.push(p)}e.layers=n;let o=[];for(let a=0;a<this.inputLayers.length;a++){let i=this.inputLayers[a],u=this.inputLayersNodeIndices[a],l=Zn.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let m=this.inputLayersTensorIndices[a];o.push([i.name,p,m])}e.inputLayers=o;let s=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],u=this.outputLayersNodeIndices[a],l=Zn.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let m=this.outputLayersTensorIndices[a];s.push([i.name,p,m])}return e.outputLayers=s,e}static fromConfig(e,t,n={},o=!1){let s={},a={};function i(g,b){g.name in a?a[g.name].push(b):a[g.name]=[b]}function u(g,b){let T=[],x;for(let I of b){let k=I[0],w=I[1],_=I[2];if(x=I[3]==null?{}:I[3],!(k in s)){i(g,b);return}let M=s[k];if(M.inboundNodes.length<=w){i(g,b);return}let R=M.inboundNodes[w];T.push(R.outputTensors[_])}T.length>0&&g.apply(Pr(T),x)}function l(g){let b=g.name,T=kn(g,t.customObjects!=null?t.customObjects:{});T.setFastWeightInitDuringBuild(o),s[b]=T,g.inboundNodes.forEach(I=>{if(!(I instanceof Array))throw new B(`Corrupted configuration, expected array for nodeData: ${I}`);i(T,I)})}let p=t.name,m=t.layers;for(let g of m)l(g);for(;!qM(a);)for(let g of m){let b=s[g.name];if(b.name in a){let T=a[b.name];delete a[b.name];for(let x of T)u(b,x)}}let c=[],d=[],f=t.inputLayers;for(let g of f){let b=g[0],T=g[1],x=g[2];hs(b in s);let k=s[b].inboundNodes[T].outputTensors;c.push(k[x])}let h=t.outputLayers;for(let g of h){let b=g[0],T=g[1],x=g[2];hs(b in s);let k=s[b].inboundNodes[T].outputTensors;d.push(k[x])}return new e({inputs:c,outputs:d,name:p})}get stateful(){if(this._stateful)throw new B("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){z(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function T9(r,e,t){let n=e.length;if(r==null||Array.isArray(r)&&r.length===0)return e.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&e[0]in r?[r[e[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${t} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return e.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${t} must be either an array with ${n} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(r)}`)}function dT(r,e){return T9(r,e,"classWeight")}async function fT(r,e,t,n){if(e!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){let o=z(()=>{if(r.shape.length===1)return gn(r);if(r.shape.length===2){if(r.shape[1]>1)return pl(r,1);if(r.shape[1]===1)return F(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());_e(o);let a=[];return s.forEach(i=>{if(t[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(t[i])}),Jt(a,"float32")}else return null}function wE(r,e){return P(r,e)}var x9=32;function _E(r,e){let t,n,o=e;t=o.xs,n=o.ys,y.assert(t!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);let s=NE("input",r.inputNames,t),a=NE("output",r.outputNames,n),i=s[0].shape[0];y.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),y.assert(a.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)y.assert(s[u].shape[0]===i,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);for(let u=0;u<a.length;u++)y.assert(a[u].shape[0]===i,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${a[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);return{xs:s,ys:a}}function NE(r,e,t){if(t instanceof We)return[t];if(Array.isArray(t))return y.assert(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${r} keys ${e}.`),t;{let n=[];for(let o of e){if(t[o]==null)throw new B(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(t[o])}return n}}function I9(r){if(r.length===3)throw new Ne("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function ME(r,e,t){let n=t.batchesPerEpoch!=null;if(y.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),y.assert(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),y.assert(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),y.assert(!n||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),y.assert(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=t.validationData!=null,s,a;if(o)if(DE(t.validationData))y.assert(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{let g=I9(t.validationData);s=g.xs,a=g.ys}let i=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let p=sT(t.callbacks,t.yieldEvery),m=t.verbose==null?1:t.verbose,{callbackList:c,history:d}=aT(p,m,t.epochs,null,null,C9(e,t),null,o,l);c.setModel(r),r.history=d,await c.onTrainBegin(),r.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,h=await e.iterator();for(;f<t.epochs;){let g={};await c.onEpochBegin(f);let b=0,T=0;for(n||(h=await e.iterator());!n||b<t.batchesPerEpoch;){let x=await h.next();if(n&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:I,ys:k}=_E(r,x.value),w={};w.batch=T,w.size=I[0].shape[0],await c.onBatchBegin(T,w);let _=[];if(t.classWeight!=null){let E=dT(t.classWeight,r.outputNames);for(let O=0;O<E.length;++O)_.push(await fT(k[O],null,E[O]))}let M=I.concat(k).concat(_),R=i(M);_e(M);for(let E=0;E<u.length;++E){let O=u[E],G=R[E];w[O]=G,Et(G)}await c.onBatchEnd(T,w),tT(w),T++,b++}if(n?b>=t.batchesPerEpoch:x.done){if(o){let I;DE(t.validationData)?I=At(await r.evaluateDataset(t.validationData,{batches:t.validationBatches})):I=At(r.evaluate(s,a,{batchSize:t.validationBatchSize==null?x9:t.validationBatchSize,verbose:0}));for(let k=0;k<r.metricsNames.length;++k)g[`val_${r.metricsNames[k]}`]=I[k]}break}if(r.stopTraining_)break}if(await c.onEpochEnd(f,g),f++,r.stopTraining_)break}return await c.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function C9(r,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(r.size)&&(t=r.size),t}function DE(r){return typeof r.iterator=="function"}function k9(r){return typeof r.next=="function"}async function RE(r,e,t){t=t||{};let n=t.batches!=null,o=r.testFunction,s=[];if(t.verbose>0)throw new Ne("Verbose mode is not implemented yet.");y.assert(!n||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);let a=k9(e)?e:await e.iterator(),i=0,u=0;for(;!n||u<t.batches;){let l=await a.next();if(s=z(()=>{if(l.value){let{xs:p,ys:m}=_E(r,l.value),c=p.concat(m),d=z(()=>o(c));if(_e(c),u===0)for(let h=0;h<d.length;++h)s.push(ge(0));let f=c[0].shape[0];for(let h=0;h<d.length;++h){let g=d[h],b=s[h];s[h]=z(()=>Z(s[h],P(f,g))),u>0&&_e(b)}_e(d),i+=f,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let p=s[l];s[l]=fe(s[l],i),_e(p)}return Pr(s)}function hT(r){y.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function Hc(r,e,t){return r==null?[null]:Array.isArray(r)?r.map(n=>hu(n,e,t-e)):hu(r,e,t-e)}function gT(r,e){return z(()=>r==null?null:Array.isArray(r)?r.map(t=>gT(t,e)):qy(r,e.dtype==="int32"?e:re(e,"int32")))}function bT(r,e){let t=[],n=0,o=null;for(;n<r;)o=n+e,o>=r&&(o=r),t.push([n,o]),n=o;return t}function VA(r){let e=[];r instanceof We&&(r=[r]);for(let t=0;t<r.length;++t){let n=r[t];if(n.rank===1)e.push(gu(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(n)}}return e}function ra(r,e){if(r==null)return;let t=[];if(e instanceof We)t.push(e.id);else if(Array.isArray(e))e.forEach(o=>t.push(o.id));else if(e!=null)for(let o in e){let s=e[o];t.push(s.id)}let n=[];if(r instanceof We)t.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{t.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];t.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function S9(r){return r instanceof We}function HA(r){return Array.isArray(r)}function PE(r){return!S9(r)&&!HA(r)}function EE(r,e,t,n=!0,o=""){if(e==null||e.length===0){if(r!=null){let a=!1;if(HA(r)&&r.length>0)a=!0;else if(PE(r)){for(let i in r)if(r.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new B(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return e.map(a=>null);let s;if(PE(r)){r=r,s=[];for(let a of e){if(r[a]==null)throw new B(`No data provided for "${a}". Need data for each key in: ${e}`);s.push(r[a])}}else if(HA(r)){if(r=r,r.length!==e.length)throw new B(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,e.length>1)throw new B(`The model ${o} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=VA(s),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new B(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<t[a].length;++u){if(u===0&&!n)continue;let l=i.shape[u],p=t[a][u];if(p!=null&&p>=0&&l!==p)throw new B(`${o} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${o} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function v9(r,e,t){let n=Qs(r.map(s=>s.shape[0]));n.sort();let o=Qs(e.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new B(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new B(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!y.arraysEqual(n,o))throw new B(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function A9(r,e,t){let n=[zi,Vc,Ap];for(let o=0;o<r.length;++o){let s=r[o],a=e[o],i=t[o];if(a!=null){if(a===Ap&&s.shape[s.shape.length-1]===1)throw new B(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(a)!==-1){let u=s.shape.slice(1),l=i.slice(1);for(let p=0;p<u.length;++p){let m=u[p],c=l[p];if(c!=null&&m!==c)throw new B(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function FE(r,e,t,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==e.length)throw new B(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(e.length>1)throw new B(`The model expects ${e.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new B(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<t[a].length;++u){if(u===0&&!n)continue;let l=i.shape[u],p=t[a][u];if(p!=null&&p!==l)throw new B(`Error when checking ${o}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function w9(r,e){if(r==null||Array.isArray(r)&&r.length===0)return e.map(n=>[]);let t;if(typeof r=="string"||typeof r=="function")t=[r];else if(Array.isArray(r)||typeof r=="object")t=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(t))return e.map(n=>t);{let n=[];for(let o of e){let s=t.hasOwnProperty(o)?t[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var N9="layers-model",Qn=class extends Zn{optimizer_;isOptimizerOwned;loss;lossFunctions;feedOutputShapes;feedLossFns;collectedTrainableWeights;testFunction;history;stopTraining_;isTraining;metrics;metricsNames;metricsTensors;userDefinedMetadata;constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new B("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");vE(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=SE(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Yr))throw new B("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new B(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(iT(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new B(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>iT(i))}else{let a=iT(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],oi("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let o=w9(e.metrics,this.outputNames),s=(a,i,u)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([u,a])};oi("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=o[a];(l=>{let p="",m,c,d;for(let f of l){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){let g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===Vc?["accuracy","acc"].indexOf(f)!==-1?c=Uh:["crossentropy","ce"].indexOf(f)!==-1&&(c=lT):this.lossFunctions[a]===Kc?["accuracy","acc"].indexOf(f)!==-1?c=pT:["crossentropy","ce"].indexOf(f)!==-1&&(c=WA):["accuracy","acc"].indexOf(f)!==-1?c=Kh:["crossentropy","ce"].indexOf(f)!==-1&&(c=Vh);let b;["accuracy","acc"].indexOf(f)!==-1?b="acc":["crossentropy","ce"].indexOf(f)!==-1&&(b="ce"),d=c,m=p+b}else d=CE(f),m=p+Hh(f);let h;oi(m,()=>{h=d}),s(a,m,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let o=n.batchSize==null?32:n.batchSize;hT(o);let s=!0,a=this.standardizeUserDataXY(e,t,s,o);try{let i=a[0].concat(a[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,i,o,n.verbose,n.steps);return Pr(l)}finally{ra(a[0],e),ra(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),RE(this,e,t)}checkNumSamples(e,t,n,o="steps"){let s;if(n!=null){if(s=null,t!=null)throw new B(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new B(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new B("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),o=n?t:[t],s=this.retrieveSymbolicTensors(o),a=new ta;if(e instanceof We&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new B(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(let u of this.inputs){let l=e[u.name];if(l==null)throw new B(`No value is provided for the model's input ${u.name}`);a.add(u,l)}let i=Sp(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Ys(null,e.length),n=e.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let u=a.indexOf(e[i]);if(u!==-1&&(t[i]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw t.forEach((s,a)=>{s==null&&o.push(e[a])}),new B(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return t}predictLoop(e,t=32,n=!1){return z(()=>{let o=this.checkNumSamples(e);if(n)throw new Ne("Verbose predictLoop() is not implemented yet.");let s=bT(o,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)z(()=>{let l=s[i][0],p=s[i][1],m=Hc(e,l,p),c=[];if(Array.isArray(m))for(let f=0;f<m.length;++f)c.push({key:this.inputs[f],value:m[f]});else c.push({key:this.inputs[0],value:m});let d=new ta(c);return Sp(this.outputs,d)}).forEach((l,p)=>a[p].push(l));return Pr(a.map(i=>ct(i,0)))})}predict(e,t={}){let n=VA(e);FE(n,this.inputNames,this.feedInputShapes,!1);try{let o=t.batchSize==null?32:t.batchSize;return hT(o),this.predictLoop(n,o)}finally{ra(n,e)}}predictOnBatch(e){FE(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,o){if(this.optimizer_==null)throw new Zr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===Kc?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=EE(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=EE(t,this.feedOutputNames,s,!1,"target"),v9(e,t,null),A9(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&e[0].shape[0]%o!==0)throw new B(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,o,s=!0,a){let[i,u]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let p=dT(o,this.outputNames);l=[];for(let m=0;m<p.length;++m)l.push(await fT(u[m],null,p[m]))}return[i,u,l]}testLoop(e,t,n,o=0,s){return z(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(o>0)throw new Ne("Verbose mode is not implemented yet.");if(s!=null)throw new Ne("steps mode in testLoop() is not implemented yet");{let u=bT(a,n),l=Jt(Tn(0,a));for(let p=0;p<u.length;++p){let m=u[p][0],c=u[p][1],d=hu(l,m,c-m),f=gT(t,d),h=e(f);if(p===0)for(let g=0;g<h.length;++g)i.push(ge(0));for(let g=0;g<h.length;++g){let b=h[g];i[g]=Z(i[g],P(c-m,b))}}for(let p=0;p<i.length;++p)i[p]=fe(i[p],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let o=e[n],s=o;NA(e,o)>1&&(s+=`_${NA(e.slice(0,n),o)}`),t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let m=[];for(let h=0;h<this.inputs.length;++h)m.push({key:this.inputs[h],value:n[h]});let c=new ta(m),d=Sp(this.outputs,c,{training:!0}),f;for(let h=0;h<this.lossFunctions.length;++h){let g=this.lossFunctions[h],b=g(o[h],d[h]);s[h]!=null&&(b=wE(b,s[h]));let T=Lt(b);t.push(T),h===0?f=b:f=Z(f,b)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=t[h];else{let b=this.metricsTensors[h][0],T=this.metricsTensors[h][1];g=Lt(b(o[T],d[T]))}Et(g),a.push(g)}return f=Lt(f),this.calculateLosses().forEach(h=>{f=Z(f,h)}),f},u=this.collectedTrainableWeights.map(m=>m.read()),l=!0;return[this.optimizer_.minimize(i,l,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>z(()=>{let t=[],n,o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:o[l]});let i=new ta(a),u=Sp(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let p=this.lossFunctions[l],m=Lt(p(s[l],u[l]));l===0?n=m:n=Z(n,m),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let p=this.metricsTensors[l][0],m=this.metricsTensors[l][1],c=Lt(p(s[m],u[m]));t.push(c)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let o,s,a,i,u,l,p,m,c;try{let d=n.batchSize==null?32:n.batchSize;hT(d);let f=!1,h=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,f,d);o=h[0],s=h[1],c=h[2];let g=!1,b;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)u=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Ne("validationData including sample weights is not supported yet."):new B(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let R=!0,E=await this.standardizeUserData(u,l,null,null,R,d);p=E[0],m=E[1],b=p.concat(m)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let R=Math.floor(o[0].shape[0]*(1-n.validationSplit)),E=o[0].shape[0];p=Hc(o,R,E),a=o,o=Hc(o,0,R),m=Hc(s,R,E),i=s,s=Hc(s,0,R),b=p.concat(m)}else n.validationSteps!=null&&(g=!0);let T=o.concat(s).concat(c);this.checkTrainableWeightsConsistency();let x=this.makeTrainFunction(),I=this.getDedupedMetricsNames(),k,w;g?(this.makeTestFunction(),k=this.testFunction,w=I.slice().concat(I.map(R=>"val_"+R))):(k=null,b=[],w=I.slice());let _=sT(n.callbacks,n.yieldEvery);return await this.fitLoop(x,T,I,d,n.epochs,n.verbose,_,k,b,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,ra(o,e),ra(s,t),ra(a,e),ra(i,t),ra(p,u),ra(m,l),c!=null&&_e(c)}}async fitLoop(e,t,n,o,s,a,i,u,l,p,m,c,d,f){o==null&&(o=32),s==null&&(s=1),p==null&&(p=!0),c==null&&(c=0);let h=!1;if(u!=null&&l!=null&&(h=!0),f!=null&&(h=!0,d==null))throw new B("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(t,o,d,"steps_per_epoch"),b;g!=null&&(b=Tn(0,g)),a==null&&(a=1);let{callbackList:T,history:x}=aT(i,a,s,c,g,d,o,h,m);T.setModel(this),this.history=x,await T.onTrainBegin(),this.stopTraining_=!1;for(let I=c;I<s;++I){await T.onEpochBegin(I);let k={};if(d!=null)throw new Ne("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new Ne("batch shuffling is not implemneted yet");p&&y.shuffle(b);let w=Jt(b),_=bT(g,o);for(let M=0;M<_.length;++M){let R={};if(await T.onBatchBegin(M,R),z(()=>{let E=_[M][0],O=_[M][1],G=hu(w,E,O-E);R.batch=M,R.size=O-E;let W=gT(t,G),H=e(W);for(let U=0;U<n.length;++U){let V=n[U],Y=H[U];R[V]=Y,Et(Y)}if(M===_.length-1&&h){let U=this.testLoop(u,l,o);for(let V=0;V<n.length;++V){let Y=n[V],j=U[V];Et(j),k["val_"+Y]=j}}}),await T.onBatchEnd(M,R),tT(R),this.stopTraining_)break}w.dispose()}if(await T.onEpochEnd(I,k),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return ME(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),o=n[0],s=n[1],i=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of i){let p=await l.data();u.push(p[0])}return _e(i),ra(n[0],e),ra(n[1],t),Pr(u)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<o.length;++a)n&&!o[a].trainable||t.push({name:o[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Ih().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Ih().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Zs(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Zs(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let o of t)if(typeof n[o]=="string")e[o]=Zs(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Zs(Hh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Zs(Hh(e)));{let e={};for(let t in this.metrics)e[t]=Zs(Hh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=wp(e.optimizer_config),n=kn(t),o;if(typeof e.loss=="string")o=fu(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>fu(a));else if(e.loss!=null){o={};for(let a in e.loss)o[a]=fu(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>fu(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=fu(e.metrics[a])}this.compile({loss:o,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let l=Br.getSaveHandlers(e);if(l.length===0)throw new B(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new B(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new B("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Br.encodeWeights(this.getNamedWeights(t)),o=!1,s=null,i={modelTopology:this.toJSON(s,o),format:N9,generatedBy:`TensorFlow.js tfjs-layers v${qh}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:p,specs:m}=await Br.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...m),n.data=Br.concatenateArrayBuffers([n.data,p])}return this.userDefinedMetadata!=null&&(KA(this.userDefinedMetadata,this.name,!0),i.userDefinedMetadata=this.userDefinedMetadata),i.weightData=n.data,i.weightSpecs=n.specs,e.save(i)}setUserDefinedMetadata(e){KA(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};K(Qn,"className","Model");Q.registerClass(Qn);var yT=class extends Qn{};K(yT,"className","Functional");Q.registerClass(yT);async function LE(r,e){"modelTopology"in r||(r={modelTopology:r}),r=r;let t=r.modelTopology;t.model_config!=null&&(t=t.model_config);let n=wp(t),o=kn(n,e);if(r.weightsManifest!=null){let s=await Br.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(i=>i.originalName)),a={};for(let i of o.weights)a[i.originalName]=s[i.originalName];o.loadWeights(a),_e(s)}return o}async function $E(r,e){if(e==null&&(e={}),typeof r=="string"){let t=Br.getLoadHandlers(r,e);if(t.length===0)t.push(Br.browserHTTPRequest(r,e));else if(t.length>1)throw new B(`Found more than one (${t.length}) load handlers for URL '${r}'`);r=t[0]}return D9(r,void 0,e)}async function D9(r,e,t){if(t==null&&(t={}),r.load==null)throw new B("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=t.strict==null?!0:t.strict,a=n.weightData!=null&&n.weightSpecs!=null&&s,i=kn(wp(o),e,a),u=n.trainingConfig;if(u!=null&&i.loadTrainingConfig(u),n.userDefinedMetadata!=null&&i.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new B("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:p}=_9(n.weightData,n.weightSpecs);i.loadWeights(l,s),i.optimizer!=null&&p.length>0&&await i.optimizer.setWeights(p),_e(l),_e(p.map(m=>m.tensor))}return i}function _9(r,e){let t=Br.decodeWeights(r,e),n={},o=[];return e.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:t[s.name]}):n[s.name]=t[s.name]}),{modelWeights:n,optimizerWeights:o}}var TT=class extends Qn{model;constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Al("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new B(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof TT||e instanceof Qn,n;if(t){if(n=e,n.outputs.length!==1)throw new B("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new B("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new B("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=Yy({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new B(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new B("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=EA(this.outputs[0])}this.inboundNodes=[],new bu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ys(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Ke(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Qn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},o=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new B("Legacy serialization format not supported yet.");s=t}else y.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;let i=new e(a);if(!(i instanceof TT))throw new Ne(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let u of s){let p=kn(u,void 0,o);o&&p.setFastWeightInitDuringBuild(!0),i.add(p)}return i}set stopTraining(e){if(this.model==null)throw new B("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new B("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}},Np=TT;K(Np,"className","Sequential");Q.registerClass(Np);function M9(r){return new Qn(r)}function R9(r){return new Np(r)}function qA(r){return Yy(r)}function P9(r,e){Wc.registerCallbackConstructor(r,e)}var pn=class extends Q.Serializable{getConfig(){return{}}},xT=class extends pn{apply(e,t=1){return uR(e,t)}};K(xT,"className","elu");Q.registerClass(xT);var IT=class extends pn{apply(e){return Iy(e)}};K(IT,"className","selu");Q.registerClass(IT);var CT=class extends pn{apply(e){return an(e)}};K(CT,"className","relu");Q.registerClass(CT);var kT=class extends pn{apply(e){return z(()=>yl(6,an(e)))}};K(kT,"className","relu6");Q.registerClass(kT);var ST=class extends pn{apply(e){return e}};K(ST,"className","linear");Q.registerClass(ST);var vT=class extends pn{apply(e){return Pn(e)}};K(vT,"className","sigmoid");Q.registerClass(vT);var AT=class extends pn{apply(e){return pR(e)}};K(AT,"className","hardSigmoid");Q.registerClass(AT);var wT=class extends pn{apply(e){return cu(e)}};K(wT,"className","softplus");Q.registerClass(wT);var NT=class extends pn{apply(e){return lR(e)}};K(NT,"className","softsign");Q.registerClass(NT);var DT=class extends pn{apply(e){return ml(e)}};K(DT,"className","tanh");Q.registerClass(DT);var qc=class extends pn{apply(e,t=-1){return yc(e,t)}};K(qc,"className","softmax");Q.registerClass(qc);var _T=class extends pn{apply(e,t=-1){return ly(e,t)}};K(_T,"className","logSoftmax");Q.registerClass(_T);var MT=class extends pn{apply(e,t=1){return z(()=>P(Pn(P(e,t)),e))}};K(MT,"className","swish");Q.registerClass(MT);var RT=class extends pn{apply(e){return z(()=>P(e,ml(cu(e))))}};K(RT,"className","mish");Q.registerClass(RT);function ui(r){return r.getClassName()}function jA(r,e={}){return $i(r,Q.SerializationMap.getMap().classNameMap,e,"activation")}function li(r){if(r==null){let e={};return e.className="linear",e.config={},jA(e)}if(typeof r=="string"){let e={};return e.className=r,e.config={},jA(e)}else return r instanceof pn?r:jA(r)}function XA(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var PT=class extends Q.Serializable{},_l=class extends PT{l1;l2;hasL1;hasL2;constructor(e){super(),XA(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return z(()=>{let t=Ct([1]);return this.hasL1&&(t=Z(t,be(P(this.l1,Ot(e))))),this.hasL2&&(t=Z(t,be(P(this.l2,bp(e))))),F(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};K(_l,"className","L1L2");Q.registerClass(_l);function zE(r){return XA(r),new _l({l1:r!=null?r.l1:null,l2:0})}function GE(r){return XA(r),new _l({l2:r!=null?r.l2:null,l1:0})}var BE={l1l2:"L1L2"};function yt(r){return Sc(r)}function OE(r,e={}){return $i(r,Q.SerializationMap.getMap().classNameMap,e,"regularizer")}function Nt(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in BE?BE[r]:r,config:{}};return OE(t)}else return r instanceof PT?r:OE(r)}var jc=class extends Re{maxValue;constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=De(e);let n=an(e);return this.maxValue!=null&&(n=Hr(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};K(jc,"className","ReLU");Q.registerClass(jc);var Xc=class extends Re{alpha;DEFAULT_ALPHA=.3;constructor(e){super(e??{}),e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=De(e);return pc(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};K(Xc,"className","LeakyReLU");Q.registerClass(Xc);var Yc=class extends Re{alphaInitializer;alphaRegularizer;alphaConstraint;sharedAxes;alpha;DEFAULT_ALPHA_INITIALIZER="zeros";constructor(e){if(super(e??{}),e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=kt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Nt(e.alphaRegularizer),this.alphaConstraint=Ht(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new B(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Ke(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)t[o-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<e.length;++o)n[o]=e[o];this.inputSpec=[new wt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=De(e),hc(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Mt(this.alphaInitializer),alphaRegularizer:yt(this.alphaRegularizer),alphaConstraint:Vt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};K(Yc,"className","PReLU");Q.registerClass(Yc);var Zc=class extends Re{alpha;DEFAULT_ALPHA=1;constructor(e){if(super(e??{}),e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ne(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=De(e);return hl(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};K(Zc,"className","ELU");Q.registerClass(Zc);var Qc=class extends Re{theta;DEFAULT_THETA=1;constructor(e){super(e??{}),e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=De(e);return P(n,re(Qt(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};K(Qc,"className","ThresholdedReLU");Q.registerClass(Qc);var Jc=class extends Re{axis;softmax;DEFAULT_AXIS=1;constructor(e){super(e??{}),e==null&&(e={}),this.softmax=new qc().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=De(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};K(Jc,"className","Softmax");Q.registerClass(Jc);function Ml(r,e,t){if(typeof r=="number")return Ys(r,e);if(r.length!==e)throw new B(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${r.length} elements.`);for(let n=0;n<e;++n){let o=r[n];if(!oR(o))throw new B(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function Fn(r,e,t,n,o=1){if(r==null)return r;let s=e+(e-1)*(o-1),a;return t==="same"?a=r:a=r-s+1,Math.floor((a+n-1)/n)}function pi(r,e,t,n){if(r==null)return null;if(n==="valid")r=r*e+si([t-e,0]);else if(n==="same")r=r*e;else throw new B(`Unsupport padding mode: ${n}.`);return r}function jh(r,e){return z(()=>(Gt(e),e==="channelsFirst"?Ge(r,[0,2,3,1]):r))}function YA(r,e){return z(()=>(Gt(e),e==="channelsFirst"?Ge(r,[0,2,3,4,1]):r))}function F9(r,e,t,n=1,o="valid",s,a=1){return z(()=>{if(s==null&&(s=xn()),Gt(s),r.shape.length!==3)throw new B(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(e.shape.length!==3)throw new B(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new B(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(r=Ge(r,[0,2,1])),o==="causal")throw new Ne("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=Jb(r,e,n,o==="same"?"same":"valid","NWC",a);return t!=null&&(i=In(i,t)),i})}function WE(r,e,t,n=[1,1],o="valid",s,a,i=null){return z(()=>{if(s==null&&(s=xn()),Gt(s),r.rank!==3&&r.rank!==4)throw new B(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(e.rank!==3&&e.rank!==4)throw new B(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=jh(r,s);if(o==="causal")throw new Ne("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Tl.conv2d({x:u,filter:e,strides:n,pad:o==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:i}),s==="channelsFirst"&&(u=Ge(u,[0,3,1,2])),u})}function L9(r,e,t,n=[1,1,1],o="valid",s,a){return z(()=>{if(s==null&&(s=xn()),Gt(s),r.rank!==4&&r.rank!==5)throw new B(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(e.rank!==4&&e.rank!==5)throw new B(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let i=YA(r,s);if(o==="causal")throw new Ne("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=ty(i,e,n,o==="same"?"same":"valid","NDHWC",a),t!=null&&(i=In(i,t)),s==="channelsFirst"&&(i=Ge(i,[0,4,1,2,3])),i})}var Mp=class extends Re{rank;kernelSize;strides;padding;dataFormat;activation;useBias;dilationRate;biasInitializer;biasConstraint;biasRegularizer;bias=null;DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_BIAS_INITIALIZER="zeros";constructor(e,t){if(super(t),Mp.verifyArgs(t),this.rank=e,sr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ne(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ml(t.kernelSize,e,"kernelSize"),this.strides=Ml(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,yn(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Gt(this.dataFormat),this.activation=li(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=kt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ht(t.biasConstraint),this.biasRegularizer=Nt(t.biasRegularizer),this.activityRegularizer=Nt(t.activityRegularizer),this.dilationRate=Ml(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new B(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new B(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new B(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(hs("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Oy(e.kernelSize,"number",1,3))throw new B(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:ui(this.activation),useBias:this.useBias,biasInitializer:Mt(this.biasInitializer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),biasConstraint:Vt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Rl=class extends Mp{filters;kernel=null;kernelInitializer;kernelConstraint;kernelRegularizer;constructor(e,t){super(e,t),Rl.verifyArgs(t),this.filters=t.filters,sr(this.filters,"filters"),this.kernelInitializer=kt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ht(t.kernelConstraint),this.kernelRegularizer=Nt(t.kernelRegularizer)}build(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return z(()=>{e=De(e);let n,o=this.bias==null?null:this.bias.read(),s=zy(this.activation.getClassName());if(s!=null&&this.rank===2)n=WE(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=F9(e,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=WE(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=L9(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ne("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=Ke(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let a=Fn(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let o=[e[0]];return this.dataFormat==="channelsLast"?(o=o.concat(t),o.push(this.filters)):(o.push(this.filters),o=o.concat(t)),o}getConfig(){let e={filters:this.filters,kernelInitializer:Mt(this.kernelInitializer),kernelRegularizer:yt(this.kernelRegularizer),kernelConstraint:Vt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new B(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},ZA=class extends Rl{constructor(e){super(2,e),ZA.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Oy(e.kernelSize,"number",1,2))throw new B(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}},Dp=ZA;K(Dp,"className","Conv2D");Q.registerClass(Dp);var QA=class extends Rl{constructor(e){super(3,e),QA.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new B(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}},_p=QA;K(_p,"className","Conv3D");Q.registerClass(_p);var ed=class extends Dp{constructor(e){if(super(e),this.inputSpec=[new wt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new B(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ke(e),e.length!==4)throw new B("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return z(()=>{let n=De(e);if(n.shape.length!==4)throw new B(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let u=o[a],l=o[i],p=this.kernelSize[0],m=this.kernelSize[1],c=this.strides[0],d=this.strides[1],f=pi(u,c,p,this.padding),h=pi(l,d,m,this.padding),g=[s,f,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Ge(n,[0,2,3,1]));let b=ey(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=Ge(b,[0,3,1,2])),this.bias!=null&&(b=In(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=Ke(e);let t=e.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[o]=pi(t[o],u,a,this.padding),t[s]=pi(t[s],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};K(ed,"className","Conv2DTranspose");Q.registerClass(ed);var td=class extends _p{constructor(e){if(super(e),this.inputSpec=[new wt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new B(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ke(e),e.length!==5)throw new B("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return z(()=>{let n=De(e);if(n.shape.length!==5)throw new B(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i,u;this.dataFormat==="channelsFirst"?(u=2,a=3,i=4):(u=1,a=2,i=3);let l=o[u],p=o[a],m=o[i],c=this.kernelSize[0],d=this.kernelSize[1],f=this.kernelSize[2],h=this.strides[0],g=this.strides[1],b=this.strides[2],T=pi(l,h,c,this.padding),x=pi(p,g,d,this.padding),I=pi(m,b,f,this.padding),k=[s,T,x,I,this.filters];this.dataFormat!=="channelsLast"&&(n=Ge(n,[0,2,3,4,1]));let w=ny(n,this.kernel.read(),k,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Ge(w,[0,4,1,2,3])),this.bias!==null&&(w=In(w,this.bias.read(),this.dataFormat)),this.activation!==null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=Ke(e);let t=e.slice(),n,o,s,a;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,a=4):(n=4,o=1,s=2,a=3);let i=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],p=this.strides[0],m=this.strides[1],c=this.strides[2];return t[n]=this.filters,t[o]=pi(t[o],p,i,this.padding),t[s]=pi(t[s],m,u,this.padding),t[a]=pi(t[a],c,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};K(td,"className","Conv3DTranspose");Q.registerClass(td);var ET=class extends Rl{depthMultiplier;depthwiseInitializer;depthwiseRegularizer;depthwiseConstraint;pointwiseInitializer;pointwiseRegularizer;pointwiseConstraint;DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";DEFAULT_POINTWISE_INITIALIZER="glorotUniform";depthwiseKernel=null;pointwiseKernel=null;constructor(e,t){if(super(e,t),t.filters==null)throw new B("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new B("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new B(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=kt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Nt(t.depthwiseRegularizer),this.depthwiseConstraint=Ht(t.depthwiseConstraint),this.pointwiseInitializer=kt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Nt(t.pointwiseRegularizer),this.pointwiseConstraint=Ht(t.pointwiseConstraint)}build(e){if(e=Ke(e),e.length<this.rank+2)throw new B(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new B(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new wt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return z(()=>{e=De(e);let n;if(this.rank===1)throw new Ne("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ge(e,[0,2,3,1])),n=Cy(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=In(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Ge(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.pointwiseInitializer=Mt(this.pointwiseInitializer),e.depthwiseRegularizer=yt(this.depthwiseRegularizer),e.pointwiseRegularizer=yt(this.pointwiseRegularizer),e.depthwiseConstraint=Vt(this.depthwiseConstraint),e.pointwiseConstraint=Vt(this.pointwiseConstraint),e}};K(ET,"className","SeparableConv");var rd=class extends ET{constructor(e){super(2,e)}};K(rd,"className","SeparableConv2D");Q.registerClass(rd);var JA=class extends Rl{constructor(e){super(1,e),JA.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Oy(e.kernelSize,"number",1,1))throw new B(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}},nd=JA;K(nd,"className","Conv1D");Q.registerClass(nd);var od=class extends Re{cropping;dataFormat;constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return z(()=>{if(e=De(e),this.dataFormat==="channelsLast"){let n=$h(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return $h(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=$h(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return $h(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};K(od,"className","Cropping2D");Q.registerClass(od);var sd=class extends Re{DEFAULT_SIZE=[2,2];size;dataFormat;interpolation;constructor(e){super(e),this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,rR(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return z(()=>{let n=De(e),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Ge(n,[0,2,3,1]);let s=this.size[0]*o[2],a=this.size[1]*o[3],i=this.interpolation==="nearest"?fs.resizeNearestNeighbor(n,[s,a]):fs.resizeBilinear(n,[s,a]);return Ge(i,[0,3,1,2])}else{let s=this.size[0]*o[1],a=this.size[1]*o[2];return this.interpolation==="nearest"?fs.resizeNearestNeighbor(n,[s,a]):fs.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};K(sd,"className","UpSampling2D");Q.registerClass(sd);function $9(r,e,t=[1,1],n="valid",o,s){return z(()=>{o==null&&(o=xn()),Gt(o);let a=jh(r,o);if(r.rank!==4)throw new B(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(e.rank!==4)throw new B(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=fl(a,e,t,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(a=Ge(a,[0,3,1,2])),a})}var ad=class extends Mp{depthMultiplier;depthwiseInitializer;depthwiseConstraint;depthwiseRegularizer;depthwiseKernel=null;constructor(e){super(2,e),this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=kt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ht(e.depthwiseConstraint),this.depthwiseRegularizer=Nt(e.depthwiseRegularizer)}build(e){if(e=Ke(e),e.length<4)throw new B(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new B(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return z(()=>{e=De(e);let n=$9(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=In(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Fn(t,this.kernelSize[0],this.padding,this.strides[0]),a=Fn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],o,s,a]:[e[0],s,a,o]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.depthwiseRegularizer=yt(this.depthwiseRegularizer),e.depthwiseConstraint=Vt(this.depthwiseRegularizer),e}};K(ad,"className","DepthwiseConv2D");Q.registerClass(ad);function ew(r,e,t,n){if(Array.isArray(r)){if(e!=null||t!=null)throw new B("When inputs is an array, neither initialState or constants should be provided");n!=null&&(t=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(e=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return e=o(e),t=o(t),{inputs:r,initialState:e,constants:t}}function tw(r,e,t,n=!1,o,s,a=!1,i=!1){return z(()=>{let u=e.shape.length;if(u<3)throw new B(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(Tn(2,u));if(e=Ge(e,l),s!=null)throw new Ne("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=re(re(o,"bool"),"float32"),o.rank===u-1&&(o=yr(o,-1)),o=Ge(o,l)),n&&(e=_r(e,0),o!=null&&(o=_r(o,0)));let p=[],m,c=t,d=e.shape[0],f=Rr(e),h;o!=null&&(h=Rr(o));for(let b=0;b<d;++b){let T=f[b],x=z(()=>r(T,c));if(o==null)m=x[0],c=x[1];else{let I=z(()=>{let k=h[b],w=me(zr(k),k),_=Z(P(x[0],k),P(c[0],w)),M=c.map((R,E)=>Z(P(x[1][E],k),P(R,w)));return{output:_,newStates:M}});m=I.output,c=I.newStates}i&&p.push(m)}let g;return i&&(g=cr(p,1)),[m,g,c]})}var rw=class extends Re{cell;returnSequences;returnState;goBackwards;unroll;stateSpec;states_;keptStates;numConstants;constructor(e){super(e);let t;if(e.cell==null)throw new B("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Ep({cells:e.cell}):t=e.cell,t.stateSize==null)throw new B("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new wt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Tn(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Xy(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],o;if(this.returnSequences?o=[e[0],e[1],n]:o=[e[0],n],this.returnState){let s=[];for(let a of t)s.push([e[0],a]);return[o].concat(s)}else return o}computeMask(e,t){return z(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ne("Constants support is not implemented in RNN yet.");Xy(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new wt({shape:[n,null,...o]});let s=[e[0]].concat(e.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!y.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new B(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new wt({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){z(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new B("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Ct([n,o])):this.states_=[Ct([n,this.cell.stateSize])];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Ct([n,o])):this.states_[0]=Ct([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new B(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let o=0;o<this.states_.length;++o){let s=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,i=[n,a];if(!y.arraysEqual(s.shape,i))throw new B(`State ${o} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Et(o.clone()))})}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=ew(e,n,o,this.numConstants);e=s.inputs,n=s.initialState,o=s.constants;let a=[],i=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new wt({shape:l.shape}));i=i.concat(this.stateSpec)}if(o!=null&&(t.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof ln){let l=[e].concat(a),p=this.inputSpec.concat(i),m=this.inputSpec;this.inputSpec=p;let c=super.apply(l,t);return this.inputSpec=m,c}else return super.apply(e,t)}call(e,t){return z(()=>{let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;e=De(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new B(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:o},l=tw((f,h)=>{let g=this.cell.call([f].concat(h),i);return[g[0],g.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),p=l[0],m=l[1],c=l[2];this.stateful&&this.resetStates(c,o);let d=this.returnSequences?m:p;return this.returnState?[d].concat(c):d})}getInitialState(e){return z(()=>{let t=Ct(e.shape);return t=be(t,[1,2]),t=gu(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?Hy(t,[1,n]):t):this.cell.stateSize>1?[Hy(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===rw.className&&(t.cell={className:this.cell.getClassName(),config:n}),{...n,...e,...t}}static fromConfig(e,t,n={}){let o=t.cell,s=kn(o,n);return new e(Object.assign(t,{cell:s}))}},gs=rw;K(gs,"className","RNN");Q.registerClass(gs);var xu=class extends Re{dropoutMask;recurrentDropoutMask},Rp=class extends xu{units;activation;useBias;kernelInitializer;recurrentInitializer;biasInitializer;kernelConstraint;recurrentConstraint;biasConstraint;kernelRegularizer;recurrentRegularizer;biasRegularizer;dropout;recurrentDropout;dropoutFunc;stateSize;kernel;recurrentKernel;bias;DEFAULT_ACTIVATION="tanh";DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_RECURRENT_INITIALIZER="orthogonal";DEFAULT_BIAS_INITIALIZER="zeros";constructor(e){super(e),this.units=e.units,sr(this.units,"units"),this.activation=li(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Ht(e.kernelConstraint),this.recurrentConstraint=Ht(e.recurrentConstraint),this.biasConstraint=Ht(e.biasConstraint),this.dropout=gp([1,si([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gp([1,si([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return z(()=>{if(e=e,e.length!==2)throw new B(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let o=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=ea(P(e,a),this.kernel.read()):s=ea(e,this.kernel.read()),this.bias!=null&&(s=In(s,this.bias.read())),i!=null&&(n=P(n,i));let u=Z(s,ea(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ui(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),recurrentConstraint:Vt(this.recurrentConstraint),biasConstraint:Vt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return{...e,...t}}};K(Rp,"className","SimpleRNNCell");Q.registerClass(Rp);var id=class extends gs{constructor(e){e.cell=new Rp(e),super(e)}call(e,t){return z(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return new e(t)}};K(id,"className","SimpleRNN");Q.registerClass(id);var Pp=class extends xu{units;activation;recurrentActivation;useBias;kernelInitializer;recurrentInitializer;biasInitializer;kernelRegularizer;recurrentRegularizer;biasRegularizer;kernelConstraint;recurrentConstraint;biasConstraint;dropout;recurrentDropout;dropoutFunc;stateSize;implementation;DEFAULT_ACTIVATION="tanh";DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_RECURRENT_INITIALIZER="orthogonal";DEFAULT_BIAS_INITIALIZER="zeros";kernel;recurrentKernel;bias;constructor(e){if(super(e),e.resetAfter)throw new B("GRUCell does not support reset_after parameter set to true.");this.units=e.units,sr(this.units,"units"),this.activation=li(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=li(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Ht(e.kernelConstraint),this.recurrentConstraint=Ht(e.recurrentConstraint),this.biasConstraint=Ht(e.biasConstraint),this.dropout=gp([1,si([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gp([1,si([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return z(()=>{if(e=e,e.length!==2)throw new B(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,u,l;0<this.dropout&&this.dropout<1&&(e=P(e,s[0]));let p=ea(e,this.kernel.read());this.useBias&&(p=In(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,a[0]));let m=this.recurrentKernel.read(),[c,d]=Mr(m,[2*this.units,this.units],m.rank-1),f=ea(o,c),[h,g,b]=Mr(p,3,p.rank-1),[T,x]=Mr(f,2,f.rank-1);i=this.recurrentActivation.apply(Z(h,T)),u=this.recurrentActivation.apply(Z(g,x));let I=ea(P(u,o),d);l=this.activation.apply(Z(b,I));let k=Z(P(i,o),P(Z(1,tt(i)),l));return[k,k]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ui(this.activation),recurrentActivation:ui(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),recurrentConstraint:Vt(this.recurrentConstraint),biasConstraint:Vt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return{...e,...t}}};K(Pp,"className","GRUCell");Q.registerClass(Pp);var ud=class extends gs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Pp(e),super(e)}call(e,t){return z(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};K(ud,"className","GRU");Q.registerClass(ud);var Tu=class extends xu{units;activation;recurrentActivation;useBias;kernelInitializer;recurrentInitializer;biasInitializer;unitForgetBias;kernelConstraint;recurrentConstraint;biasConstraint;kernelRegularizer;recurrentRegularizer;biasRegularizer;dropout;recurrentDropout;dropoutFunc;stateSize;implementation;DEFAULT_ACTIVATION="tanh";DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_RECURRENT_INITIALIZER="orthogonal";DEFAULT_BIAS_INITIALIZER="zeros";kernel;recurrentKernel;bias;constructor(e){super(e),this.units=e.units,sr(this.units,"units"),this.activation=li(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=li(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Ht(e.kernelConstraint),this.recurrentConstraint=Ht(e.recurrentConstraint),this.biasConstraint=Ht(e.biasConstraint),this.dropout=gp([1,si([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gp([1,si([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let n;if(this.useBias){if(this.unitForgetBias){let o=this.biasInitializer,s=this.units;n=new class extends Cn{static className="CustomInit";apply(i,u){let l=o.apply([s]),p=new Nl().apply([s]),m=o.apply([s*2]);return PA(PA(l,p),m)}}}else n=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return z(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new B(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,u,l,p,m;0<this.dropout&&this.dropout<1&&(e=P(e,a[0]));let c=ea(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,i[0])),c=Z(c,ea(o,this.recurrentKernel.read())),this.useBias&&(c=In(c,this.bias.read()));let[d,f,h,g]=Mr(c,4,c.rank-1);u=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(f),p=Z(P(l,s),P(u,this.activation.apply(h))),m=this.recurrentActivation.apply(g);let b=P(m,this.activation.apply(p));return[b,b,p]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:ui(this.activation),recurrentActivation:ui(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),recurrentConstraint:Vt(this.recurrentConstraint),biasConstraint:Vt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return{...e,...t}}};K(Tu,"className","LSTMCell");Q.registerClass(Tu);var ld=class extends gs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Tu(e),super(e)}call(e,t){return z(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};K(ld,"className","LSTM");Q.registerClass(ld);var Ep=class extends xu{cells;constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return z(()=>{e=e;let n=e.slice(1),o=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?o.push(n.splice(0,i.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let u=this.cells[i];n=o[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=u.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){Xy(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,o)=>{oi(`RNNCell_${o}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(t)};return{...e,...o}}static fromConfig(e,t,n={}){let o=[];for(let s of t.cells)o.push(kn(s,n));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Oh(e)}setWeights(e){let t=[];for(let n of this.cells){let o=n.weights.length,s=e.splice(o);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}$c(t)}};K(Ep,"className","StackedRNNCells");Q.registerClass(Ep);function Iu(r){let{ones:e,rate:t,training:n=!1,count:o=1,dropoutFunc:s}=r,a=()=>s!=null?s(e(),t):jy(e(),t),i=()=>wl(a,e,n);return!o||o<=1?Et(i().clone()):Array(o).fill(void 0).map(i).map(l=>Et(l.clone()))}var FT=class extends gs{constructor(e){if(e.unroll)throw new Ne("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ne("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new wt({ndim:5})]}call(e,t){return z(()=>{if(this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new B("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return z(()=>{let{stateSize:t}=this.cell,n=e.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],a=Ct(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){z(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new B("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(s)):this.states_=[Ct(s)];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(s)):this.states_[0]=Ct(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new B(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let i=0;i<this.states_.length;++i){let u=e[i],l=s;if(!y.arraysEqual(u.shape,l))throw new B(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[i]=u}}this.states_=this.states_.map(i=>Et(i.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:o,padding:s,strides:a,dilationRate:i}=this.cell,u=t==="channelsFirst",l=e[u?3:2],p=e[u?4:3],m=Fn(l,o[0],s,a[0],i[0]),c=Fn(p,o[1],s,a[1],i[1]);return[...e.slice(0,2),...u?[n,m,c]:[m,c,n]]}};K(FT,"className","ConvRNN2D");var Fp=class extends Tu{filters;kernelSize;strides;padding;dataFormat;dilationRate;constructor(e){let{filters:t,kernelSize:n,strides:o,padding:s,dataFormat:a,dilationRate:i}=e;super({...e,units:t}),this.filters=t,sr(this.filters,"filters"),this.kernelSize=Ml(n,2,"kernelSize"),this.kernelSize.forEach(u=>sr(u,"kernelSize")),this.strides=Ml(o||1,2,"strides"),this.strides.forEach(u=>sr(u,"strides")),this.padding=s||"valid",yn(this.padding),this.dataFormat=a||"channelsLast",Gt(this.dataFormat),this.dilationRate=Ml(i||1,2,"dilationRate"),this.dilationRate.forEach(u=>sr(u,"dilationRate"))}build(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=4,s=this.kernelSize.concat([n,this.filters*o]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let i;if(this.unitForgetBias){let u=this.biasInitializer,l=this.filters;i=new class extends Cn{static className="CustomInit";apply(m,c){let d=u.apply([l]),f=Tr([l]),h=u.apply([l*2]);return Ac([d,f,h])}}}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,i,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return z(()=>{if(e.length!==3)throw new B(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,o=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(o),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(ne,oe,ae)=>!oe||!oe[ae]?ne:P(oe[ae],ne),p=l(o,u,0),m=l(o,u,1),c=l(o,u,2),d=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let f=this.recurrentDropoutMask,h=l(s,f,0),g=l(s,f,1),b=l(s,f,2),T=l(s,f,3),x=3,[I,k,w,_]=Mr(this.kernel.read(),i,x),[M,R,E,O]=this.useBias?Mr(this.bias.read(),i):[null,null,null,null];p=this.inputConv(p,I,M,this.padding),m=this.inputConv(m,k,R,this.padding),c=this.inputConv(c,w,E,this.padding),d=this.inputConv(d,_,O,this.padding);let[G,W,H,U]=Mr(this.recurrentKernel.read(),i,x);h=this.recurrentConv(h,G),g=this.recurrentConv(g,W),b=this.recurrentConv(b,H),T=this.recurrentConv(T,U);let V=this.recurrentActivation.apply(Z(p,h)),Y=this.recurrentActivation.apply(Z(m,g)),j=Z(P(Y,a),P(V,this.activation.apply(Z(c,b)))),te=P(this.recurrentActivation.apply(Z(d,T)),this.activation.apply(j));return[te,te,j]})}getConfig(){let{units:e,...t}=super.getConfig(),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return{...t,...n}}inputConv(e,t,n,o){let s=cs(e,t,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?In(s,n,this.dataFormat):s}recurrentConv(e,t){return cs(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};K(Fp,"className","ConvLSTM2DCell");Q.registerClass(Fp);var pd=class extends FT{constructor(e){let t=new Fp(e);super({...e,cell:t})}static fromConfig(e,t){return new e(t)}};K(pd,"className","ConvLSTM2D");Q.registerClass(pd);var Lp=class extends Re{rate;noiseShape;seed;constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?t[o]:this.noiseShape[o]);return n}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);if(0<this.rate&&this.rate<1){let o=t.training==null?!1:t.training,s=this.getNoiseShape(n);return wl(()=>jy(n,this.rate,s,this.seed),()=>n,o)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};K(Lp,"className","Dropout");Q.registerClass(Lp);var md=class extends Lp{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};K(md,"className","SpatialDropout1D");Q.registerClass(md);var cd=class extends Re{units;activation=null;useBias=!0;kernelInitializer;biasInitializer;kernel=null;bias=null;DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_BIAS_INITIALIZER="zeros";kernelConstraint;biasConstraint;kernelRegularizer;biasRegularizer;constructor(e){if(super(e),e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,sr(this.units,"units"),this.activation=li(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ht(e.kernelConstraint),this.biasConstraint=Ht(e.biasConstraint),this.kernelRegularizer=Nt(e.kernelRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Ke(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Ke(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e),o=zy(this.activation.getClassName()),s;return o!=null?s=ea(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=ea(n,this.kernel.read()),this.bias!=null&&(s=In(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:ui(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),biasConstraint:Vt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};K(cd,"className","Dense");Q.registerClass(cd);var dd=class extends Re{dataFormat;constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ke(e);for(let t of e.slice(1))if(t==null)throw new B(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Js(e,1)]}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=Ge(n,o)}return iR(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};K(dd,"className","Flatten");Q.registerClass(dd);var fd=class extends Re{activation;constructor(e){super(e),this.supportsMasking=!0,this.activation=li(e.activation)}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);return this.activation.apply(n)})}getConfig(){let e={activation:ui(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};K(fd,"className","Activation");Q.registerClass(fd);var hd=class extends Re{n;constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return z(()=>(e=De(e),sR(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};K(hd,"className","RepeatVector");Q.registerClass(hd);var gd=class extends Re{targetShape;constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",o=t.slice(),s=1,a=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(a===null)a=u;else throw new B("Can only specifiy one unknown dimension.");else s*=l}let i=Js(e);if(a!==null){if(s===0||i%s!==0)throw new B(n);o[a]=i/s}else if(i!==s)throw new B(n);return o}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return F(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};K(gd,"className","Reshape");Q.registerClass(gd);var bd=class extends Re{dims;dimsIncludingBatch;constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Tn(1,e.dims.length+1);if(!y.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new wt({ndim:this.dims.length+1})]}computeOutputShape(e){e=Ke(e);let t=e.slice();return this.dims.forEach((n,o)=>{t[o+1]=e[n]}),t}call(e,t){return Ge(De(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};K(bd,"className","Permute");Q.registerClass(bd);var yd=class extends Re{maskValue;constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=De(e),o=-1;return vh(du(n,this.maskValue),o)}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e),o=-1,s=!0,a=vh(du(n,this.maskValue),o,s);return P(n,re(a,n.dtype))})}};K(yd,"className","Masking");Q.registerClass(yd);var Td=class extends Re{inputDim;outputDim;embeddingsInitializer;maskZero;inputLength;embeddings=null;DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform";embeddingsRegularizer;embeddingsConstraint;constructor(e){if(super(e),e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(At(e.inputLength))}this.inputDim=e.inputDim,sr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,sr(this.outputDim,"outputDim"),this.embeddingsInitializer=kt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Nt(e.embeddingsRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.embeddingsConstraint=Ht(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return z(()=>this.maskZero?(e=De(e),du(e,we(e))):null)}computeOutputShape(e){if(e=Ke(e),this.inputLength==null)return[...e,this.outputDim];let t=At(this.inputLength);if(t.length!==e.length-1)throw new B(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let o=0;o<t.length;++o){let s=t[o],a=e[o+1];if(s!=null&&a!=null&&s!==a)throw new B(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);n.dtype!=="int32"&&(n=un(n,"int32"));let o=qy(this.embeddings.read(),F(n,[n.size]));return F(o,Ke(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Mt(this.embeddingsInitializer),embeddingsRegularizer:yt(this.embeddingsRegularizer),activityRegularizer:yt(this.activityRegularizer),embeddingsConstraint:Vt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};K(Td,"className","Embedding");Q.registerClass(Td);var Cu=class extends Re{reshapeRequired;constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ne}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let o=0;o<t.length;++o){let s=e[e.length-t.length+o],a=t[o];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new B("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ke(e)]),e=e,e.length<2)throw new B(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Qs(t),t.length>1)throw new B(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let o=e.map(s=>s.length);e.indexOf(null)===-1&&Qs(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return z(()=>{if(e=e,this.reshapeRequired){let n=[],o=e.map(s=>s.rank);if(o.indexOf(null)===-1){let s=si(o);for(let a of e){let i=a.rank;for(let u=0;u<s-i;++u)a=gu(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let u of e){let l=u.rank;if(l==null){let p=u.shape,m=p[0],c=p.slice(1).concat([m]),d=F(u,[m].concat(Js(p.slice(1))));d=Ge(d,[1,0]),d=F(d,c),n.push(d),s=!0}else if(l>1){let p=Tn(1,l).concat([0]);n.push(Ge(u,p)),s=!0}else n.push(u)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let u=a.shape,l=u.length,p=u[l-1],m=[p].concat(u.slice(0,u.length-1));a=F(Ge(F(a,[-1,p]),[1,0]),m)}else if(i>1){let u=[i-1].concat(Tn(0,i-1));a=Ge(a,u)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let o=1;o<e.length;++o){let s=e[o]==null?null:e[o].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let o of e)o!=null&&o[0]!==null&&n.push(o[0]);return n=Qs(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return z(()=>{if(t==null)return null;if(!Array.isArray(t))throw new B("`mask` should be an Array");if(!Array.isArray(e))throw new B("`inputs` should be an Array");if(t.length!==e.length)throw new B(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(o=>o==null))return null;t=t.map(o=>o==null?o:yr(o,0));let n=t[0];for(let o=1;o<t.length-1;++o)n=sn(n,t[o]);return n})}},xd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return t})}};K(xd,"className","Add");Q.registerClass(xd);var Id=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=P(t,e[n]);return t})}};K(Id,"className","Multiply");Q.registerClass(Id);var Cd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return P(1/e.length,t)})}};K(Cd,"className","Average");Q.registerClass(Cd);var kd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ds(t,e[n]);return t})}};K(kd,"className","Maximum");Q.registerClass(kd);var Sd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=yl(t,e[n]);return t})}};K(Sd,"className","Minimum");Q.registerClass(Sd);var vd=class extends Cu{DEFAULT_AXIS=-1;axis;constructor(e){super(e),e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new B("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let o of e)if(o!=null){t=!1;break}if(t)return;let n=[];for(let o=0;o<e.length;++o){let s=e[o].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if(y.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new B("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return z(()=>Ac(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new B("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new B("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new B("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new B(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return z(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let o=[];for(let a=0;a<e.length;++a)t[a]==null?o.push(re(zr(e[a]),"bool")):t[a].rank<e[a].rank?o.push(yr(t[a],-1)):o.push(t[a]);let s=ct(o,this.axis);return Wb(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};K(vd,"className","Concatenate");Q.registerClass(vd);function Xh(r,e){for(;r<0;)r+=e;return r}function B9(r,e,t){if(r.shape.length>3||e.shape.length>3)throw new Ne("batchDot is not implemented for tensors of 4D or higher rank yet");if(y.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),y.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),r.dtype==="complex64"||e.dtype==="complex64")throw new Ne("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=e.shape.length;t==null&&(t=[n-1,o-2]);let s=t;return z(()=>{let a;if(n>o){a=n-o;let u=[];for(let l=0;l<a;++l)u.push(1);e=F(e,e.shape.concat(u))}else if(o>n){a=o-n;let u=[];for(let l=0;l<a;++l)u.push(1);r=F(r,r.shape.concat(u))}else a=0;let i;if(r.shape.length===2&&e.shape.length===2)s[0]===s[1]?i=be(P(r,e),s[0]):i=be(P(Ge(r,[1,0]),e),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===e.shape.length-1;i=Ue(r,e,u,l)}if(a>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let p=u;p<u+a;++p)l.push(p);i=qs(i,l)}return i.shape.length===1&&(i=yr(i,1)),i})}var Ad=class extends Cu{axes;normalize;constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Ne("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);if(t[o[0]]!==n[o[1]])throw new B(`Dimension incompatibility: ${t[o[0]]} !== ${n[o[1]]}`)}mergeFunction(e){if(e.length!==2)throw new B(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,a)=>Xh(s,e[a].shape.length)):o=[Xh(this.axes,t.shape.length),Xh(this.axes,n.shape.length)],this.normalize&&(t=zh(t,o[0]),n=zh(n,o[1])),B9(t,n,o)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Xh(this.axes,e.length),Xh(this.axes,t.length)],n}computeOutputShape(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Ne("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);t.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};K(Ad,"className","Dot");Q.registerClass(Ad);var wd=class extends Re{stddev;constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);return wl(()=>Z(wc(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};K(wd,"className","GaussianNoise");Q.registerClass(wd);var Nd=class extends Re{rate;constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);return this.rate>0&&this.rate<1?wl(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return P(n,wc(n.shape,1,s))},()=>n,t.training||!1):n})}};K(Nd,"className","GaussianDropout");Q.registerClass(Nd);var Dd=class extends Re{rate;noiseShape;constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||De(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return z(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return wl(()=>{let s=De(e),a=1.6732632423543772,i=1.0507009873554805,u=-a*i,l=Xn(Pi(n),this.rate);l=un(l,"float32");let p=((1-this.rate)*(1+this.rate*u**2))**-.5,m=-p*u*this.rate,c=Z(P(s,l),P(Z(l,-1),u));return Z(P(c,p),m)},()=>De(e),t.training||!1)}return e})}};K(Dd,"className","AlphaDropout");Q.registerClass(Dd);function Yh(r,e,t,n,o,s=.001){let a;if(r.rank===2)a=Vb(r,e,t,n,o,s);else if(r.rank===3)a=Hb(r,e,t,n,o,s);else if(r.rank===4)a=qb(r,e,t,n,o,s);else throw new Ne(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return a}function O9(r,e,t,n,o=.001){return z(()=>{let s=sp(r,n),a=s.mean,i=s.variance;return[Yh(r,a,i,t,e,o),a,i]})}function z9(r,e,t,n,o=.001){return z(()=>{let s=sp(r,n),a=s.mean,i=s.variance,u=[];for(let f of Tn(0,r.rank))n.indexOf(f)!==-1?u.push(1):u.push(r.shape[f]);let l=F(a,u),p=F(i,u),m=e==null?null:F(e,u),c=t==null?null:F(t,u);return[Yh(r,l,p,c,m,o),a,i]})}function G9(r,e,t,n,o=.001){return y.arraysEqual(n.slice().sort(),Tn(0,r.rank-1))?O9(r,e,t,n,o):z9(r,e,t,n,o)}var _d=class extends Re{axis;momentum;epsilon;center;scale;betaInitializer;gammaInitializer;movingMeanInitializer;movingVarianceInitializer;betaConstraint;gammaConstraint;betaRegularizer;gammaRegularizer;gamma;beta;movingMean;movingVariance;constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.movingMeanInitializer=kt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=kt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ht(e.betaConstraint),this.gammaConstraint=Ht(e.gammaConstraint),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer)}build(e){e=Ke(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new B(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new wt({ndim:e.length,axes:{[t]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return z(()=>{let n=t.training==null?!1:t.training,o=De(e),s=o.shape,a=s.length,i=Tn(0,a),u=this.axis>=0?this.axis:this.axis+a;i.splice(u,1);let l=Ys(1,a);l[u]=s[u];let p=i.slice();p.sort();let m=!y.arraysEqual(p,Tn(0,a).slice(0,a-1)),c=()=>{if(m){let T=F(this.movingMean.read(),l),x=F(this.movingVariance.read(),l),I=this.center?F(this.beta.read(),l):null,k=this.scale?F(this.gamma.read(),l):null;return Yh(o,T,x,I,k,this.epsilon)}else return Yh(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return c();let[d,f,h]=G9(o,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(T,x,I)=>{z(()=>{let k=1-I,w=T.read(),_=P(me(w,x),k);T.write(me(w,_))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,h,this.momentum)})(),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),movingMeanInitializer:Mt(this.movingMeanInitializer),movingVarianceInitializer:Mt(this.movingVarianceInitializer),betaRegularizer:yt(this.betaRegularizer),gammaRegularizer:yt(this.gammaRegularizer),betaConstraint:Vt(this.betaConstraint),gammaConstraint:Vt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};K(_d,"className","BatchNormalization");Q.registerClass(_d);var Md=class extends Re{axis;epsilon;center;scale;betaInitializer;gammaInitializer;betaRegularizer;gammaRegularizer;gamma;beta;constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Ke(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Qs(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(e,t){let n=De(e),o=n.shape,s=o.length;return z(()=>{let{mean:i,variance:u}=sp(n,this.axis,!0),l=Ys(1,s);for(let h of this.axis)l[h]=o[h];let p=h=>h!=null&&h.shape.length!==s?F(h,l):h,m=this.scale?p(this.gamma.read()):null,c=this.center?p(this.beta.read()):null,d=[],f=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(d.push(o[h]),f.push(1)):(d.push(1),f.push(o[h]));return i=on(i,d),u=on(u,d),m!=null&&(m=on(m,f)),c!=null&&(c=on(c,f)),Yh(n,i,u,c,m,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),betaRegularizer:yt(this.betaRegularizer),gammaRegularizer:yt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};K(Md,"className","LayerNormalization");Q.registerClass(Md);function W9(r,e,t){return z(()=>{if(r.rank!==4)throw new B(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new B("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=xn()),t!=="channelsLast"&&t!=="channelsFirst")throw new B(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return t==="channelsFirst"?n=[[0,0],[0,0],e[0],e[1]]:n=[[0,0],e[0],e[1],[0,0]],Yn(r,n)})}var Rd=class extends Re{dataFormat;padding;constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?xn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new B(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new B(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new B(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new wt({ndim:4})]}computeOutputShape(e){e=Ke(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return z(()=>W9(De(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};K(Rd,"className","ZeroPadding2D");Q.registerClass(Rd);function GT(r,e,t,n,o,s){return z(()=>{Gt(o),DA(s),yn(n),t==null&&(t=[1,1]),n==null&&(n="valid"),o==null&&(o=xn()),s==null&&(s="max"),r=jh(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=dc(r,e,t,i):a=ac(r,e,t,i),o==="channelsFirst"&&(a=Ge(a,[0,3,1,2])),a})}function UE(r,e,t,n,o,s){return z(()=>{Gt(o),DA(s),yn(n),t==null&&(t=[1,1,1]),n==null&&(n="valid"),o==null&&(o=xn()),s==null&&(s="max"),r=YA(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=dy(r,e,t,i):a=Kb(r,e,t,i),o==="channelsFirst"&&(a=Ge(a,[0,4,1,2,3])),a})}var LT=class extends Re{poolSize;strides;padding;constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new B(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(sr(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new B(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,yn(this.padding),this.inputSpec=[new wt({ndim:3})]}computeOutputShape(e){e=Ke(e);let t=Fn(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return z(()=>{this.invokeCallHook(e,t),e=gu(De(e),2);let n=this.poolingFunction(De(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return qs(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},Pd=class extends LT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),GT(e,t,n,o,s,"max")}};K(Pd,"className","MaxPooling1D");Q.registerClass(Pd);var Ed=class extends LT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),GT(e,t,n,o,s,"avg")}};K(Ed,"className","AveragePooling1D");Q.registerClass(Ed);var $T=class extends Re{poolSize;strides;padding;dataFormat;constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new B(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];sr(this.poolSize,"poolSize"),sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),yn(this.padding),this.inputSpec=[new wt({ndim:4})]}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Fn(t,this.poolSize[0],this.padding,this.strides[0]),n=Fn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return z(()=>(this.invokeCallHook(e,t),this.poolingFunction(De(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Fd=class extends $T{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),GT(e,t,n,o,s,"max")}};K(Fd,"className","MaxPooling2D");Q.registerClass(Fd);var Ld=class extends $T{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),GT(e,t,n,o,s,"avg")}};K(Ld,"className","AveragePooling2D");Q.registerClass(Ld);var BT=class extends Re{poolSize;strides;padding;dataFormat;constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new B(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];sr(this.poolSize,"poolSize"),sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),yn(this.padding),this.inputSpec=[new wt({ndim:5})]}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Fn(t,this.poolSize[0],this.padding,this.strides[0]),n=Fn(n,this.poolSize[1],this.padding,this.strides[1]),o=Fn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,o]:[e[0],t,n,o,e[4]]}call(e,t){return z(()=>(this.invokeCallHook(e,t),this.poolingFunction(De(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},$d=class extends BT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),UE(e,t,n,o,s,"max")}};K($d,"className","MaxPooling3D");Q.registerClass($d);var Bd=class extends BT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),UE(e,t,n,o,s,"avg")}};K(Bd,"className","AveragePooling3D");Q.registerClass(Bd);var OT=class extends Re{constructor(e){super(e),this.inputSpec=[new wt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ne}},Od=class extends OT{constructor(e){super(e||{})}call(e,t){return z(()=>{let n=De(e);return Lt(n,1)})}};K(Od,"className","GlobalAveragePooling1D");Q.registerClass(Od);var zd=class extends OT{constructor(e){super(e||{})}call(e,t){return z(()=>{let n=De(e);return qr(n,1)})}};K(zd,"className","GlobalMaxPooling1D");Q.registerClass(zd);var zT=class extends Re{dataFormat;constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),this.inputSpec=[new wt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ne}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Gd=class extends zT{call(e,t){return z(()=>{let n=De(e);return this.dataFormat==="channelsLast"?Lt(n,[1,2]):Lt(n,[2,3])})}};K(Gd,"className","GlobalAveragePooling2D");Q.registerClass(Gd);var Wd=class extends zT{call(e,t){return z(()=>{let n=De(e);return this.dataFormat==="channelsLast"?qr(n,[1,2]):qr(n,[2,3])})}};K(Wd,"className","GlobalMaxPooling2D");Q.registerClass(Wd);var WT=class extends Re{layer;constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let o=t.layer,s=kn(o,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},Ud=class extends WT{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Ke(e),e.length<3)throw new B(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Ke(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),o=e[1];return[n[0],o].concat(n.slice(1))}call(e,t){return z(()=>(e=De(e),tw((a,i)=>[De(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};K(Ud,"className","TimeDistributed");Q.registerClass(Ud);function U9(r){Bi(eR,"BidirectionalMergeMode",r)}var K9="concat",Kd=class extends WT{mergeMode;forwardLayer;backwardLayer;returnSequences;returnState;numConstants;_trainable;constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=kn(n),t.goBackwards=t.goBackwards!==!0;let o={};if(o.className=e.layer.getClassName(),o.config=t,this.backwardLayer=kn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?K9:e.mergeMode,U9(this.mergeMode),e.weights)throw new Ne("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,o,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Pr(o)}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=ew(e,n,o,this.numConstants);if(e=s.inputs,n=s.initialState,o=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&o==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new B("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let p=n.map(m=>new wt({shape:m.shape}));this.forwardLayer.stateSpec=p.slice(0,l/2),this.backwardLayer.stateSpec=p.slice(l/2),i.push(...p)}if(o!=null)throw new Ne("Support for constants in Bidirectional layers is not implemented yet.");let u=a[0]instanceof ln;for(let l of a)if(l instanceof ln!==u)throw new B("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[e].concat(a),p=this.inputSpec.concat(i),m=this.inputSpec;this.inputSpec=p;let c=super.apply(l,t);return this.inputSpec=m,c}else return super.apply(e,t)}call(e,t){return z(()=>{let n=t.initialState,o,s;if(n==null)o=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=_r(s,1));let i;return this.mergeMode==="concat"?i=Ac([o,s]):this.mergeMode==="sum"?i=Z(o,s):this.mergeMode==="ave"?i=P(.5,Z(o,s)):this.mergeMode==="mul"?i=P(o,s):this.mergeMode==null&&(i=[o,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){oi(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),oi(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=kn(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ne("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=t;return o.layer=n,new e(o)}};K(Kd,"className","Bidirectional");Q.registerClass(Kd);var Vd=class extends Re{scale;offset;constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return z(()=>(e=De(e),e.dtype!=="float32"&&(e=un(e,"float32")),Z(P(e,this.scale),this.offset)))}};K(Vd,"className","Rescaling");Q.registerClass(Vd);var{resizeBilinear:V9,cropAndResize:H9}=fs,Hd=class extends Re{height;width;constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,o,s,a,i,u){return z(()=>{let l,p=!1,m=t/a,c=n/i,d=(o+t)/a,f=(s+n)/i,h=[m,c,d,f],g=[];e.rank===3?(p=!0,l=cr([e])):l=e;for(let k=0;k<l.shape[0];k++)g.push(h);let b=mr(g,[g.length,4]),T=Ei(0,g.length,1,"int32"),I=H9(l,b,T,[o,s],"nearest");return p?un(De(Rr(I)),u):un(I,u)})}upsize(e,t,n,o){return z(()=>{let s=V9(e,[t,n]);return un(s,o)})}call(e,t){return z(()=>{let n=De(e),o=n.dtype,s=n.shape,a=s[s.length-3],i=s[s.length-2],u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(n,u,l,this.height,this.width,a,i,o):this.upsize(e,this.height,this.width,o)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ke(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};K(Hd,"className","CenterCrop");Q.registerClass(Hd);function KE(r,e,t,n){let o=De(r);if(o.dtype!=="int32"&&(o=un(o,"int32")),e==="int")return o;let s=o.shape;if(o.rank===0&&(o=yr(o,-1)),e==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=yr(o,-1)),o.rank>2)throw new B(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${s} which would result in output rank ${o.rank}.`);let a=["multiHot","oneHot"].includes(e),i=o,u;if(typeof n<"u"&&e==="count"?u=wh(i,n,t,a):u=wh(i,[],t,a),e!=="tfIdf")return u;if(n)return P(u,n);throw new B("When outputMode is 'tfIdf', weights must be provided.")}var qd=class extends Re{numTokens;outputMode;constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Ke(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return z(()=>{e=De(e),e.dtype!=="int32"&&(e=un(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new B(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=De(t.countWeights)}let o=qr(e),s=rp(e),a=Qt(this.numTokens,o).bufferSync().get(0),i=Xn(s,0).bufferSync().get(0);if(!(a&&i))throw new B(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return KE(e,this.outputMode,this.numTokens,n)})}};K(qd,"className","CategoryEncoding");Q.registerClass(qd);var j9=["bilinear","nearest"],VE=new Set(j9),jd=class extends Re{height;width;interpolation;cropToAspectRatio;constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(VE.has(e.interpolation))this.interpolation=e.interpolation;else throw new B(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){e=Ke(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return z(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return fs.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return fs.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...VE]} are supported`)})}};K(jd,"className","Resizing");Q.registerClass(jd);function X9(r){return new ai(r)}function Y9(r){return new Zc(r)}function Z9(r){return new jc(r)}function Q9(r){return new Xc(r)}function J9(r){return new Yc(r)}function eee(r){return new Jc(r)}function tee(r){return new Qc(r)}function ree(r){return new nd(r)}function nee(r){return new Dp(r)}function oee(r){return new ed(r)}function see(r){return new _p(r)}function aee(r){return new td(r)}function iee(r){return new rd(r)}function uee(r){return new od(r)}function lee(r){return new sd(r)}function pee(r){return new ad(r)}function mee(r){return new fd(r)}function cee(r){return new cd(r)}function dee(r){return new Lp(r)}function fee(r){return new md(r)}function hee(r){return new dd(r)}function gee(r){return new hd(r)}function bee(r){return new gd(r)}function yee(r){return new bd(r)}function Tee(r){return new Td(r)}function xee(r){return new xd(r)}function Iee(r){return new Cd(r)}function Cee(r){return new vd(r)}function kee(r){return new kd(r)}function See(r){return new Sd(r)}function vee(r){return new Id(r)}function Aee(r){return new Ad(r)}function wee(r){return new _d(r)}function Nee(r){return new Md(r)}function Dee(r){return new Rd(r)}function nw(r){return new Ed(r)}function _ee(r){return nw(r)}function Mee(r){return nw(r)}function ow(r){return new Ld(r)}function Ree(r){return ow(r)}function Pee(r){return ow(r)}function sw(r){return new Bd(r)}function Eee(r){return sw(r)}function Fee(r){return sw(r)}function Lee(r){return new Od(r)}function $ee(r){return new Gd(r)}function HE(r){return new zd(r)}function qE(r){return new Wd(r)}function jE(r){return new Pd(r)}function XE(r){return new Fd(r)}function Bee(r){return new $d(r)}function Oee(r){return new ud(r)}function zee(r){return new Pp(r)}function Gee(r){return new ld(r)}function Wee(r){return new Tu(r)}function Uee(r){return new id(r)}function Kee(r){return new Rp(r)}function Vee(r){return new pd(r)}function Hee(r){return new Fp(r)}function qee(r){return new gs(r)}function jee(r){return new Ep(r)}function Xee(r){return new Kd(r)}function Yee(r){return new Ud(r)}var Zee=HE,Qee=qE,Jee=jE,ete=XE;function tte(r){return new wd(r)}function rte(r){return new Nd(r)}function nte(r){return new Dd(r)}function ote(r){return new yd(r)}function ste(r){return new Vd(r)}function ate(r){return new Hd(r)}function ite(r){return new jd(r)}function ute(r){return new qd(r)}var ZE={};qe(ZE,{MAPE:()=>Tte,MSE:()=>Cte,binaryAccuracy:()=>lte,binaryCrossentropy:()=>pte,categoricalAccuracy:()=>cte,categoricalCrossentropy:()=>dte,cosineProximity:()=>gte,mape:()=>xte,meanAbsoluteError:()=>bte,meanAbsolutePercentageError:()=>yte,meanSquaredError:()=>Ite,mse:()=>kte,precision:()=>fte,recall:()=>hte,sparseCategoricalAccuracy:()=>mte});function lte(r,e){return Uh(r,e)}function pte(r,e){return lT(r,e)}function mte(r,e){return pT(r,e)}function cte(r,e){return Kh(r,e)}function dte(r,e){return Vh(r,e)}function fte(r,e){return GA(r,e)}function hte(r,e){return IE(r,e)}function gte(r,e){return Wh(r,e)}function bte(r,e){return Uc(r,e)}function yte(r,e){return Dl(r,e)}function Tte(r,e){return Dl(r,e)}function xte(r,e){return Dl(r,e)}function Ite(r,e){return zi(r,e)}function Cte(r,e){return zi(r,e)}function kte(r,e){return zi(r,e)}var QE={};qe(QE,{modelFromJSON:()=>LE});var JE={};qe(JE,{l1:()=>vte,l1l2:()=>Ste,l2:()=>Ate});function Ste(r){return new _l(r)}function vte(r){return zE(r)}function Ate(r){return GE(r)}var KT=class extends yu{model=null;setModel(e){if(!(e instanceof Qn))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function UT(r,e){return r<e}function eF(r,e){return r>e}var VT=class extends KT{monitor;minDelta;patience;baseline;verbose;mode;monitorFunc;wait;stoppedEpoch;best;constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Ne("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=UT:this.mode==="max"?this.monitorFunc=eF:this.monitor.indexOf("acc")!==-1?this.monitorFunc=eF:this.monitorFunc=UT,this.monitorFunc===UT&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===UT?1/0:-1/0}async onEpochEnd(e,t){await Oi(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function wte(r){return new VT(r)}var Nte={earlyStopping:wte};var Dte=$();Dte.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var aw=(J=>(J[J.DT_INVALID=0]="DT_INVALID",J[J.DT_FLOAT=1]="DT_FLOAT",J[J.DT_DOUBLE=2]="DT_DOUBLE",J[J.DT_INT32=3]="DT_INT32",J[J.DT_UINT8=4]="DT_UINT8",J[J.DT_INT16=5]="DT_INT16",J[J.DT_INT8=6]="DT_INT8",J[J.DT_STRING=7]="DT_STRING",J[J.DT_COMPLEX64=8]="DT_COMPLEX64",J[J.DT_INT64=9]="DT_INT64",J[J.DT_BOOL=10]="DT_BOOL",J[J.DT_QINT8=11]="DT_QINT8",J[J.DT_QUINT8=12]="DT_QUINT8",J[J.DT_QINT32=13]="DT_QINT32",J[J.DT_BFLOAT16=14]="DT_BFLOAT16",J[J.DT_QINT16=15]="DT_QINT16",J[J.DT_QUINT16=16]="DT_QUINT16",J[J.DT_UINT16=17]="DT_UINT16",J[J.DT_COMPLEX128=18]="DT_COMPLEX128",J[J.DT_HALF=19]="DT_HALF",J[J.DT_RESOURCE=20]="DT_RESOURCE",J[J.DT_VARIANT=21]="DT_VARIANT",J[J.DT_UINT32=22]="DT_UINT32",J[J.DT_UINT64=23]="DT_UINT64",J[J.DT_FLOAT_REF=101]="DT_FLOAT_REF",J[J.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",J[J.DT_INT32_REF=103]="DT_INT32_REF",J[J.DT_UINT8_REF=104]="DT_UINT8_REF",J[J.DT_INT16_REF=105]="DT_INT16_REF",J[J.DT_INT8_REF=106]="DT_INT8_REF",J[J.DT_STRING_REF=107]="DT_STRING_REF",J[J.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",J[J.DT_INT64_REF=109]="DT_INT64_REF",J[J.DT_BOOL_REF=110]="DT_BOOL_REF",J[J.DT_QINT8_REF=111]="DT_QINT8_REF",J[J.DT_QUINT8_REF=112]="DT_QUINT8_REF",J[J.DT_QINT32_REF=113]="DT_QINT32_REF",J[J.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",J[J.DT_QINT16_REF=115]="DT_QINT16_REF",J[J.DT_QUINT16_REF=116]="DT_QUINT16_REF",J[J.DT_UINT16_REF=117]="DT_UINT16_REF",J[J.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",J[J.DT_HALF_REF=119]="DT_HALF_REF",J[J.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",J[J.DT_VARIANT_REF=121]="DT_VARIANT_REF",J[J.DT_UINT32_REF=122]="DT_UINT32_REF",J[J.DT_UINT64_REF=123]="DT_UINT64_REF",J))(aw||{}),_te;(e=>{let r;(s=>(s[s.LEGACY=0]="LEGACY",s[s.V1=1]="V1",s[s.V2=2]="V2"))(r=e.CheckpointFormatVersion||={})})(_te||={});var iw={};function Rte(r,e){let t={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:e};iw[r]=t}function HT(r){return iw[r]}function Pte(r){delete iw[r]}function S(r,e,t,n,o){let s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){let i=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?i+1:s.inputIndexEnd;if(s.type==="tensor")return Ar(e.inputNames[s.inputIndexStart],t,n,o);if(s.type==="tensors")return e.inputNames.slice(i,u).map(c=>Ar(c,t,n,o));let l=Ar(e.inputNames.slice(i)[0],t,n,o),p=l.dataSync();return s.type==="number"?p[0]:y.toNestedArray(l.shape,p)}let a=e.attrParams[r];return a&&a.value}function Ar(r,e,t,n){let[o,s]=Sn(r);if(n!=null){let i=n.getHashTableHandleByName(o);if(i!=null)return i}let a=t.currentContextIds.find(i=>!!e[qT(o,i)]);return a!==void 0?e[qT(o,a)][s]:void 0}function tF(r,e,t){return e[qT(r,t.currentContextId)]}function mi(r,e){let[t,n,o]=Sn(r);return[qT(t,e&&e.currentContextId),n,o]}function qT(r,e){return e?`${r}-${e}`:r}function Sn(r){let e=r.split(":");if(e.length===1)return[r,0,void 0];let t=e[0],n=e.length===3?e[1]:void 0,o=Number(e[e.length-1]);return[t,o,n]}function Zh(r,e,t){let n=S("pad",r,e,t);if(n==="explicit"){n=S("explicitPaddings",r,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function ci(r){return r.kept?r:gn(r)}var uw={};qe(uw,{json:()=>Ete});var Ete=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var lw={};qe(lw,{json:()=>Fte});var Fte=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var pw={};qe(pw,{json:()=>Lte});var Lte=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var mw={};qe(mw,{json:()=>$te});var $te=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var cw={};qe(cw,{json:()=>Bte});var Bte=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var dw={};qe(dw,{json:()=>Ote});var Ote=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var fw={};qe(fw,{json:()=>zte});var zte=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var hw={};qe(hw,{json:()=>Gte});var Gte=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var gw={};qe(gw,{json:()=>Wte});var Wte=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var bw={};qe(bw,{json:()=>Ute});var Ute=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var yw={};qe(yw,{json:()=>Kte});var Kte=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Tw={};qe(Tw,{json:()=>Vte});var Vte=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var xw={};qe(xw,{json:()=>Hte});var Hte=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var Iw={};qe(Iw,{json:()=>qte});var qte=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var Cw={};qe(Cw,{json:()=>jte});var jte=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var kw={};qe(kw,{json:()=>Xte});var Xte=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var Sw={};qe(Sw,{json:()=>Yte});var Yte=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var vw={};qe(vw,{json:()=>Zte});var Zte=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var Aw={};qe(Aw,{json:()=>Qte});var Qte=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Xd=class{opMappers;static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[uw,lw,pw,mw,cw,dw,fw,hw,gw,bw,yw,Tw,xw,Iw,Cw,kw,Sw,vw,Aw],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(e,t={}){let n=e.node,o=[],s=[],a=[],i=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&a.push(h[g.name]),h),{}),u=[],l=[],p={},m={};t!=null&&(p=this.mapSignatureEntries(t.inputs),m=this.mapSignatureEntries(t.outputs));let c=Object.keys(i);c.forEach(h=>{let g=i[h];g.inputNames.forEach((b,T)=>{let[x,,I]=mi(b),k=i[x];if(k.outputs!=null){let w=k.outputs.indexOf(I);if(w!==-1){let _=`${x}:${w}`;g.inputNames[T]=_}}g.inputs.push(k),k.children.push(g)})}),Object.keys(m).length===0?c.forEach(h=>{let g=i[h];g.children.length===0&&l.push(g)}):Object.keys(m).forEach(h=>{let[g]=mi(h),b=i[g];b!=null&&(b.signatureKey=m[h],l.push(b))}),Object.keys(p).length>0?Object.keys(p).forEach(h=>{let[g]=mi(h),b=i[g];b&&(b.signatureKey=p[h],u.push(b))}):u=o;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let f={nodes:i,inputs:u,outputs:l,weights:s,placeholders:o,signature:t,functions:d};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=HT(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((o,s)=>{let a=s.type,i;switch(s.type){case"string":i=jT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=jT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=tx(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=tx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=YT(e.attr,s.tfName,s.defaultValue||0),i===void 0&&!!s.tfDeprecatedName&&(i=YT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=ex(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ex(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=XT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=XT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=nx(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=nx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=JT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=JT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=rx(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=rx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=ZT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ZT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=QT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=QT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=rF(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=rF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:i,type:a},o},{})),n}mapFunction(e){let t=e.nodeDef,n=[],o=[],s={};t!=null&&(s=t.reduce((m,c)=>(m[c.name]=this.mapNode(c),c.op==="Const"&&o.push(m[c.name]),m),{}));let a=[],i=[];e.signature.inputArg.forEach(m=>{let[c]=mi(m.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ww(m.type),type:"dtype"}},children:[]};d.signatureKey=m.name,a.push(d),s[c]=d}),Object.keys(s).forEach(m=>{let c=s[m];c.inputNames.forEach((d,f)=>{let[h,,g]=mi(d),b=s[h];if(b.outputs!=null){let T=b.outputs.indexOf(g);if(T!==-1){let x=`${h}:${T}`;c.inputNames[f]=x}}c.inputs.push(b),b.children.push(c)})});let l=e.ret;e.signature.outputArg.forEach(m=>{let[c,d]=mi(l[m.name]),f=s[c];f!=null&&(f.defaultOutput=d,i.push(f))});let p=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:o,placeholders:n,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};K(Xd,"_instance");function Jte(r){let e=$().global;if(typeof e.atob<"u")return e.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function nF(r,e){let t=Array.isArray(r)?String.fromCharCode.apply(null,r):Jte(r);return e?t:t.toLowerCase()}function jT(r,e,t,n=!1){let o=r[e];return o!=null?nF(o.s,n):t}function XT(r,e,t){let n=r[e];return n?n.b:t}function YT(r,e,t){let n=r[e]||{},o=n.i!=null?n.i:n.f!=null?n.f:t;return typeof o=="number"?o:parseInt(o,10)}function ww(r){switch(typeof r=="string"&&(r=aw[r]),r){case 1:case 19:return"float32";case 3:case 9:case 6:case 4:return"int32";case 10:return"bool";case 2:return"float32";case 7:return"string";default:return null}}function rF(r,e,t){let n=r[e];return n&&n.func?n.func.name:t}function ZT(r,e,t){let n=r[e];return n&&n.type?ww(n.type):t}function QT(r,e,t){let n=r[e];return n&&n.list&&n.list.type?n.list.type.map(o=>ww(o)):t}function oF(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function JT(r,e,t){let n=r[e];return n&&n.shape?oF(n.shape):t}function ex(r,e,t){let n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function tx(r,e,t,n=!1){let o=r[e];return o&&o.list&&o.list.s?o.list.s.map(s=>nF(s,n)):t}function rx(r,e,t){let n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(o=>oF(o)):t}function nx(r,e,t){let n=r[e];return n&&n.list&&n.list.b?n.list.b:t}var ox=class{constructor(e,t,n){this.node=e;this.tensorMap=t;this.context=n;this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}inputs=[];attrs={};getInput(e){return Ar(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return Ar(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return YT(this.node.rawAttrs,e,t);if(n.s!=null)return jT(this.node.rawAttrs,e,t);if(n.b!=null)return XT(this.node.rawAttrs,e,t);if(n.shape!=null)return JT(this.node.rawAttrs,e,t);if(n.type!=null)return ZT(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return ex(this.node.rawAttrs,e,t);if(n.list.s!=null)return tx(this.node.rawAttrs,e,t);if(n.list.shape!=null)return rx(this.node.rawAttrs,e,t);if(n.list.b!=null)return nx(this.node.rawAttrs,e,t);if(n.list.type!=null)return QT(this.node.rawAttrs,e,t)}return t}};var lt={};qe(lt,{OP_SCOPE_SUFFIX:()=>Bv,abs:()=>Ot,acos:()=>A1,acosh:()=>w1,add:()=>Z,addN:()=>N1,all:()=>Wb,any:()=>vh,argMax:()=>pl,argMin:()=>D1,asin:()=>_1,asinh:()=>M1,atan:()=>R1,atan2:()=>P1,atanh:()=>E1,avgPool:()=>ac,avgPool3d:()=>Kb,basicLSTMCell:()=>$1,batchNorm:()=>cl,batchNorm2d:()=>Vb,batchNorm3d:()=>Hb,batchNorm4d:()=>qb,batchToSpaceND:()=>ic,bincount:()=>jb,booleanMaskAsync:()=>UZ,broadcastArgs:()=>O1,broadcastTo:()=>dl,buffer:()=>Ie,cast:()=>re,ceil:()=>z1,clipByValue:()=>Hr,clone:()=>gn,complex:()=>Mn,concat:()=>ct,concat1d:()=>Xb,concat2d:()=>Yb,concat3d:()=>Zb,concat4d:()=>Qb,conv1d:()=>Jb,conv2d:()=>cs,conv2dTranspose:()=>ey,conv3d:()=>ty,conv3dTranspose:()=>ny,cos:()=>lc,cosh:()=>oy,cosineWindow:()=>Rh,cumprod:()=>Ah,cumsum:()=>sy,denseBincount:()=>wh,depthToSpace:()=>G1,depthwiseConv2d:()=>fl,diag:()=>W1,dilation2d:()=>U1,div:()=>fe,divNoNan:()=>K1,dot:()=>V1,dropout:()=>TA,einsum:()=>H1,elu:()=>hl,enclosingPowerOfTwo:()=>xA,equal:()=>nn,erf:()=>q1,euclideanNorm:()=>Y1,exp:()=>br,expandDims:()=>yr,expm1:()=>Z1,eye:()=>op,fft:()=>Tc,fill:()=>Ks,floor:()=>gl,floorDiv:()=>Gb,fused:()=>Tl,gather:()=>bl,gatherND:()=>QZ,greater:()=>Qt,greaterEqual:()=>Xn,ifft:()=>pp,imag:()=>ll,image:()=>fs,inTopKAsync:()=>tQ,irfft:()=>vy,isFinite:()=>Q1,isInf:()=>J1,isNaN:()=>e2,leakyRelu:()=>pc,less:()=>ay,lessEqual:()=>Hs,linalg:()=>CA,linspace:()=>t2,localResponseNormalization:()=>r2,log:()=>jr,log1p:()=>mc,logSigmoid:()=>n2,logSoftmax:()=>ly,logSumExp:()=>py,logicalAnd:()=>sn,logicalNot:()=>cc,logicalOr:()=>my,logicalXor:()=>o2,losses:()=>t7,lowerBound:()=>s2,matMul:()=>Ue,max:()=>qr,maxPool:()=>dc,maxPool3d:()=>dy,maxPoolWithArgmax:()=>a2,maximum:()=>ds,mean:()=>Lt,meshgrid:()=>i2,min:()=>rp,minimum:()=>yl,mirrorPad:()=>u2,mod:()=>l2,moments:()=>sp,movingAverage:()=>VZ,mul:()=>P,multiRNNCell:()=>p2,multinomial:()=>m2,neg:()=>tt,norm:()=>np,notEqual:()=>du,oneHot:()=>il,ones:()=>Tr,onesLike:()=>zr,op:()=>A,outerProduct:()=>c2,pad:()=>Yn,pad1d:()=>d2,pad2d:()=>f2,pad3d:()=>h2,pad4d:()=>g2,pool:()=>b2,pow:()=>jn,prelu:()=>hc,print:()=>Mb,prod:()=>y2,raggedGather:()=>T2,raggedRange:()=>x2,raggedTensorToTensor:()=>I2,rand:()=>C2,randomGamma:()=>O2,randomNormal:()=>up,randomStandardNormal:()=>z2,randomUniform:()=>Pi,range:()=>Ei,real:()=>mu,reciprocal:()=>G2,relu:()=>an,relu6:()=>yy,reshape:()=>F,reverse:()=>_r,reverse1d:()=>W2,reverse2d:()=>U2,reverse3d:()=>K2,reverse4d:()=>V2,rfft:()=>xc,round:()=>Ty,rsqrt:()=>xy,scalar:()=>ge,scatterND:()=>qZ,searchSorted:()=>Dh,selu:()=>Iy,separableConv2d:()=>Cy,setdiff1dAsync:()=>H2,sigmoid:()=>Pn,sign:()=>q2,signal:()=>e7,sin:()=>ky,sinh:()=>Sy,slice:()=>ze,slice1d:()=>gc,slice2d:()=>Mh,slice3d:()=>bc,slice4d:()=>lp,softmax:()=>yc,softplus:()=>cu,spaceToBatchND:()=>fc,sparse:()=>r7,sparseToDense:()=>YZ,spectral:()=>JQ,split:()=>Mr,sqrt:()=>Ft,square:()=>He,squaredDifference:()=>Ay,squeeze:()=>qs,stack:()=>cr,step:()=>Fi,stridedSlice:()=>j2,string:()=>n7,sub:()=>me,sum:()=>be,tan:()=>X2,tanh:()=>ml,tensor:()=>mr,tensor1d:()=>Jt,tensor2d:()=>ei,tensor3d:()=>Lb,tensor4d:()=>Y2,tensor5d:()=>Z2,tensor6d:()=>Q2,tile:()=>on,topk:()=>J2,transpose:()=>Ge,truncatedNormal:()=>Ic,unique:()=>eM,unsortedSegmentSum:()=>wy,unstack:()=>Rr,upperBound:()=>tM,variable:()=>Ny,where:()=>zt,whereAsync:()=>_y,zeros:()=>Ct,zerosLike:()=>we});var sF=(r,e,t,n=lt)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(S("a",r,e,t),S("b",r,e,t))];case"AddN":return[n.addN(S("tensors",r,e,t))];case"FloorMod":case"Mod":return[n.mod(S("a",r,e,t),S("b",r,e,t))];case"Mul":return[n.mul(S("a",r,e,t),S("b",r,e,t))];case"RealDiv":case"Div":return[n.div(S("a",r,e,t),S("b",r,e,t))];case"DivNoNan":return[n.divNoNan(S("a",r,e,t),S("b",r,e,t))];case"FloorDiv":return[n.floorDiv(S("a",r,e,t),S("b",r,e,t))];case"Sub":return[n.sub(S("a",r,e,t),S("b",r,e,t))];case"Minimum":return[n.minimum(S("a",r,e,t),S("b",r,e,t))];case"Maximum":return[n.maximum(S("a",r,e,t),S("b",r,e,t))];case"Pow":return[n.pow(S("a",r,e,t),S("b",r,e,t))];case"SquaredDifference":return[n.squaredDifference(S("a",r,e,t),S("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var aF=(r,e,t,n=lt)=>{switch(r.op){case"Abs":case"ComplexAbs":return[n.abs(S("x",r,e,t))];case"Acos":return[n.acos(S("x",r,e,t))];case"Acosh":return[n.acosh(S("x",r,e,t))];case"Asin":return[n.asin(S("x",r,e,t))];case"Asinh":return[n.asinh(S("x",r,e,t))];case"Atan":return[n.atan(S("x",r,e,t))];case"Atan2":return[n.atan2(S("x",r,e,t),S("y",r,e,t))];case"Atanh":return[n.atanh(S("x",r,e,t))];case"Ceil":return[n.ceil(S("x",r,e,t))];case"Complex":return[n.complex(S("real",r,e,t),S("imag",r,e,t))];case"Cos":return[n.cos(S("x",r,e,t))];case"Cosh":return[n.cosh(S("x",r,e,t))];case"Elu":return[n.elu(S("x",r,e,t))];case"Erf":return[n.erf(S("x",r,e,t))];case"Exp":return[n.exp(S("x",r,e,t))];case"Expm1":return[n.expm1(S("x",r,e,t))];case"Floor":return[n.floor(S("x",r,e,t))];case"Log":return[n.log(S("x",r,e,t))];case"Log1p":return[n.log1p(S("x",r,e,t))];case"Imag":return[n.imag(S("x",r,e,t))];case"Neg":return[n.neg(S("x",r,e,t))];case"Reciprocal":return[n.reciprocal(S("x",r,e,t))];case"Real":return[n.real(S("x",r,e,t))];case"Relu":return[n.relu(S("x",r,e,t))];case"Round":return[n.round(S("x",r,e,t))];case"Selu":return[n.selu(S("x",r,e,t))];case"Sigmoid":return[n.sigmoid(S("x",r,e,t))];case"Sin":return[n.sin(S("x",r,e,t))];case"Sign":return[n.sign(S("x",r,e,t))];case"Sinh":return[n.sinh(S("x",r,e,t))];case"Softplus":return[n.softplus(S("x",r,e,t))];case"Sqrt":return[n.sqrt(S("x",r,e,t))];case"Square":return[n.square(S("x",r,e,t))];case"Tanh":return[n.tanh(S("x",r,e,t))];case"Tan":return[n.tan(S("x",r,e,t))];case"ClipByValue":return[n.clipByValue(S("x",r,e,t),S("clipValueMin",r,e,t),S("clipValueMax",r,e,t))];case"Relu6":return[n.relu6(S("x",r,e,t))];case"Rsqrt":return[n.rsqrt(Ar(r.inputNames[0],e,t))];case"Prod":return[n.prod(S("x",r,e,t),S("axes",r,e,t))];case"LeakyRelu":return[n.leakyRelu(S("x",r,e,t),S("alpha",r,e,t))];case"Prelu":return[n.prelu(S("x",r,e,t),S("alpha",r,e,t))];case"IsNan":return[n.isNaN(Ar(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Jn(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){y.assert(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=e[n];y.assert(o<0||s<0||o===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function iF(r){return!(typeof r=="number"||r.some(e=>e<0))}function Yd(r,e,t){let n=sx(r,t),o=!iF(n);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&e.forEach(s=>{n=sx(s.shape,n)}),!iF(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function sx(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);let t=[];for(let n=0;n<r.length;++n){let o=r[n],s=e[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=o>=0?o:s}return t}var ax=class{constructor(e,t,n,o,s,a,i){this.name=e;this.dtype=t;this.maxSize=n;this.elementShape=o;this.identicalElementShapes=s;this.dynamicSize=a;this.clearAfterRead=i;this.idTensor=ge(0),Et(this.idTensor)}tensors=[];closed_=!1;idTensor;get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Jn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Et(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,o)=>this.write(n,t[o]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return mr([],[0].concat(this.elementShape));let n=this.readMany(e);return Jn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),cr(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return mr([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let n=this.readMany(t);return Jn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),ct(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Rr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,o=e.map(u=>(n+=u,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];z(()=>{t=F(t,[1,n,s]);for(let u=0;u<e.length;++u){let l=u===0?0:o[u-1],p=[0,l,0],m=[1,e[u],s];a[u]=F(ze(t,p,m),this.elementShape)}return a});let i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,a)}};var ku=class{constructor(e,t,n,o=-1){this.tensors=e;this.elementShape=t;this.elementDtype=n;e?.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Jn(t,s.shape,"TensorList shape mismatch: "),Et(s)}),this.idTensor=ge(0),this.maxNumElements=o,Et(this.idTensor)}idTensor;maxNumElements;get id(){return this.idTensor.id}copy(){return new ku([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Jn(e,this.elementShape,"TensorList shape mismatch: ");let o=Yd(this.elementShape,this.tensors,e);return z(()=>{let s=this.tensors.map(a=>F(a,o));return cr(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Yd(this.elementShape,this.tensors,e),o=this.tensors.pop();return o.kept=!1,Jn(o.shape,e,"TensorList shape mismatch: "),F(o,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Jn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Et(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new ku([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Jn(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=Yd(this.elementShape,this.tensors,t);return F(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Jn(this.elementShape,t.shape,"TensorList shape mismatch: "),Et(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Jn(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=Yd(this.elementShape,this.tensors,n);return e.length===0?mr([],[0].concat(o)):z(()=>{let s=e.map(a=>F(this.tensors[a],o));return cr(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Jn(this.elementShape,t,"TensorList shape mismatch: ");let n=Yd(this.elementShape,this.tensors,t);return this.size()===0?mr([],[0].concat(n)):z(()=>{let o=this.tensors.map(s=>F(s,n));return ct(o,0)})}};function uF(r,e,t){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);let o=r.shape.slice(1);Jn(o,e,"TensorList shape mismatch: ");let s=Rr(r);return new ku(s,e,n)}function lF(r,e,t,n){return new ku([],r,e,n)}function pF(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);let o=Math.max(...e);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new ku([],t,r.dtype,n),a=Rr(r,0);return e.forEach((i,u)=>{s.setItem(i,a[u])}),s}function mF(r,e,t){let n=0,o=e.map(p=>(n+=p,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),a=sx(s,t),i=n===0?0:r.size/n,u=z(()=>{let p=[];r=F(r,[1,n,i]);for(let m=0;m<e.length;++m){let c=m===0?0:o[m-1],d=[0,c,0],f=[1,e[m],i];p[m]=F(ze(r,d,f),a)}return r.dispose(),p}),l=new ku([],t,r.dtype,e.length);for(let p=0;p<u.length;p++)l.setItem(p,u[p]);return l}var cF=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{let n=S("thenBranch",r,e,t),o=S("elseBranch",r,e,t),s=S("cond",r,e,t),a=S("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let n=S("body",r,e,t),o=S("cond",r,e,t),s=S("args",r,e,t),a=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),i=s.map(p=>p.id),u=await a[0].data();a.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&p.dispose()});let l=s;for(;u[0];){let p=l;l=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);let m=l.map(d=>d.id);p.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&m.indexOf(d.id)===-1&&d.dispose()});let c=await t.functionMap[o].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await c[0].data(),c.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&m.indexOf(d.id)===-1&&d.dispose()})}return l}case"LoopCond":{let n=S("pred",r,e,t);return[ci(n)]}case"Switch":{let n=S("pred",r,e,t),o=S("data",r,e,t);return o.kept||(o=ci(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>Ar(o,e,t)!==void 0);if(n){let o=Ar(n,e,t);return[ci(o)]}return}case"Enter":{let n=S("frameName",r,e,t),o=S("tensor",r,e,t);return t.enterFrame(n),[ci(o)]}case"Exit":{let n=S("tensor",r,e,t);return t.exitFrame(),[ci(n)]}case"NextIteration":{let n=S("tensor",r,e,t);return t.nextIteration(),[ci(n)]}case"TensorArrayV3":{let n=S("size",r,e,t),o=S("dtype",r,e,t),s=S("elementShape",r,e,t),a=S("dynamicSize",r,e,t),i=S("clearAfterRead",r,e,t),u=S("identicalElementShapes",r,e,t),l=S("name",r,e,t),p=new ax(l,o,n,s,u,a,i);return t.addTensorArray(p),[p.idTensor,ge(1)]}case"TensorArrayWriteV3":{let n=S("tensorArrayId",r,e,t),o=S("index",r,e,t),s=S("tensor",r,e,t),a=t.getTensorArray(n.id);return a.write(o,s),[a.idTensor]}case"TensorArrayReadV3":{let n=S("tensorArrayId",r,e,t),o=S("index",r,e,t);return[t.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=S("tensorArrayId",r,e,t),o=S("indices",r,e,t),s=S("dtype",r,e,t);return[t.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=S("tensorArrayId",r,e,t),o=S("indices",r,e,t),s=S("tensor",r,e,t),a=t.getTensorArray(n.id);return a.scatter(o,s),[a.idTensor]}case"TensorArrayConcatV3":{let n=S("tensorArrayId",r,e,t),o=t.getTensorArray(n.id),s=S("dtype",r,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let n=S("tensorArrayId",r,e,t),o=S("tensor",r,e,t),s=S("lengths",r,e,t),a=t.getTensorArray(n.id);return a.split(s,o),[a.idTensor]}case"TensorArraySizeV3":{let n=S("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return[ge(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=S("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=S("tensorListId",r,e,t),o=S("index",r,e,t),s=S("tensor",r,e,t),a=t.getTensorList(n.id);return a.setItem(o,s),[a.idTensor]}case"TensorListGetItem":{let n=S("tensorListId",r,e,t),o=S("index",r,e,t),s=S("elementShape",r,e,t),a=S("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(o,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{let n=S("indices",r,e,t),o=S("tensor",r,e,t),s=S("elementShape",r,e,t),a=S("numElements",r,e,t),i=pF(o,n,s,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=S("elementShape",r,e,t),o=S("elementDType",r,e,t),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let a=S(s,r,e,t),i=r.op==="TensorListReserve"?-1:a,u=lF(n,o,a,i);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{let n=S("tensorListId",r,e,t),o=S("indices",r,e,t),s=S("elementShape",r,e,t),a=S("elementDType",r,e,t);return[t.getTensorList(n.id).gather(o,a,s)]}case"TensorListStack":{let n=S("tensorListId",r,e,t),o=S("elementShape",r,e,t),s=S("elementDType",r,e,t),a=S("numElements",r,e,t);return[t.getTensorList(n.id).stack(o,s,a)]}case"TensorListFromTensor":{let n=S("tensor",r,e,t),o=S("elementShape",r,e,t),s=S("elementDType",r,e,t),a=uF(n,o,s);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=S("tensorListId",r,e,t),o=t.getTensorList(n.id),s=S("dtype",r,e,t),a=S("elementShape",r,e,t);return[o.concat(s,a)]}case"TensorListPushBack":{let n=S("tensorListId",r,e,t),o=S("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=S("tensorListId",r,e,t),o=S("elementShape",r,e,t),s=S("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=S("tensor",r,e,t),o=S("elementShape",r,e,t),s=S("lengths",r,e,t),a=mF(n,s,o);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{let n=S("tensorListId",r,e,t),o=t.getTensorList(n.id);return[ge(o.size(),"int32")]}case"TensorListResize":{let n=S("tensorListId",r,e,t),o=S("size",r,e,t),a=t.getTensorList(n.id).resize(o);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function dF(r,e,t){let[n,o]=S("fusedOps",r,e,t),s=n==="biasadd",a=!s,i=o==="prelu",u=n==="fusedbatchnorm",l=S("numArgs",r,e,t);if(s){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=S("strides",r,e,t),m=Zh(r,e,t),c=S("dataFormat",r,e,t).toUpperCase(),d=S("dilations",r,e,t),[f,h]=S("args",r,e,t);a&&(h=f,f=void 0);let g=S("leakyreluAlpha",r,e,t);return{stride:p,pad:m,dataFormat:c,dilations:d,biasArg:f,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var fF=(r,e,t,n=lt)=>{switch(r.op){case"Conv1D":{let o=S("stride",r,e,t),s=S("pad",r,e,t),a=S("dataFormat",r,e,t).toUpperCase(),i=S("dilation",r,e,t);return[n.conv1d(S("x",r,e,t),S("filter",r,e,t),o,s,a,i)]}case"Conv2D":{let o=S("strides",r,e,t),s=Zh(r,e,t),a=S("dataFormat",r,e,t).toUpperCase(),i=S("dilations",r,e,t);return[n.conv2d(S("x",r,e,t),S("filter",r,e,t),[o[1],o[2]],s,a,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:a,dilations:i,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:m}=dF(r,e,t);return[n.fused.conv2d({x:S("x",r,e,t),filter:S("filter",r,e,t),strides:[o[1],o[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:a,dilations:i,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:m}=dF(r,e,t);return[n.fused.depthwiseConv2d({x:S("x",r,e,t),filter:S("filter",r,e,t),strides:[o[1],o[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=S("outputShape",r,e,t),s=S("strides",r,e,t),a=Zh(r,e,t);return[n.conv2dTranspose(S("x",r,e,t),S("filter",r,e,t),o,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=S("strides",r,e,t),s=Zh(r,e,t),a=S("dilations",r,e,t),i=S("dataFormat",r,e,t).toUpperCase();return[n.depthwiseConv2d(S("input",r,e,t),S("filter",r,e,t),[o[1],o[2]],s,i,[a[1],a[2]])]}case"Conv3D":{let o=S("strides",r,e,t),s=S("pad",r,e,t),a=S("dataFormat",r,e,t).toUpperCase(),i=S("dilations",r,e,t);return[n.conv3d(S("x",r,e,t),S("filter",r,e,t),[o[1],o[2],o[3]],s,a,[i[1],i[2],i[3]])]}case"AvgPool":{let o=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[n.avgPool(S("x",r,e,t),[a[1],a[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[n.maxPool(S("x",r,e,t),[a[1],a[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t),i=S("includeBatchInIndex",r,e,t),{result:u,indexes:l}=n.maxPoolWithArgmax(S("x",r,e,t),[a[1],a[2]],[o[1],o[2]],s,i);return[u,l]}case"AvgPool3D":{let o=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[n.avgPool3d(S("x",r,e,t),[a[1],a[2],a[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=S("strides",r,e,t),s=S("pad",r,e,t),a=S("kernelSize",r,e,t);return[n.maxPool3d(S("x",r,e,t),[a[1],a[2],a[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=S("strides",r,e,t),s=S("pad",r,e,t),a=S("dilations",r,e,t),i=o[1],u=o[2],l=a[1],p=a[2];return[n.dilation2d(S("x",r,e,t),S("filter",r,e,t),[i,u],s,[l,p],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var hF=(r,e,t,n=lt)=>{switch(r.op){case"Fill":{let o=S("shape",r,e,t),s=S("dtype",r,e,t),a=S("value",r,e,t);return[n.fill(o,a,s)]}case"LinSpace":{let o=S("start",r,e,t),s=S("stop",r,e,t),a=S("num",r,e,t);return[n.linspace(o,s,a)]}case"Multinomial":{let o=S("logits",r,e,t),s=S("numSamples",r,e,t),a=S("seed",r,e,t);return[n.multinomial(o,s,a)]}case"OneHot":{let o=S("indices",r,e,t),s=S("depth",r,e,t),a=S("onValue",r,e,t),i=S("offValue",r,e,t),u=S("dtype",r,e,t);return[n.oneHot(o,s,a,i,u)]}case"Ones":return[n.ones(S("shape",r,e,t),S("dtype",r,e,t))];case"OnesLike":return[n.onesLike(S("x",r,e,t))];case"RandomStandardNormal":return[n.randomStandardNormal(S("shape",r,e,t),S("dtype",r,e,t),S("seed",r,e,t))];case"RandomUniform":return[n.randomUniform(S("shape",r,e,t),S("minval",r,e,t),S("maxval",r,e,t),S("dtype",r,e,t))];case"Range":{let o=S("start",r,e,t),s=S("stop",r,e,t),a=S("step",r,e,t);return[n.range(o,s,a,S("dtype",r,e,t))]}case"TruncatedNormal":{let o=S("shape",r,e,t),s=S("mean",r,e,t),a=S("stdDev",r,e,t),i=S("seed",r,e,t);return[n.truncatedNormal(o,s,a,S("dtype",r,e,t),i)]}case"Zeros":return[n.zeros(S("shape",r,e,t),S("dtype",r,e,t))];case"ZerosLike":return[n.zerosLike(S("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Nw(r,e,t){let n=S("boxes",r,e,t),o=S("scores",r,e,t),s=S("maxOutputSize",r,e,t),a=S("iouThreshold",r,e,t),i=S("scoreThreshold",r,e,t),u=S("softNmsSigma",r,e,t);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}}var gF=async(r,e,t,n,o=lt)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:p}=Nw(r,e,t),m=await o.image.nonMaxSuppressionWithScoreAsync(s,a,i,u,l,p);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Nw(r,e,t),p=S("padToMaxOutputSize",r,e,t),m=await o.image.nonMaxSuppressionPaddedAsync(s,a,i,u,l,p);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Nw(r,e,t);return[await o.image.nonMaxSuppressionAsync(s,a,i,u,l)]}case"Where":{let s=o.cast(S("condition",r,e,t),"bool"),a=[await o.whereAsync(s)];return s.dispose(),a}case"ListDiff":return o.setdiff1dAsync(S("x",r,e,t),S("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var bF=(r,e,t,n=lt)=>{switch(r.op){case"LowerBound":{let o=S("sortedSequence",r,e,t),s=S("values",r,e,t);return[n.lowerBound(o,s)]}case"TopKV2":{let o=S("x",r,e,t),s=S("k",r,e,t),a=S("sorted",r,e,t),i=n.topk(o,s,a);return[i.values,i.indices]}case"UpperBound":{let o=S("sortedSequence",r,e,t),s=S("values",r,e,t);return[n.upperBound(o,s)]}case"Unique":{let o=S("x",r,e,t),s=n.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=S("x",r,e,t),s=S("axis",r,e,t),a=n.unique(o,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var yF=(r,e,t,n=lt)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":let o=S("default",r,e,t);return[Ar(r.name,e,t)||o];case"Placeholder":return[Ar(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let p=S("x",r,e,t);return[ci(p)]}case"IdentityN":return S("x",r,e,t).map(p=>ci(p));case"Snapshot":let s=S("x",r,e,t);return[ci(s)];case"Shape":return[n.tensor1d(S("x",r,e,t).shape,"int32")];case"ShapeN":return S("x",r,e,t).map(p=>n.tensor1d(p.shape));case"Size":return[n.scalar(S("x",r,e,t).size,"int32")];case"Rank":return[n.scalar(S("x",r,e,t).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let a=S("x",r,e,t),i=S("data",r,e,t),u=S("message",r,e,t),l=S("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<i.length;p++)console.log(Array.prototype.slice.call(i[p].dataSync()).slice(0,l));return[a];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ix=class{constructor(e,t){this.keyDType=e;this.valueDType=t;this.handle=ge(0),this.tensorMap=new Map,Et(this.handle)}handle;tensorMap;get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ge(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),z(()=>{let o=Rr(t),s=n.length,a=o.length;y.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let u=n[i],l=o[i];Et(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return z(()=>{let o=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);o.push(i)}return cr(o)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};var TF=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=n.getHashTableHandleByName(r.name);if(o!=null)return[o];{let s=S("keyDType",r,e,t),a=S("valueDType",r,e,t),i=new ix(s,a);return n.addHashTable(r.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=S("tableHandle",r,e,t,n),s=S("keys",r,e,t),a=S("values",r,e,t);return[await n.getHashTableById(o.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{let o=S("tableHandle",r,e,t,n),s=S("keys",r,e,t),a=S("defaultValue",r,e,t);return[await n.getHashTableById(o.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=S("tableHandle",r,e,t,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var xF=(r,e,t,n=lt)=>{switch(r.op){case"ResizeBilinear":{let o=S("images",r,e,t),s=S("size",r,e,t),a=S("alignCorners",r,e,t),i=S("halfPixelCenters",r,e,t);return[n.image.resizeBilinear(o,[s[0],s[1]],a,i)]}case"ResizeNearestNeighbor":{let o=S("images",r,e,t),s=S("size",r,e,t),a=S("alignCorners",r,e,t),i=S("halfPixelCenters",r,e,t);return[n.image.resizeNearestNeighbor(o,[s[0],s[1]],a,i)]}case"CropAndResize":{let o=S("image",r,e,t),s=S("boxes",r,e,t),a=S("boxInd",r,e,t),i=S("cropSize",r,e,t),u=S("method",r,e,t),l=S("extrapolationValue",r,e,t);return[n.image.cropAndResize(o,s,a,i,u,l)]}case"ImageProjectiveTransformV3":{let o=S("images",r,e,t),s=S("transforms",r,e,t),a=S("outputShape",r,e,t),i=S("fillValue",r,e,t),u=S("interpolation",r,e,t),l=S("fillMode",r,e,t);return[n.image.transform(o,s,u.toLowerCase(),l.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var IF=(r,e,t,n=lt)=>{switch(r.op){case"Equal":return[n.equal(S("a",r,e,t),S("b",r,e,t))];case"NotEqual":return[n.notEqual(S("a",r,e,t),S("b",r,e,t))];case"Greater":return[n.greater(S("a",r,e,t),S("b",r,e,t))];case"GreaterEqual":return[n.greaterEqual(S("a",r,e,t),S("b",r,e,t))];case"Less":return[n.less(S("a",r,e,t),S("b",r,e,t))];case"LessEqual":return[n.lessEqual(S("a",r,e,t),S("b",r,e,t))];case"LogicalAnd":return[n.logicalAnd(S("a",r,e,t),S("b",r,e,t))];case"LogicalNot":return[n.logicalNot(S("a",r,e,t))];case"LogicalOr":return[n.logicalOr(S("a",r,e,t),S("b",r,e,t))];case"Select":case"SelectV2":return[n.where(S("condition",r,e,t),S("a",r,e,t),S("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var CF=(r,e,t,n=lt)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(S("a",r,e,t),S("b",r,e,t),S("transposeA",r,e,t),S("transposeB",r,e,t))];case"Einsum":return[n.einsum(S("equation",r,e,t),...S("tensors",r,e,t))];case"Transpose":return[n.transpose(S("x",r,e,t),S("perm",r,e,t))];case"_FusedMatMul":let[o,s]=S("fusedOps",r,e,t),a=o==="biasadd",i=s==="prelu",u=S("numArgs",r,e,t),l=S("leakyreluAlpha",r,e,t);if(a){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[p,m]=S("args",r,e,t);return[n.fused.matMul({a:S("a",r,e,t),b:S("b",r,e,t),transposeA:S("transposeA",r,e,t),transposeB:S("transposeB",r,e,t),bias:p,activation:s,preluActivationWeights:m,leakyreluAlpha:l})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var kF=(r,e,t,n=lt)=>{switch(r.op){case"EuclideanNorm":return[n.euclideanNorm(S("x",r,e,t),S("axis",r,e,t),S("keepDims",r,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(S("x",r,e,t),S("mean",r,e,t),S("variance",r,e,t),S("offset",r,e,t),S("scale",r,e,t),S("epsilon",r,e,t))];case"FusedBatchNormV3":return[n.batchNorm(S("x",r,e,t),S("mean",r,e,t),S("variance",r,e,t),S("offset",r,e,t),S("scale",r,e,t),S("epsilon",r,e,t))];case"LRN":return[n.localResponseNormalization(S("x",r,e,t),S("radius",r,e,t),S("bias",r,e,t),S("alpha",r,e,t),S("beta",r,e,t))];case"Softmax":return[n.softmax(S("x",r,e,t))];case"LogSoftmax":return[n.logSoftmax(S("x",r,e,t))];case"SparseToDense":return[n.sparseToDense(S("sparseIndices",r,e,t),S("outputShape",r,e,t),S("sparseValues",r,e,t),S("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var SF=(r,e,t,n=lt)=>{switch(r.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=n.raggedGather(S("paramsNestedSplits",r,e,t),S("paramsDenseValues",r,e,t),S("indices",r,e,t),S("outputRaggedRank",r,e,t));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=n.raggedRange(S("starts",r,e,t),S("limits",r,e,t),S("splits",r,e,t));return[o,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(S("shape",r,e,t),S("values",r,e,t),S("defaultValue",r,e,t),S("rowPartitionTensors",r,e,t),S("rowPartitionTypes",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var vF=(r,e,t,n=lt)=>{switch(r.op){case"Max":{let i=S("axis",r,e,t),u=S("keepDims",r,e,t);return[n.max(S("x",r,e,t),i,u)]}case"Mean":{let i=S("axis",r,e,t),u=S("keepDims",r,e,t);return[n.mean(S("x",r,e,t),i,u)]}case"Min":{let i=S("axis",r,e,t),u=S("keepDims",r,e,t);return[n.min(S("x",r,e,t),i,u)]}case"Sum":{let i=S("axis",r,e,t),u=S("keepDims",r,e,t);return[n.sum(S("x",r,e,t),i,u)]}case"All":{let i=S("axis",r,e,t),u=S("keepDims",r,e,t);return[n.all(S("x",r,e,t),i,u)]}case"Any":{let i=S("axis",r,e,t),u=S("keepDims",r,e,t);return[n.any(S("x",r,e,t),i,u)]}case"ArgMax":{let i=S("axis",r,e,t);return[n.argMax(S("x",r,e,t),i)]}case"ArgMin":{let i=S("axis",r,e,t);return[n.argMin(S("x",r,e,t),i)]}case"Prod":{let i=S("axis",r,e,t),u=S("keepDims",r,e,t);return[n.prod(S("x",r,e,t),i,u)]}case"Cumprod":{let i=S("axis",r,e,t),u=S("exclusive",r,e,t),l=S("reverse",r,e,t);return[n.cumprod(S("x",r,e,t),i,u,l)]}case"Cumsum":{let i=S("axis",r,e,t),u=S("exclusive",r,e,t),l=S("reverse",r,e,t);return[n.cumsum(S("x",r,e,t),i,u,l)]}case"Bincount":let o=S("x",r,e,t),s=S("weights",r,e,t),a=S("size",r,e,t);return[n.bincount(o,s,a)];case"DenseBincount":{let i=S("x",r,e,t),u=S("weights",r,e,t),l=S("size",r,e,t),p=S("binaryOutput",r,e,t);return[n.denseBincount(i,u,l,p)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var AF=(r,e,t,n=lt)=>{switch(r.op){case"ConcatV2":case"Concat":{let o=S("n",r,e,t),s=S("axis",r,e,t),a=S("tensors",r,e,t);return a=a.slice(0,o),[n.concat(a,s)]}case"Gather":{let o=S("x",r,e,t),s=S("indices",r,e,t);return[n.gather(o,n.cast(s,"int32"),0)]}case"GatherV2":{let o=S("axis",r,e,t),s=S("batchDims",r,e,t),a=S("x",r,e,t),i=S("indices",r,e,t);return[n.gather(a,n.cast(i,"int32"),o,s)]}case"Reverse":{let o=S("dims",r,e,t),s=[];for(let i=0;i<o.length;i++)o[i]&&s.push(i);let a=S("x",r,e,t);return[n.reverse(a,s)]}case"ReverseV2":{let o=S("axis",r,e,t),s=S("x",r,e,t);return[n.reverse(s,o)]}case"Slice":{let o=S("begin",r,e,t),s=S("size",r,e,t);return[n.slice(S("x",r,e,t),o,s)]}case"StridedSlice":{let o=S("begin",r,e,t),s=S("end",r,e,t),a=S("strides",r,e,t),i=S("beginMask",r,e,t),u=S("endMask",r,e,t),l=S("ellipsisMask",r,e,t),p=S("newAxisMask",r,e,t),m=S("shrinkAxisMask",r,e,t),c=S("x",r,e,t);return[n.stridedSlice(c,o,s,a,i,u,l,p,m)]}case"Pack":return z(()=>{let o=S("axis",r,e,t),s=S("tensors",r,e,t),a=s[0].shape,i=n.squeeze(s[0]).shape,u=s.map(l=>{let p=y.arraysEqual(l.shape,a);if(!p&&!y.arraysEqual(n.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return p?l:n.reshape(l,a)});return[n.stack(u,o)]});case"Unpack":{let o=S("axis",r,e,t),s=S("tensor",r,e,t);return n.unstack(s,o)}case"Tile":{let o=S("reps",r,e,t);return[n.tile(S("x",r,e,t),o)]}case"Split":case"SplitV":{let o=S("axis",r,e,t),s=S("numOrSizeSplits",r,e,t),a=S("x",r,e,t);return n.split(a,s,o)}case"ScatterNd":{let o=S("indices",r,e,t),s=S("values",r,e,t),a=S("shape",r,e,t);return[n.scatterND(o,s,a)]}case"GatherNd":{let o=S("x",r,e,t),s=S("indices",r,e,t);return[n.gatherND(o,s)]}case"SparseToDense":{let o=S("sparseIndices",r,e,t),s=S("outputShape",r,e,t),a=S("sparseValues",r,e,t),i=S("defaultValue",r,e,t);return[n.sparseToDense(o,a,s,a.dtype===i.dtype?i:n.cast(i,a.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var wF=(r,e,t,n=lt)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:a,reverseIndexMap:i}=n.sparse.sparseFillEmptyRows(S("indices",r,e,t),S("values",r,e,t),S("denseShape",r,e,t),S("defaultValue",r,e,t));return[o,s,a,i]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=n.sparse.sparseReshape(S("inputIndices",r,e,t),S("inputShape",r,e,t),S("newShape",r,e,t));return[o,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(S("data",r,e,t),S("indices",r,e,t),S("segmentIds",r,e,t))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(S("data",r,e,t),S("indices",r,e,t),S("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var NF=(r,e,t,n=lt)=>{switch(r.op){case"FFT":return[n.fft(S("x",r,e,t))];case"IFFT":return[n.ifft(S("x",r,e,t))];case"RFFT":return[n.rfft(S("x",r,e,t))];case"IRFFT":return[n.irfft(S("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var DF=(r,e,t,n=lt)=>{switch(r.op){case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=n.string.stringNGrams(S("data",r,e,t),S("dataSplits",r,e,t),S("separator",r,e,t),S("nGramWidths",r,e,t),S("leftPad",r,e,t),S("rightPad",r,e,t),S("padWidth",r,e,t),S("preserveShortSequences",r,e,t));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:a}=n.string.stringSplit(S("input",r,e,t),S("delimiter",r,e,t),S("skipEmpty",r,e,t));return[o,s,a]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(S("input",r,e,t),S("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var _F=(r,e,t,n=lt)=>{switch(r.op){case"Cast":return[n.cast(S("x",r,e,t),S("dtype",r,e,t))];case"ExpandDims":{let o=S("axis",r,e,t);return[n.expandDims(S("x",r,e,t),o)]}case"Squeeze":{let o=S("axis",r,e,t);return[n.squeeze(S("x",r,e,t),o)]}case"Reshape":return[n.reshape(S("x",r,e,t),S("shape",r,e,t))];case"MirrorPad":return[n.mirrorPad(S("x",r,e,t),S("padding",r,e,t),S("mode",r,e,t))];case"PadV2":case"Pad":return[n.pad(S("x",r,e,t),S("padding",r,e,t),S("constantValue",r,e,t))];case"SpaceToBatchND":{let o=S("blockShape",r,e,t),s=S("paddings",r,e,t);return[n.spaceToBatchND(S("x",r,e,t),o,s)]}case"BatchToSpaceND":{let o=S("blockShape",r,e,t),s=S("crops",r,e,t);return[n.batchToSpaceND(S("x",r,e,t),o,s)]}case"DepthToSpace":{let o=S("blockSize",r,e,t),s=S("dataFormat",r,e,t).toUpperCase();return[n.depthToSpace(S("x",r,e,t),o,s)]}case"BroadcastTo":return[n.broadcastTo(S("x",r,e,t),S("shape",r,e,t))];case"BroadcastArgs":return[n.broadcastArgs(S("s0",r,e,t),S("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Dw(r,e,t,n,o=z){let s=((a,i,u)=>{switch(a.category){case"arithmetic":return o(()=>sF(a,i,u));case"basic_math":return o(()=>aF(a,i,u));case"control":return cF(a,i,u);case"convolution":return o(()=>fF(a,i,u));case"creation":return o(()=>hF(a,i,u));case"dynamic":return gF(a,i,u);case"evaluation":return o(()=>bF(a,i,u));case"image":return o(()=>xF(a,i,u));case"graph":return o(()=>yF(a,i,u));case"logical":return o(()=>IF(a,i,u));case"matrices":return o(()=>CF(a,i,u));case"normalization":return o(()=>kF(a,i,u));case"ragged":return o(()=>SF(a,i,u));case"reduction":return o(()=>vF(a,i,u));case"slice_join":return o(()=>AF(a,i,u));case"sparse":return o(()=>wF(a,i,u));case"spectral":return o(()=>NF(a,i,u));case"string":return o(()=>DF(a,i,u));case"transformation":return o(()=>_F(a,i,u));case"hash_table":return TF(a,i,u,n);case"custom":let l=HT(a.op);if(l&&l.customExecutor)return l.customExecutor(new ox(a,i,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return y.isPromise(s)?s.then(a=>[].concat(a)):[].concat(s)}var Qh=class{constructor(e={},t={},n={},o={}){this.weightMap=e;this.tensorArrayMap=t;this.tensorListMap=n;this.functionMap=o;this.generateCurrentContextIds()}rootContext={id:0,frameName:"",iterationId:0};contexts=[this.rootContext];lastId=0;_currentContextIds;newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function _w(r,e,t,n){let o=new Set,s=[],a=null,i=null,u=new Set,l=Object.keys(r).map(c=>Sn(c)[0]),p=[];n!=null&&(p=n.map(c=>Sn(c.name)[0]));let m=[...e];for(;m.length>0;){let c=m.pop();if((Mw(c)||kre(c)||Sre(c))&&a==null&&(a=c,i=a.children.map(d=>d.name).filter(d=>o.has(d))),o.add(c.name),t[c.name]==null&&l.indexOf(c.name)===-1&&p.indexOf(c.name)===-1){if(c.inputs.length===0){s.push(c.name);continue}c.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),m.push(d))})}}return{inputs:r,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:a,syncInputs:i}}function MF(r,e,t){let{usedNodes:n,inputs:o}=t,s=[],a=Object.keys(o).map(p=>Sn(p)[0]).map(p=>r.nodes[p]),i=r.initNodes;a.forEach(p=>{n.has(p.name)&&s.push(p)}),r.weights.forEach(p=>{n.has(p.name)&&s.push(p)}),i?.forEach(p=>{n.has(p.name)&&s.push(p)});let u=new Set,l=[];for(;s.length>0;){let p=s.pop();u.add(p.name),e[p.name]||l.push(p),p.children.forEach(m=>{!u.has(m.name)&&n.has(m.name)&&m.inputs.every(c=>u.has(c.name))&&s.push(m)})}return l}var xre=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Ire=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Cre=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Mw(r){return xre.indexOf(r.op)>=0}function kre(r){return Ire.indexOf(r.op)>=0}function Sre(r){return Cre.indexOf(r.op)>=0}var $p=class{constructor(e,t){this.graph=e;this.parent=t;this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new $p(e.functions[n],this)})}compiledMap=new Map;_weightMap={};_weightIds;_signature;_inputs;_outputs;_initNodes;SEPERATOR=",";_functions={};_functionExecutorMap={};_resourceManager;clonedTensorsMap;keepIntermediateTensors=!1;get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,t){let n=_w(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(o.length>0){let i=t.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return MF(this.graph,this.weightMap,n)}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return Et(t),t}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=n.map(m=>this.graph.nodes[Sn(m)[0]]),s=t.map(m=>Sn(m)[0]),a=s.map(m=>this.graph.nodes[m]);a.length===0&&(a=this._outputs);let i=this.getCompilationKey(o,a),u=this.compiledMap.get(i);u==null&&(u=this.compile(e,a),this.compiledMap.set(i,u));try{this.keepIntermediateTensors=$().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let l={},p={};return z(()=>{let m=new Qh(this.weightMap,l,p,this.functionExecutorMap),c={...this.weightMap};this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(h=>{let[g,b]=Sn(h),T=[];T[b]=e[h],c[g]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(T))});let d=this.getFrozenTensorIds(c),f={};for(let h=0;h<u.length;h++){let g=u[h];if(!c[g.name]){let b=Dw(g,c,m,this._resourceManager);if(y.isPromise(b))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);c[g.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(b)),this.checkTensorForDisposal(g.name,g,c,m,d,s,f)}}return this.parent==null&&m.dispose(d),t.map(h=>Ar(h,c,m))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,n,o,s,a,i){t.category==="control"||a.indexOf(e)!==-1||(n[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){let l=tF(u.name,n,o);l?.forEach(p=>{if(p&&!p.kept&&!s.has(p.id)){let m=i[p.id];m===1?(p.dispose(),delete i[p.id]):m!=null&&i[p.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,o={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=$().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let a=new Qh(this.weightMap,o,s,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,a,t,n),u=t.map(c=>Ar(c,i,a)),l=u.map(c=>c.id),p=Object.keys(e).map(c=>e[c].id),m=new Set([...l,...p,...this.weightIds]);return Object.values(i).forEach(c=>{c.forEach(d=>{d&&!d.isDisposed&&!m.has(d.id)&&d.dispose()})}),this.parent==null&&a.dispose(m),u}async executeFunctionAsync(e,t,n){let o=e.reduce((s,a,i)=>(s[this.inputs[i].name]=a,s),{});return this._executeAsync(o,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,o){let s=Object.keys(e),a=s.map(x=>this.graph.nodes[Sn(x)[0]]),i=n.map(x=>Sn(x)[0]),u=i.map(x=>this.graph.nodes[x]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:p,dynamicNode:m,syncInputs:c}=_w(e,u,this.weightMap,this._initNodes),d=[...a,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),f={...this.weightMap};Object.keys(e).forEach(x=>{let[I,k]=Sn(x),w=[];w[k]=e[x],f[I]=w});let h={},g=this.getFrozenTensorIds(f),b={};for(;d.length>0;){let x=this.processStack(a,d,t,f,b,g,i,h,l);await Promise.all(x)}m==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let T=u.filter(x=>!Mw(x)&&!Ar(x.name,f,t)).map(x=>x.name);if(T.length>0){let x="";throw m!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${c}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${x}`)}return f}processStack(e,t,n,o,s,a,i,u,l){let p=[];for(;t.length>0;){let m=t.pop();n.currentContext=m.contexts;let c="";if(m.node.op==="Enter"&&S("isConstant",m.node,o,n)&&([c]=mi(m.node.name,n)),o[m.node.name]==null){let d=Dw(m.node,o,n,this._resourceManager);c||([c]=mi(m.node.name,n));let f=n.currentContext;y.isPromise(d)?p.push(d.then(h=>(o[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),n.currentContext=f,this.checkTensorForDisposal(c,m.node,o,n,a,i,u),this.processChildNodes(m.node,t,n,o,s,l),h))):(o[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,m.node,o,n,a,i,u),this.processChildNodes(m.node,t,n,o,s,l))}else this.processChildNodes(m.node,t,n,o,s,l)}return p}processChildNodes(e,t,n,o,s,a){e.children.forEach(i=>{let[u]=mi(i.name,n);s[u]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Ar(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:i})):i.inputNames.every(l=>!!Ar(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[o]=Sn(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,i=a.length===n.shape.length&&n.shape.every((u,l)=>a[l]===-1||a[l]===u);y.assert(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e){let o=this._signature?.inputs?.[n];o!=null?t[o.name]=e[n]:t[n]=e[n]}return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[o]=Sn(n);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{let n=this._signature?.outputs?.[t];return n!=null?n.name:t},{})}checkOutputs(e){e.forEach(t=>{let[n]=Sn(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}};var ux=class{constructor(e={},t={}){this.hashTableNameToHandle=e;this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};var vre="?tfjs-format=file",Are="model.json",Jh=class{constructor(e,t={},n=Br){this.modelUrl=e;this.loadOptions=t;this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new ux}executor;version="n/a";handler;artifacts;initializer;resourceIdToCapturedInput;resourceManager;signature;initializerSignature;structuredOutputKeys;io;get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return y.isPromise(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(n=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let o=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new $p(Xd.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=Xd.Instance.transformGraph(e.modelInitializer);this.initializer=new $p(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof We?[e]:e,n={};return t.forEach((o,s)=>n[this.structuredOutputKeys[s]]=o),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){if(!(e instanceof We)&&!Array.isArray(e)){let o=this.signature?.inputs;if(o!=null)for(let s in o){let a=o[s];a.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];let t=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+t!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-t} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((o,s)=>{let a=this.signature?.inputs?.[s]?.resourceId;return a!=null?o[s]=this.resourceIdToCapturedInput[a]:o[s]=e[n++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let o=0;o<n.length;o++){let s=n[o],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[o]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function wre(r,e={},t=Br){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof r=="string"&&(r=Dre(r));let n=new Jh(r,e,t);return await n.load(),n}function Nre(r){if(r==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(r instanceof Array){let[n,o]=r;if(!n)throw new Error("modelJSON must be the first element of the array");if(!o||!(o instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let s=Br.getWeightSpecs(n.weightsManifest),a=Br.getModelArtifactsForJSONSync(n,s,o);e=Br.fromMemorySync(a)}else if("load"in r)e=r;else if("modelTopology"in r&&"weightSpecs"in r&&"weightData"in r)e=Br.fromMemorySync(r);else throw new Error("Unknown model format");let t=new Jh(e);return t.load(),t}function Dre(r){return r.endsWith("/")||(r=r+"/"),`${r}${Are}${vre}`}var _re="0.0.0";var QF={};qe(QF,{CSVDataset:()=>Jd,Dataset:()=>di,FileDataSource:()=>of,TextLineDataset:()=>Qd,URLDataSource:()=>sf,array:()=>GF,csv:()=>HF,func:()=>qF,generator:()=>jF,microphone:()=>YF,version_data:()=>ZF,webcam:()=>XF,zip:()=>WF});var zF=Wl(_h());var $F=Wl(_h());function RF(r,e){return lx(r,e)}function lx(r,e,t=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(t.has(r))return t.get(r);let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(Pl(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let i=r[a],u=lx(i,e,t,n);s[a]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return t.set(r,o.value),o.value}function PF(r,e=Pw){return EF(r,e)}function EF(r,e,t=new Set){let n=r[0];if(t.has(n))throw new Error("Circular references are not supported.");let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(Pl(n)){let s=Array.isArray(n)?[]:{};t.add(n);for(let a in n){let i=r.map(l=>l[a]),u=EF(i,e,t);s[a]=u}return t.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function Pw(r){return r===null?null:Pl(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function px(r,e){let t=new Map;lx(r,e,t);for(let o of Array.from(t.keys())){let s=t.get(o);if(y.isPromise(s)){let a=await s;t.set(o,a)}}return lx(r,e,t)}function Pl(r){let e=!1;if($().get("IS_BROWSER"))e=r instanceof TextDecoder;else{let{StringDecoder:t}=Rw();e=r instanceof t}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof We)&&!(r instanceof Promise)&&!e)}function FF(r){return r==null||Mre(r)||Array.isArray(r)||typeof r=="object"&&r instanceof We||y.isTypedArray(r)}function Mre(r){return r===null||typeof r!="object"&&typeof r!="function"}function LF(r){return RF(r,Rre)}function Rre(r){return r instanceof We?{value:r.clone(),recurse:!1}:Pl(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var Zd=class{constructor(e){this.capacity=e;if(e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}begin=0;end=0;doubledCapacity;data;wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}};var Ew=class extends Zd{constructor(){super(Ew.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let o=0;o<n;o++)t[o]=this.get(this.wrap(this.begin+o));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},eg=Ew;K(eg,"INITIAL_CAPACITY",32);function qw(r){return new Fw(r)}function tg(r){return new Lw(r)}function BF(r,e){return new cx(r,e)}function OF(r,e=jw.FAIL){return new Vw(r,e)}var ar=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new Uw(this,e)}filter(e){return new Gw(this,e)}map(e){return new Ww(this,e)}mapAsync(e){return new mx(this,e)}serialMapAsync(e){return new mx(this,e).serial()}flatmap(e){return new Kw(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new zw(this,e,t)}columnMajorBatch(e,t=!0,n=Pw){return this.rowMajorBatch(e,t).map(s=>PF(s,n))}concatenate(e,t){return new cx(qw([this,e]),t)}take(e){return e<0||e==null?this:new Ow(this,e)}skip(e){return e<0||e==null?this:new Bw(this,e)}prefetch(e){return new dx(this,e)}shuffle(e,t){return new Hw(this,e,t)}serial(){return new $w(this)}},Fw=class extends ar{constructor(t){super();this.items=t}trav=0;summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:LF(t),done:!1}}},Lw=class extends ar{constructor(t){super();this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},$w=class extends ar{constructor(t){super();this.upstream=t;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},Bw=class extends ar{constructor(t,n){super();this.upstream=t;this.maxCount=n;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;count=0;summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;_e(t.value)}return this.upstream.next()}},Ow=class extends ar{constructor(t,n){super();this.upstream=t;this.maxCount=n}count=0;summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},zw=class extends ar{constructor(t,n,o=!0){super();this.upstream=t;this.batchSize=n;this.enableSmallLastBatch=o;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}}},Gw=class extends ar{constructor(t,n){super();this.upstream=t;this.predicate=n;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;_e(t.value)}}},Ww=class extends ar{constructor(t,n){super();this.upstream=t;this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let n=Gs.getTensorsInContainer(t.value),o=this.transform(t.value),s=Gs.getTensorsInContainer(o);for(let a of n)Gs.isTensorInList(a,s)||a.dispose();return{value:o,done:!1}}},Uw=class extends ar{constructor(t,n){super();this.upstream=t;this.handler=n;this.lastRead=Promise.resolve({value:null,done:!1})}count=0;summary(){return`${this.upstream.summary()} -> handleErrors`}lastRead;async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},mx=class extends ar{constructor(t,n){super();this.upstream=t;this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let n=Gs.getTensorsInContainer(t.value),o=await this.transform(t.value),s=Gs.getTensorsInContainer(o);for(let a of n)Gs.isTensorInList(a,s)||a.dispose();return{value:o,done:!1}}},Bp=class extends ar{lastRead;outputQueue;constructor(){super(),this.outputQueue=new eg,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Kw=class extends Bp{constructor(t,n){super();this.upstream=t;this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let n=Gs.getTensorsInContainer(t.value),o=this.transform(t.value),s=Gs.getTensorsInContainer(o);this.outputQueue.pushAll(o);for(let a of n)Gs.isTensorInList(a,s)||a.dispose();return!0}},cx=class extends ar{constructor(t,n){super();this.baseErrorHandler=n;this.moreIterators=t}lastRead=null;iterator=null;moreIterators;summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let o=await this.moreIterators.next();if(o.done)return{value:null,done:!0};this.iterator=o.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(t)):n}},jw=(n=>(n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST",n))(jw||{}),Vw=class extends ar{constructor(t,n=0){super();this.iterators=t;this.mismatchMode=n}count=0;currentPromise=null;summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let n=0,o=0;function s(i){return i instanceof ar?{value:i.next().then(l=>(n++,l.done&&o++,l.value)),recurse:!1}:{value:null,recurse:!0}}let a=await px(this.iterators,s);if(n===o)return{value:null,done:!0};if(o>0)switch(this.mismatchMode){case 0:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case 1:return{value:null,done:!0};case 2:default:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},dx=class extends ar{constructor(t,n){super();this.upstream=t;this.bufferSize=n;this.buffer=new Zd(n)}buffer;summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},Hw=class extends dx{constructor(t,n,o){super(t,n);this.upstream=t;this.windowSize=n;this.random=$F.alea(o||y.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}random;lastRead;upstreamExhausted=!1;async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),n=await this.buffer.shuffleExcise(t);if(n.done)this.upstreamExhausted=!0;else return this.refill(),n}return{value:null,done:!0}}};var di=class{size=null;batch(e,t=!0){let n=this;y.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let o;return this.size===1/0||this.size==null?o=this.size:t?o=Math.ceil(this.size/e):o=Math.floor(this.size/e),Ln(async()=>(await n.iterator()).columnMajorBatch(e,t,Pre),o)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Ln(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Ln(async()=>(await t.iterator()).filter(o=>z(()=>e(o))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Ln(async()=>(await t.iterator()).map(n=>z(()=>e(n))),this.size)}mapAsync(e){let t=this;return Ln(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Ln(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Ln(async()=>{let o=tg(async()=>({value:await t.iterator(),done:!1}));return BF(o.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Ln(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=zF.alea(t||y.now().toString());return Ln(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await o.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Ln(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};K(di,"MAX_BUFFER_SIZE",1e4);function Ln(r,e=null){return new class extends di{size=e;async iterator(){return r()}}}function GF(r){return Ln(async()=>qw(r),r.length)}function WF(r){if(!Pl(r))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(r))for(let t=0;t<r.length;t++)e=e==null?r[t].size:Math.min(e,r[t].size);else if(r instanceof Object)for(let t in r)e=e==null?r[t].size:Math.min(e,r[t].size);return Ln(async()=>{let t=await px(r,n=>{if(n instanceof di)return{value:n.iterator(),recurse:!1};if(Pl(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return OF(t,1)},e)}function Pre(r){if(r===null)return null;let e=r[0];return FF(e)?{value:Ere(r),recurse:!1}:{value:null,recurse:!0}}function Ere(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof We?cr(r):mr(r)}var Qd=class extends di{constructor(t){super();this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(s=>(s.endsWith("\r")&&(s=s.slice(0,-1)),s))}};var fx='"',rg=Symbol("out"),UF=Symbol("field"),hx=Symbol("quote"),Xw=Symbol("quoteafterquote"),KF=Symbol("quoteinquote"),Jd=class extends di{constructor(t,n){super();this.input=t;this.base=new Qd(t),n||(n={}),this.hasHeader=n.hasHeader!==!1,this.fullColumnNames=n.columnNames,this.columnConfigs=n.columnConfigs,this.configuredColumnsOnly=n.configuredColumnsOnly,n.delimWhitespace?(y.assert(n.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=n.delimiter?n.delimiter:","}base;hasHeader=!0;fullColumnNames=null;columnNamesValidated=!1;columnConfigs=null;configuredColumnsOnly=!1;delimiter=",";delimWhitespace=!1;async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&y.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let n=this.fullColumnNames.reduce((s,a)=>(s[a]=s[a]+1||1,s),{}),o=Object.keys(n).filter(s=>n[s]>1);if(y.assert(o.length===0,()=>"Duplicate column names found: "+o.toString()),this.columnConfigs){for(let s of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(s)===-1)throw new Error('The key "'+s+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let n=await(await this.base.iterator()).next();if(n.done)throw new Error("No data was found for CSV parsing.");let o=n.value;return this.parseRow(o,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(n=>this.makeDataElement(n))}makeDataElement(t){let n=this.parseRow(t),o={},s={};for(let a=0;a<this.fullColumnNames.length;a++){let i=this.fullColumnNames[a],u=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!u)){let l=n[a],p=null;if(l==="")if(u&&u.default!==void 0)p=u.default;else{if(u&&(u.required||u.isLabel))throw new Error(`Required column ${i} is empty in this line: ${t}`);p=void 0}else{let m=Number(l);if(isNaN(m))u&&u.dtype==="bool"?p=this.getBoolean(l):p=l;else if(!u||!u.dtype)p=m;else switch(u.dtype){case"float32":p=m;break;case"int32":p=Math.floor(m);break;case"bool":p=this.getBoolean(l);break;default:p=m}}u&&u.isLabel?s[i]=p:o[i]=p}}return Object.keys(s).length===0?o:{xs:o,ys:s}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,n=!0){let o=[],s=0,a=t.length,i=rg;for(let u=0;u<a;u++)switch(i){case rg:switch(t.charAt(u)){case fx:s=u+1,i=hx;break;case this.delimiter:if(s=u+1,this.delimiter===" "&&this.delimWhitespace)break;o.push(""),i=rg;break;default:i=UF,s=u;break}break;case UF:switch(t.charAt(u)){case this.delimiter:o.push(t.substring(s,u)),i=rg,s=u+1;break;default:}break;case hx:switch(t.charAt(u)){case fx:i=Xw;break;default:}break;case Xw:switch(t.charAt(u)){case this.delimiter:o.push(t.substring(s,u-1)),i=rg,s=u+1;break;case fx:i=hx;break;default:i=KF;break}break;case KF:switch(t.charAt(u)){case fx:i=hx;break;default:}break;default:}if(i===Xw?o.push(t.substring(s,a-1)):o.push(t.substring(s)),n&&o.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${o}`);return o}};var ef=class extends ar{constructor(t){super();this.microphoneConfig=t;this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}isClosed=!1;stream;fftSize;columnTruncateLength;freqData;timeData;numFrames;analyser;audioContext;sampleRateHz;audioTrackConstraints;smoothingTimeConstant;includeSpectrogram;includeWaveform;summary(){return"microphone"}static async create(t={}){if(!$().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new ef(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(o){throw new Error(`Error thrown while initializing video stream: ${o.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,o=await this.getAudioData();if(this.includeSpectrogram){let s=this.flattenQueue(o.freqDataQueue);t=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let s=this.flattenQueue(o.timeDataQueue);n=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],o=0;return new Promise(s=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&s({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++o===this.numFrames&&(clearInterval(a),s({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,o=new Float32Array(t.length*n);return t.forEach((s,a)=>o.set(s,a*n)),o}getTensorFromAudioDataArray(t,n){let o=new Float32Array(y.sizeFromShape(n));return o.set(t,o.length-t.length),mr(o,n)}};var tf=class extends ar{constructor(t,n){super();this.webcamVideoElement=t;this.webcamConfig=n;if(this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Jt([0],"int32"),this.webcamConfig.centerCrop){let o=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-o)/2,i=(1-s)/2,u=a+o,l=s+i;this.cropBox=ei([i,a,l,u],[1,4])}else this.cropBox=ei([0,0,1,1],[1,4])}isClosed=!0;stream;resize=!1;cropSize;cropBox;cropBoxInd;summary(){return"webcam"}static async create(t,n={}){if(!$().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let o=new tf(t,n);return await o.start(),o}async start(){this.webcamConfig.facingMode&&y.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=$b.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return z(()=>{let n=yr(re(t,"float32"),0),o;o=fs.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let s=o.shape;return F(o,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(n=>n.stop());try{this.webcamVideoElement.srcObject=null}catch(n){console.log(n),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var rf=class{};var ng=class extends ar{split(e){return new Yw(this,e)}},Yw=class extends ng{constructor(t,n){super();this.upstream=t;this.impl=new Zw(t,n)}impl;summary(){return this.impl.summary()}async next(){return this.impl.next()}},Zw=class extends Bp{constructor(t,n){super();this.upstream=t;this.separator=n}carryover="";summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let n=t.value.split(this.separator);n[0]=this.carryover+n[0];for(let o of n.slice(0,-1))this.outputQueue.push(o);return this.carryover=n[n.length-1],!0}};var gx=class extends ar{decodeUTF8(){return new Qw(this)}},Qw=class extends ng{constructor(t){super();this.upstream=t;this.impl=new Jw(t)}impl;summary(){return this.impl.summary()}async next(){return this.impl.next()}},Jw=class extends Bp{constructor(t){super();this.upstream=t;if($().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:n}=Rw();this.decoder=new n("utf8")}}decoder;summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),n;if(t.done)return!1;n=t.value;let o;return $().get("IS_BROWSER")?o=this.decoder.decode(n,{stream:!0}):o=this.decoder.write(Buffer.from(n.buffer)),this.outputQueue.push(o),!0}};var nf=class extends gx{constructor(t,n={}){super();this.file=t;this.options=n;y.assert(t instanceof Uint8Array||($().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=n.offset||0,this.chunkSize=n.chunkSize||1024*1024}offset;chunkSize;summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((n,o)=>{let s=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)n(new Uint8Array(this.file.slice(this.offset,s)));else{let a=new FileReader;a.onload=u=>{let l=a.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return o(new TypeError("FileReader returned unknown type."));n(l)},a.onabort=u=>o(new Error("Aborted")),a.onerror=u=>o(new Error(u.type));let i=this.file.slice(this.offset,s);a.readAsArrayBuffer(i)}this.offset=s}),done:!1}}};async function VF(r,e={},t){let n,o;typeof r=="string"?n=r:(n=r.url,o=Fre(r));let s=await(t||y.fetch)(n,o);if(s.ok){let a=new Uint8Array(await s.arrayBuffer());return new nf(a,e)}else throw new Error(s.statusText)}var Fre=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function bx(r){return typeof r=="string"&&r.slice(0,7)==="file://"}var of=class extends rf{constructor(t,n={}){super();this.input=t;this.options=n}async iterator(){if(bx(this.input)&&$().get("IS_NODE")){let t=yx();this.input=t.readFileSync(this.input.slice(7))}return new nf(this.input,this.options)}};var sf=class extends rf{constructor(t,n={}){super();this.url=t;this.fileOptions=n}async iterator(){return bx(this.url)?new of(this.url,this.fileOptions).iterator():VF(this.url,this.fileOptions)}};function HF(r,e={}){return new Jd(new sf(r),e)}function qF(r){let e=tg(r);return Ln(async()=>e)}function jF(r){return Ln(async()=>{let e=await r();return tg(()=>e.next())})}async function XF(r,e){return tf.create(r,e)}async function YF(r){return ef.create(r)}var ZF="0.0.0";function ee(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var Lre=xr.whereImpl,eN=class extends po{blockSize=48;data;firstUse=!0;nextDataId(){return eN.nextDataId++}constructor(){super(),this.data=new fa(this,rn())}write(e,t,n){this.firstUse&&(this.firstUse=!1,$().get("IS_NODE")&&C.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:n,refCount:1}),o}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(a=>y.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,o,s){this.data.set(e,{values:t,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return C.mergeRealAndImagArrays(o,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(o=>y.decodeString(o));return Ie(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ie(e.shape,e.dtype,t)}makeOutput(e,t,n){return rn().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=y.now();return e(),{kernelMs:y.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ee([e],"where");let t=this.readSync(e.dataId);return Lre(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},af=eN;K(af,"nextDataId",0);var ff={};qe(ff,{addImpl:()=>nN,bincountImpl:()=>pf,bincountReduceImpl:()=>Tx,castImpl:()=>rN,ceilImpl:()=>oN,concatImpl:()=>Op,equalImpl:()=>sN,expImpl:()=>iN,expm1Impl:()=>lN,floorImpl:()=>pN,gatherNdImpl:()=>xx,gatherV2Impl:()=>Ix,greaterEqualImpl:()=>cN,greaterImpl:()=>mN,lessEqualImpl:()=>fN,lessImpl:()=>dN,linSpaceImpl:()=>Cx,logImpl:()=>hN,maxImpl:()=>kx,maximumImpl:()=>gN,minimumImpl:()=>bN,multiplyImpl:()=>og,negImpl:()=>yN,notEqualImpl:()=>TN,prodImpl:()=>xN,raggedGatherImpl:()=>Sx,raggedRangeImpl:()=>vx,raggedTensorToTensorImpl:()=>Ax,rangeImpl:()=>Gp,rsqrtImpl:()=>IN,scatterImpl:()=>Su,sigmoidImpl:()=>wL,simpleAbsImpl:()=>tN,sliceImpl:()=>Wp,sparseFillEmptyRowsImpl:()=>wx,sparseReshapeImpl:()=>Nx,sparseSegmentReductionImpl:()=>df,sqrtImpl:()=>_L,squaredDifferenceImpl:()=>kN,stridedSliceImpl:()=>Dx,stringNGramsImpl:()=>Up,stringSplitImpl:()=>Kp,stringToHashBucketFastImpl:()=>Vp,subImpl:()=>vN,tileImpl:()=>_x,topKImpl:()=>Mx,transposeImpl:()=>mf,uniqueImpl:()=>Rx});function tN(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}var $re=r=>{let{x:e}=r.inputs,t=r.backend;ee(e,"abs");let n=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId).values;return n=tN(o),t.makeOutput(n,e.shape,e.dtype)},JF={kernelName:Ts,backendName:"cpu",kernelFunc:$re};function ot(r){return(e,t,n,o,s)=>{let a=C.assertAndGetBroadcastShape(e,t),i=a.length,u=y.computeStrides(a),l=y.sizeFromShape(a),p=y.getTypedArrayFromDType(s,l),m=e.length,c=t.length,d=y.computeStrides(e),f=y.computeStrides(t),h=C.getBroadcastDims(e,a),g=C.getBroadcastDims(t,a);if(h.length+g.length===0)for(let b=0;b<p.length;++b)p[b]=r(n[b%n.length],o[b%o.length]);else for(let b=0;b<p.length;++b){let T=y.indexToLoc(b,i,u),x=T.slice(-m);h.forEach(_=>x[_]=0);let I=y.locToIndex(x,m,d),k=T.slice(-c);g.forEach(_=>k[_]=0);let w=y.locToIndex(k,c,f);p[b]=r(n[I],o[w])}return[p,a]}}function wr(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,i=t.makeTensorInfo(n.shape,"complex64"),u=t.data.get(i.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",a)},i}var eL={kernelName:zu,backendName:"cpu",kernelFunc:wr};function uf(r,e,t="float32"){if(t==="complex64"){let o=uf(r,e,"float32"),s=uf(r,e,"float32");return wr({inputs:{real:o,imag:s},backend:r})}let n=y.makeZerosTypedArray(y.sizeFromShape(e),t);return r.makeTensorInfo(e,t,n)}function Jr(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var tL={kernelName:Vn,backendName:"cpu",kernelFunc:Jr};function na(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var rL={kernelName:Xu,backendName:"cpu",kernelFunc:na};function rN(r,e,t,n){if(n==="int32"){let o=Int32Array.from(r);return[e,"int32",o]}if(n==="bool"){let o=y.toTypedArray([0],t),[s,a]=ot((i,u)=>i!==u?1:0)(e,[],r,o,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${n}`)}function oa(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Jr({inputs:{x:o},backend:t});let p=uf(t,o.shape,o.dtype),m=oa({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),c=wr({inputs:{real:m,imag:p},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),c}if(o.dtype==="complex64"){let p=na({inputs:{input:o},backend:t}),m=oa({inputs:{x:p},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(p),m}if(!y.hasEncodingLoss(o.dtype,s)){let p=Jr({inputs:{x:o},backend:t});return{dataId:p.dataId,shape:p.shape,dtype:s}}let a=t.data.get(o.dataId).values,[i,u,l]=rN(a,o.shape,o.dtype,s);return t.makeTensorInfo(i,u,l)}var nL={kernelName:Un,backendName:"cpu",kernelFunc:oa};function pt(r,e,t,n){return t==null?({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;ee([a,i],r);let l=u.data.get(a.dataId).values,p=u.data.get(i.dataId).values,m=a.dtype==="string"?C.fromUint8ToStringArray(l):l,c=a.dtype==="string"?C.fromUint8ToStringArray(p):p,d=n||a.dtype,[f,h]=e(a.shape,i.shape,m,c,d);return u.makeTensorInfo(h,d,f)}:({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(a.dtype==="complex64"||i.dtype==="complex64"){let l=oa({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(l.dataId),m=p.complexTensorInfos.real,c=p.complexTensorInfos.imag,d=u.data.get(m.dataId).values,f=u.data.get(c.dataId).values,h=oa({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),b=g.complexTensorInfos.real,T=g.complexTensorInfos.imag,x=u.data.get(b.dataId).values,I=u.data.get(T.dataId).values,[k,w,_]=t(a.shape,i.shape,d,f,x,I),M=u.makeTensorInfo(_,"float32",k),R=u.makeTensorInfo(_,"float32",w),E=wr({inputs:{real:M,imag:R},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(M),u.disposeIntermediateTensorInfo(R),E}else{let l=u.data.get(a.dataId).values,p=u.data.get(i.dataId).values,m=n||a.dtype,[c,d]=e(a.shape,i.shape,l,p,m);return u.makeTensorInfo(d,m,c)}}}function lf(r){return(e,t,n,o,s,a)=>{let i=C.assertAndGetBroadcastShape(e,t),u=y.sizeFromShape(i),l=i.length,p=y.computeStrides(i),m=y.getTypedArrayFromDType("float32",u),c=y.getTypedArrayFromDType("float32",u),d=C.getBroadcastDims(e,i),f=C.getBroadcastDims(t,i),h=C.mergeRealAndImagArrays(n,o),g=C.mergeRealAndImagArrays(s,a),b=e.length,T=y.computeStrides(e),x=t.length,I=y.computeStrides(t);if(d.length+f.length===0)for(let k=0;k<m.length;k++){let w=k%h.length,_=k%g.length,M=r(h[w*2],h[w*2+1],g[_*2],g[_*2+1]);m[k]=M.real,c[k]=M.imag}else for(let k=0;k<m.length;k++){let w=y.indexToLoc(k,l,p),_=w.slice(-b);d.forEach(G=>_[G]=0);let M=y.locToIndex(_,b,T),R=w.slice(-x);f.forEach(G=>R[G]=0);let E=y.locToIndex(R,x,I),O=r(h[M*2],h[M*2+1],g[E*2],g[E*2+1]);m[k]=O.real,c[k]=O.imag}return[m,c,i]}}var nN=ot((r,e)=>r+e),Bre=lf((r,e,t,n)=>({real:r+t,imag:e+n})),Gi=pt(Nn,nN,Bre),oL={kernelName:Nn,backendName:"cpu",kernelFunc:Gi};function pf(r,e,t,n,o){let s=y.sizeFromShape(n),a=y.makeZerosTypedArray(o,t);for(let i=0;i<r.length;i++){let u=r[i];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?a[u]+=e[i]:a[u]+=1)}return a}function Tx(r,e,t,n=!1){let o=r.shape[0],s=r.shape[1],a=Ie([o,t],e.dtype);for(let i=0;i<o;i++)for(let u=0;u<s;u++){let l=r.get(i,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(n?a.set(1,i,l):e.size>0?a.set(a.get(i,l)+e.get(i,u),i,l):a.set(a.get(i,l)+1,i,l))}return a}function vn(r){return(e,t,n)=>{let o=y.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=r(e[s],n);return o}}function Pe(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(ee(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,l=y.sizeFromShape(a.shape),p=t||a.dtype,m=y.getArrayFromDType(p,l);for(let c=0;c<l;++c)m[c]=e(u[c],o);return i.makeTensorInfo(a.shape,p,m)}}function sa(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(ee(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,l=t||a.dtype,p=e(u,l,o);return i.makeTensorInfo(a.shape,l,p)}}var oN=vn(r=>Math.ceil(r)),Ore=sa(bo,oN),sL={kernelName:bo,backendName:"cpu",kernelFunc:Ore};function Op(r,e,t,n){let o=y.getArrayFromDType(t,y.sizeFromShape(e));if(n&&t!=="string"){let s=0;r.forEach(a=>{let i=y.sizeFromShape(a.shape);o.set(a.vals,s),s+=i})}else{let s=0;r.forEach(a=>{let i=t==="string"?C.fromUint8ToStringArray(a.vals):a.vals,u=0;for(let l=0;l<a.shape[0];++l){let p=l*e[1]+s;for(let m=0;m<a.shape[1];++m)o[p+m]=i[u++]}s+=a.shape[1]})}return o}var sN=ot((r,e)=>r===e?1:0),aN=pt(_a,sN,null,"bool"),aL={kernelName:_a,backendName:"cpu",kernelFunc:aN};var iN=vn(r=>Math.exp(r)),uN=sa(Ao,iN,"float32"),iL={kernelName:Ao,backendName:"cpu",kernelFunc:uN};var lN=vn(r=>Math.expm1(r)),zre=sa(Ma,lN),uL={kernelName:Ma,backendName:"cpu",kernelFunc:zre};var pN=vn(r=>Math.floor(r)),Gre=sa(wo,pN),lL={kernelName:wo,backendName:"cpu",kernelFunc:Gre};function xx(r,e,t,n,o,s,a,i,u){let l=Ie([n,s],t);for(let p=0;p<n;p++){let m=[],c=0;for(let d=0;d<o;d++){let f=r[p*o+d];c+=f*a[d],m.push(f)}if(c<0||c>=u/s)throw new Error(`Invalid indices: ${m} does not index into ${i}`);for(let d=0;d<s;d++)l.values[p*s+d]=e.get(...e.indexToLoc(c*s+d))}return l}function Ix(r,e,t){let n=Ie(t,r.dtype);for(let o=0;o<n.size;++o){let a=n.indexToLoc(o).slice(),i=a[0],u=a[2],l=e.locToIndex([i,u]);a[2]=e.values[l];let p=r.locToIndex(a);0<=p&&p<r.values.length&&(n.values[o]=r.values[p])}return n}var mN=ot((r,e)=>r>e?1:0),Wre=pt(Ea,mN,null,"bool"),pL={kernelName:Ea,backendName:"cpu",kernelFunc:Wre};var cN=ot((r,e)=>r>=e?1:0),Ure=pt(_o,cN,null,"bool"),mL={kernelName:_o,backendName:"cpu",kernelFunc:Ure};var dN=ot((r,e)=>r<e?1:0),Kre=pt($a,dN,null,"bool"),cL={kernelName:$a,backendName:"cpu",kernelFunc:Kre};var fN=ot((r,e)=>r<=e?1:0),Vre=pt(Ba,fN,null,"bool"),dL={kernelName:Ba,backendName:"cpu",kernelFunc:Vre};function Cx(r,e,t){let n=(e-r)/(t-1),o=y.makeZerosTypedArray(t,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var hN=vn(r=>Math.log(r)),Hre=sa(Po,hN),fL={kernelName:Po,backendName:"cpu",kernelFunc:Hre};function kx(r,e,t,n){let o=y.getTypedArrayFromDType(n,y.sizeFromShape(t));for(let s=0;s<o.length;++s){let a=s*e,i=r[a];for(let u=0;u<e;++u){let l=r[a+u];(Number.isNaN(l)||l>i)&&(i=l)}o[s]=i}return o}var gN=ot((r,e)=>Math.max(r,e)),qre=pt(Fo,gN),hL={kernelName:Fo,backendName:"cpu",kernelFunc:qre};var bN=ot((r,e)=>Math.min(r,e)),jre=pt(Oo,bN),gL={kernelName:Oo,backendName:"cpu",kernelFunc:jre};var og=ot((r,e)=>r*e),Xre=lf((r,e,t,n)=>({real:r*t-e*n,imag:r*n+e*t})),zp=pt(Go,og,Xre),bL={kernelName:Go,backendName:"cpu",kernelFunc:zp};function yN(r,e,t){let n=y.createScalarValue(-1,t);return og([],e,n,r,t)}function Yre(r){let{inputs:e,backend:t}=r,{x:n}=e;ee(n,"neg");let o=t.data.get(n.dataId).values,[s,a]=yN(o,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,s)}var yL={kernelName:Ss,backendName:"cpu",kernelFunc:Yre};var TN=ot((r,e)=>r!==e?1:0),Zre=pt(Wa,TN,null,"bool"),TL={kernelName:Wa,backendName:"cpu",kernelFunc:Zre};function mf(r,e,t,n,o){let s=e.length,a=y.sizeFromShape(e),i=y.computeStrides(e),u=y.computeStrides(o),l=y.getTypedArrayFromDType(t,y.sizeFromShape(o));for(let p=0;p<a;++p){let m=y.indexToLoc(p,s,i),c=new Array(m.length);for(let f=0;f<c.length;f++)c[f]=m[n[f]];let d=y.locToIndex(c,s,u);l[d]=r[p]}return l}function qt(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{perm:s}=t;ee(o,"transpose");let a=o.shape.length,i=new Array(a);for(let m=0;m<i.length;m++)i[m]=o.shape[s[m]];let u=n.data.get(o.dataId).values,l=mf(u,o.shape,o.dtype,s,i);return{dataId:n.write(l,i,o.dtype),shape:i,dtype:o.dtype}}var xL={kernelName:_n,backendName:"cpu",kernelFunc:qt};function xN(r,e,t,n){let[o,s]=C.computeOutAndReduceShapes(r,n),a=Pt(e,"int32"),i=y.makeZerosTypedArray(y.sizeFromShape(o),a),u=y.sizeFromShape(s);for(let l=0;l<i.length;++l){let p=l*u,m=1;for(let c=0;c<u;++c)m*=t[p+c];i[l]=m}return{outVals:i,outShape:o,outDtype:a}}function Qre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"prod");let i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=C.getAxesPermutation(u,i),p=u,m=o,c=[];l!=null&&(m=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),c.push(m),p=C.getInnerMostAxes(p.length,i));let d=t.data.get(m.dataId).values,{outVals:f,outShape:h,outDtype:g}=xN(m.shape,m.dtype,d,p),b=h;return a&&(b=C.expandShapeToKeepDim(h,u)),c.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.makeTensorInfo(b,g,f)}var IL={kernelName:Ho,backendName:"cpu",kernelFunc:Qre};function Jre(r,e,t){r.forEach((n,o)=>{if(n<0||n>=t){let s=y.indexToLoc(o,e.length,y.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${n} is not in [0, ${t})`)}})}function ene(r,e){for(let t=0;t<r.length;++t){let n=r[t],o=t===r.length-1?e:r[t+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<n.length;++s)if(n[s-1]>n[s])throw new Error("Ragged splits must be sorted in ascending order")}}function tne(r,e,t,n){let o=[],s=0,a=e.length-1+t.length,i=new Array(a).fill(null).map(()=>[0]);ene(t,n);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];let p=e[l+1];for(let m=1;m<u+1;++m)i[l].push(m*p)}for(let l=0;l<r.length;++l){let p=r[l],m=r[l]+1;for(let c=0;c<t.length;++c){let d=t[c],f=c+e.length-1;if(f>=0){let h=i[f],g=h[h.length-1]-d[p];for(let b=p;b<m;++b)i[f].push(d[b+1]+g)}p=d[p],m=d[m]}m!==p&&(o.push([p,m]),s+=m-p)}return{outSplits:i,valueSlices:o,numValues:s}}function rne(r){let e=[];for(let t=0;t<r.length;++t){let n=r[t].length,o=y.getArrayFromDType("int32",n);e.push(o),r[t].forEach((s,a)=>o[a]=s)}return e}function CL(r,e){let t=r.slice(0,e);for(;t.length<e;)t.push(1);for(let n=e;n<r.length;n++)t[e-1]*=r[n];return t}function nne(r,e,t,n,o,s){let a=CL(e,2)[1],i=CL(s,2)[1],u=0;for(let l of t)for(let p=l[0];p<l[1];++p){for(let m=0;m<n;++m)o[u*i+m]=r[p*a+m];++u}}function one(r,e,t,n,o){let s=e.slice();s[0]=o;let a=y.getArrayFromDType(t,y.sizeFromShape(s)),i=r.length,u=i===0?0:i/e[0];return nne(r,e,n,u,a,s),[a,s]}function Sx(r,e,t,n,o,s,a,i){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");let u=e[0][0]-1;if(Jre(s,a,u),n.length===0)throw new Error("params.rank must be nonzero");let l=n[0],{outSplits:p,valueSlices:m,numValues:c}=tne(s,a,r,l),d=rne(p),f=one(t,n,o,m,c);return[d,f[0],f[1]]}var kL=2147483647;function vx(r,e,t,n,o,s,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");let i=e.length===0,u=o.length===0,l=a.length===0,p=[];i||p.push(e[0]),u||p.push(o[0]),l||p.push(a[0]);for(let g=1;g<p.length;++g)if(p[g]!==p[g-1])throw new Error("starts, limits, and deltas must have the same shape");let m=p.length===0?1:p[0],c=y.getArrayFromDType("int32",m+1);c[0]=0;for(let g=0;g<m;++g){let b=i?r[0]:r[g],T=u?n[0]:n[g],x=l?s[0]:s[g];if(x===0)throw new Error("Requires delta != 0");let I;if(x>0&&T<b||x<0&&T>b)I=0;else if(I=Math.ceil(Math.abs((T-b)/x)),I>kL)throw new Error(`Requires ((limit - start) / delta) <= ${kL}`);c[g+1]=c[g]+I}let d=c[m],f=y.getArrayFromDType(t,d),h=0;for(let g=0;g<m;++g){let b=c[g+1]-c[g],T=i?r[0]:r[g],x=l?s[0]:s[g];for(let I=0;I<b;++I)f[h++]=T,T+=x}return[c,f]}var aa=C.RowPartitionType,cf=class{constructor(e,t,n,o,s,a,i,u,l,p){this.shape=e;this.shapeShape=t;this.values=n;this.valuesShape=o;this.valuesDType=s;this.defaultValue=a;this.defaultValueShape=i;this.rowPartitionValues=u;this.rowPartitionValuesShapes=l;this.rowPartitionTypes=C.getRowPartitionTypesHelper(p),this.raggedRank=C.getRaggedRank(this.rowPartitionTypes)}rowPartitionTypes;raggedRank;getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===aa.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===aa.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case aa.VALUE_ROWIDS:return cf.getMaxWidthValueRowID(t);case aa.ROW_SPLITS:return cf.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${aa[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let n=0;for(let o=0;o<t-1;++o){let s=e[o+1]-e[o];s>n&&(n=s)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let n=0,o=e[0],s=0;for(let a=1;a<t;++a){let i=e[a];i!==o&&(o=i,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return vL(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;C.validateDefaultValueShape(n,t);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=C.combineRaggedTensorToTensorShapes(this.raggedRank,o,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,n){let o=Math.min(e,n),s=[],a=0;for(let i=0;i<o;++i,a+=t)s.push(a);for(let i=o;i<e;++i)s.push(-1);return y.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,o){let s=e.length,a=[];for(let i=0;i<s-1;++i){let u=e[i+1]-e[i],l=Math.min(o,u),p=t[i];p===-1&&(l=0);for(let m=0;m<l;++m)a.push(p),p+=n;for(let m=0;m<u-l;++m)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,o){let s=e.length,a=[];if(s===0)return[];let i=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let l=t[u];a.push(l);for(let p=1;p<s;++p){let m=e[p];if(m===u)l>=0&&(++i,i<o?l+=n:l=-1);else{if(i=0,u=m,m>=t.length)throw new Error(`Got nextValueRowId=${m} which is not less than ${t.length}`);l=t[m]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,o){let s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case aa.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,o);case aa.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,o);default:throw new Error(`Unsupported partition type: ${aa[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case aa.FIRST_DIM_SIZE:return e[0];case aa.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case aa.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${aa[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let u=o.length-2;u>=0;--u)o[u]=o[u+1]*n[u+1];let s=vL(n,!1),a=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(o[0]*n[0]>0){let u=this.calculateFirstParentOutputIndex(t,o[0],n[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,o[l],n[l]);this.setOutput(this.raggedRank,u,a,s)}return[s,a]}setOutput(e,t,n,o){if(n.length===0)return;let s=this.values,a=n,i=o.slice();i=i.slice(e+1);let u=y.sizeFromShape(i),l=t.length,p=this.defaultValue;if(p.length!==u&&p.length!==1){let f=this.defaultValueShape;z(()=>{let h=F(p,f);p=dl(h,i).dataSync()})}let m=0,c=0,d=0;for(let f=0;f<=l;++f){let h=f<l?t[f]:-1;if(h===d){++d;continue}if(c<d){let g=s.subarray(m*u),b=a.subarray(c*u),T=(d-c)*u;SL(b,g,T)}if(f>=l){let g=n.length;h=Math.floor(g/u)}if(h>d)if(this.defaultValue.length===1)a.subarray(d*u,h*u).fill(this.defaultValue[0]),d=h;else for(;h>d;){let g=a.slice(d*u);SL(g,p,u),++d}h<0?(m=f+1,c=d):(m=f,c=d,d=c+1)}}};function SL(r,e,t){for(let n=0;n<t;n++)r[n]=e[n]}function vL(r,e){let t=[];for(let n of r){if(n<0){if(!e)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}t.push(n)}return t}function Ax(r,e,t,n,o,s,a,i,u,l){return new cf(r,e,t,n,o,s,a,i,u,l).compute()}function Gp(r,e,t,n){let o=r===e,s=r<e&&t<0,a=e<r&&t>1;if(o||s||a)return y.makeZerosTypedArray(0,n);let i=Math.abs(Math.ceil((e-r)/t)),u=y.makeZerosTypedArray(i,n);e<r&&t===1&&(t=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}var IN=vn(r=>1/Math.sqrt(r)),sne=sa(Jo,IN),AL={kernelName:Jo,backendName:"cpu",kernelFunc:sne};function Su(r,e,t,n,o,s,a,i,u,l){let p=[n/o,o],m=r.values,c=e.values;if(n===0)return Ie(t,e.dtype);let d=Ie(p,e.dtype);typeof u=="string"||typeof u=="number"?d.values.fill(u):typeof u=="boolean"&&d.values.fill(+u);for(let f=0;f<s;f++){let h=[],g=0;for(let b=0;b<a;b++){let T=m[f*a+b];h.push(T),g+=T*i[b]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let b=0;b<o;b++)l?d.values[g*o+b]+=c[f*o+b]:d.values[g*o+b]=e.rank===0?c[0]:c[f*o+b]}return d}var wL=vn(r=>1/(1+Math.exp(-r))),CN=Pe(ts,r=>1/(1+Math.exp(-r))),NL={kernelName:ts,backendName:"cpu",kernelFunc:CN};function Wp(r,e,t,n,o){let s=It.isSliceContinous(n,e,t),a=y.sizeFromShape(t),i=y.computeStrides(n);if(s){let m=It.computeFlatOffset(e,i);return o==="string"?r.slice(m,m+a):r.subarray(m,m+a)}let u=o==="string"?C.fromUint8ToStringArray(r):r,l=Ie(n,o,u),p=Ie(t,o);for(let m=0;m<p.size;++m){let c=p.indexToLoc(m),d=c.map((f,h)=>f+e[h]);p.set(l.get(...d),...c)}return o==="string"?C.fromStringArrayToUint8(p.values):p.values}function ia(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n;ee(o,"slice");let[i,u]=It.parseSliceParams(o,s,a);It.assertParamsValid(o,i,u);let l=t.data.get(o.dataId).values,p=Wp(l,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,p)}var DL={kernelName:Ds,backendName:"cpu",kernelFunc:ia};function wx(r,e,t,n,o,s,a){let i=e[0],u=s[0],l=new Array(u),p=new Array(i),m=e[1];if(u===0){if(i!==0)throw new Error(C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));let g=y.getArrayFromDType(t,0),b=y.getArrayFromDType(o,0);return[g,[0,m],b,l,p]}let c=!0,d=0,f=new Array(u).fill(0);for(let g=0;g<i;++g){let b=r[g*m];if(b<0)throw new Error(C.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,b));if(b>=u)throw new Error(C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,b,u));++f[b],c=c&&b>=d,d=b}let h=!0;for(let g=0;g<u;++g){let b=f[g]===0;l[g]=b,h=h&&!b,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(h&&c){let g=r,b=n;for(let T=0;T<i;++T)p[T]=T;return[g,[i,m],b,l,p]}else{let g=f[u-1],b=y.getArrayFromDType(t,g*m),T=y.getArrayFromDType(o,g),x=new Array(u).fill(0);for(let I=0;I<i;++I){let k=r[I*m],w=x[k],_=(k===0?0:f[k-1])+w;x[k]++;for(let M=0;M<m;++M)b[_*m+M]=r[I*m+M];T[_]=n[I],p[I]=_}for(let I=0;I<u;++I)if(x[I]===0){let w=I===0?0:f[I-1];b[w*m+0]=I;for(let _=1;_<m;++_)b[w*m+_]=0;T[w]=a}return[b,[g,m],T,l,p]}}function Nx(r,e,t,n,o){let s=y.sizeFromShape(n),a=e[0],i=o.length,u=[],l=1,p=-1;for(let g=0;g<i;++g){let b=o[g];if(b===-1){if(p!==-1)throw new Error(C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,g));p=g,u.push(1)}else{if(b<0)throw new Error(C.getSparseReshapeNegativeOutputDimErrorMessage(g,b));l*=b,u.push(b)}}if(p!==-1){if(l<=0)throw new Error(C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(C.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[p]=g}if(y.sizeFromShape(u)!==s)throw new Error(C.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let c=n.length,d=[];if(c>0){d[c-1]=1;for(let g=c-2;g>=0;--g)d[g]=d[g+1]*n[g+1]}let f=[];if(i>0){f[i-1]=1;for(let g=i-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}let h=y.getArrayFromDType(t,a*i);for(let g=0;g<a;++g){let b=0;for(let T=0;T<c;++T)b+=r[g*c+T]*d[T];for(let T=0;T<i;++T)h[g*i+T]=Math.trunc(b/f[T]),b%=f[T]}return[h,[a,i],u]}function df(r,e,t,n,o,s=!1,a=0){let i=n.length,u=[e[0],r.length/e[0]],l=u[1],m=i>0?o[i-1]+1:0;if(m<0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=e.slice();c[0]=m;let d=c.reduce((x,I)=>x*I,1),f=y.getArrayFromDType(t,d);if(i===0)return m>0&&f.fill(a),[f,c];if(m<=0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,b=0,T=o[h];for(;;){let x=0;if(g<i){if(x=o[g],T===x){++g;continue}if(T>=x)throw new Error(C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(T<0||T>=m)throw new Error(C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(T,m));T>b&&f.fill(a,b*l,T*l);for(let I=h;I<g;++I){let k=n[I];if(k<0||k>=u[0])throw new Error(C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,n[I],u[0]));for(let w=0;w<l;w++)f[T*l+w]+=r[k*l+w]}if(s)for(let I=0;I<l;I++)f[T*l+I]/=g-h;if(h=g,++g,b=T+1,T=x,g>i)break}return b<m&&f.fill(a,b*l,m*l),[f,c]}var _L=vn(r=>Math.sqrt(r)),ane=Pe(rs,r=>Math.sqrt(r)),ML={kernelName:rs,backendName:"cpu",kernelFunc:ane};var kN=ot((r,e)=>{let t=r-e;return t*t}),ine=pt(ss,kN),RL={kernelName:ss,backendName:"cpu",kernelFunc:ine};function Dx(r,e,t,n){let o=Ie(r,e.dtype);for(let s=0;s<o.size;s++){let a=o.indexToLoc(s),i=new Array(a.length);for(let u=0;u<i.length;u++)i[u]=a[u]*t[u]+n[u];o.set(e.get(...i),...a)}return o}var SN=class{separator;nGramWidths;padWidth;leftPad;rightPad;preserveShort;constructor(e,t,n,o,s,a){this.separator=y.encodeString(e),this.nGramWidths=t,this.leftPad=y.encodeString(n),this.rightPad=y.encodeString(o),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,o,s,a){for(let i=0;i<s;++i){let u=this.getPadWidth(a),l=Math.max(0,u-i),p=Math.max(0,u-(s-(i+1))),m=a-(l+p),c=t+(l>0?0:i-u),d=0;d+=l*this.leftPad.length;for(let T=0;T<m;++T)d+=e[c+T].length;d+=p*this.rightPad.length,d+=(l+p+m-1)*this.separator.length,n[o+i]=new Uint8Array(d);let h=n[o+i],g=0,b=T=>T.forEach(x=>h[g++]=x);for(let T=0;T<l;++T)b(this.leftPad),b(this.separator);for(let T=0;T<m-1;++T)b(e[c+T]),b(this.separator);if(m>0){b(e[c+m-1]);for(let T=0;T<p;++T)b(this.separator),b(this.rightPad)}else{for(let T=0;T<p-1;++T)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){let n=e.length,o=t.length;if(o>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let p=t[l]>=u;if(p=p&&t[l]<=n,!p)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${n}]`);u=t[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,a=y.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)a[l]=0;return[u,a]}a[0]=0;for(let u=1;u<=s;++u){let l=t[u]-t[u-1],p=0;this.nGramWidths.forEach(m=>{p+=this.getNumNGrams(l,m)}),this.preserveShort&&l>0&&p===0&&(p=1),a[u]=a[u-1]+p}let i=new Array(a[s]);for(let u=0;u<s;++u){let l=t[u],p=a[u];if(this.nGramWidths.forEach(m=>{let c=t[u+1]-t[u],d=this.getNumNGrams(c,m);this.createNGrams(e,l,i,p,d,m),p+=d}),this.preserveShort&&p===a[u]){let m=t[u+1]-t[u];if(m===0)continue;let c=m+2*this.padWidth,d=1;this.createNGrams(e,l,i,p,d,c)}}return[i,a]}};function Up(r,e,t,n,o,s,a,i){return new SN(t,n,o,s,a,i).compute(r,e)}function une(r,e,t,n){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(e.length===1){let s=e[0],a=r.indexOf(s);for(;a!==-1;){let i=r.subarray(0,a);(!t||i.length!==0)&&n.push(i),r=r.subarray(a+1),a=r.indexOf(s)}(!t||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){let a=r.subarray(o,s);(!t||a.length!==0)&&n.push(a),o=s+1}}function Kp(r,e,t){let n=r.length,o=[],s=0,a=0,i=new Array(n);for(let c=0;c<n;++c){let d=o.length;une(r[c],e,t,o);let f=o.length-d;i[c]=f,s+=f,a=Math.max(a,f)}let u=y.getArrayFromDType("int32",s*2),l=new Array(s),p=[n,a],m=0;for(let c=0;c<n;++c)for(let d=0;d<i[c];++d)u[m*2]=c,u[m*2+1]=d,l[m]=o[m],++m;return[u,l,p]}function Vp(r,e){let t=y.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)t[n]=y.fingerPrint64(r[n]).modulo(e).getLowBitsUnsigned();return t}var vN=ot((r,e)=>r-e),lne=lf((r,e,t,n)=>({real:r-t,imag:e-n})),sg=pt(as,vN,lne),PL={kernelName:as,backendName:"cpu",kernelFunc:sg};function _x(r,e){let t=new Array(r.rank);for(let o=0;o<t.length;o++)t[o]=r.shape[o]*e[o];let n=Ie(t,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),a=new Array(r.rank);for(let u=0;u<a.length;u++)a[u]=s[u]%r.shape[u];let i=r.locToIndex(a);n.values[o]=r.values[i]}return n}var ag=(r,e)=>{let t=e.value-r.value;return t===0?r.index-e.index:t};function EL(r,e,t=0,n=r.length-1){for(;n>t;){if(n-t>600){let i=n-t+1,u=e-t+1,l=Math.log(i),p=.5*Math.exp(2*l/3),m=.5*Math.sqrt(l*p*(i-p)/i)*Math.sign(u-i/2),c=Math.max(t,Math.floor(e-u*p/i+m)),d=Math.min(n,Math.floor(e+(i-u)*p/i+m));EL(r,e,c,d)}let o=r[e],s=t,a=n;for(y.swap(r,t,e),ag(r[n],o)>0&&y.swap(r,t,n);s<a;){for(y.swap(r,s,a),s++,a--;ag(r[s],o)<0;)s=s+1;for(;ag(r[a],o)>0;)a=a-1}ag(r[t],o)===0?y.swap(r,t,a):(a=a+1,y.swap(r,a,n)),a<=e&&(t=a+1),e<=a&&(n=a-1)}}function Mx(r,e,t,n,o){let s=e[e.length-1],[a,i]=[r.length/s,s],u=y.getTypedArrayFromDType(t,a*n),l=y.getTypedArrayFromDType("int32",a*n);for(let m=0;m<a;m++){let c=m*i,d=r.subarray(c,c+i),f=new Array(d.length);d.forEach((T,x)=>f[x]={value:T,index:x}),n<f.length&&(EL(f,n),f=f.slice(0,n)),o&&f.sort(ag);let h=m*n,g=u.subarray(h,h+n),b=l.subarray(h,h+n);for(let T=0;T<n;T++)g[T]=f[T].value,b[T]=f[T].index}let p=e.slice();return p[p.length-1]=n,[Ie(p,t,u),Ie(p,"int32",l)]}function Rx(r,e,t,n){let o=y.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let f=0;f<o;f++)s[0]*=t[f];s[1]=t[o];for(let f=o+1;f<t.length;f++)s[2]*=t[f];let a={},i=new Int32Array(t[o]),u=new bt(s,n,r),l=[],p=s[0]===1&&s[2]===1;for(let f=0;f<t[o];f++){let h;if(p)h=r[f].toString();else{let g=[];for(let b=0;b<s[0];b++)for(let T=0;T<s[2];T++)g.push(u.get(b,f,T));h=g.join(",")}if(a[h]!==void 0)i[f]=a[h];else{let g=Object.keys(a).length;a[h]=g,i[f]=g,l.push(f)}}let m=s.slice();m[1]=Object.keys(a).length;let c=new bt(m,n);l.forEach((f,h)=>{for(let g=0;g<s[0];g++)for(let b=0;b<s[2];b++)c.set(u.get(g,f,b),g,h,b)});let d=t.slice();return d[o]=m[1],{outputValues:c.values,outputShape:d,indices:i}}var pne="0.0.0";ul("cpu",()=>new af,1);var AN=Pe(vo,r=>r>=0?r:Math.exp(r)-1),FL={kernelName:vo,backendName:"cpu",kernelFunc:AN};function wN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n;ee([o],"leakyRelu");let a=y.sizeFromShape(o.shape),i=t.data.get(o.dataId).values,u=y.getTypedArrayFromDType("float32",a);for(let l=0;l<i.length;l++)u[l]=i[l]<0?s*i[l]:i[l];return t.makeTensorInfo(o.shape,"float32",u)}var LL={kernelName:Ro,backendName:"cpu",kernelFunc:wN};var mne=ot((r,e)=>r<0?e*r:r);function NN(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e;ee([n,o],"prelu");let s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,[i,u]=mne(n.shape,o.shape,s,a,"float32");return t.makeTensorInfo(u,"float32",i)}var $L={kernelName:Vo,backendName:"cpu",kernelFunc:NN};var DN=Pe(jo,r=>Math.max(0,r)),BL={kernelName:jo,backendName:"cpu",kernelFunc:DN};var _N=Pe(Zo,r=>Math.min(Math.max(0,r),6)),OL={kernelName:Zo,backendName:"cpu",kernelFunc:_N};function Hp(r,e,t,n,o){if(t==="linear")return Jr({inputs:{x:e},backend:r});if(t==="relu")return DN({inputs:{x:e},backend:r});if(t==="elu")return AN({inputs:{x:e},backend:r});if(t==="relu6")return _N({inputs:{x:e},backend:r});if(t==="prelu")return NN({inputs:{x:e,alpha:n},backend:r});if(t==="leakyrelu")return wN({inputs:{x:e},backend:r,attrs:{alpha:o}});if(t==="sigmoid")return CN({inputs:{x:e},backend:r});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function rt(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=y.sizeFromShape(o.shape),i=y.inferFromImplicitShape(s,a),u=y.sizeFromShape(i);y.assert(a===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let l=t.data.get(o.dataId);if(l.complexTensorInfos!=null){let p=l.complexTensorInfos.real,m=l.complexTensorInfos.imag;p.shape=i,m.shape=i}return{dataId:o.dataId,shape:i,dtype:o.dtype}}var zL={kernelName:ws,backendName:"cpu",kernelFunc:rt};function MN(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;ee([o,s],"matMul");let u=o.shape.length,l=s.shape.length,p=a?o.shape[u-2]:o.shape[u-1],m=i?s.shape[l-1]:s.shape[l-2],c=a?o.shape[u-1]:o.shape[u-2],d=i?s.shape[l-2]:s.shape[l-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(f),b=y.sizeFromShape(h),x=Dr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,d]);y.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,p,c]:[g,c,p],k=i?[b,d,m]:[b,m,d],w=rt({inputs:{x:o},backend:t,attrs:{shape:I}}),_=rt({inputs:{x:s},backend:t,attrs:{shape:k}}),M=a?w.shape[1]:w.shape[2],R=a?w.shape[2]:w.shape[1],E=i?_.shape[1]:_.shape[2],O=Math.max(g,b),G=t.data.get(w.dataId).values,W=t.data.get(_.dataId).values,H=y.computeStrides(w.shape),U=y.computeStrides(_.shape),[V,Y,j]=a?[H[0],1,H[1]]:[H[0],H[1],1],[te,ne,oe]=i?[1,U[1],U[0]]:[U[1],1,U[0]],ae=R*E,se=Ie([O,R,E],w.dtype),ie=se.values,he=t.blockSize;for(let ye=0;ye<O;ye++)for(let ve=0;ve<R;ve+=he)for(let Fe=0;Fe<E;Fe+=he)for(let $e=0;$e<M;$e+=he){let je=Math.min(ve+he,R),J=Math.min(Fe+he,E),gt=Math.min($e+he,M);for(let St=ve;St<je;St++)for(let Je=Fe;Je<J;Je++){let Rt=0;for(let Tt=$e;Tt<gt;Tt++){let $t=Math.min(ye,g-1)*V,Xt=Math.min(ye,b-1)*oe,On=G[$t+St*Y+Tt*j],dr=W[Tt*te+Je*ne+Xt];Rt+=On*dr}ie[ye*ae+(St*E+Je)]+=Rt}}return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(x,se.dtype,se.values)}var GL={kernelName:go,backendName:"cpu",kernelFunc:MN};function cne(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n,c,d,f,h=[];c=MN({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:t}),a&&(d=Gi({inputs:{a:c,b:a},backend:t}),h.push(c),c=d),p&&(f=Hp(t,c,p,i,m),h.push(c),c=f);for(let b of h)t.disposeIntermediateTensorInfo(b);return c}var WL={kernelName:Fs,backendName:"cpu",kernelFunc:cne};var dne=Pe(ba,r=>Math.acos(r)),UL={kernelName:ba,backendName:"cpu",kernelFunc:dne};var fne=Pe(ya,r=>Math.acosh(r)),KL={kernelName:ya,backendName:"cpu",kernelFunc:fne};function hne(r){let{inputs:e,backend:t}=r,n=e;ee(e,"addN");let o=n.map(i=>t.data.get(i.dataId).values),s=Ie(n[0].shape,n[0].dtype),a=s.values;for(let i=0;i<n.length;i++){let u=o[i];for(let l=0;l<a.length;l++)a[l]+=u[l]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var VL={kernelName:co,backendName:"cpu",kernelFunc:hne};function gne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"all");let i=y.parseAxisParam(s,o.shape),u=i,l=C.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("all",u,p.shape.length);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),p.dtype),h=t.data.get(p.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let k=h[T+I];x=x&&k}f[b]=x}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(m,p.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=rt({inputs:{x:g},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(g),T}return g}var HL={kernelName:Ta,backendName:"cpu",kernelFunc:gne};function bne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"any");let i=y.parseAxisParam(s,o.shape),u=i,l=C.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("any",u,p.shape.length);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),p.dtype),h=t.data.get(p.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let k=h[T+I];x=x||k}f[b]=x}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(m,p.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=rt({inputs:{x:g},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(g),T}return g}var qL={kernelName:xa,backendName:"cpu",kernelFunc:bne};function yne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;ee(o,"argMax");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=qt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMax",a,u.shape.length);let[p,m]=C.computeOutAndReduceShapes(u.shape,a),c=y.sizeFromShape(p),d=y.makeZerosTypedArray(c,"int32"),f=y.sizeFromShape(m),h=t.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let b=g*f,T=h[b],x=0;for(let I=0;I<f;++I){let k=h[b+I];k>T&&(T=k,x=I)}d[g]=x}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",d)}var jL={kernelName:fo,backendName:"cpu",kernelFunc:yne};function Tne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;ee(o,"argMin");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=qt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMin",a,u.shape.length);let[p,m]=C.computeOutAndReduceShapes(u.shape,a),c=y.sizeFromShape(p),d=y.makeZerosTypedArray(c,"int32"),f=y.sizeFromShape(m),h=t.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let b=g*f,T=h[b],x=0;for(let I=0;I<f;++I){let k=h[b+I];k<T&&(T=k,x=I)}d[g]=x}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",d)}var XL={kernelName:Si,backendName:"cpu",kernelFunc:Tne};var xne=Pe(Ia,r=>Math.asin(r)),YL={kernelName:Ia,backendName:"cpu",kernelFunc:xne};var Ine=Pe(Ca,r=>Math.asinh(r)),ZL={kernelName:Ca,backendName:"cpu",kernelFunc:Ine};var Cne=Pe(ka,r=>Math.atan(r)),QL={kernelName:ka,backendName:"cpu",kernelFunc:Cne};var kne=ot((r,e)=>Math.atan2(r,e)),Sne=pt(va,kne),JL={kernelName:va,backendName:"cpu",kernelFunc:Sne};var vne=Pe(Sa,r=>Math.atanh(r)),e$={kernelName:Sa,backendName:"cpu",kernelFunc:vne};function hf(r,e,t,n,o,s){let a=o.strideHeight,i=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,p=o.effectiveFilterHeight,m=o.effectiveFilterWidth,c=o.padInfo.top,d=o.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=Ie(o.outShape,t),g=h.values,b=o.outShape[1]*o.outShape[2]*o.outShape[3],T=o.outShape[2]*o.outShape[3],x=o.outShape[3];for(let I=0;I<o.batchSize;++I){let k=I*b,w=I*n[0];for(let _=0;_<o.inChannels;++_)for(let M=0;M<o.outHeight;++M){let R=M*a-c,E=Math.max(0,R),O=Math.min(o.inHeight,p+R),G=k+M*T;for(let W=0;W<o.outWidth;++W){let H=W*i-d,U=Math.max(0,H),V=Math.min(o.inWidth,m+H),Y=f,j=0,te=0;for(let oe=E;oe<O;oe+=u){let ae=w+oe*n[1];for(let se=U;se<V;se+=l){let ie=ae+se*n[2],he=r[ie+_];s==="max"&&he>Y?Y=he:s==="avg"&&(j+=he,te++)}if(isNaN(Y))break}let ne=G+W*x+_;g[ne]=s==="avg"?j/te:Y}}}return h}function Px(r,e,t,n,o=!1,s=!1){let a=Ie(n.outShape,"int32"),i=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,p=n.dilationWidth,m=n.effectiveFilterHeight,c=n.effectiveFilterWidth,d=n.padInfo.top,f=n.padInfo.left,h=Ie(e,t,r);for(let g=0;g<n.batchSize;++g)for(let b=0;b<n.inChannels;++b)for(let T=0;T<n.outHeight;++T){let x=T*i-d,I=x;for(;I<0;)I+=l;let k=Math.min(n.inHeight,m+x);for(let w=0;w<n.outWidth;++w){let _=w*u-f,M=_;for(;M<0;)M+=p;let R=Math.min(n.inWidth,c+_),E=Number.NEGATIVE_INFINITY,O=-1;for(let G=I;G<k;G+=l){let W=G-x;for(let H=M;H<R;H+=p){let U=H-_,V=h.get(g,G,H,b);V>E&&(E=V,o?O=s?((g*n.inHeight+G)*n.inWidth+H)*n.inChannels+b:(G*n.inWidth+H)*n.inChannels+b:O=W*c+U)}}a.set(O,g,T,w,b)}}return a}function Ex(r,e,t,n,o,s){let a=o.strideDepth,i=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,p=o.dilationHeight,m=o.dilationWidth,c=o.effectiveFilterDepth,d=o.effectiveFilterHeight,f=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,b=o.padInfo.left,T=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Ie(o.outShape,t),I=x.values,k=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],w=o.outShape[2]*o.outShape[3]*o.outShape[4],_=o.outShape[3]*o.outShape[4],M=o.outShape[4];for(let R=0;R<o.batchSize;++R){let E=R*k,O=R*n[0];for(let G=0;G<o.inChannels;++G)for(let W=0;W<o.outDepth;++W){let H=W*a-h,U=H;for(;U<0;)U+=l;let V=Math.min(o.inDepth,c+H),Y=E+W*w;for(let j=0;j<o.outHeight;++j){let te=j*i-g,ne=te;for(;ne<0;)ne+=p;let oe=Math.min(o.inHeight,d+te),ae=Y+j*_;for(let se=0;se<o.outWidth;++se){let ie=se*u-b,he=ie;for(;he<0;)he+=m;let ye=Math.min(o.inWidth,f+ie),ve=ae+se*M,Fe=T,$e=0,je=0;for(let gt=U;gt<V;gt+=l){let St=O+gt*n[1];for(let Je=ne;Je<oe;Je+=p){let Rt=St+Je*n[2];for(let Tt=he;Tt<ye;Tt+=m){let $t=Rt+Tt*n[3],Xt=r[$t+G];if(s==="max"&&Xt>Fe?Fe=Xt:s==="avg"&&($e+=Xt,je++),isNaN(Fe))break}if(isNaN(Fe))break}if(isNaN(Fe))break}let J=ve+G;I[J]=s==="avg"?$e/je:Fe}}}}return x}function t$(r,e){let t=Ie(e.outShape,"int32"),n=e.strideDepth,o=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,c=e.padInfo.front,d=e.padInfo.top,f=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let b=0;b<e.outDepth;++b){let T=b*n-c,x=T;for(;x<0;)x+=a;let I=Math.min(e.inDepth,l+T);for(let k=0;k<e.outHeight;++k){let w=k*o-d,_=w;for(;_<0;)_+=i;let M=Math.min(e.inHeight,p+w);for(let R=0;R<e.outWidth;++R){let E=R*s-f,O=E;for(;O<0;)O+=u;let G=Math.min(e.inWidth,m+E),W=Number.NEGATIVE_INFINITY,H=-1;for(let U=x;U<I;U+=a){let V=U-T;for(let Y=_;Y<M;Y+=i){let j=Y-w;for(let te=O;te<G;te+=u){let ne=te-E,oe=r.get(h,U,Y,te,g);oe>=W&&(W=oe,H=V*p*m+j*p+ne)}}}t.set(H,h,b,k,R,g)}}}return t}function Ane(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;ee(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u),m;if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))m=Jr({inputs:{x:o},backend:t});else{let c=t.data.get(o.dataId).values,d=y.computeStrides(o.shape),f=hf(c,o.shape,o.dtype,d,p,"avg");m=t.makeTensorInfo(p.outShape,o.dtype,f.values)}return m}var r$={kernelName:ho,backendName:"cpu",kernelFunc:Ane};function wne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n;ee(o,"avgPool3d");let p=C.computePool3DInfo(o.shape,s,a,1,i,u,l),m=t.data.get(o.dataId).values,c=Ex(m,o.shape,o.dtype,y.computeStrides(o.shape),p,"avg");return t.makeTensorInfo(c.shape,"float32",c.values)}var n$={kernelName:Bu,backendName:"cpu",kernelFunc:wne};function Nne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=n;ee([o,s],"avgPool3DGrad");let p=C.computePool3DInfo(s.shape,a,i,1,u,l),m=p.strideDepth,c=p.strideHeight,d=p.strideWidth,f=p.filterDepth,h=p.filterHeight,g=p.filterWidth,b=p.dilationDepth,T=p.dilationHeight,x=p.dilationWidth,I=p.effectiveFilterDepth,k=p.effectiveFilterHeight,w=p.effectiveFilterWidth,_=I-1-p.padInfo.front,M=w-1-p.padInfo.left,R=k-1-p.padInfo.top,E=Ie(s.shape,"float32"),O=1/(f*h*g),G=t.bufferSync(o);for(let W=0;W<p.batchSize;++W)for(let H=0;H<p.inChannels;++H)for(let U=0;U<p.inDepth;++U)for(let V=0;V<p.inHeight;++V)for(let Y=0;Y<p.inWidth;++Y){let j=U-_,te=V-R,ne=Y-M,oe=0;for(let ae=0;ae<I;ae+=b){let se=(j+ae)/m;if(!(se<0||se>=p.outDepth||Math.floor(se)!==se))for(let ie=0;ie<k;ie+=T){let he=(te+ie)/c;if(!(he<0||he>=p.outHeight||Math.floor(he)!==he))for(let ye=0;ye<w;ye+=x){let ve=(ne+ye)/d;if(ve<0||ve>=p.outWidth||Math.floor(ve)!==ve)continue;oe+=G.get(W,se,he,ve,H)}}}E.set(oe*O,W,U,V,Y,H)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}var o$={kernelName:Sm,backendName:"cpu",kernelFunc:Nne};function Dne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;ee([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=n,p=C.computePool2DInfo(a.shape,i,u,1,l),m=p.strideHeight,c=p.strideWidth,d=p.filterHeight,f=p.filterWidth,h=p.dilationHeight,g=p.dilationWidth,b=p.effectiveFilterHeight,T=p.effectiveFilterWidth,x=T-1-p.padInfo.left,I=b-1-p.padInfo.top,k=Ie(a.shape,"float32"),w=1/(d*f),_=t.data.get(o.dataId).values,M=Ie(o.shape,"float32",_);for(let R=0;R<p.batchSize;++R)for(let E=0;E<p.inChannels;++E)for(let O=0;O<p.inHeight;++O)for(let G=0;G<p.inWidth;++G){let W=O-I,H=G-x,U=0;for(let V=0;V<b;V+=h){let Y=(W+V)/m;if(!(Y<0||Y>=p.outHeight||Math.floor(Y)!==Y))for(let j=0;j<T;j+=g){let te=(H+j)/c;if(te<0||te>=p.outWidth||Math.floor(te)!==te)continue;U+=M.get(R,Y,te,E)}}k.set(U*w,R,O,G,E)}return t.makeTensorInfo(k.shape,k.dtype,k.values)}var s$={kernelName:km,backendName:"cpu",kernelFunc:Dne};function _ne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,scale:s,offset:a,mean:i,variance:u}=e;y.assert(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ee([o,i,u,s,a],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let p=t.data.get(o.dataId).values,m=t.data.get(i.dataId).values,c=t.data.get(u.dataId).values,d=s?t.data.get(s.dataId).values:new Float32Array([1]),f=a?t.data.get(a.dataId).values:new Float32Array([0]),h=new Float32Array(p.length),g=f.length,b=d.length,T=c.length,x=m.length,I=0,k=0,w=0,_=0;for(let M=0;M<p.length;++M)h[M]=f[I++]+(p[M]-m[k++])*d[w++]/Math.sqrt(c[_++]+l),I>=g&&(I=0),k>=x&&(k=0),w>=b&&(w=0),_>=T&&(_=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var a$={kernelName:Do,backendName:"cpu",kernelFunc:_ne};function Mne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;ee([o],"batchToSpaceND");let i=s.reduce((b,T)=>b*T),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=rt({inputs:{x:o},backend:t,attrs:{shape:u}}),f=qt({inputs:{x:d},backend:t,attrs:{perm:l}}),h=rt({inputs:{x:f},backend:t,attrs:{shape:p}}),g=ia({inputs:{x:h},backend:t,attrs:{begin:m,size:c}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var i$={kernelName:xs,backendName:"cpu",kernelFunc:Mne};function Rne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=pf(i,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}var u$={kernelName:Ou,backendName:"cpu",kernelFunc:Rne};function Pne(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,i=C.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var l$={kernelName:vm,backendName:"cpu",kernelFunc:Pne};var Ene=Pe(Kn,(r,e)=>{let t=e;return r>t.clipValueMax?t.clipValueMax:r<t.clipValueMin?t.clipValueMin:r}),p$={kernelName:Kn,backendName:"cpu",kernelFunc:Ene};var Fne=r=>{let{x:e}=r.inputs,t=r.backend,n=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId),s=o.complexTensorInfos.real,a=o.complexTensorInfos.imag,i=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values;for(let l=0;l<i.length;l++){let p=i[l],m=u[l];n[l]=Math.hypot(p,m)}return t.makeOutput(n,e.shape,"float32")},m$={kernelName:Gu,backendName:"cpu",kernelFunc:Fne};function Wi(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var c$={kernelName:Hu,backendName:"cpu",kernelFunc:Wi};function El(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=e.map(h=>h.shape);C.assertParamsConsistent(a,s);let i=C.computeOutShape(e.map(h=>h.shape),s);if(y.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let u=e.filter(h=>y.sizeFromShape(h.shape)>0);if(u.length===1)return Jr({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){let h=u.map(I=>na({inputs:{input:I},backend:t})),g=u.map(I=>Wi({inputs:{input:I},backend:t})),b=El({inputs:h,backend:t,attrs:{axis:s}}),T=El({inputs:g,backend:t,attrs:{axis:s}}),x=wr({inputs:{real:b,imag:T},backend:t});return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),g.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(T),x}let l=u.map(h=>{let g=y.sizeFromShape(h.shape.slice(s));return rt({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}})}),p=l.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));i=C.computeOutShape(l.map(h=>h.shape),1);let m=l[0].shape[0]===1,c=Op(p,i,e[0].dtype,m),d=C.computeOutShape(u.map(h=>h.shape),s),f=t.makeTensorInfo(d,e[0].dtype,c);return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),f}var d$={kernelName:Is,backendName:"cpu",kernelFunc:El};function RN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n;ee([o,s],"conv2d");let m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,m),d=c.filterHeight,f=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,b=c.padInfo.left,T=c.padInfo.top,x=c.dataFormat==="channelsLast",I=new bt(c.outShape,o.dtype),k=y.computeStrides(o.shape),w=y.computeStrides(s.shape),_=k[0],M=x?k[1]:k[2],R=x?k[2]:1,E=x?1:k[1],O=I.strides[0],G=x?I.strides[1]:I.strides[2],W=x?I.strides[2]:1,H=x?1:I.strides[1],U=t.data.get(o.dataId).values,V=t.data.get(s.dataId).values,Y=I.values;for(let j=0;j<c.batchSize;++j){let te=j*_,ne=j*O;for(let oe=0;oe<c.outHeight;++oe){let ae=ne+oe*G,se=oe*c.strideHeight-T;for(let ie=0;ie<d;++ie){let he=se+ie*h;if(he<0||he>=c.inHeight)continue;let ye=ie*w[0],ve=te+he*M;for(let Fe=0;Fe<c.outWidth;++Fe){let $e=ae+Fe*W,je=Fe*c.strideWidth-b;for(let J=0;J<f;++J){let gt=je+J*g;if(gt<0||gt>=c.inWidth)continue;let St=ye+J*w[1],Je=ve+gt*R,Rt=St;for(let Tt=0;Tt<c.inChannels;++Tt){let $t=U[Je+Tt*E];for(let Xt=0;Xt<c.outChannels;++Xt)Y[$e+Xt*H]+=$t*V[Rt+Xt];Rt+=c.outChannels}}}}}}return t.makeTensorInfo(I.shape,I.dtype,Y)}var f$={kernelName:yo,backendName:"cpu",kernelFunc:RN};function Lne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:p}=n;ee([o,s],"conv2dBackpropFilter");let m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,p,a,1,i,l,!1,m),{strideHeight:d,strideWidth:f,filterHeight:h,filterWidth:g}=c,b=c.dataFormat==="channelsLast",T=new bt(c.filterShape,"float32"),x=c.padInfo.left,I=c.padInfo.top,k=t.data.get(o.dataId).values,w=t.data.get(s.dataId).values,_=new bt(o.shape,o.dtype,k),M=new bt(s.shape,s.dtype,w);for(let R=0;R<h;++R){let E=Math.max(0,Math.ceil((I-R)/d)),O=Math.min(c.outHeight,(c.inHeight+I-R)/d);for(let G=0;G<g;++G){let W=Math.max(0,Math.ceil((x-G)/f)),H=Math.min(c.outWidth,(c.inWidth+x-G)/f);for(let U=0;U<c.inChannels;++U)for(let V=0;V<c.outChannels;++V){let Y=0;for(let j=0;j<c.batchSize;++j)for(let te=E;te<O;++te){let ne=R+te*d-I;for(let oe=W;oe<H;++oe){let ae=G+oe*f-x;b?Y+=_.get(j,ne,ae,U)*M.get(j,te,oe,V):Y+=_.get(j,U,ne,ae)*M.get(j,V,te,oe)}}T.set(Y,R,G,U,V)}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}var h$={kernelName:Am,backendName:"cpu",kernelFunc:Lne};function $ne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n;ee([o,s],"conv2dBackpropInput");let m=y.computeStrides(s.shape),c=y.computeStrides(o.shape),d=C.convertConv2DDataFormat(l),f=C.computeConv2DInfo(a,s.shape,i,1,u,p,!1,d),h=new bt(f.inShape,"float32"),g=h.values,b=t.data.get(o.dataId).values,T=t.data.get(s.dataId).values,[x,I,k]=m,{batchSize:w,filterHeight:_,filterWidth:M,inChannels:R,inHeight:E,inWidth:O,outChannels:G,outHeight:W,outWidth:H,strideHeight:U,strideWidth:V}=f;d=f.dataFormat;let Y=_-1-f.padInfo.top,j=M-1-f.padInfo.left,te=d==="channelsLast",ne=h.strides[0],oe=te?h.strides[1]:h.strides[2],ae=te?h.strides[2]:1,se=te?1:h.strides[1],ie=c[0],he=te?c[1]:c[2],ye=te?c[2]:1,ve=te?1:c[1];for(let Fe=0;Fe<w;++Fe)for(let $e=0;$e<R;++$e)for(let je=0;je<E;++je){let J=je-Y,gt=Math.max(0,Math.ceil(J/U)),St=Math.min(W,(_+J)/U);for(let Je=0;Je<O;++Je){let Rt=Je-j,Tt=Math.max(0,Math.ceil(Rt/V)),$t=Math.min(H,(M+Rt)/V),Xt=0;for(let dr=gt;dr<St;++dr){let so=dr*U-J;for(let Wr=Tt;Wr<$t;++Wr){let rr=Wr*V-Rt,Ur=ie*Fe+he*dr+ye*Wr,Kr=x*(_-1-so)+I*(M-1-rr)+k*$e;for(let ao=0;ao<G;++ao){let io=b[Ur+ve*ao],tn=T[Kr+ao];Xt+=io*tn}}}let On=ne*Fe+oe*je+ae*Je+se*$e;g[On]=Xt}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var g$={kernelName:To,backendName:"cpu",kernelFunc:$ne};function Bne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n;ee([o,s],"conv3d");let l=C.computeConv3DInfo(o.shape,s.shape,a,u,i),{filterDepth:p,filterHeight:m,filterWidth:c,dilationDepth:d,dilationHeight:f,dilationWidth:h,padInfo:g}=l,b=g.front,T=g.left,x=g.top,I=new bt(l.outShape,o.dtype),k=t.data.get(o.dataId).values,w=t.data.get(s.dataId).values,_=I.values,M=y.computeStrides(o.shape),R=y.computeStrides(s.shape);for(let E=0;E<l.batchSize;++E){let O=E*M[0],G=E*I.strides[0];for(let W=0;W<l.outDepth;++W){let H=G+W*I.strides[1],U=W*l.strideDepth-b;for(let V=0;V<p;++V){let Y=U+V*d;if(Y<0||Y>=l.inDepth)continue;let j=V*R[0],te=O+Y*M[1];for(let ne=0;ne<l.outHeight;++ne){let oe=H+ne*I.strides[2],ae=ne*l.strideHeight-x;for(let se=0;se<m;++se){let ie=ae+se*f;if(ie<0||ie>=l.inHeight)continue;let he=j+se*R[1],ye=te+ie*M[2];for(let ve=0;ve<l.outWidth;++ve){let Fe=oe+ve*l.outChannels,$e=ve*l.strideWidth-T;for(let je=0;je<c;++je){let J=$e+je*h;if(J<0||J>=l.inWidth)continue;let gt=he+je*R[2],St=ye+J*l.inChannels,Je=gt;for(let Rt=0;Rt<l.inChannels;++Rt){let Tt=k[St+Rt];for(let $t=0;$t<l.outChannels;++$t)_[Fe+$t]+=Tt*w[Je+$t];Je+=l.outChannels}}}}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}var b$={kernelName:Wu,backendName:"cpu",kernelFunc:Bne};function One(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:u}=n;ee([o,s],"conv3dBackpropFilterV2");let l=y.computeStrides(o.shape),p=y.computeStrides(s.shape),m=C.computeConv3DInfo(o.shape,u,a,1,i),c=m.strideDepth,d=m.strideHeight,f=m.strideWidth,h=m.filterDepth,g=m.filterHeight,b=m.filterWidth,T=new bt(m.filterShape,"float32"),x=T.values,[I,k,w,_]=T.strides,M=t.data.get(s.dataId).values,[R,E,O,G]=p,W=t.data.get(o.dataId).values,[H,U,V,Y]=l,j=m.padInfo.front,te=m.padInfo.left,ne=m.padInfo.top;for(let oe=0;oe<h;++oe){let ae=Math.max(0,Math.ceil((j-oe)/c)),se=Math.min(m.outDepth,(m.inDepth+j-oe)/c),ie=oe*I;for(let he=0;he<g;++he){let ye=Math.max(0,Math.ceil((ne-he)/d)),ve=Math.min(m.outHeight,(m.inHeight+ne-he)/d),Fe=he*k+ie;for(let $e=0;$e<b;++$e){let je=Math.max(0,Math.ceil((te-$e)/f)),J=Math.min(m.outWidth,(m.inWidth+te-$e)/f),gt=$e*w+Fe;for(let St=0;St<m.inChannels;++St){let Je=St*_+gt;for(let Rt=0;Rt<m.outChannels;++Rt){let Tt=0;for(let $t=0;$t<m.batchSize;++$t){let Xt=$t*H,On=$t*R;for(let dr=ae;dr<se;++dr){let Wr=(oe+dr*c-j)*U+Xt,rr=dr*E+On;for(let Ur=ye;Ur<ve;++Ur){let ao=(he+Ur*d-ne)*V+Wr,io=Ur*O+rr;for(let tn=je;tn<J;++tn){let da=($e+tn*f-te)*Y+ao,Eu=tn*G+io;Tt+=W[da+St]*M[Eu+Rt]}}}}x[Je+Rt]=Tt}}}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}var y$={kernelName:wm,backendName:"cpu",kernelFunc:One};function zne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:u}=n;ee([o],"conv3dBackpropInputV2");let l=y.computeStrides(o.shape),p=y.computeStrides(s.shape),m=C.computeConv3DInfo(u,s.shape,i,1,a),c=new bt(m.inShape,"float32"),d=c.values,[f,h,g,b]=c.strides,T=t.data.get(o.dataId).values,[x,I,k,w]=l,_=t.data.get(s.dataId).values,[M,R,E,O]=p,{batchSize:G,filterDepth:W,filterHeight:H,filterWidth:U,inChannels:V,inDepth:Y,inHeight:j,inWidth:te,outChannels:ne,outDepth:oe,outHeight:ae,outWidth:se,strideDepth:ie,strideHeight:he,strideWidth:ye}=m,ve=W-1-m.padInfo.front,Fe=H-1-m.padInfo.top,$e=U-1-m.padInfo.left;for(let je=0;je<G;++je)for(let J=0;J<V;++J)for(let gt=0;gt<Y;++gt){let St=gt-ve,Je=Math.max(0,Math.ceil(St/ie)),Rt=Math.min(oe,(W+St)/ie);for(let Tt=0;Tt<j;++Tt){let $t=Tt-Fe,Xt=Math.max(0,Math.ceil($t/he)),On=Math.min(ae,(H+$t)/he);for(let dr=0;dr<te;++dr){let so=dr-$e,Wr=Math.max(0,Math.ceil(so/ye)),rr=Math.min(se,(U+so)/ye),Ur=0;for(let Kr=Je;Kr<Rt;++Kr){let ao=Kr*ie-St;for(let io=Xt;io<On;++io){let tn=io*he-$t;for(let Hi=Wr;Hi<rr;++Hi){let da=Hi*ye-so,Eu=x*je+I*Kr+k*io+w*Hi,Lr=M*(W-1-ao)+R*(H-1-tn)+E*(U-1-da)+O*J;for(let qi=0;qi<ne;++qi){let Yf=T[Eu+qi],Zf=_[Lr+qi];Ur+=Yf*Zf}}}}d[f*je+h*gt+g*Tt+b*dr+J]=Ur}}}return t.makeTensorInfo(c.shape,c.dtype,c.values)}var T$={kernelName:Nm,backendName:"cpu",kernelFunc:zne};var Gne=Pe(xo,r=>Math.cos(r)),x$={kernelName:xo,backendName:"cpu",kernelFunc:Gne};var Wne=Pe(Io,r=>Math.cosh(r)),I$={kernelName:Io,backendName:"cpu",kernelFunc:Wne};function Une(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,[p,m,c,d]=o.shape,f=s.shape[0],[h,g]=i,b=Ie([f,h,g,d],"float32"),T=t.data.get(s.dataId).values,x=t.data.get(a.dataId).values,I=t.data.get(o.dataId).values,k=y.computeStrides(o.shape),w=y.computeStrides(b.shape);for(let _=0;_<f;_++){let M=_*4,R=T[M],E=T[M+1],O=T[M+2],G=T[M+3],W=x[_];if(W>=p)continue;let H=h>1?(O-R)*(m-1)/(h-1):0,U=g>1?(G-E)*(c-1)/(g-1):0;for(let V=0;V<h;V++){let Y=h>1?R*(m-1)+V*H:.5*(R+O)*(m-1);if(Y<0||Y>m-1){for(let j=0;j<g;j++)for(let te=0;te<d;te++){let ne=te+j*w[2]+V*w[1]+_*w[0];b.values[ne]=l}continue}if(u==="bilinear"){let j=Math.floor(Y),te=Math.ceil(Y),ne=Y-j;for(let oe=0;oe<g;oe++){let ae=g>1?E*(c-1)+oe*U:.5*(E+G)*(c-1);if(ae<0||ae>c-1){for(let ye=0;ye<d;ye++){let ve=ye+oe*w[2]+V*w[1]+_*w[0];b.values[ve]=l}continue}let se=Math.floor(ae),ie=Math.ceil(ae),he=ae-se;for(let ye=0;ye<d;ye++){let ve=ye+se*k[2]+j*k[1]+W*k[0],Fe=I[ve];ve=ye+ie*k[2]+j*k[1]+W*k[0];let $e=I[ve];ve=ye+se*k[2]+te*k[1]+W*k[0];let je=I[ve];ve=ye+ie*k[2]+te*k[1]+W*k[0];let J=I[ve],gt=Fe+($e-Fe)*he,St=je+(J-je)*he;ve=ye+oe*w[2]+V*w[1]+_*w[0],b.values[ve]=gt+(St-gt)*ne}}}else for(let j=0;j<g;++j){let te=g>1?E*(c-1)+j*U:.5*(E+G)*(c-1);if(te<0||te>c-1){for(let ae=0;ae<d;ae++){let se=ae+j*w[2]+V*w[1]+_*w[0];b.values[se]=l}continue}let ne=Math.round(te),oe=Math.round(Y);for(let ae=0;ae<d;ae++){let se=ae+ne*k[2]+oe*k[1]+W*k[0],ie=ae+j*w[2]+V*w[1]+_*w[0];b.values[ie]=I[se]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}var C$={kernelName:wa,backendName:"cpu",kernelFunc:Une};function Kne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;ee(o,"cumprod");let u=C.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=qt({inputs:{x:o},backend:t,attrs:{perm:u}}));let p=C.getInnerMostAxes(1,o.shape.length)[0];if(p!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${p}`);let m=Pt(l.dtype,"int32"),c=y.makeOnesTypedArray(y.sizeFromShape(l.shape),m),d=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],h=i?(b,T)=>b+f-T-1:(b,T)=>b+T;for(let b=0;b<d.length;b+=f)for(let T=0;T<f;T++){let x=h(b,T);if(T===0)c[x]=a?1:d[x];else{let I=h(b,T-1);c[x]=a?d[I]*c[I]:d[x]*c[I]}}let g=t.makeTensorInfo(l.shape,m,c);if(u!=null){let b=C.getUndoAxesPermutation(u),T=qt({inputs:{x:g},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),T}return g}var k$={kernelName:Aa,backendName:"cpu",kernelFunc:Kne};function Vne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;ee(o,"cumsum");let u=C.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=qt({inputs:{x:o},backend:t,attrs:{perm:u}}));let p=C.getInnerMostAxes(1,o.shape.length)[0];if(p!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${p}`);let m=Pt(l.dtype,"int32"),c=y.makeZerosTypedArray(y.sizeFromShape(l.shape),m),d=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],h=i?(b,T)=>b+f-T-1:(b,T)=>b+T;for(let b=0;b<d.length;b+=f)for(let T=0;T<f;T++){let x=h(b,T);if(T===0)c[x]=a?0:d[x];else{let I=h(b,T-1);c[x]=a?d[I]+c[I]:d[x]+c[I]}}let g=t.makeTensorInfo(l.shape,m,c);if(u!=null){let b=C.getUndoAxesPermutation(u),T=qt({inputs:{x:g},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),T}return g}var S$={kernelName:Co,backendName:"cpu",kernelFunc:Vne};function Hne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=pf(u,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=Tx(u,l,a,i);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var v$={kernelName:Uu,backendName:"cpu",kernelFunc:Hne};function qne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n;y.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);let i=o.shape[0],u=o.shape[1],l=o.shape[2],p=o.shape[3],m=u*s,c=l*s,d=p/(s*s),f=t.data.get(o.dataId).values,h=new Float32Array(i*m*c*d),g=0;for(let b=0;b<i;++b)for(let T=0;T<m;++T){let x=Math.floor(T/s),I=T%s;for(let k=0;k<c;++k){let w=Math.floor(k/s),_=k%s,M=(I*s+_)*d;for(let R=0;R<d;++R){let O=R+M+p*(w+l*(x+u*b));h[g++]=f[O]}}}return t.makeTensorInfo([i,m,c,d],o.dtype,h)}var A$={kernelName:Na,backendName:"cpu",kernelFunc:qne};function PN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:l}=n;ee([o,s],"depthwiseConv2DNative");let p=y.computeStrides(o.shape),m=y.computeStrides(s.shape),c=u;c==null&&(c=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let d=C.computeConv2DInfo(o.shape,s.shape,a,c,i,l,!0),{filterHeight:f,filterWidth:h,dilationHeight:g,dilationWidth:b,padInfo:T}=d,x=T.left,I=T.top,k=d.outChannels/d.inChannels,w=new bt(d.outShape,o.dtype),_=t.data.get(o.dataId).values,M=t.data.get(s.dataId).values,R=w.values;for(let E=0;E<d.batchSize;++E){let O=E*p[0],G=E*w.strides[0];for(let W=0;W<d.outHeight;++W){let H=G+W*w.strides[1],U=W*d.strideHeight-I;for(let V=0;V<f;++V){let Y=U+V*g;if(Y<0||Y>=d.inHeight)continue;let j=V*m[0],te=O+Y*p[1];for(let ne=0;ne<d.outWidth;++ne){let oe=H+ne*w.strides[2],ae=ne*d.strideWidth-x;for(let se=0;se<h;++se){let ie=ae+se*b;if(ie<0||ie>=d.inWidth)continue;let he=j+se*m[1],ye=te+ie*d.inChannels,ve=oe,Fe=he;for(let $e=0;$e<d.inChannels;++$e){let je=_[ye+$e];for(let J=0;J<k;++J)R[ve+J]+=je*M[Fe+J];ve+=k,Fe+=k}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}var w$={kernelName:ko,backendName:"cpu",kernelFunc:PN};function jne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,filterShape:p}=n;ee([o,s],"depthwiseConv2dNativeBackpropFilter");let m=C.computeConv2DInfo(o.shape,p,a,i,u,l,!0),{strideHeight:c,strideWidth:d,filterHeight:f,filterWidth:h}=m,g=new bt(m.filterShape,"float32"),b=m.padInfo.left,T=m.padInfo.top,x=m.outChannels/m.inChannels,I=t.data.get(o.dataId).values,k=new bt(o.shape,o.dtype,I),w=t.data.get(s.dataId).values,_=new bt(s.shape,s.dtype,w);for(let M=0;M<f;++M){let R=Math.max(0,Math.ceil((T-M)/c)),E=Math.min(m.outHeight,(m.inHeight+T-M)/c);for(let O=0;O<h;++O){let G=Math.max(0,Math.ceil((b-O)/d)),W=Math.min(m.outWidth,(m.inWidth+b-O)/d);for(let H=0;H<m.outChannels;++H){let U=Math.trunc(H/x),V=H%x,Y=0;for(let j=0;j<m.batchSize;++j)for(let te=R;te<E;++te){let ne=M+te*c-T;for(let oe=G;oe<W;++oe){let ae=O+oe*d-b;Y+=k.get(j,ne,ae,U)*_.get(j,te,oe,H)}}g.set(Y,M,O,U,V)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var N$={kernelName:Dm,backendName:"cpu",kernelFunc:jne};function Xne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,inputShape:p}=n;ee([o,s],"depthwiseConv2DNativeBackpropInput");let m=y.computeStrides(o.shape),c=y.computeStrides(s.shape),d=C.computeConv2DInfo(p,s.shape,a,i,u,l,!0),f=new bt(d.inShape,"float32"),h=f.values,[g,b,T]=f.strides,x=t.data.get(o.dataId).values,[I,k,w]=m,_=t.data.get(s.dataId).values,[M,R,E]=c,{batchSize:O,filterHeight:G,filterWidth:W,inChannels:H,inHeight:U,inWidth:V,outChannels:Y,outHeight:j,outWidth:te,strideHeight:ne,strideWidth:oe}=d,ae=G-1-d.padInfo.top,se=W-1-d.padInfo.left,ie=Y/H;for(let he=0;he<O;++he)for(let ye=0;ye<H;++ye)for(let ve=0;ve<U;++ve){let Fe=ve-ae,$e=Math.max(0,Math.ceil(Fe/ne)),je=Math.min(j,(G+Fe)/ne);for(let J=0;J<V;++J){let gt=J-se,St=Math.max(0,Math.ceil(gt/oe)),Je=Math.min(te,(W+gt)/oe),Rt=0;for(let Tt=$e;Tt<je;++Tt){let $t=Tt*ne-Fe;for(let Xt=St;Xt<Je;++Xt){let On=Xt*oe-gt,dr=I*he+k*Tt+w*Xt,so=M*(G-1-$t)+R*(W-1-On)+E*ye;for(let Wr=0;Wr<ie;++Wr){let rr=ye*ie+Wr,Ur=x[dr+rr],Kr=_[so+Wr];Rt+=Ur*Kr}}}h[g*he+b*ve+T*J+ye]=Rt}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}var D$={kernelName:_m,backendName:"cpu",kernelFunc:Xne};function Yne(r){let{inputs:e,backend:t}=r,{x:n}=e,o=y.sizeFromShape(n.shape),s=t.data.get(n.dataId).values,a=Ie([o,o],n.dtype),i=a.values;for(let l=0;l<s.length;l++)i[l*o+l]=s[l];let u=[...n.shape,...n.shape];return t.makeTensorInfo(u,a.dtype,a.values)}var _$={kernelName:Mm,backendName:"cpu",kernelFunc:Yne};var M$={kernelName:Ku,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o}=r,{strides:s,pad:a,dilations:i}=t,u=e,l=u.data.get(n.dataId).values,p=n.shape.length,m=u.data.get(o.dataId).values,c=o.shape.length,{batchSize:d,inHeight:f,inWidth:h,inChannels:g,outHeight:b,outWidth:T,padInfo:x,strideHeight:I,strideWidth:k,filterHeight:w,filterWidth:_,dilationHeight:M,dilationWidth:R,outShape:E}=C.computeDilation2DInfo(n.shape,o.shape,s,a,"NHWC",i),O=y.sizeFromShape(E),G=E.length,W=y.getArrayFromDType(n.dtype,O);for(let U=0;U<d;++U)for(let V=0;V<b;++V){let Y=V*I-x.top;for(let j=0;j<T;++j){let te=j*k-x.left;for(let ne=0;ne<g;++ne){let oe=Number.MIN_SAFE_INTEGER;for(let se=0;se<w;++se){let ie=Y+se*M;if(ie>=0&&ie<f)for(let he=0;he<_;++he){let ye=te+he*R;if(ye>=0&&ye<h){let ve=y.locToIndex([U,ie,ye,ne],p,y.computeStrides(n.shape)),Fe=y.locToIndex([se,he,ne],c,y.computeStrides(o.shape)),$e=l[ve]+m[Fe];$e>oe&&(oe=$e)}}}let ae=y.locToIndex([U,V,j,ne],G,y.computeStrides(E));W[ae]=oe}}}return{dataId:u.write(y.toTypedArray(W,n.dtype),E,n.dtype),shape:E,dtype:n.dtype}}};var R$={kernelName:lh,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=t,l=e,p=y.toNestedArray(n.shape,l.data.get(n.dataId).values),m=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:c,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:b,padInfo:T,strideHeight:x,strideWidth:I,filterHeight:k,filterWidth:w,dilationHeight:_,dilationWidth:M,outShape:R}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);y.assert(s.rank===R.length,()=>`Error in ${lh}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let E=y.toNestedArray(R,l.data.get(s.dataId).values),O=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let W=0;W<c;++W)for(let H=0;H<g;++H){let U=H*x-T.top;for(let V=0;V<b;++V){let Y=V*I-T.left;for(let j=0;j<h;++j){let te=Number.MIN_SAFE_INTEGER,ne=0,oe=0;for(let ae=0;ae<k;++ae){let se=U+ae*_;if(se>=0&&se<d)for(let ie=0;ie<w;++ie){let he=Y+ie*M;if(he>=0&&he<f){let ye=p[W][se][he][j]+m[ae][ie][j];ye>te&&(te=ye,ne=ae,oe=ie)}}}O[ne][oe][j]+=E[W][H][V][j]}}}return{dataId:l.write(y.toTypedArray(O,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var P$={kernelName:uh,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=t,l=e,p=y.toNestedArray(n.shape,l.data.get(n.dataId).values),m=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:c,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:b,padInfo:T,strideHeight:x,strideWidth:I,filterHeight:k,filterWidth:w,dilationHeight:_,dilationWidth:M,outShape:R}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);y.assert(s.rank===R.length,()=>`Error in ${uh}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let E=y.toNestedArray(R,l.data.get(s.dataId).values),O=y.makeZerosNestedTypedArray(n.shape,n.dtype);for(let W=0;W<c;++W)for(let H=0;H<g;++H){let U=H*x-T.top;for(let V=0;V<b;++V){let Y=V*I-T.left;for(let j=0;j<h;++j){let te=Number.MIN_SAFE_INTEGER,ne=U<0?0:U,oe=Y<0?0:Y;for(let ae=0;ae<k;++ae){let se=U+ae*_;if(se>=0&&se<d)for(let ie=0;ie<w;++ie){let he=Y+ie*M;if(he>=0&&he<f){let ye=p[W][se][he][j]+m[ae][ie][j];ye>te&&(te=ye,ne=se,oe=he)}}}O[W][ne][oe][j]+=E[W][H][V][j]}}}return{dataId:l.write(y.toTypedArray(O,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function vu(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"sum");let i;o.dtype==="bool"?i=oa({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):i=Jr({inputs:{x:o},backend:t});let u=i.shape.length,l=y.parseAxisParam(s,i.shape),p=C.getAxesPermutation(l,u),m=l,c=i;p!=null&&(c=qt({inputs:{x:i},backend:t,attrs:{perm:p}}),m=C.getInnerMostAxes(m.length,u)),C.assertAxesAreInnerMostDims("sum",m,c.shape.length);let[d,f]=C.computeOutAndReduceShapes(c.shape,m),h=C.upcastType(c.dtype,"int32"),g=uf(t,d,h),b=y.sizeFromShape(f),T=t.data.get(g.dataId).values,x=t.data.get(c.dataId).values;for(let I=0;I<T.length;++I){let k=I*b,w=0;for(let _=0;_<b;++_)w+=x[k+_];T[I]=w}if(a){let I=C.expandShapeToKeepDim(g.shape,l),k=g;g=rt({inputs:{x:g},backend:t,attrs:{shape:I}}),t.disposeIntermediateTensorInfo(k)}return t.disposeIntermediateTensorInfo(i),p!=null&&t.disposeIntermediateTensorInfo(c),g}var E$={kernelName:ns,backendName:"cpu",kernelFunc:vu};function Zne(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=C.getEinsumComputePath(i,u),m=p.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of p[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=qt({inputs:{x:s[g]},backend:t,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let k=0;k<T.length;++k)I.splice(T[k],0,1);y.arraysEqual(x.shape,I)||(x=rt({inputs:{x},backend:t,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=zp({inputs:{a:x,b:c},backend:t}),f.push(c))}h<m-1&&(l[h]>=0&&(c=vu({inputs:{x:c},backend:t,attrs:{axis:l[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&t.disposeIntermediateTensorInfo(h);return c}var F$={kernelName:Vu,backendName:"cpu",kernelFunc:Zne};function Qne(r){let{inputs:e,backend:t}=r,{dy:n,y:o}=e;ee([n,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),a=t.data.get(o.dataId).values,i=t.data.get(n.dataId).values;for(let u=0;u<a.length;++u){let l=a[u];l>=1?s[u]=i[u]:s[u]=i[u]*(l+1)}return t.makeTensorInfo(o.shape,"float32",s)}var L$={kernelName:Rm,backendName:"cpu",kernelFunc:Qne};var Jne=C.ERF_P,eoe=C.ERF_A1,toe=C.ERF_A2,roe=C.ERF_A3,noe=C.ERF_A4,ooe=C.ERF_A5,soe=Pe(Da,r=>{let e=Math.sign(r),t=Math.abs(r),n=1/(1+Jne*t);return e*(1-((((ooe*n+noe)*n+roe)*n+toe)*n+eoe)*n*Math.exp(-t*t))}),$$={kernelName:Da,backendName:"cpu",kernelFunc:soe};function gf(r){let{inputs:e,backend:t,attrs:n}=r,{input:o}=e,{dim:s}=n,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),rt({inputs:{x:o},backend:t,attrs:{shape:i}})}var B$={kernelName:Cs,backendName:"cpu",kernelFunc:gf};var aoe=ot((r,e)=>r/e),ig=pt(So,aoe),ug={kernelName:So,backendName:"cpu",kernelFunc:ig};function Fx(r,e,t){let n=r.shape,o=n[0],s=n[1],a=t.data.get(r.dataId),i=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,l=[o,s],p=y.sizeFromShape(l),m=y.getTypedArrayFromDType("float32",p),c=y.getTypedArrayFromDType("float32",p);for(let g=0;g<o;g++){let b=ia({inputs:{x:i},backend:t,attrs:{begin:[g,0],size:[1,s]}}),T=ia({inputs:{x:u},backend:t,attrs:{begin:[g,0],size:[1,s]}}),x=wr({inputs:{real:b,imag:T},backend:t}),{real:I,imag:k}=ioe(x,e,t),w=C.mergeRealAndImagArrays(I,k);for(let _=0;_<s;_++){let M=C.getComplexWithIndex(w,_);m[g*s+_]=M.real,c[g*s+_]=M.imag}t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(x)}let d=t.makeTensorInfo(l,"float32",m),f=t.makeTensorInfo(l,"float32",c),h=wr({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),h}function ioe(r,e,t){let n=y.sizeFromShape(r.shape),o=t.data.get(r.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,a=t.data.get(o.complexTensorInfos.imag.dataId).values;if(uoe(n)){let i=EN(s,a,n,e,t),u=[r.shape[0],r.shape[1]];if(e){let l=t.makeTensorInfo(u,"float32",i.real),p=t.makeTensorInfo(u,"float32",i.imag),m=t.makeTensorInfo([],"float32",y.createScalarValue(n,"float32")),c=Jr({inputs:{x:m},backend:t}),d=ug.kernelFunc({inputs:{a:l,b:m},backend:t}),f=ug.kernelFunc({inputs:{a:p,b:c},backend:t}),h=t.data.get(d.dataId).values,g=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),{real:h,imag:g}}return i}else{let i=C.mergeRealAndImagArrays(s,a),u=loe(i,n,e);return C.splitRealAndImagArrays(u)}}function uoe(r){return(r&r-1)===0}function EN(r,e,t,n,o){if(t===1)return{real:r,imag:e};let s=C.mergeRealAndImagArrays(r,e),a=t/2,i=C.complexWithEvenIndex(s),u=i.real,l=i.imag,p=[u.length],m=o.makeTensorInfo(p,"float32",u),c=o.makeTensorInfo(p,"float32",l),d=wr({inputs:{real:m,imag:c},backend:o}),f=C.complexWithOddIndex(s),h=f.real,g=f.imag,b=[h.length],T=o.makeTensorInfo(b,"float32",h),x=o.makeTensorInfo(b,"float32",g),I=wr({inputs:{real:T,imag:x},backend:o}),k=EN(u,l,a,n,o),w=k.real,_=k.imag,M=[w.length],R=o.makeTensorInfo(M,"float32",w),E=o.makeTensorInfo(M,"float32",_),O=wr({inputs:{real:R,imag:E},backend:o}),G=EN(h,g,a,n,o),W=G.real,H=G.imag,U=[W.length],V=o.makeTensorInfo(U,"float32",W),Y=o.makeTensorInfo(U,"float32",H),j=wr({inputs:{real:V,imag:Y},backend:o}),te=C.exponents(t,n),ne=[te.real.length],oe=o.makeTensorInfo(ne,"float32",te.real),ae=o.makeTensorInfo(ne,"float32",te.imag),se=wr({inputs:{real:oe,imag:ae},backend:o}),ie=zp({inputs:{a:se,b:j},backend:o}),he=Gi({inputs:{a:O,b:ie},backend:o}),ye=sg({inputs:{a:O,b:ie},backend:o}),ve=na({inputs:{input:he},backend:o}),Fe=na({inputs:{input:ye},backend:o}),$e=Wi({inputs:{input:he},backend:o}),je=Wi({inputs:{input:ye},backend:o}),J=El({inputs:[ve,Fe],backend:o,attrs:{axis:0}}),gt=El({inputs:[$e,je],backend:o,attrs:{axis:0}}),St=o.data.get(J.dataId).values,Je=o.data.get(gt.dataId).values;return o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo(E),o.disposeIntermediateTensorInfo(O),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(j),o.disposeIntermediateTensorInfo(oe),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(se),o.disposeIntermediateTensorInfo(ie),o.disposeIntermediateTensorInfo(he),o.disposeIntermediateTensorInfo(ye),o.disposeIntermediateTensorInfo(ve),o.disposeIntermediateTensorInfo($e),o.disposeIntermediateTensorInfo(Fe),o.disposeIntermediateTensorInfo(je),o.disposeIntermediateTensorInfo(J),o.disposeIntermediateTensorInfo(gt),{real:St,imag:Je}}function loe(r,e,t){let n=new Float32Array(e*2);for(let o=0;o<e;o++){let s=0,a=0;for(let i=0;i<e;i++){let u=C.exponent(o*i,e,t),l=C.getComplexWithIndex(r,i);s+=l.real*u.real-l.imag*u.imag,a+=l.real*u.imag+l.imag*u.real}t&&(s/=e,a/=e),C.assignToTypedArray(n,s,a,o)}return n}function poe(r){let{inputs:e,backend:t}=r,{input:n}=e,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=rt({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),u=Fx(i,!1,t),l=rt({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var O$={kernelName:Pm,backendName:"cpu",kernelFunc:poe};function lg(r){let{backend:e,attrs:t}=r,{shape:n,value:o,dtype:s}=t,a=s||y.inferDtype(o),i=y.getArrayFromDType(a,y.sizeFromShape(n));return moe(i,o,a),e.makeTensorInfo(n,a,i)}var z$={kernelName:vi,backendName:"cpu",kernelFunc:lg};function moe(r,e,t){r.fill(e)}var G$={kernelName:Ra,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,o=t,s=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[a,i,u,l]=n.shape,p=o.data.get(n.dataId).values;for(let c=0;c<a;c++){let d=c*u*i*l;for(let f=0;f<i;f++){let h=f*(u*l);for(let g=0;g<u;g++){let b=g*l;for(let T=0;T<l;T++){let x=Math.round(u-g-1),I=d+h+b+T,k=p[I];if(x>=0&&x<u){let w=x*l,_=d+h+w+T;k=p[_]}s[I]=k}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var coe=ot((r,e)=>Math.floor(r/e)),doe=pt(No,coe,null,"int32"),W$={kernelName:No,backendName:"cpu",kernelFunc:doe};function foe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=RN({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c}});if(a){let g=h;if(p==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){let b=rt({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});h=Gi({inputs:{a:h,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else h=Gi({inputs:{a:h,b:a},backend:t});t.disposeIntermediateTensorInfo(g)}if(d){let g=h;if(p==="NCHW"&&d==="prelu"&&i.shape.length===1&&i.shape[0]!==1){let b=rt({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});h=Hp(t,h,d,b,f),t.disposeIntermediateTensorInfo(b)}else h=Hp(t,h,d,i,f);t.disposeIntermediateTensorInfo(g)}return h}var U$={kernelName:Ls,backendName:"cpu",kernelFunc:foe};function hoe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=PN({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c}});if(a){let g=h;h=Gi({inputs:{a:h,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){let g=h;h=Hp(t,h,d,i,f),t.disposeIntermediateTensorInfo(g)}return h}var K$={kernelName:$s,backendName:"cpu",kernelFunc:hoe};function goe(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=y.sizeFromShape(n.shape),a=o.shape,i=a[a.length-1],[u,l,p,m]=C.prepareAndValidate(n,o);if(l===0)return t.makeTensorInfo(u,n.dtype,[]);let c=t.data.get(o.dataId).values,d=t.bufferSync(n),f=xx(c,d,n.dtype,l,i,p,m,n.shape,s);return t.makeTensorInfo(u,n.dtype,f.values)}var V$={kernelName:Pa,backendName:"cpu",kernelFunc:goe};function boe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n;ee([o,s],"gatherV2");let u=y.parseAxisParam(a,o.shape)[0],l=t.data.get(s.dataId).values,p=o.shape[u];for(let I=0;I<l.length;++I){let k=l[I];y.assert(k<=p-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${p-1}]`)}let m=i;i==null&&(m=0);let c=y.sizeFromShape(s.shape),d=C.segment_util.collectGatherOpShapeInfo(o,s,u,m),f=rt({inputs:{x:o},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),h=rt({inputs:{x:s},backend:t,attrs:{shape:[d.batchSize,c/d.batchSize]}}),g=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize],b=t.bufferSync(h),T=t.bufferSync(f),x=Ix(T,b,g);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(d.outputShape,x.dtype,x.values)}var H$={kernelName:ks,backendName:"cpu",kernelFunc:boe};function yoe(r){let{inputs:e,backend:t}=r,{input:n}=e,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=rt({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),u=Fx(i,!0,t),l=rt({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var q$={kernelName:Em,backendName:"cpu",kernelFunc:yoe};var Toe=Pe(Fa,r=>Number.isFinite(r)?1:0,"bool"),j$={kernelName:Fa,backendName:"cpu",kernelFunc:Toe};var xoe=Pe(La,r=>Math.abs(r)===1/0?1:0,"bool"),X$={kernelName:La,backendName:"cpu",kernelFunc:xoe};var Ioe=Pe(Mo,r=>Number.isNaN(r)?1:0,"bool"),Y$={kernelName:Mo,backendName:"cpu",kernelFunc:Ioe};function Coe(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=Cx(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var Z$={kernelName:Fm,backendName:"cpu",kernelFunc:Coe};var koe=Pe(Qi,r=>Math.log1p(r)),Q$={kernelName:Qi,backendName:"cpu",kernelFunc:koe};var Soe=ot((r,e)=>r&&e),voe=pt(Oa,Soe,null,"bool"),J$={kernelName:Oa,backendName:"cpu",kernelFunc:voe};var Aoe=Pe(za,r=>r?0:1,"bool"),eB={kernelName:za,backendName:"cpu",kernelFunc:Aoe};var woe=ot((r,e)=>r||e),Noe=pt(Ji,woe,null,"bool"),tB={kernelName:Ji,backendName:"cpu",kernelFunc:Noe};function Doe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:u}=n;ee(o,"LRN");let l=o.shape[3],p=l-1,m=t.data.get(o.dataId).values,c=y.sizeFromShape(o.shape),d=new Float32Array(c);function f(h){let g=h%l,b=h-g+Math.max(0,g-s),T=h-g+Math.min(g+s,p),x=0;for(;b<=T;b++){let I=m[b];x+=I*I}return x}for(let h=0;h<c;h++){let g=f(h),b=m[h]*Math.pow(a+i*g,-u);d[h]=b}return t.makeTensorInfo(o.shape,o.dtype,d)}var rB={kernelName:qu,backendName:"cpu",kernelFunc:Doe};function _oe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:u,alpha:l,beta:p}=n;ee(a,"LRNGrad");let m=y.sizeFromShape(a.shape),c=a.shape[3],d=t.data.get(a.dataId).values,f=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(m),b=m;for(let T=0;T<b;T++){let x=T%c,I=T-x+Math.max(0,x-i),k=T-x+Math.min(c,x+i+1),w=0;for(let _=I;_<k;_++)w+=Math.pow(f[_],2);w=l*w+u;for(let _=I;_<k;_++){let M=-2*l*p*f[_]*h[T]/w;T===_&&(M+=Math.pow(w,-p)),M*=d[T],g[_]+=M}}return t.makeTensorInfo(a.shape,o.dtype,g)}var nB={kernelName:Lm,backendName:"cpu",kernelFunc:_oe};function FN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=t,u=o.shape,l=u.length,p=y.parseAxisParam(s,u),m=p,c=C.getAxesPermutation(m,l),d=i.data.get(o.dataId).values;if(c!=null){let I=new Array(l);for(let k=0;k<I.length;k++)I[k]=u[c[k]];d=mf(d,u,o.dtype,c,I),m=C.getInnerMostAxes(m.length,l),u=I}ee(o,"max"),C.assertAxesAreInnerMostDims("max",m,l);let[f,h]=C.computeOutAndReduceShapes(u,m),g=y.sizeFromShape(h),b=kx(d,g,f,o.dtype),T=i.write(b,f,o.dtype),x=f;return a&&(x=C.expandShapeToKeepDim(f,p)),{dataId:T,shape:x,dtype:o.dtype}}var oB={kernelName:Eo,backendName:"cpu",kernelFunc:FN};function Moe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;ee(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u),m;if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))m=Jr({inputs:{x:o},backend:t});else{let c=t.data.get(o.dataId).values,d=y.computeStrides(o.shape),f=hf(c,o.shape,o.dtype,d,p,"max");m=t.makeTensorInfo(p.outShape,o.dtype,f.values)}return m}var sB={kernelName:Lo,backendName:"cpu",kernelFunc:Moe};function Roe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n;ee(o,"maxPool3d");let p=C.computePool3DInfo(o.shape,s,a,1,i,u,l),m=t.data.get(o.dataId).values,c=Ex(m,o.shape,o.dtype,y.computeStrides(o.shape),p,"max");return t.makeTensorInfo(c.shape,"float32",c.values)}var aB={kernelName:ju,backendName:"cpu",kernelFunc:Roe};function Poe(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=n;ee([o,s],"maxPool3DGrad");let p=C.computePool3DInfo(s.shape,a,i,1,u,l),m=t.bufferSync(s),c=t$(m,p),d=p.strideDepth,f=p.strideHeight,h=p.strideWidth,g=p.dilationDepth,b=p.dilationHeight,T=p.dilationWidth,x=p.effectiveFilterDepth,I=p.effectiveFilterHeight,k=p.effectiveFilterWidth,w=x-1-p.padInfo.front,_=k-1-p.padInfo.left,M=I-1-p.padInfo.top,R=Ie(s.shape,"float32"),E=t.bufferSync(o);for(let O=0;O<p.batchSize;++O)for(let G=0;G<p.inChannels;++G)for(let W=0;W<p.inDepth;++W)for(let H=0;H<p.inHeight;++H)for(let U=0;U<p.inWidth;++U){let V=W-w,Y=H-M,j=U-_,te=0;for(let ne=0;ne<x;ne+=g){let oe=(V+ne)/d;if(!(oe<0||oe>=p.outDepth||Math.floor(oe)!==oe))for(let ae=0;ae<I;ae+=b){let se=(Y+ae)/f;if(!(se<0||se>=p.outHeight||Math.floor(se)!==se))for(let ie=0;ie<k;ie+=T){let he=(j+ie)/h;if(he<0||he>=p.outWidth||Math.floor(he)!==he)continue;let ye=x*I*k-1-c.get(O,oe,se,he,G),ve=ne*I*k+ae*k+ie,Fe=ye===ve?1:0;if(Fe===0)continue;te+=E.get(O,oe,se,he,G)*Fe}}}R.set(te,O,W,H,U,G)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}var iB={kernelName:Bm,backendName:"cpu",kernelFunc:Poe};function Eoe(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;ee([s,a],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:m}=n,c=C.computePool2DInfo(i.shape,u,l,1,p,m),d=t.data.get(i.dataId).values,f=Ie(c.outShape,i.dtype,Px(d,i.shape,i.dtype,c).values),h=c.strideHeight,g=c.strideWidth,b=c.dilationHeight,T=c.dilationWidth,x=c.effectiveFilterHeight,I=c.effectiveFilterWidth,k=I-1-c.padInfo.left,w=x-1-c.padInfo.top,_=Ie(i.shape,"float32"),M=t.data.get(o.dataId).values,R=Ie(o.shape,"float32",M);for(let E=0;E<c.batchSize;++E)for(let O=0;O<c.inChannels;++O)for(let G=0;G<c.inHeight;++G)for(let W=0;W<c.inWidth;++W){let H=G-w,U=W-k,V=0;for(let Y=0;Y<x;Y+=b){let j=(H+Y)/h;if(!(j<0||j>=c.outHeight||Math.floor(j)!==j))for(let te=0;te<I;te+=T){let ne=(U+te)/g;if(ne<0||ne>=c.outWidth||Math.floor(ne)!==ne)continue;let oe=x*I-1-f.get(E,j,ne,O),ae=Y*I+te,se=oe===ae?1:0;if(se===0)continue;V+=R.get(E,j,ne,O)*se}}_.set(V,E,G,W,O)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}var uB={kernelName:$m,backendName:"cpu",kernelFunc:Eoe};function lB(r,e,t,n,o){let s=y.computeStrides(e),a=hf(r,e,t,s,o,"max"),i=Px(r,e,t,o,!0,n);return[a.values,i.values]}var pB={kernelName:Om,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,u=t;ee(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,p=C.computePool2DInfo(n.shape,o,s,[1,1],a),[m,c]=lB(l,n.shape,n.dtype,i,p),d=u.write(m,p.outShape,n.dtype),f=u.write(c,p.outShape,n.dtype);return[{dataId:d,shape:p.outShape,dtype:n.dtype},{dataId:f,shape:p.outShape,dtype:"int32"}]}};function Foe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=y.parseAxisParam(s,o.shape),l=C.computeOutAndReduceShapes(o.shape,i)[1],p=y.sizeFromShape(l),m=[],c=t.makeTensorInfo([],"float32",new Float32Array([p]));m.push(c);let d=oa({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});m.push(d);let f=ig({inputs:{a:d,b:c},backend:t});m.push(f);let h=vu({inputs:{x:f},backend:t,attrs:{axis:s,keepDims:a}});return m.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var mB={kernelName:$o,backendName:"cpu",kernelFunc:Foe};function Loe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"min");let i=y.parseAxisParam(s,o.shape),u=i,l=C.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",u,p.shape.length);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),p.dtype),h=t.data.get(p.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let k=h[T+I];(Number.isNaN(k)||k<x)&&(x=k)}f[b]=x}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(m,p.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=rt({inputs:{x:g},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(g),T}return g}var cB={kernelName:Bo,backendName:"cpu",kernelFunc:Loe};function $oe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,mode:a}=n;ee(o,"mirrorPad");let i=s.map((x,I)=>x[0]+o.shape[I]+x[1]),u=s.map(x=>x[0]),l=s.map((x,I)=>x[0]+o.shape[I]),p=a==="reflect"?0:1,m=t.data.get(o.dataId).values,c=o.shape.length,d=y.computeStrides(o.shape),f=y.sizeFromShape(i),h=i.length,g=y.computeStrides(i),b=y.getTypedArrayFromDType(o.dtype,f);for(let x=0;x<f;x++){let I=y.indexToLoc(x,h,g);for(let w=0;w<h;w++)I[w]<u[w]?I[w]=u[w]*2-I[w]-p:I[w]>=l[w]&&(I[w]=(l[w]-1)*2-I[w]+p);I=I.map((w,_)=>w-u[_]);let k=y.locToIndex(I,c,d);b[x]=m[k]}return{dataId:t.write(b,i,o.dtype),shape:i,dtype:o.dtype}}var dB={kernelName:zo,backendName:"cpu",kernelFunc:$oe};var Boe=ot((r,e)=>{let t=r%e;return r<0&&e<0||r>=0&&e>=0?t:(t+e)%e}),Ooe=pt(Ga,Boe),fB={kernelName:Ga,backendName:"cpu",kernelFunc:Ooe};var gB=Wl(_h());function LN(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=o.shape.length,i=s;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let u=y.parseAxisParam([i],o.shape),l=FN({inputs:{x:o},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),p=C.expandShapeToKeepDim(l.shape,u),m=rt({inputs:{x:l},backend:t,attrs:{shape:p}}),c=sg({inputs:{a:o,b:m},backend:t}),d=uN({inputs:{x:c},backend:t}),f=vu({inputs:{x:d},backend:t,attrs:{axis:u,keepDims:!1}}),h=rt({inputs:{x:f},backend:t,attrs:{shape:p}}),g=ig({inputs:{a:d,b:h},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var hB={kernelName:os,backendName:"cpu",kernelFunc:LN};function zoe(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n;ee(o,"multinomial");let u=i?o:LN({inputs:{logits:o},backend:t,attrs:{dim:-1}}),l=u.shape[0],p=u.shape[1],m=t.data.get(u.dataId).values,c=[l,s],d=y.makeZerosTypedArray(y.sizeFromShape(c),"int32");for(let f=0;f<l;++f){let h=f*p,g=new Float32Array(p-1);g[0]=m[h];for(let x=1;x<g.length;++x)g[x]=g[x-1]+m[h+x];let b=gB.alea(a.toString()),T=f*s;for(let x=0;x<s;++x){let I=b();d[T+x]=g.length;for(let k=0;k<g.length;k++)if(I<g[k]){d[T+x]=k;break}}}return i||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(c,"int32",d)}var bB={kernelName:zm,backendName:"cpu",kernelFunc:zoe};var Goe=xr.nonMaxSuppressionV3Impl;function Woe(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n;ee(o,"NonMaxSuppression");let l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:m}=Goe(l,p,a,i,u);return t.makeTensorInfo([m.length],"int32",new Int32Array(m))}var yB={kernelName:Ua,backendName:"cpu",kernelFunc:Woe};var Uoe=xr.nonMaxSuppressionV4Impl;function Koe(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n;ee(o,"NonMaxSuppressionPadded");let p=t.data.get(o.dataId).values,m=t.data.get(s.dataId).values,{selectedIndices:c,validOutputs:d}=Uoe(p,m,a,i,u,l);return[t.makeTensorInfo([c.length],"int32",new Int32Array(c)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}var TB={kernelName:eu,backendName:"cpu",kernelFunc:Koe};var Voe=xr.nonMaxSuppressionV5Impl;function Hoe(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n;ee(o,"NonMaxSuppressionWithScore");let p=t.data.get(o.dataId).values,m=t.data.get(s.dataId).values,c=a,d=i,f=u,h=l,{selectedIndices:g,selectedScores:b}=Voe(p,m,c,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var xB={kernelName:Ka,backendName:"cpu",kernelFunc:Hoe};function qoe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n;ee(o,"oneHot");let l=y.sizeFromShape(o.shape),p=new Float32Array(l*a);p.fill(u);let m=t.data.get(o.dataId).values;for(let c=0;c<l;++c)m[c]>=0&&m[c]<a&&(p[c*a+m[c]]=i);return t.makeTensorInfo([...o.shape,a],s,p)}var IB={kernelName:Wo,backendName:"cpu",kernelFunc:qoe};function pg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=na({inputs:{input:n},backend:t}),s=pg({inputs:{x:o},backend:t}),a=Wi({inputs:{input:n},backend:t}),i=pg({inputs:{x:a},backend:t}),u=wr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return lg({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var CB={kernelName:Ps,backendName:"cpu",kernelFunc:pg};function kB(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=na({inputs:{input:n},backend:t}),s=kB({inputs:{x:o},backend:t}),a=Wi({inputs:{input:n},backend:t}),i=pg({inputs:{x:a},backend:t}),u=wr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return lg({backend:t,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var SB={kernelName:vs,backendName:"cpu",kernelFunc:kB};function $N(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return gf({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=gf({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=El({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var vB={kernelName:As,backendName:"cpu",kernelFunc:$N};function joe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;ee(o,"pad");let i=s.map((T,x)=>T[0]+o.shape[x]+T[1]),u=s.map(T=>T[0]),l=t.data.get(o.dataId).values,p=y.sizeFromShape(o.shape),m=o.shape.length,c=y.computeStrides(o.shape),d=y.sizeFromShape(i),f=i.length,h=y.computeStrides(i),g=y.getTypedArrayFromDType(o.dtype,d);a!==0&&g.fill(a);for(let T=0;T<p;T++){let I=y.indexToLoc(T,m,c).map((w,_)=>w+u[_]),k=y.locToIndex(I,f,h);g[k]=l[T]}return{dataId:t.write(g,i,o.dtype),shape:i,dtype:o.dtype}}var Lx={kernelName:Uo,backendName:"cpu",kernelFunc:joe};var Xoe=ot((r,e)=>Math.pow(r,e)),Yoe=pt(Ko,Xoe),AB={kernelName:Ko,backendName:"cpu",kernelFunc:Yoe};function Zoe(r){let{inputs:e,backend:t,attrs:n}=r,{paramsNestedSplits:o,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:i}=n,u=o.map(b=>t.data.get(b.dataId).values),l=o.map(b=>b.shape),p=t.data.get(s.dataId).values,m=t.data.get(a.dataId).values,[c,d,f]=Sx(u,l,p,s.shape,s.dtype,m,a.shape,i),h=c.map(b=>t.makeTensorInfo([b.length],"int32",b)),g=t.makeTensorInfo(f,s.dtype,d);return h.concat([g])}var wB={kernelName:Gm,backendName:"cpu",kernelFunc:Zoe};function Qoe(r){let{inputs:e,backend:t}=r,{starts:n,limits:o,deltas:s}=e,a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=vx(a,n.shape,n.dtype,i,o.shape,u,s.shape),m=t.makeTensorInfo([l.length],"int32",l),c=t.makeTensorInfo([p.length],n.dtype,p);return[m,c]}var NB={kernelName:Wm,backendName:"cpu",kernelFunc:Qoe};function Joe(r){let{inputs:e,backend:t,attrs:n}=r,{shape:o,values:s,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=n,l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,m=t.data.get(a.dataId).values,c=i.map(g=>t.data.get(g.dataId).values),d=i.map(g=>g.shape),[f,h]=Ax(l,o.shape,p,s.shape,s.dtype,m,a.shape,c,d,u);return t.makeTensorInfo(f,s.dtype,h)}var DB={kernelName:Um,backendName:"cpu",kernelFunc:Joe};function ese(r){let{backend:e,attrs:t}=r,{start:n,stop:o,dtype:s,step:a}=t,i=Gp(n,o,a,s);return e.makeTensorInfo([i.length],s,i)}var _B={kernelName:Ai,backendName:"cpu",kernelFunc:ese};var tse=Pe(qo,r=>1/r),MB={kernelName:qo,backendName:"cpu",kernelFunc:tse};function rse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;ee(o,"resizeBilinear");let u=y.computeStrides(o.shape),[l,p]=i,[m,c,d,f]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([m,l,p,f])),b=[s&&l>1?c-1:c,s&&p>1?d-1:d],T=[s&&l>1?l-1:l,s&&p>1?p-1:p],x=0,I=b[0]/T[0],k=b[1]/T[1];for(let w=0;w<m;w++)for(let _=0;_<l;_++){let M;a?M=I*(_+.5)-.5:M=I*_;let R=Math.max(0,Math.floor(M)),E=M-R,O=Math.min(c-1,Math.ceil(M)),G=w*u[0]+R*u[1],W=w*u[0]+O*u[1];for(let H=0;H<p;H++){let U;a?U=k*(H+.5)-.5:U=k*H;let V=Math.max(0,Math.floor(U)),Y=U-V,j=Math.min(d-1,Math.ceil(U)),te=G+V*u[2],ne=W+V*u[2],oe=G+j*u[2],ae=W+j*u[2];for(let se=0;se<f;se++){let ie=h[te+se],he=h[ne+se],ye=h[oe+se],ve=h[ae+se],Fe=ie+(ye-ie)*Y,$e=he+(ve-he)*Y,je=Fe+($e-Fe)*E;g[x++]=je}}}return t.makeTensorInfo([m,l,p,f],"float32",g)}var RB={kernelName:Yo,backendName:"cpu",kernelFunc:rse};function nse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;ee([s,o],"resizeBilinearGrad");let i=y.computeStrides(o.shape),[u,l,p,m]=o.shape,[,c,d]=s.shape,f=new Float32Array(u*l*p*m),h=[a&&c>1?l-1:l,a&&d>1?p-1:p],g=[a&&c>1?c-1:c,a&&d>1?d-1:d],b=h[0]/g[0],T=h[1]/g[1],x=t.data.get(s.dataId).values,I=0;for(let k=0;k<u;k++){let w=k*i[0];for(let _=0;_<c;_++){let M=_*b,R=Math.floor(M),E=Math.min(Math.ceil(M),l-1),O=w+R*i[1],G=w+E*i[1],W=M-R,H=1-W;for(let U=0;U<d;U++){let V=U*T,Y=Math.floor(V),j=Math.min(Math.ceil(V),p-1),te=V-Y,ne=1-te,oe=O+Y*i[2],ae=O+j*i[2],se=G+Y*i[2],ie=G+j*i[2],he=H*ne,ye=H*te,ve=W*ne,Fe=W*te;for(let $e=0;$e<m;$e++){let je=x[I++];f[oe+$e]+=je*he,f[ae+$e]+=je*ye,f[se+$e]+=je*ve,f[ie+$e]+=je*Fe}}}}return t.makeTensorInfo([u,p,l,m],"float32",f)}var PB={kernelName:Vm,backendName:"cpu",kernelFunc:nse};function ose(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;ee(o,"resizeNearestNeighbor");let u=y.computeStrides(o.shape),[l,p]=i,[m,c,d,f]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(m*l*p*f),b=[s&&l>1?c-1:c,s&&p>1?d-1:d],T=[s&&l>1?l-1:l,s&&p>1?p-1:p],x=b[0]/T[0],I=b[1]/T[1],k=0;for(let w=0;w<m;w++){let _=w*u[0];for(let M=0;M<l;M++){let R=a?x*(M+.5):x*M,E=Math.min(c-1,s?Math.round(R):Math.floor(R));a&&(E=Math.max(0,E));let O=_+E*u[1];for(let G=0;G<p;G++){let W=a?I*(G+.5):I*G,H=Math.min(d-1,s?Math.round(W):Math.floor(W));a&&(H=Math.max(0,H));let U=O+H*u[2];for(let V=0;V<f;V++){let Y=h[U+V];g[k++]=Y}}}}return t.makeTensorInfo([m,l,p,f],o.dtype,g)}var EB={kernelName:Xo,backendName:"cpu",kernelFunc:ose};function sse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;ee([s,o],"resizeNearestNeighborGrad");let i=y.computeStrides(o.shape),u=y.computeStrides(s.shape),[l,p,m,c]=o.shape,[,d,f]=s.shape,h=new Float32Array(l*p*m*c),g=t.data.get(s.dataId).values,b=[a&&d>1?p-1:p,a&&f>1?m-1:m],T=[a&&d>1?d-1:d,a&&f>1?f-1:f],x=b[0]/T[0],I=b[1]/T[1],k=1/x,w=1/I,_=Math.ceil(k)*2+2,M=Math.ceil(w)*2+2;for(let R=0;R<l;R++){let E=R*i[0];for(let O=0;O<p;O++){let G=E+O*i[1],W=Math.floor(O*k),H=Math.floor(W-_/2);for(let U=0;U<m;U++){let V=G+U*i[2],Y=Math.floor(U*w),j=Math.floor(Y-M/2);for(let te=0;te<c;te++){let ne=0;for(let oe=0;oe<_;oe++){let ae=oe+H;if(ae<0||ae>=d)continue;let se=E+ae*u[1],ie=ae*x,he=Math.min(p-1,a?Math.round(ie):Math.floor(ie));if(O===he)for(let ye=0;ye<M;ye++){let ve=ye+j;if(ve<0||ve>=f)continue;let Fe=se+ve*u[2],$e=ve*I,je=Math.min(m-1,a?Math.round($e):Math.floor($e));U===je&&(ne+=g[Fe+te])}}h[V+te]=ne}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var FB={kernelName:Km,backendName:"cpu",kernelFunc:sse};function ase(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n;ee(o,"reverse");let a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return Jr({inputs:{x:o},backend:t});let u=new bt(o.shape,o.dtype),l=t.bufferSync(o);for(let p=0;p<u.size;p++){let m=u.indexToLoc(p),c=m.slice();i.forEach(d=>c[d]=o.shape[d]-1-c[d]),u.set(l.get(...c),...m)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}var LB={kernelName:Qo,backendName:"cpu",kernelFunc:ase};var $B={kernelName:Za,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[l,p,m,c]=n.shape,[d,f]=C.getImageCenter(a,p,m),h=255,g=Math.sin(o),b=Math.cos(o),T=i.data.get(n.dataId).values;for(let I=0;I<l;I++){let k=I*m*p*c;for(let w=0;w<p;w++){let _=w*(m*c);for(let M=0;M<m;M++){let R=M*c;for(let E=0;E<c;E++){let O=[l,w,M,E],G=O[2],W=O[1],H=(G-d)*b-(W-f)*g,U=(G-d)*g+(W-f)*b;H=Math.round(H+d),U=Math.round(U+f);let V=s;if(typeof s!="number"&&(E===3?V=h:V=s[E]),H>=0&&H<m&&U>=0&&U<p){let j=U*(m*c),te=H*c,ne=k+j+te+E;V=T[ne]}let Y=k+_+R+E;u[Y]=V}}}}return{dataId:i.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var ise=Pe(Va,r=>{let e=Math.floor(r);return r-e<.5?Math.floor(r):r-e>.5?Math.ceil(r):e%2===0?e:e+1}),BB={kernelName:Va,backendName:"cpu",kernelFunc:ise};function use(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:m}=C.calculateShapes(s,o,a),c=!0,d=t.bufferSync(o),f=t.bufferSync(s),h=Su(d,f,a,m,l,u,i,p,0,c);return t.makeTensorInfo(a,h.dtype,h.values)}var OB={kernelName:Ha,backendName:"cpu",kernelFunc:use};function lse(r,e){let t=0,n=r.length,o=0;for(;t<n;)o=Math.floor((t+n)/2),r[o]<e?t=o+1:n=o;return n}function pse(r,e){let t=0,n=r.length,o=0;for(;t<n;)o=Math.floor((t+n)/2),r[o]<=e?t=o+1:n=o;return n}function zB(r,e,t,n,o,s){let a=y.getArrayFromDType("int32",t*o);for(let i=0;i<t;++i){let u=r.slice(i*n,(i+1)*n),l=i*o;for(let p=0;p<o;++p)a[l+p]=s==="left"?lse(u,e[p+l]):pse(u,e[p+l])}return a}function mse(r){let{inputs:e,backend:t,attrs:n}=r,{sortedSequence:o,values:s}=e,{side:a}=n,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=zB(i,u,o.shape[0],o.shape[1],s.shape[1],a);return t.makeTensorInfo(s.shape,"int32",l)}var GB={kernelName:Hm,backendName:"cpu",kernelFunc:mse};function cse(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e;ee([n,o,s],"select");let a=n.shape.length,i=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=Pt(o.dtype,s.dtype),m=y.makeZerosTypedArray(y.sizeFromShape(o.shape),p),c=0,d=a===0||a>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let f=0;f<i.length;f++)for(let h=0;h<d;h++)i[f]===1?m[c++]=u[f]:m[c++]=l[f];return t.makeTensorInfo(o.shape,p,m)}var WB={kernelName:Ns,backendName:"cpu",kernelFunc:cse};var dse=C.SELU_SCALEALPHA,fse=C.SELU_SCALE,hse=Pe(tu,r=>r>=0?fse*r:dse*(Math.exp(r)-1)),UB={kernelName:tu,backendName:"cpu",kernelFunc:hse};var gse=Pe(ru,r=>r<0?-1:r>0?1:0),KB={kernelName:ru,backendName:"cpu",kernelFunc:gse};var bse=Pe(es,r=>Math.sin(r)),VB={kernelName:es,backendName:"cpu",kernelFunc:bse};var yse=Pe(qa,r=>Math.sinh(r)),HB={kernelName:qa,backendName:"cpu",kernelFunc:yse};var Tse=11920928955078125e-23,qB=Math.log(Tse)+2,xse=Pe(nu,r=>{let e=r>-qB,t=r<qB,n=Math.exp(r),o;return t?o=n:e?o=r:o=Math.log(1+n),o}),jB={kernelName:nu,backendName:"cpu",kernelFunc:xse};function Ise(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;ee([o],"spaceToBatchND");let i=y.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let w=1+s.length;w<o.shape.length;++w)u.push([0,0]);let l=Lx.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=C.getReshaped(l.shape,s,i,!1),m=C.getPermuted(p.length,s.length,!1),c=C.getReshapedPermuted(l.shape,s,i,!1),h=rt({inputs:{x:l},backend:t,attrs:{shape:p}}),T=qt({inputs:{x:h},backend:t,attrs:{perm:m}}),k=rt({inputs:{x:T},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(T),k}var XB={kernelName:_s,backendName:"cpu",kernelFunc:Ise};function Cse(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=t.data.get(a.dataId).values[0],[m,c,d,f,h]=wx(i,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(c,n.dtype,m),t.makeTensorInfo([c[0]],o.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var YB={kernelName:Yu,backendName:"cpu",kernelFunc:Cse};function kse(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.data.get(o.dataId).values),i=t.data.get(n.dataId).values,u=Array.from(t.data.get(s.dataId).values),[l,p,m]=Nx(i,n.shape,n.dtype,a,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}var ZB={kernelName:ou,backendName:"cpu",kernelFunc:kse};function Sse(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=df(a,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var QB={kernelName:Zu,backendName:"cpu",kernelFunc:Sse};function vse(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=df(a,n.shape,n.dtype,i,u);return t.makeTensorInfo(p,n.dtype,l)}var JB={kernelName:Qu,backendName:"cpu",kernelFunc:vse};function Ase(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1,f=t.bufferSync(o),h;switch(s.dtype){case"bool":{let g=t.bufferSync(s),b=Boolean(t.data.get(a.dataId).values[0]);h=Su(f,g,i,c,p,l,u,m,b,d);break}case"float32":{let g=t.bufferSync(s),b=t.data.get(a.dataId).values[0];h=Su(f,g,i,c,p,l,u,m,b,d);break}case"int32":{let g=t.bufferSync(s),b=t.data.get(a.dataId).values[0];h=Su(f,g,i,c,p,l,u,m,b,d);break}case"string":{let g=t.bufferSync(s),b=y.decodeString(t.data.get(a.dataId).values[0]);h=Su(f,g,i,c,p,l,u,m,b,d);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(i,h.dtype,h.values)}var eO={kernelName:Ju,backendName:"cpu",kernelFunc:Ase};function wse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(m=>{let c=[...p];c[i]=m;let d=ia({inputs:{x:o},backend:t,attrs:{begin:l,size:c}});return l[i]+=m,d})}var tO={kernelName:Ms,backendName:"cpu",kernelFunc:wse};var rO={kernelName:wi,backendName:"cpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e;ee(t,"square");let o=n.data.get(t.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){let u=o[i];s[i]=u*u}return{dataId:n.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};var Nse=Pe(Es,(r,e)=>{let t=e;return isNaN(r)?NaN:r>0?1:t.alpha}),nO={kernelName:Es,backendName:"cpu",kernelFunc:Nse};function Dse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n;ee(o,"stridedSlice");let{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),k;if(h)k=rt({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),_=ia({inputs:{x:o},backend:t,attrs:{begin:T,size:w}});k=rt({inputs:{x:_},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(_)}else{let w=t.bufferSync(o),_=Dx(d,w,I,T);k=t.makeTensorInfo(f,_.dtype,_.values)}return k}var oO={kernelName:ja,backendName:"cpu",kernelFunc:Dse};function _se(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:m}=e,c=t.data.get(p.dataId).values,d=t.data.get(m.dataId).values,[f,h]=Up(c,d,o,s,a,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(m.shape,"int32",h)]}var sO={kernelName:Ni,backendName:"cpu",kernelFunc:_se};function Mse(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values[0],[l,p,m]=Kp(i,u,o),c=p.length;return[t.makeTensorInfo([c,2],"int32",l),t.makeTensorInfo([c],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(m))]}var aO={kernelName:el,backendName:"cpu",kernelFunc:Mse};function Rse(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=t.data.get(s.dataId).values,i=Vp(a,o);return t.makeTensorInfo(s.shape,"int32",i)}var iO={kernelName:tl,backendName:"cpu",kernelFunc:Rse};var Pse=Pe(is,r=>Math.tan(r)),uO={kernelName:is,backendName:"cpu",kernelFunc:Pse};var Ese=Pe(us,r=>Math.tanh(r)),lO={kernelName:us,backendName:"cpu",kernelFunc:Ese};function Fse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;ee(o,"tile");let a=_x(t.bufferSync(o),s);return t.makeTensorInfo(a.shape,a.dtype,a.values)}var pO={kernelName:Dn,backendName:"cpu",kernelFunc:Fse};function Lse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n;ee(o,"topk");let i=t.data.get(o.dataId).values,[u,l]=Mx(i,o.shape,o.dtype,s,a);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}var mO={kernelName:Xa,backendName:"cpu",kernelFunc:Lse};function $se(r){let{inputs:e,attrs:t,backend:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=t,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=y.computeStrides(o.shape),T=b[0],x=b[1],I=b[2],k=y.computeStrides(g),w=k[0],_=k[1],M=k[2],R=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));R.fill(u);let E=n.data.get(o.dataId).values,O=n.data.get(s.dataId).values;for(let W=0;W<p;++W){let H=s.shape[0]===1?O:O.subarray(W*8,W*8+8);for(let U=0;U<f;++U)for(let V=0;V<h;++V)for(let Y=0;Y<d;++Y){let j,te=H[6]*V+H[7]*U+1;if(te===0)continue;let ne=(H[0]*V+H[1]*U+H[2])/te,oe=(H[3]*V+H[4]*U+H[5])/te,ae=cO(ne,c,i),se=cO(oe,m,i);switch(a){case"nearest":j=Wse(E,m,c,T,x,I,W,se,ae,Y,u);break;case"bilinear":j=Use(E,m,c,T,x,I,W,se,ae,Y,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let ie=W*w+U*_+V*M+Y;R[ie]=j}return n.makeTensorInfo(g,o.dtype,R)}return{dataId:n.write(R,g,o.dtype),shape:o.shape,dtype:o.dtype}}var dO={kernelName:Ya,backendName:"cpu",kernelFunc:$se};function cO(r,e,t){switch(t){case"reflect":return Bse(r,e);case"wrap":return Ose(r,e);case"nearest":return Gse(r,e);case"constant":default:return zse(r,e)}}function Bse(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{let n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return y.clamp(0,t,e-1)}function Ose(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{let n=e-1;t-=e*Math.trunc(t/n)}return y.clamp(0,t,e-1)}function zse(r,e){return r}function Gse(r,e){return y.clamp(0,r,e-1)}function mg(r,e,t,n,o,s,a,i,u,l,p){let m=a*n+i*o+u*s+l;return 0<=i&&i<e&&0<=u&&u<t?r[m]:p}function Wse(r,e,t,n,o,s,a,i,u,l,p){let m=Math.round(i),c=Math.round(u);return mg(r,e,t,n,o,s,a,m,c,l,p)}function Use(r,e,t,n,o,s,a,i,u,l,p){let m=Math.floor(i),c=Math.floor(u),d=m+1,f=c+1,h=(f-u)*mg(r,e,t,n,o,s,a,m,c,l,p)+(u-c)*mg(r,e,t,n,o,s,a,m,f,l,p),g=(f-u)*mg(r,e,t,n,o,s,a,d,c,l,p)+(u-c)*mg(r,e,t,n,o,s,a,d,f,l,p);return(d-i)*h+(i-m)*g}function Kse(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;ee(s,"unique");let a=n.data.get(s.dataId).values,{outputValues:i,outputShape:u,indices:l}=Rx(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}var fO={kernelName:qm,backendName:"cpu",kernelFunc:Kse};function Vse(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape.length,i=o.shape[s],u=new Array(a-1),l=0;for(let d=0;d<a;d++)d!==s&&(u[l++]=o.shape[d]);let p=new Array(a).fill(0),m=o.shape.slice();m[s]=1;let c=new Array(i);for(let d=0;d<c.length;d++){p[s]=d;let f=ia({inputs:{x:o},backend:t,attrs:{begin:p,size:m}});c[d]=rt({inputs:{x:f},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(f)}return c}var hO={kernelName:Rs,backendName:"cpu",kernelFunc:Vse};function Hse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n;ee(o,"unsortedSegmentSum");let i=o.shape.length,u=s.shape.length,l=[],p=[],m=i-u,c=s;for(let f=0;f<m;++f){let h=gf({inputs:{input:c},backend:t,attrs:{dim:f+1}});c=h,p.push(h)}for(let f=0;f<a;++f){let h=y.createScalarValue(f,"int32"),g=t.makeTensorInfo([],"int32",h),b=aN({inputs:{a:g,b:c},backend:t}),T=oa({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),x=zp({inputs:{a:T,b:o},backend:t}),I=vu({inputs:{x},backend:t,attrs:{axis:0,keepDims:!1}});l.push(I),p.push(g),p.push(b),p.push(T),p.push(x),p.push(I)}let d=$N({inputs:l,backend:t,attrs:{axis:0}});return p.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}var gO={kernelName:rl,backendName:"cpu",kernelFunc:Hse};var qse=[WL,JF,UL,KL,oL,VL,HL,qL,jL,XL,YL,ZL,QL,JL,e$,r$,n$,o$,s$,GL,a$,i$,u$,l$,nL,sL,p$,eL,m$,d$,f$,h$,g$,b$,y$,T$,x$,I$,C$,k$,S$,v$,A$,w$,N$,D$,_$,M$,R$,P$,F$,FL,L$,aL,$$,iL,B$,uL,O$,z$,G$,lL,W$,U$,K$,V$,H$,pL,mL,tL,q$,c$,j$,X$,Y$,LL,cL,dL,Z$,fL,Q$,J$,eB,tB,rB,nB,oB,hL,sB,aB,iB,uB,pB,mB,cB,gL,dB,fB,bB,bL,yL,yB,TB,xB,TL,IB,SB,vB,Lx,AB,$L,IL,wB,NB,DB,_B,rL,ug,MB,BL,OL,zL,RB,PB,EB,FB,LB,$B,BB,AL,OB,GB,WB,UB,NL,KB,VB,HB,DL,hB,jB,XB,YB,ZB,QB,JB,eO,tO,ML,rO,RL,nO,oO,sO,aO,iO,PL,E$,uO,lO,pO,mO,dO,xL,fO,hO,gO,CB];for(let r of qse)su(r);var xf={};qe(xf,{assertNotComplex:()=>fi,bindCanvasToFramebuffer:()=>rae,bindColorTextureToFramebuffer:()=>hg,bindTextureToProgramUniformSampler:()=>JN,bindTextureUnit:()=>xO,bindVertexBufferToProgramAttribute:()=>Wx,callAndCheck:()=>Te,canBeRepresented:()=>GN,createFragmentShader:()=>UN,createFramebuffer:()=>YN,createProgram:()=>KN,createStaticIndexBuffer:()=>qN,createStaticVertexBuffer:()=>HN,createTexture:()=>jN,createVertexShader:()=>WN,getBatchDim:()=>wu,getExtensionOrThrow:()=>bf,getFramebufferErrorMessage:()=>IO,getMaxTexturesInShader:()=>rD,getNumChannels:()=>eae,getProgramUniformLocation:()=>QN,getProgramUniformLocationOrThrow:()=>ZN,getRowsCols:()=>Nu,getShapeAs3D:()=>Tf,getTextureShapeFromLogicalShape:()=>eD,getWebGLDisjointQueryTimerVersion:()=>nD,getWebGLErrorMessage:()=>TO,getWebGLMaxTextureSize:()=>tD,hasExtension:()=>to,isCapableOfRenderingToFloatTexture:()=>oD,isDownloadFloatTextureEnabled:()=>sD,isReshapeFree:()=>Fl,isWebGLFenceEnabled:()=>aD,isWebGLVersionEnabled:()=>Kx,linkProgram:()=>VN,logShaderSourceAndInfoLog:()=>Gx,resetMaxTextureSize:()=>nae,resetMaxTexturesInShader:()=>oae,unbindColorTextureFromFramebuffer:()=>Ux,unbindTextureUnit:()=>tae,validateFramebuffer:()=>yf,validateProgram:()=>fg,validateTextureSize:()=>XN});var qp={},$x={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function BN(r,e){qp[r]=e}function eo(r,e){if(!(r in qp)||e!=null){let n=Xse(r,e);if(n!==null)qp[r]=n;else return console.log("Could not get context for WebGL version",r),null}let t=qp[r];return t==null||t.isContextLost()?(delete qp[r],eo(r)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),qp[r])}function jse(r){if(typeof OffscreenCanvas<"u"&&r===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Xse(r,e){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=e??jse(r);return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete qp[r]},!1),$().getBool("SOFTWARE_WEBGL_ENABLED")&&($x.failIfMajorPerformanceCaveat=!1),r===1?t.getContext("webgl",$x)||t.getContext("experimental-webgl",$x):t.getContext("webgl2",$x)}function jp(r,e){return[e,r]}function bO(r,e){return r*e}function cg(r){let e=y.sizeFromShape(r),t=Math.ceil(e/4);return y.sizeToSquarishShape(t)}function Ui(r,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(r/2))]}function yO(r,e){let[t,n]=Ui(r,e);return t*n*4}function dg(r,e){let t=r,n,o,s,a,i,u,l,p,m,c;return $().getNumber("WEBGL_VERSION")===2?(n=t.R32F,o=t.R16F,s=t.RGBA16F,a=t.RGBA32F,i=t.RED,l=4,p=1,m=t.HALF_FLOAT,c=t.FLOAT,u=t.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,a=t.RGBA,i=r.RGBA,l=4,p=4,m=e!=null?e.HALF_FLOAT_OES:null,c=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:p,textureTypeHalfFloat:m,textureTypeFloat:c}}function Te(r,e){let t=e();return $().getBool("DEBUG")&&Yse(r),t}function Yse(r){let e=r.getError();if(e!==r.NO_ERROR)throw new Error("WebGL Error: "+TO(r,e))}var Zse=596e-10,Qse=65504;function GN(r){return!!($().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||Zse<Math.abs(r)&&Math.abs(r)<Qse)}function TO(r,e){switch(e){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function bf(r,e){return Au(r,()=>r.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function WN(r,e){let t=Au(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Te(r,()=>r.shaderSource(t,e)),Te(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function UN(r,e){let t=Au(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Te(r,()=>r.shaderSource(t,e)),Te(r,()=>r.compileShader(t)),$().get("ENGINE_COMPILE_ONLY"))return t;if(r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw Gx(e,r.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var Jse=/ERROR: [0-9]+:([0-9]+):/g;function Gx(r,e){let t=Jse.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(r);return}let n=+t[1],o=r.split(`
`),s=o.length.toString().length+2,a=o.map((m,c)=>y.rightPad((c+1).toString(),s)+m),i=0;for(let m=0;m<a.length;m++)i=Math.max(a[m].length,i);let u=a.slice(0,n-1),l=a.slice(n-1,n),p=a.slice(n);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${y.rightPad(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join(`
`))}function KN(r){return Au(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function VN(r,e){if(Te(r,()=>r.linkProgram(e)),!$().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(e,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function fg(r,e){if(Te(r,()=>r.validateProgram(e)),r.getProgramParameter(e,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function HN(r,e){let t=Au(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Te(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Te(r,()=>r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function qN(r,e){let t=Au(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Te(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t)),Te(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function eae(){return $().getNumber("WEBGL_VERSION")===2?1:4}function jN(r){return Au(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function XN(r,e){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||e<=0){let n=`[${r}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>t||e>t){let n=`[${r}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function YN(r){return Au(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Wx(r,e,t,n,o,s,a){let i=r.getAttribLocation(e,t);return i===-1?!1:(Te(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Te(r,()=>r.vertexAttribPointer(i,o,r.FLOAT,!1,s,a)),Te(r,()=>r.enableVertexAttribArray(i)),!0)}function xO(r,e,t){CO(r,t),Te(r,()=>r.activeTexture(r.TEXTURE0+t)),Te(r,()=>r.bindTexture(r.TEXTURE_2D,e))}function tae(r,e){CO(r,e),Te(r,()=>r.activeTexture(r.TEXTURE0+e)),Te(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function ZN(r,e,t){return Au(r,()=>r.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function QN(r,e,t){return r.getUniformLocation(e,t)}function JN(r,e,t,n){Te(r,()=>xO(r,e,n)),Te(r,()=>r.uniform1i(t,n))}function rae(r){Te(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),Te(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),Te(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function hg(r,e,t){Te(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Te(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0))}function Ux(r,e){Te(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),Te(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function yf(r){let e=r.checkFramebufferStatus(r.FRAMEBUFFER);if(e!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+IO(r,e))}function IO(r,e){switch(e){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Au(r,e,t){let n=Te(r,()=>e());if(n==null)throw new Error(t);return n}function CO(r,e){let t=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+r.TEXTURE0;if(n<r.TEXTURE0||n>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function wu(r,e=2){return y.sizeFromShape(r.slice(0,r.length-e))}function Nu(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Tf(r){let e=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(e=[wu(r),...Nu(r)]),e}function eD(r,e=!1){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=$().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&$().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=t/2),e&&(t=t*2,n=n*2,r=r.map((i,u)=>u>=r.length-2?y.nearestLargerEven(r[u]):r[u]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=y.squeezeShape(r).newShape);let o=y.sizeFromShape(r),s=null;r.length<=1&&o<=t?s=[1,o]:r.length===2&&r[0]<=t&&r[1]<=t?s=r:r.length===3&&r[0]*r[1]<=t&&r[2]<=t?s=[r[0]*r[1],r[2]]:r.length===3&&r[0]<=t&&r[1]*r[2]<=t?s=[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t?s=[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t&&(s=[r[0],r[1]*r[2]*r[3]]);let a=s!=null&&Math.max(...s)>n&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||a)if(e){let i=wu(r),u=2,l=2;r.length&&([u,l]=Nu(r)),o=i*(u/2)*(l/2),s=y.sizeToSquarishShape(o).map(p=>p*2)}else s=y.sizeToSquarishShape(o);return s}function Bx(r){return r%2===0}function Fl(r,e){if(r=r.slice(-2),e=e.slice(-2),y.arraysEqual(r,e)||!r.length||!e.length||r[0]===0||r[1]===0||e[0]===0||e[1]===0)return!0;if(r.length!==e.length){let t=r.slice(-1)[0],n=e.slice(-1)[0];if(t===n||Bx(t)&&Bx(n)&&(r[0]===1||e[0]===1))return!0}return r[1]===e[1]&&Bx(r[0])&&Bx(e[0])}var Ox,zx;function tD(r){if(Ox==null){let e=eo(r);Ox=e.getParameter(e.MAX_TEXTURE_SIZE)}return Ox}function nae(){Ox=null}function oae(){zx=null}function rD(r){if(zx==null){let e=eo(r);zx=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,zx)}function nD(r){if(r===0)return 0;let e,t=eo(r);return to(t,"EXT_disjoint_timer_query_webgl2")&&r===2?e=2:to(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function to(r,e){return r.getExtension(e)!=null}function Kx(r){try{if(eo(r)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function oD(r){if(r===0)return!1;let e=eo(r);if(r===1){if(!to(e,"OES_texture_float"))return!1}else if(!to(e,"EXT_color_buffer_float"))return!1;return zN(e)}function sD(r){if(r===0)return!1;let e=eo(r);if(r===1){if(!to(e,"OES_texture_float")||!to(e,"WEBGL_color_buffer_float"))return!1}else{if(to(e,"EXT_color_buffer_float"))return zN(e);let n="EXT_color_buffer_half_float";if(to(e,n)){let o=e.getExtension(n);return sae(e,o)}return!1}return zN(e)}function zN(r){let e=dg(r),t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatFloat,n,o,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(t),r.deleteFramebuffer(s),a}function sae(r,e){let t=dg(r,e),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatHalfFloat,o,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(a),i}function aD(r){return r!==2?!1:eo(r).fenceSync!=null}function fi(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var Me=$();Me.registerFlag("HAS_WEBGL",()=>Me.getNumber("WEBGL_VERSION")>0);Me.registerFlag("WEBGL_VERSION",()=>Kx(2)?2:Kx(1)?1:0);Me.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Me.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Me.get("WEBGL_VERSION")===2);Me.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Me.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Me.registerFlag("WEBGL_PACK",()=>Me.getBool("HAS_WEBGL"));Me.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_CLIP",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_REDUCE",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_LAZILY_UNPACK",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_CONV_IM2COL",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>tD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>rD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Me.getNumber("WEBGL_VERSION");return r===0?0:nD(r)});Me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Me.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!sl.isMobile());Me.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>oD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Me.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Me.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Me.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>sD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_FENCE_API_ENABLED",()=>aD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Me.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Me.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Me.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>sl.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Me.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Me.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Me.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Me.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Me.registerFlag("WEBGL_EXP_CONV",()=>!1);Me.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Me.getBool("IS_TEST"));Me.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Me.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Me.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Me.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function jt(){let r,e,t,n,o,s,a,i,u,l;return $().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",e="in",t="out",n="in",o="texture",s="outputColor",a="out vec4 outputColor;",i=$().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",e="attribute",t="varying",n="varying",o="texture2D",s="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:e,varyingVs:t,varyingFs:n,texture2D:o,output:s,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function hi(r,e,t="index"){let n=y.computeStrides(e);return n.map((o,s)=>{let a=`int ${r[s]} = ${t} / ${o}`,i=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${a}; ${i};`}).join("")}function Xp(r,e,t="index"){let n=y.computeStrides(e);return n.map((o,s)=>{let a=`int ${r[s]} = ${t} / outShapeStrides[${s}]`,i=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${a}; ${i};`}).join("")}function aae(r,e){let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function kO(r,e,t="index"){let n=r.map((s,a)=>a),o=aae(n,e);return o.map((s,a)=>{let i=`int ${r[a]} = ${t} / ${o[a]}`,u=a===o.length-1?`int ${r[a+1]} = ${t} - ${r[a]} * ${o[a]}`:`index -= ${r[a]} * ${o[a]}`;return`${i}; ${u};`}).join("")}function If(r){let e=y.computeStrides(r).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Cf(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Vx=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:SO}=C;function vO(r,e,t){let n=[];if(r.forEach(d=>{let f=y.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?n.push(`uniform float ${d.name}${f>1?`[${f}]`:""};`):(n.push(`uniform sampler2D ${d.name};`),n.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){let{uniformShape:h}=Hx(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${d.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{n.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(d=>iae(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,i=jt(),u=pae(i),l,p,m=dae(i);return e.isPacked?(l=uae(e.logicalShape,a,t.enableShapeUniforms),p=cae(i)):(l=lae(e.logicalShape,a,t.enableShapeUniforms),p=mae(i)),t.packedInputs&&(m+=bae),[m,u,p,o,l,s,t.userCode].join(`
`)}function Sf(r,e=!1){let t=r.shapeInfo.logicalShape;switch(t.length){case 0:return Dae(r,e);case 1:return Mae(r,e);case 2:return Pae(r,e);case 3:return Fae(r,e);case 4:return $ae(r,e);case 5:return Bae(r);case 6:return Oae(r);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function AO(r,e){switch(r.shapeInfo.logicalShape.length){case 0:return Nae(r);case 1:return _ae(r,e);case 2:return Rae(r,e);case 3:return Eae(r,e);default:return Lae(r,e)}}function iae(r,e,t=!1,n){let o="";t?o+=AO(r,n):o+=Sf(r,n);let s=r.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(t?o+=zae(r,e):o+=Gae(r,e)),o}function uae(r,e,t){switch(r.length){case 0:return wO();case 1:return yae(r,e,t);case 2:return Aae(r,e,t);case 3:return xae(r,e,t);default:return Cae(r,e,t)}}function lae(r,e,t){switch(r.length){case 0:return wO();case 1:return Tae(r,e,t);case 2:return wae(r,e,t);case 3:return Iae(r,e,t);case 4:return kae(r,e,t);case 5:return Sae(r,e);case 6:return vae(r,e);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function pae(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function mae(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function cae(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function dae(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${fae}
    ${hae}
    ${gae}
  `}var fae=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,hae=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,gae=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,bae=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function wO(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function yae(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function Tae(r,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function xae(r,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Iae(r,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Xp(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=hi(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function Cae(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),a=s,i="",u="b, r, c";for(let l=2;l<r.length-1;l++)a*=r[r.length-l-1],i=`
      int b${l} = index / ${a};
      index -= b${l} * ${a};
    `+i,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${i}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function kae(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Xp(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=hi(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function Sae(r,e){let t=hi(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function vae(r,e){let t=hi(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Aae(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(y.arraysEqual(r,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function wae(r,e,t){return y.arraysEqual(r,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:r[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Yp(r){return`offset${r}`}function Nae(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=jt();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function Dae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Yp(t);if(e)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;let[i,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function _ae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape,s=jt();if(e)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function Mae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${vf(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],a=o[1];if(a===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Yp(t);return a===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Rae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=s[0],i=s[1],u=jt();if(s!=null&&y.arraysEqual(t,s))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function Pae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&y.arraysEqual(t,s)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let c=s[0],d=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${c}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:a,keptDims:i}=y.squeezeShape(t),u=a;if(u.length<t.length){let c=Af(r,u),d=["row","col"];return`
      ${Sf(c,e)}
      float ${o}(int row, int col) {
        return ${o}(${wf(d,i)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${vf(r)}
      }
    `;let l=s[0],p=s[1],m=Yp(n);return p===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${m}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${m}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${m}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${m}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${m};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${m};
    vec2 uv = uvFromFlat(${l}, ${p}, index);
    return sampleTexture(${n}, uv);
  }
`}function Eae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let c=t.slice(1),d=[1,2],f=Af(r,c),h=["b","row","col"];return`
        ${AO(f,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${wf(h,d)});
        }
      `}let i=jt();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `;let u=a[0],l=a[1],p=Math.ceil(t[2]/2),m=p*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${m}, ${p}, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `}function Fae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],a=t[2],{newShape:i,keptDims:u}=y.squeezeShape(t),l=i;if(l.length<t.length){let h=Af(r,l),g=["row","col","depth"];return`
        ${Sf(h,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${wf(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${vf(r)}
      }
    `;let p=r.shapeInfo.texShape,m=p[0],c=p[1],d=r.shapeInfo.flatOffset;if(c===s&&d==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${c}.0, ${m}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(c===a&&d==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `;let f=Yp(n);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${m}, ${c}, index);
        return sampleTexture(${n}, uv);
      }
  `}function Lae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=jt();if(e)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,a=s.length,i=r.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],p=u[1],m=Math.ceil(s[a-1]/2),c=m*Math.ceil(s[a-2]/2),d="int b, int row, int col",f=`b * ${c} + (row / 2) * ${m} + (col / 2)`;for(let h=2;h<a-1;h++)d=`int b${h}, `+d,c*=s[a-h-1],f=`b${h} * ${c} + `+f;return`
    vec4 ${n}(${d}) {
      int index = ${f};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});
      return ${o.texture2D}(${t}, uv);
    }
  `}function $ae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],a=t[2]*s,i=t[1]*a,{newShape:u,keptDims:l}=y.squeezeShape(t);if(u.length<t.length){let T=Af(r,u),x=["row","col","depth","depth2"];return`
      ${Sf(T,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${wf(x,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${s}, 1)));
        ${vf(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,c=m[0],d=m[1],f=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(d===i&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${f}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(d===s&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;let b=Yp(n);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${b});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${c}, ${d}, index + ${b});
      return sampleTexture(${n}, uv);
    }
  `}function Bae(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,a=e[2]*s,i=e[1]*a,{newShape:u,keptDims:l}=y.squeezeShape(e);if(u.length<e.length){let h=Af(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${Sf(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${wf(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${s}, ${o})) +
          depth3;
        ${vf(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,c=m[0],d=m[1];if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${c}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===o&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${c}.0);
        return sampleTexture(${t}, uv);
      }
    `;let f=Yp(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${s} +
          depth2 * ${o} + depth3 + ${f};
      vec2 uv = uvFromFlat(${c}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Oae(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(e);if(o.length<e.length){let g=Af(r,o),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${Sf(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${wf(b,s)});
      }
    `}let a=e[5],i=e[4]*a,u=e[3]*i,l=e[2]*u,p=e[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${l}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${vf(r)}
      }
    `;let m=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,d=c[0],f=c[1];if(f===p&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===a&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Yp(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${l} + depth * ${u} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function vf(r){let e=r.name,t=y.sizeFromShape(r.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function zae(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=SO(r.shapeInfo.logicalShape,e.logicalShape),u=Ve(a),l=a-s,p,m=["x","y","z","w","u","v"];s===0?p="":a<2&&i.length>=1?p="coords = 0;":p=i.map(T=>`coords.${m[T+l]} = 0;`).join(`
`);let c="";a<2&&s>0?c="coords":c=r.shapeInfo.logicalShape.map((T,x)=>`coords.${m[x+l]}`).join(", ");let d="return outputValue;",h=y.sizeFromShape(r.shapeInfo.logicalShape)===1,b=y.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!b)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!b)a===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(i.length){let T=s-2,x=s-1;i.indexOf(T)>-1&&i.indexOf(x)>-1?d="return vec4(outputValue.x);":i.indexOf(T)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(x)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${p}
      vec4 outputValue = get${n}(${c});
      ${d}
    }
  `}function Gae(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=e.texShape,a=r.shapeInfo.texShape,i=r.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!r.shapeInfo.isUniform&&i===u&&r.shapeInfo.flatOffset==null&&y.arraysEqual(a,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let l=Ve(u),p=SO(r.shapeInfo.logicalShape,e.logicalShape),m=u-i,c,d=["x","y","z","w","u","v"];i===0?c="":u<2&&p.length>=1?c="coords = 0;":c=p.map(h=>`coords.${d[h+m]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=r.shapeInfo.logicalShape.map((h,g)=>`coords.${d[g+m]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${c}
      return get${n}(${f});
    }
  `}function Ve(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Hx(r,e,t){let{newShape:n,keptDims:o}=y.squeezeShape(e),s=e.length,a=r&&s===3&&e[0]===1,i=a?e.slice(1):n,u=!r&&s>1&&!y.arraysEqual(e,t)&&n.length<s||a;return{useSqueezeShape:u,uniformShape:u?i:e,keptDims:o}}function Af(r,e){let t=JSON.parse(JSON.stringify(r));return t.shapeInfo.logicalShape=e,t}function wf(r,e){return e.map(t=>r[t]).join(", ")}function DO(r,e,t,n){let o=t.map((p,m)=>{let c={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:p.isUniform?!1:p.texData.isPacked,flatOffset:null};return p.texData!=null&&p.texData.slice!=null&&p.texData.slice.flatOffset>0&&(c.flatOffset=p.texData.slice.flatOffset),{name:e.variableNames[m],shapeInfo:c}}),s=o.map(p=>p.shapeInfo),a={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},i=vO(o,a,e),u=UN(r.gl,i),l=r.createProgram(u);return $().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:{program:e,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:a,...iD(r,e,l)}}function iD(r,e,t){let n={},o={},s={},a=[],i,u,l,p=null,m=null;m=r.getUniformLocation(t,"NAN",!1),$().getNumber("WEBGL_VERSION")===1&&(p=r.getUniformLocation(t,"INFINITY",!1));let c=!1;for(let d=0;d<e.variableNames.length;d++){let f=e.variableNames[d];n[f]=r.getUniformLocation(t,f,c),n[`offset${f}`]=r.getUniformLocation(t,`offset${f}`,c),e.enableShapeUniforms&&(o[`${f}Shape`]=r.getUniformLocation(t,`${f}Shape`,c),s[`${f}TexShape`]=r.getUniformLocation(t,`${f}TexShape`,c))}return e.enableShapeUniforms&&(i=r.getUniformLocation(t,"outShape",c),l=r.getUniformLocation(t,"outShapeStrides",c),u=r.getUniformLocation(t,"outTexShape",c)),e.customUniforms&&e.customUniforms.forEach((d,f)=>{a[f]=r.getUniformLocation(t,d.name,c)}),{uniformLocations:n,customUniformLocations:a,infLoc:p,nanLoc:m,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}}function NO(r,e){if(r.length!==e.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${e.length} inputs`);r.forEach((t,n)=>{let o=t.logicalShape,s=e[n],a=s.shape;if(!y.arraysEqual(o,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${a} must match`);if(t.isUniform&&s.isUniform)return;let i=t.texShape,u=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function _O(r,e,t,n,o){e.program.enableShapeUniforms||(NO(e.inShapeInfos,t),NO([e.outShapeInfo],[n]));let s=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):r.setOutputMatrixTexture(s.texture,a[0],a[1]),r.setProgram(e.webGLProgram),$().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&r.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&r.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,l)=>{let p=e.program.variableNames[l],m=e.uniformLocations[p],c=e.uniformLocations[`offset${p}`],d=e.inShapesLocations[`${p}Shape`],f=e.inTexShapesLocations[`${p}TexShape`];if(d){let{uniformShape:h}=Hx(e.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(d,new Int32Array(h));break;case 2:r.gl.uniform2iv(d,new Int32Array(h));break;case 3:r.gl.uniform3iv(d,new Int32Array(h));break;case 4:r.gl.uniform4iv(d,new Int32Array(h));break;default:break}}if(f&&r.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),m!=null){if(u.isUniform){if(y.sizeFromShape(u.shape)<2)r.gl.uniform1f(m,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(m,h)}return}u.texData.slice!=null&&c!=null&&r.gl.uniform1i(c,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture.texture,m,l)}});let i=e.outShapeLocation;if(i)switch(n.shape.length){case 1:r.gl.uniform1iv(i,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(i,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(i,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(i,new Int32Array(n.shape));break;default:break}if(e.outShapeStridesLocation){let u=y.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break;default:break}}e.outTexShapeLocation&&r.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&o&&e.program.customUniforms.forEach((u,l)=>{let p=e.customUniformLocations[l],m=o[l];if(u.type==="float")r.gl.uniform1fv(p,m);else if(u.type==="vec2")r.gl.uniform2fv(p,m);else if(u.type==="vec3")r.gl.uniform3fv(p,m);else if(u.type==="vec4")r.gl.uniform4fv(p,m);else if(u.type==="int")r.gl.uniform1iv(p,m);else if(u.type==="ivec2")r.gl.uniform2iv(p,m);else if(u.type==="ivec3")r.gl.uniform3iv(p,m);else if(u.type==="ivec4")r.gl.uniform4iv(p,m);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function MO(r,e,t){let n="";e.concat(t).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!a.isUniform){let u=a.texData.texShape,{useSqueezeShape:l,uniformShape:p,keptDims:m}=Hx(r.packedInputs,a.shape,u),c="",d="",f="";if(p.length===1&&r.packedInputs){let k=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];c=`${k[0]>1}_${k[1]>1}`}else if(p.length===2&&!r.packedInputs)d=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!r.packedInputs){let k=y.computeStrides(p);f=`${k[0]===u[1]}_${k[k.length-1]===u[1]}`}let h=a.shape.length,g=p.length===2&&y.arraysEqual(a.shape,u),b=y.sizeFromShape(a.shape)===1,T=C.getBroadcastDims(a.shape,t.shape),x=!r.packedInputs&&h===t.shape.length&&y.arraysEqual(u,t.texData.texShape),I=r.packedInputs||p.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${x}_${l?m:""}_${p.length}_${b}_${T}_${g}_${c}_${d}_${f}_${I}_${i}`}else{let u=a.isUniform?"uniform":a.texData.texShape;n+=`${a.shape}_${u}_${i}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${$().getNumber("WEBGL_VERSION")}`,s}function Dt(r){return $().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var qx=class{variableNames=["A"];userCode;outputShape;packedInputs=!1;packedOutput=!0;outPackingScheme=0;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e){let t=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Xp(["r","c","d"],e):hi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var jx=class{variableNames=["A"];userCode;packedInputs=!0;packedOutput=!0;outputShape;outPackingScheme=0;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e){let t=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Xp(["r","c","d"],e):hi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var Xx=class{variableNames=["A"];userCode;outputShape;outTexUsage=3;constructor(e){let t=jt();this.outputShape=e,this.userCode=`
      ${Vx}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var Zx=class{variableNames=["A"];userCode;outputShape;packedInputs=!0;packedOutput=!1;outTexUsage=3;constructor(e){let t=jt();this.outputShape=e,this.userCode=`
      ${Vx}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var Kae={R:0,G:1,B:2,A:3},gg=class{variableNames=["A"];userCode;outputShape;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e,t=!1,n="RGBA"){let o=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){let u=n[i];a+=`
          if(offset == ${i}) {
            result = values[${Kae[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Cf():If(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${a}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var Qx=class{variableNames=["A"];userCode;outputShape;packedInputs=!1;packedOutput=!0;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e,t=!1){let n=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let u=a*2+i;o+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Cf():If(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var SD={};qe(SD,{bindVertexProgramAttributeStreams:()=>gD,createBufferFromOutputTexture:()=>TD,createFloat16MatrixTexture:()=>cD,createFloat16PackedMatrixTexture:()=>hD,createFloat32MatrixTexture:()=>mD,createIndexBuffer:()=>pD,createPackedMatrixTexture:()=>fD,createUnsignedBytesMatrixTexture:()=>dD,createVertexBuffer:()=>lD,createVertexShader:()=>uD,downloadByteEncodedFloatMatrixFromOutputTexture:()=>ID,downloadFloat32MatrixFromBuffer:()=>xD,downloadMatrixFromPackedOutputTexture:()=>kD,downloadPackedMatrixFromBuffer:()=>CD,getInternalFormatForFloat16MatrixTexture:()=>eI,getInternalFormatForFloat16PackedMatrixTexture:()=>nI,getInternalFormatForFloat32MatrixTexture:()=>Jx,getInternalFormatForPackedMatrixTexture:()=>rI,getInternalFormatForUnsignedBytesMatrixTexture:()=>tI,uploadDenseMatrixToTexture:()=>bD,uploadPixelDataToTexture:()=>yD});function uD(r){let e=jt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return WN(r,t)}function lD(r){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return HN(r,e)}function pD(r){let e=new Uint16Array([0,1,2,2,1,3]);return qN(r,e)}function bg(r,e,t,n,o,s){XN(e,t);let a=jN(r),i=r.TEXTURE_2D;return Te(r,()=>r.bindTexture(i,a)),Te(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Te(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Te(r,()=>r.texParameteri(i,r.TEXTURE_MIN_FILTER,r.NEAREST)),Te(r,()=>r.texParameteri(i,r.TEXTURE_MAG_FILTER,r.NEAREST)),$().getNumber("WEBGL_VERSION")===1?Te(r,()=>r.texImage2D(i,0,n,e,t,0,o,s,null)):Te(r,()=>r.texStorage2D(i,1,n,e,t)),Te(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function Jx(r){return r.internalFormatFloat}function mD(r,e,t,n){let[o,s]=jp(e,t);return bg(r,o,s,Jx(n),n.textureFormatFloat,r.FLOAT)}function eI(r){return r.internalFormatHalfFloat}function cD(r,e,t,n){let[o,s]=jp(e,t);return bg(r,o,s,eI(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function tI(r){return r.downloadTextureFormat}function dD(r,e,t,n){let[o,s]=jp(e,t);return bg(r,o,s,tI(n),r.RGBA,r.UNSIGNED_BYTE)}function rI(r){return r.internalFormatPackedFloat}function fD(r,e,t,n){let[o,s]=Ui(e,t);return bg(r,o,s,rI(n),r.RGBA,r.FLOAT)}function nI(r){return r.internalFormatPackedHalfFloat}function hD(r,e,t,n){let[o,s]=Ui(e,t);return bg(r,o,s,nI(n),r.RGBA,n.textureTypeHalfFloat)}function gD(r,e,t){return Te(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Wx(r,e,"clipSpacePos",t,3,20,0)&&Wx(r,e,"uv",t,2,20,12)}function bD(r,e,t,n,o,s){Te(r,()=>r.bindTexture(r.TEXTURE_2D,e));let a,i,u;o instanceof Uint8Array?(a=new Uint8Array(t*n*4),i=r.UNSIGNED_BYTE,u=r.RGBA):(a=new Float32Array(t*n*4),i=r.FLOAT,u=s.internalFormatPackedFloat),a.set(o),$().getNumber("WEBGL_VERSION")===2?Te(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t,n,r.RGBA,i,a)):Te(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,t,n,0,r.RGBA,i,a)),Te(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function yD(r,e,t){Te(r,()=>r.bindTexture(r.TEXTURE_2D,e)),t.data instanceof Uint8Array?$().getNumber("WEBGL_VERSION")===2?Te(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t.width,t.height,r.RGBA,r.UNSIGNED_BYTE,t.data)):Te(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,t.data)):$().getNumber("WEBGL_VERSION")===2?Te(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,t)):Te(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)),Te(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function TD(r,e,t,n){let o=r.createBuffer();Te(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let i=4*4*e*t;return Te(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,i,r.STREAM_READ)),Te(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,0)),Te(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function xD(r,e,t){let n=r,o=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function ID(r,e,t,n){let[o,s]=jp(e,t),a=4,i=new Uint8Array(bO(e*t,a));return Te(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function CD(r,e,t,n,o,s,a,i){let u=r,l=new Float32Array(yO(s,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function kD(r,e,t){let n=new Float32Array(e*t*4);return Te(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,n)),n}var Zp=class{gl;textureFloatExtension;textureHalfFloatExtension;colorBufferFloatExtension;colorBufferHalfFloatExtension;disjointQueryTimerExtension;parallelCompilationExtension;vertexBuffer;indexBuffer;framebuffer;outputTexture=null;program=null;disposed=!1;disjoint;vertexShader;textureConfig;createVertexArray;bindVertexArray;deleteVertexArray;getVertexArray;constructor(e){let t=$().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,BN(t,e)):this.gl=eo(t),e=this.gl,$().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>Te(s,()=>s.createVertexArray()),this.bindVertexArray=a=>Te(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>Te(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>Te(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Te(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>Te(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Te(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>Te(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),$().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=bf(this.gl,s),to(this.gl,a))this.textureHalfFloatExtension=bf(this.gl,a);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),to(this.gl,o))this.colorBufferHalfFloatExtension=bf(this.gl,o);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",to(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(to(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=lD(this.gl),this.indexBuffer=pD(this.gl),this.framebuffer=YN(this.gl),this.textureConfig=dg(this.gl,this.textureHalfFloatExtension)}get debug(){return $().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Te(e,()=>e.finish()),Te(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Te(e,()=>e.deleteFramebuffer(this.framebuffer)),Te(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Te(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Te(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),mD(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),cD(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),dD(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),yD(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,o){this.throwIfDisposed(),bD(this.gl,e,t,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),hD(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),fD(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Ux(this.gl,this.framebuffer),this.outputTexture=null),Te(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>ID(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,o,s,a){return CD(this.gl,e,t,n,o,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return xD(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let o=TD(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if($().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=o.clientWaitSync(s,0,0);return a===o.ALREADY_SIGNALED||a===o.CONDITION_SATISFIED},t=s}else $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>kD(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=uD(t));let n=KN(t);Te(t,()=>t.attachShader(n,this.vertexShader)),Te(t,()=>t.attachShader(n,e)),VN(t,n);let o;return o=Object.assign(n,{vao:this.createVertexArray()}),this.bindVertexArray(o.vao),Te(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(gD(t,o,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&fg(t,o),this.setProgram(o),o}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Te(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&fg(this.gl,this.program)),Te(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?ZN(this.gl,e,t):QN(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Te(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),JN(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[o,s]=Ui(t,n);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,n,o){this.setOutputMatrixWriteRegionDriver(n,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&fg(this.gl,this.program),yf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Te(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Te(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=bf(this.gl,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}itemsToPoll=[];pollItems(){let e=Vae(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in $().platform&&(n=$().platform.setTimeoutCustom.bind($().platform)),y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),hg(this.gl,e,this.framebuffer),this.debug&&yf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(hg(this.gl,this.outputTexture,this.framebuffer),this.debug&&yf(this.gl)):Ux(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let o=this.gl;hg(o,e,this.framebuffer),this.debug&&yf(o),this.outputTexture=e,Te(o,()=>o.viewport(0,0,t,n)),Te(o,()=>o.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,o){this.throwIfDisposed(),Te(this.gl,()=>this.gl.scissor(e,t,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Vae(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var{addImpl:PO,bincountImpl:oI,bincountReduceImpl:EO,castImpl:FO,ceilImpl:LO,concatImpl:$O,equalImpl:BO,expImpl:OO,expm1Impl:zO,floorImpl:GO,gatherNdImpl:WO,gatherV2Impl:UO,greaterImpl:KO,greaterEqualImpl:VO,lessImpl:HO,lessEqualImpl:qO,linSpaceImpl:jO,logImpl:XO,maxImpl:YO,maximumImpl:ZO,minimumImpl:QO,multiplyImpl:JO,negImpl:ez,notEqualImpl:tz,prodImpl:rz,raggedGatherImpl:nz,raggedRangeImpl:oz,raggedTensorToTensorImpl:sz,rangeImpl:az,rsqrtImpl:iz,scatterImpl:uz,sigmoidImpl:lz,simpleAbsImpl:sI,sliceImpl:pz,sparseFillEmptyRowsImpl:mz,sparseReshapeImpl:cz,sparseSegmentReductionImpl:aI,sqrtImpl:dz,stridedSliceImpl:fz,stringNGramsImpl:hz,stringSplitImpl:gz,stringToHashBucketFastImpl:bz,subImpl:yz,tileImpl:Tz,topKImpl:xz,transposeImpl:Qp,uniqueImpl:Iz}=ff;function vD(r,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${r}.${t}`)}function ir(r,e){return e===1?[r]:vD(r,e)}function Cz(r,e){if(r===1)return"rc";let t="";for(let n=0;n<r;n++)t+=e[n],n<r-1&&(t+=",");return t}var iI=class{variableNames=["A"];outputShape;userCode;packedInputs=!1;packedOutput=!0;enableShapeUniforms;rank;constructor(e){if(this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Dt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=ir("rc",this.rank),n=Ve(this.rank),o=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}};var Nf=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"inputShape",type:"ivec3"}];constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Hae(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Cf():If(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function Hae(r,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?kO(["r","c","d"],"inputShape"):hi(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var uI=class{constructor(e){this.gpgpu=e}numUsedTextures=0;numFreeTextures=0;_numBytesAllocated=0;_numBytesFree=0;freeTextures={};logEnabled=!1;usedTextures={};acquireTexture(e,t,n){let o=Sz(t,n),s=vz(e,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=kz(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let i;return o===3?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===4?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===1?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===0?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===2&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,o){if(this.freeTextures==null)return;let s=Sz(n,o),a=vz(t,s,o);a in this.freeTextures||(this.freeTextures[a]=[]);let i=kz(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=$().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[a],p=l.indexOf(e);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(p,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function qae(r,e){let t=r;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===r.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function kz(r,e,t,n,o){let s=jae(e,n),a;if(o){let[u,l]=Ui(r[0],r[1]);a=u*l}else{let[u,l]=jp(r[0],r[1]);a=u*l}let i=qae(t,s);return a*i}function jae(r,e){switch(r){case 3:return rI(e);case 4:return nI(e);case 1:return Jx(e);case 0:return eI(e);case 2:return tI(e);default:throw new Error(`Unknown physical texture type ${r}`)}}function Xae(r){return $().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?3:1:r?4:0}function Sz(r,e){if(r===1)return 3;if(r===0||r==null)return Xae(e);if(r===3||r===2)return 2;throw new Error(`Unknown logical texture type ${r}`)}function vz(r,e,t){return`${r[0]}_${r[1]}_${e}_${t}`}var Gr=class{variableNames=["A"];userCode;outputShape;enableShapeUniforms;constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Ir="if (isnan(x)) return x;",Az="return x;",AD="return abs(x);";var wz="return (x >= 0.0) ? x : (exp(x) - 1.0);",Nz=Ir+`
  return (x < 0.0) ? 0.0 : x;
`,Dz=Ir+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ki="return x;",_z="return 1.0 / (1.0 + exp(-1.0 * x));";var Rz="return x;",Pz=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Ez=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Fz=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Lz="return 1.0 / (1.0 + exp(-1.0 * x));",$n=class{variableNames=["A"];userCode;enableShapeUniforms;outputShape;packedInputs=!0;packedOutput=!0;constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var lI=class{variableNames=["A"];packedInputs=!0;packedOutput=!1;outputShape;userCode;enableShapeUniforms;constructor(e){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let t=e.length,n=ir("rc",t),o=Ve(t),s=Cz(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}};var Zae=xr.whereImpl,Qae=1e-7,Jae=1e-4,pI={};function eie(r){return r in pI||(pI[r]={}),pI[r]}var tie=$().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),rie=600;function nie(){return $().global.screen==null?1024:$().global.screen.height*$().global.screen.width*window.devicePixelRatio*rie/1024/1024}var wD=class extends po{texData;gpgpu;nextDataId(){return wD.nextDataId++}pendingRead=new WeakMap;pendingDisposal=new WeakSet;dataRefCount=new WeakMap;numBytesInGPU=0;canvas;programTimersStack;activeTimers;uploadWaitMs=0;downloadWaitMs=0;lastGlFlushTime=0;floatPrecisionValue;textureManager;binaryCache;gpgpuCreatedLocally;numMBBeforeWarning;warnedAboutMemory=!1;constructor(e){if(super(),!$().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Zp)t=e;else{let n=eo($().getNumber("WEBGL_VERSION"),e);t=new Zp(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=eo($().getNumber("WEBGL_VERSION"));t=new Zp(n),this.binaryCache=eie($().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new uI(this.gpgpu),this.numMBBeforeWarning=nie(),this.texData=new fa(this,rn())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,o,s,a){let i=this.makeTensorInfo(t,n),u=this.texData.get(i.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[o,s]},u.texShape=[o,s];let l=Tf(t),p=new gg(l,!1,a),m=this.runWebGLProgram(p,[i],n,[[o,s]]);return m.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(i),m.dataId}write(e,t,n){if(($().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||$().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:t,dtype:n,values:e,usage:1,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,o,s){if($().getBool("DEBUG")&&this.checkNumericalProblems(t),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:o,values:t,usage:1,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:s,slice:a,shape:i,isPacked:u}=t;if(a!=null){let c;u?c=new $n(i,Ki):c=new Gr(i,Ki);let d=this.runWebGLProgram(c,[{dataId:e,shape:i,dtype:o}],o),f=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),f}if(n!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return n;let l=this.activeTimers!=null,p;l&&(p=y.now());let m;if(o==="complex64"){let c=this.readSync(s.real.dataId),d=this.readSync(s.imag.dataId);m=C.mergeRealAndImagArrays(c,d)}else m=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=y.now()-p),this.convertAndCacheOnCPU(e,m)}async read(e){if(this.pendingRead.has(e)){let f=this.pendingRead.get(e);return new Promise(h=>f.push(h))}let t=this.texData.get(e),{values:n,shape:o,slice:s,dtype:a,complexTensorInfos:i,isPacked:u}=t;if(s!=null){let f;u?f=new $n(o,Ki):f=new Gr(o,Ki);let h=this.runWebGLProgram(f,[{dataId:e,shape:o,dtype:a}],a),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(e);if($().getBool("DEBUG")&&!$().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&$().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,p;if(a!=="complex64"&&$().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let f=this.texData.get(p.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...cg(o))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let m;if(a==="complex64"){let f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),h=f[0],g=f[1];m=C.mergeRealAndImagArrays(h,g)}else if(l==null)m=this.getValuesFromTexture(e);else{let f=y.sizeFromShape(o);m=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(p!=null&&this.disposeIntermediateTensorInfo(p),l!=null){let f=this.gpgpu.gl;Te(f,()=>f.deleteBuffer(l))}let c=this.convertAndCacheOnCPU(e,m),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(f=>f(c)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&rn().removeDataId(e,this),this.pendingDeletes--),c}readToGPU(e,t={}){let n=this.texData.get(e),{values:o,shape:s,slice:a,dtype:i,isPacked:u,texture:l}=n;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let d;u?d=new $n(s,Ki):d=new Gr(s,Ki);let f=this.runWebGLProgram(d,[{dataId:e,shape:s,dtype:i}],i),h=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),h}if(l==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(e,t.customTexShape),m=rn().makeTensorFromTensorInfo(p),c=this.texData.get(p.dataId);return{tensorRef:m,...c.texture}}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(o=>y.decodeString(o));return Ie(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ie(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!GN(n))throw $().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:o}=this.texData.get(e),s=y.sizeFromShape(t);if($().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let c=this.decode(e),d=this.texData.get(c.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...cg(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(c),f}let a=$().getBool("WEBGL_PACK")&&o===!0,i=a?Tf(t):t,u=a?new Zx(i):new Xx(i),l=this.runWebGLProgram(u,[{shape:i,dtype:n,dataId:e}],"float32"),p=this.texData.get(l.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),m}timerAvailable(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=y.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=y.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);i.kernelMs=y.sum(u),i.getExtraProfileInfo=()=>u.map((l,p)=>({name:a[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(e){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=y.now(),e)}async getQueryTime(e){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}pendingDeletes=0;disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:o,usage:s,isPacked:a,slice:i}=this.texData.get(e),u=i&&i.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(t,o,s,a)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=tie){return $().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&y.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){C.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return Zae(e.shape,t)}packedUnaryOp(e,t,n){let o=new $n(e.shape,t),s=this.compileAndRun(o,[e],n);return rn().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let o=sI(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if($().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,AD,e.dtype);let t=new Gr(e.shape,AD),n=this.compileAndRun(t,[e]);return rn().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(a=>y.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:t}}makeOutput(e,t,n){return rn().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new lI(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new iI(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[wu(e.shape),...Nu(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},s=[wu(t),...Nu(t)],a=new Nf(s,n),i=!0,u=[n],l=this.runWebGLProgram(a,[o],e.dtype,u,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:o,shape:s,dtype:a}=n;if(t!=null){let c=y.sizeFromShape(s),d=t[0]*t[1]*4;y.assert(c<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i=Tf(s),u;o?u=new jx(i):u=new qx(i);let l=!0,p=[t??cg(i)],m=this.runWebGLProgram(u,[{shape:i,dtype:a,dataId:e}],a,p,l,t);return{dtype:a,shape:s,dataId:m.dataId}}runWebGLProgram(e,t,n,o,s=!1,a){let i=this.makeTensorInfo(e.outputShape,n),u=this.texData.get(i.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===0){let b=a??cg(e.outputShape);u.texShape=b.map(T=>T*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),y.sizeFromShape(i.shape)===0)return u.values=y.getTypedArrayFromDType(i.dtype,0),i;let l=[],p=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(b.dataId);if(T.texture==null){if(!e.packedInputs&&y.sizeFromShape(b.shape)<=$().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:T.values};e.packedInputs&&(T.isPacked=!0,T.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!T.isPacked!=!!e.packedInputs)b=T.isPacked?this.unpackTensor(b):this.packTensor(b),l.push(b),T=this.texData.get(b.dataId);else if(T.isPacked&&!Fl(T.shape,b.shape)){let x=b,I=b.shape;b.shape=T.shape,b=this.packedReshape(b,I),l.push(b),T=this.texData.get(b.dataId),x.shape=I}return{shape:b.shape,texData:T,isUniform:!1}});this.uploadToGPU(i.dataId);let m={shape:i.shape,texData:u,isUniform:!1},c=MO(e,p,m),d=this.getAndSaveBinary(c,()=>DO(this.gpgpu,e,p,m)),f=this.activeTimers!=null,h;f&&(h=this.startTimer()),$().get("ENGINE_COMPILE_ONLY")||_O(this.gpgpu,d,p,m,o),l.forEach(b=>this.disposeIntermediateTensorInfo(b)),f&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));let g=$().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let b=y.now();b-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!$().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let b=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),b}return i}compileAndRun(e,t,n,o,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,o,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}disposed=!1;dispose(){this.disposed||($().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=z(()=>{if(!$().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=$().getBool("DEBUG");$().set("DEBUG",!1);let t=this.abs(ge(1e-8)).dataSync()[0];if($().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Qae:Jae}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:o,values:s,texture:a,usage:i,isPacked:u}=t;if(a!=null)return;let l=this.activeTimers!=null,p;l&&(p=y.now());let m=t.texShape;if(m==null&&(m=eD(n,u),t.texShape=m),s!=null){let c=Tf(n),d,f=m[1],h=m[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!g)&&([f,h]=Ui(m[0],m[1])),u?d=new Qx(c,g):d=new gg(c,g);let b=g?[h,f]:m,T=this.makeTensorInfo(b,o),x=this.texData.get(T.dataId);g?x.usage=2:x.usage=1,x.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),f,h,s);let I=[[h,f]],k=!0,w=this.runWebGLProgram(d,[T],o,I,k),_=this.texData.get(w.dataId);t.texShape=_.texShape,t.isPacked=_.isPacked,t.usage=_.usage,$().get("ENGINE_COMPILE_ONLY")?this.disposeData(w.dataId):(t.texture=_.texture,t.values=null,this.texData.delete(w.dataId)),this.disposeIntermediateTensorInfo(T),l&&(this.uploadWaitMs+=y.now()-p)}else{let c=this.acquireTexture(m,i,o,u);t.texture=c}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:o}=n;return this.releaseGPUData(e),t!=null&&(n.values=oie(t,o)),n.values}acquireTexture(e,t,n,o){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,o)}computeBytes(e,t){return e[0]*e[1]*y.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(o=>{try{this.checkCompletion_(t),o(!0)}catch(s){throw s}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Ph(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Gx(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,e]of Object.entries(this.binaryCache)){let{uniformLocations:t,customUniformLocations:n,infLoc:o,nanLoc:s,inShapesLocations:a,inTexShapesLocations:i,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:p}=iD(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=o,e.nanLoc=s,e.inShapesLocations=a,e.inTexShapesLocations=i,e.outShapeLocation=u,e.outShapeStridesLocation=l,e.outTexShapeLocation=p}}createTensorFromTexture(e,t,n){let{texture:o,height:s,width:a,channels:i}=e,u=rn().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=u.writeTexture(o,t,n,s,a,i);return rn().makeTensorFromDataId(l,t,n,u)}},Df=wD;K(Df,"nextDataId",0);function oie(r,e){if(e==="float32"||e==="complex64")return r;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<t.length;++n)t[n]=Math.round(r[n]);return t}else throw new Error(`Unknown dtype ${e}`)}var sie="0.0.0";function $z(){$().set("WEBGL_FORCE_F16_TEXTURES",!0)}sl.isBrowser()&&ul("webgl",()=>new Df,2);var VQt={forceHalfFloat:$z};var _f=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var bs=class{variableNames=["A","B"];outputShape;userCode;enableShapeUniforms;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Vi=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var ua=class{variableNames=["A","B"];outputShape;userCode;supportsBroadcasting=!0;packedInputs=!0;packedOutput=!0;enableShapeUniforms;constructor(e,t,n,o=!1){this.outputShape=C.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=Dt(s);let a="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ve(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=ir("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ur(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var Bz={kernelName:Vn,backendName:"webgl",kernelFunc:ur};function Bn(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),a=t.texData.get(s.dataId),i=ur({inputs:{x:n},backend:t}),u=ur({inputs:{x:o},backend:t});return a.complexTensorInfos={real:i,imag:u},s}var Oz={kernelName:zu,backendName:"webgl",kernelFunc:Bn};var ND="return (a < 0.) ? b * a : a;",DD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function aie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,a=t.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),i=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ua(DD,o.shape,a.shape):new bs(ND,o.shape,a.shape),u=t.runWebGLProgram(i,[o,a],"float32");return t.disposeIntermediateTensorInfo(a),u}var zz={kernelName:Ro,backendName:"webgl",kernelFunc:aie};var _D="return (a < 0.) ? b * a : a;",MD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function iie(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ua(MD,n.shape,o.shape):new bs(_D,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],"float32")}var Gz={kernelName:Vo,backendName:"webgl",kernelFunc:iie};var la="if (isnan(x)) return x;";function Ae({opSnippet:r,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:o,backend:s})=>{let{x:a}=o,i=s,u=n||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){let m=i.texData.get(a.dataId),c=t(m.values,u);return i.makeTensorInfo(a.shape,u,c)}let l=$().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,p;return l?p=new $n(a.shape,e):p=new Gr(a.shape,r),i.runWebGLProgram(p,[a],u)}}function dt({opSnippet:r,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:a,backend:i})=>{let{a:u,b:l}=a,p=i;if(n&&u.dtype==="complex64"){let f=p.texData.get(u.dataId),h=p.texData.get(l.dataId),[g,b]=[[f.complexTensorInfos.real,h.complexTensorInfos.real],[f.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(x=>{let[I,k]=x,w={dataId:I.dataId,dtype:I.dtype,shape:u.shape},_={dataId:k.dataId,dtype:k.dtype,shape:l.shape},M=new bs(r,u.shape,l.shape);return p.runWebGLProgram(M,[w,_],Pt(I.dtype,k.dtype))}),T=Bn({inputs:{real:g,imag:b},backend:p});return p.disposeIntermediateTensorInfo(g),p.disposeIntermediateTensorInfo(b),T}let m=s||Pt(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||p.shouldExecuteOnCPU([u,l]))&&o!=null){let f=p.texData.get(u.dataId).values,h=p.texData.get(l.dataId).values,g=u.dtype==="string"?C.fromUint8ToStringArray(f):f,b=u.dtype==="string"?C.fromUint8ToStringArray(h):h,[T,x]=o(u.shape,l.shape,g,b,m),I=p.makeTensorInfo(x,m),k=p.texData.get(I.dataId);return k.values=T,I}let c=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,d;return c?d=new ua(e,u.shape,l.shape,t):d=new bs(r,u.shape,l.shape),p.runWebGLProgram(d,[u,l],m)}}function Du(r,e=!1){if(r==="linear")return e?Rz:Az;if(r==="relu")return e?Ez:Nz;if(r==="elu")return e?Pz:wz;if(r==="relu6")return e?Fz:Dz;if(r==="prelu")return e?MD:_D;if(r==="leakyrelu")return e?DD:ND;if(r==="sigmoid")return e?Lz:_z;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var Mf=class{variableNames=["matrixA","matrixB"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;constructor(e,t,n,o=!1,s=!1,a=!1,i=null,u=!1,l=!1){this.outputShape=n,this.enableShapeUniforms=Dt(this.outputShape.length);let p=o?e[1]:e[2],m=Math.ceil(p/2),c=o?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",f=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",b="";i&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,b="result = activation(result);");let T=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let x="rc.x",I="rc.x";e[0]<t[0]?x=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(I=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${m}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${m}; i++) {
          int batchA = ${x};
          int batchB = ${I};
          vec4 a = getMatrixA(batchA, ${c});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${h[0]});
          result += (${f[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${b}

        setOutput(result);
      }
    `}};var RD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},yg=class{variableNames=["AReal","AImag","BReal","BImag"];userCode;outputShape;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var Wz="return a * b;";function Tg(r){let{inputs:e,backend:t}=r,{a:n,b:o}=e,s=C.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let i=t.texData.get(n.dataId),u=t.texData.get(o.dataId),l=new yg(RD.REAL,n.shape,o.shape),p=new yg(RD.IMAG,n.shape,o.shape),m=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:n.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],c=t.runWebGLProgram(l,m,"float32"),d=t.runWebGLProgram(p,m,"float32"),f=Bn({inputs:{real:c,imag:d},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),f}if(t.shouldExecuteOnCPU([n,o])){let i=t.texData.get(n.dataId),u=t.texData.get(o.dataId),[l,p]=JO(n.shape,o.shape,i.values,u.values,s),m=t.makeTensorInfo(p,s),c=t.texData.get(m.dataId);return c.values=l,m}let a;return $().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new ua(Wz,n.shape,o.shape):a=new bs(Wz,n.shape,o.shape),t.runWebGLProgram(a,[n,o],s)}var Uz={kernelName:Go,backendName:"webgl",kernelFunc:Tg};function Kz(r,e,t){let n=[wu(r.shape),...Nu(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[wu(e),...Nu(e)],a=new Nf(s,n),i=!0,u=[n],l=t.runWebGLProgram(a,[o],r.dtype,u,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}function ue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=t,i=y.sizeFromShape(o.shape),u=y.inferFromImplicitShape(s,i),l=y.sizeFromShape(u);y.assert(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let p=a.texData.get(o.dataId);return p.isPacked&&!Fl(o.shape,u)&&!(p.texture!==null&&Fl(p.shape,u))?Kz(o,u,a):(a.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var Vz={kernelName:ws,backendName:"webgl",kernelFunc:ue};var xg=class{variableNames=["x"];outputShape;userCode;constructor(e,t){let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(t!=null){let m=1/t;l=`sumValue += dot(values * ${y.isInt(m)?m.toPrecision(2):m}, ones);`}let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var mI=class{variableNames=["x"];outputShape;userCode;constructor(e,t){let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i="0.0",u="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",u="min"):t==="max"&&(i="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let p=Math.floor(n/4)*4,m=n%4,c=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(i="1.0",c=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(i="0.0",c=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${p};
        if (${m===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${m===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${m===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${c}
        }
        setOutput(${l});
      }
    `}};function lie(r){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:r[1],n=C.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function ro(r,e,t,n){let o=lie(r.shape),s=r;for(let a=0;a<o.length;a++){let{inSize:i,windowSize:u,outSize:l}=o[a],p,m;t==="mean"?p=a===0?new xg({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l},i):new xg({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l}):p=new mI({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l},t),m=s,s=n.runWebGLProgram(p,[s],e),m.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(m)}return s}var cI=class{variableNames=["A"];outputShape;userCode;rank;constructor(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=pie(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function pie(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let o=0;o<r.length;o++)n[r[o]]=t[o];return n.join()}var dI=class{variableNames=["A"];outputShape;userCode;rank;packedInputs=!0;packedOutput=!0;constructor(e,t){let n=new Array(e.length);for(let p=0;p<n.length;p++)n[p]=e[t[p]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Ve(this.rank),s=vD("rc",this.rank),a=new Array(this.rank);for(let p=0;p<t.length;p++)a[t[p]]=s[p];let i=`vec2(${a.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Ll(r,e,t){let n=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dI(r.shape,e):new cI(r.shape,e);return t.runWebGLProgram(n,[r],r.dtype)}function Hz(r,e,t,n){let o=e,s=r.shape.length,a=y.parseAxisParam(o,r.shape),i=a,u=C.getAxesPermutation(i,s),l=u!=null,p=r;l&&(p=Ll(r,u,n),i=C.getInnerMostAxes(i.length,s)),C.assertAxesAreInnerMostDims("sum",i,s);let[m,c]=C.computeOutAndReduceShapes(p.shape,i),d=m;t&&(d=C.expandShapeToKeepDim(m,a));let f=y.sizeFromShape(c),g=y.sizeFromShape(r.shape)/f,b=ue({inputs:{x:p},attrs:{shape:[g,f]},backend:n}),T=iu(r.dtype),x=ro(b,T,"sum",n),I=ue({inputs:{x},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),l&&n.disposeIntermediateTensorInfo(p),I}function Jp(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return Hz(o,s,a,t)}var qz={kernelName:ns,backendName:"webgl",kernelFunc:Jp};function Wt(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,a=t,i=o.shape.length,u=new Array(i);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];let l;if(a.shouldExecuteOnCPU([o])){let m=a.texData.get(o.dataId).values,c=Qp(m,o.shape,o.dtype,s,u);l=a.makeTensorInfo(u,o.dtype);let d=a.texData.get(l.dataId);d.values=c}else l=Ll(o,s,a);return l}var jz={kernelName:_n,backendName:"webgl",kernelFunc:Wt};var PD=1e3;function em({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,m=t?r.shape[l-2]:r.shape[l-1],c=n?e.shape[p-1]:e.shape[p-2],d=t?r.shape[l-1]:r.shape[l-2],f=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),b=y.sizeFromShape(h),T=y.sizeFromShape(g),I=Dr.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);y.assert(m===c,()=>`Error in matMul: inner shapes (${m}) and (${c}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let k=t?[b,m,d]:[b,d,m],w=n?[T,f,c]:[T,c,f],_=ue({inputs:{x:r},backend:o,attrs:{shape:k}}),M=ue({inputs:{x:e},backend:o,attrs:{shape:w}}),R=[_,M],E=Math.max(b,T),O=t?_.shape[1]:_.shape[2],G=s!=null,W=a!=null,H=u==="leakyrelu",U=u!=null?Du(u,!0):null,V=G||W||H||U!=null,Y;if((d===1||f===1)&&O>PD&&V===!1){let te=_,ne=M;t&&(te=Wt({inputs:{x:_},backend:o,attrs:{perm:[0,2,1]}}),R.push(te)),n&&(ne=Wt({inputs:{x:M},backend:o,attrs:{perm:[0,2,1]}}),R.push(ne));let oe=f!==1,ae=f===1,se=te;oe&&(se=ue({inputs:{x:te},backend:o,attrs:{shape:[E,O,1]}}),R.push(se));let ie=f===1?2:1,he=ne;ae&&(he=ue({inputs:{x:ne},backend:o,attrs:{shape:[E,1,O]}}),R.push(he));let ye=Tg({inputs:{a:se,b:he},backend:o});Y=Jp({inputs:{x:ye},backend:o,attrs:{axis:ie,keepDims:!0}}),R.push(ye)}else{let te=Pt(r.dtype,e.dtype),ne=new Mf(k,w,[E,d,f],t,n,G,U,W,H),oe=[_,M];if(s!=null&&oe.push(s),W&&oe.push(a),H){let ae=o.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));oe.push(ae),R.push(ae)}Y=o.runWebGLProgram(ne,oe,te)}let j=ue({inputs:{x:Y},backend:o,attrs:{shape:I}});R.push(Y);for(let te of R)o.disposeIntermediateTensorInfo(te);return j}function mie(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n;return em({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:m,activation:p})}var Xz={kernelName:Fs,backendName:"webgl",kernelFunc:mie};var Yz="return abs(x);";function cie(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=t.texData.get(n.dataId),a=sI(s.values);return t.makeTensorInfo(n.shape,n.dtype,a)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new $n(n.shape,Yz):o=new Gr(n.shape,Yz),t.runWebGLProgram(o,[n],n.dtype)}var Zz={kernelName:Ts,backendName:"webgl",kernelFunc:cie};var die=Ir+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,fie=Ae({opSnippet:die}),Qz={kernelName:ba,backendName:"webgl",kernelFunc:fie};var hie=Ir+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,gie=Ae({opSnippet:hie}),Jz={kernelName:ya,backendName:"webgl",kernelFunc:gie};var e3="return a + b;",bie=dt({opSnippet:e3,packedOpSnippet:e3,supportsComplex:!0,cpuKernelImpl:PO}),t3={kernelName:Nn,backendName:"webgl",kernelFunc:bie};var fI=class{variableNames;outputShape=[];userCode;constructor(e,t){this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var hI=class{variableNames;outputShape=[];userCode;packedInputs=!0;packedOutput=!0;constructor(e,t){this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function gI(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return ur({inputs:{x:n[0]},backend:t});if(n.length>$().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=gI({inputs:n.slice(0,u),backend:t}),p=gI({inputs:n.slice(u),backend:t});return gI({inputs:[l,p],backend:t})}let o=n.map(u=>u.dtype).reduce((u,l)=>Pt(u,l)),s=n.map(u=>u.shape),i=$().getBool("WEBGL_PACK")?new hI(n[0].shape,s):new fI(n[0].shape,s);return t.runWebGLProgram(i,n,o)}var r3={kernelName:co,backendName:"webgl",kernelFunc:gI};function yie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=C.getInnerMostAxes(l.length,i)),C.assertAxesAreInnerMostDims("all",l,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,l),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,f]}}),g=ro(h,h.dtype,"all",t),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:t,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(m),b}var n3={kernelName:Ta,backendName:"webgl",kernelFunc:yie};function Tie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=C.getInnerMostAxes(l.length,i)),C.assertAxesAreInnerMostDims("any",l,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,l),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,f]}}),g=ro(h,h.dtype,"any",t),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:t,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(m),b}var o3={kernelName:xa,backendName:"webgl",kernelFunc:Tie};var bI=class{variableNames=["A"];outputShape;userCode;constructor(e,t,n){let{windowSize:o,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var yI=class{variableNames=["A"];outputShape;userCode;packedInputs=!0;packedOutput=!0;constructor(e,t,n,o){y.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),o||this.variableNames.push("bestIndicesA");let i=this.outputShape,u=i.length,l=Ve(u),p=ir("coords",u),m,c;if(a===1){c=u+1;let M=Ve(c);m=`
        ${M} sourceLocR = ${M}(${p.join()}, 0);
        ++${p[u-1]};
        ${M} sourceLocG = ${M}(${p.join()}, 0);
        ++${p[u-2]};
        ${M} sourceLocA = ${M}(${p.join()}, 0);
        --${p[u-1]};
        ${M} sourceLocB = ${M}(${p.join()}, 0);
        --${p[u-2]};`}else c=u,m=`
        ${l} sourceLocR = coords;
        ++${p[u-1]};
        ${l} sourceLocG = coords;
        ++${p[u-2]};
        ${l} sourceLocA = coords;
        --${p[u-1]};
        ${l} sourceLocB = coords;
        --${p[u-2]};`;let d=["x","y","z","w","u","v"].slice(0,c),f="."+d[c-1],h=d.map(M=>"int "+M),g=ir("sourceLocR",c-1).concat("inIdx.r"),b=ir("sourceLocG",c-1).concat("inIdx.g"),T=ir("sourceLocB",c-1).concat("inIdx.b"),x=ir("sourceLocA",c-1).concat("inIdx.a"),I=n==="max"?"greaterThan":"lessThan",k=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${x.join()})));`,w=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,_=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${p[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${p[u-2]} < ${i[u-2]-1};
        ${m}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function s3(r,e,t,n=null){let o=e.shape[0],s=e.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let a=C.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:o,outSize:Math.ceil(s/a)},u=new bI(i,t,n==null),l=[e];n!=null&&l.push(n);let p=r.runWebGLProgram(u,l,"int32");if(p.shape[1]===1)return p;let m=s3(r,e,t,p);return r.disposeIntermediateTensorInfo(p),m}function a3(r,e,t,n=null){let o=n!=null?n.shape:e.shape,s=o[o.length-1],a=C.computeOptimalWindowSize(s),i=new yI(o,a,t,n==null),u=n==null?[e]:[e,n],l=r.runWebGLProgram(i,u,"int32");if(l.shape.length===e.shape.length){let p=a3(r,e,t,l);return r.disposeIntermediateTensorInfo(l),p}return l}function TI(r,e,t,n){let o=[t];if(C.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.shape.length),!$().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],a=r.texData.get(e.dataId),i=a!==null&&a.isPacked,u=e;i&&(u=r.unpackTensor(e),s.push(u));let[l,p]=C.computeOutAndReduceShapes(u.shape,o),m=y.sizeFromShape(p),c=ue({inputs:{x:u},backend:r,attrs:{shape:[-1,m]}});s.push(c);let d=s3(r,c,n);s.push(d);let f=ue({inputs:{x:d},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),f}return a3(r,e,n)}function xie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=Wt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let p=TI(t,u,a[0],"max");return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}var i3={kernelName:fo,backendName:"webgl",kernelFunc:xie};function Iie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=Wt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let p=TI(t,u,a[0],"min");return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}var u3={kernelName:Si,backendName:"webgl",kernelFunc:Iie};var Cie=Ir+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,kie=Ae({opSnippet:Cie}),l3={kernelName:Ia,backendName:"webgl",kernelFunc:kie};var Sie=Ir+"return log(x + sqrt(x * x + 1.0));",vie=Ae({opSnippet:Sie}),p3={kernelName:Ca,backendName:"webgl",kernelFunc:vie};var Aie=Ir+`
  return atan(x);
`,wie=Ae({opSnippet:Aie}),m3={kernelName:ka,backendName:"webgl",kernelFunc:wie};var Nie=_f+`
  return atan(a, b);
`,Die=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vi+`
  return result;
`,_ie=dt({opSnippet:Nie,packedOpSnippet:Die}),c3={kernelName:va,backendName:"webgl",kernelFunc:_ie};var Mie=Ir+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Rie=Ae({opSnippet:Mie}),d3={kernelName:Sa,backendName:"webgl",kernelFunc:Rie};var gi=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n,o=!1,s=!1){if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,p=e.dilationWidth,m=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,T="0.0";if(h||(T="-1.0 / 1e-20"),n){let M=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${c};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${M} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:b:`wR * ${c} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / count");let k=Math.floor(a/4)*4,w=a%4,_=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${m};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${k};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${I});
      }
    `}},$l=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n,o=!1,s=!1){if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,u=e.strideHeight,l=e.strideWidth,p=e.dilationDepth,m=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,b=e.padInfo.top,T=e.padInfo.left;this.outputShape=e.outShape;let x=t==="avg",I="0.0";if(x||(I="-1.0 / 1e-20"),n){let E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${b}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${m}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${c}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / count");let _=Math.floor(a/4)*4,M=a%4,R=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${b}, ${T});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${m}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${c};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                getValue(batch, xD, xR, xC + 3 * ${c}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${_};
            if (${M===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${M===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${M===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                initializationValue
              );

              ${R}
            }
          }
          setOutput(${w});
        }
      }
    `}};function Pie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;fi(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u);if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))return ur({inputs:{x:o},backend:t});let m=new gi(p,"avg",!1);return t.runWebGLProgram(m,[o],"float32")}var f3={kernelName:ho,backendName:"webgl",kernelFunc:Pie};function Eie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n,p=[1,1,1],m=C.computePool3DInfo(o.shape,s,a,p,i,u,l),c=new $l(m,"avg",!1);return t.runWebGLProgram(c,[o],"float32")}var h3={kernelName:Bu,backendName:"webgl",kernelFunc:Eie};var xI=class{variableNames=["dy"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=u-1-e.padInfo.top,m=l-1-e.padInfo.left,c=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${p}, ${m});
      const float avgMultiplier = float(${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},II=class{variableNames=["dy"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,m=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=m-1-e.padInfo.front,h=c-1-e.padInfo.top,g=d-1-e.padInfo.left,b=1/(t*n*o);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${h}, ${g});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Fie(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:p}=n,m=[1,1,1],c=C.computePool3DInfo(a.shape,i,u,m,l,p),d=new II(c);return t.runWebGLProgram(d,[o],a.dtype)}var g3={kernelName:Sm,backendName:"webgl",kernelFunc:Fie};function Lie(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;fi([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=n,p=C.computePool2DInfo(a.shape,i,u,1,l),m=new xI(p);return t.runWebGLProgram(m,[o],a.dtype)}var b3={kernelName:km,backendName:"webgl",kernelFunc:Lie};function $ie(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;return em({a:o,b:s,transposeA:a,transposeB:i,backend:t})}var y3={kernelName:go,backendName:"webgl",kernelFunc:$ie};var CI=class{variableNames;outputShape=[];userCode;constructor(e,t,n,o,s,a){this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n);let i="0.0";o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var kI=class{variableNames;outputShape;userCode;packedInputs=!0;packedOutput=!0;constructor(e,t,n,o,s,a){this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Bie=({inputs:r,backend:e,attrs:t})=>{let{x:n,mean:o,variance:s,offset:a,scale:i}=r;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);let l=[n,o,s],p=null;a!=null&&(p=a.shape,l.push(a));let m=null;i!=null&&(m=i.shape,l.push(i));let c=$().getBool("WEBGL_PACK_NORMALIZATION")?new kI(n.shape,o.shape,s.shape,p,m,u):new CI(n.shape,o.shape,s.shape,p,m,u);return e.runWebGLProgram(c,l,l[0].dtype)},T3={kernelName:Do,backendName:"webgl",kernelFunc:Bie};var SI=class{variableNames=["source"];outputShape;userCode;rank;customUniforms;constructor(e){this.outputShape=e,this.rank=e.length;let t=Ve(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=Oie(this.rank),o,s=e.map((a,i)=>`sourceLoc.${ED[i]} = start[${i}] + coords.${ED[i]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},ED=["x","y","z","w","u","v"];function Oie(r){if(r===1)return"sourceLoc";if(r<=6)return ED.slice(0,r).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var vI=class{variableNames=["source"];packedInputs=!0;packedOutput=!0;outputShape;userCode;rank;customUniforms;constructor(e){this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Ve(this.rank),n=ir("coords",this.rank),o=ir("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,a=`getChannel(getSource(${o.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${a};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((p,m)=>`start[${m}]`).join()});`:e.map((p,m)=>`${o[m]} = ${n[m]} + start[${m}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}};function zie(r,e,t,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(t,r.dtype),a=n.texData.get(s.dataId);Object.assign(a,o),a.refCount=1,a.shape=t,a.dtype=r.dtype;let i=It.computeFlatOffset(e,y.computeStrides(r.shape));o.slice&&(i+=o.slice.flatOffset),a.slice={flatOffset:i,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,u+1),s}function bi(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n,[i,u]=It.parseSliceParams(o,s,a);if(It.assertParamsValid(o,i,u),y.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let m=t.texData.get(o.dataId),c=pz(m.values,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,c)}let{isPacked:l}=t.texData.get(o.dataId),p=It.isSliceContinous(o.shape,i,u);if(l||!p){let m=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vI(u):new SI(u),c=[i];return t.runWebGLProgram(m,[o],o.dtype,c)}return t.uploadToGPU(o.dataId),zie(o,i,u,t)}var x3={kernelName:Ds,backendName:"webgl",kernelFunc:bi};var Gie=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((T,x)=>T*x),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=[],f=ue({inputs:{x:o},backend:t,attrs:{shape:u}}),h=Wt({inputs:{x:f},backend:t,attrs:{perm:l}}),g=ue({inputs:{x:h},backend:t,attrs:{shape:p}}),b=bi({inputs:{x:g},backend:t,attrs:{begin:m,size:c}});return d.push(f),d.push(h),d.push(g),d.forEach(T=>t.disposeIntermediateTensorInfo(T)),b},I3={kernelName:xs,backendName:"webgl",kernelFunc:Gie};function Wie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.readSync(o.dataId),u=t.readSync(s.dataId),l=oI(i,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}var C3={kernelName:Ou,backendName:"webgl",kernelFunc:Wie};function Uie(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.readSync(n.dataId),a=t.readSync(o.dataId),i=C.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var k3={kernelName:vm,backendName:"webgl",kernelFunc:Uie};var Kie="return float(a != b);",FD=dt({opSnippet:Kie,cpuKernelImpl:tz,dtype:"bool"}),S3={kernelName:Wa,backendName:"webgl",kernelFunc:FD};function _u(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ur({inputs:{x:o.complexTensorInfos.real},backend:t})}var v3={kernelName:Xu,backendName:"webgl",kernelFunc:_u};var Vie="return float(int(x));";function A3(r,e){let t=new Gr(r.shape,Vie),n=e.runWebGLProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function LD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return ur({inputs:{x:o},backend:t});let a=Ct(o.shape),i=LD({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=Bn({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),u}if(o.dtype==="complex64"){let a=_u({inputs:{input:o},backend:t}),i=LD({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=ur({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(t.shouldExecuteOnCPU([o])){let a=t.texData.get(o.dataId).values,[i,u,l]=FO(a,o.shape,o.dtype,s);return t.makeTensorInfo(i,u,l)}if(s==="int32")return A3(o,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),u=FD({inputs:{a:o,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var w3={kernelName:Un,backendName:"webgl",kernelFunc:LD};var N3="return ceil(x);",Hie=Ae({opSnippet:N3,packedOpSnippet:N3,cpuKernelImpl:LO}),D3={kernelName:bo,backendName:"webgl",kernelFunc:Hie};var AI=class{variableNames=["A"];userCode;outputShape;customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];constructor(e){this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var wI=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;userCode;outputShape;customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];constructor(e){this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function qie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i;$().getBool("WEBGL_PACK_CLIP")?i=new wI(o.shape):i=new AI(o.shape);let u=[[s],[a]];return t.runWebGLProgram(i,[o],o.dtype,u)}var _3={kernelName:Kn,backendName:"webgl",kernelFunc:qie};var NI=class{variableNames=["real","imag"];userCode;outputShape;constructor(e){this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function M3(r,e){return{dataId:e.dataId,dtype:e.dtype,shape:r.shape}}function jie(r){let{inputs:e,backend:t}=r,{x:n}=e,o=t.texData.get(n.dataId),s=new NI(n.shape),a=[M3(n,o.complexTensorInfos.real),M3(n,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,a,a[0].dtype)}var R3={kernelName:Gu,backendName:"webgl",kernelFunc:jie};var DI=class{variableNames;outputShape=[];userCode;constructor(e){this.outputShape=C.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let o=t.length,s=t[t.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var MI=class{variableNames;packedInputs=!0;packedOutput=!0;outputShape=[];userCode;constructor(e,t){this.outputShape=C.computeOutShape(e,t);let n=this.outputShape,o=n.length,s=Ve(o),a=ir("coords",o),i=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let u=new Array(e.length-1);u[0]=e[0][t];for(let h=1;h<u.length;h++)u[h]=u[h-1]+e[h][t];let l=i[t],p=i.slice(-2),m=i.join(),c=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${m}), vec2(${p.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];c+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${_I(i,l,g)}),
            vec2(${_I(p,l,g)}));
        }`}let d=u.length,f=u[u.length-1];c+=`
        return getChannel(
          getT${d}(${_I(i,l,f)}),
          vec2(${_I(p,l,f)}));`,this.userCode=`
      float getValue(${i.map(h=>"int "+h)}) {
        ${c}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[o-1]} = ${a[o-1]} + 1;
        if (${a[o-1]} < ${n[o-1]}) {
          result.g = getValue(${a});
        }

        ${a[o-2]} = ${a[o-2]} + 1;
        if (${a[o-2]} < ${n[o-2]}) {
          result.a = getValue(${a});
        }

        ${a[o-1]} = ${a[o-1]} - 1;
        if (${a[o-2]} < ${n[o-2]} &&
            ${a[o-1]} < ${n[o-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function _I(r,e,t){let n=r.indexOf(e);return r.map((s,a)=>a===n?`${s} - ${t}`:s).join()}function tm(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ur({inputs:{x:o.complexTensorInfos.imag},backend:t})}var P3={kernelName:Hu,backendName:"webgl",kernelFunc:tm};function Rf(r,e,t){let n=r[0].dtype;if(n==="complex64"){let d=r.map(T=>_u({inputs:{input:T},backend:t})),f=r.map(T=>tm({inputs:{input:T},backend:t})),h=Rf(d,e,t),g=Rf(f,e,t),b=Bn({inputs:{real:h,imag:g},backend:t});return d.forEach(T=>t.disposeIntermediateTensorInfo(T)),f.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),b}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let d=r.map(I=>{let k=y.sizeFromShape(I.shape.slice(e));return ue({inputs:{x:I},backend:t,attrs:{shape:[-1,k]}})}),f=d.map(I=>({vals:t.readSync(I.dataId),shape:I.shape})),h=C.computeOutShape(d.map(I=>I.shape),1),g=d[0].shape[0]===1,b=$O(f,h,n,g),T=C.computeOutShape(r.map(I=>I.shape),e),x=t.makeTensorInfo(T,n,b);return d.forEach(I=>t.disposeIntermediateTensorInfo(I)),x}let s=r.filter(d=>y.sizeFromShape(d.shape)>0),a=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let d=a?new Gr(r[0].shape,Ki):new $n(r[0].shape,Ki);return t.runWebGLProgram(d,r,n)}let i=$().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>i){let d=[];for(let h=0;h<s.length;h+=i){let g=s.slice(h,h+i);d.push(Rf(g,e,t))}let f=Rf(d,e,t);for(let h of d)t.disposeIntermediateTensorInfo(h);return f}if(a){let d=new MI(s.map(f=>f.shape),e);return t.runWebGLProgram(d,s,n)}let{tensors2D:u,outShape:l}=Xie(s,e,t),p=new DI(u.map(d=>d.shape)),m=t.runWebGLProgram(p,u,n);u.forEach(d=>t.disposeIntermediateTensorInfo(d));let c=ue({inputs:{x:m},attrs:{shape:l},backend:t});return t.disposeIntermediateTensorInfo(m),c}function Xie(r,e,t){let n=C.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>ue({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:n}}function $D(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=e.map(l=>l.shape);C.assertParamsConsistent(a,s);let i=C.computeOutShape(e.map(l=>l.shape),s);if(y.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let u=e.filter(l=>y.sizeFromShape(l.shape)>0);return u.length===1?ur({inputs:{x:u[0]},backend:t}):Rf(u,s,t)}var E3={kernelName:Is,backendName:"webgl",kernelFunc:$D};var Pf=class{variableNames=["x","W"];outputShape;userCode;constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,p=e.dilationHeight,m=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",b=g?1:2,T=g?2:3,x=g?3:1,I="",k="";n&&(o?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:I=`
          float activation(float x) {
            ${n}
          }
        `,k="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${m};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${k}
        setOutput(result);
      }
    `}},RI=class{variableNames=["x","W"];outputShape;userCode;constructor(e){this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,m=e.filterDepth,c=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${m}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Ef=class{variableNames=["x","W"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape,this.enableShapeUniforms=Dt(this.outputShape.length);let a=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,p=e.filterWidth,m=p,c=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<p;g++)c+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;c+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<p;g++)c+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;c+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(m+1)/2;g++){let b=g*2;if(c+=`
           xC = xCCorner + ${b*u};
           `,i===1){if(b<p&&(a%2===1?(c+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,u===1&&b>0?c+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:c+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):c+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<p)){let T=a%2===0?y.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(c+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,u>1?c+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:c+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):T===1?c+=`
                     xC${b+1} = xTexelC${b};
                     `:c+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<p&&(a%2===1?(c+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<p&&(c+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(c+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<p&&(c+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<p&&(c+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<p&&(c+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}c+=`
     }
   `,c+=`
     }
   `,c+=`
     }
   `;let d="",f="";n&&(o?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,f="result = activation(result);");let h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${c}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${f}
         setOutput(result);
       }
     `}};var PI=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}];constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let{dataFormat:n}=t,o=jt(),s=n==="channelsLast",a=s?1:2,i=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let p=0;p<=1;p++)for(let m=0;m<=1;m++)l+=`
          blockIndex = rc.z + ${m};
          pos = rc.y + ${p};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${p*2+m}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${p*2+m}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function EI(r,e){let t=r.length;return t>=3?e?[...r.slice(0,-3),r[t-3]*r[t-2],r[t-1]]:[...r.slice(0,-3),r[t-3],r[t-2]*r[t-1]]:!e&&t===1&&r[0]>1?[r[0],1]:null}function FI({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=r.shape,l=n.texData.get(r.dataId),p=t.inChannels,m=u[0]*u[1]*u[2],c=t.outChannels,d=t.dataFormat==="channelsLast",f=!1,h=!1,g,b=[];if(s!=null){let I=EI(s.shape,d);I!=null&&(s=ue({inputs:{x:s},backend:n,attrs:{shape:I}}),b.push(s))}if(o!=null){let I=EI(o.shape,d);I!=null&&(o=ue({inputs:{x:o},backend:n,attrs:{shape:I}}),b.push(o))}if(!((m===1||c===1)&&p>PD)&&l.isPacked&&d&&l.texture!=null&&u[2]%2!==0&&y.arraysEqual(l.shape.slice(-3),u.slice(-3))){let I=u[0]*u[1]*(u[2]+1),k={dataId:r.dataId,shape:[1,I,t.inChannels],dtype:r.dtype},w=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,y.assert(Fl(l.shape,k.shape),()=>`packed reshape ${l.shape} to ${k.shape} isn't free`);let _=ue({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(_);let M=em({a:k,b:_,backend:n,transposeA:f,transposeB:h,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),R=n.texData.get(M.dataId);y.assert(R.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=w,R.shape=t.outShape,g=ur({inputs:{x:M},backend:n}),g.shape=t.outShape,b.push(M)}else{let I=t.outHeight*t.outWidth,k=ue({inputs:{x:r},backend:n,attrs:{shape:d?[t.batchSize,I,t.inChannels]:[t.batchSize,t.inChannels,I]}}),w=ue({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),_=em({a:d?k:w,b:d?w:k,transposeA:!d,transposeB:h,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});g=ue({inputs:{x:_},backend:n,attrs:{shape:t.outShape}}),b.push(k),b.push(w),b.push(_)}for(let I of b)n.disposeIntermediateTensorInfo(I);return g}function LI({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:p,outWidth:m,outHeight:c,dataFormat:d}=t,f=d==="channelsLast",h=u*l*p,g=c*m,b=[t.batchSize,h,g],T=!0,x=!1,I=[];if(s!=null){let j=EI(s.shape,f);j!=null&&(s=ue({inputs:{x:s},backend:n,attrs:{shape:j}}),I.push(s))}if(o!=null){let j=EI(o.shape,f);j!=null&&(o=ue({inputs:{x:o},backend:n,attrs:{shape:j}}),I.push(o))}let k=ue({inputs:{x:e},backend:n,attrs:{shape:[1,h,y.sizeFromShape(e.shape)/h]}});I.push(k);let w=new PI(b,t),_=[r.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],M=n.runWebGLProgram(w,[r],"float32",_),R=ue({inputs:{x:M},backend:n,attrs:{shape:b}});I.push(M),I.push(R);let E=o!=null,O=s!=null,G=i==="leakyrelu",W=i?Du(i,!0):null,H=new Mf(f?R.shape:k.shape,f?k.shape:R.shape,f?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],T,x,E,W,O,G),U=f?[R,k]:[k,R];if(o&&U.push(o),O&&U.push(s),G){let j=n.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));U.push(j),I.push(j)}let V=n.runWebGLProgram(H,U,"float32"),Y=ue({inputs:{x:V},backend:n,attrs:{shape:t.outShape}});I.push(V);for(let j of I)n.disposeIntermediateTensorInfo(j);return Y}function Yie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,m),d;if(c.filterHeight===1&&c.filterWidth===1&&c.dilationHeight===1&&c.dilationWidth===1&&c.strideHeight===1&&c.strideWidth===1&&(c.padInfo.type==="SAME"||c.padInfo.type==="VALID"))d=FI({x:o,filter:s,convInfo:c,backend:t});else if(c.strideWidth<=2&&m==="channelsLast"&&$().getBool("WEBGL_EXP_CONV")){let h=new Ef(c),g=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];d=t.runWebGLProgram(h,[o,s],"float32",g)}else if($().getBool("WEBGL_CONV_IM2COL"))d=LI({x:o,filter:s,convInfo:c,backend:t});else{let h=new Pf(c);d=t.runWebGLProgram(h,[o,s],"float32")}let f=ue({inputs:{x:d},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(d),f}var F3={kernelName:yo,backendName:"webgl",kernelFunc:Yie};var $I=class{variableNames=["x","dy"];outputShape;userCode;constructor(e){this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},BI=class{variableNames=["dy","W"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,u=n-1-e.padInfo.left,l=a?1:2,p=a?2:3,m=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${m}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},OI=class{variableNames=["x","dy"];outputShape;userCode;constructor(e){this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},zI=class{variableNames=["dy","W"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=t-1-e.padInfo.front,l=n-1-e.padInfo.top,p=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Zie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:p}=n,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,p,a,1,i,l,!1,m),d=new $I(c);return t.runWebGLProgram(d,[o,s],"float32")}var L3={kernelName:Am,backendName:"webgl",kernelFunc:Zie};function Qie(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(l),c=C.computeConv2DInfo(a,s.shape,i,1,u,p,!1,m),d=new BI(c);return t.runWebGLProgram(d,[o,s],"float32")}var $3={kernelName:To,backendName:"webgl",kernelFunc:Qie};function Jie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n,l=C.computeConv3DInfo(o.shape,s.shape,a,u,i),p=new RI(l);return t.runWebGLProgram(p,[o,s],"float32")}var B3={kernelName:Wu,backendName:"webgl",kernelFunc:Jie};function eue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:u}=n,l=C.computeConv3DInfo(o.shape,u,a,1,i),p=new OI(l);return t.runWebGLProgram(p,[o,s],"float32")}var O3={kernelName:wm,backendName:"webgl",kernelFunc:eue};function tue(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:u}=n,l=C.computeConv3DInfo(u,s.shape,i,1,a),p=new zI(l);return t.runWebGLProgram(p,[o,s],"float32")}var z3={kernelName:Nm,backendName:"webgl",kernelFunc:tue};var rue=la+`
  return cos(x);
`,nue=Ae({opSnippet:rue}),G3={kernelName:xo,backendName:"webgl",kernelFunc:nue};var oue=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,sue=Ae({opSnippet:oue}),W3={kernelName:Io,backendName:"webgl",kernelFunc:sue};var GI=class{variableNames=["Image","Boxes","BoxInd"];outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e,[p]=t,[m,c]=n;this.outputShape=[p,m,c,l];let d=o==="bilinear"?1:0,[f,h]=[`${i-1}.0`,`${u-1}.0`],[g,b,T]=m>1?[`${(i-1)/(m-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,I,k]=c>1?[`${(u-1)/(c-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${I};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var aue=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,p=new GI(o.shape,s.shape,i,u,l);return t.runWebGLProgram(p,[o,s,a],"float32")},U3={kernelName:wa,backendName:"webgl",kernelFunc:aue};var Ig=class{constructor(e,t,n,o){this.op=e;this.outputShape=t;let s=this.outputShape.length,a=this.op==="*"?"1.0":"0.0",i=n?a:`getX(${K3(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1],l="",p="";n?(l=o?`end != ${u-1}`:"end != 0",p=o?"end + 1":"end - 1"):(l=o?`end + pow2 < ${u}`:"end >= pow2",p=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ve(s)} coords = getOutputCoords();
        int end = ${V3(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${p};
          ${V3(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${K3(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}variableNames=["x"];userCode;customUniforms=[{name:"index",type:"float"}]};function K3(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function V3(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function WI(r,e,t,n,o,s){let a=e.shape.length,i=C.getAxesPermutation([n],a),u=e;i!=null&&(u=Wt({inputs:{x:e},backend:t,attrs:{perm:i}}));let l=C.getInnerMostAxes(1,a)[0];if(l!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${n}`);let p=u.shape[l],m=ur({inputs:{x:u},backend:t});for(let c=0;c<=Math.ceil(Math.log2(p))-1;c++){let d=new Ig(r,u.shape,!1,s),f=[[c]],h=m;m=t.runWebGLProgram(d,[m],m.dtype,f),t.disposeIntermediateTensorInfo(h)}if(o){let c=new Ig(r,u.shape,o,s),d=m;m=t.runWebGLProgram(c,[m],m.dtype),t.disposeIntermediateTensorInfo(d)}if(i!=null){let c=C.getUndoAxesPermutation(i),d=Wt({inputs:{x:m},backend:t,attrs:{perm:c}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(u),d}return m}function uue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return WI("*",o,t,s,a,i)}var H3={kernelName:Aa,backendName:"webgl",kernelFunc:uue};function lue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return WI("+",o,t,s,a,i)}var q3={kernelName:Co,backendName:"webgl",kernelFunc:lue};function pue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=oI(u,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=EO(u,l,a,i);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var j3={kernelName:Uu,backendName:"webgl",kernelFunc:pue};var UI=class{variableNames=["x"];outputShape=[];userCode;blockSize;dataFormat;constructor(e,t,n){this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function mue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=l*s,d=p/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=new UI(f,s,a);return t.runWebGLProgram(h,[o],o.dtype)}var X3={kernelName:Na,backendName:"webgl",kernelFunc:mue};var Ff=class{variableNames=["x","W"];outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape,this.enableShapeUniforms=Dt(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,u=e.outChannels/e.inChannels,l="",p="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,p="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${m}
        ${p}
        setOutput(result);
      }
    `}};var Lf=class{variableNames=["x","W"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape,this.enableShapeUniforms=Dt(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,p=e.filterHeight,m=e.filterWidth,c=m,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<m;b++)d+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;d+=`
    for (int r = 0; r < ${p}; r++) {
      `;for(let b=0;b<m;b++)d+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(c+1)/2;b++){let T=b*2;if(d+=`
          xC = xCCorner + ${T*l};
          `,u===1){if(T<m&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,l===1&&T>0?d+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<m)){let x=i%2===0?y.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,l>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:d+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):x===1?d+=`
                    xC${T+1} = xTexelC${T};
                    `:d+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<m&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<m&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<m&&(d+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<m&&(d+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<m&&(d+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let f="",h="";n&&(o?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function cue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:l}=n,p=u;p==null&&(p=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let m=C.computeConv2DInfo(o.shape,s.shape,a,p,i,l,!0),c;$().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1?c=new Lf(m):c=new Ff(m);let d=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];return t.runWebGLProgram(c,[o,s],"float32",d)}var Y3={kernelName:ko,backendName:"webgl",kernelFunc:cue};var KI=class{variableNames=["x","dy"];outputShape;userCode;constructor(e){this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},VI=class{variableNames=["dy","W"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function due(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,filterShape:p}=n,m=C.computeConv2DInfo(o.shape,p,a,i,u,l,!0),c=new KI(m);return t.runWebGLProgram(c,[o,s],"float32")}var Z3={kernelName:Dm,backendName:"webgl",kernelFunc:due};function fue(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,inputShape:p}=n,m=C.computeConv2DInfo(p,s.shape,a,i,u,l,!0),c=new VI(m);return t.runWebGLProgram(c,[o,s],"float32")}var Q3={kernelName:_m,backendName:"webgl",kernelFunc:fue};var HI=class{variableNames=["X"];outputShape;userCode;constructor(e){this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function hue(r){let{inputs:e,backend:t}=r,{x:n}=e,o=[...n.shape,...n.shape],s=y.sizeFromShape(n.shape),a=ue({inputs:{x:n},backend:t,attrs:{shape:[s]}}),i=new HI(s),u=t.runWebGLProgram(i,[a],a.dtype),l=ue({inputs:{x:u},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),l}var J3={kernelName:Mm,backendName:"webgl",kernelFunc:hue};var qI=class{variableNames=["x","W"];outputShape;userCode;constructor(e){this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:o,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:u,dilationHeight:l,dilationWidth:p}=e,{top:m,left:c}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${m}, ${c});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function gue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n,l=C.computeDilation2DInfo(o.shape,s.shape,a,i,"NHWC",u),p,m=new qI(l);p=t.runWebGLProgram(m,[o,s],"float32");let c=ue({inputs:{x:p},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(p),c}var eG={kernelName:Ku,backendName:"webgl",kernelFunc:gue};function bue(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=C.getEinsumComputePath(i,u),m=p.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of p[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=Wt({inputs:{x:s[g]},backend:t,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let k=0;k<T.length;++k)I.splice(T[k],0,1);y.arraysEqual(x.shape,I)||(x=ue({inputs:{x},backend:t,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=Tg({inputs:{a:x,b:c},backend:t}),f.push(c))}h<m-1&&(l[h]>=0&&(c=Jp({inputs:{x:c},backend:t,attrs:{axis:l[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&t.disposeIntermediateTensorInfo(h);return c}var tG={kernelName:Vu,backendName:"webgl",kernelFunc:bue};var yue="return (x >= 0.0) ? x : (exp(x) - 1.0);",Tue=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,xue=Ae({opSnippet:yue,packedOpSnippet:Tue}),rG={kernelName:vo,backendName:"webgl",kernelFunc:xue};var Iue="return (b >= 1.0) ? a : a * (b + 1.0);",Cue=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,kue=r=>{let{inputs:e,backend:t}=r,{dy:n,y:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ua(Cue,n.shape,o.shape):new bs(Iue,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)},nG={kernelName:Rm,backendName:"webgl",kernelFunc:kue};var Sue=`
  return vec4(equal(a, b));
`,vue="return float(a == b);",Aue=dt({opSnippet:vue,packedOpSnippet:Sue,dtype:"bool",cpuKernelImpl:BO}),oG={kernelName:_a,backendName:"webgl",kernelFunc:Aue};var wue=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${C.ERF_P};
  float a1 = ${C.ERF_A1};
  float a2 = ${C.ERF_A2};
  float a3 = ${C.ERF_A3};
  float a4 = ${C.ERF_A4};
  float a5 = ${C.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Nue=Ae({opSnippet:wue}),sG={kernelName:Da,backendName:"webgl",kernelFunc:Nue};var Due=la+`
  return exp(x);
`,_ue=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,BD=Ae({opSnippet:Due,packedOpSnippet:_ue,cpuKernelImpl:OO,dtype:"float32"}),aG={kernelName:Ao,backendName:"webgl",kernelFunc:BD};function jI(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(y.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),ue({inputs:{x:s},backend:n,attrs:{shape:i}})}var iG={kernelName:Cs,backendName:"webgl",kernelFunc:jI};var uG="return exp(x) - 1.0;",Mue=Ae({opSnippet:uG,packedOpSnippet:uG,cpuKernelImpl:zO}),lG={kernelName:Ma,backendName:"webgl",kernelFunc:Mue};var Cg=class{variableNames=["real","imag"];outputShape;userCode;constructor(e,t,n){let o=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${o}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function XI(r,e,t){let n=t.texData.get(r.dataId),o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=o/s,i=ue({inputs:{x:r},backend:t,attrs:{shape:[a,s]}}),u=i.shape,l=new Cg("real",u,e),p=new Cg("imag",u,e),m=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],c=t.runWebGLProgram(l,m,"float32"),d=t.runWebGLProgram(p,m,"float32"),f=Bn({inputs:{real:c,imag:d},backend:t});t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d);let h=ue({inputs:{x:f},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),h}function Rue(r){let{inputs:e,backend:t}=r,{input:n}=e;return XI(n,!1,t)}var pG={kernelName:Pm,backendName:"webgl",kernelFunc:Rue};var YI=class{variableNames;outputShape=[];userCode;customUniforms=[{name:"value",type:"float"}];constructor(e,t){this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Mu(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let a=y.getArrayFromDType(s,y.sizeFromShape(n));return a.fill(o),e.makeTensorInfo(n,s,a)}else{let a=new YI(n,o),i=[[o]];return e.runWebGLProgram(a,[],s,i)}}var mG={kernelName:vi,backendName:"webgl",kernelFunc:Mu};var ZI=class{variableNames=["Image"];outputShape=[];userCode;constructor(e){let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var cG={kernelName:Ra,backendName:"webgl",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new ZI(t.shape);return n.runWebGLProgram(o,[t],t.dtype)}};var dG="return floor(x);",Pue=Ae({opSnippet:dG,packedOpSnippet:dG,cpuKernelImpl:GO}),fG={kernelName:wo,backendName:"webgl",kernelFunc:Pue};var Eue=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Fue=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Lue=dt({opSnippet:Eue,packedOpSnippet:Fue,dtype:"int32"}),hG={kernelName:No,backendName:"webgl",kernelFunc:Lue};var QI=class{variableNames=["A"];userCode;outputShape;constructor(e){let t=jt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var JI=class{variableNames=["A"];userCode;outputShape;packedInputs=!1;packedOutput=!0;constructor(e){let t=jt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var gG={kernelName:Vl,backendName:"webgl",kernelFunc:$ue},$f,OD=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function $ue(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n,a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[u,l]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],p=[l,u],m=[l,u,s];if(i||a){let h=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");($f==null||h!==OD)&&(OD=h,$f=document.createElement("canvas").getContext("2d",{willReadFrequently:OD})),$f.canvas.width=u,$f.canvas.height=l,$f.drawImage(o,0,0,u,l),o=$f.canvas}let c=t.makeTensorInfo(p,"int32");t.texData.get(c.dataId).usage=2,t.gpgpu.uploadPixelDataToTexture(t.getTexture(c.dataId),o);let d=$().getBool("WEBGL_PACK")?new JI(m):new QI(m),f=t.runWebGLProgram(d,[c],"int32");return t.disposeData(c.dataId),f}function Bue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=C.convertConv2DDataFormat(p),g=C.computeConv2DInfo(o.shape,s.shape,u,m,l,c,!1,h),b,T=[],x=a!=null,I=i!=null,k=d==="leakyrelu",w=()=>{let M=[o,s],R=(E,O)=>{if(O==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){let G=ue({inputs:{x:E},backend:t,attrs:{shape:[E.shape[0],1,1]}});return T.push(G),G}return E};if(x&&M.push(R(a,p)),I&&M.push(R(i,p)),k){let E=t.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));M.push(E),T.push(E)}return M};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))b=FI({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else if(g.strideWidth<=2&&h==="channelsLast"&&$().getBool("WEBGL_EXP_CONV")){let M=d?Du(d,!0):null,R=new Ef(g,x,M,I,k),E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],O=w();b=t.runWebGLProgram(R,O,"float32",E)}else if($().getBool("WEBGL_CONV_IM2COL"))b=LI({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else{let M=d?Du(d,!1):null,R=new Pf(g,x,M,I,k),E=w();b=t.runWebGLProgram(R,E,"float32")}let _=ue({inputs:{x:b},backend:t,attrs:{shape:g.outShape}});return T.push(b),T.forEach(M=>t.disposeIntermediateTensorInfo(M)),_}var bG={kernelName:Ls,backendName:"webgl",kernelFunc:Bue};function Oue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:m,activation:c,leakyreluAlpha:d}=n,f=[],h=p;h==null&&(h=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=C.computeConv2DInfo(o.shape,s.shape,u,h,l,m,!0),b=$().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,T=c?Du(c,b):null,x=[o,s],I=a!=null,k=i!=null,w=c==="leakyrelu";if(I&&x.push(a),k&&x.push(i),w){let E=t.makeTensorInfo([],"float32",y.createScalarValue(d,"float32"));x.push(E),f.push(E)}let _;b?_=new Lf(g,I,T,k,w):_=new Ff(g,I,T,k,w);let M=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],R=t.runWebGLProgram(_,x,"float32",M);return f.forEach(E=>t.disposeIntermediateTensorInfo(E)),R}var yG={kernelName:$s,backendName:"webgl",kernelFunc:Oue};var eC=class{constructor(e,t,n,o){this.sliceDim=e;this.strides=t;this.paramsShape=o;this.outputShape=n;let s=Ve(n.length),a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}variableNames=["x","indices"];outputShape;userCode};function zue(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,a=s[s.length-1],i=y.sizeFromShape(n.shape),[u,l,p,m]=C.prepareAndValidate(n,o),c=ue({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),d=ue({inputs:{x:n},backend:t,attrs:{shape:[y.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let b=t.readSync(o.dataId),T=t.bufferSync(n),x=WO(b,T,n.dtype,l,a,p,m,n.shape,i);return t.makeTensorInfo(u,n.dtype,x.values)}let f=new eC(a,m,[l,p],n.shape),h=t.runWebGLProgram(f,[d,c],d.dtype),g=ue({inputs:{x:h},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var TG={kernelName:Pa,backendName:"webgl",kernelFunc:zue};var tC=class{variableNames=["A","indices"];outputShape;userCode;rank;constructor(e,t){this.outputShape=t,this.rank=t.length;let n=Ve(this.rank),o=Gue(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function Gue(r,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${t[o]}`);return n.join()}function zD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0];if($().get("DEBUG")){let T=t.readSync(s.dataId),x=o.shape[u];for(let I=0;I<T.length;++I){let k=T[I];y.assert(k<=x-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${x-1}]`)}}let l=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),p=y.sizeFromShape(s.shape),m=[],c=ue({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=ue({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,p/l.batchSize]}});m.push(c),m.push(d);let f=[l.batchSize,l.outerSize,p/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let T=t.bufferSync(d),x=t.bufferSync(c),I=UO(x,T,f);return m.forEach(k=>t.disposeIntermediateTensorInfo(k)),t.makeTensorInfo(l.outputShape,I.dtype,I.values)}let h=new tC(c.shape,f),g=t.runWebGLProgram(h,[c,d],c.dtype);m.push(g);let b=ue({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return m.forEach(T=>t.disposeIntermediateTensorInfo(T)),b}var xG={kernelName:ks,backendName:"webgl",kernelFunc:zD};var Wue="return float(a > b);",Uue=`
  return vec4(greaterThan(a, b));
`,Kue=dt({opSnippet:Wue,packedOpSnippet:Uue,cpuKernelImpl:KO,dtype:"bool"}),IG={kernelName:Ea,backendName:"webgl",kernelFunc:Kue};var Vue="return float(a >= b);",Hue=`
  return vec4(greaterThanEqual(a, b));
`,que=dt({opSnippet:Vue,packedOpSnippet:Hue,dtype:"bool",cpuKernelImpl:VO}),CG={kernelName:_o,backendName:"webgl",kernelFunc:que};function jue(r){let{inputs:e,backend:t}=r,{input:n}=e;return XI(n,!0,t)}var kG={kernelName:Em,backendName:"webgl",kernelFunc:jue};var Xue="return float(!isnan(x) && !isinf(x));",Yue=Ae({opSnippet:Xue,dtype:"bool"}),SG={kernelName:Fa,backendName:"webgl",kernelFunc:Yue};var Zue="return float(isinf(x));",Que=Ae({opSnippet:Zue,dtype:"bool"}),vG={kernelName:La,backendName:"webgl",kernelFunc:Que};var Jue="return float(isnan(x));",ele=Ae({opSnippet:Jue,dtype:"bool"}),AG={kernelName:Mo,backendName:"webgl",kernelFunc:ele};var tle="return float(a < b);",rle=`
  return vec4(lessThan(a, b));
`,nle=dt({opSnippet:tle,packedOpSnippet:rle,cpuKernelImpl:HO,dtype:"bool"}),wG={kernelName:$a,backendName:"webgl",kernelFunc:nle};var ole="return float(a <= b);",sle=`
  return vec4(lessThanEqual(a, b));
`,ale=dt({opSnippet:ole,packedOpSnippet:sle,cpuKernelImpl:qO,dtype:"bool"}),NG={kernelName:Ba,backendName:"webgl",kernelFunc:ale};function ile(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=jO(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var DG={kernelName:Fm,backendName:"webgl",kernelFunc:ile};var ule=la+`
  return x < 0.0 ? 0./0. : log(x);
`,lle=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ple=Ae({opSnippet:ule,packedOpSnippet:lle,cpuKernelImpl:XO}),_G={kernelName:Po,backendName:"webgl",kernelFunc:ple};var mle=la+`
  return log(1.0 + x);
`,cle=Ae({opSnippet:mle}),MG={kernelName:Qi,backendName:"webgl",kernelFunc:cle};var dle="return float(a >= 1.0 && b >= 1.0);",fle=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,hle=dt({opSnippet:dle,packedOpSnippet:fle,dtype:"bool"}),RG={kernelName:Oa,backendName:"webgl",kernelFunc:hle};var gle="return float(!(x >= 1.0));",ble=Ae({opSnippet:gle}),PG={kernelName:za,backendName:"webgl",kernelFunc:ble};var yle="return float(a >= 1.0 || b >= 1.0);",Tle=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,xle=dt({opSnippet:yle,packedOpSnippet:Tle,dtype:"bool"}),EG={kernelName:Ji,backendName:"webgl",kernelFunc:xle};var rC=class{variableNames=["x"];outputShape=[];userCode;constructor(e,t,n,o,s){let a=t,i=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var nC=class{variableNames=["x"];outputShape=[];userCode;packedInputs=!0;packedOutput=!0;constructor(e,t,n,o,s){let a=t,i=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var Ile=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:u}=n,l=$().getBool("WEBGL_PACK_NORMALIZATION")?new nC(o.shape,s,a,i,u):new rC(o.shape,s,a,i,u);return t.runWebGLProgram(l,[o],o.dtype)},FG={kernelName:qu,backendName:"webgl",kernelFunc:Ile};var oC=class{variableNames=["inputImage","outputImage","dy"];outputShape=[];userCode;depthRadius;bias;alpha;beta;depth;constructor(e,t,n,o,s){this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Cle=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:u,alpha:l,beta:p}=n,m=new oC(o.shape,i,u,l,p);return t.runWebGLProgram(m,[o,s,a],o.dtype)},LG={kernelName:Lm,backendName:"webgl",kernelFunc:Cle};function $G(r,e,t,n){let o=y.sizeFromShape(e),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=ro(i,r.dtype,"max",n),l=ue({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}function GD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=p!=null,c=t.shouldExecuteOnCPU([o]),d=o;if(m){if(c){let x=t.texData.get(d.dataId).values,I=new Array(i);for(let _=0;_<I.length;_++)I[_]=o.shape[p[_]];let k=Qp(x,o.shape,o.dtype,p,I);d=t.makeTensorInfo(I,o.dtype);let w=t.texData.get(d.dataId);w.values=k}else d=Ll(o,p,t);l=C.getInnerMostAxes(l.length,i)}C.assertAxesAreInnerMostDims("max",l,i);let[f,h]=C.computeOutAndReduceShapes(d.shape,l),g=f;a&&(g=C.expandShapeToKeepDim(f,u));let b;if(c){let x=t.texData.get(d.dataId).values,I=YO(x,y.sizeFromShape(h),g,o.dtype);b=t.makeTensorInfo(g,o.dtype);let k=t.texData.get(b.dataId);k.values=I}else b=$G(d,h,g,t);return m&&t.disposeIntermediateTensorInfo(d),b}var BG={kernelName:Eo,backendName:"webgl",kernelFunc:GD};var kle=_f+`
  return max(a, b);
`,Sle=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vi+`
  return result;
`,vle=dt({opSnippet:kle,packedOpSnippet:Sle,cpuKernelImpl:ZO}),OG={kernelName:Fo,backendName:"webgl",kernelFunc:vle};function Ale(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;fi(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u);if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))return ur({inputs:{x:o},backend:t});let m=new gi(p,"max",!1);return t.runWebGLProgram(m,[o],o.dtype)}var zG={kernelName:Lo,backendName:"webgl",kernelFunc:Ale};function wle(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dataFormat:u,dimRoundingMode:l}=n,p=[1,1,1],m=C.computePool3DInfo(o.shape,s,a,p,i,l,u),c=new $l(m,"max",!1);return t.runWebGLProgram(c,[o],o.dtype)}var GG={kernelName:ju,backendName:"webgl",kernelFunc:wle};var sC=class{variableNames=["dy","maxPos"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,u=a-1-e.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},aC=class{variableNames=["dy","maxPos"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=u-1-e.padInfo.front,c=l-1-e.padInfo.top,d=p-1-e.padInfo.left,f=u*l*p-1;this.userCode=`
      const ivec3 pads = ivec3(${m}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Nle(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:p}=n,m=[1,1,1],c=C.computePool3DInfo(a.shape,i,u,m,l,p),d=new $l(c,"max",!0),f=t.runWebGLProgram(d,[a],a.dtype),h=new aC(c),g=t.runWebGLProgram(h,[o,f],a.dtype);return t.disposeIntermediateTensorInfo(f),g}var WG={kernelName:Bm,backendName:"webgl",kernelFunc:Nle};function Dle(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;fi([s,a],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:m}=n,c=C.computePool2DInfo(i.shape,u,l,1,p,m),d=!0,f=new gi(c,"max",d),h=t.runWebGLProgram(f,[i],i.dtype),g=new sC(c),b=t.runWebGLProgram(g,[o,h],i.dtype);return t.disposeIntermediateTensorInfo(h),b}var UG={kernelName:$m,backendName:"webgl",kernelFunc:Dle};function KG(r,e,t,n){let o=new gi(t,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new gi(t,"max",!0,!0,e);let a=n.runWebGLProgram(o,[r],"float32");return[s,a]}var VG={kernelName:Om,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,u=t;y.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];y.assert(C.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let p=C.computePool2DInfo(n.shape,o,s,l,a),[m,c]=KG(n,i,p,u);return[m,c]}};function HG(r,e,t,n){let o=y.sizeFromShape(e),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=ro(i,"float32","mean",n),l=ue({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}var qG={kernelName:$o,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{keepDims:o,axis:s}=e,a=t,i=n.shape.length,u=y.parseAxisParam(s,n.shape),l=u,p=C.getAxesPermutation(l,i),m=p!=null,c=a.shouldExecuteOnCPU([n]),d=[],f=n;if(m){if(c){let I=a.texData.get(f.dataId).values,k=new Array(i);for(let M=0;M<k.length;M++)k[M]=n.shape[p[M]];let w=Qp(I,n.shape,n.dtype,p,k);f=a.makeTensorInfo(k,n.dtype);let _=a.texData.get(f.dataId);_.values=w}else f=Ll(n,p,a);d.push(f),l=C.getInnerMostAxes(l.length,i)}C.assertAxesAreInnerMostDims("sum",l,i);let[h,g]=C.computeOutAndReduceShapes(f.shape,l),b=h;o&&(b=C.expandShapeToKeepDim(h,u));let T=HG(f,g,b,a);for(let x of d)a.disposeIntermediateTensorInfo(x);return T}};function _le(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=C.getInnerMostAxes(l.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",l,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,l),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,f]}}),g=ro(h,h.dtype,"min",t),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:t,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(m),b}var jG={kernelName:Bo,backendName:"webgl",kernelFunc:_le};var Mle=_f+`
  return min(a, b);
`,Rle=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Vi+`
  return result;
`,Ple=dt({opSnippet:Mle,packedOpSnippet:Rle,cpuKernelImpl:QO}),XG={kernelName:Oo,backendName:"webgl",kernelFunc:Ple};var iC=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n){this.outputShape=t.map((p,m)=>p[0]+e[m]+p[1]);let o=e.length,s=Ve(o),a=t.map(p=>p[0]).join(","),i=t.map((p,m)=>p[0]+e[m]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var uC=class{variableNames=["x"];packedInputs=!0;packedOutput=!0;outputShape;userCode;constructor(e,t,n){this.outputShape=t.map((f,h)=>f[0]+e[h]+f[1]);let o=e.length,s=Ve(o),a=t.map(f=>f[0]).join(","),i=t.map((f,h)=>f[0]+e[h]).join(","),u=ir("rc",o),l=ir("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,m=o===1?"source":`vec2(${l.slice(-2).join()})`,c=n==="reflect"?0:1,d="";if(o===1){let f=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${c};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${c};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${m});
        ${u[o-1]} += 1;
        if(${p}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${m});
        }
      `}else{let f=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${c}) +
                gte * ((end - 1) * 2 - source + ${c});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${m});
        ${u[o-1]} += 1;
        if(${p}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${m});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${m});
          ${u[o-1]} += 1;
          if(${p}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${m});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var Ele=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{paddings:o,mode:s}=t,a=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new uC(n.shape,o,s):new iC(n.shape,o,s);return e.runWebGLProgram(a,[n],n.dtype)},YG={kernelName:zo,backendName:"webgl",kernelFunc:Ele};var Fle=`if (b == 0.0) return NAN;
  return mod(a, b);`,Lle=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Vi+`
  return result;
`,$le=dt({opSnippet:Fle,packedOpSnippet:Lle}),ZG={kernelName:Ga,backendName:"webgl",kernelFunc:$le};var lC=class{variableNames=["probs"];outputShape;userCode;customUniforms=[{name:"seed",type:"float"}];constructor(e,t,n){this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};var Ble=`
if (a == b) {
  return 1.0;
};
return a / b;`,Ole=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,WD=dt({opSnippet:Ble,packedOpSnippet:Ole,checkOutOfBounds:!0}),QG={kernelName:So,backendName:"webgl",kernelFunc:WD};var JG="return a - b;",UD=dt({opSnippet:JG,packedOpSnippet:JG,supportsComplex:!0,cpuKernelImpl:yz}),eW={kernelName:as,backendName:"webgl",kernelFunc:UD};function KD(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=y.parseAxisParam([s],o.shape),i=GD({inputs:{x:o},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=C.expandShapeToKeepDim(i.shape,a),l=ue({inputs:{x:i},backend:t,attrs:{shape:u}}),p=UD({inputs:{a:o,b:l},backend:t}),m=BD({inputs:{x:p},backend:t}),c=Jp({inputs:{x:m},backend:t,attrs:{axis:a,keepDims:!1}}),d=ue({inputs:{x:c},backend:t,attrs:{shape:u}}),f=WD({inputs:{a:m,b:d},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),f}var tW={kernelName:os,backendName:"webgl",kernelFunc:KD};function zle(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n,u=i?o:KD({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),l=u.shape[0],p=u.shape[1],m=new lC(l,p,s),c=[[a]],d=t.runWebGLProgram(m,[u],"int32",c);return i||t.disposeIntermediateTensorInfo(u),d}var rW={kernelName:zm,backendName:"webgl",kernelFunc:zle};var Gle=Ir+`
  return -x;
`,Wle=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Ule(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.texData.get(n.dataId),[a,i]=ez(s.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,a)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new $n(n.shape,Wle):o=new Gr(n.shape,Gle),t.runWebGLProgram(o,[n],n.dtype)}var nW={kernelName:Ss,backendName:"webgl",kernelFunc:Ule};var Kle=xr.nonMaxSuppressionV3Impl;function Vle(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:m}=Kle(l,p,a,i,u);return t.makeTensorInfo([m.length],"int32",new Int32Array(m))}var oW={kernelName:Ua,backendName:"webgl",kernelFunc:Vle};var Hle=xr.nonMaxSuppressionV4Impl;function qle(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n,p=t.readSync(o.dataId),m=t.readSync(s.dataId),{selectedIndices:c,validOutputs:d}=Hle(p,m,a,i,u,l);return[t.makeTensorInfo([c.length],"int32",new Int32Array(c)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}var sW={kernelName:eu,backendName:"webgl",kernelFunc:qle};var jle=xr.nonMaxSuppressionV5Impl;function Xle(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),m=t.readSync(s.dataId),c=a,d=i,f=u,h=l,{selectedIndices:g,selectedScores:b}=jle(p,m,c,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var aW={kernelName:Ka,backendName:"webgl",kernelFunc:Xle};var pC=class{variableNames=["indices"];outputShape;userCode;seedLoc;constructor(e,t,n,o){this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var Yle=r=>{let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n,l=y.sizeFromShape(o.shape),p=new pC(l,a,i,u),m=ue({inputs:{x:o},backend:t,attrs:{shape:[l]}}),c=t.runWebGLProgram(p,[m],s);t.disposeIntermediateTensorInfo(m);let d=[...o.shape,a],f=ue({inputs:{x:c},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(c),f},iW={kernelName:Wo,backendName:"webgl",kernelFunc:Yle};function kg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=_u({inputs:{input:n},backend:t}),s=kg({inputs:{x:o},backend:t}),a=tm({inputs:{input:n},backend:t}),i=kg({inputs:{x:a},backend:t}),u=Bn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Mu({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var uW={kernelName:Ps,backendName:"webgl",kernelFunc:kg};function lW(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=_u({inputs:{input:n},backend:t}),s=lW({inputs:{x:o},backend:t}),a=tm({inputs:{input:n},backend:t}),i=kg({inputs:{x:a},backend:t}),u=Bn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Mu({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var pW={kernelName:vs,backendName:"webgl",kernelFunc:lW};function Zle(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return jI({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=jI({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=$D({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var mW={kernelName:As,backendName:"webgl",kernelFunc:Zle};var mC=class{variableNames=["x"];outputShape;userCode;customUniforms=[{name:"value",type:"float"}];constructor(e,t,n){this.outputShape=t.map((l,p)=>l[0]+e[p]+l[1]);let o=e.length,s=Ve(o),a=t.map(l=>l[0]).join(","),i=t.map((l,p)=>l[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var cC=class{variableNames=["x"];packedInputs=!0;packedOutput=!0;outputShape;userCode;customUniforms=[{name:"value",type:"float"}];constructor(e,t,n){this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=Ve(o),a=t.map(h=>h[0]).join(","),i=t.map((h,g)=>h[0]+e[g]).join(","),u=ir("rc",o),l=ir("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,m=o===1?"source":`vec2(${l.slice(-2).join()})`,c=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${p}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${p}) {`],d=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="";for(let h=0,g=o===1?2:4;h<g;h++)f+=`
        ${c[h]}
        if (${d}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${m});
        }
      `;f+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var VD=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;if(y.sizeFromShape(o.shape)===0){let l=s.map((p,m)=>p[0]+o.shape[m]+p[1]);return Mu({backend:t,attrs:{shape:l,value:a,dtype:o.dtype}})}let i=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new cC(o.shape,s,a):new mC(o.shape,s,a),u=[[a]];return t.runWebGLProgram(i,[o],o.dtype,u)},cW={kernelName:Uo,backendName:"webgl",kernelFunc:VD};var Qle=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Jle=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Vi+`
  return result;
`,epe=dt({opSnippet:Qle,packedOpSnippet:Jle}),dW={kernelName:Ko,backendName:"webgl",kernelFunc:epe};function tpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=[],l=y.parseAxisParam(s,o.shape),p=l,m=C.getAxesPermutation(p,i),c=o;m!=null&&(c=Wt({inputs:{x:o},backend:t,attrs:{perm:m}}),p=C.getInnerMostAxes(p.length,i),u.push(c)),C.assertAxesAreInnerMostDims("prod",p,i);let d;if(t.shouldExecuteOnCPU([c])){let f=t.texData.get(c.dataId).values,{outVals:h,outShape:g,outDtype:b}=rz(c.shape,c.dtype,f,p);d=t.makeTensorInfo(g,b,h)}else{let[f,h]=C.computeOutAndReduceShapes(c.shape,p),g=y.sizeFromShape(h),b=ue({inputs:{x:c},backend:t,attrs:{shape:[-1,g]}}),T=iu(o.dtype),x=ro(b,T,"prod",t);d=ue({inputs:{x},backend:t,attrs:{shape:f}}),u.push(b),u.push(x)}if(a){u.push(d);let f=C.expandShapeToKeepDim(d.shape,l);d=ue({inputs:{x:d},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}var fW={kernelName:Ho,backendName:"webgl",kernelFunc:tpe};function rpe(r){let{inputs:e,backend:t,attrs:n}=r,{paramsNestedSplits:o,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:i}=n,u=o.map(b=>t.readSync(b.dataId)),l=o.map(b=>b.shape),p=t.readSync(s.dataId),m=t.readSync(a.dataId),[c,d,f]=nz(u,l,p,s.shape,s.dtype,m,a.shape,i),h=c.map(b=>t.makeTensorInfo([b.length],"int32",b)),g=t.makeTensorInfo(f,s.dtype,d);return h.concat([g])}var hW={kernelName:Gm,backendName:"webgl",kernelFunc:rpe};function npe(r){let{inputs:e,backend:t}=r,{starts:n,limits:o,deltas:s}=e,a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=oz(a,n.shape,n.dtype,i,o.shape,u,s.shape),m=t.makeTensorInfo([l.length],"int32",l),c=t.makeTensorInfo([p.length],n.dtype,p);return[m,c]}var gW={kernelName:Wm,backendName:"webgl",kernelFunc:npe};function ope(r){let{inputs:e,backend:t,attrs:n}=r,{shape:o,values:s,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),m=t.readSync(a.dataId),c=i.map(g=>t.readSync(g.dataId)),d=i.map(g=>g.shape),[f,h]=sz(l,o.shape,p,s.shape,s.dtype,m,a.shape,c,d,u);return t.makeTensorInfo(f,s.dtype,h)}var bW={kernelName:Um,backendName:"webgl",kernelFunc:ope};var HD=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=az(n,o,s,a);return e.makeTensorInfo([i.length],a,i)},yW={kernelName:Ai,backendName:"webgl",kernelFunc:HD};var spe="return 1.0 / x;",ape=Ae({opSnippet:spe}),TW={kernelName:qo,backendName:"webgl",kernelFunc:ape};var ipe=Ir+`
  return (x < 0.0) ? 0.0 : x;
`,upe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,lpe=Ae({opSnippet:ipe,packedOpSnippet:upe}),xW={kernelName:jo,backendName:"webgl",kernelFunc:lpe};var ppe=Ir+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,mpe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cpe=Ae({opSnippet:ppe,packedOpSnippet:mpe}),IW={kernelName:Zo,backendName:"webgl",kernelFunc:cpe};var dC=class{variableNames=["A"];outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c;s?c="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":c="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/m[0]},
          ${p[1]/m[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var fC=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c;s?c="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":c="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/m[0]},
          ${p[1]/m[1]},
          ${p[1]/m[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function dpe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new fC(o.shape,u,l,s,a):new dC(o.shape,u,l,s,a);return t.runWebGLProgram(p,[o],"float32")}var CW={kernelName:Yo,backendName:"webgl",kernelFunc:dpe};var hC=class{variableNames=["dy"];outputShape=[];userCode;constructor(e,t,n){this.outputShape=t;let[,o,s]=t,[,a,i]=e,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],p=u[0]/l[0],m=u[1]/l[1],c=1/p,d=1/m,f=Math.ceil(c)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${m});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function fpe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new hC(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var kW={kernelName:Vm,backendName:"webgl",kernelFunc:fpe};var gC=class{variableNames=["A"];outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c=o?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/m[0]},
          ${p[1]/m[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var bC=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c=o?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/m[0]},
          ${p[1]/m[1]},
          ${p[1]/m[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function hpe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new bC(o.shape,u,l,s,a):new gC(o.shape,u,l,s,a);return t.runWebGLProgram(p,[o],o.dtype)}var SW={kernelName:Xo,backendName:"webgl",kernelFunc:hpe};var yC=class{variableNames=["dy"];outputShape=[];userCode;constructor(e,t,n){this.outputShape=t;let[,o,s]=t,[,a,i]=e,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],p=u[0]/l[0],m=u[1]/l[1],c=1/p,d=1/m,f=Math.ceil(c)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${m});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function gpe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new yC(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var vW={kernelName:Km,backendName:"webgl",kernelFunc:gpe};var TC=class{variableNames=["x"];outputShape;userCode;constructor(e,t){let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,u)=>o(u)).join(","),a=Ve(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var xC=class{variableNames=["x"];outputShape;userCode;packedInputs=!0;packedOutput=!0;constructor(e,t){let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let o=ir("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Ve(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${a}) {
            result.b = ${p(o.slice())};
            if(${s}) {
              result.a = ${m(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return c(f)}function l(f){return f[n-1]="("+f[n-1]+" + 1)",c(f)}function p(f){return f[n-2]="("+f[n-2]+" + 1)",c(f)}function m(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",c(f)}function c(f){let h=e.map((T,x)=>d(x,f)),g=h.join(","),b=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${b}))`}function d(f,h){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${h[f]} - 1`:`${h[f]}`}}};function bpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return ur({inputs:{x:o},backend:t});let u=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new xC(o.shape,i):new TC(o.shape,i);return t.runWebGLProgram(u,[o],o.dtype)}var AW={kernelName:Qo,backendName:"webgl",kernelFunc:bpe};var IC=class{variableNames=["Image"];outputShape=[];userCode;customUniforms=[{name:"params",type:"vec4"}];constructor(e,t){let n=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var wW={kernelName:Za,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=new IC(n.shape,s),[l,p]=C.getImageCenter(a,n.shape[1],n.shape[2]),m=[[l,p,Math.sin(o),Math.cos(o)]];return i.runWebGLProgram(u,[n],n.dtype,m)}};var ype=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Tpe=Ae({opSnippet:ype}),NW={kernelName:Va,backendName:"webgl",kernelFunc:Tpe};var xpe="return inversesqrt(x);",Ipe=Ae({opSnippet:xpe,cpuKernelImpl:iz}),DW={kernelName:Jo,backendName:"webgl",kernelFunc:Ipe};var Bf=class{variableNames=["updates","indices","defaultValue"];outputShape;userCode;constructor(e,t,n,o,s,a,i=!0){this.outputShape=a;let u=Ve(s.length),l=Ve(a.length),p="";n===1?p="i":n===2&&(p="i, j");let m=`getIndices(${p})`,c="";o===1?c="i":o===2&&(c="i, coords[1]");let d=`getUpdates(${c})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Cpe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:m}=C.calculateShapes(s,o,a),c=[m/l,l];if(m===0)return t.makeTensorInfo(a,o.dtype);let d=ue({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),f=ue({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new Bf(u,i,d.shape.length,f.shape.length,p,c),b=t.runWebGLProgram(g,[f,d,h],f.dtype),T=ue({inputs:{x:b},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(h),T}var _W={kernelName:Ha,backendName:"webgl",kernelFunc:Cpe};var CC=class{variableNames=["sortedSequence","values"];outputShape;userCode;customUniforms=[{name:"numInputs",type:"int"}];constructor(e,t,n,o){this.outputShape=[e,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=$().getNumber("WEBGL_VERSION")===2?s:a,u=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function kpe(r){let{inputs:e,backend:t,attrs:n}=r,{sortedSequence:o,values:s}=e,{side:a}=n,i=new CC(o.shape[0],o.shape[1],s.shape[1],a),u=[[o.shape[1]]];return t.runWebGLProgram(i,[o,s],"int32",u)}var MW={kernelName:Hm,backendName:"webgl",kernelFunc:kpe};var kC=class{variableNames=["c","a","b"];outputShape;userCode;constructor(e,t,n){this.outputShape=t;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let p=0;p<t.length;p++)l.push(`${i[p]}`),p<e&&u.push(`${i[p]}`);o=u.join(),s=l.join()}let a=Ve(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Spe(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=new kC(n.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(a,[n,o,s],Pt(o.dtype,s.dtype))}var RW={kernelName:Ns,backendName:"webgl",kernelFunc:Spe};var vpe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${C.SELU_SCALEALPHA};
  float scale = ${C.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Ape=Ae({opSnippet:vpe}),PW={kernelName:tu,backendName:"webgl",kernelFunc:Ape};var wpe=la+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Npe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Dpe=Ae({opSnippet:wpe,packedOpSnippet:Npe,cpuKernelImpl:lz}),EW={kernelName:ts,backendName:"webgl",kernelFunc:Dpe};var _pe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Mpe=Ae({opSnippet:_pe}),FW={kernelName:ru,backendName:"webgl",kernelFunc:Mpe};var Rpe=la+`
  return sin(x);
`,Ppe=Ae({opSnippet:Rpe}),LW={kernelName:es,backendName:"webgl",kernelFunc:Ppe};var Epe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Fpe=Ae({opSnippet:Epe}),$W={kernelName:qa,backendName:"webgl",kernelFunc:Fpe};var Lpe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,$pe=Ae({opSnippet:Lpe}),BW={kernelName:nu,backendName:"webgl",kernelFunc:$pe};var Bpe=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((b,T)=>b*T),u=[[0,0]];u.push(...a);for(let b=1+s.length;b<o.shape.length;++b)u.push([0,0]);let l=[],p=VD({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),m=C.getReshaped(p.shape,s,i,!1),c=C.getPermuted(m.length,s.length,!1),d=C.getReshapedPermuted(p.shape,s,i,!1),f=ue({inputs:{x:p},backend:t,attrs:{shape:m}}),h=Wt({inputs:{x:f},backend:t,attrs:{perm:c}}),g=ue({inputs:{x:h},backend:t,attrs:{shape:d}});return l.push(p),l.push(f),l.push(h),l.forEach(b=>t.disposeIntermediateTensorInfo(b)),g},OW={kernelName:_s,backendName:"webgl",kernelFunc:Bpe};function Ope(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.readSync(n.dataId),u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=t.readSync(a.dataId)[0],[m,c,d,f,h]=mz(i,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(c,n.dtype,m),t.makeTensorInfo([c[0]],o.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var zW={kernelName:Yu,backendName:"webgl",kernelFunc:Ope};function zpe(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.readSync(o.dataId)),i=t.readSync(n.dataId),u=Array.from(t.readSync(s.dataId)),[l,p,m]=cz(i,n.shape,n.dtype,a,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}var GW={kernelName:ou,backendName:"webgl",kernelFunc:zpe};function Gpe(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=aI(a,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var WW={kernelName:Zu,backendName:"webgl",kernelFunc:Gpe};function Wpe(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=aI(a,n.shape,n.dtype,i,u);return t.makeTensorInfo(p,n.dtype,l)}var UW={kernelName:Qu,backendName:"webgl",kernelFunc:Wpe};function Upe(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1;if(s.dtype==="string"){let b=t.bufferSync(o),T=t.bufferSync(s),x=y.decodeString(t.readSync(a.dataId)[0]),I=uz(b,T,i,c,p,l,u,m,x,d);return t.makeTensorInfo(i,I.dtype,I.values)}let f=new Bf(l,u,o.shape.length,s.shape.length,m,[c,1],d),h=t.runWebGLProgram(f,[s,o,a],s.dtype),g=ue({inputs:{x:h},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(h),g}var KW={kernelName:Ju,backendName:"webgl",kernelFunc:Upe};function Kpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=o.shape.length,p=new Array(l).fill(0),m=o.shape.slice();return u.map(c=>{let d=[...m];d[i]=c;let f=bi({inputs:{x:o},backend:t,attrs:{begin:p,size:d}});return p[i]+=c,f})}var VW={kernelName:Ms,backendName:"webgl",kernelFunc:Kpe};var HW="return sqrt(x);",Vpe=Ae({opSnippet:HW,packedOpSnippet:HW,cpuKernelImpl:dz}),qW={kernelName:rs,backendName:"webgl",kernelFunc:Vpe};var Hpe="return x * x;",qpe=Ae({opSnippet:Hpe}),jW={kernelName:wi,backendName:"webgl",kernelFunc:qpe};var XW="return (a - b) * (a - b);",jpe=dt({opSnippet:XW,packedOpSnippet:XW}),YW={kernelName:ss,backendName:"webgl",kernelFunc:jpe};function Xpe({inputs:r,attrs:e,backend:t}){let{x:n}=r,o=Ir+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new Gr(n.shape,o);return t.runWebGLProgram(s,[n],n.dtype)}var ZW={kernelName:Es,backendName:"webgl",kernelFunc:Xpe};var SC=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n){this.outputShape=n;let o=n.length,s=Ve(n.length),a=Ve(n.length),i="";if(o===1)i="coords * strides + begin";else{let u=0;i=n.map((l,p)=>(u++,n.length===1?`coords * strides[${p}] + begin[${p}]`:`coords[${u-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function Ype(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),k;if(h)k=ue({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let _=It.computeOutShape(T,x,I),M=bi({inputs:{x:o},backend:t,attrs:{begin:T,size:_}});k=ue({inputs:{x:M},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(M)}else if(t.shouldExecuteOnCPU([o])){let M=t.readSync(o.dataId),R=Ie(o.shape,o.dtype,M),E=fz(d,R,I,T);k=t.makeTensorInfo(f,o.dtype,E.values)}else{let M=new SC(T,I,d);k=t.runWebGLProgram(M,[o],o.dtype)}let w=ue({inputs:{x:k},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(k),w}var QW={kernelName:ja,backendName:"webgl",kernelFunc:Ype};function Zpe(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:m}=e,c=t.readSync(p.dataId),d=t.readSync(m.dataId),[f,h]=hz(c,d,o,s,a,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(m.shape,"int32",h)]}var JW={kernelName:Ni,backendName:"webgl",kernelFunc:Zpe};function Qpe(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.readSync(s.dataId),u=t.readSync(a.dataId)[0],[l,p,m]=gz(i,u,o),c=p.length;return[t.makeTensorInfo([c,2],"int32",l),t.makeTensorInfo([c],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(m))]}var eU={kernelName:el,backendName:"webgl",kernelFunc:Qpe};function Jpe(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=t.readSync(s.dataId),i=bz(a,o);return t.makeTensorInfo(s.shape,"int32",i)}var tU={kernelName:tl,backendName:"webgl",kernelFunc:Jpe};var eme="return tan(x);",tme=Ae({opSnippet:eme}),rU={kernelName:is,backendName:"webgl",kernelFunc:tme};var rme=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,nme=Ae({opSnippet:rme}),nU={kernelName:us,backendName:"webgl",kernelFunc:nme};var vC=class{variableNames=["A"];outputShape;userCode;rank;constructor(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=ome(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function ome(r){let e=r.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${r[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${t[o]}, ${r[o]})`);return n.join()}function qD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(c=>y.decodeString(c)):u,p=Ie(o.shape,o.dtype,l),m=Tz(p,s);return t.makeTensorInfo(m.shape,m.dtype,m.values)}let a=new vC(o.shape,s);return t.runWebGLProgram(a,[o],o.dtype)}var oU={kernelName:Dn,backendName:"webgl",kernelFunc:qD};var AC=class{variableNames=["x","indices"];outputShape;userCode;customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}];constructor(e){this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},wC=class{variableNames=["x","indices"];outputShape;userCode;customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}];constructor(e){this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function rm(r,e){e!==null&&r.disposeIntermediateTensorInfo(e)}function sU(r){let e=1;for(;e<r;)e*=2;return e}function sme(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n,i=$().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=$().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,p=l[l.length-1];if(t.shouldExecuteOnCPU([o])||p<i||s>u){let E=t.readSync(o.dataId),[O,G]=xz(E,l,o.dtype,s,a);return[t.makeTensorInfo(O.shape,O.dtype,O.values),t.makeTensorInfo(G.shape,G.dtype,G.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,o.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(p===1)return[o,Mu({attrs:{shape:l,dtype:"int32",value:0},backend:t})];let m=t.texData.get(o.dataId),c=m!==null&&m.isPacked,d=c?t.unpackTensor(o):o,h=y.sizeFromShape(l)/p,g=ue({inputs:{x:d},attrs:{shape:[h,p]},backend:t});c&&rm(t,d);let b=sU(s),T=sU(p),x=null,I=()=>x===null?[g,g]:[g,x],k=(E,O,G)=>{let W=I(),H=new AC(G),V=[[p],[x===null?1:0],[Number.NEGATIVE_INFINITY],[E],[O]],Y=x;x=t.runWebGLProgram(H,W,"int32",V),rm(t,Y)};for(let E=1;E<b;E*=2){let O=E*2;for(let G=E;G>=1;G/=2)k(O,G,[h,T])}for(let E=T;E>b;E/=2){let O=I(),G=new wC([h,E/2]),H=[[p],[x===null?1:0],[b]],U=x;x=t.runWebGLProgram(G,O,"int32",H),rm(t,U);let V=b/2,Y=V*2;for(let j=V;j>=1;j/=2)k(Y,j,x.shape)}let w=x;x=bi({inputs:{x},backend:t,attrs:{begin:0,size:[h,s]}}),rm(t,w);let _=zD({inputs:{x:g,indices:x},backend:t,attrs:{axis:1,batchDims:1}});rm(t,g);let M=l.slice(0,-1);M.push(s),w=x,x=ue({inputs:{x},attrs:{shape:M},backend:t}),rm(t,w);let R=_;return _=ue({inputs:{x:_},attrs:{shape:M},backend:t}),rm(t,R),[_,x]}var aU={kernelName:Xa,backendName:"webgl",kernelFunc:sme};var NC=class{variableNames=["Image","Transforms"];outputShape;userCode;constructor(e,t,n,o,s,a){this.outputShape=a;let i=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function ame(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=new NC(m,c,a,i,u,g);return t.runWebGLProgram(b,[o,s],"float32")}var iU={kernelName:Ya,backendName:"webgl",kernelFunc:ame};function ime(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;fi(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=n.readSync(s.dataId),{outputValues:i,outputShape:u,indices:l}=Iz(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}var uU={kernelName:qm,backendName:"webgl",kernelFunc:ime};function ume(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],l=new Array(i-1),p=0;for(let h=0;h<i;h++)h!==s&&(l[p++]=a.shape[h]);let m=[],c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){c[s]=h;let g=bi({inputs:{x:a},backend:t,attrs:{begin:c,size:d}}),b=ue({inputs:{x:g},backend:t,attrs:{shape:l}});f[h]=b,m.push(g)}return m.forEach(h=>t.disposeIntermediateTensorInfo(h)),f}var lU={kernelName:Rs,backendName:"webgl",kernelFunc:ume};var DC=class{variableNames=["x","segmentIds"];outputShape;userCode;constructor(e,t){let n=e.windowSize,o=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[o,i];let u="0.0",l="sumValue",p=Math.floor(n/4)*4,m=n%4,c=`
        sumValue += dot(values, segFilter);
    `,d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${c}
        }

        int inIdx = inOffset + ${p};
        if (${m===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${c}
        } else if (${m===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${c}
        } else if (${m===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${c}
        }
        setOutput(${l});
      }
    `}};function lme(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n,i=o.shape.length,u=[],l=0,p=C.getAxesPermutation([l],i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),u.push(m),l=C.getInnerMostAxes(1,i)[0]);let c=C.segment_util.computeOutShape(m.shape,l,a),d=y.sizeFromShape([m.shape[l]]),f=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,d]}});u.push(f);let h=iu(o.dtype),g=(I,k,w,_,M)=>{let R=I.shape[0],E=I.shape[1],O=C.segment_util.segOpComputeOptimalWindowSize(E,M),G={windowSize:O,inSize:E,batchSize:R,numSegments:M},W=new DC(G,k),H=t.compileAndRun(W,[I,w],_);if(u.push(H),H.shape[1]===M)return H;let U=HD({backend:t,attrs:{start:0,stop:M,step:1,dtype:"float32"}}),V=qD({inputs:{x:U},backend:t,attrs:{reps:[E/O]}});return u.push(U),u.push(V),g(H,k,V,_,M)},b=g(f,"unsortedSegmentSum",s,h,a),T=ue({inputs:{x:b},backend:t,attrs:{shape:c}}),x=T;if(p!=null){u.push(T);let I=C.getUndoAxesPermutation(p);x=Wt({inputs:{x},backend:t,attrs:{perm:I}})}return u.forEach(I=>t.disposeIntermediateTensorInfo(I)),x}var pU={kernelName:rl,backendName:"webgl",kernelFunc:lme};var pme=[Xz,Zz,Qz,Jz,t3,r3,n3,o3,i3,u3,l3,p3,m3,c3,d3,f3,h3,g3,b3,y3,T3,I3,C3,k3,w3,D3,_3,Oz,R3,E3,F3,L3,$3,B3,O3,z3,G3,W3,U3,H3,q3,j3,X3,Y3,Z3,Q3,J3,eG,tG,rG,nG,oG,sG,aG,iG,lG,pG,mG,cG,fG,hG,gG,bG,yG,TG,xG,IG,CG,Bz,kG,P3,SG,vG,AG,zz,wG,NG,DG,_G,MG,RG,PG,EG,FG,LG,BG,OG,zG,GG,WG,UG,VG,qG,jG,XG,YG,ZG,rW,Uz,nW,oW,sW,aW,S3,iW,pW,mW,cW,dW,Gz,fW,hW,gW,bW,yW,v3,QG,TW,xW,IW,Vz,CW,kW,SW,vW,AW,wW,NW,DW,_W,MW,RW,PW,EW,FW,LW,$W,x3,tW,BW,OW,zW,GW,WW,UW,KW,VW,qW,jW,YW,ZW,QW,JW,eU,tU,eW,qz,rU,nU,oU,aU,iU,jz,uU,lU,pU,uW];for(let r of pme)su(r);var yi=$();yi.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);yi.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);yi.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);yi.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1);yi.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);yi.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);yi.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);yi.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);yi.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);yi.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>0);yi.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);var _C=class{vendor;architecture;intelGPUGeneration;constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}};var MC=class{constructor(e){this.device=e}numUsedBuffers=0;numFreeBuffers=0;freeBuffers=new Map;usedBuffers=new Map;numBytesUsed=0;numBytesAllocated=0;acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){let o=mU(e,t);if(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(o).length>0){this.numFreeBuffers--;let a=this.freeBuffers.get(o).shift();return this.usedBuffers.get(o).push(a),a}this.numBytesAllocated+=e;let s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(o).push(s),s}releaseBuffer(e,t,n){if(this.freeBuffers.size===0)return;let o=mU(t,n);this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).push(e),this.numFreeBuffers++,this.numUsedBuffers--;let s=this.usedBuffers.get(o),a=s.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(a,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(e,t,n)},o=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function mU(r,e){return`${r}_${e}`}var RC=class{constructor(e){this.device=e}numUsedTextures=0;numFreeTextures=0;freeTextures=new Map;usedTextures=new Map;numBytesUsed=0;numBytesAllocated=0;acquireTexture(e,t,n,o){let s=dU(n),a=e*t*s,i=cU(e,t,n,o);if(this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.usedTextures.has(i)||this.usedTextures.set(i,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(i).length>0){this.numFreeTextures--;let l=this.freeTextures.get(i).shift();return this.usedTextures.get(i).push(l),l}this.numBytesAllocated+=a;let u=this.device.createTexture({size:[e,t],format:n,usage:o});return this.usedTextures.get(i).push(u),u}releaseTexture(e,t,n,o,s){if(this.freeTextures.size===0)return;let a=cU(t,n,o,s);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;let i=this.usedTextures.get(a),u=i.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");i.splice(u,1);let l=dU(o),p=t*n*l;this.numBytesUsed-=p}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function cU(r,e,t,n){return`${r}_${e}_${t}_${n}`}function dU(r){if(r==="rgba8unorm")return 16;throw new Error(`${r} is not supported!`)}function fU(r,e){if(Math.max(...r)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}var TU=(r,e,t,n)=>{let o={dtype:n.dtype,shape:n.shape},s=cme(t,o,e),a=r.createShaderModule({code:s,label:e.constructor.name});return r.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})};function lr(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";if(r===5)return"vec5";if(r===6)return"vec6";throw Error(`GPU for rank ${r} is not yet supported`)}function pa(r){if(r===0)return"x";if(r===1)return"y";if(r===2)return"z";if(r===3)return"w";if(r===4)return"u";if(r===5)return"v";throw Error(`Index ${r} is not yet supported`)}function de(...r){let e;switch(r.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${r[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function hU(r){let e;return e=`
     ${mme()}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${r?"main(getGlobalIndex());":"main();"};
      }
    `,e}function mme(){return`
  @compute @workgroup_size(workgroupSizeX, workgroupSizeY, workgroupSizeZ)
`}function cme(r,e,t){let n=[],o=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(n.push(`
      const workgroupSizeX = ${t.workgroupSize[0]}u;
      const workgroupSizeY = ${t.workgroupSize[1]}u;
      const workgroupSizeZ = ${t.workgroupSize[2]}u;

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${IU(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${o} +
                localIndex);
        `}
      }
    `),t.isFromPixels){n.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${Of(e.dtype,t.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);let f=yU(t);return[gU,n.join(`
`),bU(e.shape),t.getUserCode(),hU(f)].join(`
`)}let s="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((f,h)=>{let g=lr(r[h].shape.length);s+=`${f.charAt(0).toLowerCase()+f.slice(1)}Shape : ${g}, `}),s+=`outShape : ${lr(e.shape.length)}, `;let i=e.shape.length-1;s+=`
         outShapeStrides: ${lr(i)}, `,t.size&&(s+="size : i32, "),t.uniforms&&(s+=t.uniforms),s+="};",s=xme(s),n.push(s),t.atomic?n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Of(e.dtype,t.isVec4)}>;
    `),t.variableNames.forEach((f,h)=>{n.push(`
      @group(0) @binding(${1+h}) var<storage, read> ${f}: array<${t.variableTypes?t.variableTypes[h]:Of(r[h].dtype,t.isVec4)}>;
        `)}),s!==""&&n.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);let l=bme(e.shape,t.dispatchLayout),p=[gU+dme,n.join(`
`),bU(e.shape),l,yme(e.shape.length)];t.atomic||p.push(Tme(e.shape,e.dtype,t.isVec4));let m=r.map((f,h)=>gme(f,e.shape,t.variableTypes?t.variableTypes[h]==="vec4<f32>":t.isVec4,t.dispatchLayout.x.length===e.shape.length)).join(`
`);p.push(m),p.push(t.getUserCode());let c=yU(t);return p.push(hU(c)),p.join(`
`)}function xU(r,e,t,n){let o=r.shaderKey;if(r.isFromPixels)return o;let s=t.map(p=>p.dtype).concat(n.dtype),a=t.map(p=>C.getBroadcastDims(p.shape,n.shape)),i=t.map(p=>y.arraysEqual(p.shape,n.shape)).join("_"),u=a.map(p=>p.join("_")).join(";"),l=IU(r)?"flatDispatch":"";return o+="_"+(r.workgroupSize?r.workgroupSize.join(","):"")+e.map(p=>p.length).join(",")+s.join(",")+r.variableNames.join(",")+u+i+l,o}var gU=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`,dme=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function bU(r){let e=r.length;if(e<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";let t=y.computeStrides(r),n=lr(e),o=[];for(let a=0;a<e;a++)o.push(`d${a}`);if(t.length===1)return`    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let s;return s="var index2 = index;"+t.map((a,i)=>{let u=`let ${o[i]} = index2 / uniforms.outShapeStrides.${pa(i)}`,l=i===t.length-1?`let ${o[i+1]} = index2 - ${o[i]} * uniforms.outShapeStrides.${pa(i)}`:`index2 = index2 - ${o[i]} * uniforms.outShapeStrides.${pa(i)}`;return`${u}; ${l};`}).join(""),`
    fn getCoordsFromIndex(index : i32) -> ${n} {
      ${s}
      return ${n}(${o.join(",")});
    }
  `}function fme(r,e){let t=r.name,n=r.shape.length,o=lr(n),s="get"+t.charAt(0).toUpperCase()+t.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,n),i=a.map(p=>`${p} : i32`).join(", ");if(n<1)return e?`
        fn ${s}() -> vec4<f32> {
          return vec4<f32>(${t}[0]);
        }
      `:`
      fn ${s}() ->f32 {
        return f32(${t}[0]);
      }
    `;let u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`,l=`${n}D`;return n===0&&(l="1D"),e?`
      fn ${s}(${i}) -> vec4<f32> {
        return vec4<f32>(${t}[getIndexFromCoords${l}(${o}(${a.join(",")}),
          ${u}) / 4]);
      }
      `:`
    fn ${s}(${i}) -> f32 {
      return f32(${t}[getIndexFromCoords${l}(${o}(${a.join(",")}),
        ${u})]);
    }
   `}function hme(r,e,t,n){let o=r.name,s=o.charAt(0).toUpperCase()+o.slice(1),a="get"+s+"ByOutput",i=r.shape.length,u=e.length,l=lr(u);if(y.arraysEqual(r.shape,e)&&n)return t?`
      fn ${a}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${o}[globalIndex]);
      }

      fn ${a}Coords(coords : ${l}) -> vec4<f32> {
        return vec4<f32>(${o}[${u>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);
      }
      `:`
    fn ${a}Index(globalIndex : i32) -> f32 {
      return f32(${o}[globalIndex]);
    }

    fn ${a}Coords(coords : ${l}) -> f32 {
      return f32(${o}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}]);
    }
    `;let p=C.getBroadcastDims(r.shape,e),m=u-i,c="";if(i===0)return t?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      return get${s}();
    }

    fn ${a}Coords(coords : ${l}) -> vec4<f32> {
      return get${s}();
    }
  `:`
    fn ${a}Index(globalIndex : i32) -> f32{
      return get${s}();
    }

    fn ${a}Coords(coords : ${l}) -> f32{
      return get${s}();
    }
  `;u<2&&p.length>=1?c="coords = 0;":c=p.map(g=>`coords.${pa(g+m)} = 0;`).join(`
`);let d="";if(u<2&&i>0)d="coords";else if(u>1){let g=lr(i),b=r.shape.map((T,x)=>`coords.${pa(x+m)}`).join(", ");d=`${g}(${b})`}else d="coords";let f=`uniforms.${o.charAt(0).toLowerCase()+o.slice(1)}Shape`,h=`${i}D`;return t?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${c}
      return ${o}[getIndexFromCoords${h}(${d}, ${f}) / 4];
    }

    fn ${a}Coords(coordsIn : ${l}) -> vec4<f32> {
      var coords = coordsIn;
      ${c}
      return ${o}[getIndexFromCoords${h}(${d}, ${f}) / 4];
    }
  `:`
  fn ${a}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${c}
    return f32(${o}[getIndexFromCoords${h}(${d}, ${f})]);
  }

  fn ${a}Coords(coordsIn : ${l}) -> f32 {
    var coords = coordsIn;
    ${c}
    return f32(${o}[getIndexFromCoords${h}(${d}, ${f})]);
  }
`}function gme(r,e,t,n){let o=fme(r,t);return r.shape.length<=e.length&&(o+=hme(r,e,t,n)),o}function bme(r,e){let{x:t,y:n=[],z:o=[]}=e,s=r.length,a=t.length+n.length+o.length;if(a!==s)return"";if(t.length===s)return`fn getOutputCoords() -> ${lr(s)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let i="",u=[t,n,o];for(let c=0;c<u.length;c++){let d=u[c];if(d.length!==0)if(d.length===1)i+=`let d${d[0]} = i32(globalId[${c}]);`;else{let f=fU(d,"uniforms.outShape");i+=`var index${c} = i32(globalId[${c}]);`;for(let h=0;h<f.length;h++)i+=`let d${d[h]} = index${c} / ${f[h]};`,h===f.length-1?i+=`let d${d[h+1]} = index${c} - d${d[h]} * ${f[h]};`:i+=`index${c} = index${c} - d${d[h]} * ${f[h]};`}}let l=[];for(let c=0;c<a;c++)l.push(`d${c}`);let p=lr(a),m=`fn getOutputCoords() -> ${p} {
  ${i}
`;return l.length===0?m+=`return ${p}(0); }`:m+=`return ${p}(${l.join(",")}); }`,m}function yme(r){let e="";switch(r){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:y.assert(!1,()=>`Unsupported ${r}D shape`);break}return e}function IU(r){return r.dispatch[1]===1&&r.dispatch[2]===1}function Of(r,e){return r==="float32"?e?"vec4<f32>":"f32":r==="int32"||r==="bool"?e?"vec4<i32>":"i32":r}function Tme(r,e,t){let n=r.length,o=Of(e,t),s;if(t?s=`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${o}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${o}(value);
    }`:s=`fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${o}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${o}(value);
    }`,n>=2){let a=["d0","d1","d2","d3","d4","d5"].slice(0,n),i=lr(n);t?s+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `:s+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `}return s}function xme(r){let e=/(\w+)\s*:\s*vec(5|6)/g;r=r.replace(e,n=>"@align(16) "+n);let t=/vec(5|6)\s*,\s*(\w+)/g;return r=r.replace(t,(n,o,s)=>`vec${o}, @align(16) ${s}`),r}function yU(r){return!(r.dispatchLayout.hasOwnProperty("y")&&r.dispatchLayout.y.length!==0||r.dispatchLayout.hasOwnProperty("z")&&r.dispatchLayout.z.length!==0)}var QD={};qe(QD,{ArrayBufferToTypedArray:()=>YD,GPUBytesPerElement:()=>XD,MatMulProgramType:()=>ZD,computeDispatch:()=>ce,computeWorkPerThreadForConv2d:()=>vg,computeWorkgroupInfoForMatMul:()=>jD,computeWorkgroupSizeForConv2d:()=>Sg,flatDispatchLayout:()=>xe,isWebGPUSupported:()=>Ag,tilesFitEvenlyIntoShape:()=>Cme});var nm=r=>{let e=1;for(let t=0;t<r.length;t++)e*=r[t];return e};function Cme(r,e){if(r.length!==e.length)throw new Error(`Cannot compute whether rank ${r.length} tiles fit evenly into rank ${e.length} shape - ranks must match.`);return e.every((t,n)=>t%r[n]===0)}function ce(r,e,t=[1,1,1],n=[1,1,1]){let[o,s,a]=[Math.ceil(nm(r.x.map(i=>e[i]))/(t[0]*n[0])),r.y?Math.ceil(nm(r.y.map(i=>e[i]))/(t[1]*n[1])):1,r.z?Math.ceil(nm(r.z.map(i=>e[i]))/(t[2]*n[2])):1];return[o,s,a]}function jD(r,e,t,n=!1){let o=[8,8,1],s=[4,4,1];return n||(r<=8&&(s[1]=1),e<=16&&t<=16&&(o[0]=4)),{workgroupSize:o,elementsPerThread:s}}function Sg(r,e,t=!1){if(t)return[8,8,1];let n=nm(r.x.map(s=>e[s])),o=nm(r.y.map(s=>e[s]));return n<=4?[4,16,1]:o<=4?[16,4,1]:[16,16,1]}function vg(r,e,t=!1){if(t)return[4,4,1];let n=nm(r.x.map(s=>e[s])),o=nm(r.y.map(s=>e[s]));return n<=4?[1,2,1]:o<=4?[2,1,1]:[2,2,1]}function xe(r){return{x:r.map((e,t)=>t)}}function XD(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function YD(r,e){if(e==="float32")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${e}`)}function Ag(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}var ZD=(s=>(s[s.MatMulReduceProgram=0]="MatMulReduceProgram",s[s.MatMulSplitKProgram=1]="MatMulSplitKProgram",s[s.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",s[s.MatMulPackedProgram=3]="MatMulPackedProgram",s[s.MatMulMax=4]="MatMulMax",s))(ZD||{});var kme=$().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Sme=(r,e)=>{let t=r.limits.maxComputeWorkgroupsPerDimension,n=e.dispatchLayout,o=e.dispatch;if(o.every(a=>a<=t))return o;y.assert(o[0]>t&&n.y===void 0&&n.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let s=Math.ceil(Math.sqrt(o[0]));return s>t?(s=Math.ceil(Math.cbrt(o[0])),y.assert(s<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[s,s,s]):[s,s,1]},JD=class extends po{bufferManager;adapterInfo;device;queue;tensorMap;textureManager;thresholdToIncreaseWorkgroups;activeTimers;currentCommandEncoder;currentComputePass;commandQueueOwnedIds=new WeakSet;dispatchNumberInEncoder=0;disposed=!1;downloadWaitMs=0;dummyCanvas;dummyContext;tensorDataPendingDisposal=[];pipelineCache;programTimersStack;querySet;stagingPendingDisposal=[];supportTimeQuery;uniformPendingDisposal=[];uploadWaitMs=0;nextDataId(){return JD.nextDataId++}constructor(e,t){if(super(),!Ag())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new _C(t),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new MC(this.device),this.textureManager=new RC(this.device),this.tensorMap=new fa(this,rn()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),$().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;let n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;let{complexTensorInfos:o}=this.tensorMap.get(e);return o!=null&&(this.disposeData(o.real.dataId,t),this.disposeData(o.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){let t=this.tensorMap.get(e);if(!(!t||!t.resourceInfo)){if("texture"in t.resourceInfo){let n=t.resourceInfo;n.texture instanceof GPUTexture&&this.textureManager.releaseTexture(n.texture,n.width,n.height,n.format,n.usage),n.texture=null}else{let n=t.resourceInfo;this.bufferManager.releaseBuffer(n.buffer,n.size,n.usage),n.buffer=null}t.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);t.refCount--}}write(e,t,n){if(n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.tensorMap.set(o,{dtype:n,shape:t,values:e,refCount:1}),o}move(e,t,n,o,s){if(o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:o,shape:n,values:t,refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){let n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);let o=n.getMappedRange().slice(0);return n.unmap(),n!=null&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),$().getBool("WEBGPU_USE_PROFILE_TOOL")&&(y.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),o}convertAndCacheOnCPU(e,t){let n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){let t=this.tensorMap.get(e),{values:n}=t;if(n==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let t=this.tensorMap.get(e),{values:n}=t;if(n!=null)return this.convertAndCacheOnCPU(e,n);let o;if(t.dtype==="complex64"){let s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),a=s[0],i=s[1];o=C.mergeRealAndImagArrays(a,i)}else{let s=t.resourceInfo,a=await this.getBufferData(s.buffer,s.size);o=YD(a,t.dtype)}return this.convertAndCacheOnCPU(e,o),o}readToGPU(e){let t=this.tensorMap.get(e),{values:n,dtype:o,shape:s,resourceInfo:a}=t;if(o==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw n!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let i=a.size,u=this.bufferManager.acquireBuffer(i,a.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a.buffer,0,u,0,i),this.submitQueue();let l=this.makeTensorInfo(s,o),p=rn().makeTensorFromTensorInfo(l),m=this.tensorMap.get(l.dataId);return m.resourceInfo={size:i,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:p,buffer:u,bufSize:i}}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(o=>y.decodeString(o));return Ie(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ie(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=y.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=y.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(s);return i.kernelMs=y.sum(u),i.getExtraProfileInfo=()=>u.map((l,p)=>({name:a[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,i}makeTensorInfo(e,t,n){return t==="string"&&n!=null&&n.length>0&&y.isString(n[0])&&(n=n.map(s=>y.encodeString(s))),{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;let t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){let o=t.resourceInfo;return o.texture instanceof GPUExternalTexture?o.texture:o.texture.createView()}let n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){let t=this.tensorMap.get(e);if(t.resourceInfo)return;let n=XD(t.dtype)*y.sizeFromShape(t.shape),o=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:o},t.values){let s=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),a=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),s.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s,0,o,0,n);let i={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:s};this.stagingPendingDisposal.push(i)}}makeUniforms(e){let t=0,n=0,o=[];e.forEach(u=>{u.data.length===0&&(u.data=[1]);let l;switch(u.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:y.assert(!1,()=>`Unsupported ${u.data.length}D shape`)}(n===5||n===6)&&(l=16),t=Math.ceil(t/l)*l,n=u.data.length,o.push(t),t+=u.data.length*4});let s=new ArrayBuffer(t);e.forEach((u,l)=>{let p=o[l];u.type==="int32"?new Int32Array(s,p,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(s,p,u.data.length).set(u.data):new Float32Array(s,p,u.data.length).set(u.data)});let a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,s,0,t);let i={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(i),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,n,o,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),y.sizeFromShape(s.shape)===0)return this.tensorMap.get(s.dataId).values=y.getTypedArrayFromDType(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=Sme(this.device,e);let a=[],i=[];if(!e.isFromPixels){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=t.concat(s).map(b=>b.shape);let h="int32";i.map(b=>{a.push({type:h,data:b})});let g=y.computeStrides(s.shape);if(a.push({type:h,data:g}),e.size){let b=y.sizeFromShape(e.outputShape);a.push({type:h,data:[e.isVec4?b/4:b]})}}let u=t.map((h,g)=>{if(h.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(h.dataId),{dtype:this.tensorMap.get(h.dataId).dtype,shape:h.shape,name:e.variableNames[g]}}),l=xU(e,i,u,s),p;l in this.pipelineCache?p=this.pipelineCache[l]:(p=TU(this.device,e,u,s),this.pipelineCache[l]=p),o&&(a=[...a,...o]);let m=[this.tensorToBinding(s),...t.map(h=>this.tensorToBinding(h)),this.makeUniforms(a)],c=this.device.createBindGroup({layout:p.getBindGroupLayout(0),entries:m.map((h,g)=>({binding:g,resource:h}))});this.ensureCommandEncoderReady();let d=this.getComputePass(),f=this.activeTimers!=null;return f&&this.supportTimeQuery&&d.writeTimestamp(this.querySet,0),d.setPipeline(p),d.setBindGroup(0,c),d.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),f&&this.supportTimeQuery&&d.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(h=>{this.commandQueueOwnedIds.add(h.dataId)}),this.commandQueueOwnedIds.add(s.dataId),$().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),f&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}async getTimeFromQuerySet(e){let t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);let o=new BigUint64Array(n.getMappedRange()),s=Number(o[1]-o[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,t=kme){return $().getBool("WEBGPU_CPU_FORWARD")&&e.every(n=>this.tensorMap.get(n.dataId).resourceInfo==null&&y.sizeFromShape(n.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}},zf=JD;K(zf,"nextDataId",0);Ag()&&ul("webgpu",async()=>{$().set("CHECK_COMPUTATION_FOR_ERRORS",!1);let r={powerPreference:$().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(r),t={};e.features.has("timestamp-query-inside-passes")&&(t.requiredFeatures=["timestamp-query-inside-passes"]);let n=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:n.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.maxStorageBufferBindingSize};let o=await e.requestDevice(t),s=await e.requestAdapterInfo();return new zf(o,s)},3);var CU=`
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `,kU=`
  if (isNaN.r) {
    resultTemp.r = valueForNaN;
  }
  if (isNaN.g) {
    resultTemp.g = valueForNaN;
  }
  if (isNaN.b) {
    resultTemp.b = valueForNaN;
  }
  if (isNaN.a) {
    resultTemp.a = valueForNaN;
  }
  `,t0=`
  let isNaN = isnanVec4(a) | isnanVec4(b);
  ${kU}
  `,vme="return a + b;",Ame="return areal * breal - aimag * bimag;",wme="return areal * bimag + aimag * breal;",Nme="return a / b;",Dme="return f32(a == b);",_me="return vec4<f32>(a == b);",Mme="return f32(a > b);",Rme="return vec4<f32>(a > b);",Pme="return f32(a >= b);",Eme="return vec4<f32>(a >= b);",Fme=`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
`,Lme=`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
`,$me="return f32(a < b);",Bme="return vec4<f32>(a < b);",Ome="return f32(a <= b);",zme="return vec4<f32>(a <= b);",Gme="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",Wme=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Ume=`
  ${CU}
  if (b == 0.) {
    return uniforms.NAN;
  }
  var resultTemp = a % b;
  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {
    return resultTemp;
  } else {
    return (resultTemp + b) % b;
  }
`,Kme=`
  let valueForNaN = uniforms.NAN;
  var resultTemp = vec4<f32>(a % b);
  ${t0}

  if (b[0] == 0.) {
    resultTemp[0] = uniforms.NAN;
  }
  if (b[1] == 0.) {
    resultTemp[1] = uniforms.NAN;
  }
  if (b[2] == 0.) {
    resultTemp[2] = uniforms.NAN;
  }
  if (b[3] == 0.) {
    resultTemp[3] = uniforms.NAN;
  }

  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }

  return resultTemp;
`,Vme="return a * b;",Hme=`
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`,qme=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${t0}

  return resultTemp;
`,jme=`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
`,Xme=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
  let valueForNaN = uniforms.NAN;
  ${kU}
  return resultTemp;
`,Yme="if (a < 0.0) { return b * a; }  return a;",Zme=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Qme="return (a - b) * (a - b);",Jme="return a - b;";function e0(r,e,t="uniforms.NAN"){let n=e?t0:CU;return e?`
    let valueForNaN = ${t};
    var resultTemp = vec4<f32>(${r}(a, b));
    `+n+`
    return resultTemp;
  `:n+`
    return ${r}(a, b);
  `}function Gf(r,e){switch(r){case 0:return vme;case 1:return e0("atan2",e);case 2:return wme;case 3:return Ame;case 4:return Nme;case 5:return e?_me:Dme;case 6:return e?Rme:Mme;case 7:return e?Eme:Pme;case 8:return e?Lme:Fme;case 9:return e?Bme:$me;case 10:return e?zme:Ome;case 11:return e?Wme:Gme;case 12:return e0("max",e);case 13:return e0("min",e);case 14:return e?Kme:Ume;case 15:return Vme;case 16:return e?qme:Hme;case 17:return e?Xme:jme;case 18:return e?Zme:Yme;case 19:return Qme;case 20:return Jme;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var ece="return abs(a);",tce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,rce=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,nce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,oce="return asinh(a);",sce=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,ace=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,ice="return ceil(a);",uce="return cos(a);",lce=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,pce="return exp(a) - 1.0;",mce="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",cce=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,dce=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${C.ERF_P};
  let a1 = ${C.ERF_A1};
  let a2 = ${C.ERF_A2};
  let a3 = ${C.ERF_A3};
  let a4 = ${C.ERF_A4};
  let a5 = ${C.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,fce="return exp(a);",hce="return floor(a);",gce="return f32(!isnan(a) && !isinf(a));",bce="return f32(isinf(a));",yce="return f32(isnan(a));",Tce="return a;",xce=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,Ice="return f32(!(a >= 1.0));",Cce="return -a;",kce="if (a < 0.0) { return uniforms.alpha * a; } return a;",Sce=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,vce="return 1.0 / a;",Ace="return select(a, 0.0, a < 0.0);",wce="return clamp(a, 0.0, 6.0);",Nce="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",Dce=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,_ce="return inverseSqrt(a);",Mce="return 1.0 / (1.0 + exp(-1.0 * a));",Rce="return sin(a);",Pce=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,Ece="return sqrt(a);",Fce="return a * a;",Lce="return tan(a);",$ce=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Bce="return f32(i32((a)));";function Ru(r,e){switch(r){case 0:return ece;case 1:return tce;case 2:return rce;case 3:return nce;case 4:return oce;case 5:return sce;case 6:return ace;case 8:return uce;case 9:return lce;case 7:return ice;case 10:return e?cce:mce;case 11:return dce;case 12:return fce;case 13:return pce;case 14:return hce;case 15:return gce;case 16:return bce;case 17:return yce;case 18:return Tce;case 19:return xce;case 20:return Ice;case 21:return Cce;case 24:return e?Sce:kce;case 25:return vce;case 22:return e?Dce:Ace;case 23:return e?Nce:wce;case 26:return _ce;case 29:return Mce;case 27:return Rce;case 28:return Pce;case 30:return Ece;case 31:return Fce;case 32:return Lce;case 33:return $ce;case 34:return Bce;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var tr=r=>{switch(r){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${r}-component is not supported.`)}};function en(r,e=!1,t=!1,n=3){if(r===null)return"";let o="";if(r==="linear")o=Ru(18);else if(r==="relu")o=Ru(22,t);else if(r==="elu")o=Ru(10,t);else if(r==="relu6")o=Ru(23,t);else if(r==="prelu")o=Gf(18,t);else if(r==="sigmoid")o=Ru(29,t);else if(r==="leakyrelu")o=Ru(24,t);else throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);let a=tr(t?4:1),i="";return e?i=`
      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${o}
      }`:i=`
      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {
        ${o}
      }`,i}function no(r,e){return`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}function r0(r,e,t,n,o=!1,s=!1,a=!1,i=1){y.assert(t&&i===1||!t,()=>`transposeA ${t} is not compatible with component size ${i}`);let u=`
      let batch = ${r?"0":"batchIn"};
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,l=n?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${tr(i)} {
    var value = ${tr(i)}(0.0);
    let col = colIn * ${i};
    ${o&&a?u:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${u}
    }
    `}
    return value;
  }

  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${tr(i)} {
    let col = colIn * ${i};
    let batch = ${e?"0":"batchIn"};
    var value = ${tr(i)}(0.0);
    ${l}
    return value;
  }
  `}function wg(r,e,t,n,o,s,a=!1,i=!1,u=!1,l=1){return`
  ${r0(t,n,o,s,a,i,u,l)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tr(l)}) {
    let col = colIn * ${l};
    ${a&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${no(r,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}var Oce=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `,zce=(r,e)=>r?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;function om(r,e,t=!1,n=32,o=!1,s=32,a=!1){let i=e[1]*r[1],u=e[0]*r[0],l=t?i:n,p=t?n:i,m=l/e[0],c=n/e[1];return y.assert((t&&m===4&&r[1]===4||!t&&(m===3||m===4))&&l%e[0]===0&&n%e[1]===0&&r[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${m} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${m} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${r[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${m}<f32>, ${l/m}>, ${p}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/r[0]}>, ${n}>;

  const rowPerThread = ${r[1]};
  const colPerThread = ${r[0]};
  const innerElementSize = ${m};
  const tileInner = ${n};

  ${de()} {
    let localRow = i32(localId.y);
    let tileRow = ${a?"0":"localRow * rowPerThread"};
    let tileCol = i32(localId.x);

    let globalRow = ${a?"0":"i32(globalId.y) * rowPerThread"};
    let globalCol = i32(globalId.x);
    let batch = ${o?"0":"i32(globalId.z)"};
    let globalRowStart = i32(workgroupId.y) * ${i};

    let numTiles = ${o?`${Math.ceil(s/n)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

    var acc: array<vec4<f32>, rowPerThread>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${c};
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${Oce(t)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
        }
        kStart = kStart + tileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
            let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
            let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
            let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
            ${m===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

            ${zce(t,m)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}var SU=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Gce=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function sm(r,e,t=!1,n=32,o=!1,s=32,a=!1){let i=r[1]*e[1],u=r[0]*e[0],l=t?i:n,p=t?n:i;y.assert(p%e[1]===0&&l%e[0]===0&&n%e[1]===0,()=>`tileAHight ${p} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}, tileInner ${n} must be divisible by workgroupSize[1]${e[1]}`);let m=p/e[1],c=l/e[0],d=n/e[1],f=a?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${i};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${e[0]}) {
            ${SU(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batch,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + tileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, colPerThread>;
        for (var k = 0; k < tileInner; k = k + 1) {
          for (var inner = 0; inner < colPerThread; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                  ACached * BCached[innerCol];
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * rowPerThread;
  let tileCol = i32(localId.x) * colPerThread;

  let globalRow = i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x) * colPerThread;
  let globalRowStart = i32(workgroupId.y) * ${i};

  let tileRowA = i32(localId.y) * ${m};
  let tileColA = i32(localId.x) * ${c};
  let tileRowB = i32(localId.y) * ${d};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t = t + 1) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < ${c}; innerCol = innerCol + 1) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${SU(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batch,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + tileInner;
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, colPerThread>;
    for (var k = 0; k < tileInner; k = k + 1) {
      for (var inner = 0; inner < colPerThread; inner = inner + 1) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        ${Gce(t)}
        for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${l}>, ${p}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${n}>;
    const rowPerThread = ${r[1]};
    const colPerThread = ${r[0]};
    const tileInner = ${n};

    ${de()} {
      let batch = ${o?"0":"i32(globalId.z)"};
      let numTiles = ${o?`${Math.ceil(s/n)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
      var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

      var acc : array<array<f32, colPerThread>, rowPerThread>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${f}
    }
  `}var Wce=r=>r?`
      mm_readA(batch, colA, globalRow),
      mm_readA(batch, colA + 1, globalRow),
      mm_readA(batch, colA + 2, globalRow),
      mm_readA(batch, colA + 3, globalRow)
  `:`
      mm_readA(batch, globalRow, colA),
      mm_readA(batch, globalRow, colA + 1),
      mm_readA(batch, globalRow, colA + 2),
      mm_readA(batch, globalRow, colA + 3)
  `;function Uce(r,e=!1){return y.assert(r[1]===1&&r[2]===1,()=>`A linear work group size is required. But got ${r}.`),`
    const tileSize = ${r[0]*4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${de()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / tileSize + 1;
      let batch = i32(globalId.z);
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * tileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Wce(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < tileSize / 4; k = k + 1) {
          let rowB = t * tileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),
                              mm_readB(batch, rowB + 1, globalCol),
                              mm_readB(batch, rowB + 2, globalCol),
                              mm_readB(batch, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}var PC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize;elementsPerThread;transposeA;transposeB;addBias;activation;hasPreluActivationWeights;batchAEqualOne;batchBEqualOne;fitAOuter;fitBOuter;fitInner;tileInner;isVectorA;isVec4;sequentialAccessByThreads;constructor(e,t,n,o,s=!1,a=!1,i=null,u=null,l=null,p=!1){this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};let m=s?e[1]:e[2];if(this.isVec4=(m%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!a,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{let f=jD(t[1],m,t[2],s);this.workgroupSize=f.workgroupSize,this.elementsPerThread=f.elementsPerThread}this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);let c=i!=null,d=l!=null;c&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=p,this.transposeA=s,this.transposeB=a,this.addBias=c,this.activation=u,this.hasPreluActivationWeights=d,this.batchAEqualOne=n,this.batchBEqualOne=o,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],m),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${a}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){let o=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=s;let a=e%o===0,i=t%s===0,u=n%this.tileInner===0;return[a,i,u]}getUserCode(){return`
      ${en(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${wg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?om(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?Uce(this.workgroupSize,this.transposeA):sm(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads)}
    `}};function Kce(){return`
    var<workgroup> sumValues : array<f32, workgroupSizeX>;
    ${de()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workgroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workgroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}var EC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize=[256,1,1];transposeA;transposeB;addBias;activation;hasPreluActivationWeights;batchAEqualOne;batchBEqualOne;constructor(e,t,n,o=!1,s=!1,a=null,i=null,u=null){this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize);let l=a!=null,p=u!=null;l&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=s,this.addBias=l,this.activation=i,this.hasPreluActivationWeights=p,this.batchAEqualOne=t,this.batchBEqualOne=n,this.shaderKey=`matMulReduce_${this.activation}_${o}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${en(this.activation,this.hasPreluActivationWeights)}
      ${wg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${Kce()}
    `}};function Vce(r){let e=r[1],t=r[0],n=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${n}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${de()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batch, globalRow, globalColA);
    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${n};
    globalRowB = globalRowB + ${n};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batch, globalRow, globalColA);
      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${n};
      globalRowB = globalRowB + ${n};

      for (var k = 0; k < ${n}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}var FC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize=[16,8,1];transposeA;transposeB;addBias;activation;hasPreluActivationWeights;batchAEqualOne;batchBEqualOne;constructor(e,t,n,o=!1,s=!1,a=null,i=null,u=null){this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];let l=a!=null;l&&this.variableNames.push("bias");let p=u!=null;p&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=s,this.addBias=l,this.activation=i,this.hasPreluActivationWeights=p,this.batchAEqualOne=e[0]===1,this.batchBEqualOne=t[0]===1,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${o}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${en(this.activation,this.hasPreluActivationWeights)}
      ${wg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${Vce(this.workgroupSize)}
    `}};var LC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize=[8,8,1];elementsPerThread;transposeA;transposeB;atomic=!0;batchAEqualOne;batchBEqualOne;isVec4=!1;splitedDimInner=128;constructor(e,t,n,o,s=!1,a=!1){y.assert(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=ce(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=a,this.batchAEqualOne=n,this.batchBEqualOne=o,this.shaderKey=`matMulSplitK_${s}_${a}_${n}_${o}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){let e=o=>`
      for (var i = 0; i < ${o}; i = i + 1)
      {
        var oldValue = atomicLoad(&(result[flatIndex + i]));
        var exchanged = false;
        for (; !exchanged;) {
          let newValueF32 = bitcast<f32>(oldValue) + ${o>1?"value[i]":"value"};
          let newValue = bitcast<i32>(newValueF32);
          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);
          oldValue = res.old_value;
          exchanged = res.exchanged;
        }
      }
      `,t=this.isVec4?4:1;return`
      ${r0(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${tr(t)}) {
        let col = colIn * ${t};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          ${e(t)}
        }
      }
      ${this.isVec4?om(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):sm(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}},$C=class{outputShape;shaderKey;uniforms="";dispatchLayout;dispatch;variableNames=["x"];workgroupSize=[64,1,1];size=!0;addBias;activation;hasPreluActivationWeights;constructor(e,t=null,n=null,o=null){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=o!=null,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`
    ${en(this.activation,this.hasPreluActivationWeights)}
    ${de("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${no(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}};var BC=class{variableNames=[];outputShape=[];shaderKey;dispatchLayout;dispatch;uniforms="value : f32,";workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${de("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};function mn(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let a=y.getArrayFromDType(s,y.sizeFromShape(n));return a.fill(o),e.makeTensorInfo(n,s,a)}else{let a=new BC(n),i=[{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],s,i)}}var vU={kernelName:vi,backendName:"webgpu",kernelFunc:mn};function Se(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(o,s),i=y.sizeFromShape(a);return y.assert(s===i,()=>`The new shape (${a}) has ${i} elements and the old shape (${n.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var AU={kernelName:ws,backendName:"webgpu",kernelFunc:Se};function am({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,m=t?r.shape[l-2]:r.shape[l-1],c=n?e.shape[p-1]:e.shape[p-2],d=t?r.shape[l-1]:r.shape[l-2],f=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),b=y.sizeFromShape(h),T=y.sizeFromShape(g),I=Dr.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);y.assert(m===c,()=>`Error in matMul: inner shapes (${m}) and (${c}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let k=t?[b,m,d]:[b,d,m],w=n?[T,f,c]:[T,c,f],_=Se({inputs:{x:r},backend:o,attrs:{shape:k}}),M=Se({inputs:{x:e},backend:o,attrs:{shape:w}}),R=[_,M],E=Math.max(b,T),O=b===1,G=T===1,W=[_,M],H=[{type:"int32",data:[d]},{type:"int32",data:[f]},{type:"int32",data:[m]}],U,V,Y=[E,d,f],j=$().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(j<0){let ne=$().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),oe=ne>0?ne:o.thresholdToIncreaseWorkgroups,ae=E*Math.ceil(d/32)*Math.ceil(f/32);ae<=oe||d<=8&&ae<=oe*2?E*d*f<=128?j=0:E===1&&c>=2e3?j=1:j=2:j=3}switch(j){case 0:U=new EC(Y,O,G,t,n,s,u,a);break;case 1:{if(V=mn({backend:o,attrs:{shape:Y,value:0,dtype:r.dtype}}),U=new LC(Y,c,O,G,t,n),s||u){V=o.runWebGPUProgram(U,W,r.dtype,H,V);let oe=new $C(V.shape,s,u,a),ae=null,se=[V];s&&se.push(s),a&&se.push(a),u==="leakyrelu"&&(ae=[{type:"float32",data:[i]}],oe.uniforms+=" alpha : f32,");let ie=o.runWebGPUProgram(oe,se,V.dtype,ae);R.push(V);let he=Se({inputs:{x:ie},backend:o,attrs:{shape:I}});R.push(ie);for(let ye of R)o.disposeData(ye.dataId);return he}break}case 2:U=new FC(k,w,Y,t,n,s,u,a);break;case 3:let ne=o.adapterInfo.isIntel();U=new PC(k,Y,O,G,t,n,s,u,a,ne);break;default:throw new Error(`Unsupported MatMulProgramType ${j}.`)}s&&W.push(s),a&&W.push(a),u==="leakyrelu"&&(H.push({type:"float32",data:[i]}),U.uniforms+=" alpha : f32,"),V=o.runWebGPUProgram(U,W,r.dtype,H,V);let te=Se({inputs:{x:V},backend:o,attrs:{shape:I}});R.push(V);for(let ne of R)o.disposeData(ne.dataId);return te}function Hce(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n;return am({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:m,activation:p})}var wU={kernelName:Fs,backendName:"webgpu",kernelFunc:Hce};var Ng=class{variableNames=["AReal","AImag","BReal","BImag"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[128,1,1];op;size=!0;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Gf(this.op,!1)}
      }

      ${de("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};var im=class{dispatch;dispatchLayout;isVec4;op;outputShape;shaderKey;size=!0;variableNames=["A","B"];workgroupSize;workPerThread;lastDimensionSize;useSharedMemoryWithA;useSharedMemoryWithB;type;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.dispatchLayout=xe(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(y.arraysEqual(t,n)&&y.sizeFromShape(t)%4===0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workgroupSize=[128,1,1]),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}getUserCode(){let e,t=this.isVec4?"vec4<f32>":"f32",n=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${Gf(this.op,this.isVec4)}
    };
    `;if(this.type==="shared"){let o=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",s=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${o}];`:`let a = sharedBuf[${o}];
          let b = getBByOutputIndex(index);`;e=`
        ${n}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${de("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${n}
       ${de("index")} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};function pr(r){let{inputs:e}=r,{x:t}=e;return r.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var NU={kernelName:Vn,backendName:"webgpu",kernelFunc:pr};function Ti(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),a=t.tensorMap.get(s.dataId),i=pr({inputs:{x:n},backend:t}),u=pr({inputs:{x:o},backend:t});return a.complexTensorInfos={real:i,imag:u},s}var DU={kernelName:zu,backendName:"webgpu",kernelFunc:Ti};var ma=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A"];workgroupSize;op;uniforms;size=!0;constructor(e,t){this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Ru(this.op,!1)}
      }
      ${de("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};function Ee({opType:r,cpuKernelImpl:e,dtype:t}){return({inputs:n,backend:o})=>{let{x:s}=n,a=o,i=t||s.dtype;if(a.shouldExecuteOnCPU([s])&&e!=null){let l=a.tensorMap.get(s.dataId),p=e(l.values,i);return a.makeTensorInfo(s.shape,i,p)}let u=new ma(s.shape,r);return a.runWebGPUProgram(u,[s],i)}}function ft({opType:r,cpuKernelImpl:e,supportsComplex:t=!1,dtype:n}){return({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(t&&a.dtype==="complex64"){let m=u.tensorMap.get(a.dataId),c=u.tensorMap.get(i.dataId),d,f;if(r!==15)[d,f]=[[m.complexTensorInfos.real,c.complexTensorInfos.real],[m.complexTensorInfos.imag,c.complexTensorInfos.imag]].map(g=>{let[b,T]=g,x={dataId:b.dataId,dtype:b.dtype,shape:a.shape},I={dataId:T.dataId,dtype:T.dtype,shape:i.shape},k=new im(r,a.shape,i.shape);return u.runWebGPUProgram(k,[x,I],Pt(b.dtype,T.dtype))});else{let g=new Ng(3,a.shape,i.shape),b=new Ng(2,a.shape,i.shape),T=[{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:a.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape}];d=u.runWebGPUProgram(g,T,"float32"),f=u.runWebGPUProgram(b,T,"float32")}let h=Ti({inputs:{real:d,imag:f},backend:u});return u.disposeData(d.dataId),u.disposeData(f.dataId),h}let l=n||Pt(a.dtype,i.dtype);if((a.dtype==="string"||i.dtype==="string"||u.shouldExecuteOnCPU([a,i]))&&e!=null){let m=u.tensorMap.get(a.dataId).values,c=u.tensorMap.get(i.dataId).values,d=a.dtype==="string"?C.fromUint8ToStringArray(m):m,f=a.dtype==="string"?C.fromUint8ToStringArray(c):c,[h,g]=e(a.shape,i.shape,d,f,l);return u.makeTensorInfo(g,l,h)}let p=new im(r,a.shape,i.shape);return u.runWebGPUProgram(p,[a,i],l)}}var{addImpl:_U,castImpl:MU,ceilImpl:RU,concatImpl:PU,equalImpl:EU,expImpl:FU,expm1Impl:LU,floorImpl:$U,gatherNdImpl:BU,gatherV2Impl:OU,greaterEqualImpl:zU,greaterImpl:GU,lessEqualImpl:WU,lessImpl:UU,logImpl:KU,maxImpl:VU,maximumImpl:HU,minimumImpl:qU,multiplyImpl:jU,negImpl:XU,notEqualImpl:YU,prodImpl:ZU,rangeImpl:QU,rsqrtImpl:JU,scatterImpl:eK,simpleAbsImpl:tK,sliceImpl:rK,stridedSliceImpl:nK,stringNGramsImpl:oK,subImpl:sK,tileImpl:aK,topKImpl:iK,transposeImpl:uK,uniqueImpl:X0r}=ff;var qce=Ee({opType:0,cpuKernelImpl:tK}),lK={kernelName:Ts,backendName:"webgpu",kernelFunc:qce};var jce=Ee({opType:1}),pK={kernelName:ba,backendName:"webgpu",kernelFunc:jce};var Xce=Ee({opType:2}),mK={kernelName:ya,backendName:"webgpu",kernelFunc:Xce};var Yce=ft({opType:0,cpuKernelImpl:_U,supportsComplex:!0}),cK={kernelName:Nn,backendName:"webgpu",kernelFunc:Yce};var OC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames;workPerThread=1;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e[0],this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let e=[];this.variableNames.forEach(o=>{e.push(`let v${o} = get${o}ByOutputCoords(coords);`)});let t=this.variableNames.map(o=>`v${o}`).join(" + ");return`
      ${de("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}};function Zce(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return pr({inputs:{x:n[0]},backend:t});let o=n.map(i=>i.dtype).reduce((i,u)=>Pt(i,u)),s=n.map(i=>i.shape),a=new OC(s);return t.runWebGPUProgram(a,n,o)}var dK={kernelName:co,backendName:"webgpu",kernelFunc:Zce};var zC=class{variableNames=["A"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[16,16,1];constructor(e,t){let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return y.assert(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`),`
      const tileSize = ${this.workgroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${de()} {
        var x = i32(workgroupId.x) * tileSize + i32(localId.x);
        var y = i32(workgroupId.y) * tileSize + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * tileSize + i32(localId.x);
        y = i32(workgroupId.x) * tileSize + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}};var GC=class{variableNames=["A"];shaderKey;outputShape;dispatchLayout;dispatch;workPerThread=1;workgroupSize=[64,1,1];newDim;size=!0;constructor(e,t){let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){let e=lr(this.outputShape.length),t=Qce(this.newDim);return`
      ${de("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function Qce(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=new Array(e);for(let n=0;n<r.length;n++)t[r[n]]=`resRC.${pa(n)}`;return t.join()}function An(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,a=t,i=o.shape.length,u=new Array(i);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];if(t.shouldExecuteOnCPU([o])){let m=a.tensorMap.get(o.dataId).values,c=uK(m,o.shape,o.dtype,s,u);return t.makeTensorInfo(u,o.dtype,c)}if(o.shape.length===2&&y.arraysEqual(s,[1,0])){let p=new zC(o.shape,s);return a.runWebGPUProgram(p,[o],o.dtype)}let l=new GC(o.shape,s);return a.runWebGPUProgram(l,[o],o.dtype)}var fK={kernelName:_n,backendName:"webgpu",kernelFunc:An};var WC=class{outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];variableNames=["x"];uniforms="reduceSize : i32,";reduceType;inputShape;size=!0;constructor(e,t){this.inputShape=[e.batchSize,e.inSize];let[n]=C.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=n.length===0?[1]:n,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");let n=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workgroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${de("index")} {
         let outputIndex = index / i32(workgroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workgroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workgroupSizeX)) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workgroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n}
        }
       }
     `}};function oo(r,e,t,n,o){let s=r.shape.length,a=[],i=y.parseAxisParam(e,r.shape),u=i,l=C.getAxesPermutation(u,s),p=r;l!=null&&(p=An({inputs:{x:r},attrs:{perm:l},backend:o}),u=C.getInnerMostAxes(u.length,s),a.push(p)),C.assertAxesAreInnerMostDims(n,u,s);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=m;t&&(d=C.expandShapeToKeepDim(m,i));let f;if((n==="max"||n==="prod")&&o.shouldExecuteOnCPU([p])){let h=o.tensorMap.get(p.dataId).values;switch(n){case"max":let g=VU(h,y.sizeFromShape(c),d,r.dtype);f=o.makeTensorInfo(d,r.dtype,g);break;case"prod":let{outVals:b,outShape:T,outDtype:x}=ZU(p.shape,p.dtype,h,u);f=o.makeTensorInfo(T,x,b);break;default:throw new Error(`${n} CPU implementation is not yet supported.`)}}else{let h=y.sizeFromShape(c),b=y.sizeFromShape(p.shape)/h,T={windowSize:h,inSize:h,batchSize:b,outSize:1},x=n==="mean"?"float32":iu(r.dtype),I=[{type:"int32",data:[h]}],k=new WC(T,n),w=o.runWebGPUProgram(k,[p],x,I);a.push(w),f=Se({inputs:{x:w},attrs:{shape:d},backend:o})}return a.forEach(h=>o.disposeData(h.dataId)),f}function Jce(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:a}=n;return oo(o,a,s,"all",t)}var hK={kernelName:Ta,backendName:"webgpu",kernelFunc:Jce};function ede(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:a}=n;return oo(o,a,s,"any",t)}var gK={kernelName:xa,backendName:"webgpu",kernelFunc:ede};var Wf=class{outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];variableNames=["x"];uniforms="infinityValue : f32,";inputShape;reductionFactor;op;size=!0;type;constructor(e,t,n){let o=[t];this.op=n==="min"?"<":">";let[s,a]=C.computeOutAndReduceShapes(e,o);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=xe(this.outputShape),y.sizeFromShape(a)<32||y.sizeFromShape(s)>1e3?(this.type="plain",this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=ce(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){let e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${pa(this.inputShape.length-1)}`,t=()=>{let n="";if(this.outputShape.length===1)this.inputShape.length!==1&&(n+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)n+=`outputCoords.${pa(o)},`;return n};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${this.workgroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workgroupSize[0]}>;
    `}

      ${de("index")} {
        let outputIndex = index / i32(workgroupSizeX);
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + i32(workgroupSizeX)) {
          let candidate = getX(${t()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), workgroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${de("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${t()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${t()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};function tde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=An({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let p=new Wf(u.shape,a[0],"max"),m=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],c=t.runWebGPUProgram(p,[u],"int32",m);return l.forEach(d=>t.disposeData(d.dataId)),c}var bK={kernelName:fo,backendName:"webgpu",kernelFunc:tde};function rde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=An({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let p=new Wf(u.shape,a[0],"min"),m=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],c=t.runWebGPUProgram(p,[u],"int32",m);return l.forEach(d=>t.disposeData(d.dataId)),c}var yK={kernelName:Si,backendName:"webgpu",kernelFunc:rde};var nde=Ee({opType:3}),TK={kernelName:Ia,backendName:"webgpu",kernelFunc:nde};var ode=Ee({opType:4}),xK={kernelName:Ca,backendName:"webgpu",kernelFunc:ode};var sde=Ee({opType:5}),IK={kernelName:ka,backendName:"webgpu",kernelFunc:sde};var ade=ft({opType:1}),CK={kernelName:va,backendName:"webgpu",kernelFunc:ade};var ide=Ee({opType:6}),kK={kernelName:Sa,backendName:"webgpu",kernelFunc:ide};var Dg=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,";workgroupSize=[128,1,1];poolType;size=!0;constructor(e,t){this.outputShape=e.outShape,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";this.poolType==="avg"&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return this.poolType==="avg"&&(t="resultValue / count"),`
      ${de("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutputAtIndex(index, ${t});
        }
      }
    `}};var UC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="stride : vec2<i32>,";workgroupSize=[256,1,1];size=!0;constructor(e){this.outputShape=e.outShape,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${de("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}};function _g(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n;return oo(o,s,a,"max",t)}var SK={kernelName:Eo,backendName:"webgpu",kernelFunc:_g};function n0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:a}=n;return oo(o,a,s,"mean",t)}var vK={kernelName:$o,backendName:"webgpu",kernelFunc:n0};function KC(r,e,t,n){if(e.filterWidth===1&&e.filterHeight===1&&y.arraysEqual(e.inShape,e.outShape))return pr({inputs:{x:r},backend:n});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){let a=r.shape.length,i=Se({inputs:{x:r},backend:n,attrs:{shape:[r.shape[a-3]*r.shape[a-2],r.shape[a-1]]}}),u;t==="avg"?u=n0({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}}):(y.assert(t==="max",()=>`Invalid pool type ${t}`),u=_g({inputs:{x:i},backend:n,attrs:{reductionIndices:0,keepDims:!1}}));let l=Se({inputs:{x:u},backend:n,attrs:{shape:e.outShape}});return n.disposeData(i.dataId),n.disposeData(u.dataId),l}let o,s=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?o=new UC(e):(t==="avg"?o=new Dg(e,"avg"):(y.assert(t==="max",()=>`Invalid pool type ${t}`),o=new Dg(e,"max")),s.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),n.runWebGPUProgram(o,[r],r.dtype,s)}function ude(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1,p=C.computePool2DInfo(o.shape,s,a,l,i,u);return KC(o,p,"avg",t)}var AK={kernelName:ho,backendName:"webgpu",kernelFunc:ude};function lde(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;return am({a:o,b:s,transposeA:a,transposeB:i,backend:t})}var wK={kernelName:go,backendName:"webgpu",kernelFunc:lde};var VC=class{variableNames=["source"];uniforms;outputShape;shaderKey;rank;dispatchLayout;dispatch;workPerThread=1;workgroupSize=[64,1,1];start;size=!0;constructor(e,t){this.outputShape=t,this.rank=t.length,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${lr(e.length)}, `,this.shaderKey="slice"}getUserCode(){let e=lr(this.rank),t=pde(this.rank),n;return this.start.length===1?n=this.outputShape.map((s,a)=>"sourceLoc = uniforms.start + coords;"):n=this.outputShape.map((s,a)=>`sourceLoc.${o0[a]} = uniforms.start.${pa(a)} + coords.${o0[a]};`),`
      ${de("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${n.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}},o0=["x","y","z","w","u","v"];function pde(r){if(r===1)return"sourceLoc";if(r<=6)return o0.slice(0,r).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}function xi(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n,[i,u]=It.parseSliceParams(o,s,a);if(It.assertParamsValid(o,i,u),t.shouldExecuteOnCPU([o])||o.dtype==="string"){let m=t.tensorMap.get(o.dataId),c=rK(m.values,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,c)}if(y.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);let l=new VC(i,u),p=[{type:"int32",data:i}];return t.runWebGPUProgram(l,[o],o.dtype,p)}var NK={kernelName:Ds,backendName:"webgpu",kernelFunc:xi};var mde=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((T,x)=>T*x),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=[],f=Se({inputs:{x:o},backend:t,attrs:{shape:u}}),h=An({inputs:{x:f},backend:t,attrs:{perm:l}}),g=Se({inputs:{x:h},backend:t,attrs:{shape:p}}),b=xi({inputs:{x:g},backend:t,attrs:{begin:m,size:c}});return d.push(f),d.push(h),d.push(g),d.forEach(T=>t.disposeData(T.dataId)),b},DK={kernelName:xs,backendName:"webgpu",kernelFunc:mde};var cde=`
  fn bincount_write(index: i32, value: f32) {
    var oldValue = atomicLoad(& (result[index]));
    var exchanged = false;
    for (; !exchanged;) {
      let newValueF32 = bitcast<f32>(oldValue) + value;
      let newValue = bitcast<i32>(newValueF32);
      let res = atomicCompareExchangeWeak(
          &(result[index]), oldValue, newValue);
      oldValue = res.old_value;
      exchanged = res.exchanged;
    }
  }
`,dde=`
  fn bincount_write(index: i32, value: f32) {
    result[index] = value;
  }
`,Uf=class{outputShape=[];shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="binCountSize : i32,";workgroupSize=[64,1,1];atomic=!0;hasWeights=!0;binaryOutput=!1;rank;constructor(e,t,n=!1){this.outputShape=e,this.rank=e.length,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?dde:cde}
  ${de("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"f32(getW(index))":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"f32(getW(coord[0], coord[1]))":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}};function fde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=y.sizeFromShape(o.shape),l=y.sizeFromShape(s.shape)>0,p=[a],m=s.dtype,c=mn({backend:t,attrs:{shape:p,value:0,dtype:m}}),d=new Uf([i],l),f=[{type:"int32",data:[a]}],h=l?[o,s]:[o];return t.runWebGPUProgram(d,h,m,f,c)}var _K={kernelName:Ou,backendName:"webgpu",kernelFunc:fde};var s0=ft({opType:16,dtype:"bool",cpuKernelImpl:YU}),MK={kernelName:Wa,backendName:"webgpu",kernelFunc:s0};function Pu(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return pr({inputs:{x:o.complexTensorInfos.real},backend:t})}var RK={kernelName:Xu,backendName:"webgpu",kernelFunc:Pu};function PK(r,e){let t=new ma(r.shape,34),n=e.runWebGPUProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function a0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return pr({inputs:{x:o},backend:t});let a=Ct(o.shape),i=a0({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=Ti({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeData(i.dataId),u}if(o.dtype==="complex64"){let a=Pu({inputs:{input:o},backend:t}),i=a0({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeData(a.dataId),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=pr({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(t.shouldExecuteOnCPU([o])){let a=t.tensorMap.get(o.dataId).values,[i,u,l]=MU(a,o.shape,o.dtype,s);return t.makeTensorInfo(i,u,l)}if(s==="int32")return PK(o,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),u=s0({inputs:{a:o,b:a},backend:t});return t.disposeData(a.dataId),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var EK={kernelName:Un,backendName:"webgpu",kernelFunc:a0};var hde=Ee({opType:7,cpuKernelImpl:RU}),FK={kernelName:bo,backendName:"webgpu",kernelFunc:hde};var HC=class{outputShape;shaderKey;variableNames=["A"];uniforms="minVal : f32, maxVal : f32,";dispatchLayout;dispatch;workPerThread=4;workgroupSize=[64,1,1];isVec4=!0;size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${de("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isnan(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputAtIndex(index, clampedValue);
        }
      }
    `}};var qC=class{outputShape;shaderKey;variableNames=["A"];uniforms="minVal : f32, maxVal : f32,";dispatchLayout;dispatch;workgroupSize=[64,1,1];minVal;maxVal;size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${de("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function gde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i,u=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return y.sizeFromShape(o.shape)%4===0?i=new HC(o.shape):i=new qC(o.shape),t.runWebGPUProgram(i,[o],o.dtype,u)}var LK={kernelName:Kn,backendName:"webgpu",kernelFunc:gde};var jC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames;uniforms="";workPerThread=1;workgroupSize=[64,1,1];size=!0;offsetLength;constructor(e){this.outputShape=C.computeOutShape(e,1),this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){let e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)e.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);let n=this.offsetLength,o=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${o})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${de("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};function um(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return pr({inputs:{x:o.complexTensorInfos.imag},backend:t})}var $K={kernelName:Hu,backendName:"webgpu",kernelFunc:um};function Kf(r,e,t){let n=r[0].dtype;if(n==="complex64"){let f=r.map(x=>Pu({inputs:{input:x},backend:t})),h=r.map(x=>um({inputs:{input:x},backend:t})),g=Kf(f,e,t),b=Kf(h,e,t),T=Ti({inputs:{real:g,imag:b},backend:t});return f.forEach(x=>t.disposeData(x.dataId)),h.forEach(x=>t.disposeData(x.dataId)),t.disposeData(g.dataId),t.disposeData(b.dataId),T}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let f=r.map(k=>{let w=y.sizeFromShape(k.shape.slice(e));return Se({inputs:{x:k},backend:t,attrs:{shape:[-1,w]}})}),h=f.map(k=>({vals:t.readSync(k.dataId),shape:k.shape})),g=C.computeOutShape(f.map(k=>k.shape),1),b=f[0].shape[0]===1,T=PU(h,g,n,b),x=C.computeOutShape(r.map(k=>k.shape),e),I=t.makeTensorInfo(x,n,T);return f.forEach(k=>t.disposeData(k.dataId)),I}let s=t.device.limits.maxStorageBuffersPerShaderStage-1;if(r.length>s){let f=[];for(let g=0;g<r.length;g+=s){let b=r.slice(g,g+s);f.push(Kf(b,e,t))}let h=Kf(f,e,t);for(let g of f)t.disposeData(g.dataId);return h}let{tensors2D:a,outShape:i}=bde(r,e,t),u=a.map(f=>f.shape),l=new jC(u),p=[],m=new Array(u.length-1);if(m.length>0){m[0]=u[0][1],p.push({type:"int32",data:[m[0]]});for(let f=1;f<m.length;f++)m[f]=m[f-1]+u[f][1],p.push({type:"int32",data:[m[f]]})}let c=t.runWebGPUProgram(l,a,a[0].dtype,p);a.forEach(f=>t.disposeData(f.dataId));let d=Se({inputs:{x:c},backend:t,attrs:{shape:i}});return t.disposeData(c.dataId),d}function bde(r,e,t){let n=C.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>Se({inputs:{x:s},backend:t,attrs:{shape:[y.sizeFromShape(s.shape.slice(0,e)),y.sizeFromShape(s.shape.slice(e))]}})),outShape:n}}function i0(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=e.map(l=>l.shape);C.assertParamsConsistent(a,s);let i=C.computeOutShape(e.map(l=>l.shape),s);if(y.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let u=e.filter(l=>y.sizeFromShape(l.shape)>0);return u.length===1?pr({inputs:{x:u[0]},backend:t}):Kf(u,s,t)}var BK={kernelName:Is,backendName:"webgpu",kernelFunc:i0};function yde(r,e,t,n,o=!1,s=null,a=!1,i=4,u=4,l=4){let p=R=>{switch(R){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},m=R=>{switch(R){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},c=r?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,d=r?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,f=r?"uniforms.xShape[1]":"uniforms.xShape[2]",h=r?"uniforms.xShape[2]":"uniforms.xShape[3]",g=r?"row":"col",b=r?"col":"row",T=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${b} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${b} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
      let xCh = ${b} % inChannels;
      var resData = ${tr(i)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {
        ${c}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${p(i)}
      }
      return resData;`,x=r?e&&n?`
      let col = colIn * ${i};
      ${T}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${T}
      }
      return ${tr(i)}(0.0);`:n&&t?`
      let col = colIn * ${i};
      ${T}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${T}
      }
      return ${tr(i)}(0.0);`,I=`${m(u)}`,k=tr(l),w=r?tr(i):tr(u),_=r?tr(u):tr(i);return`
      ${en(s,a,l===4,4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${w} {
        ${r?x:I}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${_} {
        ${r?I:x}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${k}) {
        let col = colIn * ${l};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${d}
        ${no(o,s)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}var XC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];variableTypes;uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize;elementsPerThread;addBias;activation;hasPreluActivationWeights;isChannelsLast;fitAOuter;fitBOuter;fitInner;tileAOuter;tileBOuter;tileInner;innerElementSize;isVec4;sequentialAccessByThreads;constructor(e,t,n,o,s=!1,a=null,i=!1,u=!1){this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Sg(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=vg(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),s&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),i&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=s,this.activation=a,this.hasPreluActivationWeights=i,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=n%this.tileBOuter===0,this.fitInner=o%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){let e=this.isVec4?om(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):sm(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${yde(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}};var YC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,";workgroupSize=[4,4,8];addBias;activation;hasPreluActivationWeights;isChannelsLast;constructor(e,t=!1,n=null,o=!1){this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${en(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${no(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${de("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}};var ZC=class{variableNames=["x"];uniforms=`pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`;outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];isChannelsLast;size=!0;constructor(e,t){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",o=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${de("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${n};
        let col = ${o};
        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];
        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -
              uniforms.pad[1];
          let xCol = offsetX + uniforms.dilation[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${s};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}};function QC(r,e){let t=r.length;return t>=3?e?[...r.slice(0,-3),r[t-3]*r[t-2],r[t-1]]:[...r.slice(0,-3),r[t-3],r[t-2]*r[t-1]]:!e&&t===1&&r[0]>1?[r[0],1]:null}function Tde({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=t.dataFormat==="channelsLast",l=!u,p=!1,m=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",c=[],d,f;if(m){let b=t.inHeight*t.inWidth*t.inChannels;d=Se({inputs:{x:r},backend:n,attrs:{shape:[1,t.batchSize,b]}}),f=Se({inputs:{x:e},backend:n,attrs:{shape:[1,b,t.outChannels]}})}else d=Se({inputs:{x:r},backend:n,attrs:{shape:u?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),f=Se({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(c.push(d),c.push(f),s!=null){let b=QC(s.shape,u);b!=null&&(s=Se({inputs:{x:s},backend:n,attrs:{shape:b}}),c.push(s))}if(o!=null){let b=QC(o.shape,u);b!=null&&(o=Se({inputs:{x:o},backend:n,attrs:{shape:b}}),c.push(o))}let h=am({a:u?d:f,b:u?f:d,transposeA:l,transposeB:p,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),g=Se({inputs:{x:h},backend:n,attrs:{shape:t.outShape}});c.push(h);for(let b of c)n.disposeData(b.dataId);return g}function xde({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:p,strideWidth:m,strideHeight:c,padInfo:d,outWidth:f,outHeight:h,dilationWidth:g,dilationHeight:b,dataFormat:T}=t,x=T==="channelsLast",I=u*l*p,k=h*f,w=x?[t.batchSize,k,I]:[t.batchSize,I,k],_=new ZC(w,x),M=[{type:"int32",data:[d.top,d.left]},{type:"int32",data:[c,m]},{type:"int32",data:[b,g]},{type:"int32",data:[f]},{type:"int32",data:[p*u]},{type:"int32",data:[p]}],R=n.runWebGPUProgram(_,[r],r.dtype,M),E=[];E.push(R);let O=Se({inputs:{x:e},backend:n,attrs:{shape:[1,I,-1]}});if(E.push(O),s!=null){let V=QC(s.shape,x);V!=null&&(s=Se({inputs:{x:s},backend:n,attrs:{shape:V}}),E.push(s))}if(o!=null){let V=QC(o.shape,x);V!=null&&(o=Se({inputs:{x:o},backend:n,attrs:{shape:V}}),E.push(o))}let H=am({a:x?R:O,b:x?O:R,transposeA:!x,transposeB:!1,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),U=Se({inputs:{x:H},backend:n,attrs:{shape:t.outShape}});E.push(H);for(let V of E)n.disposeData(V.dataId);return U}function JC({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=o!=null,l=s!=null,p=t.dataFormat==="channelsLast",m=p&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",c=$().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!c&&(m||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return Tde({x:r,filter:e,convInfo:t,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});let d=$().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=d>0?d:n.thresholdToIncreaseWorkgroups,h=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if($().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||h<=f)return xde({x:r,filter:e,convInfo:t,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:a,activation:i});let g,b=[t.padInfo.top,t.padInfo.left],T=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(c)g=new YC(t,u,i,l);else{let w=p?t.outHeight*t.outWidth:t.outChannels,_=p?t.outChannels:t.outHeight*t.outWidth,M=t.filterHeight*t.filterWidth*t.inChannels;T.push({type:"int32",data:[w]},{type:"int32",data:[_]},{type:"int32",data:[M]});let R=n.adapterInfo.isIntel();g=new XC(t,w,_,M,u,i,l,R)}let x=[],I=[r,e];u&&(!p&&o.shape.length===1&&(o=Se({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}}),x.push(o)),I.push(o)),l&&(!p&&s.shape.length===1&&(s=Se({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}}),x.push(s)),I.push(s)),i==="leakyrelu"&&(T.push({type:"float32",data:[a]}),g.uniforms+=" alpha : f32,");let k=n.runWebGPUProgram(g,I,r.dtype,T);for(let w of x)n.disposeData(w.dataId);return k}function Ide(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=t,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,m);return JC({x:o,filter:s,convInfo:c,backend:n})}var OK={kernelName:yo,backendName:"webgpu",kernelFunc:Ide};function Cde(r=4){let e=s=>{switch(s){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${s} is not supported.`)}},n=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${tr(r)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${tr(r)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r}];`}
      }
      return ${tr(r)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${tr(r)} {
    let col = colIn * ${r};
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${tr(r)} {
    let col = colIn * ${r};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(r)}
    }
    return ${tr(r)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${tr(r)}) {
    let col = colIn * ${r};
    if (row < uniforms.dimAOuter && (col + ${r-1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r}] = value;
    }
  }`}var ek=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];variableTypes;uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize;elementsPerThread;isVec4;constructor(e){this.outputShape=e.inShape,y.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Sg(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=vg(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){let e=this.isVec4?om(this.elementsPerThread,this.workgroupSize):sm(this.elementsPerThread,this.workgroupSize);return`
    ${Cde(this.isVec4?4:1)}
    ${e}
    `}};var tk=class{variableNames=["dy","W"];uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,";outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];isChannelsLast;size=!0;constructor(e){this.outputShape=e.inShape,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`
    ${de("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};function kde(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(l),c=C.computeConv2DInfo(a,s.shape,i,1,u,p,!1,m),d=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize,c.outHeight,c.outWidth,c.outChannels]}],f;if($().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||c.filterHeight<=2&&c.filterWidth<=2&&c.outChannels<=16&&c.inChannels===1)f=new tk(c);else{f=new ek(c);let h=c.inHeight*c.inWidth,g=c.inChannels,b=c.filterHeight*c.filterWidth*c.outChannels;d.push({type:"uint32",data:[h]},{type:"uint32",data:[g]},{type:"uint32",data:[b]})}return t.runWebGPUProgram(f,[o,s],"float32",d)}var zK={kernelName:To,backendName:"webgpu",kernelFunc:kde};var Sde=Ee({opType:8}),GK={kernelName:xo,backendName:"webgpu",kernelFunc:Sde};var vde=Ee({opType:9}),WK={kernelName:Io,backendName:"webgpu",kernelFunc:vde};var rk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["Image","Boxes","BoxInd"];uniforms="extrapolationValue : f32,";workgroupSize=[64,1,1];methodId;cropHeightBiggerThan1;cropWidthBiggerThan1;size=!0;constructor(e,t,n,o){let[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=o==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,o,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,i,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${de("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${o};
        let width_scale = ${i};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};var Ade=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,p=new rk(o.shape[3],s.shape,i,u),m=[{type:"float32",data:[l]}];return t.runWebGPUProgram(p,[o,s,a],"float32",m)},UK={kernelName:wa,backendName:"webgpu",kernelFunc:Ade};var Mg=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];workgroupSize;uniforms="index : f32,";size=!0;exclusive;reverse;op;constructor(e,t,n,o){this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=o,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){let e=this.outputShape.length,t=this.op==="*"?"1.0":"0.0",n=this.exclusive?t:`getX(${KK(e,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],s="",a="";return this.exclusive?(s=this.reverse?`end != ${o-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${o}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${de("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${VK(e,"coords",this.op)};
         var val = ${n};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${a};
           ${VK(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${KK(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function KK(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function VK(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function nk(r,e,t,n,o,s){let a=e.shape.length,i=C.getAxesPermutation([n],a),u=e;i!=null&&(u=An({inputs:{x:e},backend:t,attrs:{perm:i}}));let l=C.getInnerMostAxes(1,a)[0];if(l!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${n}`);let p=u.shape[l],m=pr({inputs:{x:u},backend:t});for(let c=0;c<=Math.ceil(Math.log2(p))-1;c++){let d=new Mg(r,u.shape,!1,s),f=m,h=[{type:"float32",data:[c]}];m=t.runWebGPUProgram(d,[m],m.dtype,h),t.disposeData(f.dataId)}if(o){let c=new Mg(r,u.shape,o,s),d=m,f=[{type:"float32",data:[0]}];m=t.runWebGPUProgram(c,[m],m.dtype,f),t.disposeData(d.dataId)}if(i!=null){let c=C.getUndoAxesPermutation(i),d=An({inputs:{x:m},backend:t,attrs:{perm:c}});return t.disposeData(m.dataId),t.disposeData(u.dataId),d}return m}function Nde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return nk("*",o,t,s,a,i)}var HK={kernelName:Aa,backendName:"webgpu",kernelFunc:Nde};function Dde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return nk("+",o,t,s,a,i)}var qK={kernelName:Co,backendName:"webgpu",kernelFunc:Dde};function _de(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n,u=o.shape.length===1,p=y.sizeFromShape(s.shape)>0,m=s.dtype,c=u?[o.shape[0]]:[o.shape[0],o.shape[1]],d=u?[a]:[o.shape[0],a],f=mn({backend:t,attrs:{shape:d,value:0,dtype:m}}),h=new Uf(c,p,i),g=[{type:"int32",data:[a]}],b=p?[o,s]:[o];return t.runWebGPUProgram(h,b,m,g,f)}var jK={kernelName:Uu,backendName:"webgpu",kernelFunc:_de};var ok=class{variableNames=["x"];outputShape;dataFormat;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];size=!0;uniforms="blockSize : i32,";constructor(e,t){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${de("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Mde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=l*s,d=p/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=[{type:"int32",data:[s]}],g=new ok(f,a);return t.runWebGPUProgram(g,[o],o.dtype,h)}var XK={kernelName:Na,backendName:"webgpu",kernelFunc:Mde};var sk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms="pad : vec2<i32>, inDims : vec2<i32>,";workgroupSize=[16,16,1];addBias;activation;hasPreluActivation;filterHeight;filterWidth;constructor(e,t,n,o=!1,s=null,a=!1){this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=o,this.activation=s,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){let e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,o=this.workgroupSize[0]+this.filterWidth-1;return`
      ${en(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${o}>, ${n}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${de()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${o}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${no(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};var Vf=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms="pad : vec2<i32>, inDims : vec2<i32>,";workgroupSize=[4,4,4];workPerThread=4;convInfo;addBias;activation;hasPreluActivation;isVec4=!0;constructor(e,t=!1,n=null,o=!1){this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),y.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){let e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth;return`
      ${en(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      const strideHeight = ${this.convInfo.strideHeight};
      const strideWidth = ${this.convInfo.strideWidth};
      ${de()} {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * ${this.workPerThread};
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(strideHeight, strideWidth) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * strideWidth + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${no(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}};var Hf=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms=`pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,`;workgroupSize=[256,1,1];convInfo;addBias;activation;hasPreluActivation;isChannelsLast;size=!0;constructor(e,t=!1,n=null,o=!1){this.outputShape=e.outShape,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${en(this.activation,this.hasPreluActivation,!1,4)}

      ${de("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilation[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilation[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilation[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilation[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilation[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilation[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${no(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};function Rde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(u),c=l;c==null&&(c=[1,1]);let d=C.computeConv2DInfo(o.shape,s.shape,a,c,i,p,!0,m),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],h=d.dataFormat==="channelsLast",g;return!h&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?g=new sk(d.outShape,d.filterHeight,d.filterWidth):h&&d.outHeight>4&&d.outWidth>4&&d.strideWidth<=2&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4===0?g=new Vf(d):(g=new Hf(d),f.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),t.runWebGPUProgram(g,[o,s],o.dtype,f)}var YK={kernelName:ko,backendName:"webgpu",kernelFunc:Rde};var u0=ft({opType:15,cpuKernelImpl:jU,supportsComplex:!0}),ZK={kernelName:Go,backendName:"webgpu",kernelFunc:u0};function Rg(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return oo(o,s,a,"sum",t)}var QK={kernelName:ns,backendName:"webgpu",kernelFunc:Rg};function Pde(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=C.getEinsumComputePath(i,u),m=p.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of p[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=An({inputs:{x:s[g]},backend:t,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let k=0;k<T.length;++k)I.splice(T[k],0,1);y.arraysEqual(x.shape,I)||(x=Se({inputs:{x},backend:t,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=u0({inputs:{a:x,b:c},backend:t}),f.push(c))}h<m-1&&(l[h]>=0&&(c=Rg({inputs:{x:c},backend:t,attrs:{axis:l[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&t.disposeData(h.dataId);return c}var JK={kernelName:Vu,backendName:"webgpu",kernelFunc:Pde};var Ede=Ee({opType:10}),eV={kernelName:vo,backendName:"webgpu",kernelFunc:Ede};var Fde=ft({opType:5,dtype:"bool",cpuKernelImpl:EU}),tV={kernelName:_a,backendName:"webgpu",kernelFunc:Fde};var Lde=Ee({opType:11}),rV={kernelName:Da,backendName:"webgpu",kernelFunc:Lde};var l0=Ee({opType:12,cpuKernelImpl:FU,dtype:"float32"}),nV={kernelName:Ao,backendName:"webgpu",kernelFunc:l0};function ak(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(y.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),Se({inputs:{x:s},backend:n,attrs:{shape:i}})}var oV={kernelName:Cs,backendName:"webgpu",kernelFunc:ak};var $de=Ee({opType:13,cpuKernelImpl:LU}),sV={kernelName:Ma,backendName:"webgpu",kernelFunc:$de};var ik=class{outputShape=[];shaderKey;dispatchLayout;dispatch;variableNames=["x"];workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${de("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};var aV={kernelName:Ra,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new ik(t.shape);return n.runWebGPUProgram(o,[t],t.dtype)}};var Bde=Ee({opType:14,cpuKernelImpl:$U}),iV={kernelName:wo,backendName:"webgpu",kernelFunc:Bde};var Ode=ft({opType:8,dtype:"int32"}),uV={kernelName:No,backendName:"webgpu",kernelFunc:Ode};var uk=class{dispatch;dispatchLayout;isFromPixels=!0;outputShape=[0];shaderKey;importVideo;variableNames=[];workgroupSize=[256,1,1];constructor(e,t,n=!1){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){let e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${de("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};var lV={kernelName:Vl,backendName:"webgpu",kernelFunc:zde},qf,p0=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),lk=new Map;function zde(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n;if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&o instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,[p,m]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[m,p,s],d=!1,f=a||i;if(l||u||f){let T;if(d){let E=o;if(!lk.has(E)||lk.get(E).expired){let O={source:E};lk.set(E,t.device.importExternalTexture(O))}T={width:p,height:m,format:null,usage:null,texture:lk.get(E)}}else{if(f){let W=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(qf==null||W!==p0)&&(p0=W,qf=document.createElement("canvas").getContext("2d",{willReadFrequently:p0})),qf.canvas.width=p,qf.canvas.height=m,qf.drawImage(o,0,0,p,m),o=qf.canvas}let E=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,O="rgba8unorm",G=t.textureManager.acquireTexture(c[1],c[0],O,E);t.queue.copyExternalImageToTexture({source:o},{texture:G},[c[1],c[0]]),T={width:p,height:m,format:O,usage:E,texture:G}}let x=y.sizeFromShape(c),I=y.computeStrides(c),k=new uk(c,s,d),w=[{type:"uint32",data:[x]},{type:"uint32",data:[s]},{type:"uint32",data:[...I]}],_=t.makeTensorInfo([m,p],"int32"),M=t.tensorMap.get(_.dataId);M.resourceInfo=T;let R=t.runWebGPUProgram(k,[_],"int32",w);return t.disposeData(_.dataId),R}let h=o.data,g=h;if(s!=null&&s!==4){g=new Uint8Array(o.width*o.height*s);let T=h.length,x=0;for(let I=0;I<T;I++)I%4<s&&(g[x++]=h[I])}let b=t.makeTensorInfo(c,"int32",new Int32Array(g));return t.uploadToGPU(b.dataId),b}var pk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames;uniforms="varianceEpsilon : f32,";workgroupSize=[128,1,1];offsetShape;scaleShape;varianceEpsilon;size=!0;constructor(e,t,n,o,s){this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset")),s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale")),this.offsetShape=o,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${de("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};var pV={kernelName:Do,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n,scale:o,offset:s,mean:a,variance:i}=r,{varianceEpsilon:u}=e,l=t,p=[n,a,i],m=null;s!=null&&(m=s.shape,p.push(s));let c=null;o!=null&&(c=o.shape,p.push(o));let d=new pk(n.shape,a.shape,i.shape,m,c),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(d,p,n.dtype,f)}};function Gde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=C.convertConv2DDataFormat(p),g=C.computeConv2DInfo(o.shape,s.shape,u,m,l,c,!1,h);return JC({x:o,filter:s,convInfo:g,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:f,activation:d})}var mV={kernelName:Ls,backendName:"webgpu",kernelFunc:Gde};function Wde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:m,activation:c,leakyreluAlpha:d}=n,f=p;f==null&&(f=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(u,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`);let h=C.computeConv2DInfo(o.shape,s.shape,u,f,l,m,!0),g=[o,s],b=a!=null,T=i!=null;b&&g.push(a),T&&g.push(i);let x=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inHeight,h.inWidth]}],I;return h.outHeight>4&&h.outWidth>4&&h.strideWidth<=2&&h.inChannels===h.outChannels&&h.dilationHeight===1&&h.dilationWidth===1&&h.inChannels%4===0?I=new Vf(h,b,c,T):(I=new Hf(h,b,c,T),x.push({type:"int32",data:[h.filterHeight]},{type:"int32",data:[h.filterWidth]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]})),c==="leakyrelu"&&(x.push({type:"float32",data:[d]}),I.uniforms+=" alpha : f32,"),t.runWebGPUProgram(I,g,"float32",x)}var cV={kernelName:$s,backendName:"webgpu",kernelFunc:Wde};var mk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","indices"];uniforms;workgroupSize=[64,1,1];size=!0;sliceDim;constructor(e,t){this.outputShape=t,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${lr(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${de("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};function Ude(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,a=s[s.length-1],i=y.sizeFromShape(n.shape),[u,l,p,m]=C.prepareAndValidate(n,o),c=Se({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),d=Se({inputs:{x:n},backend:t,attrs:{shape:[y.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let T=t.readSync(o.dataId),x=t.bufferSync(n),I=BU(T,x,n.dtype,l,a,p,m,n.shape,i);return t.makeTensorInfo(u,n.dtype,I.values)}let f=new mk(a,[l,p]),h=[{type:"int32",data:[a]},{type:"int32",data:m}],g=t.runWebGPUProgram(f,[d,c],d.dtype,h),b=Se({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeData(c.dataId),t.disposeData(d.dataId),t.disposeData(g.dataId),b}var dV={kernelName:Pa,backendName:"webgpu",kernelFunc:Ude};var ck=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","indices"];workgroupSize=[64,1,1];aShape;size=!0;constructor(e,t){this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){let e=Kde(this.aShape);return`
      ${de("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}};function Kde(r){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let n=0;n<r.length;n++)n===2?t.push("indexZ"):t.push(`${e[n]}`);return t.join()}function m0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0],l=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),p=y.sizeFromShape(s.shape),m=[],c=Se({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=Se({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,p/l.batchSize]}});m.push(c),m.push(d);let f=[l.batchSize,l.outerSize,p/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])){let x=t.tensorMap.get(d.dataId).values,I=Ie(d.shape,d.dtype,x),w=t.tensorMap.get(c.dataId).values,_=Ie(c.shape,c.dtype,w),M=OU(_,I,f);return m.forEach(R=>t.disposeData(R.dataId)),t.makeTensorInfo(l.outputShape,M.dtype,M.values)}let h=new ck(c.shape,f),g=t.runWebGPUProgram(h,[c,d],c.dtype);m.push(g);let b=Se({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return m.forEach(T=>t.disposeData(T.dataId)),b}var fV={kernelName:ks,backendName:"webgpu",kernelFunc:m0};var Vde=ft({opType:6,cpuKernelImpl:GU,dtype:"bool"}),hV={kernelName:Ea,backendName:"webgpu",kernelFunc:Vde};var Hde=ft({opType:7,dtype:"bool",cpuKernelImpl:zU}),gV={kernelName:_o,backendName:"webgpu",kernelFunc:Hde};var qde=Ee({opType:15,dtype:"bool"}),bV={kernelName:Fa,backendName:"webgpu",kernelFunc:qde};var jde=Ee({opType:16,dtype:"bool"}),yV={kernelName:La,backendName:"webgpu",kernelFunc:jde};var Xde=Ee({opType:17,dtype:"bool"}),TV={kernelName:Mo,backendName:"webgpu",kernelFunc:Xde};function Yde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,a=[{type:"float32",data:[s]}],i=new ma(o.shape,24);return i.uniforms="alpha : f32,",t.runWebGPUProgram(i,[o],"float32",a)}var xV={kernelName:Ro,backendName:"webgpu",kernelFunc:Yde};var Zde=ft({opType:9,dtype:"bool",cpuKernelImpl:UU}),IV={kernelName:$a,backendName:"webgpu",kernelFunc:Zde};var Qde=ft({opType:10,dtype:"bool",cpuKernelImpl:WU}),CV={kernelName:Ba,backendName:"webgpu",kernelFunc:Qde};var Jde=Ee({opType:19,cpuKernelImpl:KU}),kV={kernelName:Po,backendName:"webgpu",kernelFunc:Jde};var efe=ft({opType:11,dtype:"bool"}),SV={kernelName:Oa,backendName:"webgpu",kernelFunc:efe};var tfe=Ee({opType:20}),vV={kernelName:za,backendName:"webgpu",kernelFunc:tfe};var rfe=ft({opType:12,cpuKernelImpl:HU}),AV={kernelName:Fo,backendName:"webgpu",kernelFunc:rfe};function nfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1,p=C.computePool2DInfo(o.shape,s,a,l,i,u);return KC(o,p,"max",t)}var wV={kernelName:Lo,backendName:"webgpu",kernelFunc:nfe};function ofe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return oo(o,s,a,"min",t)}var NV={kernelName:Bo,backendName:"webgpu",kernelFunc:ofe};var sfe=ft({opType:13,cpuKernelImpl:qU}),DV={kernelName:Oo,backendName:"webgpu",kernelFunc:sfe};var dk=class{outputShape;shaderKey;uniforms="";dispatchLayout;dispatch;variableNames=["x"];workgroupSize=[64,1,1];xShape;offset;size=!0;constructor(e,t,n){this.outputShape=t.map((o,s)=>o[0]+e[s]+o[1]),this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((o,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.offset=n==="reflect"?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){let e=this.xShape.length,t=this.xShape.map((l,p)=>`uniforms.pad${p}[0]`).join(","),n=this.xShape.map((l,p)=>`uniforms.pad${p}[0] + uniforms.xShape${e>1?`[${p}]`:""}`).join(","),o=e===1?"start":"start[i]",s=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",i=lr(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${de("index")} {
        if (index < uniforms.size) {
          let start = ${i}(${t});
          let end = ${i}(${n});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${o}) {
              ${a} = ${o} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${s}) {
              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}};var _V={kernelName:zo,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{paddings:o,mode:s}=e,a=t,i=o.map(p=>({type:"int32",data:[p[0],p[1]]})),u=new dk(n.shape,o,s);return a.runWebGPUProgram(u,[n],n.dtype,i)}};var afe=ft({opType:14}),MV={kernelName:Ga,backendName:"webgpu",kernelFunc:afe};function ife(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.tensorMap.get(n.dataId),[a,i]=XU(s.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,a)}let o=new ma(n.shape,21);return t.runWebGPUProgram(o,[n],n.dtype)}var RV={kernelName:Ss,backendName:"webgpu",kernelFunc:ife};function ufe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:m}=xr.nonMaxSuppressionV3Impl(l,p,a,i,u);return t.makeTensorInfo([m.length],"int32",new Int32Array(m))}var PV={kernelName:Ua,backendName:"webgpu",kernelFunc:ufe};function lfe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),m=t.readSync(s.dataId),c=a,d=i,f=u,h=l,{selectedIndices:g,selectedScores:b}=xr.nonMaxSuppressionV5Impl(p,m,c,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var EV={kernelName:Ka,backendName:"webgpu",kernelFunc:lfe};var fk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="onValue : f32, offValue : f32,";workgroupSize=[64,1,1];size=!0;constructor(e,t){this.outputShape=[e,t],this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${de("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};function pfe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n,l=y.sizeFromShape(o.shape),p=new fk(l,a),m=Se({inputs:{x:o},backend:t,attrs:{shape:[l]}}),c=[{type:"float32",data:[i]},{type:"float32",data:[u]}],d=t.runWebGPUProgram(p,[m],s,c);t.disposeData(m.dataId);let f=[...o.shape,a],h=Se({inputs:{x:d},backend:t,attrs:{shape:f}});return t.disposeData(d.dataId),h}var FV={kernelName:Wo,backendName:"webgpu",kernelFunc:pfe};function Pg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=Pu({inputs:{input:n},backend:t}),s=Pg({inputs:{x:o},backend:t}),a=um({inputs:{input:n},backend:t}),i=Pg({inputs:{x:a},backend:t}),u=Ti({inputs:{real:s,imag:i},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),u}else return mn({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var LV={kernelName:Ps,backendName:"webgpu",kernelFunc:Pg};function $V(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Pu({inputs:{input:n},backend:t}),s=$V({inputs:{x:o},backend:t}),a=um({inputs:{input:n},backend:t}),i=Pg({inputs:{x:a},backend:t}),u=Ti({inputs:{real:s,imag:i},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),u}else return mn({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var BV={kernelName:vs,backendName:"webgpu",kernelFunc:$V};function mfe(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return ak({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=ak({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=i0({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeData(p.dataId)),l}var OV={kernelName:As,backendName:"webgpu",kernelFunc:mfe};var hk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="constantValue : f32,";workgroupSize=[64,1,1];xShape;size=!0;constructor(e,t){this.outputShape=t.map((n,o)=>n[0]+e[o]+n[1]),this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((n,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){let e=this.xShape.length,t=lr(e),n=this.xShape.map((m,c)=>`uniforms.pad${c}[0]`).join(","),o=this.xShape.map((m,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),s=e>1?`${t}(${n})`:`${n}`,a=e>1?`${t}(${o})`:`${o}`,i=e>1?"any(outC < start)":"outC < start",u=e>1?"any(outC >= end)":"outC >= end",l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${de("index")} {
        if (index < uniforms.size) {
          let start = ${s};
          let end = ${a};
          let outC = getCoordsFromIndex(index);

          if (${i} || ${u}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${l}));
          }
        }
      }
    `}};var c0=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;if(s.every(l=>y.arraysEqual(l,[0,0])))return pr({inputs:{x:o},backend:t});if(y.sizeFromShape(o.shape)===0){let l=s.map((p,m)=>p[0]+o.shape[m]+p[1]);return mn({backend:t,attrs:{shape:l,value:a,dtype:o.dtype}})}let i=[{type:"float32",data:[a]}];s.map(l=>i.push({type:"int32",data:[l[0],l[1]]}));let u=new hk(o.shape,s);return t.runWebGPUProgram(u,[o],o.dtype,i)},zV={kernelName:Uo,backendName:"webgpu",kernelFunc:c0};var cfe=ft({opType:17}),GV={kernelName:Ko,backendName:"webgpu",kernelFunc:cfe};function dfe(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=new im(18,n.shape,o.shape);return t.runWebGPUProgram(s,[n,o],"float32")}var WV={kernelName:Vo,backendName:"webgpu",kernelFunc:dfe};function ffe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return oo(o,s,a,"prod",t)}var UV={kernelName:Ho,backendName:"webgpu",kernelFunc:ffe};var hfe=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=QU(n,o,s,a);return e.makeTensorInfo([i.length],a,i)},KV={kernelName:Ai,backendName:"webgpu",kernelFunc:hfe};var d0=ft({opType:4}),VV={kernelName:So,backendName:"webgpu",kernelFunc:d0};var gfe=Ee({opType:25}),HV={kernelName:qo,backendName:"webgpu",kernelFunc:gfe};var bfe=Ee({opType:22}),qV={kernelName:jo,backendName:"webgpu",kernelFunc:bfe};var yfe=Ee({opType:23}),jV={kernelName:Zo,backendName:"webgpu",kernelFunc:yfe};var gk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,";workgroupSize=[64,1,1];size=!0;constructor(e,t,n){this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${de("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function Tfe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,size:a,halfPixelCenters:i}=n,[u,l]=a,p=s&&u>1?1:0,m=s&&l>1?1:0,d=[{type:"float32",data:[p,m]},{type:"float32",data:[i?.5:0]}],f=new gk(o.shape,u,l);return t.runWebGPUProgram(f,[o],"float32",d)}var XV={kernelName:Yo,backendName:"webgpu",kernelFunc:Tfe};var bk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,";workgroupSize=[64,1,1];halfPixelCenters;size=!0;constructor(e,t,n,o){this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=o,this.shaderKey=`resizeNearest_${o}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${de("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function xfe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=s&&u>1?1:0,m=s&&l>1?1:0,d=[{type:"float32",data:[p,m]},{type:"float32",data:[s?.5:0]}],f=new bk(o.shape,u,l,a);return t.runWebGPUProgram(f,[o],o.dtype,d)}var YV={kernelName:Xo,backendName:"webgpu",kernelFunc:xfe};var yk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${de("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};function Ife(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=o.shape.length;if(a===0)return pr({inputs:{x:o},backend:t});let i=o.shape,u=[1,1,1,1];i.forEach((g,b)=>{let T=b+4-a;u[T]=g});let l=y.parseAxisParam(s,o.shape),p=[0,0,0,0];l.forEach(g=>{let b=g+4-a;p[b]=1});let m=[{type:"int32",data:p}],c=Se({inputs:{x:o},backend:t,attrs:{shape:u}}),d=new yk(u),f=t.runWebGPUProgram(d,[c],c.dtype,m);t.disposeData(c.dataId);let h=Se({inputs:{x:f},backend:t,attrs:{shape:i}});return t.disposeData(f.dataId),h}var ZV={kernelName:Qo,backendName:"webgpu",kernelFunc:Ife};var Tk=class{outputShape=[];shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms;workgroupSize=[64,1,1];fillSnippet;size=!0;constructor(e,t){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${de("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};var QV={kernelName:Za,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=new Tk(n.shape,s),[l,p]=C.getImageCenter(a,n.shape[1],n.shape[2]),m=[{type:"float32",data:[l]},{type:"float32",data:[p]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return typeof s=="number"?m.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):m.push({type:"float32",data:s}),i.runWebGPUProgram(u,[n],n.dtype,m)}};var Cfe=Ee({opType:26,cpuKernelImpl:JU}),JV={kernelName:Jo,backendName:"webgpu",kernelFunc:Cfe};var Bl=class{variableNames=["updates","indices"];uniforms;outputShape;sumDupeIndices;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];updatesRank;indicesRank;sliceDimGreaterThanOne;atomic=!0;type;constructor(e,t,n,o,s,a,i,u=!0){this.outputShape=a,this.type=i,this.sumDupeIndices=u,this.dispatchLayout=xe(e),this.dispatch=ce(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${o}_${this.sliceDimGreaterThanOne}_${i}_${u}`;let l=lr(s.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=o,this.indicesRank=n}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");let t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",o="",s="";this.dispatchLayout.x.length===1?(o="flattenedIndex",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(o="vec2<i32>(flattenedIndex, coords[1])",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);let i=`getUpdates(${Array.from({length:this.updatesRank},(p,m)=>`coords[${m}]`).join(", ")})`,u=(p,m)=>{let c=`atomicAdd(${p}, bitcast<i32>(${m}))`;this.type==="float32"&&(c=`
          {
            var oldBits = 0;
            var newBits = bitcast<i32>(${m});
            loop {
              let info = atomicCompareExchangeWeak(${p}, oldBits, newBits);
              if (info.exchanged) {
                break;
              }
              oldBits = info.old_value;
              let oldValue = bitcast<f32>(oldBits);
              let newValue = oldValue + (${m});
              newBits = bitcast<i32>(newValue);
            }
          }
        `);let d=`atomicStore(${p}, bitcast<i32>(${m}));`;return this.sumDupeIndices?c:d};return`
    ${s}

      ${de("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue =
              ${Of(this.type,!1)}(${i});
          let flatIndex = getOutputIndexFromCoords(${o});

          ${u("&result[flatIndex]","updateValue")};
        }
      }`}};function kfe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:m}=C.calculateShapes(s,o,a),c=[m/l,l];if(m===0)return t.makeTensorInfo(a,o.dtype);let d=Se({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),f=Se({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=f.dtype,g=mn({backend:t,attrs:{shape:c,value:0,dtype:h}}),b=y.sizeFromShape(f.shape),T=[{type:"int32",data:[i]},{type:"int32",data:p},{type:"int32",data:[b]}],x=new Bl(f.shape,i,d.shape.length,f.shape.length,p,c,h),I=t.runWebGPUProgram(x,[f,d],h,T,g),k=Se({inputs:{x:I},backend:t,attrs:{shape:a}});return t.disposeData(d.dataId),t.disposeData(f.dataId),t.disposeData(I.dataId),k}var e4={kernelName:Ha,backendName:"webgpu",kernelFunc:kfe};var xk=class{variableNames=["c","a","b"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];cRank;rank;size=!0;constructor(e,t,n){this.outputShape=t,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let i=0;i<this.outputShape.length;i++)a.push(`${o[i]}`),i<this.cRank&&s.push(`${o[i]}`);e=s.join(),t=a.join()}return`
      ${de("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}};function Sfe(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=new xk(n.shape.length,o.shape,o.shape.length);return t.runWebGPUProgram(a,[n,o,s],Pt(o.dtype,s.dtype))}var t4={kernelName:Ns,backendName:"webgpu",kernelFunc:Sfe};var vfe=Ee({opType:29}),r4={kernelName:ts,backendName:"webgpu",kernelFunc:vfe};var Afe=Ee({opType:27}),n4={kernelName:es,backendName:"webgpu",kernelFunc:Afe};var wfe=Ee({opType:28}),o4={kernelName:qa,backendName:"webgpu",kernelFunc:wfe};var f0=ft({opType:20,cpuKernelImpl:sK,supportsComplex:!0}),s4={kernelName:as,backendName:"webgpu",kernelFunc:f0};function Nfe(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=y.parseAxisParam([s],o.shape),i=_g({inputs:{x:o},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=C.expandShapeToKeepDim(i.shape,a),l=Se({inputs:{x:i},backend:t,attrs:{shape:u}}),p=f0({inputs:{a:o,b:l},backend:t}),m=l0({inputs:{x:p},backend:t}),c=Rg({inputs:{x:m},backend:t,attrs:{axis:a,keepDims:!1}}),d=Se({inputs:{x:c},backend:t,attrs:{shape:u}}),f=d0({inputs:{a:m,b:d},backend:t});return t.disposeData(i.dataId),t.disposeData(l.dataId),t.disposeData(p.dataId),t.disposeData(m.dataId),t.disposeData(c.dataId),t.disposeData(d.dataId),f}var a4={kernelName:os,backendName:"webgpu",kernelFunc:Nfe};var Dfe=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((b,T)=>b*T),u=[[0,0]];u.push(...a);for(let b=1+s.length;b<o.shape.length;++b)u.push([0,0]);let l=[],p=c0({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),m=C.getReshaped(p.shape,s,i,!1),c=C.getPermuted(m.length,s.length,!1),d=C.getReshapedPermuted(p.shape,s,i,!1),f=Se({inputs:{x:p},backend:t,attrs:{shape:m}}),h=An({inputs:{x:f},backend:t,attrs:{perm:c}}),g=Se({inputs:{x:h},backend:t,attrs:{shape:d}});return l.push(p),l.push(f),l.push(h),l.forEach(b=>t.disposeData(b.dataId)),g},i4={kernelName:_s,backendName:"webgpu",kernelFunc:Dfe};var Ik=class{variableNames=["A"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];size=!0;rank;constructor(e,t){let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let e=_fe(this.rank,"uniforms.");return`
      ${de("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}};function _fe(r,e=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${e}aShape)`;let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r;o++)n.push(`(${t[o]} % ${e}aShape[${o}])`);return n.join()}function h0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(t.shouldExecuteOnCPU([o])||o.dtype==="string"||o.shape.length>=5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(c=>y.decodeString(c)):u,p=Ie(o.shape,o.dtype,l),m=aK(p,s);return t.makeTensorInfo(m.shape,m.dtype,m.values)}let a=new Ik(o.shape,s);return t.runWebGPUProgram(a,[o],o.dtype)}var u4={kernelName:Dn,backendName:"webgpu",kernelFunc:h0};function Mfe(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1;if(s.dtype==="string"){let M=t.bufferSync(o),R=t.bufferSync(s),E=y.decodeString(t.readSync(a.dataId)[0]),O=eK(M,R,i,c,p,l,u,m,E,d);return t.makeTensorInfo(i,O.dtype,O.values)}let f=[c/p,p],h=Se({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),g=s.shape.length?Se({inputs:{x:s},backend:t,attrs:{shape:[l,p]}}):pr({inputs:{x:s},backend:t}),b=g.dtype,T=t.makeTensorInfo([],b,y.makeZerosTypedArray(1,b)),x=Se({inputs:{x:a},backend:t,attrs:{shape:Array(f.length).fill(1)}}),I=h0({inputs:{x},backend:t,attrs:{reps:f}}),k=y.sizeFromShape([l,p]),w=[{type:"int32",data:[u]},{type:"int32",data:m},{type:"int32",data:[k]}];switch(l){case 0:break;case 1:{let M=new Bl([l,p],u,h.shape.length,g.shape.length,m,f,b,d);t.runWebGPUProgram(M,[g,h],b,w,I)}break;default:{let M=new Bl([l,p],u,h.shape.length,T.shape.length,m,f,b,d);t.runWebGPUProgram(M,[T,h],b,w,I)}{let M=new Bl([l,p],u,h.shape.length,g.shape.length,m,f,b);t.runWebGPUProgram(M,[g,h],b,w,I)}}let _=Se({inputs:{x:I},backend:t,attrs:{shape:i}});return t.disposeData(h.dataId),t.disposeData(g.dataId),t.disposeData(x.dataId),t.disposeData(T.dataId),t.disposeData(I.dataId),_}var l4={kernelName:Ju,backendName:"webgpu",kernelFunc:Mfe};function Rfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=o.shape.length,p=new Array(l).fill(0),m=o.shape.slice();return u.map(c=>{let d=[...m];d[i]=c;let f=xi({inputs:{x:o},backend:t,attrs:{begin:p,size:d}});return p[i]+=c,f})}var p4={kernelName:Ms,backendName:"webgpu",kernelFunc:Rfe};var Pfe=Ee({opType:30}),m4={kernelName:rs,backendName:"webgpu",kernelFunc:Pfe};var c4={kernelName:wi,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e,o=new ma(t.shape,31);return n.runWebGPUProgram(o,[t],t.dtype)}};var Efe=ft({opType:19}),d4={kernelName:ss,backendName:"webgpu",kernelFunc:Efe};var Ck=class{variableNames=["x"];uniforms;outputShape;shaderKey;dispatchLayout;dispatch;workPerThread=1;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);let t=lr(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e=this.outputShape.length,t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let o=0;t=this.outputShape.map((s,a)=>(o++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${o-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${de("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}};function Ffe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),k;if(h)k=Se({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),_=xi({inputs:{x:o},backend:t,attrs:{begin:T,size:w}});k=Se({inputs:{x:_},backend:t,attrs:{shape:f}}),t.disposeData(_.dataId)}else if(t.shouldExecuteOnCPU([o])){let _=t.readSync(o.dataId),M=Ie(o.shape,o.dtype,_),R=nK(d,M,I,T);k=t.makeTensorInfo(f,o.dtype,R.values)}else{let _=new Ck(d),M=[{type:"int32",data:T},{type:"int32",data:I}],R=t.runWebGPUProgram(_,[o],o.dtype,M);k=Se({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeData(R.dataId)}return k}var f4={kernelName:ja,backendName:"webgpu",kernelFunc:Ffe};function Lfe(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:m}=e,c=t.readSync(p.dataId),d=t.readSync(m.dataId),[f,h]=oK(c,d,o,s,a,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(m.shape,"int32",h)]}var h4={kernelName:Ni,backendName:"webgpu",kernelFunc:Lfe};var $fe=Ee({opType:32}),g4={kernelName:is,backendName:"webgpu",kernelFunc:$fe};var Bfe=Ee({opType:33}),b4={kernelName:us,backendName:"webgpu",kernelFunc:Bfe};var kk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","indices"];uniforms;workgroupSize=[256,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${de("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},Sk=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","indices"];uniforms;workgroupSize=[256,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${de("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};function jf(r,e){e!==null&&r.disposeData(e.dataId)}function y4(r){let e=1;for(;e<r;)e*=2;return e}function Ofe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n,i=o.shape,u=i[i.length-1];if(t.shouldExecuteOnCPU([o])){let k=t.readSync(o.dataId),[w,_]=iK(k,i,o.dtype,s,a);return[t.makeTensorInfo(w.shape,w.dtype,w.values),t.makeTensorInfo(_.shape,_.dtype,_.values)]}if(s===0)return i[i.length-1]=0,[t.makeTensorInfo(i,o.dtype,[]),t.makeTensorInfo(i,"int32",[])];if(u===1)return[o,mn({attrs:{shape:i,dtype:"int32",value:0},backend:t})];let p=y.sizeFromShape(i)/u,m=Se({inputs:{x:o},attrs:{shape:[p,u]},backend:t}),c=y4(s),d=y4(u),f=null,h=()=>f===null?[m,m]:[m,f],g=(k,w,_)=>{let M=h(),R=new kk(_),O=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[k]},{type:"int32",data:[w]}],G=f;f=t.runWebGPUProgram(R,M,"int32",O),jf(t,G)};for(let k=1;k<c;k*=2){let w=k*2;for(let _=k;_>=1;_/=2)g(w,_,[p,d])}for(let k=d;k>c;k/=2){let w=h(),_=new Sk([p,k/2]),R=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[c]}],E=f;f=t.runWebGPUProgram(_,w,"int32",R),jf(t,E);let O=c/2,G=O*2;for(let W=O;W>=1;W/=2)g(G,W,f.shape)}let b=f;f=xi({inputs:{x:f},backend:t,attrs:{begin:0,size:[p,s]}}),jf(t,b);let T=m0({inputs:{x:m,indices:f},backend:t,attrs:{axis:1,batchDims:1}});jf(t,m);let x=i.slice(0,-1);x.push(s),b=f,f=Se({inputs:{x:f},attrs:{shape:x},backend:t}),jf(t,b);let I=T;return T=Se({inputs:{x:T},attrs:{shape:x},backend:t}),jf(t,I),[T,f]}var T4={kernelName:Xa,backendName:"webgpu",kernelFunc:Ofe};var vk=class{variableNames=["Image","Transforms"];outputShape;uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,";shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=xe(this.outputShape),this.dispatch=ce(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${de("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};function zfe(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=new vk(g),T=a==="nearest"?1:2,x;switch(i){case"constant":x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4;break;default:x=1;break}let I=[{type:"int32",data:[T]},{type:"int32",data:[x]},{type:"float32",data:[u]}];return t.runWebGPUProgram(b,[o,s],"float32",I)}var x4={kernelName:Ya,backendName:"webgpu",kernelFunc:zfe};function Gfe(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],l=new Array(i-1),p=0;for(let h=0;h<i;h++)h!==s&&(l[p++]=a.shape[h]);let m=[],c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){c[s]=h;let g=xi({inputs:{x:a},backend:t,attrs:{begin:c,size:d}}),b=Se({inputs:{x:g},backend:t,attrs:{shape:l}});f[h]=b,m.push(g)}return m.forEach(h=>t.disposeData(h.dataId)),f}var I4={kernelName:Rs,backendName:"webgpu",kernelFunc:Gfe};var Wfe=[wU,lK,pK,mK,cK,dK,hK,gK,bK,yK,TK,xK,IK,CK,kK,AK,wK,DK,_K,EK,FK,LK,DU,BK,OK,zK,GK,WK,UK,HK,qK,jK,XK,YK,JK,eV,tV,rV,nV,oV,sV,vU,aV,lV,iV,uV,pV,mV,cV,dV,fV,hV,gV,NU,$K,bV,yV,TV,xV,IV,CV,kV,SV,vV,SK,AV,wV,vK,NV,DV,_V,MV,ZK,RV,PV,EV,MK,FV,BV,OV,zV,GV,WV,UV,KV,RK,VV,HV,qV,jV,AU,XV,YV,ZV,QV,JV,e4,t4,r4,n4,o4,NK,f4,h4,a4,i4,l4,p4,m4,c4,d4,s4,QK,g4,b4,u4,T4,x4,fK,I4,LV];for(let r of Wfe)su(r);var Qe=(s=>(s[s.float32=0]="float32",s[s.int32=1]="int32",s[s.bool=2]="bool",s[s.string=3]="string",s[s.complex64=4]="complex64",s))(Qe||{}),lm=(i=>(i[i.linear=0]="linear",i[i.relu=1]="relu",i[i.relu6=2]="relu6",i[i.prelu=3]="prelu",i[i.leakyrelu=4]="leakyrelu",i[i.sigmoid=5]="sigmoid",i[i.elu=6]="elu",i))(lm||{});var C4;function Ufe(r){C4=r.wasm.cwrap(Fs,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function Kfe(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n,c=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(s.dataId).id,f=0;if(a!=null){let M=t.dataIdMap.get(a.dataId);if(M.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${M.shape.length}.`);f=M.id}let h=i==null?0:t.dataIdMap.get(i.dataId).id,g=lm[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let b=u?o.shape[2]:o.shape[1],T=l?s.shape[1]:s.shape[2],x=Dr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),I=t.makeOutput([...x,b,T],o.dtype),k=t.dataIdMap.get(I.dataId).id,w=new Uint8Array(new Int32Array(o.shape).buffer),_=new Uint8Array(new Int32Array(s.shape).buffer);return C4(c,w,o.shape.length,d,_,s.shape.length,u,l,g,f,h,m||0,k),I}var k4={kernelName:Fs,backendName:"wasm",setupFunc:Ufe,kernelFunc:Kfe};function st(r,e){let t;function n(s){t=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:a,inputs:{x:i}}=s,u=a.dataIdMap.get(i.dataId).id,l=a.makeOutput(i.shape,e||i.dtype),p=a.dataIdMap.get(l.dataId).id;return y.sizeFromShape(l.shape)===0||t(u,Qe[i.dtype],p),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var S4=st(Ts);function ht(r,e,t){let n;function o(a){n=a.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(a){let{backend:i,inputs:u}=a,{a:l,b:p}=u,m=i.dataIdMap.get(l.dataId).id,c=i.dataIdMap.get(p.dataId).id,d=t??l.dtype,f=C.assertAndGetBroadcastShape(l.shape,p.shape),h=i.makeOutput(f,d);if(y.sizeFromShape(f)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),b=new Uint8Array(new Int32Array(p.shape).buffer),T=i.dataIdMap.get(h.dataId).id;return(()=>n(m,g,l.shape.length,c,b,p.shape.length,Qe[l.dtype],T))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var Vfe=!0,v4=ht(Nn,Vfe);var A4;function Hfe(r){A4=r.wasm.cwrap(co,null,["array","number","number","number"])}function qfe(r){let{inputs:e,backend:t}=r,n=t.makeOutput(e[0].shape,e[0].dtype);if(y.sizeFromShape(n.shape)===0)return n;let o=e.map(i=>t.dataIdMap.get(i.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),a=t.dataIdMap.get(n.dataId).id;return A4(s,o.length,Qe[n.dtype],a),n}var w4={kernelName:co,backendName:"wasm",setupFunc:Hfe,kernelFunc:qfe};function pm(r){let{inputs:{x:e},backend:t}=r;if(e.dtype==="string")return mr(t.readSync(e.dataId),e.shape,e.dtype);let n=t.makeOutput(e.shape,e.dtype),o=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(n).set(o),n}var N4={kernelName:Vn,backendName:"wasm",kernelFunc:pm};var D4;function jfe(r){D4=r.wasm.cwrap(_n,null,["number","array","number","number","number","array","number"])}function ys(r){let{inputs:e,backend:t,attrs:n}=r,[o,s]=Yfe(e.x.shape,n.perm),a=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(a=!1);let i=Xfe(e.x.shape,n.perm),u={dataId:e.x.dataId,shape:o,dtype:e.x.dtype};if(a){let f=pm({inputs:e,backend:t});return f.shape=i,f}let l=t.makeOutput(i,u.dtype),p=t.dataIdMap.get(u.dataId).id,m=t.dataIdMap.get(l.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),d=new Uint8Array(new Int32Array(u.shape).buffer);return D4(p,d,u.shape.length,Qe[u.dtype],m,c,s.length),l}function Xfe(r,e){let t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=r[e[n]];return t}function Yfe(r,e){let t=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&t.push(r[o]),r[e[o]]!==1&&n.push(e[o]);for(let o=0;o<n.length;++o){let s=-1;for(let a=0;a<n.length;++a)n[a]>=o&&(s===-1||n[s]>n[a])&&(s=a);n[s]=o}return[t,n]}var _4={kernelName:_n,backendName:"wasm",kernelFunc:ys,setupFunc:jfe};function wn(r,e,t){let n=r.shape,o=r.shape.length,s=y.parseAxisParam(e,n),a=s,i=C.getAxesPermutation(a,o),u=null,l=!1;if(i!=null){let p=new Array(o);for(let d=0;d<p.length;d++)p[d]=n[i[d]];a=C.getInnerMostAxes(a.length,o),u=ys({inputs:{x:r},attrs:{perm:i},backend:t});let m=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(u.dataId).id!==m&&(l=!0)}return{transposed:u,originalAxes:s,axes:a,inputWasTransposed:l}}var M4;function Zfe(r){M4=r.wasm.cwrap(Ta,null,["number, number, number"])}function Qfe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;l=p,u=x}let f=l.shape.length;C.assertAxesAreInnerMostDims("all",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,a.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;M4(u,b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var R4={kernelName:Ta,backendName:"wasm",setupFunc:Zfe,kernelFunc:Qfe};var P4;function Jfe(r){P4=r.wasm.cwrap(xa,null,["number, number, number"])}function ehe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;l=p,u=x}let f=l.shape.length;C.assertAxesAreInnerMostDims("any",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,a.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;P4(u,b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var E4={kernelName:xa,backendName:"wasm",setupFunc:Jfe,kernelFunc:ehe};var F4;function the(r){F4=r.wasm.cwrap(fo,null,["number","number","number","number","number"])}function rhe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=a,u=s,{transposed:l,axes:p,inputWasTransposed:m}=wn(s,o,e);if(m){let b=e.dataIdMap.get(l.dataId).id;b!==a&&(u=l,i=b)}let c=u.shape.slice(0,-1),d=e.makeOutput(c,"int32"),f=e.dataIdMap.get(d.dataId).id,h=y.sizeFromShape(d.shape),g=u.shape[p[0]];return F4(i,Qe[u.dtype],h,g,f),m&&e.disposeData(l.dataId),d}var L4={kernelName:fo,backendName:"wasm",kernelFunc:rhe,setupFunc:the};var $4;function nhe(r){$4=r.wasm.cwrap(ho,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ohe(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=t,p=C.computePool2DInfo(o.shape,a,i,1,u,l),m=p.filterHeight,c=p.filterWidth,d=p.padInfo.top,f=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,b=p.strideHeight,T=p.strideWidth,x=p.inChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(p.dilationWidth!==1||p.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let I=n.makeOutput(p.outShape,"float32"),k=n.dataIdMap.get(I.dataId).id;return $4(s,o.shape[0],o.shape[1],o.shape[2],m,c,d,f,h,g,b,T,x,k),I}var B4={kernelName:ho,backendName:"wasm",setupFunc:nhe,kernelFunc:ohe};function hr(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(o,s);return y.assert(s===y.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var O4={kernelName:ws,backendName:"wasm",kernelFunc:hr};var z4;function she(r){z4=r.wasm.cwrap(go,null,["number","array","number","number","array","number","number","number","number"])}function ahe(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,p=a?o.shape[u-2]:o.shape[u-1],m=i?s.shape[l-1]:s.shape[l-2],c=a?o.shape[u-1]:o.shape[u-2],d=i?s.shape[l-2]:s.shape[l-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(f),b=y.sizeFromShape(h),x=Dr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,d]);y.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,p,c]:[g,c,p],k=i?[b,d,m]:[b,m,d],w=hr({inputs:{x:o},backend:t,attrs:{shape:I}}),_=hr({inputs:{x:s},backend:t,attrs:{shape:k}}),M=t.dataIdMap.get(w.dataId).id,R=t.dataIdMap.get(_.dataId).id,E=a?w.shape[2]:w.shape[1],O=i?_.shape[1]:_.shape[2],G=Math.max(g,b),W=t.makeOutput([G,E,O],w.dtype),H=t.dataIdMap.get(W.dataId).id,U=new Uint8Array(new Int32Array(w.shape).buffer),V=new Uint8Array(new Int32Array(_.shape).buffer);return z4(M,U,w.shape.length,R,V,_.shape.length,a,i,H),t.disposeData(w.dataId),t.disposeData(_.dataId),W.shape=x,W}var G4={kernelName:go,backendName:"wasm",setupFunc:she,kernelFunc:ahe};function ca(r){let{inputs:{x:e},attrs:{begin:t,size:n},backend:o}=r,[s,a]=It.parseSliceParams(e,t,n),i=It.isSliceContinous(e.shape,s,a),u=o.readSync(e.dataId),l=o.makeOutput(a,e.dtype),p=y.computeStrides(e.shape),m=o.dataIdMap.get(l.dataId);if(i){let f=It.computeFlatOffset(s,p);return e.dtype==="string"?m.stringBytes=u.slice(f,f+y.sizeFromShape(a)):o.typedArrayFromHeap(l).set(u.subarray(f,f+y.sizeFromShape(a))),l}if(e.dtype==="string"){let f=Wp(u,s,a,e.shape,e.dtype);return m.stringBytes=f,l}let c=o.typedArrayFromHeap(l),d=e.shape.length;if(d===2)ihe(u,p[0],c,s,a);else if(d===3)uhe(u,p[0],p[1],c,s,a);else if(d===4)lhe(u,p[0],p[1],p[2],c,s,a);else{let f=Wp(u,s,a,e.shape,e.dtype);c.set(f)}return l}function ihe(r,e,t,n,o){let s=0,a=n[0],i=n[1],u=a+o[0];for(let l=a;l<u;l++){let p=l*e+i;t.set(r.subarray(p,p+o[1]),s),s+=o[1]}}function uhe(r,e,t,n,o,s){let a=0,i=o[0],u=o[1],l=o[2],p=i+s[0],m=u+s[1];for(let c=i;c<p;c++)for(let d=u;d<m;d++){let f=c*e+d*t+l;n.set(r.subarray(f,f+s[2]),a),a+=s[2]}}function lhe(r,e,t,n,o,s,a){let i=0,u=s[0],l=s[1],p=s[2],m=u+a[0],c=l+a[1],d=p+a[2],f=s[3];for(let h=u;h<m;h++)for(let g=l;g<c;g++)for(let b=p;b<d;b++){let T=h*e+g*t+b*n+f;o.set(r.subarray(T,T+a[3]),i),i+=a[3]}}var W4={kernelName:Ds,backendName:"wasm",kernelFunc:ca};function phe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n,i=s.reduce((b,T)=>b*T),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=hr({inputs:{x:o},backend:t,attrs:{shape:u}}),f=ys({inputs:{x:d},backend:t,attrs:{perm:l}}),h=hr({inputs:{x:f},backend:t,attrs:{shape:p}}),g=ca({inputs:{x:h},backend:t,attrs:{begin:m,size:c}});return t.disposeData(d.dataId),t.disposeData(f.dataId),t.disposeData(d.dataId),g}var U4={kernelName:xs,backendName:"wasm",kernelFunc:phe};function Ii(r){let{inputs:{x:e},attrs:{dtype:t},backend:n}=r,o=n.makeOutput(e.shape,t),s=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(o).set(s),o}var K4={kernelName:Un,backendName:"wasm",kernelFunc:Ii};var V4=st(bo);var H4;function mhe(r){H4=r.wasm.cwrap(Kn,null,["number","number","number","number"])}function che(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i=t.dataIdMap.get(o.dataId).id,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(u.dataId).id;return H4(i,s,a,l),u}var q4={kernelName:Kn,backendName:"wasm",setupFunc:mhe,kernelFunc:che};function g0(r){let{inputs:e,backend:t}=r,n=y.parseAxisParam(r.attrs.axis,e[0].shape)[0],o=e.map(d=>d.shape);C.assertParamsConsistent(o,n);let s=C.computeOutShape(e.map(d=>d.shape),n),a=e.filter(d=>y.sizeFromShape(d.shape)>0);if(a.length===1)return pm({inputs:{x:a[0]},backend:t});let i=t.makeOutput(s,e[0].dtype);if(y.sizeFromShape(s)===0)return i;if(a[0].dtype==="string"){let d=a.map(x=>{let I=y.sizeFromShape(x.shape.slice(n));return hr({inputs:{x},backend:t,attrs:{shape:[-1,I]}})}),f=d.map(x=>({vals:t.readSync(x.dataId),shape:x.shape}));s=C.computeOutShape(d.map(x=>x.shape),1);let h=d[0].shape[0]===1,g=Op(f,s,e[0].dtype,h),b=C.computeOutShape(a.map(x=>x.shape),n);i.shape=b;let T=t.dataIdMap.get(i.dataId);return T.stringBytes=C.fromStringArrayToUint8(g),d.forEach(x=>t.disposeData(x.dataId)),i}let u=y.sizeFromShape(a[0].shape.slice(0,n)),l=0,p=a.map(d=>{let f=y.sizeFromShape(d.shape.slice(n));return l+=f,f}),m=a.map(d=>t.typedArrayFromHeap(d)),c=t.typedArrayFromHeap(i);for(let d=0;d<u;d++){let f=d*l;for(let h=0;h<m.length;h++){let g=p[h],b=d*g,T=m[h].subarray(b,b+g);c.set(T,f),f+=g}}return i}var j4={kernelName:Is,backendName:"wasm",kernelFunc:g0};var X4;function dhe(r){X4=r.wasm.cwrap(yo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function fhe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:m,dataFormat:c}=t,d=C.convertConv2DDataFormat(c),f=C.computeConv2DInfo(o.shape,s.shape,u,l,p,m,!1,d),h=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,T=f.padInfo.right,x=f.padInfo.bottom,I=f.padInfo.left,k=f.dilationHeight,w=f.dilationWidth,_=f.strideHeight,M=f.strideWidth,R=f.inChannels,E=f.outChannels,O=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let G=n.makeOutput(f.outShape,"float32"),W=n.dataIdMap.get(G.dataId).id;return X4(a,o.shape[0],o.shape[1],o.shape[2],i,h,g,b,T,x,I,O,k,w,_,M,R,E,W),G}var Y4={kernelName:yo,backendName:"wasm",setupFunc:dhe,kernelFunc:fhe};var Z4;function hhe(r){Z4=r.wasm.cwrap(To,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ghe(r){let{backend:e,inputs:t,attrs:n}=r,{dy:o,filter:s}=t,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,inputShape:p}=n,m=1,c=C.convertConv2DDataFormat(u),d=C.computeConv2DInfo(p,s.shape,a,m,i,l,!1,c),{batchSize:f,filterHeight:h,filterWidth:g,inChannels:b,inHeight:T,inWidth:x,outChannels:I,outHeight:k,outWidth:w,strideHeight:_,strideWidth:M}=d,R=h-1-d.padInfo.top,E=g-1-d.padInfo.left,O=d.dataFormat==="channelsLast",G=y.computeStrides(d.inShape),W=y.computeStrides(o.shape),[H,U,V]=y.computeStrides(s.shape),Y=G[0],j=O?G[1]:G[2],te=O?G[2]:1,ne=O?1:G[1],oe=W[0],ae=O?W[1]:W[2],se=O?W[2]:1,ie=O?1:W[1],he=e.makeOutput(d.inShape,"float32"),ye=e.dataIdMap.get(he.dataId).id,ve=e.dataIdMap.get(o.dataId).id,Fe=e.dataIdMap.get(s.dataId).id;return Z4(ve,Fe,f,h,g,T,x,b,k,w,I,_,M,R,E,H,U,V,Y,j,te,ne,oe,ae,se,ie,ye),he}var Q4={kernelName:To,backendName:"wasm",setupFunc:hhe,kernelFunc:ghe};var J4=st(xo);var eH=st(Io);var tH=(t=>(t[t.bilinear=0]="bilinear",t[t.nearest=1]="nearest",t))(tH||{}),rH;function bhe(r){rH=r.wasm.cwrap(wa,null,["number","number","number","number","array","number","number","number","number","number"])}function yhe(r){let{backend:e,inputs:t,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:a}=n,{image:i,boxes:u,boxInd:l}=t,p=u.shape[0],[m,c]=a,d=[p,m,c,i.shape[3]],f=e.dataIdMap.get(i.dataId),h;i.dtype!=="float32"&&(h=Ii({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),f=e.dataIdMap.get(h.dataId));let g=f.id,b=e.dataIdMap.get(u.dataId).id,T=e.dataIdMap.get(l.dataId).id,x=e.makeOutput(d,"float32"),I=e.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(i.shape).buffer);return rH(g,b,T,p,k,m,c,tH[o],s,I),h!=null&&e.disposeData(h.dataId),x}var nH={kernelName:wa,backendName:"wasm",setupFunc:bhe,kernelFunc:yhe};var oH;function The(r){oH=r.wasm.cwrap(Aa,null,["number","number","number","number","number","number"])}function xhe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumprod does not support ${o.dtype} tensors in the WASM backend`);let l=C.getAxesPermutation([s],u),p=o;l!==null&&(p=ys({inputs:{x:o},attrs:{perm:l},backend:t}));let m=C.getInnerMostAxes(1,u)[0];C.assertAxesAreInnerMostDims("cumprod",[m],u);let c=t.makeOutput(p.shape,p.dtype),d=p.shape[m],f=t.dataIdMap.get(p.dataId).id,h=t.dataIdMap.get(c.dataId).id;oH(f,a?1:0,i?1:0,d,h,Qe[o.dtype]);let g=c;if(l!==null){let b=C.getUndoAxesPermutation(l);g=ys({inputs:{x:c},attrs:{perm:b},backend:t}),t.disposeData(p.dataId),t.disposeData(c.dataId)}return g}var sH={kernelName:Aa,backendName:"wasm",setupFunc:The,kernelFunc:xhe};var aH;function Ihe(r){aH=r.wasm.cwrap(Co,null,["number","number","number","number","number","number"])}function Che(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=C.getAxesPermutation([s],u),p=o;l!==null&&(p=ys({inputs:{x:o},attrs:{perm:l},backend:t}));let m=C.getInnerMostAxes(1,u)[0];C.assertAxesAreInnerMostDims("cumsum",[m],u);let c=t.makeOutput(p.shape,p.dtype),d=p.shape[m],f=t.dataIdMap.get(p.dataId).id,h=t.dataIdMap.get(c.dataId).id;aH(f,a?1:0,i?1:0,d,h,Qe[o.dtype]);let g=c;if(l!==null){let b=C.getUndoAxesPermutation(l);g=ys({inputs:{x:c},attrs:{perm:b},backend:t}),t.disposeData(p.dataId),t.disposeData(c.dataId)}return g}var iH={kernelName:Co,backendName:"wasm",setupFunc:Ihe,kernelFunc:Che};var uH;function khe(r){uH=r.wasm.cwrap(Na,null,["number","number","number","array","number","array","array","number","number"])}function She(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=l*s,d=p/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=e.makeOutput(f,"float32"),b=e.dataIdMap.get(o.dataId).id,T=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),x=new Uint8Array(new Int32Array(f).buffer),I=new Uint8Array(new Int32Array(y.computeStrides(f)).buffer),k=e.dataIdMap.get(h.dataId).id;return uH(b,s,a==="NHWC"?1:0,T,o.shape.length-1,x,I,f.length,k),h}var lH={kernelName:Na,backendName:"wasm",setupFunc:khe,kernelFunc:She};var pH;function vhe(r){pH=r.wasm.cwrap(ko,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ahe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:m}=t,c=l??[1,1],d=C.computeConv2DInfo(o.shape,s.shape,u,c,p,m,!0),f=d.filterHeight,h=d.filterWidth,g=d.padInfo.top,b=d.padInfo.right,T=d.padInfo.bottom,x=d.padInfo.left,I=d.dilationHeight,k=d.dilationWidth,w=d.strideHeight,_=d.strideWidth,M=d.inChannels,R=d.outChannels,E=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let O=n.makeOutput(d.outShape,"float32"),G=n.dataIdMap.get(O.dataId).id;return pH(a,o.shape[0],o.shape[1],o.shape[2],i,f,h,g,b,T,x,E,I,k,w,_,M,R,G),O}var mH={kernelName:ko,backendName:"wasm",setupFunc:vhe,kernelFunc:Ahe};var cH=st(vo);var whe=!1,dH=ht(_a,whe,"bool");var fH=st(Ao,"float32");function Ak(r){let{inputs:e,attrs:t,backend:n}=r,{input:o}=e,{dim:s}=t,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),hr({inputs:{x:o},backend:n,attrs:{shape:i}})}var hH={kernelName:Cs,backendName:"wasm",kernelFunc:Ak};function b0(r){let{attrs:{shape:e,value:t,dtype:n},backend:o}=r,s=o.makeOutput(e,n);return o.typedArrayFromHeap(s).fill(t),s}var gH={kernelName:vi,backendName:"wasm",kernelFunc:b0};var bH;function Nhe(r){bH=r.wasm.cwrap(Ra,null,["number","number","number","number","number","number"])}function Dhe(r){let{inputs:e,backend:t}=r,{image:n}=e,o=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,[i,u,l,p]=n.shape;return bH(s,i,u,l,p,a),o}var yH={kernelName:Ra,backendName:"wasm",kernelFunc:Dhe,setupFunc:Nhe};var TH=st(wo);var _he=!1,xH=ht(No,_he);var IH;function Mhe(r){IH=r.wasm.cwrap(Do,null,["number","number","number","number","number","number","number"])}function Rhe(r){let{backend:e,inputs:t,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:a,variance:i,offset:u,scale:l}=t,p=e.dataIdMap.get(s.dataId).id,m=e.dataIdMap.get(a.dataId).id,c=e.dataIdMap.get(i.dataId).id,d=u!=null?e.dataIdMap.get(u.dataId).id:0,f=l!=null?e.dataIdMap.get(l.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(y.sizeFromShape(s.shape)===0)return h;let g=e.dataIdMap.get(h.dataId).id;return IH(p,m,c,d,f,o,g),h}var CH={kernelName:Do,backendName:"wasm",setupFunc:Mhe,kernelFunc:Rhe};var kH;function Phe(r){kH=r.wasm.cwrap(Ls,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ehe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dataFormat:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=t,h=C.computeConv2DInfo(o.shape,s.shape,u,p,l,c),g=lm[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);let b=n.dataIdMap.get(o.dataId).id,T=n.dataIdMap.get(s.dataId).id,x=h.outChannels,I=0;if(a!=null){let se=n.dataIdMap.get(a.dataId);if(se.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${se.shape.length}.`);if(se.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${se.shape}) does not match the number of output channels (${x})`);I=se.id}let k=h.filterHeight,w=h.filterWidth,_=h.padInfo.top,M=h.padInfo.right,R=h.padInfo.bottom,E=h.padInfo.left,O=h.dilationHeight,G=h.dilationWidth,W=h.strideHeight,H=h.strideWidth,U=h.inChannels,V=h.padInfo.type==="SAME"?1:0,Y=h.batchSize,j=h.inHeight,te=h.inWidth;if(m!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);let ne=n.makeOutput(h.outShape,"float32"),oe=n.dataIdMap.get(ne.dataId).id,ae=i==null?0:n.dataIdMap.get(i.dataId).id;return kH(b,Y,j,te,T,k,w,I,_,M,R,E,V,O,G,W,H,U,x,g,ae,f||0,oe),ne}var SH={kernelName:Ls,backendName:"wasm",setupFunc:Phe,kernelFunc:Ehe};var vH;function Fhe(r){vH=r.wasm.cwrap($s,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Lhe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dataFormat:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=t,h=C.computeConv2DInfo(o.shape,s.shape,u,p,l,c,!0),g=lm[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=n.dataIdMap.get(o.dataId).id,T=n.dataIdMap.get(s.dataId).id,x=h.outChannels,I=0;if(a!=null){let se=n.dataIdMap.get(a.dataId);if(se.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${se.shape.length}.`);if(se.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${se.shape}) does not match the number of output channels (${x})`);I=se.id}let k=h.filterHeight,w=h.filterWidth,_=h.padInfo.top,M=h.padInfo.right,R=h.padInfo.bottom,E=h.padInfo.left,O=h.dilationHeight,G=h.dilationWidth,W=h.strideHeight,H=h.strideWidth,U=h.inChannels,V=h.padInfo.type==="SAME"?1:0,Y=h.batchSize,j=h.inHeight,te=h.inWidth;if(m!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);let ne=n.makeOutput(h.outShape,"float32"),oe=n.dataIdMap.get(ne.dataId).id,ae=i==null?0:n.dataIdMap.get(i.dataId).id;return vH(b,Y,j,te,T,k,w,I,_,M,R,E,V,O,G,W,H,U,x,g,ae,f||0,oe),ne}var AH={kernelName:$s,backendName:"wasm",setupFunc:Fhe,kernelFunc:Lhe};var wH;function $he(r){wH=r.wasm.cwrap(Pa,null,["number","number","number","number","number","number","array","number"])}function Bhe(r){let{backend:e,inputs:t}=r,{params:n,indices:o}=t,[s,a,i,u]=Bb.prepareAndValidate(n,o),l=e.makeOutput(s,n.dtype);if(a===0)return l;let p=o.shape,m=p[p.length-1],d=e.dataIdMap.get(n.dataId).id,h=e.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),b=e.dataIdMap.get(l.dataId).id;return wH(d,Qe[n.dtype],h,a,m,i,g,b),l}var NH={kernelName:Pa,backendName:"wasm",setupFunc:$he,kernelFunc:Bhe};var DH;function Ohe(r){DH=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function zhe(r){let{backend:e,inputs:t,attrs:n}=r,{x:o,indices:s}=t,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0],l=e.readSync(s.dataId),p=o.shape[u];for(let R=0;R<l.length;++R){let E=l[R];y.assert(E<=p-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${p-1}]`)}let m=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),c=hr({inputs:{x:o},attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]},backend:e}),d=y.sizeFromShape(s.shape),f=hr({inputs:{x:s},attrs:{shape:[m.batchSize,d/m.batchSize]},backend:e}),h=[m.batchSize,m.outerSize,d/m.batchSize,m.sliceSize],g=e.makeOutput(h,o.dtype);if(y.sizeFromShape(o.shape)===0)return g;let b=c.shape.length-1,x=e.dataIdMap.get(c.dataId).id,k=e.dataIdMap.get(f.dataId).id,w=e.dataIdMap.get(g.dataId).id,_=new Uint8Array(new Int32Array(y.computeStrides(c.shape)).buffer),M=new Uint8Array(new Int32Array(y.computeStrides(h)).buffer);return DH(x,Qe[o.dtype],_,b,k,m.batchSize,M,w),e.disposeData(c.dataId),e.disposeData(f.dataId),g.shape=m.outputShape,g}var _H={kernelName:ks,backendName:"wasm",setupFunc:Ohe,kernelFunc:zhe};var Ghe=!1,MH=ht(Ea,Ghe,"bool");var Whe=!1,RH=ht(_o,Whe,"bool");var PH=st(Mo,"bool");var EH;function Uhe(r){EH=r.wasm.cwrap(Ro,null,["number","number","number","number"])}function Khe(r){let{inputs:{x:e},attrs:{alpha:t},backend:n}=r,o=n.dataIdMap.get(e.dataId).id,s=n.makeOutput(e.shape,"float32");if(y.sizeFromShape(e.shape)!==0){let a=n.dataIdMap.get(s.dataId).id;EH(o,Qe[e.dtype],t,a)}return s}var FH={kernelName:Ro,backendName:"wasm",setupFunc:Uhe,kernelFunc:Khe};var Vhe=!1,LH=ht($a,Vhe,"bool");var Hhe=!1,$H=ht(Ba,Hhe,"bool");var BH=st(Po);var qhe=!1,OH=ht(Oa,qhe,"bool");var zH=st(za);var jhe=!1,GH=ht(Ji,jhe,"bool");var Xhe=!1,WH=ht(Z0,Xhe,"bool");var UH;function Yhe(r){UH=r.wasm.cwrap(Eo,null,["number","number","number","number"])}function Zhe(r){let{backend:e,inputs:t,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;l=p,u=x}let f=l.shape.length;C.assertAxesAreInnerMostDims("max",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,a.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;UH(u,Qe[a.dtype],b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var KH={kernelName:Eo,backendName:"wasm",setupFunc:Yhe,kernelFunc:Zhe};var Qhe=!1,VH=ht(Fo,Qhe);var HH;function Jhe(r){HH=r.wasm.cwrap(Lo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ege(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id;y.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=t,p=C.computePool2DInfo(o.shape,a,i,1,u,l),m=p.filterHeight,c=p.filterWidth,d=p.padInfo.top,f=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,b=p.dilationHeight,T=p.dilationWidth,x=p.strideHeight,I=p.strideWidth,k=p.inChannels,w=p.outChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let _=n.makeOutput(p.outShape,"float32"),M=n.dataIdMap.get(_.dataId).id;return HH(s,o.shape[0],o.shape[1],o.shape[2],m,c,d,f,h,g,b,T,x,I,k,w,M),_}var qH={kernelName:Lo,backendName:"wasm",setupFunc:Jhe,kernelFunc:ege};var jH;function tge(r){jH=r.wasm.cwrap($o,null,["number, number, number"])}function rge(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e),f=m;if(d){let I=e.dataIdMap.get(p.dataId).id;I!==i&&(l=p,u=I,f=C.getInnerMostAxes(f.length,l.shape.length))}C.assertAxesAreInnerMostDims("mean",f,l.shape.length);let[h,g]=C.computeOutAndReduceShapes(l.shape,f),b=y.sizeFromShape(g),T=l;l.dtype!=="float32"&&(T=Ii({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),u=e.dataIdMap.get(T.dataId).id);let x=e.makeOutput(h,"float32");if(y.sizeFromShape(l.shape)!==0){let I=e.dataIdMap.get(x.dataId).id;jH(u,b,I)}if(d&&e.disposeData(p.dataId),s){let I=C.expandShapeToKeepDim(x.shape,c);x.shape=I}return l.dtype!=="float32"&&e.disposeData(T.dataId),x}var XH={kernelName:$o,backendName:"wasm",setupFunc:tge,kernelFunc:rge};var YH;function nge(r){YH=r.wasm.cwrap(Bo,null,["number","number","number","number"])}function oge(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;x!==i&&(l=p,u=x)}let f=l.shape.length;C.assertAxesAreInnerMostDims("min",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;YH(u,Qe[a.dtype],b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var ZH={kernelName:Bo,backendName:"wasm",setupFunc:nge,kernelFunc:oge};var sge=!1,QH=ht(Oo,sge);var JH=(t=>(t[t.reflect=0]="reflect",t[t.symmetric=1]="symmetric",t))(JH||{}),eq;function age(r){eq=r.wasm.cwrap(zo,null,["number","array","number","number","array","array","number","number"])}function ige(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,mode:o}}=r,s=n.map((f,h)=>f[0]+e.shape[h]+f[1]),a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),u=t.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),p=n.map(f=>f[0]),m=n.map(f=>f[1]),c=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(m).buffer);return eq(a,l,e.shape.length,Qe[e.dtype],c,d,JH[o],u),i}var tq={kernelName:zo,backendName:"wasm",kernelFunc:ige,setupFunc:age};var uge=!0,rq=ht(Go,uge);var nq=st(Ss);function Xf(r,e){let t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),n=t[0],o=t[1],s=t[2],a=t[3];return r.wasm._free(e),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:a}}var oq;function lge(r){oq=r.wasm.cwrap(Ua,"number",["number","number","number","number","number"])}function pge(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a}=n,{boxes:i,scores:u}=t,l=e.dataIdMap.get(i.dataId).id,p=e.dataIdMap.get(u.dataId).id,m=oq(l,p,s,o,a),{pSelectedIndices:c,selectedSize:d,pSelectedScores:f,pValidOutputs:h}=Xf(e,m);return e.wasm._free(f),e.wasm._free(h),e.makeOutput([d],"int32",c)}var sq={kernelName:Ua,backendName:"wasm",setupFunc:lge,kernelFunc:pge};var aq;function mge(r){aq=r.wasm.cwrap(eu,"number",["number","number","number","number","number","bool"])}function cge(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,padToMaxOutputSize:i}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,m=e.dataIdMap.get(l.dataId).id,c=aq(p,m,s,o,a,i),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Xf(e,c);e.wasm._free(h);let b=e.makeOutput([f],"int32",d),T=e.makeOutput([],"int32",g);return[b,T]}var iq={kernelName:eu,backendName:"wasm",setupFunc:mge,kernelFunc:cge};var uq;function dge(r){uq=r.wasm.cwrap(Ka,"number",["number","number","number","number","number","number"])}function fge(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,softNmsSigma:i}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,m=e.dataIdMap.get(l.dataId).id,c=uq(p,m,s,o,a,i),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Xf(e,c);e.wasm._free(g);let b=e.makeOutput([f],"int32",d),T=e.makeOutput([f],"float32",h);return[b,T]}var lq={kernelName:Ka,backendName:"wasm",setupFunc:dge,kernelFunc:fge};var hge=!1,pq=ht(Wa,hge,"bool");var mq;function gge(r){mq=r.wasm.cwrap(Wo,null,["number","number","number","number","number"])}function bge(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n,l=t.makeOutput([...o.shape,a],s),p=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(o.dataId).id;return mq(c,a,i,u,p),l}var cq={kernelName:Wo,backendName:"wasm",setupFunc:gge,kernelFunc:bge};function yge(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(1),n}var dq={kernelName:vs,backendName:"wasm",kernelFunc:yge};function Tge(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return Ak({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=Ak({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=g0({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeData(p.dataId)),l}var fq={kernelName:As,backendName:"wasm",kernelFunc:Tge};var hq;function xge(r){hq=r.wasm.cwrap(Uo,null,["number","array","number","number","array","array","number","number"])}function Ige(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+e.shape[g]+h[1]);if(y.sizeFromShape(e.shape)===0)return b0({backend:t,attrs:{shape:s,value:o,dtype:e.dtype}});let a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),l=t.dataIdMap.get(i.dataId).id,p=new Uint8Array(new Int32Array(e.shape).buffer),m=n.map(h=>h[0]),c=n.map(h=>h[1]),d=new Uint8Array(new Int32Array(m).buffer),f=new Uint8Array(new Int32Array(c).buffer);return hq(a,p,e.shape.length,Qe[e.dtype],d,f,o,l),i}var wk={kernelName:Uo,backendName:"wasm",kernelFunc:Ige,setupFunc:xge};var Cge=!1,gq=ht(Ko,Cge);var bq;function kge(r){bq=r.wasm.cwrap(Vo,null,["number","number","number"])}function Sge(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,i=s,u=n,l=u;u.dtype!=="float32"&&(l=Ii({backend:t,inputs:{x:n},attrs:{dtype:"float32"}}),i=t.dataIdMap.get(l.dataId).id);let p=t.makeOutput(n.shape,"float32"),m=t.dataIdMap.get(p.dataId).id;return bq(i,a,m),u.dtype!=="float32"&&t.disposeData(l.dataId),p}var yq={kernelName:Vo,backendName:"wasm",setupFunc:kge,kernelFunc:Sge};var Tq;function vge(r){Tq=r.wasm.cwrap(Ho,null,["number","number","number","number"])}function Age(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e),f=m;if(d){let x=e.dataIdMap.get(p.dataId).id;x!==i&&(l=p,u=x,f=C.getInnerMostAxes(f.length,l.shape.length))}C.assertAxesAreInnerMostDims("prod",f,l.shape.length);let[h,g]=C.computeOutAndReduceShapes(l.shape,f),b=y.sizeFromShape(g),T=e.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;Tq(u,b,Qe[T.dtype],x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var xq={kernelName:Ho,backendName:"wasm",setupFunc:vge,kernelFunc:Age};var wge=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=Gp(n,o,s,a),u=e.makeOutput([i.length],a);return e.typedArrayFromHeap(u).set(i),u},Iq={kernelName:Ai,backendName:"wasm",kernelFunc:wge};var Nge=!0,Cq=ht(So,Nge);var kq=st(qo);var Sq=st(jo);var vq=st(Zo);var Aq;function Dge(r){Aq=r.wasm.cwrap(Yo,null,["number","number","number","number","number","number","number","number","number","number"])}function _ge(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,[p,m,c,d]=o.shape,f=[p,u,l,d],h=e.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=Ii({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(g.dataId));let b=h.id,T=e.makeOutput(f,"float32");if(y.sizeFromShape(o.shape)===0)return T;let x=e.dataIdMap.get(T.dataId).id;return Aq(b,p,m,c,d,u,l,s?1:0,a?1:0,x),g!=null&&e.disposeData(g.dataId),T}var wq={kernelName:Yo,backendName:"wasm",setupFunc:Dge,kernelFunc:_ge};var Nq;function Mge(r){Nq=r.wasm.cwrap(Xo,null,["number","number","number","number","number","number","number","number","number","number"])}function Rge(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,[p,m,c,d]=o.shape,f=[p,u,l,d],h=e.makeOutput(f,"float32");if(y.sizeFromShape(o.shape)===0)return h;let g=e.dataIdMap.get(o.dataId),b;g.dtype!=="float32"&&(b=Ii({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),g=e.dataIdMap.get(b.dataId));let T=g.id,x=e.dataIdMap.get(h.dataId).id;return Nq(T,p,m,c,d,u,l,s?1:0,a?1:0,x),b!=null&&e.disposeData(b.dataId),h}var Dq={kernelName:Xo,backendName:"wasm",setupFunc:Mge,kernelFunc:Rge};var _q;function Pge(r){_q=r.wasm.cwrap(Qo,null,["number","array","number","array","number","number"])}function Ege(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=y.parseAxisParam(s,o.shape);if(o.shape.length===0)return pm({inputs:{x:o},backend:t});let i=t.makeOutput(o.shape,o.dtype),u=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(i.dataId).id,p=new Uint8Array(new Int32Array(a).buffer),m=new Uint8Array(new Int32Array(o.shape).buffer);_q(u,p,a.length,m,o.shape.length,l);let c=hr({inputs:{x:i},attrs:{shape:o.shape},backend:t});return t.disposeData(i.dataId),c}var Mq={kernelName:Qo,backendName:"wasm",kernelFunc:Ege,setupFunc:Pge};var Rq;function Fge(r){Rq=r.wasm.cwrap(Za,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Lge(r){let{inputs:e,backend:t,attrs:n}=r,{image:o}=e,{radians:s,fillValue:a,center:i}=n,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(u.dataId).id,[m,c,d,f]=o.shape,[h,g]=C.getImageCenter(i,c,d),b=a===0,T=255,x=typeof a=="number"?[a,a,a,b?0:T]:[...a,T],I=new Uint8Array(new Int32Array(x).buffer);return Rq(l,m,c,d,f,s,h,g,I,x.length,p),u}var Pq={kernelName:Za,backendName:"wasm",kernelFunc:Lge,setupFunc:Fge};var Eq=st(Va);var Fq=st(Jo);var Lq;function $ge(r){Lq=r.wasm.cwrap(Ha,null,["number","number","number","number","number","number","array","number","number"])}function Bge(r){let{backend:e,inputs:t,attrs:n}=r,{indices:o,updates:s}=t,{shape:a}=n,i=e.makeOutput(a,s.dtype);if(y.sizeFromShape(a)===0)return i;let{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=Ch.calculateShapes(s,o,a),f=e.dataIdMap.get(o.dataId).id,g=e.dataIdMap.get(s.dataId).id,b=new Uint8Array(new Int32Array(m).buffer),T=e.dataIdMap.get(i.dataId).id;return Lq(f,g,Qe[s.dtype],u,l,p,b,c,T),i}var $q={kernelName:Ha,backendName:"wasm",setupFunc:$ge,kernelFunc:Bge};var Bq;function Oge(r){Bq=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function zge(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=t.makeOutput(o.shape,o.dtype),p=t.dataIdMap.get(l.dataId).id,m=n.shape.length,c=o.shape.length,d=m===0||m>1||c===1?1:y.sizeFromShape(o.shape.slice(1));return Bq(a,i,u,d,p),l}var Oq={kernelName:Ns,backendName:"wasm",kernelFunc:zge,setupFunc:Oge};var zq;function Gge(r){zq=r.wasm.cwrap(ts,null,["number","number"])}function Wge(r){let{backend:e,inputs:{x:t}}=r,n=e.dataIdMap.get(t.dataId).id,o=e.makeOutput(t.shape,t.dtype),s=e.dataIdMap.get(o.dataId).id;return y.sizeFromShape(o.shape)===0||zq(n,s),o}var Gq={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Gge,kernelFunc:Wge};var Wq=st(es);var Uq;function Uge(r){Uq=r.wasm.cwrap(os,null,["number","number","number","number"])}function Kge(r){let{backend:e,inputs:{logits:t},attrs:{dim:n}}=r,o=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),a=e.dataIdMap.get(s.dataId).id,i=t.shape[n],u=y.sizeFromShape(t.shape)/i;return y.sizeFromShape(s.shape)===0||Uq(o,a,i,u),s}var Kq={kernelName:os,backendName:"wasm",setupFunc:Uge,kernelFunc:Kge};function Vge(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n,i=y.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let w=1+s.length;w<o.shape.length;++w)u.push([0,0]);let l=wk.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=C.getReshaped(l.shape,s,i,!1),m=C.getPermuted(p.length,s.length,!1),c=C.getReshapedPermuted(l.shape,s,i,!1),h=hr({inputs:{x:l},backend:t,attrs:{shape:p}}),T=ys({inputs:{x:h},backend:t,attrs:{perm:m}}),k=hr({inputs:{x:T},backend:t,attrs:{shape:c}});return t.disposeData(l.dataId),t.disposeData(h.dataId),t.disposeData(T.dataId),k}var Vq={kernelName:_s,backendName:"wasm",kernelFunc:Vge};var Hq;function Hge(r){Hq=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function qge(r){let{backend:e,inputs:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=t,i=n.shape[0],u=n.shape[1],l=e.readSync(s.dataId)[0],p=[i+l,u],m=e.dataIdMap.get(n.dataId).id,c=e.dataIdMap.get(o.dataId).id,d=e.dataIdMap.get(a.dataId).id,f=e.makeOutput(p,n.dtype),h=e.dataIdMap.get(f.dataId).id,g=e.makeOutput(p.slice(0,1),o.dtype),b=e.dataIdMap.get(g.dataId).id,T=e.makeOutput([l],"bool"),x=e.dataIdMap.get(T.dataId).id,I=e.makeOutput([i],n.dtype),k=e.dataIdMap.get(I.dataId).id,w=e.makeOutput([4],"int32"),_=e.dataIdMap.get(w.dataId).id,M=Hq(m,c,Qe[o.dtype],i,l,u,d,h,b,x,k,_),R=e.readSync(w.dataId),E;switch(R[0]){case 1:{E=C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(R[1]);break}case 2:{E=C.getSparseFillEmptyRowsNegativeIndexErrorMessage(R[1],R[2]);break}case 3:E=C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(R[1],R[2],R[3]);break;default:E=""}if(e.disposeData(w.dataId),E)throw e.disposeData(f.dataId),e.disposeData(g.dataId),e.disposeData(T.dataId),e.disposeData(I.dataId),new Error(E);let O=f,G=g;return M!==p[0]&&(O=ca({inputs:{x:f},attrs:{begin:0,size:[M,u]},backend:e}),G=ca({inputs:{x:g},attrs:{begin:0,size:M},backend:e}),e.disposeData(f.dataId),e.disposeData(g.dataId)),[O,G,T,I]}var qq={kernelName:Yu,backendName:"wasm",setupFunc:Hge,kernelFunc:qge};var jq;function jge(r){jq=r.wasm.cwrap(ou,null,["number","number","number","number","number","number","number"])}function Xge(r){let{backend:e,inputs:t}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=n.shape[0],p=y.sizeFromShape(s.shape),m=e.makeOutput([l,p],n.dtype),c=e.dataIdMap.get(m.dataId).id,d=e.makeOutput([p],s.dtype),f=e.dataIdMap.get(d.dataId).id,h=e.makeOutput([3],"int32"),g=e.dataIdMap.get(h.dataId).id;jq(a,i,u,l,c,f,g);let b=e.readSync(h.dataId),T;switch(b[0]){case 0:{T=C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{T=C.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:T=C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(e.readSync(o.dataId)),I=Array.from(e.readSync(d.dataId));T=C.getSparseReshapeInputOutputMultipleErrorMessage(x,I);break}case 4:{let x=Array.from(e.readSync(o.dataId)),I=Array.from(e.readSync(d.dataId));T=C.getSparseReshapeInputOutputMismatchErrorMessage(x,I);break}default:T=""}if(e.disposeData(h.dataId),T)throw e.disposeData(m.dataId),e.disposeData(d.dataId),new Error(T);return[m,d]}var Xq={kernelName:ou,backendName:"wasm",setupFunc:jge,kernelFunc:Xge};var Yq;function Nk(r){Yq=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Dk(r,e){let{backend:t,inputs:n}=r,{data:o,indices:s,segmentIds:a}=n,i=s.shape[0],u=t.readSync(a.dataId,i-1,i)[0],p=i>0?u+1:0;if(p<0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=o.shape.slice();m[0]=p;let c=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(a.dataId).id,h=t.makeOutput(m,o.dtype),g=t.dataIdMap.get(h.dataId).id,b=t.makeOutput([4],"int32"),T=t.dataIdMap.get(b.dataId).id;Yq(c,Qe[o.dtype],o.shape[0],d,f,g,T,e,0);let x=t.readSync(b.dataId),I;switch(x[0]){case 0:{I=C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{I=C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:I=C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1],x[2]);break;case 3:I=C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1],x[2],x[3]);break;default:I=""}if(t.disposeData(b.dataId),I)throw t.disposeData(h.dataId),new Error(I);return h}function Yge(r){return Dk(r,!0)}var Zq={kernelName:Zu,backendName:"wasm",setupFunc:Nk,kernelFunc:Yge};function Zge(r){return Dk(r,!1)}var Qq={kernelName:Qu,backendName:"wasm",setupFunc:Nk,kernelFunc:Zge};function Qge(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=t,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(m=>{let c=[...p];c[i]=m;let d=ca({inputs:{x:o},attrs:{begin:l,size:c},backend:n});return l[i]+=m,d})}var Jq={kernelName:Ms,backendName:"wasm",kernelFunc:Qge};var ej=st(rs);var tj=st(wi);var Jge=!0,rj=ht(ss,Jge);var nj;function ebe(r){nj=r.wasm.cwrap(Es,null,["number","number","number","number"])}function tbe(r){let{backend:e,inputs:t,attrs:n}=r,{alpha:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=e.makeOutput(s.shape,s.dtype),u=e.dataIdMap.get(i.dataId).id;return nj(a,o,Qe[s.dtype],u),i}var oj={kernelName:Es,backendName:"wasm",setupFunc:ebe,kernelFunc:tbe};var sj;function rbe(r){sj=r.wasm.cwrap(ja,null,["number","array","number","array","array","array","array","array","number","number"])}function nbe(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),k;if(h)k=hr({inputs:{x:o},backend:e,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),_=ca({inputs:{x:o},backend:e,attrs:{begin:T,size:w}});k=hr({inputs:{x:_},backend:e,attrs:{shape:f}}),e.disposeData(_.dataId)}else{let w=e.makeOutput(d,"float32"),_=e.dataIdMap.get(o.dataId).id,M=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),R=new Uint8Array(new Int32Array(T).buffer),E=new Uint8Array(new Int32Array(x).buffer),O=new Uint8Array(new Int32Array(I).buffer),G=new Uint8Array(new Int32Array(d).buffer),W=new Uint8Array(new Int32Array(y.computeStrides(d)).buffer),H=e.dataIdMap.get(w.dataId).id;sj(_,M,o.shape.length,R,E,O,G,W,d.length,H),k=hr({inputs:{x:w},backend:e,attrs:{shape:f}}),e.disposeData(w.dataId)}return k}var aj={kernelName:ja,backendName:"wasm",setupFunc:rbe,kernelFunc:nbe};function obe(r){let{backend:e,inputs:t,attrs:n}=r,{data:o,dataSplits:s}=t,{separator:a,nGramWidths:i,leftPad:u,rightPad:l,padWidth:p,preserveShortSequences:m}=n,c=e.readSync(o.dataId),d=e.readSync(s.dataId),[f,h]=Up(c,d,a,i,u,l,p,m),g=e.makeOutput([f.length],"string"),b=e.dataIdMap.get(g.dataId);b.stringBytes=f;let T=e.makeOutput(s.shape,"int32");return e.typedArrayFromHeap(T).set(h),[g,T]}var ij={kernelName:Ni,backendName:"wasm",kernelFunc:obe};function sbe(r){let{backend:e,inputs:t,attrs:n}=r,{input:o,delimiter:s}=t,{skipEmpty:a}=n,i=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,p,m]=Kp(i,u[0],a),c=p.length,d=e.makeOutput([c,2],"int32");e.typedArrayFromHeap(d).set(l);let h=e.makeOutput([c],"string"),g=e.dataIdMap.get(h.dataId);g.stringBytes=p;let b=e.makeOutput([2],"int32");return e.typedArrayFromHeap(b).set(m),[d,h,b]}var uj={kernelName:el,backendName:"wasm",kernelFunc:sbe};function abe(r){let{backend:e,inputs:t,attrs:n}=r,{input:o}=t,{numBuckets:s}=n,a=e.readSync(o.dataId),i=Vp(a,s),u=e.makeOutput(o.shape,"int32");return e.typedArrayFromHeap(u).set(i),u}var lj={kernelName:tl,backendName:"wasm",kernelFunc:abe};var ibe=!0,pj=ht(as,ibe);var mj;function ube(r){mj=r.wasm.cwrap(ns,null,["number","number","number","number"])}function lbe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e),f=m;if(d){let x=e.dataIdMap.get(p.dataId).id;x!==i&&(l=p,u=x,f=C.getInnerMostAxes(f.length,l.shape.length))}C.assertAxesAreInnerMostDims("sum",f,l.shape.length);let[h,g]=C.computeOutAndReduceShapes(l.shape,f),b=y.sizeFromShape(g),T=e.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;mj(u,b,Qe[T.dtype],x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var cj={kernelName:ns,backendName:"wasm",setupFunc:ube,kernelFunc:lbe};var dj=st(is);var fj=st(us);var hj;function pbe(r){hj=r.wasm.cwrap(Dn,null,["number","array","number","array","number","number"])}function mbe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,s=t.dataIdMap.get(o.dataId).id,{reps:a}=n,i=new Array(o.shape.length);for(let c=0;c<i.length;c++)i[c]=o.shape[c]*a[c];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(i).buffer),p=t.makeOutput(i,o.dtype),m=t.dataIdMap.get(p.dataId).id;return hj(s,u,o.shape.length,l,i.length,Qe[p.dtype],m),p}var gj={kernelName:Dn,backendName:"wasm",setupFunc:pbe,kernelFunc:mbe};var bj;function cbe(r){bj=r.wasm.cwrap(Xa,null,["number","array","number","number","number","bool","number","number"])}var dbe=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{k:o,sorted:s}=t,a=e.dataIdMap.get(n.dataId).id,i=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=e.makeOutput(u,n.dtype),p=e.dataIdMap.get(l.dataId).id,m=e.makeOutput(u,"int32"),c=e.dataIdMap.get(m.dataId).id;return bj(a,i,n.shape.length,Qe[n.dtype],o,s,p,c),[l,m]},yj={kernelName:Xa,backendName:"wasm",setupFunc:cbe,kernelFunc:dbe};var Tj;function fbe(r){Tj=r.wasm.cwrap(Ya,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function hbe(r){let{backend:e,inputs:t,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),T=new Uint8Array(new Int32Array(y.computeStrides(g)).buffer),x=e.makeOutput(g,o.dtype),I=e.dataIdMap.get(x.dataId).id,w=e.dataIdMap.get(o.dataId).id,M=e.dataIdMap.get(s.dataId).id,R=a==="nearest"?1:2,E;switch(i){case"constant":E=1;break;case"reflect":E=2;break;case"wrap":E=3;break;case"nearest":E=4;break;default:E=1;break}return Tj(w,M,s.shape[0]>1,p,f,h,d,c,m,b,o.shape.length-1,T,g.length-1,R,E,u,I),x}var xj={kernelName:Ya,backendName:"wasm",setupFunc:fbe,kernelFunc:hbe};function gbe(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape[s],i=o.shape.length,u=new Array(i-1),l=0;for(let d=0;d<i;d++)d!==s&&(u[l++]=o.shape[d]);let p=new Array(a),m=new Array(i).fill(0),c=o.shape.slice();c[s]=1;for(let d=0;d<p.length;d++)m[s]=d,p[d]=ca({inputs:{x:o},attrs:{begin:m,size:c},backend:t});return p.map(({dataId:d,dtype:f})=>({dataId:d,dtype:f,shape:u}))}var Ij={kernelName:Rs,backendName:"wasm",kernelFunc:gbe};function bbe(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(0),n}var Cj={kernelName:Ps,backendName:"wasm",kernelFunc:bbe};var ybe=[k4,S4,v4,w4,R4,E4,L4,B4,G4,U4,K4,V4,q4,j4,Y4,Q4,J4,eH,nH,sH,iH,lH,mH,cH,dH,fH,hH,gH,yH,TH,xH,CH,SH,AH,NH,_H,MH,RH,N4,PH,FH,LH,$H,BH,OH,zH,GH,WH,KH,VH,qH,XH,ZH,QH,tq,rq,nq,sq,iq,lq,pq,cq,dq,fq,wk,gq,yq,xq,Iq,Cq,kq,Sq,vq,O4,wq,Dq,Mq,Pq,Eq,Fq,$q,Oq,Gq,Wq,W4,Kq,Vq,qq,Xq,Zq,Qq,Jq,ej,tj,rj,oj,aj,ij,uj,lj,pj,cj,dj,fj,gj,yj,xj,_4,Ij,Cj];for(let r of ybe)su(r);var y0=$();y0.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});y0.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(y0.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var S0=Wl(Aj());var wj=`var WasmBackendModuleThreadedSimd = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(WasmBackendModuleThreadedSimd) {
  WasmBackendModuleThreadedSimd = WasmBackendModuleThreadedSimd || {};

function GROWABLE_HEAP_I8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP8}function GROWABLE_HEAP_U8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU8}function GROWABLE_HEAP_I16(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP16}function GROWABLE_HEAP_I32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP32}function GROWABLE_HEAP_U32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU32}function GROWABLE_HEAP_F32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF32}function GROWABLE_HEAP_F64(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF64}var Module=typeof WasmBackendModuleThreadedSimd!="undefined"?WasmBackendModuleThreadedSimd:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var beforeListeners;if(typeof process!=="undefined"&&process.listeners){beforeListeners={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")}}var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var ENVIRONMENT_IS_PTHREAD=Module["ENVIRONMENT_IS_PTHREAD"]||false;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err("exiting due to exception: "+toLog)}if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require("path").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}var fs,nodePath;if(typeof require==="function"){fs=require("fs");nodePath=require("path")}read_=(filename,binary)=>{filename=nodePath["normalize"](filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror)=>{filename=nodePath["normalize"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer)})};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",function(reason){throw reason});quit_=(status,toThrow)=>{if(keepRuntimeAlive()){process["exitCode"]=status;throw toThrow}logExceptionOnExit(toThrow);process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"};let nodeWorkerThreads;try{nodeWorkerThreads=require("worker_threads")}catch(e){console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');throw e}global.Worker=nodeWorkerThreads.Worker}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}if(!ENVIRONMENT_IS_NODE){read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}if(ENVIRONMENT_IS_NODE){if(typeof performance=="undefined"){global.performance=require("perf_hooks").performance}}var defaultPrint=console.log.bind(console);var defaultPrintErr=console.warn.bind(console);if(ENVIRONMENT_IS_NODE){defaultPrint=str=>fs.writeSync(1,str+"
");defaultPrintErr=str=>fs.writeSync(2,str+"
")}var out=Module["print"]||defaultPrint;var err=Module["printErr"]||defaultPrintErr;Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var POINTER_SIZE=4;var Atomics_load=Atomics.load;var Atomics_store=Atomics.store;var Atomics_compareExchange=Atomics.compareExchange;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var wasmModule;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort(text)}}var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.buffer instanceof SharedArrayBuffer?heapOrArray.slice(idx,endPtr):heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite)}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;if(ENVIRONMENT_IS_PTHREAD){buffer=Module["buffer"]}function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;if(ENVIRONMENT_IS_PTHREAD){wasmMemory=Module["wasmMemory"];buffer=Module["buffer"]}else{if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"]}else{wasmMemory=new WebAssembly.Memory({"initial":INITIAL_MEMORY/65536,"maximum":2147483648/65536,"shared":true});if(!(wasmMemory.buffer instanceof SharedArrayBuffer)){err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");if(ENVIRONMENT_IS_NODE){console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)")}throw Error("bad memory")}}}if(wasmMemory){buffer=wasmMemory.buffer}INITIAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(ENVIRONMENT_IS_PTHREAD)return;callRuntimeCallbacks(__ATINIT__)}function postRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(ENVIRONMENT_IS_PTHREAD){postMessage({"cmd":"onAbort","arg":what})}else{if(Module["onAbort"]){Module["onAbort"](what)}}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="tfjs-backend-wasm-threaded-simd.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"env":asmLibraryArg,"wasi_snapshot_preview1":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;registerTLSInit(Module["asm"]["_emscripten_tls_init"]);wasmTable=Module["asm"]["__indirect_function_table"];addOnInit(Module["asm"]["__wasm_call_ctors"]);wasmModule=module;if(!ENVIRONMENT_IS_PTHREAD){var numWorkersToLoad=PThread.unusedWorkers.length;PThread.unusedWorkers.forEach(function(w){PThread.loadWasmModuleToWorker(w,function(){if(!--numWorkersToLoad)removeRunDependency("wasm-instantiate")})})}}if(!ENVIRONMENT_IS_PTHREAD){addRunDependency("wasm-instantiate")}function receiveInstantiationResult(result){receiveInstance(result["instance"],result["module"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);readyPromiseReject(e)}}instantiateAsync().catch(readyPromiseReject);return{}}var tempDouble;var tempI64;var ASM_CONSTS={};function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}function killThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];delete PThread.pthreads[pthread_ptr];worker.terminate();__emscripten_thread_free_data(pthread_ptr);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0}function cancelThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];worker.postMessage({"cmd":"cancel"})}function cleanupThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];assert(worker);PThread.returnWorkerToPool(worker)}function spawnThread(threadParams){var worker=PThread.getNewWorker();if(!worker){return 6}PThread.runningWorkers.push(worker);PThread.pthreads[threadParams.pthread_ptr]=worker;worker.pthread_ptr=threadParams.pthread_ptr;var msg={"cmd":"run","start_routine":threadParams.startRoutine,"arg":threadParams.arg,"pthread_ptr":threadParams.pthread_ptr};worker.runPthread=()=>{msg.time=performance.now();worker.postMessage(msg,threadParams.transferList)};if(worker.loaded){worker.runPthread();delete worker.runPthread}return 0}var SYSCALLS={varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=GROWABLE_HEAP_I32()[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret}};function _proc_exit(code){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(1,1,code);EXITSTATUS=code;if(!keepRuntimeAlive()){PThread.terminateAllThreads();if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))}function exitJS(status,implicit){EXITSTATUS=status;if(!implicit){if(ENVIRONMENT_IS_PTHREAD){exitOnMainThread(status);throw"unwind"}else{}}_proc_exit(status)}var _exit=exitJS;function handleException(e){if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)}var PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){if(ENVIRONMENT_IS_PTHREAD){PThread.initWorker()}else{PThread.initMainThread()}},initMainThread:function(){var pthreadPoolSize=8;while(pthreadPoolSize--){PThread.allocateUnusedWorker()}},initWorker:function(){noExitRuntime=false},setExitStatus:function(status){EXITSTATUS=status},terminateAllThreads:function(){for(var worker of Object.values(PThread.pthreads)){PThread.returnWorkerToPool(worker)}for(var worker of PThread.unusedWorkers){worker.terminate()}PThread.unusedWorkers=[]},returnWorkerToPool:function(worker){var pthread_ptr=worker.pthread_ptr;delete PThread.pthreads[pthread_ptr];PThread.unusedWorkers.push(worker);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0;__emscripten_thread_free_data(pthread_ptr)},receiveObjectTransfer:function(data){},threadInitTLS:function(){PThread.tlsInitFunctions.forEach(f=>f())},loadWasmModuleToWorker:function(worker,onFinishedLoading){worker.onmessage=e=>{var d=e["data"];var cmd=d["cmd"];if(worker.pthread_ptr)PThread.currentProxiedOperationCallerThread=worker.pthread_ptr;if(d["targetThread"]&&d["targetThread"]!=_pthread_self()){var targetWorker=PThread.pthreads[d.targetThread];if(targetWorker){targetWorker.postMessage(d,d["transferList"])}else{err('Internal error! Worker sent a message "'+cmd+'" to target pthread '+d["targetThread"]+", but that thread no longer exists!")}PThread.currentProxiedOperationCallerThread=undefined;return}if(cmd==="processProxyingQueue"){executeNotifiedProxyingQueue(d["queue"])}else if(cmd==="spawnThread"){spawnThread(d)}else if(cmd==="cleanupThread"){cleanupThread(d["thread"])}else if(cmd==="killThread"){killThread(d["thread"])}else if(cmd==="cancelThread"){cancelThread(d["thread"])}else if(cmd==="loaded"){worker.loaded=true;if(onFinishedLoading)onFinishedLoading(worker);if(worker.runPthread){worker.runPthread();delete worker.runPthread}}else if(cmd==="print"){out("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="printErr"){err("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="alert"){alert("Thread "+d["threadId"]+": "+d["text"])}else if(d.target==="setimmediate"){worker.postMessage(d)}else if(cmd==="onAbort"){if(Module["onAbort"]){Module["onAbort"](d["arg"])}}else if(cmd){err("worker sent an unknown command "+cmd)}PThread.currentProxiedOperationCallerThread=undefined};worker.onerror=e=>{var message="worker sent an error!";err(message+" "+e.filename+":"+e.lineno+": "+e.message);throw e};if(ENVIRONMENT_IS_NODE){worker.on("message",function(data){worker.onmessage({data:data})});worker.on("error",function(e){worker.onerror(e)});worker.on("detachedExit",function(){})}worker.postMessage({"cmd":"load","urlOrBlob":Module["mainScriptUrlOrBlob"]||_scriptDir,"wasmMemory":wasmMemory,"wasmModule":wasmModule})},allocateUnusedWorker:function(){var pthreadMainJs=locateFile("tfjs-backend-wasm-threaded-simd.worker.js");PThread.unusedWorkers.push(new Worker(pthreadMainJs))},getNewWorker:function(){if(PThread.unusedWorkers.length==0){PThread.allocateUnusedWorker();PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])}return PThread.unusedWorkers.pop()}};Module["PThread"]=PThread;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){callbacks.shift()(Module)}}function withStackSave(f){var stack=stackSave();var ret=f();stackRestore(stack);return ret}function demangle(func){return func}function demangleAll(text){var regex=/\b_Z[wd_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function establishStackSpace(){var pthread_ptr=_pthread_self();var stackTop=GROWABLE_HEAP_I32()[pthread_ptr+44>>2];var stackSize=GROWABLE_HEAP_I32()[pthread_ptr+48>>2];var stackMax=stackTop-stackSize;_emscripten_stack_set_limits(stackTop,stackMax);stackRestore(stackTop)}Module["establishStackSpace"]=establishStackSpace;function exitOnMainThread(returnCode){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(2,0,returnCode);try{_exit(returnCode)}catch(e){handleException(e)}}var wasmTableMirror=[];function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func}function invokeEntryPoint(ptr,arg){var result=getWasmTableEntry(ptr)(arg);if(keepRuntimeAlive()){PThread.setExitStatus(result)}else{__emscripten_thread_exit(result)}}Module["invokeEntryPoint"]=invokeEntryPoint;function jsStackTrace(){var error=new Error;if(!error.stack){try{throw new Error}catch(e){error=e}if(!error.stack){return"(no stack trace available)"}}return error.stack.toString()}function registerTLSInit(tlsInitFunc){PThread.tlsInitFunctions.push(tlsInitFunc)}function writeArrayToMemory(array,buffer){GROWABLE_HEAP_I8().set(array,buffer)}function ___emscripten_init_main_thread_js(tb){__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1,!ENVIRONMENT_IS_WEB);PThread.threadInitTLS()}function ___emscripten_thread_cleanup(thread){if(!ENVIRONMENT_IS_PTHREAD)cleanupThread(thread);else postMessage({"cmd":"cleanupThread","thread":thread})}function pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(3,1,pthread_ptr,attr,startRoutine,arg);return ___pthread_create_js(pthread_ptr,attr,startRoutine,arg)}function ___pthread_create_js(pthread_ptr,attr,startRoutine,arg){if(typeof SharedArrayBuffer=="undefined"){err("Current environment does not support SharedArrayBuffer, pthreads are not available!");return 6}var transferList=[];var error=0;if(ENVIRONMENT_IS_PTHREAD&&(transferList.length===0||error)){return pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg)}if(error)return error;var threadParams={startRoutine:startRoutine,pthread_ptr:pthread_ptr,arg:arg,transferList:transferList};if(ENVIRONMENT_IS_PTHREAD){threadParams.cmd="spawnThread";postMessage(threadParams,transferList);return 0}return spawnThread(threadParams)}function __emscripten_default_pthread_stack_size(){return 2097152}var nowIsMonotonic=true;function __emscripten_get_now_is_monotonic(){return nowIsMonotonic}function executeNotifiedProxyingQueue(queue){Atomics.store(GROWABLE_HEAP_I32(),queue>>2,1);if(_pthread_self()){__emscripten_proxy_execute_task_queue(queue)}Atomics.compareExchange(GROWABLE_HEAP_I32(),queue>>2,1,0)}Module["executeNotifiedProxyingQueue"]=executeNotifiedProxyingQueue;function __emscripten_notify_task_queue(targetThreadId,currThreadId,mainThreadId,queue){if(targetThreadId==currThreadId){setTimeout(()=>executeNotifiedProxyingQueue(queue))}else if(ENVIRONMENT_IS_PTHREAD){postMessage({"targetThread":targetThreadId,"cmd":"processProxyingQueue","queue":queue})}else{var worker=PThread.pthreads[targetThreadId];if(!worker){return}worker.postMessage({"cmd":"processProxyingQueue","queue":queue})}return 1}function __emscripten_set_offscreencanvas_size(target,width,height){return-1}function _abort(){abort("")}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;if(ENVIRONMENT_IS_NODE)text="warning: "+text;err(text)}}function _emscripten_check_blocking_allowed(){if(ENVIRONMENT_IS_NODE)return;if(ENVIRONMENT_IS_WORKER)return;warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function _emscripten_date_now(){return Date.now()}function getHeapMax(){return 2147483648}function _emscripten_get_heap_max(){return getHeapMax()}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=()=>{var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(ENVIRONMENT_IS_PTHREAD){_emscripten_get_now=()=>performance.now()-Module["__performance_now_clock_drift"]}else _emscripten_get_now=()=>performance.now();function _emscripten_memcpy_big(dest,src,num){GROWABLE_HEAP_U8().copyWithin(dest,src,src+num)}function _emscripten_num_logical_cores(){if(ENVIRONMENT_IS_NODE)return require("os").cpus().length;return navigator["hardwareConcurrency"]}function _emscripten_proxy_to_main_thread_js(index,sync){var numCallArgs=arguments.length-2;var outerArgs=arguments;return withStackSave(()=>{var serializedNumCallArgs=numCallArgs;var args=stackAlloc(serializedNumCallArgs*8);var b=args>>3;for(var i=0;i<numCallArgs;i++){var arg=outerArgs[2+i];GROWABLE_HEAP_F64()[b+i]=arg}return _emscripten_run_in_main_runtime_thread_js(index,serializedNumCallArgs,args,sync)})}var _emscripten_receive_on_main_thread_js_callArgs=[];function _emscripten_receive_on_main_thread_js(index,numCallArgs,args){_emscripten_receive_on_main_thread_js_callArgs.length=numCallArgs;var b=args>>3;for(var i=0;i<numCallArgs;i++){_emscripten_receive_on_main_thread_js_callArgs[i]=GROWABLE_HEAP_F64()[b+i]}var isEmAsmConst=index<0;var func=!isEmAsmConst?proxiedFunctionTable[index]:ASM_CONSTS[-index-1];return func.apply(null,_emscripten_receive_on_main_thread_js_callArgs)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=GROWABLE_HEAP_U8().length;requestedSize=requestedSize>>>0;if(requestedSize<=oldSize){return false}var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _emscripten_unwind_to_js_event_loop(){throw"unwind"}function _fd_close(fd){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(4,1,fd);return 52}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(5,1,fd,offset_low,offset_high,whence,newOffset);return 70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}}function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(6,1,fd,iov,iovcnt,pnum);var num=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>2];var len=GROWABLE_HEAP_U32()[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,GROWABLE_HEAP_U8()[ptr+j])}num+=len}GROWABLE_HEAP_U32()[pnum>>2]=num;return 0}function getCFunc(ident){var func=Module["_"+ident];return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},"array":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string"){return UTF8ToString(ret)}if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret}function cwrap(ident,returnType,argTypes,opts){argTypes=argTypes||[];var numericArgs=argTypes.every(type=>type==="number"||type==="boolean");var numericRet=returnType!=="string";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return function(){return ccall(ident,returnType,argTypes,arguments,opts)}}PThread.init();var proxiedFunctionTable=[null,_proc_exit,exitOnMainThread,pthreadCreateProxied,_fd_close,_fd_seek,_fd_write];var asmLibraryArg={"__emscripten_init_main_thread_js":___emscripten_init_main_thread_js,"__emscripten_thread_cleanup":___emscripten_thread_cleanup,"__pthread_create_js":___pthread_create_js,"_emscripten_default_pthread_stack_size":__emscripten_default_pthread_stack_size,"_emscripten_get_now_is_monotonic":__emscripten_get_now_is_monotonic,"_emscripten_notify_task_queue":__emscripten_notify_task_queue,"_emscripten_set_offscreencanvas_size":__emscripten_set_offscreencanvas_size,"abort":_abort,"emscripten_check_blocking_allowed":_emscripten_check_blocking_allowed,"emscripten_date_now":_emscripten_date_now,"emscripten_get_heap_max":_emscripten_get_heap_max,"emscripten_get_now":_emscripten_get_now,"emscripten_memcpy_big":_emscripten_memcpy_big,"emscripten_num_logical_cores":_emscripten_num_logical_cores,"emscripten_receive_on_main_thread_js":_emscripten_receive_on_main_thread_js,"emscripten_resize_heap":_emscripten_resize_heap,"emscripten_unwind_to_js_event_loop":_emscripten_unwind_to_js_event_loop,"exit":_exit,"fd_close":_fd_close,"fd_seek":_fd_seek,"fd_write":_fd_write,"memory":wasmMemory||Module["wasmMemory"]};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["__wasm_call_ctors"]).apply(null,arguments)};var _init=Module["_init"]=function(){return(_init=Module["_init"]=Module["asm"]["init"]).apply(null,arguments)};var _init_with_threads_count=Module["_init_with_threads_count"]=function(){return(_init_with_threads_count=Module["_init_with_threads_count"]=Module["asm"]["init_with_threads_count"]).apply(null,arguments)};var _get_threads_count=Module["_get_threads_count"]=function(){return(_get_threads_count=Module["_get_threads_count"]=Module["asm"]["get_threads_count"]).apply(null,arguments)};var _register_tensor=Module["_register_tensor"]=function(){return(_register_tensor=Module["_register_tensor"]=Module["asm"]["register_tensor"]).apply(null,arguments)};var _dispose_data=Module["_dispose_data"]=function(){return(_dispose_data=Module["_dispose_data"]=Module["asm"]["dispose_data"]).apply(null,arguments)};var _dispose=Module["_dispose"]=function(){return(_dispose=Module["_dispose"]=Module["asm"]["dispose"]).apply(null,arguments)};var _Abs=Module["_Abs"]=function(){return(_Abs=Module["_Abs"]=Module["asm"]["Abs"]).apply(null,arguments)};var _Add=Module["_Add"]=function(){return(_Add=Module["_Add"]=Module["asm"]["Add"]).apply(null,arguments)};var _AddN=Module["_AddN"]=function(){return(_AddN=Module["_AddN"]=Module["asm"]["AddN"]).apply(null,arguments)};var _All=Module["_All"]=function(){return(_All=Module["_All"]=Module["asm"]["All"]).apply(null,arguments)};var _Any=Module["_Any"]=function(){return(_Any=Module["_Any"]=Module["asm"]["Any"]).apply(null,arguments)};var _ArgMax=Module["_ArgMax"]=function(){return(_ArgMax=Module["_ArgMax"]=Module["asm"]["ArgMax"]).apply(null,arguments)};var _AvgPool=Module["_AvgPool"]=function(){return(_AvgPool=Module["_AvgPool"]=Module["asm"]["AvgPool"]).apply(null,arguments)};var _BatchMatMul=Module["_BatchMatMul"]=function(){return(_BatchMatMul=Module["_BatchMatMul"]=Module["asm"]["BatchMatMul"]).apply(null,arguments)};var _Ceil=Module["_Ceil"]=function(){return(_Ceil=Module["_Ceil"]=Module["asm"]["Ceil"]).apply(null,arguments)};var _ClipByValue=Module["_ClipByValue"]=function(){return(_ClipByValue=Module["_ClipByValue"]=Module["asm"]["ClipByValue"]).apply(null,arguments)};var _Conv2D=Module["_Conv2D"]=function(){return(_Conv2D=Module["_Conv2D"]=Module["asm"]["Conv2D"]).apply(null,arguments)};var _Conv2DBackpropInput=Module["_Conv2DBackpropInput"]=function(){return(_Conv2DBackpropInput=Module["_Conv2DBackpropInput"]=Module["asm"]["Conv2DBackpropInput"]).apply(null,arguments)};var _Cos=Module["_Cos"]=function(){return(_Cos=Module["_Cos"]=Module["asm"]["Cos"]).apply(null,arguments)};var _Cosh=Module["_Cosh"]=function(){return(_Cosh=Module["_Cosh"]=Module["asm"]["Cosh"]).apply(null,arguments)};var _CropAndResize=Module["_CropAndResize"]=function(){return(_CropAndResize=Module["_CropAndResize"]=Module["asm"]["CropAndResize"]).apply(null,arguments)};var _Cumprod=Module["_Cumprod"]=function(){return(_Cumprod=Module["_Cumprod"]=Module["asm"]["Cumprod"]).apply(null,arguments)};var _Cumsum=Module["_Cumsum"]=function(){return(_Cumsum=Module["_Cumsum"]=Module["asm"]["Cumsum"]).apply(null,arguments)};var _DepthToSpace=Module["_DepthToSpace"]=function(){return(_DepthToSpace=Module["_DepthToSpace"]=Module["asm"]["DepthToSpace"]).apply(null,arguments)};var _DepthwiseConv2dNative=Module["_DepthwiseConv2dNative"]=function(){return(_DepthwiseConv2dNative=Module["_DepthwiseConv2dNative"]=Module["asm"]["DepthwiseConv2dNative"]).apply(null,arguments)};var _Elu=Module["_Elu"]=function(){return(_Elu=Module["_Elu"]=Module["asm"]["Elu"]).apply(null,arguments)};var _Equal=Module["_Equal"]=function(){return(_Equal=Module["_Equal"]=Module["asm"]["Equal"]).apply(null,arguments)};var _Exp=Module["_Exp"]=function(){return(_Exp=Module["_Exp"]=Module["asm"]["Exp"]).apply(null,arguments)};var _FlipLeftRight=Module["_FlipLeftRight"]=function(){return(_FlipLeftRight=Module["_FlipLeftRight"]=Module["asm"]["FlipLeftRight"]).apply(null,arguments)};var _Floor=Module["_Floor"]=function(){return(_Floor=Module["_Floor"]=Module["asm"]["Floor"]).apply(null,arguments)};var _FloorDiv=Module["_FloorDiv"]=function(){return(_FloorDiv=Module["_FloorDiv"]=Module["asm"]["FloorDiv"]).apply(null,arguments)};var _FusedBatchNorm=Module["_FusedBatchNorm"]=function(){return(_FusedBatchNorm=Module["_FusedBatchNorm"]=Module["asm"]["FusedBatchNorm"]).apply(null,arguments)};var _FusedConv2D=Module["_FusedConv2D"]=function(){return(_FusedConv2D=Module["_FusedConv2D"]=Module["asm"]["FusedConv2D"]).apply(null,arguments)};var _FusedDepthwiseConv2D=Module["_FusedDepthwiseConv2D"]=function(){return(_FusedDepthwiseConv2D=Module["_FusedDepthwiseConv2D"]=Module["asm"]["FusedDepthwiseConv2D"]).apply(null,arguments)};var _Gather=Module["_Gather"]=function(){return(_Gather=Module["_Gather"]=Module["asm"]["Gather"]).apply(null,arguments)};var _GatherNd=Module["_GatherNd"]=function(){return(_GatherNd=Module["_GatherNd"]=Module["asm"]["GatherNd"]).apply(null,arguments)};var _Greater=Module["_Greater"]=function(){return(_Greater=Module["_Greater"]=Module["asm"]["Greater"]).apply(null,arguments)};var _GreaterEqual=Module["_GreaterEqual"]=function(){return(_GreaterEqual=Module["_GreaterEqual"]=Module["asm"]["GreaterEqual"]).apply(null,arguments)};var _IsNan=Module["_IsNan"]=function(){return(_IsNan=Module["_IsNan"]=Module["asm"]["IsNan"]).apply(null,arguments)};var _LeakyRelu=Module["_LeakyRelu"]=function(){return(_LeakyRelu=Module["_LeakyRelu"]=Module["asm"]["LeakyRelu"]).apply(null,arguments)};var _Less=Module["_Less"]=function(){return(_Less=Module["_Less"]=Module["asm"]["Less"]).apply(null,arguments)};var _LessEqual=Module["_LessEqual"]=function(){return(_LessEqual=Module["_LessEqual"]=Module["asm"]["LessEqual"]).apply(null,arguments)};var _Log=Module["_Log"]=function(){return(_Log=Module["_Log"]=Module["asm"]["Log"]).apply(null,arguments)};var _LogicalAnd=Module["_LogicalAnd"]=function(){return(_LogicalAnd=Module["_LogicalAnd"]=Module["asm"]["LogicalAnd"]).apply(null,arguments)};var _LogicalNot=Module["_LogicalNot"]=function(){return(_LogicalNot=Module["_LogicalNot"]=Module["asm"]["LogicalNot"]).apply(null,arguments)};var _LogicalOr=Module["_LogicalOr"]=function(){return(_LogicalOr=Module["_LogicalOr"]=Module["asm"]["LogicalOr"]).apply(null,arguments)};var _LogicalXor=Module["_LogicalXor"]=function(){return(_LogicalXor=Module["_LogicalXor"]=Module["asm"]["LogicalXor"]).apply(null,arguments)};var _Max=Module["_Max"]=function(){return(_Max=Module["_Max"]=Module["asm"]["Max"]).apply(null,arguments)};var _MaxPool=Module["_MaxPool"]=function(){return(_MaxPool=Module["_MaxPool"]=Module["asm"]["MaxPool"]).apply(null,arguments)};var _Maximum=Module["_Maximum"]=function(){return(_Maximum=Module["_Maximum"]=Module["asm"]["Maximum"]).apply(null,arguments)};var _Mean=Module["_Mean"]=function(){return(_Mean=Module["_Mean"]=Module["asm"]["Mean"]).apply(null,arguments)};var _Min=Module["_Min"]=function(){return(_Min=Module["_Min"]=Module["asm"]["Min"]).apply(null,arguments)};var _Minimum=Module["_Minimum"]=function(){return(_Minimum=Module["_Minimum"]=Module["asm"]["Minimum"]).apply(null,arguments)};var _MirrorPad=Module["_MirrorPad"]=function(){return(_MirrorPad=Module["_MirrorPad"]=Module["asm"]["MirrorPad"]).apply(null,arguments)};var _Multiply=Module["_Multiply"]=function(){return(_Multiply=Module["_Multiply"]=Module["asm"]["Multiply"]).apply(null,arguments)};var _Neg=Module["_Neg"]=function(){return(_Neg=Module["_Neg"]=Module["asm"]["Neg"]).apply(null,arguments)};var _NonMaxSuppressionV3=Module["_NonMaxSuppressionV3"]=function(){return(_NonMaxSuppressionV3=Module["_NonMaxSuppressionV3"]=Module["asm"]["NonMaxSuppressionV3"]).apply(null,arguments)};var _NonMaxSuppressionV4=Module["_NonMaxSuppressionV4"]=function(){return(_NonMaxSuppressionV4=Module["_NonMaxSuppressionV4"]=Module["asm"]["NonMaxSuppressionV4"]).apply(null,arguments)};var _NonMaxSuppressionV5=Module["_NonMaxSuppressionV5"]=function(){return(_NonMaxSuppressionV5=Module["_NonMaxSuppressionV5"]=Module["asm"]["NonMaxSuppressionV5"]).apply(null,arguments)};var _NotEqual=Module["_NotEqual"]=function(){return(_NotEqual=Module["_NotEqual"]=Module["asm"]["NotEqual"]).apply(null,arguments)};var _OneHot=Module["_OneHot"]=function(){return(_OneHot=Module["_OneHot"]=Module["asm"]["OneHot"]).apply(null,arguments)};var _PadV2=Module["_PadV2"]=function(){return(_PadV2=Module["_PadV2"]=Module["asm"]["PadV2"]).apply(null,arguments)};var _Pow=Module["_Pow"]=function(){return(_Pow=Module["_Pow"]=Module["asm"]["Pow"]).apply(null,arguments)};var _Prelu=Module["_Prelu"]=function(){return(_Prelu=Module["_Prelu"]=Module["asm"]["Prelu"]).apply(null,arguments)};var _Prod=Module["_Prod"]=function(){return(_Prod=Module["_Prod"]=Module["asm"]["Prod"]).apply(null,arguments)};var _RealDiv=Module["_RealDiv"]=function(){return(_RealDiv=Module["_RealDiv"]=Module["asm"]["RealDiv"]).apply(null,arguments)};var _Reciprocal=Module["_Reciprocal"]=function(){return(_Reciprocal=Module["_Reciprocal"]=Module["asm"]["Reciprocal"]).apply(null,arguments)};var _Relu=Module["_Relu"]=function(){return(_Relu=Module["_Relu"]=Module["asm"]["Relu"]).apply(null,arguments)};var _Relu6=Module["_Relu6"]=function(){return(_Relu6=Module["_Relu6"]=Module["asm"]["Relu6"]).apply(null,arguments)};var _ResizeBilinear=Module["_ResizeBilinear"]=function(){return(_ResizeBilinear=Module["_ResizeBilinear"]=Module["asm"]["ResizeBilinear"]).apply(null,arguments)};var _ResizeNearestNeighbor=Module["_ResizeNearestNeighbor"]=function(){return(_ResizeNearestNeighbor=Module["_ResizeNearestNeighbor"]=Module["asm"]["ResizeNearestNeighbor"]).apply(null,arguments)};var _Reverse=Module["_Reverse"]=function(){return(_Reverse=Module["_Reverse"]=Module["asm"]["Reverse"]).apply(null,arguments)};var _RotateWithOffset=Module["_RotateWithOffset"]=function(){return(_RotateWithOffset=Module["_RotateWithOffset"]=Module["asm"]["RotateWithOffset"]).apply(null,arguments)};var _Round=Module["_Round"]=function(){return(_Round=Module["_Round"]=Module["asm"]["Round"]).apply(null,arguments)};var _Rsqrt=Module["_Rsqrt"]=function(){return(_Rsqrt=Module["_Rsqrt"]=Module["asm"]["Rsqrt"]).apply(null,arguments)};var _ScatterNd=Module["_ScatterNd"]=function(){return(_ScatterNd=Module["_ScatterNd"]=Module["asm"]["ScatterNd"]).apply(null,arguments)};var _SelectV2=Module["_SelectV2"]=function(){return(_SelectV2=Module["_SelectV2"]=Module["asm"]["SelectV2"]).apply(null,arguments)};var _Sigmoid=Module["_Sigmoid"]=function(){return(_Sigmoid=Module["_Sigmoid"]=Module["asm"]["Sigmoid"]).apply(null,arguments)};var _Sin=Module["_Sin"]=function(){return(_Sin=Module["_Sin"]=Module["asm"]["Sin"]).apply(null,arguments)};var _Softmax=Module["_Softmax"]=function(){return(_Softmax=Module["_Softmax"]=Module["asm"]["Softmax"]).apply(null,arguments)};var _SparseFillEmptyRows=Module["_SparseFillEmptyRows"]=function(){return(_SparseFillEmptyRows=Module["_SparseFillEmptyRows"]=Module["asm"]["SparseFillEmptyRows"]).apply(null,arguments)};var _SparseReshape=Module["_SparseReshape"]=function(){return(_SparseReshape=Module["_SparseReshape"]=Module["asm"]["SparseReshape"]).apply(null,arguments)};var _SparseSegmentReduction=Module["_SparseSegmentReduction"]=function(){return(_SparseSegmentReduction=Module["_SparseSegmentReduction"]=Module["asm"]["SparseSegmentReduction"]).apply(null,arguments)};var _Sqrt=Module["_Sqrt"]=function(){return(_Sqrt=Module["_Sqrt"]=Module["asm"]["Sqrt"]).apply(null,arguments)};var _Square=Module["_Square"]=function(){return(_Square=Module["_Square"]=Module["asm"]["Square"]).apply(null,arguments)};var _SquaredDifference=Module["_SquaredDifference"]=function(){return(_SquaredDifference=Module["_SquaredDifference"]=Module["asm"]["SquaredDifference"]).apply(null,arguments)};var _Step=Module["_Step"]=function(){return(_Step=Module["_Step"]=Module["asm"]["Step"]).apply(null,arguments)};var _StridedSlice=Module["_StridedSlice"]=function(){return(_StridedSlice=Module["_StridedSlice"]=Module["asm"]["StridedSlice"]).apply(null,arguments)};var _Sub=Module["_Sub"]=function(){return(_Sub=Module["_Sub"]=Module["asm"]["Sub"]).apply(null,arguments)};var _Sum=Module["_Sum"]=function(){return(_Sum=Module["_Sum"]=Module["asm"]["Sum"]).apply(null,arguments)};var _Tan=Module["_Tan"]=function(){return(_Tan=Module["_Tan"]=Module["asm"]["Tan"]).apply(null,arguments)};var _Tanh=Module["_Tanh"]=function(){return(_Tanh=Module["_Tanh"]=Module["asm"]["Tanh"]).apply(null,arguments)};var _Tile=Module["_Tile"]=function(){return(_Tile=Module["_Tile"]=Module["asm"]["Tile"]).apply(null,arguments)};var _TopK=Module["_TopK"]=function(){return(_TopK=Module["_TopK"]=Module["asm"]["TopK"]).apply(null,arguments)};var _Transform=Module["_Transform"]=function(){return(_Transform=Module["_Transform"]=Module["asm"]["Transform"]).apply(null,arguments)};var _Transpose=Module["_Transpose"]=function(){return(_Transpose=Module["_Transpose"]=Module["asm"]["Transpose"]).apply(null,arguments)};var __FusedMatMul=Module["__FusedMatMul"]=function(){return(__FusedMatMul=Module["__FusedMatMul"]=Module["asm"]["_FusedMatMul"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["malloc"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["free"]).apply(null,arguments)};var __emscripten_tls_init=Module["__emscripten_tls_init"]=function(){return(__emscripten_tls_init=Module["__emscripten_tls_init"]=Module["asm"]["_emscripten_tls_init"]).apply(null,arguments)};var _pthread_self=Module["_pthread_self"]=function(){return(_pthread_self=Module["_pthread_self"]=Module["asm"]["pthread_self"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["__errno_location"]).apply(null,arguments)};var __emscripten_thread_init=Module["__emscripten_thread_init"]=function(){return(__emscripten_thread_init=Module["__emscripten_thread_init"]=Module["asm"]["_emscripten_thread_init"]).apply(null,arguments)};var __emscripten_thread_crashed=Module["__emscripten_thread_crashed"]=function(){return(__emscripten_thread_crashed=Module["__emscripten_thread_crashed"]=Module["asm"]["_emscripten_thread_crashed"]).apply(null,arguments)};var _emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=function(){return(_emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=Module["asm"]["emscripten_main_thread_process_queued_calls"]).apply(null,arguments)};var _emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=function(){return(_emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=Module["asm"]["emscripten_main_browser_thread_id"]).apply(null,arguments)};var _emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=function(){return(_emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=Module["asm"]["emscripten_run_in_main_runtime_thread_js"]).apply(null,arguments)};var _emscripten_dispatch_to_thread_=Module["_emscripten_dispatch_to_thread_"]=function(){return(_emscripten_dispatch_to_thread_=Module["_emscripten_dispatch_to_thread_"]=Module["asm"]["emscripten_dispatch_to_thread_"]).apply(null,arguments)};var __emscripten_proxy_execute_task_queue=Module["__emscripten_proxy_execute_task_queue"]=function(){return(__emscripten_proxy_execute_task_queue=Module["__emscripten_proxy_execute_task_queue"]=Module["asm"]["_emscripten_proxy_execute_task_queue"]).apply(null,arguments)};var __emscripten_thread_free_data=Module["__emscripten_thread_free_data"]=function(){return(__emscripten_thread_free_data=Module["__emscripten_thread_free_data"]=Module["asm"]["_emscripten_thread_free_data"]).apply(null,arguments)};var __emscripten_thread_exit=Module["__emscripten_thread_exit"]=function(){return(__emscripten_thread_exit=Module["__emscripten_thread_exit"]=Module["asm"]["_emscripten_thread_exit"]).apply(null,arguments)};var _emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=function(){return(_emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=Module["asm"]["emscripten_stack_set_limits"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["stackSave"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["stackRestore"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["stackAlloc"]).apply(null,arguments)};var dynCall_iijjiiii=Module["dynCall_iijjiiii"]=function(){return(dynCall_iijjiiii=Module["dynCall_iijjiiii"]=Module["asm"]["dynCall_iijjiiii"]).apply(null,arguments)};var dynCall_jiji=Module["dynCall_jiji"]=function(){return(dynCall_jiji=Module["dynCall_jiji"]=Module["asm"]["dynCall_jiji"]).apply(null,arguments)};Module["keepRuntimeAlive"]=keepRuntimeAlive;Module["wasmMemory"]=wasmMemory;Module["cwrap"]=cwrap;Module["ExitStatus"]=ExitStatus;Module["PThread"]=PThread;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}if(ENVIRONMENT_IS_PTHREAD){readyPromiseResolve(Module);initRuntime();postMessage({"cmd":"loaded"});return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}run();var listenersAdded;if(beforeListeners){listenersAdded={uncaughtException:process.listeners("uncaughtException").filter(function(listener){return!beforeListeners.uncaughtException.indexOf(listener)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(listener){return!beforeListeners.unhandledRejection.indexOf(listener)>-1})}}var actualModule;if(typeof WasmBackendModule!=="undefined"){actualModule=WasmBackendModule}else if(typeof WasmBackendModuleThreadedSimd!=="undefined"){actualModule=WasmBackendModuleThreadedSimd}else{throw new Error("Could not find wasm module in post.js")}if(listenersAdded){var tmpDispose=actualModule["_dispose"];actualModule["_dispose"]=function(){tmpDispose();listenersAdded.uncaughtException.forEach(function(listener){process.removeListener("uncaughtException",listener)});listenersAdded.unhandledRejection.forEach(function(listener){process.removeListener("unhandledRejection",listener)})}}


  return WasmBackendModuleThreadedSimd.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = WasmBackendModuleThreadedSimd;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return WasmBackendModuleThreadedSimd; });
else if (typeof exports === 'object')
  exports["WasmBackendModuleThreadedSimd"] = WasmBackendModuleThreadedSimd;`;var v0=Wl(Nj());var Dj=S0.default||S0,Tbe=v0.default||v0,Bg=class extends po{constructor(t){super();this.wasm=t;this.wasm.tfjs.initWithThreadsCount(Rj),k0=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new fa(this,rn())}dataIdNextNumber=1;dataIdMap;write(t,n,o){let s={id:this.dataIdNextNumber++};return this.move(s,t,n,o,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){let n=y.now();return t(),{kernelMs:y.now()-n}}move(t,n,o,s,a){let i=this.dataIdNextNumber++;if(s==="string"){let m=n;this.dataIdMap.set(t,{id:i,stringBytes:m,shape:o,dtype:s,memoryOffset:null,refCount:a});return}let u=y.sizeFromShape(o),l=u*y.bytesPerElement(s),p=this.wasm._malloc(l);this.dataIdMap.set(t,{id:i,memoryOffset:p,shape:o,dtype:s,refCount:a}),this.wasm.tfjs.registerTensor(i,u,p),n!=null&&this.wasm.HEAPU8.set(new Uint8Array(n.buffer,n.byteOffset,l),p)}async read(t){return this.readSync(t)}readSync(t,n,o){let{memoryOffset:s,dtype:a,shape:i,stringBytes:u}=this.dataIdMap.get(t);if(a==="string")return(n==null||n===0)&&(o==null||o>=u.length)?u:u.slice(n,o);n=n||0,o=o||y.sizeFromShape(i);let l=y.bytesPerElement(a),p=this.wasm.HEAPU8.slice(s+n*l,s+o*l);return Ibe(p.buffer,a)}disposeData(t,n=!1){if(this.dataIdMap.has(t)){let o=this.dataIdMap.get(t);if(o.refCount--,!n&&o.refCount>0)return!1;this.wasm._free(o.memoryOffset),this.wasm.tfjs.disposeData(o.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){let n=this.dataIdMap.get(t);n!=null&&n.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,n,o){let s;if(o==null)s=this.write(null,t,n);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:o,shape:t,dtype:n,refCount:1});let i=y.sizeFromShape(t);this.wasm.tfjs.registerTensor(a,i,o)}return{dataId:s,shape:t,dtype:n}}typedArrayFromHeap({shape:t,dtype:n,dataId:o}){let s=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(o),i=y.sizeFromShape(t);switch(n){case"float32":return new Float32Array(s,a,i);case"int32":return new Int32Array(s,a,i);case"bool":return new Uint8Array(s,a,i);default:throw new Error(`Unknown dtype ${n}`)}}};function xbe(r){return(e,t)=>(y.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||e.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,e).then(s=>{t(s.instance,s.module)})})}),{})}function _j(r,e,t){if(Rk!=null)return Rk;let n="tfjs-backend-wasm.wasm";return r&&e?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),Lg!=null&&Lg[n]!=null?Lg[n]:t+n}async function Mj(){let[r,e]=await Promise.all([$().getAsync("WASM_HAS_SIMD_SUPPORT"),$().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,n)=>{let o={};o.locateFile=(i,u)=>{if(i.endsWith(".worker.js")){let l=wj.replace(/\n/g,"\\n"),p=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(p)}return i.endsWith(".wasm")?_j(r,e,Fg??u):u+i},A0&&(o.instantiateWasm=xbe(_j(r,e,Fg??"")));let s=!1;o.onAbort=()=>{if(s||$g)return;$g=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;e&&r&&Rk==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Dj.toString()],{type:"text/javascript"}),a=Dj(o)):a=Tbe(o),a.then(i=>{s=!0,$g=!1;let u=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",u,["number"]),dispose:i.cwrap("dispose",u,[])},t({wasm:i})}).catch(n)})}function Ibe(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}var Cbe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Rk=null,Fg=null,Lg={},$g=!1,A0=!1;function kbe(r,e=!1){if(eA("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),$g)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Rk=r,A0=e}function Sbe(r,e=!1){if($g)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")Fg=r;else{Lg=r;let t=Cbe.filter(n=>Lg[n]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}A0=e}var Rj=-1,k0=-1;function vbe(r){Rj=r}function Abe(){if(k0===-1)throw new Error("WASM backend not initialized.");return k0}var wbe="0.0.0";var Nbe=2;ul("wasm",async()=>{let{wasm:r}=await Mj();return new Bg(r)},Nbe);var Ol="4.0.0-20221110",Nsn={tfjs:Ol,"tfjs-core":Ol,"tfjs-data":Ol,"tfjs-layers":Ol,"tfjs-converter":Ol,"tfjs-backend-cpu":Ol,"tfjs-backend-webgl":Ol,"tfjs-backend-wasm":Ol};export{Ts as Abs,ba as Acos,ya as Acosh,xl as AdadeltaOptimizer,Il as AdagradOptimizer,Cl as AdamOptimizer,kl as AdamaxOptimizer,Nn as Add,co as AddN,Ta as All,xa as Any,fo as ArgMax,Si as ArgMin,Ia as Asin,Ca as Asinh,ka as Atan,va as Atan2,Sa as Atanh,ho as AvgPool,Bu as AvgPool3D,Sm as AvgPool3DGrad,km as AvgPoolGrad,Bg as BackendWasm,go as BatchMatMul,xs as BatchToSpaceND,Ou as Bincount,vm as BroadcastArgs,Y0 as BroadcastTo,KT as Callback,rT as CallbackList,Un as Cast,bo as Ceil,Kn as ClipByValue,zu as Complex,Gu as ComplexAbs,Is as Concat,yo as Conv2D,Am as Conv2DBackpropFilter,To as Conv2DBackpropInput,Wu as Conv3D,wm as Conv3DBackpropFilterV2,Nm as Conv3DBackpropInputV2,xo as Cos,Io as Cosh,wa as CropAndResize,Aa as Cumprod,Co as Cumsum,oT as CustomCallback,fa as DataStorage,Uu as DenseBincount,Na as DepthToSpace,ko as DepthwiseConv2dNative,Dm as DepthwiseConv2dNativeBackpropFilter,_m as DepthwiseConv2dNativeBackpropInput,Mm as Diag,Ku as Dilation2D,lh as Dilation2DBackpropFilter,uh as Dilation2DBackpropInput,Cv as ENV,VT as EarlyStopping,Vu as Einsum,vo as Elu,Rm as EluGrad,ah as Environment,_a as Equal,Da as Erf,Ao as Exp,Cs as ExpandDims,Ma as Expm1,Pm as FFT,vi as Fill,Ra as FlipLeftRight,wo as Floor,No as FloorDiv,Vl as FromPixels,Do as FusedBatchNorm,Ls as FusedConv2D,$s as FusedDepthwiseConv2D,Zp as GPGPUContext,Pa as GatherNd,ks as GatherV2,Jh as GraphModel,Ea as Greater,_o as GreaterEqual,nT as History,Em as IFFT,Vn as Identity,Hu as Imag,wt as InputSpec,Fa as IsFinite,La as IsInf,Mo as IsNan,po as KernelBackend,qu as LRN,Lm as LRNGrad,Bh as LayerVariable,Qn as LayersModel,Ro as LeakyRelu,$a as Less,Ba as LessEqual,Fm as LinSpace,Po as Log,Qi as Log1p,Q0 as LogSoftmax,Oa as LogicalAnd,za as LogicalNot,Ji as LogicalOr,Z0 as LogicalXor,Ebe as LowerBound,af as MathBackendCPU,Df as MathBackendWebGL,Eo as Max,Lo as MaxPool,ju as MaxPool3D,Bm as MaxPool3DGrad,$m as MaxPoolGrad,Om as MaxPoolWithArgmax,Fo as Maximum,$o as Mean,Bo as Min,Oo as Minimum,zo as MirrorPad,Ga as Mod,Sl as MomentumOptimizer,zm as Multinomial,Go as Multiply,Ss as Neg,Ua as NonMaxSuppressionV3,eu as NonMaxSuppressionV4,Ka as NonMaxSuppressionV5,Wa as NotEqual,Bv as OP_SCOPE_SUFFIX,Wo as OneHot,vs as OnesLike,Yr as Optimizer,ri as OptimizerConstructors,As as Pack,Uo as PadV2,Fbe as Pool,Ko as Pow,Vo as Prelu,Ho as Prod,vl as RMSPropOptimizer,gs as RNN,Gm as RaggedGather,Wm as RaggedRange,Um as RaggedTensorToTensor,Ai as Range,k_ as Rank,Xu as Real,So as RealDiv,qo as Reciprocal,ti as Reduction,jo as Relu,Zo as Relu6,ws as Reshape,Yo as ResizeBilinear,Vm as ResizeBilinearGrad,Xo as ResizeNearestNeighbor,Km as ResizeNearestNeighborGrad,Qo as Reverse,Za as RotateWithOffset,Va as Round,Jo as Rsqrt,Li as SGDOptimizer,Ha as ScatterNd,Hm as SearchSorted,Ns as Select,tu as Selu,Np as Sequential,ts as Sigmoid,ru as Sign,es as Sin,qa as Sinh,Ds as Slice,os as Softmax,nu as Softplus,_s as SpaceToBatchND,Yu as SparseFillEmptyRows,ou as SparseReshape,Zu as SparseSegmentMean,Qu as SparseSegmentSum,Ju as SparseToDense,Ms as SplitV,rs as Sqrt,wi as Square,ss as SquaredDifference,Es as Step,ja as StridedSlice,Ni as StringNGrams,el as StringSplit,tl as StringToHashBucketFast,as as Sub,ns as Sum,ln as SymbolicTensor,is as Tan,us as Tanh,We as Tensor,bt as TensorBuffer,Dn as Tile,Xa as TopK,Ya as Transform,_n as Transpose,qm as Unique,Rs as Unpack,rl as UnsortedSegmentSum,Lbe as UpperBound,au as Variable,zf as WebGPUBackend,Ps as ZerosLike,Fs as _FusedMatMul,Ot as abs,A1 as acos,w1 as acosh,Z as add,N1 as addN,Wb as all,vh as any,pl as argMax,D1 as argMin,_1 as asin,M1 as asinh,R1 as atan,P1 as atan2,E1 as atanh,ac as avgPool,Kb as avgPool3d,a1 as backend,C as backend_util,$1 as basicLSTMCell,cl as batchNorm,Vb as batchNorm2d,Hb as batchNorm3d,qb as batchNorm4d,ic as batchToSpaceND,jb as bincount,UZ as booleanMaskAsync,O1 as broadcastArgs,dl as broadcastTo,Dr as broadcast_util,$b as browser,Ie as buffer,Nte as callbacks,re as cast,z1 as ceil,Hr as clipByValue,gn as clone,Mn as complex,ct as concat,Xb as concat1d,Yb as concat2d,Zb as concat3d,Qb as concat4d,bE as constraints,Jb as conv1d,cs as conv2d,ey as conv2dTranspose,ty as conv3d,ny as conv3dTranspose,Ube as copyRegisteredKernels,lc as cos,oy as cosh,Rh as cosineWindow,Ah as cumprod,sy as cumsum,bn as customGrad,QF as data,wh as denseBincount,eA as deprecationWarn,G1 as depthToSpace,fl as depthwiseConv2d,Pte as deregisterOp,sl as device_util,W1 as diag,U1 as dilation2d,GIe as disableDeprecationWarnings,_e as dispose,WIe as disposeVariables,fe as div,K1 as divNoNan,V1 as dot,TA as dropout,H1 as einsum,hl as elu,zIe as enableDebugMode,OIe as enableProdMode,xA as enclosingPowerOfTwo,rn as engine,$ as env,nn as equal,q1 as erf,Y1 as euclideanNorm,br as exp,yr as expandDims,Z1 as expm1,op as eye,Tc as fft,Ks as fill,jIe as findBackend,XIe as findBackendFactory,gl as floor,Gb as floorDiv,$z as forceHalfFloat,Tl as fused,bl as gather,QZ as gatherND,Bb as gather_util,HIe as getBackend,vv as getGradient,mh as getKernel,bb as getKernelsForBackend,Abe as getThreadsCount,SD as gpgpu_util,sY as grad,aY as grads,Qt as greater,Xn as greaterEqual,pp as ifft,ll as imag,fs as image,tQ as inTopKAsync,yE as initializers,qA as input,Br as io,vy as irfft,Q1 as isFinite,J1 as isInf,e2 as isNaN,Et as keep,xr as kernel_impls,YE as layers,pc as leakyRelu,ay as less,Hs as lessEqual,CA as linalg,t2 as linspace,wre as loadGraphModel,Nre as loadGraphModelSync,$E as loadLayersModel,r2 as localResponseNormalization,jr as log,mc as log1p,n2 as logSigmoid,ly as logSoftmax,py as logSumExp,sn as logicalAnd,cc as logicalNot,my as logicalOr,o2 as logicalXor,t7 as losses,s2 as lowerBound,Ue as matMul,u1 as math,qr as max,dc as maxPool,dy as maxPool3d,a2 as maxPoolWithArgmax,ds as maximum,Lt as mean,Ih as memory,i2 as meshgrid,ZE as metrics,rp as min,yl as minimum,u2 as mirrorPad,l2 as mod,M9 as model,QE as models,sp as moments,VZ as movingAverage,P as mul,p2 as multiRNNCell,m2 as multinomial,tt as neg,Ph as nextFrame,np as norm,du as notEqual,il as oneHot,Tr as ones,zr as onesLike,A as op,c2 as outerProduct,Yn as pad,d2 as pad1d,f2 as pad2d,h2 as pad3d,g2 as pad4d,b2 as pool,jn as pow,hc as prelu,Mb as print,y2 as prod,UIe as profile,T2 as raggedGather,x2 as raggedRange,I2 as raggedTensorToTensor,C2 as rand,O2 as randomGamma,up as randomNormal,z2 as randomStandardNormal,Pi as randomUniform,Ei as range,VIe as ready,mu as real,G2 as reciprocal,ul as registerBackend,P9 as registerCallbackConstructor,e_ as registerGradient,su as registerKernel,Rte as registerOp,JE as regularizers,an as relu,yy as relu6,qIe as removeBackend,F as reshape,_r as reverse,W2 as reverse1d,U2 as reverse2d,K2 as reverse3d,V2 as reverse4d,xc as rfft,Ty as round,xy as rsqrt,ge as scalar,qZ as scatterND,Ch as scatter_util,Dh as searchSorted,Iy as selu,Cy as separableConv2d,R9 as sequential,Q as serialization,O8 as setBackend,YIe as setPlatform,vbe as setThreadsCount,kbe as setWasmPath,Sbe as setWasmPaths,BN as setWebGLContext,H2 as setdiff1dAsync,ff as shared,Pn as sigmoid,q2 as sign,e7 as signal,ky as sin,Sy as sinh,ze as slice,gc as slice1d,Mh as slice2d,bc as slice3d,lp as slice4d,It as slice_util,yc as softmax,cu as softplus,fc as spaceToBatchND,r7 as sparse,YZ as sparseToDense,JQ as spectral,Mr as split,Ft as sqrt,He as square,Ay as squaredDifference,qs as squeeze,cr as stack,Fi as step,j2 as stridedSlice,n7 as string,me as sub,be as sum,iu as sumOutType,X2 as tan,ml as tanh,mr as tensor,Jt as tensor1d,ei as tensor2d,Lb as tensor3d,Y2 as tensor4d,Z2 as tensor5d,Q2 as tensor6d,Gs as tensor_util,v1 as test_util,z as tidy,on as tile,KIe as time,J2 as topk,hp as train,Ge as transpose,Ic as truncatedNormal,eM as unique,Wbe as unregisterGradient,Gbe as unregisterKernel,wy as unsortedSegmentSum,Rr as unstack,Pt as upcastType,tM as upperBound,y as util,iY as valueAndGrad,uY as valueAndGrads,Ny as variable,iy as variableGrads,Nsn as version,_re as version_converter,h5 as version_core,pne as version_cpu,qh as version_layers,wbe as version_wasm,sie as version_webgl,VQt as webgl,xf as webgl_util,QD as webgpu_util,zt as where,_y as whereAsync,Ct as zeros,we as zerosLike};
//# sourceMappingURL=tfjs.min.esm.js.map
