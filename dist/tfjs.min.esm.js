var x6=Object.create;var fb=Object.defineProperty;var I6=Object.getOwnPropertyDescriptor;var C6=Object.getOwnPropertyNames;var S6=Object.getPrototypeOf,k6=Object.prototype.hasOwnProperty;var v6=(r,e,t)=>e in r?fb(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var hb=(r=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(r,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):r)(function(r){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var Nr=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),qe=(r,e)=>{for(var t in e)fb(r,t,{get:e[t],enumerable:!0})},A6=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of C6(e))!k6.call(r,o)&&o!==t&&fb(r,o,{get:()=>e[o],enumerable:!(n=I6(e,o))||n.enumerable});return r};var Vl=(r,e,t)=>(t=r!=null?x6(S6(r)):{},A6(e||!r||!r.__esModule?fb(t,"default",{value:r,enumerable:!0}):t,r));var K=(r,e,t)=>(v6(r,typeof e!="symbol"?e+"":e,t),t);var f_=Nr((nye,d_)=>{d_.exports=Yt;var Os=null;try{Os=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Yt(r,e,t){this.low=r|0,this.high=e|0,this.unsigned=!!t}Yt.prototype.__isLong__;Object.defineProperty(Yt.prototype,"__isLong__",{value:!0});function qn(r){return(r&&r.__isLong__)===!0}Yt.isLong=qn;var o_={},s_={};function Yl(r,e){var t,n,o;return e?(r>>>=0,(o=0<=r&&r<256)&&(n=s_[r],n)?n:(t=Zt(r,(r|0)<0?-1:0,!0),o&&(s_[r]=t),t)):(r|=0,(o=-128<=r&&r<128)&&(n=o_[r],n)?n:(t=Zt(r,r<0?-1:0,!1),o&&(o_[r]=t),t))}Yt.fromInt=Yl;function zs(r,e){if(isNaN(r))return e?Xl:Gs;if(e){if(r<0)return Xl;if(r>=l_)return c_}else{if(r<=-i_)return Hn;if(r+1>=i_)return m_}return r<0?zs(-r,e).neg():Zt(r%Ym|0,r/Ym|0,e)}Yt.fromNumber=zs;function Zt(r,e,t){return new Yt(r,e,t)}Yt.fromBits=Zt;var Tb=Math.pow;function Mv(r,e,t){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return Gs;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return Mv(r.substring(1),e,t).neg();for(var o=zs(Tb(t,8)),s=Gs,a=0;a<r.length;a+=8){var i=Math.min(8,r.length-a),u=parseInt(r.substring(a,a+i),t);if(i<8){var l=zs(Tb(t,i));s=s.mul(l).add(zs(u))}else s=s.mul(o),s=s.add(zs(u))}return s.unsigned=e,s}Yt.fromString=Mv;function ei(r,e){return typeof r=="number"?zs(r,e):typeof r=="string"?Mv(r,e):Zt(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}Yt.fromValue=ei;var a_=1<<16,Y6=1<<24,Ym=a_*a_,l_=Ym*Ym,i_=l_/2,u_=Yl(Y6),Gs=Yl(0);Yt.ZERO=Gs;var Xl=Yl(0,!0);Yt.UZERO=Xl;var Xm=Yl(1);Yt.ONE=Xm;var p_=Yl(1,!0);Yt.UONE=p_;var _v=Yl(-1);Yt.NEG_ONE=_v;var m_=Zt(-1,2147483647,!1);Yt.MAX_VALUE=m_;var c_=Zt(-1,-1,!0);Yt.MAX_UNSIGNED_VALUE=c_;var Hn=Zt(0,-2147483648,!1);Yt.MIN_VALUE=Hn;var Ce=Yt.prototype;Ce.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ce.toNumber=function(){return this.unsigned?(this.high>>>0)*Ym+(this.low>>>0):this.high*Ym+(this.low>>>0)};Ce.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Hn)){var t=zs(e),n=this.div(t),o=n.mul(t).sub(this);return n.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=zs(Tb(e,6),this.unsigned),a=this,i="";;){var u=a.div(s),l=a.sub(u.mul(s)).toInt()>>>0,p=l.toString(e);if(a=u,a.isZero())return p+i;for(;p.length<6;)p="0"+p;i=""+p+i}};Ce.getHighBits=function(){return this.high};Ce.getHighBitsUnsigned=function(){return this.high>>>0};Ce.getLowBits=function(){return this.low};Ce.getLowBitsUnsigned=function(){return this.low>>>0};Ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Hn)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};Ce.isZero=function(){return this.high===0&&this.low===0};Ce.eqz=Ce.isZero;Ce.isNegative=function(){return!this.unsigned&&this.high<0};Ce.isPositive=function(){return this.unsigned||this.high>=0};Ce.isOdd=function(){return(this.low&1)===1};Ce.isEven=function(){return(this.low&1)===0};Ce.equals=function(e){return qn(e)||(e=ei(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Ce.eq=Ce.equals;Ce.notEquals=function(e){return!this.eq(e)};Ce.neq=Ce.notEquals;Ce.ne=Ce.notEquals;Ce.lessThan=function(e){return this.comp(e)<0};Ce.lt=Ce.lessThan;Ce.lessThanOrEqual=function(e){return this.comp(e)<=0};Ce.lte=Ce.lessThanOrEqual;Ce.le=Ce.lessThanOrEqual;Ce.greaterThan=function(e){return this.comp(e)>0};Ce.gt=Ce.greaterThan;Ce.greaterThanOrEqual=function(e){return this.comp(e)>=0};Ce.gte=Ce.greaterThanOrEqual;Ce.ge=Ce.greaterThanOrEqual;Ce.compare=function(e){if(qn(e)||(e=ei(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Ce.comp=Ce.compare;Ce.negate=function(){return!this.unsigned&&this.eq(Hn)?Hn:this.not().add(Xm)};Ce.neg=Ce.negate;Ce.add=function(e){qn(e)||(e=ei(e));var t=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,a=e.high>>>16,i=e.high&65535,u=e.low>>>16,l=e.low&65535,p=0,m=0,c=0,d=0;return d+=s+l,c+=d>>>16,d&=65535,c+=o+u,m+=c>>>16,c&=65535,m+=n+i,p+=m>>>16,m&=65535,p+=t+a,p&=65535,Zt(c<<16|d,p<<16|m,this.unsigned)};Ce.subtract=function(e){return qn(e)||(e=ei(e)),this.add(e.neg())};Ce.sub=Ce.subtract;Ce.multiply=function(e){if(this.isZero())return Gs;if(qn(e)||(e=ei(e)),Os){var t=Os.mul(this.low,this.high,e.low,e.high);return Zt(t,Os.get_high(),this.unsigned)}if(e.isZero())return Gs;if(this.eq(Hn))return e.isOdd()?Hn:Gs;if(e.eq(Hn))return this.isOdd()?Hn:Gs;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(u_)&&e.lt(u_))return zs(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,a=this.low&65535,i=e.high>>>16,u=e.high&65535,l=e.low>>>16,p=e.low&65535,m=0,c=0,d=0,f=0;return f+=a*p,d+=f>>>16,f&=65535,d+=s*p,c+=d>>>16,d&=65535,d+=a*l,c+=d>>>16,d&=65535,c+=o*p,m+=c>>>16,c&=65535,c+=s*l,m+=c>>>16,c&=65535,c+=a*u,m+=c>>>16,c&=65535,m+=n*p+o*l+s*u+a*i,m&=65535,Zt(d<<16|f,m<<16|c,this.unsigned)};Ce.mul=Ce.multiply;Ce.divide=function(e){if(qn(e)||(e=ei(e)),e.isZero())throw Error("division by zero");if(Os){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Os.div_u:Os.div_s)(this.low,this.high,e.low,e.high);return Zt(t,Os.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Xl:Gs;var n,o,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Xl;if(e.gt(this.shru(1)))return p_;s=Xl}else{if(this.eq(Hn)){if(e.eq(Xm)||e.eq(_v))return Hn;if(e.eq(Hn))return Xm;var a=this.shr(1);return n=a.div(e).shl(1),n.eq(Gs)?e.isNegative()?Xm:_v:(o=this.sub(e.mul(n)),s=n.add(o.div(e)),s)}else if(e.eq(Hn))return this.unsigned?Xl:Gs;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=Gs}for(o=this;o.gte(e);){n=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:Tb(2,i-48),l=zs(n),p=l.mul(e);p.isNegative()||p.gt(o);)n-=u,l=zs(n,this.unsigned),p=l.mul(e);l.isZero()&&(l=Xm),s=s.add(l),o=o.sub(p)}return s};Ce.div=Ce.divide;Ce.modulo=function(e){if(qn(e)||(e=ei(e)),Os){var t=(this.unsigned?Os.rem_u:Os.rem_s)(this.low,this.high,e.low,e.high);return Zt(t,Os.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Ce.mod=Ce.modulo;Ce.rem=Ce.modulo;Ce.not=function(){return Zt(~this.low,~this.high,this.unsigned)};Ce.and=function(e){return qn(e)||(e=ei(e)),Zt(this.low&e.low,this.high&e.high,this.unsigned)};Ce.or=function(e){return qn(e)||(e=ei(e)),Zt(this.low|e.low,this.high|e.high,this.unsigned)};Ce.xor=function(e){return qn(e)||(e=ei(e)),Zt(this.low^e.low,this.high^e.high,this.unsigned)};Ce.shiftLeft=function(e){return qn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Zt(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Zt(0,this.low<<e-32,this.unsigned)};Ce.shl=Ce.shiftLeft;Ce.shiftRight=function(e){return qn(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Zt(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Zt(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Ce.shr=Ce.shiftRight;Ce.shiftRightUnsigned=function(e){if(qn(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return Zt(n>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Zt(t,0,this.unsigned):Zt(t>>>e-32,0,this.unsigned)};Ce.shru=Ce.shiftRightUnsigned;Ce.shr_u=Ce.shiftRightUnsigned;Ce.toSigned=function(){return this.unsigned?Zt(this.low,this.high,!1):this};Ce.toUnsigned=function(){return this.unsigned?this:Zt(this.low,this.high,!0)};Ce.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Ce.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Ce.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Yt.fromBytes=function(e,t,n){return n?Yt.fromBytesLE(e,t):Yt.fromBytesBE(e,t)};Yt.fromBytesLE=function(e,t){return new Yt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Yt.fromBytesBE=function(e,t){return new Yt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});var J_=Nr(()=>{});var e1=Nr(()=>{});var w2=Nr((A2,gA)=>{(function(r,e,t){function n(i){var u=this,l=a();u.next=function(){var p=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=p-(u.c=p|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(i),u.s0<0&&(u.s0+=1),u.s1-=l(i),u.s1<0&&(u.s1+=1),u.s2-=l(i),u.s2<0&&(u.s2+=1),l=null}function o(i,u){return u.c=i.c,u.s0=i.s0,u.s1=i.s1,u.s2=i.s2,u}function s(i,u){var l=new n(i),p=u&&u.state,m=l.next;return m.int32=function(){return l.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,p&&(typeof p=="object"&&o(p,l),m.state=function(){return o(l,{})}),m}function a(){var i=4022871197,u=function(l){l=String(l);for(var p=0;p<l.length;p++){i+=l.charCodeAt(p);var m=.02519603282416938*i;i=m>>>0,m-=i,m*=i,i=m>>>0,m-=i,i+=m*4294967296}return(i>>>0)*23283064365386963e-26};return u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(A2,typeof gA=="object"&&gA,typeof define=="function"&&define)});var D2=Nr((N2,bA)=>{(function(r,e,t){function n(a){var i=this,u="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var p=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^p^p>>>8},a===(a|0)?i.x=a:u+=a;for(var l=0;l<u.length+64;l++)i.x^=u.charCodeAt(l)|0,i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(N2,typeof bA=="object"&&bA,typeof define=="function"&&define)});var M2=Nr((_2,yA)=>{(function(r,e,t){function n(a){var i=this,u="";i.next=function(){var p=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(p^p<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:u+=a;for(var l=0;l<u.length+64;l++)i.x^=u.charCodeAt(l)|0,l==u.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(_2,typeof yA=="object"&&yA,typeof define=="function"&&define)});var P2=Nr((R2,TA)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var l=i.x,p=i.i,m,c,d;return m=l[p],m^=m>>>7,c=m^m<<24,m=l[p+1&7],c^=m^m>>>10,m=l[p+3&7],c^=m^m>>>3,m=l[p+4&7],c^=m^m<<7,m=l[p+7&7],m=m^m<<13,c^=m^m<<9,l[p]=c,i.i=p+1&7,c};function u(l,p){var m,c,d=[];if(p===(p|0))c=d[0]=p;else for(p=""+p,m=0;m<p.length;++m)d[m&7]=d[m&7]<<15^p.charCodeAt(m)+d[m+1&7]<<13;for(;d.length<8;)d.push(0);for(m=0;m<8&&d[m]===0;++m);for(m==8?c=d[7]=-1:c=d[m],l.x=d,l.i=0,m=256;m>0;--m)l.next()}u(i,a)}function o(a,i){return i.x=a.x.slice(),i.i=a.i,i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(l.x&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(R2,typeof TA=="object"&&TA,typeof define=="function"&&define)});var F2=Nr((E2,xA)=>{(function(r,e,t){function n(a){var i=this;i.next=function(){var l=i.w,p=i.X,m=i.i,c,d;return i.w=l=l+1640531527|0,d=p[m+34&127],c=p[m=m+1&127],d^=d<<13,c^=c<<17,d^=d>>>15,c^=c>>>12,d=p[m]=d^c,i.i=m,d+(l^l>>>16)|0};function u(l,p){var m,c,d,f,h,g=[],b=128;for(p===(p|0)?(c=p,p=null):(p=p+"\0",c=0,b=Math.max(b,p.length)),d=0,f=-32;f<b;++f)p&&(c^=p.charCodeAt((f+32)%p.length)),f===0&&(h=c),c^=c<<10,c^=c>>>15,c^=c<<4,c^=c>>>13,f>=0&&(h=h+1640531527|0,m=g[f&127]^=c+h,d=m==0?d+1:0);for(d>=128&&(g[(p&&p.length||0)&127]=-1),d=127,f=4*128;f>0;--f)c=g[d+34&127],m=g[d=d+1&127],c^=c<<13,m^=m<<17,c^=c>>>15,m^=m>>>12,g[d]=c^m;l.w=h,l.X=g,l.i=d}u(i,a)}function o(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(l.X&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(E2,typeof xA=="object"&&xA,typeof define=="function"&&define)});var $2=Nr((L2,IA)=>{(function(r,e,t){function n(a){var i=this,u="";i.next=function(){var p=i.b,m=i.c,c=i.d,d=i.a;return p=p<<25^p>>>7^m,m=m-c|0,c=c<<24^c>>>8^d,d=d-p|0,i.b=p=p<<20^p>>>12^m,i.c=m=m-c|0,i.d=c<<16^m>>>16^d,i.a=d-p|0},i.a=0,i.b=0,i.c=-1640531527,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):u+=a;for(var l=0;l<u.length+20;l++)i.b^=u.charCodeAt(l)|0,i.next()}function o(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function s(a,i){var u=new n(a),l=i&&i.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(L2,typeof IA=="object"&&IA,typeof define=="function"&&define)});var B2=Nr(()=>{});var z2=Nr((O2,hy)=>{(function(r,e,t){var n=256,o=6,s=52,a="random",i=t.pow(n,o),u=t.pow(2,s),l=u*2,p=n-1,m;function c(x,I,S){var w=[];I=I==!0?{entropy:!0}:I||{};var _=g(h(I.entropy?[x,T(e)]:x??b(),3),w),M=new d(w),R=function(){for(var E=M.g(o),O=i,G=0;E<u;)E=(E+G)*n,O*=n,G=M.g(1);for(;E>=l;)E/=2,O/=2,G>>>=1;return(E+G)/O};return R.int32=function(){return M.g(4)|0},R.quick=function(){return M.g(4)/4294967296},R.double=R,g(T(M.S),e),(I.pass||S||function(E,O,G,W){return W&&(W.S&&f(W,M),E.state=function(){return f(M,{})}),G?(t[a]=E,O):E})(R,_,"global"in I?I.global:this==t,I.state)}function d(x){var I,S=x.length,w=this,_=0,M=w.i=w.j=0,R=w.S=[];for(S||(x=[S++]);_<n;)R[_]=_++;for(_=0;_<n;_++)R[_]=R[M=p&M+x[_%S]+(I=R[_])],R[M]=I;(w.g=function(E){for(var O,G=0,W=w.i,H=w.j,U=w.S;E--;)O=U[W=p&W+1],G=G*n+U[p&(U[W]=U[H=p&H+O])+(U[H]=O)];return w.i=W,w.j=H,G})(n)}function f(x,I){return I.i=x.i,I.j=x.j,I.S=x.S.slice(),I}function h(x,I){var S=[],w=typeof x,_;if(I&&w=="object")for(_ in x)try{S.push(h(x[_],I-1))}catch{}return S.length?S:w=="string"?x:x+"\0"}function g(x,I){for(var S=x+"",w,_=0;_<S.length;)I[p&_]=p&(w^=I[p&_]*19)+S.charCodeAt(_++);return T(I)}function b(){try{var x;return m&&(x=m.randomBytes)?x=x(n):(x=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(x)),T(x)}catch{var I=r.navigator,S=I&&I.plugins;return[+new Date,r,S,r.screen,T(e)]}}function T(x){return String.fromCharCode.apply(0,x)}if(g(t.random(),e),typeof hy=="object"&&hy.exports){hy.exports=c;try{m=B2()}catch{}}else typeof define=="function"&&define.amd?define(function(){return c}):t["seed"+a]=c})(typeof self<"u"?self:O2,[],Math)});var _h=Nr((jLe,G2)=>{var tZ=w2(),rZ=D2(),nZ=M2(),oZ=P2(),sZ=F2(),aZ=$2(),lp=z2();lp.alea=tZ;lp.xor128=rZ;lp.xorwow=nZ;lp.xorshift7=oZ;lp.xor4096=sZ;lp.tychei=aZ;G2.exports=lp});var Fw=Nr(()=>{});var Tx=Nr(()=>{});var Fg=Nr(()=>{});var _j=Nr(()=>{});var Mj=Nr(()=>{});var Rj=Nr(()=>{});var Pj=Nr((PS,S0)=>{"use strict";var C0=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e){e=e||{};function t(){return ie.buffer!=Je&&rr(ie.buffer),Rt}function n(){return ie.buffer!=Je&&rr(ie.buffer),xt}function o(){return ie.buffer!=Je&&rr(ie.buffer),$t}function s(){return ie.buffer!=Je&&rr(ie.buffer),On}function a(){return ie.buffer!=Je&&rr(ie.buffer),dr}function i(){return ie.buffer!=Je&&rr(ie.buffer),so}function u(){return ie.buffer!=Je&&rr(ie.buffer),Wr}var l=typeof e<"u"?e:{},p,m;l.ready=new Promise(function(L,q){p=L,m=q});var c;typeof process<"u"&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d=Object.assign({},l),f=[],h="./this.program",g=(L,q)=>{throw q},b=typeof window=="object",T=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",I=l.ENVIRONMENT_IS_PTHREAD||!1,S="";function w(L){return l.locateFile?l.locateFile(L,S):S+L}var _,M,R,E;function O(L){if(L instanceof Ul)return;Y("exiting due to exception: "+L)}if(x){T?S=Fg().dirname(S)+"/":S=__dirname+"/";var G,W;typeof hb=="function"&&(G=Tx(),W=Fg()),_=(q,me)=>(q=W.normalize(q),G.readFileSync(q,me?void 0:"utf8")),R=q=>{var me=_(q,!0);return me.buffer||(me=new Uint8Array(me)),me},M=(q,me,ke)=>{q=W.normalize(q),G.readFile(q,function(Be,mt){Be?ke(Be):me(mt.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),f=process.argv.slice(2),process.on("uncaughtException",function(q){if(!(q instanceof Ul))throw q}),process.on("unhandledRejection",function(q){throw q}),g=(q,me)=>{if(fa())throw process.exitCode=q,me;O(me),process.exit(q)},l.inspect=function(){return"[Emscripten Module object]"};let L;try{L=_j()}catch(q){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),q}global.Worker=L.Worker}else(b||T)&&(T?S=self.location.href:typeof document<"u"&&document.currentScript&&(S=document.currentScript.src),r&&(S=r),S.indexOf("blob:")!==0?S=S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):S="",x||(_=L=>{var q=new XMLHttpRequest;return q.open("GET",L,!1),q.send(null),q.responseText},T&&(R=L=>{var q=new XMLHttpRequest;return q.open("GET",L,!1),q.responseType="arraybuffer",q.send(null),new Uint8Array(q.response)}),M=(L,q,me)=>{var ke=new XMLHttpRequest;ke.open("GET",L,!0),ke.responseType="arraybuffer",ke.onload=()=>{if(ke.status==200||ke.status==0&&ke.response){q(ke.response);return}me()},ke.onerror=me,ke.send(null)}),E=L=>document.title=L);x&&typeof performance>"u"&&(global.performance=Mj().performance);var H=console.log.bind(console),U=console.warn.bind(console);x&&(H=L=>G.writeSync(1,L+`
`),U=L=>G.writeSync(2,L+`
`));var V=l.print||H,Y=l.printErr||U;Object.assign(l,d),d=null,l.arguments&&(f=l.arguments),l.thisProgram&&(h=l.thisProgram),l.quit&&(g=l.quit);var j=4,te=Atomics.load,ne=Atomics.store,oe=Atomics.compareExchange,ae;l.wasmBinary&&(ae=l.wasmBinary);var se=l.noExitRuntime||!0;typeof WebAssembly!="object"&&hm("no native wasm support detected");var ie,he,Te=!1,ve;function Pe(L,q){L||hm(q)}var Le=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function je(L,q,me){for(var ke=q+me,Be=q;L[Be]&&!(Be>=ke);)++Be;if(Be-q>16&&L.buffer&&Le)return Le.decode(L.buffer instanceof SharedArrayBuffer?L.slice(q,Be):L.subarray(q,Be));for(var mt="";q<Be;){var Xe=L[q++];if(!(Xe&128)){mt+=String.fromCharCode(Xe);continue}var et=L[q++]&63;if((Xe&224)==192){mt+=String.fromCharCode((Xe&31)<<6|et);continue}var Sr=L[q++]&63;if((Xe&240)==224?Xe=(Xe&15)<<12|et<<6|Sr:Xe=(Xe&7)<<18|et<<12|Sr<<6|L[q++]&63,Xe<65536)mt+=String.fromCharCode(Xe);else{var lo=Xe-65536;mt+=String.fromCharCode(55296|lo>>10,56320|lo&1023)}}return mt}function J(L,q){return L?je(n(),L,q):""}function gt(L,q,me,ke){if(!(ke>0))return 0;for(var Be=me,mt=me+ke-1,Xe=0;Xe<L.length;++Xe){var et=L.charCodeAt(Xe);if(et>=55296&&et<=57343){var Sr=L.charCodeAt(++Xe);et=65536+((et&1023)<<10)|Sr&1023}if(et<=127){if(me>=mt)break;q[me++]=et}else if(et<=2047){if(me+1>=mt)break;q[me++]=192|et>>6,q[me++]=128|et&63}else if(et<=65535){if(me+2>=mt)break;q[me++]=224|et>>12,q[me++]=128|et>>6&63,q[me++]=128|et&63}else{if(me+3>=mt)break;q[me++]=240|et>>18,q[me++]=128|et>>12&63,q[me++]=128|et>>6&63,q[me++]=128|et&63}}return q[me]=0,me-Be}function kt(L,q,me){return gt(L,n(),q,me)}var Je,Rt,xt,$t,Xt,On,dr,so,Wr;I&&(Je=l.buffer);function rr(L){Je=L,l.HEAP8=Rt=new Int8Array(L),l.HEAP16=$t=new Int16Array(L),l.HEAP32=On=new Int32Array(L),l.HEAPU8=xt=new Uint8Array(L),l.HEAPU16=Xt=new Uint16Array(L),l.HEAPU32=dr=new Uint32Array(L),l.HEAPF32=so=new Float32Array(L),l.HEAPF64=Wr=new Float64Array(L)}var Ur=l.INITIAL_MEMORY||16777216;if(I)ie=l.wasmMemory,Je=l.buffer;else if(l.wasmMemory)ie=l.wasmMemory;else if(ie=new WebAssembly.Memory({initial:Ur/65536,maximum:32768,shared:!0}),!(ie.buffer instanceof SharedArrayBuffer))throw Y("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");ie&&(Je=ie.buffer),Ur=Je.byteLength,rr(Je);var Kr,ao=[],io=[],tn=[],qi=!1;function fa(){return se}function Eu(){if(l.preRun)for(typeof l.preRun=="function"&&(l.preRun=[l.preRun]);l.preRun.length;)Yf(l.preRun.shift());Jf(ao)}function Lr(){qi=!0,!I&&Jf(io)}function ji(){if(!I){if(l.postRun)for(typeof l.postRun=="function"&&(l.postRun=[l.postRun]);l.postRun.length;)_0(l.postRun.shift());Jf(tn)}}function Yf(L){ao.unshift(L)}function Zf(L){io.unshift(L)}function _0(L){tn.unshift(L)}var Fu=0,fm=null,Xi=null;function M0(L){Fu++,l.monitorRunDependencies&&l.monitorRunDependencies(Fu)}function R0(L){if(Fu--,l.monitorRunDependencies&&l.monitorRunDependencies(Fu),Fu==0&&(fm!==null&&(clearInterval(fm),fm=null),Xi)){var q=Xi;Xi=null,q()}}function hm(L){I?postMessage({cmd:"onAbort",arg:L}):l.onAbort&&l.onAbort(L),L="Aborted("+L+")",Y(L),Te=!0,ve=1,L+=". Build with -sASSERTIONS for more info.";var q=new WebAssembly.RuntimeError(L);throw m(q),q}var LS="data:application/octet-stream;base64,";function zg(L){return L.startsWith(LS)}function Gg(L){return L.startsWith("file://")}var cn;cn="tfjs-backend-wasm-threaded-simd.wasm",zg(cn)||(cn=w(cn));function Wg(L){try{if(L==cn&&ae)return new Uint8Array(ae);if(R)return R(L);throw"both async and sync fetching of the wasm failed"}catch(q){hm(q)}}function $S(){if(!ae&&(b||T)){if(typeof fetch=="function"&&!Gg(cn))return fetch(cn,{credentials:"same-origin"}).then(function(L){if(!L.ok)throw"failed to load wasm binary file at '"+cn+"'";return L.arrayBuffer()}).catch(function(){return Wg(cn)});if(M)return new Promise(function(L,q){M(cn,function(me){L(new Uint8Array(me))},q)})}return Promise.resolve().then(function(){return Wg(cn)})}function Ug(){var L={env:rb,wasi_snapshot_preview1:rb};function q(Xe,et){var Sr=Xe.exports;if(l.asm=Sr,qS(l.asm._emscripten_tls_init),Kr=l.asm.__indirect_function_table,Zf(l.asm.__wasm_call_ctors),he=et,!I){var lo=Ze.unusedWorkers.length;Ze.unusedWorkers.forEach(function(Zi){Ze.loadWasmModuleToWorker(Zi,function(){--lo||R0("wasm-instantiate")})})}}I||M0("wasm-instantiate");function me(Xe){q(Xe.instance,Xe.module)}function ke(Xe){return $S().then(function(et){return WebAssembly.instantiate(et,L)}).then(function(et){return et}).then(Xe,function(et){Y("failed to asynchronously prepare wasm: "+et),hm(et)})}function Be(){return!ae&&typeof WebAssembly.instantiateStreaming=="function"&&!zg(cn)&&!Gg(cn)&&!x&&typeof fetch=="function"?fetch(cn,{credentials:"same-origin"}).then(function(Xe){var et=WebAssembly.instantiateStreaming(Xe,L);return et.then(me,function(Sr){return Y("wasm streaming compile failed: "+Sr),Y("falling back to ArrayBuffer instantiation"),ke(me)})}):ke(me)}if(l.instantiateWasm)try{var mt=l.instantiateWasm(L,q);return mt}catch(Xe){Y("Module.instantiateWasm callback failed with error: "+Xe),m(Xe)}return Be().catch(m),{}}var P0,E0,BS={};function Ul(L){this.name="ExitStatus",this.message="Program terminated with exit("+L+")",this.status=L}function OS(L){var q=Ze.pthreads[L];delete Ze.pthreads[L],q.terminate(),gv(L),Ze.runningWorkers.splice(Ze.runningWorkers.indexOf(q),1),q.pthread_ptr=0}function Kg(L){var q=Ze.pthreads[L];q.postMessage({cmd:"cancel"})}function Vg(L){var q=Ze.pthreads[L];Pe(q),Ze.returnWorkerToPool(q)}function Hg(L){var q=Ze.getNewWorker();if(!q)return 6;Ze.runningWorkers.push(q),Ze.pthreads[L.pthread_ptr]=q,q.pthread_ptr=L.pthread_ptr;var me={cmd:"run",start_routine:L.startRoutine,arg:L.arg,pthread_ptr:L.pthread_ptr};return q.runPthread=()=>{me.time=performance.now(),q.postMessage(me,L.transferList)},q.loaded&&(q.runPthread(),delete q.runPthread),0}var Qf={varargs:void 0,get:function(){Qf.varargs+=4;var L=s()[Qf.varargs-4>>2];return L},getStr:function(L){var q=J(L);return q}};function zS(L){if(I)return Lu(1,1,L);ve=L,fa()||(Ze.terminateAllThreads(),l.onExit&&l.onExit(L),Te=!0),g(L,new Ul(L))}function GS(L,q){if(ve=L,!q&&I)throw jg(L),"unwind";zS(L)}var qg=GS;function WS(L){if(L instanceof Ul||L=="unwind")return ve;g(1,L)}var Ze={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){I?Ze.initWorker():Ze.initMainThread()},initMainThread:function(){for(var L=8;L--;)Ze.allocateUnusedWorker()},initWorker:function(){se=!1},setExitStatus:function(L){ve=L},terminateAllThreads:function(){for(var L of Object.values(Ze.pthreads))Ze.returnWorkerToPool(L);for(var L of Ze.unusedWorkers)L.terminate();Ze.unusedWorkers=[]},returnWorkerToPool:function(L){var q=L.pthread_ptr;delete Ze.pthreads[q],Ze.unusedWorkers.push(L),Ze.runningWorkers.splice(Ze.runningWorkers.indexOf(L),1),L.pthread_ptr=0,gv(q)},receiveObjectTransfer:function(L){},threadInitTLS:function(){Ze.tlsInitFunctions.forEach(L=>L())},loadWasmModuleToWorker:function(L,q){L.onmessage=me=>{var ke=me.data,Be=ke.cmd;if(L.pthread_ptr&&(Ze.currentProxiedOperationCallerThread=L.pthread_ptr),ke.targetThread&&ke.targetThread!=ub()){var mt=Ze.pthreads[ke.targetThread];mt?mt.postMessage(ke,ke.transferList):Y('Internal error! Worker sent a message "'+Be+'" to target pthread '+ke.targetThread+", but that thread no longer exists!"),Ze.currentProxiedOperationCallerThread=void 0;return}Be==="processProxyingQueue"?eh(ke.queue):Be==="spawnThread"?Hg(ke):Be==="cleanupThread"?Vg(ke.thread):Be==="killThread"?OS(ke.thread):Be==="cancelThread"?Kg(ke.thread):Be==="loaded"?(L.loaded=!0,q&&q(L),L.runPthread&&(L.runPthread(),delete L.runPthread)):Be==="print"?V("Thread "+ke.threadId+": "+ke.text):Be==="printErr"?Y("Thread "+ke.threadId+": "+ke.text):Be==="alert"?alert("Thread "+ke.threadId+": "+ke.text):ke.target==="setimmediate"?L.postMessage(ke):Be==="onAbort"?l.onAbort&&l.onAbort(ke.arg):Be&&Y("worker sent an unknown command "+Be),Ze.currentProxiedOperationCallerThread=void 0},L.onerror=me=>{var ke="worker sent an error!";throw Y(ke+" "+me.filename+":"+me.lineno+": "+me.message),me},x&&(L.on("message",function(me){L.onmessage({data:me})}),L.on("error",function(me){L.onerror(me)}),L.on("detachedExit",function(){})),L.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||r,wasmMemory:ie,wasmModule:he})},allocateUnusedWorker:function(){var L=w("tfjs-backend-wasm-threaded-simd.worker.js");Ze.unusedWorkers.push(new Worker(L))},getNewWorker:function(){return Ze.unusedWorkers.length==0&&(Ze.allocateUnusedWorker(),Ze.loadWasmModuleToWorker(Ze.unusedWorkers[0])),Ze.unusedWorkers.pop()}};l.PThread=Ze;function Jf(L){for(;L.length>0;)L.shift()(l)}function US(L){var q=bv(),me=L();return lb(q),me}function F0(L){return L}function L0(L){var q=/\b_Z[\w\d_]+/g;return L.replace(q,function(me){var ke=me;return me===ke?me:ke+" ["+me+"]"})}function KS(){var L=ub(),q=s()[L+44>>2],me=s()[L+48>>2],ke=q-me;U0(q,ke),lb(q)}l.establishStackSpace=KS;function jg(L){if(I)return Lu(2,0,L);try{qg(L)}catch(q){WS(q)}}var gm=[];function VS(L){var q=gm[L];return q||(L>=gm.length&&(gm.length=L+1),gm[L]=q=Kr.get(L)),q}function HS(L,q){var me=VS(L)(q);fa()?Ze.setExitStatus(me):W0(me)}l.invokeEntryPoint=HS;function $0(){var L=new Error;if(!L.stack){try{throw new Error}catch(q){L=q}if(!L.stack)return"(no stack trace available)"}return L.stack.toString()}function qS(L){Ze.tlsInitFunctions.push(L)}function jS(L,q){t().set(L,q)}function XS(L){O0(L,!T,1,!b),Ze.threadInitTLS()}function YS(L){I?postMessage({cmd:"cleanupThread",thread:L}):Vg(L)}function Xg(L,q,me,ke){return I?Lu(3,1,L,q,me,ke):Yg(L,q,me,ke)}function Yg(L,q,me,ke){if(typeof SharedArrayBuffer>"u")return Y("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var Be=[],mt=0;if(I&&(Be.length===0||mt))return Xg(L,q,me,ke);if(mt)return mt;var Xe={startRoutine:me,pthread_ptr:L,arg:ke,transferList:Be};return I?(Xe.cmd="spawnThread",postMessage(Xe,Be),0):Hg(Xe)}function ZS(){return 2097152}var QS=!0;function JS(){return QS}function eh(L){Atomics.store(s(),L>>2,1),ub()&&G0(L),Atomics.compareExchange(s(),L>>2,1,0)}l.executeNotifiedProxyingQueue=eh;function ek(L,q,me,ke){if(L==q)setTimeout(()=>eh(ke));else if(I)postMessage({targetThread:L,cmd:"processProxyingQueue",queue:ke});else{var Be=Ze.pthreads[L];if(!Be)return;Be.postMessage({cmd:"processProxyingQueue",queue:ke})}return 1}function tk(L,q,me){return-1}function rk(){hm("")}function Kl(L){Kl.shown||(Kl.shown={}),Kl.shown[L]||(Kl.shown[L]=1,x&&(L="warning: "+L),Y(L))}function nk(){x||T||Kl("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function ok(){return Date.now()}function Zg(){return 2147483648}function sk(){return Zg()}var bm;x?bm=()=>{var L=process.hrtime();return L[0]*1e3+L[1]/1e6}:I?bm=()=>performance.now()-l.__performance_now_clock_drift:bm=()=>performance.now();function ak(L,q,me){n().copyWithin(L,q,q+me)}function ik(){return x?Rj().cpus().length:navigator.hardwareConcurrency}function Lu(L,q){var me=arguments.length-2,ke=arguments;return US(()=>{for(var Be=me,mt=pb(Be*8),Xe=mt>>3,et=0;et<me;et++){var Sr=ke[2+et];u()[Xe+et]=Sr}return z0(L,Be,mt,q)})}var th=[];function uk(L,q,me){th.length=q;for(var ke=me>>3,Be=0;Be<q;Be++)th[Be]=u()[ke+Be];var mt=L<0,Xe=mt?BS[-L-1]:gk[L];return Xe.apply(null,th)}function lk(L){try{return ie.grow(L-Je.byteLength+65535>>>16),rr(ie.buffer),1}catch{}}function pk(L){var q=n().length;if(L=L>>>0,L<=q)return!1;var me=Zg();if(L>me)return!1;let ke=(Sr,lo)=>Sr+(lo-Sr%lo)%lo;for(var Be=1;Be<=4;Be*=2){var mt=q*(1+.2/Be);mt=Math.min(mt,L+100663296);var Xe=Math.min(me,ke(Math.max(L,mt),65536)),et=lk(Xe);if(et)return!0}return!1}function mk(){throw"unwind"}function Qg(L){return I?Lu(4,1,L):52}function Jg(L,q,me,ke,Be){return I?Lu(5,1,L,q,me,ke,Be):70}var ck=[null,[],[]];function dk(L,q){var me=ck[L];q===0||q===10?((L===1?V:Y)(je(me,0)),me.length=0):me.push(q)}function eb(L,q,me,ke){if(I)return Lu(6,1,L,q,me,ke);for(var Be=0,mt=0;mt<me;mt++){var Xe=a()[q>>2],et=a()[q+4>>2];q+=8;for(var Sr=0;Sr<et;Sr++)dk(L,n()[Xe+Sr]);Be+=et}return a()[ke>>2]=Be,0}function tb(L){var q=l["_"+L];return q}function fk(L,q,me,ke,Be){var mt={string:zn=>{var Im=0;if(zn!=null&&zn!==0){var H0=(zn.length<<2)+1;Im=pb(H0),kt(zn,Im,H0)}return Im},array:zn=>{var Im=pb(zn.length);return jS(zn,Im),Im}};function Xe(zn){return q==="string"?J(zn):q==="boolean"?Boolean(zn):zn}var et=tb(L),Sr=[],lo=0;if(ke)for(var Zi=0;Zi<ke.length;Zi++){var V0=mt[me[Zi]];V0?(lo===0&&(lo=bv()),Sr[Zi]=V0(ke[Zi])):Sr[Zi]=ke[Zi]}var yv=et.apply(null,Sr);function T6(zn){return lo!==0&&lb(lo),Xe(zn)}return yv=T6(yv),yv}function hk(L,q,me,ke){me=me||[];var Be=me.every(Xe=>Xe==="number"||Xe==="boolean"),mt=q!=="string";return mt&&Be&&!ke?tb(L):function(){return fk(L,q,me,arguments,ke)}}Ze.init();var gk=[null,zS,jg,Xg,Qg,Jg,eb],rb={__emscripten_init_main_thread_js:XS,__emscripten_thread_cleanup:YS,__pthread_create_js:Yg,_emscripten_default_pthread_stack_size:ZS,_emscripten_get_now_is_monotonic:JS,_emscripten_notify_task_queue:ek,_emscripten_set_offscreencanvas_size:tk,abort:rk,emscripten_check_blocking_allowed:nk,emscripten_date_now:ok,emscripten_get_heap_max:sk,emscripten_get_now:bm,emscripten_memcpy_big:ak,emscripten_num_logical_cores:ik,emscripten_receive_on_main_thread_js:uk,emscripten_resize_heap:pk,emscripten_unwind_to_js_event_loop:mk,exit:qg,fd_close:Qg,fd_seek:Jg,fd_write:eb,memory:ie||l.wasmMemory},B0=Ug(),bk=l.___wasm_call_ctors=function(){return(bk=l.___wasm_call_ctors=l.asm.__wasm_call_ctors).apply(null,arguments)},yk=l._init=function(){return(yk=l._init=l.asm.init).apply(null,arguments)},Tk=l._init_with_threads_count=function(){return(Tk=l._init_with_threads_count=l.asm.init_with_threads_count).apply(null,arguments)},xk=l._get_threads_count=function(){return(xk=l._get_threads_count=l.asm.get_threads_count).apply(null,arguments)},Ik=l._register_tensor=function(){return(Ik=l._register_tensor=l.asm.register_tensor).apply(null,arguments)},Ck=l._dispose_data=function(){return(Ck=l._dispose_data=l.asm.dispose_data).apply(null,arguments)},Sk=l._dispose=function(){return(Sk=l._dispose=l.asm.dispose).apply(null,arguments)},kk=l._Abs=function(){return(kk=l._Abs=l.asm.Abs).apply(null,arguments)},vk=l._Add=function(){return(vk=l._Add=l.asm.Add).apply(null,arguments)},Ak=l._AddN=function(){return(Ak=l._AddN=l.asm.AddN).apply(null,arguments)},wk=l._All=function(){return(wk=l._All=l.asm.All).apply(null,arguments)},Nk=l._Any=function(){return(Nk=l._Any=l.asm.Any).apply(null,arguments)},Dk=l._ArgMax=function(){return(Dk=l._ArgMax=l.asm.ArgMax).apply(null,arguments)},_k=l._AvgPool=function(){return(_k=l._AvgPool=l.asm.AvgPool).apply(null,arguments)},Mk=l._BatchMatMul=function(){return(Mk=l._BatchMatMul=l.asm.BatchMatMul).apply(null,arguments)},Rk=l._Ceil=function(){return(Rk=l._Ceil=l.asm.Ceil).apply(null,arguments)},Pk=l._ClipByValue=function(){return(Pk=l._ClipByValue=l.asm.ClipByValue).apply(null,arguments)},Ek=l._Conv2D=function(){return(Ek=l._Conv2D=l.asm.Conv2D).apply(null,arguments)},Fk=l._Conv2DBackpropInput=function(){return(Fk=l._Conv2DBackpropInput=l.asm.Conv2DBackpropInput).apply(null,arguments)},Lk=l._Cos=function(){return(Lk=l._Cos=l.asm.Cos).apply(null,arguments)},$k=l._Cosh=function(){return($k=l._Cosh=l.asm.Cosh).apply(null,arguments)},Bk=l._CropAndResize=function(){return(Bk=l._CropAndResize=l.asm.CropAndResize).apply(null,arguments)},Ok=l._Cumprod=function(){return(Ok=l._Cumprod=l.asm.Cumprod).apply(null,arguments)},zk=l._Cumsum=function(){return(zk=l._Cumsum=l.asm.Cumsum).apply(null,arguments)},Gk=l._DepthToSpace=function(){return(Gk=l._DepthToSpace=l.asm.DepthToSpace).apply(null,arguments)},Wk=l._DepthwiseConv2dNative=function(){return(Wk=l._DepthwiseConv2dNative=l.asm.DepthwiseConv2dNative).apply(null,arguments)},Uk=l._Elu=function(){return(Uk=l._Elu=l.asm.Elu).apply(null,arguments)},Kk=l._Equal=function(){return(Kk=l._Equal=l.asm.Equal).apply(null,arguments)},Vk=l._Exp=function(){return(Vk=l._Exp=l.asm.Exp).apply(null,arguments)},Hk=l._FlipLeftRight=function(){return(Hk=l._FlipLeftRight=l.asm.FlipLeftRight).apply(null,arguments)},qk=l._Floor=function(){return(qk=l._Floor=l.asm.Floor).apply(null,arguments)},jk=l._FloorDiv=function(){return(jk=l._FloorDiv=l.asm.FloorDiv).apply(null,arguments)},Xk=l._FusedBatchNorm=function(){return(Xk=l._FusedBatchNorm=l.asm.FusedBatchNorm).apply(null,arguments)},Yk=l._FusedConv2D=function(){return(Yk=l._FusedConv2D=l.asm.FusedConv2D).apply(null,arguments)},Zk=l._FusedDepthwiseConv2D=function(){return(Zk=l._FusedDepthwiseConv2D=l.asm.FusedDepthwiseConv2D).apply(null,arguments)},Qk=l._Gather=function(){return(Qk=l._Gather=l.asm.Gather).apply(null,arguments)},Jk=l._GatherNd=function(){return(Jk=l._GatherNd=l.asm.GatherNd).apply(null,arguments)},ev=l._Greater=function(){return(ev=l._Greater=l.asm.Greater).apply(null,arguments)},tv=l._GreaterEqual=function(){return(tv=l._GreaterEqual=l.asm.GreaterEqual).apply(null,arguments)},rv=l._IsNan=function(){return(rv=l._IsNan=l.asm.IsNan).apply(null,arguments)},nv=l._LeakyRelu=function(){return(nv=l._LeakyRelu=l.asm.LeakyRelu).apply(null,arguments)},ov=l._Less=function(){return(ov=l._Less=l.asm.Less).apply(null,arguments)},sv=l._LessEqual=function(){return(sv=l._LessEqual=l.asm.LessEqual).apply(null,arguments)},av=l._Log=function(){return(av=l._Log=l.asm.Log).apply(null,arguments)},iv=l._LogicalAnd=function(){return(iv=l._LogicalAnd=l.asm.LogicalAnd).apply(null,arguments)},uv=l._LogicalNot=function(){return(uv=l._LogicalNot=l.asm.LogicalNot).apply(null,arguments)},lv=l._LogicalOr=function(){return(lv=l._LogicalOr=l.asm.LogicalOr).apply(null,arguments)},pv=l._LogicalXor=function(){return(pv=l._LogicalXor=l.asm.LogicalXor).apply(null,arguments)},mv=l._Max=function(){return(mv=l._Max=l.asm.Max).apply(null,arguments)},nb=l._MaxPool=function(){return(nb=l._MaxPool=l.asm.MaxPool).apply(null,arguments)},ob=l._Maximum=function(){return(ob=l._Maximum=l.asm.Maximum).apply(null,arguments)},rh=l._Mean=function(){return(rh=l._Mean=l.asm.Mean).apply(null,arguments)},cv=l._Min=function(){return(cv=l._Min=l.asm.Min).apply(null,arguments)},dv=l._Minimum=function(){return(dv=l._Minimum=l.asm.Minimum).apply(null,arguments)},ym=l._MirrorPad=function(){return(ym=l._MirrorPad=l.asm.MirrorPad).apply(null,arguments)},sb=l._Multiply=function(){return(sb=l._Multiply=l.asm.Multiply).apply(null,arguments)},Tm=l._Neg=function(){return(Tm=l._Neg=l.asm.Neg).apply(null,arguments)},xm=l._NonMaxSuppressionV3=function(){return(xm=l._NonMaxSuppressionV3=l.asm.NonMaxSuppressionV3).apply(null,arguments)},fv=l._NonMaxSuppressionV4=function(){return(fv=l._NonMaxSuppressionV4=l.asm.NonMaxSuppressionV4).apply(null,arguments)},X=l._NonMaxSuppressionV5=function(){return(X=l._NonMaxSuppressionV5=l.asm.NonMaxSuppressionV5).apply(null,arguments)},pe=l._NotEqual=function(){return(pe=l._NotEqual=l.asm.NotEqual).apply(null,arguments)},$e=l._OneHot=function(){return($e=l._OneHot=l.asm.OneHot).apply(null,arguments)},ut=l._PadV2=function(){return(ut=l._PadV2=l.asm.PadV2).apply(null,arguments)},nr=l._Pow=function(){return(nr=l._Pow=l.asm.Pow).apply(null,arguments)},or=l._Prelu=function(){return(or=l._Prelu=l.asm.Prelu).apply(null,arguments)},it=l._Prod=function(){return(it=l._Prod=l.asm.Prod).apply(null,arguments)},at=l._RealDiv=function(){return(at=l._RealDiv=l.asm.RealDiv).apply(null,arguments)},Cr=l._Reciprocal=function(){return(Cr=l._Reciprocal=l.asm.Reciprocal).apply(null,arguments)},uo=l._Relu=function(){return(uo=l._Relu=l.asm.Relu).apply(null,arguments)},Yi=l._Relu6=function(){return(Yi=l._Relu6=l.asm.Relu6).apply(null,arguments)},ab=l._ResizeBilinear=function(){return(ab=l._ResizeBilinear=l.asm.ResizeBilinear).apply(null,arguments)},nh=l._ResizeNearestNeighbor=function(){return(nh=l._ResizeNearestNeighbor=l.asm.ResizeNearestNeighbor).apply(null,arguments)},hv=l._Reverse=function(){return(hv=l._Reverse=l.asm.Reverse).apply(null,arguments)},dn=l._RotateWithOffset=function(){return(dn=l._RotateWithOffset=l.asm.RotateWithOffset).apply(null,arguments)},$u=l._Round=function(){return($u=l._Round=l.asm.Round).apply(null,arguments)},ib=l._Rsqrt=function(){return(ib=l._Rsqrt=l.asm.Rsqrt).apply(null,arguments)},zj=l._ScatterNd=function(){return(zj=l._ScatterNd=l.asm.ScatterNd).apply(null,arguments)},Gj=l._SelectV2=function(){return(Gj=l._SelectV2=l.asm.SelectV2).apply(null,arguments)},Wj=l._Sigmoid=function(){return(Wj=l._Sigmoid=l.asm.Sigmoid).apply(null,arguments)},Uj=l._Sin=function(){return(Uj=l._Sin=l.asm.Sin).apply(null,arguments)},Kj=l._Softmax=function(){return(Kj=l._Softmax=l.asm.Softmax).apply(null,arguments)},Vj=l._SparseFillEmptyRows=function(){return(Vj=l._SparseFillEmptyRows=l.asm.SparseFillEmptyRows).apply(null,arguments)},Hj=l._SparseReshape=function(){return(Hj=l._SparseReshape=l.asm.SparseReshape).apply(null,arguments)},qj=l._SparseSegmentReduction=function(){return(qj=l._SparseSegmentReduction=l.asm.SparseSegmentReduction).apply(null,arguments)},jj=l._Sqrt=function(){return(jj=l._Sqrt=l.asm.Sqrt).apply(null,arguments)},Xj=l._Square=function(){return(Xj=l._Square=l.asm.Square).apply(null,arguments)},Yj=l._SquaredDifference=function(){return(Yj=l._SquaredDifference=l.asm.SquaredDifference).apply(null,arguments)},Zj=l._Step=function(){return(Zj=l._Step=l.asm.Step).apply(null,arguments)},Qj=l._StridedSlice=function(){return(Qj=l._StridedSlice=l.asm.StridedSlice).apply(null,arguments)},Jj=l._Sub=function(){return(Jj=l._Sub=l.asm.Sub).apply(null,arguments)},e6=l._Sum=function(){return(e6=l._Sum=l.asm.Sum).apply(null,arguments)},t6=l._Tan=function(){return(t6=l._Tan=l.asm.Tan).apply(null,arguments)},r6=l._Tanh=function(){return(r6=l._Tanh=l.asm.Tanh).apply(null,arguments)},n6=l._Tile=function(){return(n6=l._Tile=l.asm.Tile).apply(null,arguments)},o6=l._TopK=function(){return(o6=l._TopK=l.asm.TopK).apply(null,arguments)},s6=l._Transform=function(){return(s6=l._Transform=l.asm.Transform).apply(null,arguments)},a6=l._Transpose=function(){return(a6=l._Transpose=l.asm.Transpose).apply(null,arguments)},i6=l.__FusedMatMul=function(){return(i6=l.__FusedMatMul=l.asm._FusedMatMul).apply(null,arguments)},u6=l._malloc=function(){return(u6=l._malloc=l.asm.malloc).apply(null,arguments)},l6=l._free=function(){return(l6=l._free=l.asm.free).apply(null,arguments)},p6=l.__emscripten_tls_init=function(){return(p6=l.__emscripten_tls_init=l.asm._emscripten_tls_init).apply(null,arguments)},ub=l._pthread_self=function(){return(ub=l._pthread_self=l.asm.pthread_self).apply(null,arguments)},m6=l.___errno_location=function(){return(m6=l.___errno_location=l.asm.__errno_location).apply(null,arguments)},O0=l.__emscripten_thread_init=function(){return(O0=l.__emscripten_thread_init=l.asm._emscripten_thread_init).apply(null,arguments)},c6=l.__emscripten_thread_crashed=function(){return(c6=l.__emscripten_thread_crashed=l.asm._emscripten_thread_crashed).apply(null,arguments)},d6=l._emscripten_main_thread_process_queued_calls=function(){return(d6=l._emscripten_main_thread_process_queued_calls=l.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},f6=l._emscripten_main_browser_thread_id=function(){return(f6=l._emscripten_main_browser_thread_id=l.asm.emscripten_main_browser_thread_id).apply(null,arguments)},z0=l._emscripten_run_in_main_runtime_thread_js=function(){return(z0=l._emscripten_run_in_main_runtime_thread_js=l.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},h6=l._emscripten_dispatch_to_thread_=function(){return(h6=l._emscripten_dispatch_to_thread_=l.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},G0=l.__emscripten_proxy_execute_task_queue=function(){return(G0=l.__emscripten_proxy_execute_task_queue=l.asm._emscripten_proxy_execute_task_queue).apply(null,arguments)},gv=l.__emscripten_thread_free_data=function(){return(gv=l.__emscripten_thread_free_data=l.asm._emscripten_thread_free_data).apply(null,arguments)},W0=l.__emscripten_thread_exit=function(){return(W0=l.__emscripten_thread_exit=l.asm._emscripten_thread_exit).apply(null,arguments)},U0=l._emscripten_stack_set_limits=function(){return(U0=l._emscripten_stack_set_limits=l.asm.emscripten_stack_set_limits).apply(null,arguments)},bv=l.stackSave=function(){return(bv=l.stackSave=l.asm.stackSave).apply(null,arguments)},lb=l.stackRestore=function(){return(lb=l.stackRestore=l.asm.stackRestore).apply(null,arguments)},pb=l.stackAlloc=function(){return(pb=l.stackAlloc=l.asm.stackAlloc).apply(null,arguments)},g6=l.dynCall_iijjiiii=function(){return(g6=l.dynCall_iijjiiii=l.asm.dynCall_iijjiiii).apply(null,arguments)},b6=l.dynCall_jiji=function(){return(b6=l.dynCall_jiji=l.asm.dynCall_jiji).apply(null,arguments)};l.keepRuntimeAlive=fa,l.wasmMemory=ie,l.cwrap=hk,l.ExitStatus=Ul,l.PThread=Ze;var mb;Xi=function L(){mb||K0(),mb||(Xi=L)};function K0(L){if(L=L||f,Fu>0)return;if(I){p(l),Lr(),postMessage({cmd:"loaded"});return}if(Eu(),Fu>0)return;function q(){mb||(mb=!0,l.calledRun=!0,!Te&&(Lr(),p(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),ji()))}l.setStatus?(l.setStatus("Running..."),setTimeout(function(){setTimeout(function(){l.setStatus("")},1),q()},1)):q()}if(l.preInit)for(typeof l.preInit=="function"&&(l.preInit=[l.preInit]);l.preInit.length>0;)l.preInit.pop()();K0();var cb;c&&(cb={uncaughtException:process.listeners("uncaughtException").filter(function(L){return!c.uncaughtException.indexOf(L)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(L){return!c.unhandledRejection.indexOf(L)>-1})});var db;if(typeof WasmBackendModule<"u")db=WasmBackendModule;else if(typeof e<"u")db=e;else throw new Error("Could not find wasm module in post.js");if(cb){var y6=db._dispose;db._dispose=function(){y6(),cb.uncaughtException.forEach(function(L){process.removeListener("uncaughtException",L)}),cb.unhandledRejection.forEach(function(L){process.removeListener("unhandledRejection",L)})}}return e.ready}})();typeof PS=="object"&&typeof S0=="object"?S0.exports=C0:typeof define=="function"&&define.amd?define([],function(){return C0}):typeof PS=="object"&&(PS.WasmBackendModuleThreadedSimd=C0)});var Fj=Nr((ES,v0)=>{"use strict";var k0=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(e){e=e||{};var t=typeof e<"u"?e:{},n,o;t.ready=new Promise(function(X,pe){n=X,o=pe});var s;typeof process<"u"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var a=Object.assign({},t),i=[],u="./this.program",l=(X,pe)=>{throw pe},p=typeof window=="object",m=typeof importScripts=="function",c=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",d="";function f(X){return t.locateFile?t.locateFile(X,d):d+X}var h,g,b,T;function x(X){if(X instanceof fm)return;_("exiting due to exception: "+X)}if(c){m?d=Fg().dirname(d)+"/":d=__dirname+"/";var I,S;typeof hb=="function"&&(I=Tx(),S=Fg()),h=(X,pe)=>(X=S.normalize(X),I.readFileSync(X,pe?void 0:"utf8")),b=X=>{var pe=h(X,!0);return pe.buffer||(pe=new Uint8Array(pe)),pe},g=(X,pe,$e)=>{X=S.normalize(X),I.readFile(X,function(ut,nr){ut?$e(ut):pe(nr.buffer)})},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),i=process.argv.slice(2),process.on("uncaughtException",function(X){if(!(X instanceof fm))throw X}),process.on("unhandledRejection",function(X){throw X}),l=(X,pe)=>{if(xt())throw process.exitCode=X,pe;x(pe),process.exit(X)},t.inspect=function(){return"[Emscripten Module object]"}}else(p||m)&&(m?d=self.location.href:typeof document<"u"&&document.currentScript&&(d=document.currentScript.src),r&&(d=r),d.indexOf("blob:")!==0?d=d.substr(0,d.replace(/[?#].*/,"").lastIndexOf("/")+1):d="",h=X=>{var pe=new XMLHttpRequest;return pe.open("GET",X,!1),pe.send(null),pe.responseText},m&&(b=X=>{var pe=new XMLHttpRequest;return pe.open("GET",X,!1),pe.responseType="arraybuffer",pe.send(null),new Uint8Array(pe.response)}),g=(X,pe,$e)=>{var ut=new XMLHttpRequest;ut.open("GET",X,!0),ut.responseType="arraybuffer",ut.onload=()=>{if(ut.status==200||ut.status==0&&ut.response){pe(ut.response);return}$e()},ut.onerror=$e,ut.send(null)},T=X=>document.title=X);var w=t.print||console.log.bind(console),_=t.printErr||console.warn.bind(console);Object.assign(t,a),a=null,t.arguments&&(i=t.arguments),t.thisProgram&&(u=t.thisProgram),t.quit&&(l=t.quit);var M=4,R;t.wasmBinary&&(R=t.wasmBinary);var E=t.noExitRuntime||!0;typeof WebAssembly!="object"&&tn("no native wasm support detected");var O,G=!1,W;function H(X,pe){X||tn(pe)}var U=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function V(X,pe,$e){for(var ut=pe+$e,nr=pe;X[nr]&&!(nr>=ut);)++nr;if(nr-pe>16&&X.buffer&&U)return U.decode(X.subarray(pe,nr));for(var or="";pe<nr;){var it=X[pe++];if(!(it&128)){or+=String.fromCharCode(it);continue}var at=X[pe++]&63;if((it&224)==192){or+=String.fromCharCode((it&31)<<6|at);continue}var Cr=X[pe++]&63;if((it&240)==224?it=(it&15)<<12|at<<6|Cr:it=(it&7)<<18|at<<12|Cr<<6|X[pe++]&63,it<65536)or+=String.fromCharCode(it);else{var uo=it-65536;or+=String.fromCharCode(55296|uo>>10,56320|uo&1023)}}return or}function Y(X,pe){return X?V(ae,X,pe):""}function j(X,pe,$e,ut){if(!(ut>0))return 0;for(var nr=$e,or=$e+ut-1,it=0;it<X.length;++it){var at=X.charCodeAt(it);if(at>=55296&&at<=57343){var Cr=X.charCodeAt(++it);at=65536+((at&1023)<<10)|Cr&1023}if(at<=127){if($e>=or)break;pe[$e++]=at}else if(at<=2047){if($e+1>=or)break;pe[$e++]=192|at>>6,pe[$e++]=128|at&63}else if(at<=65535){if($e+2>=or)break;pe[$e++]=224|at>>12,pe[$e++]=128|at>>6&63,pe[$e++]=128|at&63}else{if($e+3>=or)break;pe[$e++]=240|at>>18,pe[$e++]=128|at>>12&63,pe[$e++]=128|at>>6&63,pe[$e++]=128|at&63}}return pe[$e]=0,$e-nr}function te(X,pe,$e){return j(X,ae,pe,$e)}var ne,oe,ae,se,ie,he,Te,ve,Pe;function Le(X){ne=X,t.HEAP8=oe=new Int8Array(X),t.HEAP16=se=new Int16Array(X),t.HEAP32=he=new Int32Array(X),t.HEAPU8=ae=new Uint8Array(X),t.HEAPU16=ie=new Uint16Array(X),t.HEAPU32=Te=new Uint32Array(X),t.HEAPF32=ve=new Float32Array(X),t.HEAPF64=Pe=new Float64Array(X)}var je=t.INITIAL_MEMORY||16777216,J,gt=[],kt=[],Je=[],Rt=!1;function xt(){return E}function $t(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)dr(t.preRun.shift());Xi(gt)}function Xt(){Rt=!0,Xi(kt)}function On(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)Wr(t.postRun.shift());Xi(Je)}function dr(X){gt.unshift(X)}function so(X){kt.unshift(X)}function Wr(X){Je.unshift(X)}var rr=0,Ur=null,Kr=null;function ao(X){rr++,t.monitorRunDependencies&&t.monitorRunDependencies(rr)}function io(X){if(rr--,t.monitorRunDependencies&&t.monitorRunDependencies(rr),rr==0&&(Ur!==null&&(clearInterval(Ur),Ur=null),Kr)){var pe=Kr;Kr=null,pe()}}function tn(X){t.onAbort&&t.onAbort(X),X="Aborted("+X+")",_(X),G=!0,W=1,X+=". Build with -sASSERTIONS for more info.";var pe=new WebAssembly.RuntimeError(X);throw o(pe),pe}var qi="data:application/octet-stream;base64,";function fa(X){return X.startsWith(qi)}function Eu(X){return X.startsWith("file://")}var Lr;Lr="tfjs-backend-wasm.wasm",fa(Lr)||(Lr=f(Lr));function ji(X){try{if(X==Lr&&R)return new Uint8Array(R);if(b)return b(X);throw"both async and sync fetching of the wasm failed"}catch(pe){tn(pe)}}function Yf(){if(!R&&(p||m)){if(typeof fetch=="function"&&!Eu(Lr))return fetch(Lr,{credentials:"same-origin"}).then(function(X){if(!X.ok)throw"failed to load wasm binary file at '"+Lr+"'";return X.arrayBuffer()}).catch(function(){return ji(Lr)});if(g)return new Promise(function(X,pe){g(Lr,function($e){X(new Uint8Array($e))},pe)})}return Promise.resolve().then(function(){return ji(Lr)})}function Zf(){var X={env:Qf,wasi_snapshot_preview1:Qf};function pe(it,at){var Cr=it.exports;t.asm=Cr,O=t.asm.memory,Le(O.buffer),J=t.asm.__indirect_function_table,so(t.asm.__wasm_call_ctors),io("wasm-instantiate")}ao("wasm-instantiate");function $e(it){pe(it.instance)}function ut(it){return Yf().then(function(at){return WebAssembly.instantiate(at,X)}).then(function(at){return at}).then(it,function(at){_("failed to asynchronously prepare wasm: "+at),tn(at)})}function nr(){return!R&&typeof WebAssembly.instantiateStreaming=="function"&&!fa(Lr)&&!Eu(Lr)&&!c&&typeof fetch=="function"?fetch(Lr,{credentials:"same-origin"}).then(function(it){var at=WebAssembly.instantiateStreaming(it,X);return at.then($e,function(Cr){return _("wasm streaming compile failed: "+Cr),_("falling back to ArrayBuffer instantiation"),ut($e)})}):ut($e)}if(t.instantiateWasm)try{var or=t.instantiateWasm(X,pe);return or}catch(it){_("Module.instantiateWasm callback failed with error: "+it),o(it)}return nr().catch(o),{}}var _0,Fu;function fm(X){this.name="ExitStatus",this.message="Program terminated with exit("+X+")",this.status=X}function Xi(X){for(;X.length>0;)X.shift()(t)}function M0(X){return X}function R0(X){var pe=/\b_Z[\w\d_]+/g;return X.replace(pe,function($e){var ut=$e;return $e===ut?$e:ut+" ["+$e+"]"})}function hm(){var X=new Error;if(!X.stack){try{throw new Error}catch(pe){X=pe}if(!X.stack)return"(no stack trace available)"}return X.stack.toString()}function LS(X,pe){oe.set(X,pe)}function zg(){tn("")}function Gg(X,pe,$e){ae.copyWithin(X,pe,pe+$e)}function cn(){return 2147483648}function Wg(X){try{return O.grow(X-ne.byteLength+65535>>>16),Le(O.buffer),1}catch{}}function $S(X){var pe=ae.length;X=X>>>0;var $e=cn();if(X>$e)return!1;let ut=(Cr,uo)=>Cr+(uo-Cr%uo)%uo;for(var nr=1;nr<=4;nr*=2){var or=pe*(1+.2/nr);or=Math.min(or,X+100663296);var it=Math.min($e,ut(Math.max(X,or),65536)),at=Wg(it);if(at)return!0}return!1}var Ug={varargs:void 0,get:function(){Ug.varargs+=4;var X=he[Ug.varargs-4>>2];return X},getStr:function(X){var pe=Y(X);return pe}};function P0(X){return 52}function E0(X,pe,$e,ut,nr){return 70}var BS=[null,[],[]];function Ul(X,pe){var $e=BS[X];pe===0||pe===10?((X===1?w:_)(V($e,0)),$e.length=0):$e.push(pe)}function OS(X,pe,$e,ut){for(var nr=0,or=0;or<$e;or++){var it=Te[pe>>2],at=Te[pe+4>>2];pe+=8;for(var Cr=0;Cr<at;Cr++)Ul(X,ae[it+Cr]);nr+=at}return Te[ut>>2]=nr,0}function Kg(X){var pe=t["_"+X];return pe}function Vg(X,pe,$e,ut,nr){var or={string:dn=>{var $u=0;if(dn!=null&&dn!==0){var ib=(dn.length<<2)+1;$u=rh(ib),te(dn,$u,ib)}return $u},array:dn=>{var $u=rh(dn.length);return LS(dn,$u),$u}};function it(dn){return pe==="string"?Y(dn):pe==="boolean"?Boolean(dn):dn}var at=Kg(X),Cr=[],uo=0;if(ut)for(var Yi=0;Yi<ut.length;Yi++){var ab=or[$e[Yi]];ab?(uo===0&&(uo=nb()),Cr[Yi]=ab(ut[Yi])):Cr[Yi]=ut[Yi]}var nh=at.apply(null,Cr);function hv(dn){return uo!==0&&ob(uo),it(dn)}return nh=hv(nh),nh}function Hg(X,pe,$e,ut){$e=$e||[];var nr=$e.every(it=>it==="number"||it==="boolean"),or=pe!=="string";return or&&nr&&!ut?Kg(X):function(){return Vg(X,pe,$e,arguments,ut)}}var Qf={abort:zg,emscripten_memcpy_big:Gg,emscripten_resize_heap:$S,fd_close:P0,fd_seek:E0,fd_write:OS},zS=Zf(),GS=t.___wasm_call_ctors=function(){return(GS=t.___wasm_call_ctors=t.asm.__wasm_call_ctors).apply(null,arguments)},qg=t._init=function(){return(qg=t._init=t.asm.init).apply(null,arguments)},WS=t._init_with_threads_count=function(){return(WS=t._init_with_threads_count=t.asm.init_with_threads_count).apply(null,arguments)},Ze=t._get_threads_count=function(){return(Ze=t._get_threads_count=t.asm.get_threads_count).apply(null,arguments)},Jf=t._register_tensor=function(){return(Jf=t._register_tensor=t.asm.register_tensor).apply(null,arguments)},US=t._dispose_data=function(){return(US=t._dispose_data=t.asm.dispose_data).apply(null,arguments)},F0=t._dispose=function(){return(F0=t._dispose=t.asm.dispose).apply(null,arguments)},L0=t._Abs=function(){return(L0=t._Abs=t.asm.Abs).apply(null,arguments)},KS=t._Add=function(){return(KS=t._Add=t.asm.Add).apply(null,arguments)},jg=t._AddN=function(){return(jg=t._AddN=t.asm.AddN).apply(null,arguments)},gm=t._All=function(){return(gm=t._All=t.asm.All).apply(null,arguments)},VS=t._Any=function(){return(VS=t._Any=t.asm.Any).apply(null,arguments)},HS=t._ArgMax=function(){return(HS=t._ArgMax=t.asm.ArgMax).apply(null,arguments)},$0=t._AvgPool=function(){return($0=t._AvgPool=t.asm.AvgPool).apply(null,arguments)},qS=t._BatchMatMul=function(){return(qS=t._BatchMatMul=t.asm.BatchMatMul).apply(null,arguments)},jS=t._Ceil=function(){return(jS=t._Ceil=t.asm.Ceil).apply(null,arguments)},XS=t._ClipByValue=function(){return(XS=t._ClipByValue=t.asm.ClipByValue).apply(null,arguments)},YS=t._Conv2D=function(){return(YS=t._Conv2D=t.asm.Conv2D).apply(null,arguments)},Xg=t._Conv2DBackpropInput=function(){return(Xg=t._Conv2DBackpropInput=t.asm.Conv2DBackpropInput).apply(null,arguments)},Yg=t._Cos=function(){return(Yg=t._Cos=t.asm.Cos).apply(null,arguments)},ZS=t._Cosh=function(){return(ZS=t._Cosh=t.asm.Cosh).apply(null,arguments)},QS=t._CropAndResize=function(){return(QS=t._CropAndResize=t.asm.CropAndResize).apply(null,arguments)},JS=t._Cumprod=function(){return(JS=t._Cumprod=t.asm.Cumprod).apply(null,arguments)},eh=t._Cumsum=function(){return(eh=t._Cumsum=t.asm.Cumsum).apply(null,arguments)},ek=t._DepthToSpace=function(){return(ek=t._DepthToSpace=t.asm.DepthToSpace).apply(null,arguments)},tk=t._DepthwiseConv2dNative=function(){return(tk=t._DepthwiseConv2dNative=t.asm.DepthwiseConv2dNative).apply(null,arguments)},rk=t._Elu=function(){return(rk=t._Elu=t.asm.Elu).apply(null,arguments)},Kl=t._Equal=function(){return(Kl=t._Equal=t.asm.Equal).apply(null,arguments)},nk=t._Exp=function(){return(nk=t._Exp=t.asm.Exp).apply(null,arguments)},ok=t._FlipLeftRight=function(){return(ok=t._FlipLeftRight=t.asm.FlipLeftRight).apply(null,arguments)},Zg=t._Floor=function(){return(Zg=t._Floor=t.asm.Floor).apply(null,arguments)},sk=t._FloorDiv=function(){return(sk=t._FloorDiv=t.asm.FloorDiv).apply(null,arguments)},bm=t._FusedBatchNorm=function(){return(bm=t._FusedBatchNorm=t.asm.FusedBatchNorm).apply(null,arguments)},ak=t._FusedConv2D=function(){return(ak=t._FusedConv2D=t.asm.FusedConv2D).apply(null,arguments)},ik=t._FusedDepthwiseConv2D=function(){return(ik=t._FusedDepthwiseConv2D=t.asm.FusedDepthwiseConv2D).apply(null,arguments)},Lu=t._Gather=function(){return(Lu=t._Gather=t.asm.Gather).apply(null,arguments)},th=t._GatherNd=function(){return(th=t._GatherNd=t.asm.GatherNd).apply(null,arguments)},uk=t._Greater=function(){return(uk=t._Greater=t.asm.Greater).apply(null,arguments)},lk=t._GreaterEqual=function(){return(lk=t._GreaterEqual=t.asm.GreaterEqual).apply(null,arguments)},pk=t._IsNan=function(){return(pk=t._IsNan=t.asm.IsNan).apply(null,arguments)},mk=t._LeakyRelu=function(){return(mk=t._LeakyRelu=t.asm.LeakyRelu).apply(null,arguments)},Qg=t._Less=function(){return(Qg=t._Less=t.asm.Less).apply(null,arguments)},Jg=t._LessEqual=function(){return(Jg=t._LessEqual=t.asm.LessEqual).apply(null,arguments)},ck=t._Log=function(){return(ck=t._Log=t.asm.Log).apply(null,arguments)},dk=t._LogicalAnd=function(){return(dk=t._LogicalAnd=t.asm.LogicalAnd).apply(null,arguments)},eb=t._LogicalNot=function(){return(eb=t._LogicalNot=t.asm.LogicalNot).apply(null,arguments)},tb=t._LogicalOr=function(){return(tb=t._LogicalOr=t.asm.LogicalOr).apply(null,arguments)},fk=t._LogicalXor=function(){return(fk=t._LogicalXor=t.asm.LogicalXor).apply(null,arguments)},hk=t._Max=function(){return(hk=t._Max=t.asm.Max).apply(null,arguments)},gk=t._MaxPool=function(){return(gk=t._MaxPool=t.asm.MaxPool).apply(null,arguments)},rb=t._Maximum=function(){return(rb=t._Maximum=t.asm.Maximum).apply(null,arguments)},B0=t._Mean=function(){return(B0=t._Mean=t.asm.Mean).apply(null,arguments)},bk=t._Min=function(){return(bk=t._Min=t.asm.Min).apply(null,arguments)},yk=t._Minimum=function(){return(yk=t._Minimum=t.asm.Minimum).apply(null,arguments)},Tk=t._MirrorPad=function(){return(Tk=t._MirrorPad=t.asm.MirrorPad).apply(null,arguments)},xk=t._Multiply=function(){return(xk=t._Multiply=t.asm.Multiply).apply(null,arguments)},Ik=t._Neg=function(){return(Ik=t._Neg=t.asm.Neg).apply(null,arguments)},Ck=t._NonMaxSuppressionV3=function(){return(Ck=t._NonMaxSuppressionV3=t.asm.NonMaxSuppressionV3).apply(null,arguments)},Sk=t._NonMaxSuppressionV4=function(){return(Sk=t._NonMaxSuppressionV4=t.asm.NonMaxSuppressionV4).apply(null,arguments)},kk=t._NonMaxSuppressionV5=function(){return(kk=t._NonMaxSuppressionV5=t.asm.NonMaxSuppressionV5).apply(null,arguments)},vk=t._NotEqual=function(){return(vk=t._NotEqual=t.asm.NotEqual).apply(null,arguments)},Ak=t._OneHot=function(){return(Ak=t._OneHot=t.asm.OneHot).apply(null,arguments)},wk=t._PadV2=function(){return(wk=t._PadV2=t.asm.PadV2).apply(null,arguments)},Nk=t._Pow=function(){return(Nk=t._Pow=t.asm.Pow).apply(null,arguments)},Dk=t._Prelu=function(){return(Dk=t._Prelu=t.asm.Prelu).apply(null,arguments)},_k=t._Prod=function(){return(_k=t._Prod=t.asm.Prod).apply(null,arguments)},Mk=t._RealDiv=function(){return(Mk=t._RealDiv=t.asm.RealDiv).apply(null,arguments)},Rk=t._Reciprocal=function(){return(Rk=t._Reciprocal=t.asm.Reciprocal).apply(null,arguments)},Pk=t._Relu=function(){return(Pk=t._Relu=t.asm.Relu).apply(null,arguments)},Ek=t._Relu6=function(){return(Ek=t._Relu6=t.asm.Relu6).apply(null,arguments)},Fk=t._ResizeBilinear=function(){return(Fk=t._ResizeBilinear=t.asm.ResizeBilinear).apply(null,arguments)},Lk=t._ResizeNearestNeighbor=function(){return(Lk=t._ResizeNearestNeighbor=t.asm.ResizeNearestNeighbor).apply(null,arguments)},$k=t._Reverse=function(){return($k=t._Reverse=t.asm.Reverse).apply(null,arguments)},Bk=t._RotateWithOffset=function(){return(Bk=t._RotateWithOffset=t.asm.RotateWithOffset).apply(null,arguments)},Ok=t._Round=function(){return(Ok=t._Round=t.asm.Round).apply(null,arguments)},zk=t._Rsqrt=function(){return(zk=t._Rsqrt=t.asm.Rsqrt).apply(null,arguments)},Gk=t._ScatterNd=function(){return(Gk=t._ScatterNd=t.asm.ScatterNd).apply(null,arguments)},Wk=t._SelectV2=function(){return(Wk=t._SelectV2=t.asm.SelectV2).apply(null,arguments)},Uk=t._Sigmoid=function(){return(Uk=t._Sigmoid=t.asm.Sigmoid).apply(null,arguments)},Kk=t._Sin=function(){return(Kk=t._Sin=t.asm.Sin).apply(null,arguments)},Vk=t._Softmax=function(){return(Vk=t._Softmax=t.asm.Softmax).apply(null,arguments)},Hk=t._SparseFillEmptyRows=function(){return(Hk=t._SparseFillEmptyRows=t.asm.SparseFillEmptyRows).apply(null,arguments)},qk=t._SparseReshape=function(){return(qk=t._SparseReshape=t.asm.SparseReshape).apply(null,arguments)},jk=t._SparseSegmentReduction=function(){return(jk=t._SparseSegmentReduction=t.asm.SparseSegmentReduction).apply(null,arguments)},Xk=t._Sqrt=function(){return(Xk=t._Sqrt=t.asm.Sqrt).apply(null,arguments)},Yk=t._Square=function(){return(Yk=t._Square=t.asm.Square).apply(null,arguments)},Zk=t._SquaredDifference=function(){return(Zk=t._SquaredDifference=t.asm.SquaredDifference).apply(null,arguments)},Qk=t._Step=function(){return(Qk=t._Step=t.asm.Step).apply(null,arguments)},Jk=t._StridedSlice=function(){return(Jk=t._StridedSlice=t.asm.StridedSlice).apply(null,arguments)},ev=t._Sub=function(){return(ev=t._Sub=t.asm.Sub).apply(null,arguments)},tv=t._Sum=function(){return(tv=t._Sum=t.asm.Sum).apply(null,arguments)},rv=t._Tan=function(){return(rv=t._Tan=t.asm.Tan).apply(null,arguments)},nv=t._Tanh=function(){return(nv=t._Tanh=t.asm.Tanh).apply(null,arguments)},ov=t._Tile=function(){return(ov=t._Tile=t.asm.Tile).apply(null,arguments)},sv=t._TopK=function(){return(sv=t._TopK=t.asm.TopK).apply(null,arguments)},av=t._Transform=function(){return(av=t._Transform=t.asm.Transform).apply(null,arguments)},iv=t._Transpose=function(){return(iv=t._Transpose=t.asm.Transpose).apply(null,arguments)},uv=t.__FusedMatMul=function(){return(uv=t.__FusedMatMul=t.asm._FusedMatMul).apply(null,arguments)},lv=t._malloc=function(){return(lv=t._malloc=t.asm.malloc).apply(null,arguments)},pv=t._free=function(){return(pv=t._free=t.asm.free).apply(null,arguments)},mv=t.___errno_location=function(){return(mv=t.___errno_location=t.asm.__errno_location).apply(null,arguments)},nb=t.stackSave=function(){return(nb=t.stackSave=t.asm.stackSave).apply(null,arguments)},ob=t.stackRestore=function(){return(ob=t.stackRestore=t.asm.stackRestore).apply(null,arguments)},rh=t.stackAlloc=function(){return(rh=t.stackAlloc=t.asm.stackAlloc).apply(null,arguments)},cv=t.dynCall_iijjiiii=function(){return(cv=t.dynCall_iijjiiii=t.asm.dynCall_iijjiiii).apply(null,arguments)},dv=t.dynCall_jiji=function(){return(dv=t.dynCall_jiji=t.asm.dynCall_jiji).apply(null,arguments)};t.cwrap=Hg;var ym;Kr=function X(){ym||sb(),ym||(Kr=X)};function sb(X){if(X=X||i,rr>0||($t(),rr>0))return;function pe(){ym||(ym=!0,t.calledRun=!0,!G&&(Xt(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),On()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),pe()},1)):pe()}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();sb();var Tm;s&&(Tm={uncaughtException:process.listeners("uncaughtException").filter(function(X){return!s.uncaughtException.indexOf(X)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(X){return!s.unhandledRejection.indexOf(X)>-1})});var xm;if(typeof e<"u")xm=e;else if(typeof WasmBackendModuleThreadedSimd<"u")xm=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Tm){var fv=xm._dispose;xm._dispose=function(){fv(),Tm.uncaughtException.forEach(function(X){process.removeListener("uncaughtException",X)}),Tm.unhandledRejection.forEach(function(X){process.removeListener("unhandledRejection",X)})}}return e.ready}})();typeof ES=="object"&&typeof v0=="object"?v0.exports=k0:typeof define=="function"&&define.amd?define([],function(){return k0}):typeof ES=="object"&&(ES.WasmBackendModule=k0)});var w6=1e-7,N6=1e-4,ha=class{constructor(e,t){this.backend=e;this.dataMover=t}data=new WeakMap;dataIdsCount=0;get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},po=class{refCount(e){return Gn("refCount")}incRef(e){return Gn("incRef")}timerAvailable(){return!0}time(e){return Gn("time")}read(e){return Gn("read")}readSync(e){return Gn("readSync")}readToGPU(e,t){return Gn("readToGPU")}numDataIds(){return Gn("numDataIds")}disposeData(e,t){return Gn("disposeData")}write(e,t,n){return Gn("write")}move(e,t,n,o,s){return Gn("move")}createTensorFromTexture(e,t,n){return Gn("createTensorFromTexture")}memory(){return Gn("memory")}floatPrecision(){return Gn("floatPrecision")}epsilon(){return this.floatPrecision()===32?w6:N6}dispose(){return Gn("dispose")}};function Gn(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function q0(r){let e=r.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,gb(r,e,t)}function D6(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,gb(r,t,n),gb(e,t,n)}function Cm(r,e,t){return Math.max(r,Math.min(e,t))}function _6(r){return r%2===0?r:r+1}function gb(r,e,t){let n=r[e];r[e]=r[t],r[t]=n}function M6(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function R6(r,e){let t=Math.random();return e*t+(1-t)*r}function P6(r,e){let t=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(e[n]);t+=o*o}return t}function D(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Bt(r,e,t=""){D(Wn(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function mo(r){D(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ga(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||kr(r)&&!t)for(let n=0;n<r.length;++n)ga(r[n],e,t);else e.push(r);return e}function nt(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function E6(r){return r.length===0}function Wn(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Qi(r){return r%1===0}function F6(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let e=Math.exp(2*r);return(e-1)/(e+1)}}function L6(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function $6(r){let e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return q0(e),e}function ql(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function B6(r,e=o=>0,t,n){return new Promise((o,s)=>{let a=0,i=()=>{if(r()){o();return}a++;let u=e(a);if(t!=null&&a>=t){s();return}n!=null?n(i,u):setTimeout(i,u)};i()})}function O6(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=r.slice();return o[n]=e/t,o}function gr(r,e){let t=e.length;return r=r==null?e.map((n,o)=>o):[].concat(r),D(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),D(r.every(n=>Qi(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function Tv(r,e){let t=[],n=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:gr(e,r).sort(),a=0;for(let i=0;i<r.length;++i){if(s!=null){if(s[a]===i&&r[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${r[i]}' is not 1`);(s[a]==null||s[a]>i)&&r[i]===1&&(t.push(r[i]),n.push(i)),s[a]<=i&&a++}r[i]!==1&&(t.push(r[i]),n.push(i))}return{newShape:t,keptDims:n}}function xv(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Iv(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Cv(r,e){for(let t=0;t<r.length;t++){let n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function Sv(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function z6(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function kr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function bb(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function kv(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function ba(r){return typeof r=="string"||r instanceof String}function j0(r){return typeof r=="boolean"}function X0(r){return typeof r=="number"}function Sm(r){return Array.isArray(r)?Sm(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":X0(r)?"float32":ba(r)?"string":j0(r)?"bool":"float32"}function Si(r){return!!(r&&r.constructor&&r.call&&r.apply)}function km(r,e){for(let t=e;t<r;++t)if(r%t===0)return t;return r}function ki(r){let e=r.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function Y0(r,e,t,n=!1){let o=new Array;if(e.length===1){let s=e[0]*(n?2:1);for(let a=0;a<s;a++)o[a]=t[r+a]}else{let s=e[0],a=e.slice(1),i=a.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=Y0(r+u*i,a,t,n)}return o}function Hl(r,e,t=!1){if(r.length===0)return e[0];let n=r.reduce((o,s)=>o*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Y0(0,r,e,t)}function oh(r,e){let t=vm(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function vm(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function G6(r,e){let t=r.reduce((n,o)=>n*o,1);if(e==null||e==="float32")return Hl(r,new Float32Array(t));if(e==="int32")return Hl(r,new Int32Array(t));if(e==="bool")return Hl(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Ut(r){r.forEach(e=>{D(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function W6(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=t[o]*r[o];return n}function U6(r,e,t){if(e===0)return[];if(e===1)return[r];let n=new Array(e);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/t[o]),r-=n[o]*t[o];return n[n.length-1]=r,n}function sh(r){return r&&r.then&&typeof r.then=="function"}var Z0="tfjsflags",ah=class{constructor(e){this.global=e;this.populateURLFlags()}flags={};flagRegistry={};urlFlags={};platformName;platform;getQueryParams=V6;setPlatform(e,t){this.platform!=null&&($().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let o=this.urlFlags[e];$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(sh(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let e=this.getQueryParams(this.global.location.search);Z0 in e&&e[Z0].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=q6(o,s)})}};function V6(r){let e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(H6(e,n[0],n[1]),n.join("="))),e}function H6(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function q6(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function $(){return vv}var vv=null;function Q0(r){vv=r}var Av;function wv(){if(Av==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");Av=r}return Av}function j6(){let r=wv();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function ih(r,e){let t=j6();if(t.has(r))return t.get(r);{let n=e();return t.set(r,n),t.get(r)}}var xs="Abs",ya="Acos",Ta="Acosh",Nn="Add",co="AddN",xa="All",Ia="Any",fo="ArgMax",vi="ArgMin",Ca="Asin",Sa="Asinh",ka="Atan",va="Atanh",Aa="Atan2",ho="AvgPool",Am="AvgPoolGrad",Bu="AvgPool3D",wm="AvgPool3DGrad",go="BatchMatMul",Is="BatchToSpaceND",Ou="Bincount",J0="BroadcastTo",Nm="BroadcastArgs",Un="Cast",bo="Ceil",Kn="ClipByValue",zu="Complex",Gu="ComplexAbs",Cs="Concat",yo="Conv2D",Dm="Conv2DBackpropFilter",To="Conv2DBackpropInput",Wu="Conv3D",_m="Conv3DBackpropFilterV2",Mm="Conv3DBackpropInputV2",xo="Cos",Io="Cosh",wa="Cumprod",Co="Cumsum",Na="CropAndResize",Uu="DenseBincount",Da="DepthToSpace",So="DepthwiseConv2dNative",Rm="DepthwiseConv2dNativeBackpropFilter",Pm="DepthwiseConv2dNativeBackpropInput",Em="Diag",Ku="Dilation2D",uh="Dilation2DBackpropInput",lh="Dilation2DBackpropFilter",ko="RealDiv",Vu="Einsum",vo="Elu",Fm="EluGrad",_a="Erf",Ma="Equal",Ao="Exp",Ss="ExpandDims",Ra="Expm1",Hu="FFT",Ai="Fill",Pa="FlipLeftRight",wo="Floor",No="FloorDiv",Do="FusedBatchNorm",ks="GatherV2",Ea="GatherNd",Fa="Greater",_o="GreaterEqual",Vn="Identity",qu="IFFT",ju="Imag",La="IsFinite",$a="IsInf",Mo="IsNan",Ro="LeakyRelu",Ba="Less",Oa="LessEqual",Lm="LinSpace",Po="Log",za="Log1p",Ga="LogicalAnd",Wa="LogicalNot",Ji="LogicalOr",e_="LogicalXor",t_="LogSoftmax",Hbe="LowerBound",Xu="LRN",$m="LRNGrad",Eo="Max",Fo="Maximum",Lo="MaxPool",Bm="MaxPoolGrad",Yu="MaxPool3D",Om="MaxPool3DGrad",zm="MaxPoolWithArgmax",$o="Mean",Bo="Min",Oo="Minimum",zo="MirrorPad",Ua="Mod",Gm="Multinomial",Go="Multiply",vs="Neg",Ka="NotEqual",Va="NonMaxSuppressionV3",eu="NonMaxSuppressionV4",Ha="NonMaxSuppressionV5",As="OnesLike",Wo="OneHot",ws="Pack",Uo="PadV2",qbe="Pool",Ko="Pow",Vo="Prelu",Ho="Prod",Wm="RaggedGather",Um="RaggedRange",Km="RaggedTensorToTensor",wi="Range",Zu="Real",qo="Reciprocal",jo="Relu",Ns="Reshape",Xo="ResizeNearestNeighbor",Vm="ResizeNearestNeighborGrad",Yo="ResizeBilinear",Hm="ResizeBilinearGrad",Zo="Relu6",Qo="Reverse",qa="Round",Jo="Rsqrt",ja="ScatterNd",Qu="SearchSorted",Ds="Select",tu="Selu",_s="Slice",es="Sin",Xa="Sinh",ru="Sign",ts="Sigmoid",nu="Softplus",rs="Sqrt",ns="Sum",Ms="SpaceToBatchND",Rs="SplitV",os="Softmax",Ju="SparseFillEmptyRows",ou="SparseReshape",el="SparseSegmentMean",tl="SparseSegmentSum",rl="SparseToDense",ss="SquaredDifference",Ni="Square",Ya="StridedSlice",Di="StringNGrams",nl="StringSplit",ol="StringToHashBucketFast",as="Sub",is="Tan",us="Tanh",Dn="Tile",Za="TopK",Qa="Transform",_n="Transpose",qm="Unique",Ps="Unpack",sl="UnsortedSegmentSum",jbe="UpperBound",Es="ZerosLike",Fs="Step",jl="FromPixels",Ja="RotateWithOffset",Ls="_FusedMatMul",$s="FusedConv2D",Bs="FusedDepthwiseConv2D";function _i(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(...r)}function X6(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.log(...r)}var jm=ih("kernelRegistry",()=>new Map),ph=ih("gradRegistry",()=>new Map);function mh(r,e){let t=Dv(r,e);return jm.get(t)}function Nv(r){return ph.get(r)}function yb(r){let e=jm.entries(),t=[];for(;;){let{done:n,value:o}=e.next();if(n)break;let[s,a]=o,[i]=s.split("_");i===r&&t.push(a)}return t}function su(r){let{kernelName:e,backendName:t}=r,n=Dv(e,t);jm.has(n)&&_i(`The kernel '${e}' for backend '${t}' is already registered`),jm.set(n,r)}function n_(r){let{kernelName:e}=r;ph.has(e)&&$().getBool("DEBUG")&&_i(`Overriding the gradient for '${e}'`),ph.set(e,r)}function Jbe(r,e){let t=Dv(r,e);if(!jm.has(t))throw new Error(`The kernel '${r}' for backend '${e}' is not registered`);jm.delete(t)}function eye(r){if(!ph.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);ph.delete(r)}function tye(r,e){yb(r).forEach(n=>{let o=Object.assign({},n,{backendName:e});su(o)})}function Dv(r,e){return`${e}_${r}`}var y={};qe(y,{arraysEqual:()=>Wn,assert:()=>D,assertNonNegativeIntegerDimensions:()=>Ut,assertNonNull:()=>mo,assertShapesMatch:()=>Bt,bytesFromStringArray:()=>kv,bytesPerElement:()=>bb,checkConversionForErrors:()=>Cv,clamp:()=>Cm,computeStrides:()=>ki,createScalarValue:()=>r8,createShuffledIndices:()=>$6,decodeString:()=>Qm,distSquared:()=>P6,encodeString:()=>il,fetch:()=>o8,fingerPrint64:()=>t8,flatten:()=>ga,getArrayFromDType:()=>Iv,getTypedArrayFromDType:()=>xv,hasEncodingLoss:()=>z6,hexToLong:()=>ch,indexToLoc:()=>U6,inferDtype:()=>Sm,inferFromImplicitShape:()=>O6,isBoolean:()=>j0,isFunction:()=>Si,isInt:()=>Qi,isNumber:()=>X0,isPromise:()=>sh,isScalarShape:()=>E6,isString:()=>ba,isTypedArray:()=>kr,isValidDtype:()=>Sv,locToIndex:()=>W6,makeOnesTypedArray:()=>oh,makeZerosNestedTypedArray:()=>G6,makeZerosTypedArray:()=>vm,nearestDivisor:()=>km,nearestLargerEven:()=>_6,now:()=>Jl,parseAxisParam:()=>gr,randUniform:()=>R6,repeatedTry:()=>B6,rightPad:()=>ql,shuffle:()=>q0,shuffleCombo:()=>D6,sizeFromShape:()=>nt,sizeToSquarishShape:()=>L6,squeezeShape:()=>Tv,sum:()=>M6,swap:()=>gb,tanh:()=>F6,toNestedArray:()=>Hl,toTypedArray:()=>Zm});var Pv=Vl(f_());var Ql=Pv.default||Pv;function ch(r){return Ql.fromString(r,!0,16)}var g_=ch("c3a5c85c97cb3127"),Zl=ch("b492b66fbe98f273"),fn=ch("9ae16a3b2f90404f");function Rv(r){return r.xor(r.shru(47))}function b_(r,e,t){let n=r.slice(e,e+t);return Ql.fromBytes(Array.from(n),!0,!0)}function Kt(r,e){return b_(r,e,8)}function h_(r,e){return b_(r,e,4)}function $r(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function al(r,e,t=ch("9ddfea08eb382d69")){let n=r.xor(e).mul(t);n=n.xor(n.shru(47));let o=e.xor(n).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function Z6(r,e,t,n,o,s){o=o.add(r),s=$r(s.add(o).add(n),21);let a=o;return o=o.add(e),o=o.add(t),s=s.add($r(o,44)),[o.add(n),s.add(a)]}function xb(r,e,t,n){return Z6(Kt(r,e),Kt(r,e+8),Kt(r,e+16),Kt(r,e+24),t,n)}function Q6(r,e=r.length){if(e>=8){let t=fn.add(e*2),n=Kt(r,0).add(fn),o=Kt(r,e-8),s=$r(o,37).mul(t).add(n),a=$r(n,25).add(o).mul(t);return al(s,a,t)}if(e>=4){let t=fn.add(e*2),n=h_(r,0);return al(n.shl(3).add(e),h_(r,e-4),t)}if(e>0){let t=r[0],n=r[e>>1],o=r[e-1],s=t+(n<<8),a=e+(o<<2);return Rv(fn.mul(s).xor(g_.mul(a))).mul(fn)}return fn}function J6(r,e=r.length){let t=fn.add(e*2),n=Kt(r,0).mul(Zl),o=Kt(r,8),s=Kt(r,e-8).mul(t),a=Kt(r,e-16).mul(fn);return al($r(n.add(o),43).add($r(s,30)).add(a),n.add($r(o.add(fn),18)).add(s),t)}function e8(r,e=r.length){let t=fn.add(e*2),n=Kt(r,0).mul(fn),o=Kt(r,8),s=Kt(r,e-8).mul(t),a=Kt(r,e-16).mul(fn),i=$r(n.add(o),43).add($r(s,30)).add(a),u=al(i,n.add($r(o.add(fn),18)).add(s),t),l=Kt(r,16).mul(t),p=Kt(r,24),m=i.add(Kt(r,e-32)).mul(t),c=u.add(Kt(r,e-24)).mul(t);return al($r(l.add(p),43).add($r(m,30)).add(c),l.add($r(p.add(n),18)).add(m),t)}function t8(r,e=r.length){let t=Ql.fromNumber(81,!0);if(e<=32)return e<=16?Q6(r,e):J6(r,e);if(e<=64)return e8(r,e);let n=t,o=t.mul(Zl).add(113),s=Rv(o.mul(fn).add(113)).mul(fn),a=[Ql.UZERO,Ql.UZERO],i=[Ql.UZERO,Ql.UZERO];n=n.mul(fn).add(Kt(r,0));let u=0,l=(e-1>>6)*64,p=l+(e-1&63)-63;do n=$r(n.add(o).add(a[0]).add(Kt(r,u+8)),37).mul(Zl),o=$r(o.add(a[1]).add(Kt(r,u+48)),42).mul(Zl),n=n.xor(i[1]),o=o.add(a[0]).add(Kt(r,u+40)),s=$r(s.add(i[0]),33).mul(Zl),a=xb(r,u,a[1].mul(Zl),n.add(i[0])),i=xb(r,u+32,s.add(i[1]),o.add(Kt(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let m=Zl.add(s.and(255).shl(1));return u=p,i[0]=i[0].add(e-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),n=$r(n.add(o).add(a[0]).add(Kt(r,u+8)),37).mul(m),o=$r(o.add(a[1]).add(Kt(r,u+48)),42).mul(m),n=n.xor(i[1].mul(9)),o=o.add(a[0].mul(9).add(Kt(r,u+40))),s=$r(s.add(i[0]),33).mul(m),a=xb(r,u,a[1].mul(m),n.add(i[0])),i=xb(r,u+32,s.add(i[1]),o.add(Kt(r,u+16))),[s,n]=[n,s],al(al(a[0],i[0],m).add(Rv(o).mul(g_)).add(s),al(a[1],i[1],m).add(n),m)}function r8(r,e){return e==="string"?il(r):Zm([r],e)}function n8(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Zm(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=ga(r)),$().getBool("DEBUG")&&Cv(r,e),n8(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){let t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Jl(){return $().platform.now()}function o8(r,e){return $().platform.fetch(r,e)}function il(r,e="utf-8"){return e=e||"utf-8",$().platform.encode(r,e)}function Qm(r,e="utf-8"){return e=e||"utf-8",$().platform.decode(r,e)}var Ib=class{constructor(e,t){this.backendTimer=e;this.logger=t;t==null&&(this.logger=new Ev)}profileKernel(e,t,n){let o,s=()=>{o=n()},a,i=Jl();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();a=Promise.resolve({kernelMs:Jl()-i})}if($().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let p=o[l];p.data().then(m=>{s8(m,p.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:o,inputs:s,extraInfo:a}=e;n.forEach(i=>{Promise.all([i.data(),o,a]).then(u=>{this.logger.logKernelProfile(t,i,u[0],u[1],s,u[2])})})}};function s8(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var Ev=class{logKernelProfile(e,t,n,o,s,a){let i=typeof o=="number"?ql(`${o}ms`,9):o.error,u=ql(e,25),l=t.rank,p=t.size,m=ql(t.shape.toString(),14),c="";for(let d in s){let f=s[d];if(f!=null){let h=f.shape||t.shape,g=h.length;c+=`${d}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${i}	%c${l}D ${m}	%c${p}	%c${c}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function y_(r,e,t){let n={},o={};for(let u=0;u<e.length;u++)n[e[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],p=l.inputs;for(let m in p){let c=p[m],d=!1;for(let f=0;f<e.length;f++)if(n[c.id]){l.outputs.forEach(h=>n[h.id]=!0),d=!0,o[l.id]=!0;break}if(d)break}}let s={};s[t.id]=!0;let a={};for(let u=r.length-1;u>=0;u--){let l=r[u],p=l.inputs;for(let m=0;m<l.outputs.length;m++)if(s[l.outputs[m].id]){for(let c in p)s[p[c].id]=!0,a[l.id]=!0;break}}let i=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&a[l.id]){let p={};for(let c in l.inputs){let d=l.inputs[c];n[d.id]&&(p[c]=d)}let m=Object.assign({},l);m.inputs=p,m.outputs=l.outputs,i.push(m)}}return i}function T_(r,e,t,n){for(let o=e.length-1;o>=0;o--){let s=e[o],a=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?a.push(l):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let i=s.gradient(a);for(let u in s.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);let l=t(()=>i[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let p=s.inputs[u];if(!Wn(l.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${p.shape}'`);if(r[p.id]==null)r[p.id]=l;else{let m=r[p.id];r[p.id]=n(m,l),m.dispose()}}}}var x_=20,dh=3,Fv=7;function I_(r,e,t,n){let o=ki(e),s=a8(r,e,t,o),a=e.length,i=Cb(r,e,t,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${a}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(i.map(l=>"    "+l).join(`
`)),u.join(`
`)}function a8(r,e,t,n){let o=nt(e),s=n[n.length-1],a=new Array(s).fill(0),i=e.length,u=t==="complex64"?hh(r):r;if(i>1)for(let l=0;l<o/s;l++){let p=l*s;for(let m=0;m<s;m++)a[m]=Math.max(a[m],fh(u[p+m],0,t).length)}return a}function fh(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(Fv))} + ${parseFloat(r[1].toFixed(Fv))}j`:ba(r)?n=`'${r}'`:t==="bool"?n=C_(r):n=parseFloat(r.toFixed(Fv)).toString(),ql(n,e)}function C_(r){return r===0?"false":"true"}function Cb(r,e,t,n,o,s=!0){let a=t==="complex64"?2:1,i=e[0],u=e.length;if(u===0){if(t==="complex64"){let h=hh(r);return[fh(h[0],0,t)]}return t==="bool"?[C_(r[0])]:[r[0].toString()]}if(u===1){if(i>x_){let g=dh*a,b=Array.from(r.slice(0,g)),T=Array.from(r.slice((i-dh)*a,i*a));return t==="complex64"&&(b=hh(b),T=hh(T)),["["+b.map((x,I)=>fh(x,o[I],t)).join(", ")+", ..., "+T.map((x,I)=>fh(x,o[i-dh+I],t)).join(", ")+"]"]}return["["+(t==="complex64"?hh(r):Array.from(r)).map((g,b)=>fh(g,o[b],t)).join(", ")+"]"]}let l=e.slice(1),p=n.slice(1),m=n[0]*a,c=[];if(i>x_){for(let h=0;h<dh;h++){let g=h*m,b=g+m;c.push(...Cb(r.slice(g,b),l,t,p,o,!1))}c.push("...");for(let h=i-dh;h<i;h++){let g=h*m,b=g+m;c.push(...Cb(r.slice(g,b),l,t,p,o,h===i-1))}}else for(let h=0;h<i;h++){let g=h*m,b=g+m;c.push(...Cb(r.slice(g,b),l,t,p,o,h===i-1))}let d=u===2?",":"";c[0]="["+c[0]+d;for(let h=1;h<c.length-1;h++)c[h]=" "+c[h]+d;let f=`,
`;for(let h=2;h<u;h++)f+=`
`;return c[c.length-1]=" "+c[c.length-1]+"]"+(s?"":f),c}function hh(r){let e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}var bt=class{constructor(e,t,n){this.dtype=t;if(this.shape=e.slice(),this.size=nt(e),n!=null){let o=n.length;D(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Iv(t,this.size),this.strides=ki(e)}size;shape;strides;values;set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let o=0;o<e.length-1;++o)n+=this.strides[o]*e[o];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ti().makeTensor(this.values,this.shape,this.dtype)}},ti=null,Jm=null,i8=null;function S_(r){ti=r}function k_(r){Jm=r}function v_(r){i8=r}var We=class{id;dataId;shape;size;dtype;rankType;kept=!1;scopeId;strides;constructor(e,t,n,o){this.shape=e.slice(),this.dtype=t||"float32",this.size=nt(e),this.strides=ki(e),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Jm.buffer(this.shape,this.dtype,e)}bufferSync(){return Jm.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Hl(this.shape,e,this.dtype==="complex64")}arraySync(){return Hl(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=ti().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Qm(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),ti().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();let e=ti().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Qm(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await ti().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(ti().disposeTensor(this),this.isDisposedInternal=!0)}isDisposedInternal=!1;get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Jm.print(this,e)}clone(){return this.throwIfDisposed(),Jm.clone(this)}toString(e=!1){let t=this.dataSync();return I_(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Jm.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ti().makeVariable(this,e,t,n)}};Object.defineProperty(We,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function u8(){return ih("Tensor",()=>We)}u8();var au=class extends We{constructor(t,n,o,s){super(t.shape,t.dtype,t.dataId,s);this.trainable=n;this.name=o}name;assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Wn(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);ti().disposeTensor(this),this.dataId=t.dataId,ti().incRef(this,null)}dispose(){ti().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(au,Symbol.hasInstance,{value:r=>r instanceof We&&r.assign!=null&&r.assign instanceof Function});var Ws={};qe(Ws,{assertTypesMatch:()=>Lv,getTensorsInContainer:()=>gh,isTensorInList:()=>p8,makeTypesMatch:()=>Ye});var A_=(i=>(i.R0="R0",i.R1="R1",i.R2="R2",i.R3="R3",i.R4="R4",i.R5="R5",i.R6="R6",i))(A_||{}),w_=(o=>(o.float32="float32",o.int32="int32",o.bool="int32",o.complex64="complex64",o))(w_||{}),N_=(o=>(o.float32="float32",o.int32="int32",o.bool="bool",o.complex64="complex64",o))(N_||{}),D_=(o=>(o.float32="float32",o.int32="float32",o.bool="float32",o.complex64="complex64",o))(D_||{}),__=(o=>(o.float32="complex64",o.int32="complex64",o.bool="complex64",o.complex64="complex64",o))(__||{}),l8={float32:D_,int32:w_,bool:N_,complex64:__};function Pt(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return l8[r][e]}function iu(r){return Pt(r,"int32")}function Ye(r,e){if(r.dtype===e.dtype)return[r,e];let t=Pt(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function Lv(r,e){D(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function p8(r,e){return e.some(t=>t.id===r.id)}function gh(r){let e=[];return M_(r,e,new Set),e}function M_(r,e,t){if(r==null)return;if(r instanceof We){e.push(r);return}if(!m8(r))return;let n=r;for(let o in n){let s=n[o];t.has(s)||(t.add(s),M_(s,e,t))}}function m8(r){return Array.isArray(r)||typeof r=="object"}function $v(r){return r.kernelName!=null}var Sb=class{registeredVariables={};nextTapeNodeId=0;numBytes=0;numTensors=0;numStringTensors=0;numDataBuffers=0;activeTape;gradientDepth=0;kernelDepth=0;activeScope;scopeStack=[];numDataMovesStack=[];nextScopeId=0;tensorInfo=new WeakMap;profiling=!1;activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}};dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},kb=class{constructor(e){this.ENV=e;this.state=new Sb}state;backendName;registry={};registryFactory={};profiler;backendInstance;pendingBackendInit;pendingBackendInitId=0;async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(_i(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Ib(this.backendInstance),!0}setupRegisteredKernels(){yb(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){yb(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof po)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(a=>o<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,_i(`Initialization of backend ${e} failed`),_i(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return _i(`Initialization of backend ${e} failed`),_i(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),o=n.backend,s=this.readSync(t),a=o.refCount(t);o.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=t(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,t,n){e();try{let o=n();return t(),o}catch(o){throw t(),o}}nextTensorId(){return kb.nextTensorId++}nextVariableId(){return kb.nextVariableId++}clone(e){let t=N.runKernel(Vn,{x:e}),n={x:e},o=a=>({x:()=>{let i="float32",u={x:a},l={dtype:i};return N.runKernel(Un,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],o,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(mh(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=o-t-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],o=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u,l=$v(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if($v(e)){let{kernelName:f,inputs:h,attrs:g}=e;this.backendName==null&&this.backend;let b=mh(f,this.backendName);D(b!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{let T=this.backend.numDataIds();u=b.kernelFunc({inputs:h,attrs:g,backend:this.backend});let x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,T,x);let I=x.map(S=>S.rank!=null?S:this.makeTensorFromTensorInfo(S));if(o){let S=this.getTensorsForGradient(f,h,I);n=this.saveTensorsForBackwardMode(S)}return I}}else{let{forwardFunc:f}=e,h=g=>{!o||(n=g.map(b=>this.keep(this.clone(b))))};i=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,h));let b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,b),b}}let{inputs:p,attrs:m}=e,c=$v(e)?null:e.backwardsFunc,d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=i():(d=this.profiler.profileKernel(l,p,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),o&&this.addTapeNode(l,p,t,c,n,m),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(f=>p[f]!=null?p[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let o=Nv(e);if(o!=null){let s=o.inputsToSave||[],a=o.outputsToSave||[],i;o.saveAllInputs?(D(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(t).map(l=>t[l])):i=s.map(l=>t[l]);let u=n.filter((l,p)=>a[p]);return i.concat(u)}return[]}makeTensor(e,t,n,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=e;n==="string"&&ba(e[0])&&(s=e.map(u=>il(u)));let a=o.write(s,t,n),i=new We(t,n,a,this.nextTensorId());if(this.trackTensor(i,o),n==="string"){let u=this.state.tensorInfo.get(a),l=kv(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return i}makeTensorFromDataId(e,t,n,o){n=n||"float32";let s={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(s,o)}makeTensorFromTensorInfo(e,t){let{dataId:n,shape:o,dtype:s}=e,a=new We(o,s,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));let s=new au(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*bb(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof au||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*bb(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,o,s,a){let i={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},u=Nv(e);u!=null&&(o=u.gradFunc),o!=null&&(i.gradient=l=>(l=l.map((p,m)=>{if(p==null){let c=n[m],d=vm(c.size,c.dtype);return this.makeTensor(d,c.shape,c.dtype)}return p}),o(l.length>1?l:l[0],s,a))),this.state.activeTape.push(i)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=gh(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(e,t,n,o=!1){if(D(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(s instanceof We,()=>"The result y returned by f() must be a tensor.");let a=y_(this.state.activeTape,t,s);if(!o&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[s.id]=n??c8(s.shape),T_(i,a,l=>this.tidy(l),d8);let u=t.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let p of l.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(e){return D(Si(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{D(t.every(i=>i instanceof We),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};t.forEach((i,u)=>{o[u]=i});let s=(i,u)=>(n=e(...t,u),D(n.value instanceof We,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(Si(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(i,u)=>{let l=n.gradFunc(i,u),p=Array.isArray(l)?l:[l];D(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(p.every(c=>c instanceof We),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let m={};return p.forEach((c,d)=>{m[d]=()=>c}),m};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){let t=Jl(),n=await this.backend.time(e);return n.wallMs=Jl()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Sb;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},bh=kb;K(bh,"nextTensorId",0),K(bh,"nextVariableId",0);function c8(r){let e=oh(nt(r),"float32");return N.makeTensor(e,r,"float32")}function Bv(){let r=wv();if(r._tfengine==null){let e=new ah(r);r._tfengine=new bh(e)}return Q0(r._tfengine.ENV),S_(()=>r._tfengine),r._tfengine}var N=Bv();function d8(r,e){let t={a:r,b:e};return N.runKernel(Nn,t)}var ul={};qe(ul,{isBrowser:()=>zv,isMobile:()=>g8,mockIsMobile:()=>h8});function f8(){return typeof navigator<"u"&&navigator!=null}var Ov;function h8(r){Ov=r}function g8(r){if(Ov!==void 0)return Ov;if(r||f8()){if(r||(r=navigator),r.product==="ReactNative")return!0;let e=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");if(!e){let t=r;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function zv(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var ls=$();ls.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ls.registerFlag("IS_BROWSER",()=>zv());ls.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ls.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ls.registerFlag("PROD",()=>!1);ls.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ls.getBool("DEBUG"));ls.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ls.registerFlag("IS_TEST",()=>!1);ls.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ls.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ls.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ls.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Vr(r,e){let t=r;if(kr(r))return e==="string"?[]:[r.length];if(typeof r=="object"&&"texture"in r){let o=r.channels||"RGBA";return[r.height,r.width*o.length]}if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(t)||kr(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&$().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&P_(r,n,[]),n}function P_(r,e,t){if(t=t||[],!Array.isArray(r)&&!kr(r)){D(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}D(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),D(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);let n=e.slice(1);for(let o=0;o<r.length;++o)P_(r[o],n,t.concat(o))}function R_(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function v(r,e,t,n="numeric"){if(r instanceof We)return R_(n,r.dtype,e,t),r;let o=Sm(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),R_(n,o,e,t),r==null||!kr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Vr(r,o);!kr(r)&&!Array.isArray(r)&&(r=[r]);let i=o!=="string"?Zm(r,o):ga(r,[],!0);return N.makeTensor(i,s,o)}function uu(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,a)=>v(s,`${e}[${a}]`,t,n))}var Gv="__op";function A(r){let e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+Gv;let o=(...s)=>{N.startScope(t);try{let a=n(...s);return sh(a)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(a),a}catch(a){throw N.endScope(null),a}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}function b8(r,e){let t=v(r,"real","complex"),n=v(e,"imag","complex");Bt(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:t,imag:n};return N.runKernel(zu,o)}var Mn=A({complex_:b8});function hn(r,e,t,n){if(n==null&&(n=Sm(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof r=="object"&&"texture"in r){if(n!=="float32"&&n!=="int32")throw new Error(`Creating tensor from texture only supports 'float32'|'int32' dtype, while the dtype is ${n}.`);return r.channels=r.channels||"RGBA",N.backend.createTensorFromTexture(r,e||t,n)}if(!kr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ut(e);let o=nt(e),s=nt(t);D(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let a=0;a<t.length;++a){let i=t[a],u=a===t.length-1?i!==nt(e.slice(a)):!0;D(t[a]===e[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!kr(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Zm(r,n):ga(r,[],!0),N.makeTensor(r,e,n)}function mr(r,e,t){let n=Vr(r,t);return hn(r,e,n,t)}var yh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var vb=4;async function F_(r,e){let t=[],n=[],o=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<o.length;++a){let i=o[a],u=Array.isArray(r)?r[a].tensor:r[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);let l={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let p=new Promise(async m=>{let c=await u.bytes(),d=c.reduce((g,b)=>g+b.length,0)+vb*c.length,f=new Uint8Array(d),h=0;for(let g=0;g<c.length;g++){let b=c[g],T=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(T,h),h+=vb,f.set(b,h),h+=b.length}m(f)});n.push(p)}else n.push(u.data());e!=null&&(l.group=e),t.push(l)}let s=await Promise.all(n);return{data:y8(s),specs:t}}function Ab(r,e){let t={},n,o=0;for(let s of e){let a=s.name,i=s.dtype,u=s.shape,l=nt(u),p;if("quantization"in s){let m=s.quantization;if(m.dtype==="uint8"||m.dtype==="uint16"){if(!("min"in m&&"scale"in m))throw new Error(`Weight ${s.name} with quantization ${m.dtype} doesn't have corresponding metadata min and scale.`)}else if(m.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${s.name} is quantized with ${m.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${m.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=yh[m.dtype],d=r.slice(o,o+l*c),f=m.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(i==="float32")if(m.dtype==="uint8"||m.dtype==="uint16"){p=new Float32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];p[h]=g*m.scale+m.min}}else if(m.dtype==="float16")n===void 0&&(n=C8()),p=n(f);else throw new Error(`Unsupported quantization type ${m.dtype} for weight type float32.`);else if(i==="int32"){if(m.dtype!=="uint8"&&m.dtype!=="uint16")throw new Error(`Unsupported quantization type ${m.dtype} for weight type int32.`);p=new Int32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];p[h]=Math.round(g*m.scale+m.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=l*c}else if(i==="string"){let m=nt(s.shape);p=[];for(let c=0;c<m;c++){let d=new Uint32Array(r.slice(o,o+vb))[0];o+=vb;let f=new Uint8Array(r.slice(o,o+d));p.push(f),o+=d}}else{let m=yh[i],c=r.slice(o,o+l*m);if(i==="float32")p=new Float32Array(c);else if(i==="int32")p=new Int32Array(c);else if(i==="bool")p=new Uint8Array(c);else if(i==="complex64"){p=new Float32Array(c);let d=new Float32Array(p.length/2),f=new Float32Array(p.length/2);for(let b=0;b<d.length;b++)d[b]=p[b*2],f[b]=p[b*2+1];let h=mr(d,u,"float32"),g=mr(f,u,"float32");t[a]=Mn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=l*m}i!=="complex64"&&(t[a]=mr(p,u,i))}return t}function y8(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0,t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(e),o=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var Wv=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function E_(r){return Wv?Buffer.byteLength(r):new Blob([r]).size}function L_(r){if(Wv)return Buffer.from(r).toString("base64");let e=new Uint8Array(r),t="";for(let n=0,o=e.length;n<o;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function $_(r){if(Wv){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function ec(r){if(r.length===1)return r[0];let e=0;r.forEach(o=>{e+=o.byteLength});let t=new Uint8Array(e),n=0;return r.forEach(o=>{t.set(new Uint8Array(o),n),n+=o.byteLength}),t.buffer}function Uv(r){let e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);let t=r.split(e);return t[t.length-1]}function wb(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(t.initializerSignature=r.initializerSignature),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}function Kv(r,e,t){let n={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(n.trainingConfig=r.trainingConfig),r.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=e,n.weightData=t}return r.signature!=null&&(n.signature=r.signature),r.userDefinedMetadata!=null&&(n.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(n.modelInitializer=r.modelInitializer),r.initializerSignature!=null&&(n.initializerSignature=r.initializerSignature),n}async function tc(r,e){let t,n;return r.weightsManifest!=null&&([t,n]=await e(r.weightsManifest)),Kv(r,t,n)}function Mi(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:E_(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:E_(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function Nb(r){let e=[];for(let t of r)e.push(...t.weights);return e}function T8(){let r=t=>{let n=t<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function x8(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function I8(){let r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function C8(){let r=T8(),e=x8(),t=I8();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let a=0;a<n.length;a++){let i=n[a],u=r[t[i>>10]+(i&1023)]+e[i>>10];s[a]=u}return new Float32Array(o)}}var Us=class{saveRouters;loadRouters;constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Us.instance==null&&(Us.instance=new Us),Us.instance}static registerSaveRouter(e){Us.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Us.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Us.getHandlers(e,"save")}static getLoadHandlers(e,t){return Us.getHandlers(e,"load",t)}static getHandlers(e,t,n){let o=[];return(t==="load"?Us.getInstance().loadRouters:Us.getInstance().saveRouters).forEach(a=>{let i=a(e,n);i!==null&&o.push(i)}),o}},vr=Us;K(vr,"instance");var B_=r=>vr.registerSaveRouter(r),O_=r=>vr.registerLoadRouter(r),z_=r=>vr.getSaveHandlers(r),G_=(r,e)=>vr.getLoadHandlers(r,e);var Vv="tensorflowjs",Hv=1,ep="models_store",ll="model_info_store";function W_(){if(!$().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window>"u"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function qv(r){let e=r.result;e.createObjectStore(ep,{keyPath:"modelPath"}),e.createObjectStore(ll,{keyPath:"modelPath"})}var Ri=class{indexedDB;modelPath;constructor(e){if(this.indexedDB=W_(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,o)=>{let s=this.indexedDB.open(Vv,Hv);s.onupgradeneeded=()=>qv(s),s.onsuccess=()=>{let a=s.result;if(t==null){let i=a.transaction(ep,"readonly"),l=i.objectStore(ep).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=p=>(a.close(),o(l.error)),i.oncomplete=()=>a.close()}else{let i=Mi(t),u=a.transaction(ll,"readwrite"),l=u.objectStore(ll),p=l.put({modelPath:this.modelPath,modelArtifactsInfo:i}),m;p.onsuccess=()=>{m=a.transaction(ep,"readwrite");let d=m.objectStore(ep).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:i});d.onsuccess=()=>n({modelArtifactsInfo:i}),d.onerror=f=>{l=u.objectStore(ll);let h=l.delete(this.modelPath);h.onsuccess=()=>(a.close(),o(d.error)),h.onerror=g=>(a.close(),o(d.error))}},p.onerror=c=>(a.close(),o(p.error)),u.oncomplete=()=>{m==null?a.close():m.oncomplete=()=>a.close()}}},s.onerror=a=>o(s.error)})}};K(Ri,"URL_SCHEME","indexeddb://");var U_=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ri.URL_SCHEME)?S8(r.slice(Ri.URL_SCHEME.length)):null;vr.registerSaveRouter(U_);vr.registerLoadRouter(U_);function S8(r){return new Ri(r)}function k8(r){return r.startsWith(Ri.URL_SCHEME)?r.slice(Ri.URL_SCHEME.length):r}var Db=class{indexedDB;constructor(){this.indexedDB=W_()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(Vv,Hv);n.onupgradeneeded=()=>qv(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(ll,"readonly"),i=s.objectStore(ll).getAll();i.onsuccess=()=>{let u={};for(let l of i.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},i.onerror=u=>(o.close(),t(i.error)),s.oncomplete=()=>o.close()},n.onerror=o=>t(n.error)})}async removeModel(e){return e=k8(e),new Promise((t,n)=>{let o=this.indexedDB.open(Vv,Hv);o.onupgradeneeded=()=>qv(o),o.onsuccess=()=>{let s=o.result,a=s.transaction(ll,"readwrite"),i=a.objectStore(ll),u=i.get(e),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let p=i.delete(e),m=()=>{l=s.transaction(ep,"readwrite");let d=l.objectStore(ep).delete(e);d.onsuccess=()=>t(u.result.modelArtifactsInfo),d.onerror=f=>n(u.error)};p.onsuccess=m,p.onerror=c=>(m(),s.close(),n(u.error))}},u.onerror=p=>(s.close(),n(u.error)),a.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var lu="/",rc="tensorflowjs_models",K_="info",v8="model_topology",A8="weight_specs",w8="weight_data",N8="model_metadata";function V_(r){return{info:[rc,r,K_].join(lu),topology:[rc,r,v8].join(lu),weightSpecs:[rc,r,A8].join(lu),weightData:[rc,r,w8].join(lu),modelMetadata:[rc,r,N8].join(lu)}}function H_(r){for(let e of Object.values(r))window.localStorage.removeItem(e)}function D8(r){let e=r.split(lu);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(lu)}function _8(r){return r.startsWith(Pi.URL_SCHEME)?r.slice(Pi.URL_SCHEME.length):r}var Pi=class{LS;modelPath;keys;constructor(e){if(!$().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=V_(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),o=Mi(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,L_(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch{throw H_(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);t.format=i.format,t.generatedBy=i.generatedBy,t.convertedBy=i.convertedBy,i.signature!=null&&(t.signature=i.signature),i.userDefinedMetadata!=null&&(t.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(t.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(t.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(t.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=$_(a),t}};K(Pi,"URL_SCHEME","localstorage://");var q_=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Pi.URL_SCHEME)?M8(r.slice(Pi.URL_SCHEME.length)):null;vr.registerSaveRouter(q_);vr.registerLoadRouter(q_);function M8(r){return new Pi(r)}var _b=class{LS;constructor(){D($().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=rc+lu,n=lu+K_;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(n)){let a=D8(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=_8(e);let t=V_(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return H_(t),n}};var nc="://",pu=class{managers;constructor(){this.managers={}}static getInstance(){return pu.instance==null&&(pu.instance=new pu),pu.instance}static registerManager(e,t){D(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(nc)&&(e=e.slice(0,e.indexOf(nc))),D(e.length>0,()=>"scheme must not be an empty string.");let n=pu.getInstance();D(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=pu.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(pu.getInstance().managers)}},Ks=pu;K(Ks,"instance");function Mb(r){if(r.indexOf(nc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Ks.getSchemes().join(",")}`);return{scheme:r.split(nc)[0],path:r.split(nc)[1]}}async function j_(r,e,t=!1){D(r!==e,()=>`Old path and new path are the same: '${r}'`);let n=vr.getLoadHandlers(r);D(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),D(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=vr.getSaveHandlers(e);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),D(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);let a=s[0],i=Mb(r).scheme,u=Mb(r).path,l=i===Mb(r).scheme,p=await o.load();t&&l&&await Ks.getManager(i).removeModel(u);let m=await a.save(p);return t&&!l&&await Ks.getManager(i).removeModel(u),m.modelArtifactsInfo}async function X_(){let r=Ks.getSchemes(),e={};for(let t of r){let n=await Ks.getManager(t).listModels();for(let o in n){let s=t+nc+o;e[s]=n[o]}}return e}async function Y_(r){let e=Mb(r);return Ks.getManager(e.scheme).removeModel(e.path)}async function Z_(r,e){return j_(r,e,!1)}async function Q_(r,e){return j_(r,e,!0)}var jv=class{textEncoder;messageName="setTimeoutCustom";functionRefs=[];handledMessageCount=0;hasEventListener=!1;fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!$().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();let o=this.functionRefs[n.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}};if($().get("IS_BROWSER")){$().setPlatform("browser",new jv);try{Ks.registerManager(Pi.URL_SCHEME,new _b)}catch{}try{Ks.registerManager(Ri.URL_SCHEME,new Db)}catch{}}var R8={importFetch:()=>J_()},Xv;var Yv=class{textEncoder;util;constructor(){this.util=e1(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return $().global.fetch!=null?$().global.fetch(e,t):(Xv==null&&(Xv=R8.importFetch()),Xv(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};$().get("IS_NODE")&&!$().get("IS_BROWSER")&&$().setPlatform("node",new Yv);function Ie(r,e="float32",t){return e=e||"float32",Ut(r),new bt(r,e,t)}function P8(r,e){let t=v(r,"x","cast");if(!Sv(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:t},o={dtype:e};return N.runKernel(Un,n,o)}var re=A({cast_:P8});function E8(r){let t={x:v(r,"x","clone","string_or_numeric")};return N.runKernel(Vn,t)}var gn=A({clone_:E8});function Rb(r,e=!1){console.log(r.toString(e))}Bv();var F8={buffer:Ie,cast:re,clone:gn,print:Rb};k_(F8);var Br={};qe(Br,{browserFiles:()=>r1,browserHTTPRequest:()=>s1,concatenateArrayBuffers:()=>ec,copyModel:()=>Z_,decodeWeights:()=>Ab,encodeWeights:()=>F_,fromMemory:()=>a1,fromMemorySync:()=>rA,getLoadHandlers:()=>G_,getModelArtifactsForJSON:()=>tc,getModelArtifactsForJSONSync:()=>Kv,getModelArtifactsInfoForJSON:()=>Mi,getSaveHandlers:()=>z_,getWeightSpecs:()=>Nb,http:()=>Fb,isHTTPScheme:()=>Eb,listModels:()=>X_,loadWeights:()=>n1,moveModel:()=>Q_,registerLoadRouter:()=>O_,registerSaveRouter:()=>B_,removeModel:()=>Y_,weightsLoaderFactory:()=>eA,withSaveHandler:()=>i1,withSaveHandlerSync:()=>u1});var L8="model",$8=".json",B8=".weights.bin";function t1(r){return new Promise(e=>setTimeout(e)).then(r)}var Pb=class{modelJsonFileName;weightDataFileName;modelJsonAnchor;weightDataAnchor;constructor(e){if(!$().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Pb.URL_SCHEME)&&(e=e.slice(Pb.URL_SCHEME.length)),(e==null||e.length===0)&&(e=L8),this.modelJsonFileName=e+$8,this.weightDataFileName=e+B8}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=wb(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await t1(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=t,await t1(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Mi(e)}}}},oc=Pb;K(oc,"URL_SCHEME","downloads://");var Zv=class{jsonFile;weightsFiles;constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),a=s.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}let u=tc(s,l=>this.loadWeights(l));e(u)},n.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let a of e)t.push(...a.weights),n.push(...a.paths);let o=this.checkManifestAndWeightFiles(e),s=n.map(a=>this.loadWeightsFile(a,o[a]));return Promise.all(s).then(a=>[t,ec(a)])}loadWeightsFile(e,t){return new Promise((n,o)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>o(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>Uv(s.name)),o={};for(let s of e)s.paths.forEach(a=>{let i=Uv(a);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);o[a]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},O8=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(oc.URL_SCHEME)?z8(r.slice(oc.URL_SCHEME.length)):null;vr.registerSaveRouter(O8);function z8(r="model"){return new oc(r)}function r1(r){return new Zv(r)}function Qv(r,e,t,n){a(r),t=t??0,n=n??1,i(t,n);let o=0,s=u=>(u.then(l=>{let p=t+ ++o/r.length*(n-t);return e(p),l}),u);function a(u){D(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,l){D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),D(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function Jv(r,e){e==null&&(e={});let t=e.fetchFunc==null?$().platform.fetch:e.fetchFunc,n=r.map(m=>t(m,e.requestInit,{isBinary:!0})),o=0,s=.5,i=(e.onProgress==null?await Promise.all(n):await Qv(n,e.onProgress,o,s)).map(m=>m.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(i):await Qv(i,e.onProgress,u,l)}async function n1(r,e="",t,n){return eA(a=>Jv(a,{requestInit:n}))(r,e,t)}function eA(r){return async(e,t="",n)=>{let o=e.map(()=>!1),s={},a=n!=null?n.map(()=>!1):[],i=[];if(e.forEach((d,f)=>{let h=0;d.weights.forEach(g=>{let b="quantization"in g?g.quantization.dtype:g.dtype,T=yh[b]*nt(g.shape),x=()=>{o[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:h,sizeBytes:T})};n!=null?n.forEach((I,S)=>{I===g.name&&(x(),a[S]=!0)}):x(),i.push(g.name),h+=T})}),!a.every(d=>d)){let d=n.filter((f,h)=>!a[h]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let u=o.reduce((d,f,h)=>(f&&d.push(h),d),[]),l=[];u.forEach(d=>{e[d].paths.forEach(f=>{let h=t+(t.endsWith("/")?"":"/")+f;l.push(h)})});let p=await r(l),m={},c=0;return u.forEach(d=>{let f=e[d].paths.length,h=0;for(let I=0;I<f;I++)h+=p[c+I].byteLength;let g=new ArrayBuffer(h),b=new Uint8Array(g),T=0;for(let I=0;I<f;I++){let S=new Uint8Array(p[c+I]);b.set(S,T),T+=S.byteLength}s[d].forEach(I=>{let S=g.slice(I.groupOffset,I.groupOffset+I.sizeBytes),w=Ab(S,[I.manifestEntry]);for(let _ in w)m[_]=w[_]}),c+=f}),m}}var G8="application/octet-stream",W8="application/json",Th=class{path;requestInit;fetch;weightUrlConverter;DEFAULT_METHOD="POST";weightPathPrefix;onProgress;constructor(e,t){if(t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(D(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=$().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o=wb(e,n);t.body.append("model.json",new Blob([JSON.stringify(o)],{type:W8}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:G8}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:Mi(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=t.modelTopology,o=t.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return tc(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=U8(t),s=this.weightPathPrefix||n,a=Nb(e),i=[],u=[];for(let p of e)for(let m of p.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(m)):i.push(s+m+o);this.weightUrlConverter&&i.push(...await Promise.all(u));let l=await Jv(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,ec(l)]}};K(Th,"URL_SCHEME_REGEX",/^https?:\/\//);function U8(r){let e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),o=t>e?r.substring(t):"";return[n+"/",o]}function Eb(r){return r.match(Th.URL_SCHEME_REGEX)!=null}var o1=(r,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>Eb(n)):t=Eb(r),t)return Fb(r,e)}return null};vr.registerSaveRouter(o1);vr.registerLoadRouter(o1);function Fb(r,e){return new Th(r,e)}function s1(r,e){return Fb(r,e)}var xh=class{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}},Lb=class{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}},tA=class{load;save;constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}};function a1(r,e,t,n){let o=arguments;return new tA(rA(...o))}function rA(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new xh(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new xh({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new xh({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function i1(r){return new Lb(r)}function u1(r){return new Lb(r)}var m1={};qe(m1,{confusionMatrix:()=>p1});function K8(r,e,t=!1,n=!1){let o=v(r,"a","matMul"),s=v(e,"b","matMul");[o,s]=Ye(o,s);let a={a:o,b:s},i={transposeA:t,transposeB:n};return N.runKernel(go,a,i)}var Ue=A({matMul_:K8});function V8(r,e,t=1,n=0,o="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let a={indices:v(r,"indices","oneHot","int32")},i={dtype:o,depth:e,onValue:t,offValue:n};return N.runKernel(Wo,a,i)}var pl=A({oneHot_:V8});function ZIe(){$().set("PROD",!0)}function QIe(){$().set("DEBUG",!0)}function JIe(){$().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function nA(r){$().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}v_(nA);function eCe(){N.disposeVariables()}function rn(){return N}function Ih(){return N.memory()}function tCe(r){return N.profile(r)}function z(r,e){return N.tidy(r,e)}function _e(r){gh(r).forEach(t=>t.dispose())}function Et(r){return N.keep(r)}function rCe(r){return N.time(r)}function H8(r){return N.setBackend(r)}function nCe(){return N.ready()}function oCe(){return N.backendName}function sCe(r){N.removeBackend(r)}function aCe(r){return N.findBackend(r)}function iCe(r){return N.findBackendFactory(r)}function ml(r,e,t=1){return N.registerBackend(r,e,t)}function l1(){return N.backend}function uCe(r,e){$().setPlatform(r,e)}function q8(r){let t={input:v(r,"input","imag")};return N.runKernel(ju,t)}var cl=A({imag_:q8});function j8(r){let t={x:v(r,"x","neg")};return N.runKernel(vs,t)}var tt=A({neg_:j8});function X8(r){let t={input:v(r,"input","real")};return N.runKernel(Zu,t)}var mu=A({real_:X8});function Y8(r,e,t){let n=v(r,"x","transpose");if(e==null&&(e=n.shape.map((a,i)=>i).reverse()),D(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(a=>{D(a>=0&&a<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();let o={x:n},s={perm:e};return n.dtype==="complex64"?z(()=>{let a=mu(n),i=cl(n);return a=N.runKernel(_n,{x:a},s),i=N.runKernel(_n,{x:i},s),t&&(i=tt(i)),Mn(a,i)}):N.runKernel(_n,o,s)}var Ge=A({transpose_:Y8});function Z8(r,e,t){let n=v(r,"labels","confusionMatrix"),o=v(e,"predictions","confusionMatrix");D(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),D(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),D(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),D(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),D(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=pl(re(n,"int32"),t),a=pl(re(o,"int32"),t),i=Ge(s),u=Ue(i,a);return re(u,"int32")}var p1=A({confusionMatrix_:Z8});var Dr={};qe(Dr,{assertAndGetBroadcastShape:()=>Oe,getBroadcastDims:()=>c1,getReductionAxes:()=>vt});function c1(r,e){let t=r.length,n=[];for(let o=0;o<t;o++){let s=t-1-o,a=r[s]||1;(e[e.length-1-o]||1)>1&&a===1&&n.unshift(s)}return n}function vt(r,e){let t=[];for(let n=0;n<e.length;n++){let o=r[r.length-n-1],s=e.length-n-1,a=e[s];(o==null||o===1&&a>1)&&t.unshift(s)}return t}function Oe(r,e){let t=[],n=Math.max(r.length,e.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let a=e[e.length-o-1];if(a==null&&(a=1),s===1)t.unshift(a);else if(a===1)t.unshift(s);else if(s!==a){let i=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(i)}else t.unshift(s)}return t}var Bb={};qe(Bb,{fromPixels:()=>o5,fromPixelsAsync:()=>r5,toPixels:()=>n5});function $b(r,e,t){if(mo(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Vr(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return hn(r,e,n,t)}var tp;function d1(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,o=!1,s=!1,a=!1,i=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(mh(jl,N.backendName)!=null){let f={pixels:r},h={numChannels:e};return N.runKernel(jl,f,h)}let[l,p]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],m;if(a)m=r.getContext("2d").getImageData(0,0,l,p).data;else if(n||t)m=r.data;else if(s||o||i){if(tp==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")tp=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else tp=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});tp.canvas.width=l,tp.canvas.height=p,tp.drawImage(r,0,0,l,p),m=tp.getImageData(0,0,l,p).data}let c;if(e===4)c=new Int32Array(m);else{let f=l*p;c=new Int32Array(f*e);for(let h=0;h<f;h++)for(let g=0;g<e;++g)c[h*e+g]=m[h*4+g]}return $b(c,[p,l,e],"int32")}function Q8(r){return r!=null&&r.data instanceof Uint8Array}function J8(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function e5(r){return r!=null&&r.width!==0&&r.height!==0}function t5(r){return J8()&&!(r instanceof ImageBitmap)&&e5(r)&&!Q8(r)}async function r5(r,e=3){let t=null;if($().getBool("WRAP_TO_IMAGEBITMAP")&&t5(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===r.width&&n.height===r.height?t=n:t=r}else t=r;return d1(t,e)}async function n5(r,e){let t=v(r,"img","toPixels");if(!(r instanceof We)){let l=t;t=re(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let[n,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);let a=await t.data(),i=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let p=[0,0,0,255];for(let c=0;c<s;c++){let d=a[l*s+c];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(p[0]=d*i,p[1]=d*i,p[2]=d*i):p[c]=d*i}let m=l*4;u[m+0]=Math.round(p[0]),u[m+1]=Math.round(p[1]),u[m+2]=Math.round(p[2]),u[m+3]=Math.round(p[3])}if(e!=null){e.width=o,e.height=n;let l=e.getContext("2d"),p=new ImageData(u,o,n);l.putImageData(p,0,0)}return t!==r&&t.dispose(),u}var o5=A({fromPixels_:d1});var Ob={};qe(Ob,{prepareAndValidate:()=>f1});function f1(r,e){let t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(nt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=e.shape,s=o[o.length-1],a=1;for(let m=0;m<o.length-1;++m)a*=o[m];let i=r.shape,u=o.slice();u.pop();let l=1;for(let m=s;m<t;++m)l*=i[m],u.push(i[m]);let p=[...ki(r.shape).map(m=>m/l),1].slice(0,s);return[u,a,l,p]}var Ch={};qe(Ch,{calculateShapes:()=>h1,validateInput:()=>zb,validateUpdateShape:()=>oA});function oA(r,e,t){let n=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(t.rank-o))throw new Error(s+` Output shape length < ${n+(t.rank-o)}`);if(t.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let a=0;a<o;++a)if(t.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-o;++a)if(t.shape[a+o]!==r[a+n])throw new Error(s+` updates.shape[${a+o}] (${t.shape[a+o]}) != shape[${a+o}] (${r[a+o]})`)}function zb(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}oA(t,e,r)}function h1(r,e,t){let n=e.shape.length,o=n>1?e.shape[n-1]:1,s=t.length,a=1;for(let m=o;m<s;++m)a*=t[m];let i=o<1?1:o,u=nt(e.shape)/i,l=[...ki(t.slice(0,o)),1],p=nt(t);return{sliceRank:o,numUpdates:u,sliceSize:a,strides:l,outputSize:p}}var It={};qe(It,{assertParamsValid:()=>a5,computeFlatOffset:()=>m5,computeOutShape:()=>u5,getNormalizedAxes:()=>l5,isSliceContinous:()=>p5,maskToAxes:()=>i5,parseSliceParams:()=>aA,sliceInfo:()=>c5,startForAxis:()=>S1,startIndicesWithElidedDims:()=>x1,stopForAxis:()=>k1,stopIndicesWithElidedDims:()=>I1,stridesForAxis:()=>C1,stridesWithElidedDims:()=>b1});var sA=-2,s5=-1;function a5(r,e,t){let n=r.shape.length;D(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),D(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)D(e[o]+t[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function i5(r){let e=[],t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function u5(r,e,t){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((e[o]-r[o])/t[o]);return n}function b1(r,e,t,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function y1(r,e,t){return t<=r?t:t-(e-1)}function T1(r,e){let t=[];for(let n=0;n<r;n++)t.push(e+n);return t}function l5(r,e,t,n,o,s,a,i,u){let l=r.length,p=new Array(l),m=new Array(l),c=new Array(l);if(e.length&&t>0){let d=e[0],f=t+1;p=x1(a,d,f,n,r),m=I1(i,d,f,o,r),c=b1(s,d,f,r)}else for(let d=0;d<l;d++)p[d]=S1(a,n,s,r,d,u),m[d]=k1(i,o,s,r,d,u),c[d]=C1(s,d,u);return{begin:p,end:m,strides:c}}function x1(r,e,t,n,o){let s=[...o],a=T1(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{let u=y1(e,t,i),l=n[u];r&1<<u&&(l=0),s[i]=l}return s}function I1(r,e,t,n,o){let s=[...o],a=T1(t,e);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{let u=y1(e,t,i),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[i]=l}for(let i=0;i<s.length;i++){let u=o[i];s[i]<0&&(s[i]+=u),s[i]=Cm(0,s[i],o[i])}return s}function C1(r,e,t){let n=r[e];return(t&1<<e||n==null)&&(n=1),n}function S1(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),a=Cm(0,a,u-1),a}function k1(r,e,t,n,o,s){let a=e[o],i=t[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),i>0?a=Cm(0,a,u):a=Cm(-1,a,u-1),a}function p5(r,e,t){let n=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){n=o;break}for(let o=n+1;o<t.length;o++)if(e[o]>0||t[o]!==r[o])return!1;return!0}function m5(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function aA(r,e,t){let n,o=r.shape.length;typeof e=="number"?n=[e,...new Array(o-1).fill(0)]:e.length<o?n=e.concat(new Array(o-e.length).fill(0)):n=e.slice(),n.forEach(a=>{D(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((a,i)=>a>=0?a:(D(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),r.shape[i]-n[i])),[n,s]}function c5(r,e,t,n,o,s,a,i,u){let l;if(n==null?(l=new Array(e.length),l.fill(1)):l=n,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1,m={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};for(let x=0;x<m.dims;x++)p&&(1<<x&i)!==0&&m.numAddAxisAfterEllipsis++,1<<x&a&&(p=!0);p||(m.ellipsisMask|=1<<m.dims,m.dims++);let c={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};d5(m,c);let d=!0,f=!0,h=!0,g=[],b=[];for(let x=0;x<r.length;++x){if(c.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);let I=!!(c.shrinkAxisMask&1<<x),S=r[x];if(S===-1){g.push(I?1:-1);continue}let w=[c.beginMask&1<<x,c.endMask&1<<x],_=[c.strides[x]>0?0:-1,c.strides[x]>0?S:S-1];if(I&&c.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&c.strides[x]===1;let M=!!(c.beginMask&1<<x&&c.endMask&1<<x);if(c.beginValid&&c.endValid){if(I){let G=c.begin[x]<0?S+c.begin[x]:c.begin[x];if(c.begin[x]=G,c.end[x]=c.begin[x]+1,G<0||G>=S)throw Error(`slice index ${c.begin[x]} of dimension ${x} out of bounds.`)}else c.begin[x]=g1(c.begin[x],0,c.strides[x],S,w,_),c.end[x]=g1(c.end[x],1,c.strides[x],S,w,_);let O=c.strides[x]===1&&c.begin[x]===0&&c.end[x]===S;d=d&&O,f=f&&(x===0&&c.strides[x]===1||O)}else d=d&&c.strides[x]===1&&M,f=f&&(x===0&&c.strides[x]===1||M);let R,E=!1;if(c.beginValid&&c.endValid?(R=c.end[x]-c.begin[x],E=!0):I?(R=1,E=!0):M&&S>=0&&(c.strides[x]<0?R=-S:R=S,E=!0),E){let O;R===0||R<0!=c.strides[x]<0?O=0:O=Math.trunc(R/c.strides[x])+(R%c.strides[x]!==0?1:0),g.push(O)}else g.push(-1)}for(let x=0;x<c.finalShapeGatherIndices.length;++x){let I=c.finalShapeGatherIndices[x];I>=0?b.push(g[I]):I===sA&&b.push(1)}return{finalShapeSparse:b.filter((x,I)=>c.finalShapeGatherIndices[I]!==sA),finalShape:b,isIdentity:d,sliceDim0:f,isSimpleSlice:h,begin:c.begin,end:c.end,strides:c.strides}}function d5(r,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=r.begin!=null,e.endValid=r.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(e.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,e.dims);for(;t<o;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&r.newAxisMask)e.finalShapeGatherIndices.push(sA),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);r.begin!=null&&(e.begin[t]=r.begin[n]),r.end!=null&&(e.end[t]=r.end[n]),e.strides[t]=r.strides[n],r.beginMask&1<<n&&(e.beginMask|=1<<t),r.endMask&1<<n&&(e.endMask|=1<<t),r.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(s5),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function g1(r,e,t,n,o,s){if(o[e])return t>0?s[e]:s[e+1&1];{let a=r<0?n+r:r;return a<s[0]?s[0]:a>s[1]?s[1]:a}}var Q={};qe(Q,{Serializable:()=>kh,SerializationMap:()=>Sh,registerClass:()=>Rn});var kh=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},rp=class{classNameMap;constructor(){this.classNameMap={}}static getMap(){return rp.instance==null&&(rp.instance=new rp),rp.instance}static register(e){rp.getMap().classNameMap[e.className]=[e,e.fromConfig]}},Sh=rp;K(Sh,"instance");function Rn(r){D(r.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),D(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Sh.register(r)}var N1={};qe(N1,{TEST_EPSILON_FLOAT16:()=>v1,createVideoElement:()=>x5,encodeStrings:()=>w1,expectArrayBuffersEqual:()=>T5,expectArraysClose:()=>h5,expectArraysEqual:()=>b5,expectNumbersClose:()=>A1,expectPromiseToFail:()=>g5,expectValuesInRange:()=>y5,play:()=>I5,testEpsilon:()=>Gb});var f5=.001,v1=.1;function h5(r,e,t){return t==null&&(t=Gb()),iA(r,e,(n,o)=>uA(n,o,t))}function Gb(){return N.backend.floatPrecision()===32?f5:v1}function iA(r,e,t){let n=!0;if((kr(r)||kr(e))&&(n=!1),kr(r)&&kr(e)&&(n=!0),n){let a=r.constructor.name,i=e.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(r)&&Array.isArray(e)){let a=Vr(r),i=Vr(e);if(!Wn(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let o=kr(r)?r:ga(r),s=kr(e)?e:ga(e);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){let i=o[a],u=s[a];if(!t(i,u))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function g5(r,e){r().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function b5(r,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return ba(r)||ba(r[0])||ba(e)||ba(e[0])?iA(r,t,(n,o)=>n==o):iA(r,e,(n,o)=>uA(n,o,0))}function A1(r,e,t){if(t==null&&(t=Gb()),!uA(r,e,t))throw new Error(`Numbers differ: actual === ${r}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function uA(r,e,t){return!isFinite(r)&&!isFinite(e)?!0:!(isNaN(r)||isNaN(e)||Math.abs(r-e)>t)}function y5(r,e,t){for(let n=0;n<r.length;n++)if(r[n]<e||r[n]>t)throw new Error(`Value out of range:${r[n]} low: ${e}, high: ${t}`)}function T5(r,e){let t=new Float32Array(r),n=new Float32Array(e);if(t.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${t.length}`);for(let o=0;o<n.length;o++)if(t[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${n[o]} but got ${t[o]} instead`)}function w1(r){for(let e=0;e<r.length;e++){let t=r[e];Array.isArray(t)?w1(t):r[e]=il(t)}return r}function x5(r){let e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(r),new Promise(t=>{e.addEventListener("loadeddata",n=>t(e)),e.load()})}async function I5(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(e=>{r.requestVideoFrameCallback(e)})}var C5="0.0.0";function S5(r,e){let t=v(r,"a","add"),n=v(e,"b","add");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Nn,o)}var Z=A({add_:S5});function k5(r,e){let t=v(r,"a","floorDiv"),n=v(e,"b","floorDiv");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(No,o)}var Wb=A({floorDiv_:k5});function v5(r,e){let t=v(r,"a","div"),n=v(e,"b","div");if([t,n]=Ye(t,n),t.dtype==="int32"&&n.dtype==="int32")return Wb(t,n);let o={a:t,b:n},s={};return N.runKernel(ko,o,s)}var fe=A({div_:v5});function A5(r,e){let t=v(r,"a","mul"),n=v(e,"b","mul");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Go,o)}var P=A({mul_:A5});function w5(r){let e=v(r,"x","abs");if(e.dtype==="complex64"){let t={x:e};return N.runKernel(Gu,t)}else{let t={x:e};return N.runKernel(xs,t)}}var Ot=A({abs_:w5});function N5(r){let t={x:v(r,"x","acos")};return N.runKernel(ya,t)}var D1=A({acos_:N5});function D5(r){let t={x:v(r,"x","acosh")};return N.runKernel(Ta,t)}var _1=A({acosh_:D5});function _5(r){D(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),D(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let e=r.map((o,s)=>v(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!Wn(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=e;return N.runKernel(co,n)}var M1=A({addN_:_5});function M5(r,e=null,t=!1){let o={x:v(r,"x","all","bool")},s={axis:e,keepDims:t};return N.runKernel(xa,o,s)}var Ub=A({all_:M5});function R5(r,e=null,t=!1){let o={x:v(r,"x","any","bool")},s={axis:e,keepDims:t};return N.runKernel(Ia,o,s)}var vh=A({any_:R5});function P5(r,e=0){let n={x:v(r,"x","argMax")},o={axis:e};return N.runKernel(fo,n,o)}var dl=A({argMax_:P5});function E5(r,e=0){let n={x:v(r,"x","argMin")},o={axis:e};return N.runKernel(vi,n,o)}var R1=A({argMin_:E5});function F5(r){let t={x:v(r,"x","asin")};return N.runKernel(Ca,t)}var P1=A({asin_:F5});function L5(r){let t={x:v(r,"x","asinh")};return N.runKernel(Sa,t)}var E1=A({asinh_:L5});function $5(r){let t={x:v(r,"x","atan")};return N.runKernel(ka,t)}var F1=A({atan_:$5});function B5(r,e){let t=v(r,"a","atan2"),n=v(e,"b","atan2");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Aa,o)}var L1=A({atan2_:B5});function O5(r){let t={x:v(r,"x","atanh")};return N.runKernel(va,t)}var $1=A({atanh_:O5});function z5(r,e,t,n,o="NHWC",s){let a=r[3],i=[...e,a],u=O1(o);return op(r,i,t,s,n,null,null,u)}function pA(r,e,t,n,o,s,a="channelsLast"){let[i,u]=Kb(e),l;if(a==="channelsLast")l=[i,u,r[3],r[3]];else if(a==="channelsFirst")l=[i,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return op(r,l,t,n,o,s,!1,a)}function G5(r,e,t,n,o,s,a="NDHWC"){let[i,u,l]=lA(e),p,m;if(a==="NDHWC")m="channelsLast",p=[i,u,l,r[4],r[4]];else if(a==="NCDHW")m="channelsFirst",p=[i,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return B1(r,p,t,n,o,!1,m,s)}function op(r,e,t,n,o,s,a=!1,i="channelsLast"){let[u,l,p,m]=[-1,-1,-1,-1];if(i==="channelsLast")[u,l,p,m]=r;else if(i==="channelsFirst")[u,m,l,p]=r;else throw new Error(`Unknown dataFormat ${i}`);let[c,d,,f]=e,[h,g]=Kb(t),[b,T]=Kb(n),x=sc(c,b),I=sc(d,T),{padInfo:S,outHeight:w,outWidth:_}=K5(o,l,p,h,g,x,I,s,i),M=a?f*m:f,R;return i==="channelsFirst"?R=[u,M,w,_]:i==="channelsLast"&&(R=[u,w,_,M]),{batchSize:u,dataFormat:i,inHeight:l,inWidth:p,inChannels:m,outHeight:w,outWidth:_,outChannels:M,padInfo:S,strideHeight:h,strideWidth:g,filterHeight:c,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:I,dilationHeight:b,dilationWidth:T,inShape:r,outShape:R,filterShape:e}}function B1(r,e,t,n,o,s=!1,a="channelsLast",i){let[u,l,p,m,c]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,l,p,m,c]=r;else if(a==="channelsFirst")[u,c,l,p,m]=r;else throw new Error(`Unknown dataFormat ${a}`);let[d,f,h,,g]=e,[b,T,x]=lA(t),[I,S,w]=lA(n),_=sc(d,I),M=sc(f,S),R=sc(h,w),{padInfo:E,outDepth:O,outHeight:G,outWidth:W}=V5(o,l,p,m,b,T,x,_,M,R,i),H=s?g*c:g,U;return a==="channelsFirst"?U=[u,H,O,G,W]:a==="channelsLast"&&(U=[u,O,G,W,H]),{batchSize:u,dataFormat:a,inDepth:l,inHeight:p,inWidth:m,inChannels:c,outDepth:O,outHeight:G,outWidth:W,outChannels:H,padInfo:E,strideDepth:b,strideHeight:T,strideWidth:x,filterDepth:d,filterHeight:f,filterWidth:h,effectiveFilterDepth:_,effectiveFilterHeight:M,effectiveFilterWidth:R,dilationDepth:I,dilationHeight:S,dilationWidth:w,inShape:r,outShape:U,filterShape:e}}function W5(r,e,t,n,o){n==null&&(n=mA(r,e,t));let s=r[0],a=r[1],i=np((s-e+2*n)/t+1,o),u=np((a-e+2*n)/t+1,o);return[i,u]}function U5(r,e,t,n,o,s){o==null&&(o=mA(r,e,n));let a=r[0],i=r[1],u=r[2],l=np((a-e+2*o)/n+1,s),p=np((i-e+2*o)/n+1,s),m=np((u-e+2*o)/n+1,s);return[l,p,m,t]}function mA(r,e,t,n=1){let o=sc(e,n);return Math.floor((r[0]*(t-1)-t+o)/2)}function Kb(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function lA(r){return typeof r=="number"?[r,r,r]:r}function sc(r,e){return e<=1?r:r+(r-1)*(e-1)}function K5(r,e,t,n,o,s,a,i,u){let l,p,m;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let d=W5([e,t],s,n,r,i);p=d[0],m=d[1]}else if(r==="same"){p=Math.ceil(e/n),m=Math.ceil(t/o);let c=Math.max(0,(p-1)*n+s-e),d=Math.max(0,(m-1)*o+a-t),f=Math.floor(c/2),h=c-f,g=Math.floor(d/2),b=d-g;l={top:f,bottom:h,left:g,right:b,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-s+1)/n),m=Math.ceil((t-a+1)/o);else if(typeof r=="object"){let c=u==="channelsLast"?r[1][0]:r[2][0],d=u==="channelsLast"?r[1][1]:r[2][1],f=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:c,bottom:d,left:f,right:h,type:c===0&&d===0&&f===0&&h===0?"VALID":"EXPLICIT"},p=np((e-s+c+d)/n+1,i),m=np((t-a+f+h)/o+1,i)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:p,outWidth:m}}function V5(r,e,t,n,o,s,a,i,u,l,p){let m,c,d,f;if(typeof r=="number"){m={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=U5([e,t,n,1],i,1,o,r,p);c=g[0],d=g[1],f=g[2]}else if(r==="same"){c=Math.ceil(e/o),d=Math.ceil(t/s),f=Math.ceil(n/a);let h=(c-1)*o+i-e,g=(d-1)*s+u-t,b=(f-1)*a+l-n,T=Math.floor(h/2),x=h-T,I=Math.floor(g/2),S=g-I,w=Math.floor(b/2),_=b-w;m={top:I,bottom:S,left:w,right:_,front:T,back:x,type:"SAME"}}else if(r==="valid")m={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},c=Math.ceil((e-i+1)/o),d=Math.ceil((t-u+1)/s),f=Math.ceil((n-l+1)/a);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:m,outDepth:c,outHeight:d,outWidth:f}}function np(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function ps(r){let[e,t,n]=Kb(r);return e===1&&t===1&&n===1}function Or(r,e){return ps(r)||ps(e)}function O1(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function _t(r,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")D(Qi(e),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(o=>{D(Qi(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${e}`)}}function H5(r,e){let n={x:v(r,"x","reshape","string_or_numeric")},o={shape:e};return N.runKernel(Ns,n,o)}var F=A({reshape_:H5});function q5(r,e,t,n,o){let s=v(r,"x","avgPool","float32"),a=1;D(Or(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let i=s,u=!1;s.rank===3&&(u=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),_t("avgPool",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},m=N.runKernel(ho,l,p);return m=re(m,s.dtype),u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var ac=A({avgPool_:q5});function j5(r,e,t,n,o,s="NDHWC"){let a=v(r,"x","avgPool3d","float32"),i=a,u=!1;a.rank===4&&(u=!0,i=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),_t("avgPool3d",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},m=N.runKernel(Bu,l,p);return m=re(m,i.dtype),u?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Vb=A({avgPool3d_:j5});function X5(r,e=0){D(r.length>=1,()=>"Pass at least one tensor to concat");let t=uu(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return gn(t[0]);let n=t,o={axis:e};return N.runKernel(Cs,n,o)}var ct=A({concat_:X5});function Y5(r){let t={x:v(r,"x","sigmoid","float32")};return N.runKernel(ts,t)}var Pn=A({sigmoid_:Y5});function Z5(r,e,t){let n=v(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:e,size:t};return N.runKernel(_s,o,s)}var ze=A({slice_:Z5});function Q5(r){let t={x:v(r,"x","tanh","float32")};return N.runKernel(us,t)}var fl=A({tanh_:Q5});function J5(r,e,t,n,o,s){let a=v(r,"forgetBias","basicLSTMCell"),i=v(e,"lstmKernel","basicLSTMCell"),u=v(t,"lstmBias","basicLSTMCell"),l=v(n,"data","basicLSTMCell"),p=v(o,"c","basicLSTMCell"),m=v(s,"h","basicLSTMCell"),c=ct([l,m],1),d=Ue(c,i),f=Z(d,u),h=f.shape[0],g=f.shape[1]/4,b=[h,g],T=ze(f,[0,0],b),x=ze(f,[0,g],b),I=ze(f,[0,g*2],b),S=ze(f,[0,g*3],b),w=Z(P(Pn(T),fl(x)),P(p,Pn(Z(a,I)))),_=P(fl(w),Pn(S));return[w,_]}var z1=A({basicLSTMCell_:J5});function eX(r,e,t){let n=v(r,"x","batchToSpaceND"),o=e.reduce((i,u)=>i*u);D(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),D(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),D(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:n},a={blockShape:e,crops:t};return N.runKernel(Is,s,a)}var ic=A({batchToSpaceND_:eX});function G1(r){let e;return r.rank===0||r.rank===1?e=F(r,[1,1,1,r.size]):r.rank===2?e=F(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}function tX(r,e,t,n,o,s){s==null&&(s=.001);let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;n!=null&&(p=v(n,"offset","batchNorm")),D(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(p==null||i.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let c={x:G1(a),scale:l,offset:p,mean:i,variance:u},d={varianceEpsilon:s},f=N.runKernel(Do,c,d);return F(f,a.shape)}var hl=A({batchNorm_:tX});function rX(r,e,t,n,o,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),D(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),hl(a,i,u,p,l,s)}var Hb=A({batchNorm2d_:rX});function nX(r,e,t,n,o,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),D(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),hl(a,i,u,p,l,s)}var qb=A({batchNorm3d_:nX});function oX(r,e,t,n,o,s){let a=v(r,"x","batchNorm"),i=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),D(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),hl(a,i,u,p,l,s)}var jb=A({batchNorm4d_:oX});function sX(r,e,t){let n=v(r,"x","bincount"),o=v(e,"weights","bincount");D(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},a={size:t};return N.runKernel(Ou,s,a)}var Xb=A({bincount_:sX});function aX(r,e){let t=v(r,"s0","broadcastArgs","int32"),n=v(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:t,s1:n};return N.runKernel(Nm,o)}var W1=A({broadcastArgs_:aX});function iX(r,e){let t=v(r,"broadcastTo","x"),n=t.shape;if(Ut(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=F(t,l)}let o=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(o[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((l,p)=>l>1?p:-1).filter(l=>l>=0).length===0)return gn(t);let i={x:t},u={reps:s};return N.runKernel(Dn,i,u)}var gl=A({broadcastTo_:iX});function uX(r){let t={x:v(r,"x","ceil","float32")};return N.runKernel(bo,t)}var U1=A({ceil_:uX});function Vs(r,e,t){Ut(r);let n={shape:r,value:e,dtype:t};return N.runKernel(Ai,{},n)}function lX(r,e,t){let n=v(r,"x","clipByValue");if(D(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return Vs(n.shape,e,n.dtype);let o={x:n},s={clipValueMin:e,clipValueMax:t};return N.runKernel(Kn,o,s)}var Hr=A({clipByValue_:lX});function pX(r){return ct(r,0)}var Yb=A({concat1d_:pX});function mX(r,e){return ct(r,e)}var Zb=A({concat2d_:mX});function cX(r,e){return ct(r,e)}var Qb=A({concat3d_:cX});function dX(r,e){return ct(r,e)}var Jb=A({concat4d_:dX});function fX(r,e,t,n,o="NHWC",s=[1,1],a){let i=v(r,"x","conv2d","float32"),u=v(e,"filter","conv2d","float32"),l=i,p=!1;i.rank===3&&(p=!0,l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),_t("conv2d",n,a);let m=o==="NHWC"?l.shape[3]:l.shape[1];D(m===u.shape[2],()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${u.shape[2]}.`),D(Or(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let c={x:l,filter:u},d={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=N.runKernel(yo,c,d);return p?F(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var cs=A({conv2d_:fX});function hX(r,e,t,n,o="NWC",s=1,a){let i=v(r,"x","conv1d"),u=v(e,"filter","conv1d"),l=i,p=!1;i.rank===2&&(p=!0,l=F(i,[1,i.shape[0],i.shape[1]])),D(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),D(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),_t("conv1d",n,a),D(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),D(Or(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),D(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let m=F(u,[1,u.shape[0],u.shape[1],u.shape[2]]),c=F(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=cs(c,m,[1,t],n,"NHWC",[1,s],a);return p?F(g,[g.shape[2],g.shape[3]]):F(g,[g.shape[0],g.shape[2],g.shape[3]])}var ey=A({conv1d_:hX});function gX(r,e,t,n,o,s="NHWC",a){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let i=r,u=e,l=!1;e.rank===3&&(l=!0,u=F(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,r[0],r[1],r[2]]),D(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),D(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),D(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let p=s==="NHWC"?i[3]:i[1],m=s==="NHWC"?u.shape[3]:u.shape[1];D(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),D(m===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${t.shape[3]}.`),_t("conv2dDerInput",o,a);let c={dy:u,filter:t},d={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,inputShape:i},f=N.runKernel(To,c,d);return l?F(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var uc=A({conv2DBackpropInput_:gX});function bX(r,e,t,n,o,s){let a=v(r,"x","conv2dTranspose"),i=v(e,"filter","conv2dTranspose");return uc(t,a,i,n,o,"NHWC",s)}var ty=A({conv2dTranspose_:bX});function yX(r,e,t,n,o="NDHWC",s=[1,1,1]){let a=v(r,"x","conv3d"),i=v(e,"filter","conv3d"),u=a,l=!1;a.rank===4&&(l=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),D(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),D(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),D(Or(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let p={x:u,filter:i},m={strides:t,pad:n,dataFormat:o,dilations:s},c=N.runKernel(Wu,p,m);return l?F(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var ry=A({conv3d_:yX});function TX(r,e,t,n,o){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,a=e,i=!1;e.rank===4&&(i=!0,a=F(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=a.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),D(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),D(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),D(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);let p={dy:a,filter:t},m={pad:o,strides:n,inputShape:s},c=N.runKernel(Mm,p,m);return i?F(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var ny=A({conv3DBackpropInput_:TX});function xX(r,e,t,n,o){let s=v(r,"x","conv3dTranspose"),a=v(e,"filter","conv3dTranspose");return ny(t,s,a,n,o)}var oy=A({conv3dTranspose_:xX});function IX(r){let t={x:v(r,"x","cos","float32")};return N.runKernel(xo,t)}var lc=A({cos_:IX});function CX(r){let t={x:v(r,"x","cosh","float32")};return N.runKernel(Io,t)}var sy=A({cosh_:CX});function SX(r,e=0,t=!1,n=!1){let s={x:v(r,"x","cumprod")},a={axis:e,exclusive:t,reverse:n};return N.runKernel(wa,s,a)}var Ah=A({cumprod_:SX});function kX(r,e=0,t=!1,n=!1){let s={x:v(r,"x","cumsum")},a={axis:e,exclusive:t,reverse:n};return N.runKernel(Co,s,a)}var ay=A({cumsum_:kX});function vX(r,e,t,n=!1){let o=v(r,"x","denseBincount"),s=v(e,"weights","denseBincount");D(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),D(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let a={x:o,weights:s},i={size:t,binaryOutput:n};return N.runKernel(Uu,a,i)}var wh=A({denseBincount_:vX});function AX(r,e,t="NHWC"){let n=v(r,"x","depthToSpace","float32"),o=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];D(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),D(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${n.shape}`),D(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),D(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${n.shape}`);let i={x:n},u={blockSize:e,dataFormat:t};return N.runKernel(Da,i,u)}var K1=A({depthToSpace_:AX});function wX(r,e,t,n,o="NHWC",s=[1,1],a){let i=v(r,"x","depthwiseConv2d","float32"),u=v(e,"filter","depthwiseConv2d","float32"),l=i,p=!1;i.rank===3&&(p=!0,l=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let m=o==="NHWC"?l.shape[3]:l.shape[1];D(m===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${m}) must match the inChannels dimension in filter ${u.shape[2]}.`),_t("depthwiseConv2d",n,a);let c={x:l,filter:u},d={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=N.runKernel(So,c,d);return p?F(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var bl=A({depthwiseConv2d_:wX});function NX(r){let t={x:v(r,"x","diag")};return N.runKernel(Em,t)}var V1=A({diag_:NX});function DX(r,e,t,n,o=[1,1],s="NHWC"){let a=v(r,"x","dilation2d"),i=v(e,"filter","dilation2d");D(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),D(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=a,l=!1;a.rank===3&&(u=F(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=!0);let p={x:u,filter:i},m={strides:t,pad:n,dilations:o},c=N.runKernel(Ku,p,m);return l?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var H1=A({dilation2d_:DX});function _X(r,e){let t=v(r,"a","equal","string_or_numeric"),n=v(e,"b","equal","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ma,o)}var nn=A({equal_:_X});function MX(r,e,t){let n=v(e,"a","where"),o=v(t,"b","where"),s=v(r,"condition","where","bool"),a=Oe(Oe(s.shape,n.shape),o.shape),i=gl(s,a),u=gl(n,a),l=gl(o,a),p={condition:i,t:u,e:l};return N.runKernel(Ds,p)}var zt=A({where_:MX});function RX(r){let t={x:v(r,"x","zerosLike")};return N.runKernel(Es,t)}var we=A({zerosLike_:RX});function PX(r,e){let t=v(r,"a","div"),n=v(e,"b","div");[t,n]=Ye(t,n);let o=fe(t,n),s=we(o),a=nn(n,s);return zt(a,s,o)}var q1=A({divNoNan_:PX});function EX(r,e){let t=v(r,"t1","dot"),n=v(e,"t2","dot");D((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=n.rank===1?n.size:n.shape[0];if(D(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&n.rank===1){let a=F(t,[1,-1]),i=F(n,[-1,1]),u=Ue(a,i);return F(u,[])}else if(t.rank===1&&n.rank===2){let a=F(t,[1,-1]),i=F(n,[n.shape[0],n.shape[1]]),u=Ue(a,i);return F(u,[u.size])}else if(t.rank===2&&n.rank===1){let a=F(n,[-1,1]),i=Ue(t,a);return F(i,[i.size])}else{let a=F(n,[n.shape[0],n.shape[1]]);return Ue(t,a)}}var j1=A({dot_:EX});function FX(r,...e){let t=e.map((o,s)=>v(o,`tensors${s}`,"einsum")),n={equation:r};return N.runKernel(Vu,t,n)}var X1=A({einsum_:FX});function LX(r){let t={x:v(r,"x","elu","float32")};return N.runKernel(vo,t)}var yl=A({elu_:LX});function $X(r){let e=v(r,"x","erf");D(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=re(e,"float32"));let t={x:e};return N.runKernel(_a,t)}var Y1=A({erf_:$X});function cA(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function Z1(r,e,t){let n=r.length+e.length,o=[],s=0,a=0;for(let i=0;i<n;i++)t.indexOf(i)===-1?o.push(r[s++]):o.push(e[a++]);return o}function dA(r,e){let t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);let o=e.map(s=>r[s]);return[t,o]}function Hs(r,e){let t=e.map(n=>1);return Z1(r,t,e)}function BX(r,e,t){D(cA(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function fA(r,e){if(cA(r,e))return null;let t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function Nh(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function OX(r,e){let t=[];for(let n=e-r;n<e;++n)t.push(n);return t}function zX(r,e=null,t=!1){let o={x:v(r,"x","max")},s={reductionIndices:e,keepDims:t};return N.runKernel(Eo,o,s)}var qr=A({max_:zX});function GX(r,e=null,t=!1){let o={x:v(r,"x","min")},s={axis:e,keepDims:t};return N.runKernel(Bo,o,s)}var sp=A({min_:GX});function WX(r,e){let t=v(r,"base","pow"),n=v(e,"exp","pow");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Ko,o)}var jn=A({pow_:WX});function ge(r,e){if((kr(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&kr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return hn(r,[],[],e)}function UX(r){let t={x:v(r,"x","sqrt","float32")};return N.runKernel(rs,t)}var Ft=A({sqrt_:UX});function KX(r){let e=v(r,"x","square"),t={};return N.runKernel("Square",{x:e},t)}var He=A({square_:KX});function VX(r,e=null,t=!1){let n=v(r,"x","sum");n.dtype==="bool"&&(n=re(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(ns,o,s)}var be=A({sum_:VX});function HX(r,e="euclidean",t=null,n=!1){r=v(r,"x","norm");let o=Q1(r,e,t),s=o.shape;if(n){let a=gr(t,r.shape);s=Hs(o.shape,a)}return F(o,s)}function Q1(r,e,t=null){if(r.rank===0)return Ot(r);if(r.rank!==1&&t===null)return Q1(F(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return be(Ot(r),t);if(e===1/0)return qr(Ot(r),t);if(e===-1/0)return sp(Ot(r),t);if(e==="euclidean"||e===2)return Ft(be(jn(Ot(r),ge(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return qr(be(Ot(r),t[0]),t[1]-1);if(e===1/0)return qr(be(Ot(r),t[1]),t[0]);if(e===-1/0)return sp(be(Ot(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Ft(be(He(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var ap=A({norm_:HX});function qX(r,e=null,t=!1){return ap(r,"euclidean",e,t)}var J1=A({euclideanNorm_:qX});function jX(r){let t={x:v(r,"x","exp")};return N.runKernel(Ao,t)}var br=A({exp_:jX});function XX(r,e=0){let t=v(r,"x","expandDims","string_or_numeric");D(e<=t.rank,()=>"Axis must be <= rank of the tensor");let n={input:t},o={dim:e};return N.runKernel(Ss,n,o)}var yr=A({expandDims_:XX});function YX(r){let t={x:v(r,"x","expm1")};return N.runKernel(Ra,t)}var e2=A({expm1_:YX});function ZX(r,e){let t=v(r,"x","tile","string_or_numeric");D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let n={x:t},o={reps:e};return N.runKernel(Dn,n,o)}var on=A({tile_:ZX});function QX(r,e,t,n="float32"){e==null&&(e=r);let o=Ie([r,e],n),s=r<=e?r:e;for(let i=0;i<s;++i)o.set(1,i,i);let a=F(o.toTensor(),[r,e]);if(t==null)return a;if(t.length===1)return on(yr(a,0),[t[0],1,1]);if(t.length===2)return on(yr(yr(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return on(yr(yr(yr(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var ip=A({eye_:QX});function JX(r){let t={x:v(r,"x","floor","float32")};return N.runKernel(wo,t)}var Tl=A({floor_:JX});function eY(r,e,t=0,n=0){let o=v(r,"x","gather"),s=v(e,"indices","gather","int32"),a={x:o,indices:s},i={axis:t,batchDims:n};return N.runKernel(ks,a,i)}var xl=A({gather_:eY});function tY(r,e){let t=v(r,"a","greater","string_or_numeric"),n=v(e,"b","greater","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Fa,o)}var Qt=A({greater_:tY});function rY(r,e){let t=v(r,"a","greaterEqual","string_or_numeric"),n=v(e,"b","greaterEqual","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(_o,o)}var Xn=A({greaterEqual_:rY});function nY(r){let t={x:v(r,"x","isFinite")};return N.runKernel(La,t)}var t2=A({isFinite_:nY});function oY(r){let t={x:v(r,"x","isInf")};return N.runKernel($a,t)}var r2=A({isInf_:oY});function sY(r){let t={x:v(r,"x","isNaN")};return N.runKernel(Mo,t)}var n2=A({isNaN_:sY});function aY(r,e=.2){let n={x:v(r,"x","leakyRelu")},o={alpha:e};return N.runKernel(Ro,n,o)}var pc=A({leakyRelu_:aY});function iY(r,e){let t=v(r,"a","less","string_or_numeric"),n=v(e,"b","less","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ba,o)}var iy=A({less_:iY});function uY(r,e){let t=v(r,"a","lessEqual","string_or_numeric"),n=v(e,"b","lessEqual","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Oa,o)}var qs=A({lessEqual_:uY});function o2(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:e,num:t};return N.runKernel(Lm,{},n)}function lY(r,e=5,t=1,n=1,o=.5){let s=v(r,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(Qi(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,i=!1;s.rank===3&&(i=!0,a=F(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:a},l={depthRadius:e,bias:t,alpha:n,beta:o},p=N.runKernel(Xu,u,l);return i?F(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var s2=A({localResponseNormalization_:lY});function pY(r){let t={x:v(r,"x","log","float32")};return N.runKernel(Po,t)}var jr=A({log_:pY});function mY(r){let t={x:v(r,"x","log1p")};return N.runKernel(za,t)}var mc=A({log1p_:mY});function cY(r){return D(Si(r),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let n=v(e,"x","tf.grad","string_or_numeric"),o=t!=null?v(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(n),[n],o);return o!=null&&Bt(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),ly(a),a[0]})}}function dY(r){return D(Si(r),()=>"The f passed in grads(f) must be a function"),(e,t)=>{D(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=uu(e,"args","tf.grads","string_or_numeric"),o=t!=null?v(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:a}=N.gradients(()=>r(...n),n,o);return o!=null&&Bt(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ly(a),a})}}function fY(r){return D(Si(r),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{D(e instanceof We,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(t==null||t instanceof We,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=N.gradients(()=>r(e),[e],t);return ly(n),{grad:n[0],value:o}}}function hY(r){return D(Si(r),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{D(Array.isArray(e)&&e.every(o=>o instanceof We),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(t==null||t instanceof We,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=N.gradients(()=>r(...e),e,t);return t!=null&&Bt(n.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),ly(n.grads),n}}function uy(r,e){D(Si(r),()=>"The f passed in variableGrads(f) must be a function"),D(e==null||Array.isArray(e)&&e.every(l=>l instanceof au),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let l in N.registeredVariables)e.push(N.registeredVariables[l])}let n=t?e.filter(l=>!l.trainable):null,o=e.length;e=e.filter(l=>l.trainable),D(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:a,grads:i}=N.gradients(r,e,null,s);D(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let u={};return e.forEach((l,p)=>{i[p]!=null&&(u[l.name]=i[p])}),n?.forEach(l=>u[l.name]=null),{value:a,grads:u}}function bn(r){return N.customGrad(r)}function ly(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function gY(r){let t={x:v(r,"x","softplus")};return N.runKernel(nu,t)}var cu=A({softplus_:gY});function bY(r){let e=v(r,"x","logSigmoid");return bn(n=>({value:tt(cu(tt(n))),gradFunc:a=>P(a,Pn(tt(n)))}))(e)}var a2=A({logSigmoid_:bY});function yY(r,e){let t=v(r,"a","sub"),n=v(e,"b","sub");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(as,o)}var de=A({sub_:yY});function TY(r,e=-1){let t=v(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return bn((o,s)=>{let i=qr(o,e,!0),u=de(o,i),l=de(re(u,"float32"),jr(be(br(u),e,!0)));return s([l]),{value:l,gradFunc:(m,c)=>{let[d]=c,f=!0,h=br(d);return de(m,P(be(m,e,f),h))}}})(t)}var py=A({logSoftmax_:TY});function xY(r,e=null,t=!1){let n=v(r,"x","logSumExp"),o=gr(e,n.shape),s=qr(n,o,!0),a=de(n,s),i=br(a),u=be(i,o),l=jr(u),p=Z(F(s,l.shape),l);if(t){let m=Hs(p.shape,o);return F(p,m)}return p}var my=A({logSumExp_:xY});function IY(r,e){let t=v(r,"a","logicalAnd","bool"),n=v(e,"b","logicalAnd","bool");Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ga,o)}var sn=A({logicalAnd_:IY});function CY(r){let t={x:v(r,"x","logicalNot","bool")};return N.runKernel(Wa,t)}var cc=A({logicalNot_:CY});function SY(r,e){let t=v(r,"a","logicalOr","bool"),n=v(e,"b","logicalOr","bool");Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ji,o)}var cy=A({logicalOr_:SY});function kY(r,e){let t=v(r,"a","logicalXor","bool"),n=v(e,"b","logicalXor","bool");return Oe(t.shape,n.shape),sn(cy(r,e),cc(sn(r,e)))}var i2=A({logicalXor_:kY});var dy=2147483648;function vY(r,e,t="left"){let n=v(r,"sortedSequence","searchSorted"),o=v(e,"values","searchSorted"),s=n.shape[n.shape.length-1],a=o.shape[o.shape.length-1],i=F(n,[-1,s]),u=F(o,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(nt(u.shape)>=dy)throw new Error(`values tensor size must less than ${dy}`);if(i.shape[1]>=dy)throw new Error(`trailing dim_size must less than ${dy} for int32 output type, was ${i.shape[1]}`);let l={sortedSequence:i,values:u},p={side:t};return N.runKernel(Qu,l,p)}var Dh=A({searchSorted_:vY});function u2(r,e){return Dh(r,e,"left")}function AY(r,e,t,n,o){let s=v(r,"x","maxPool"),a=1,i=s,u=!1;s.rank===3&&(u=!0,i=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),D(Or(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),_t("maxPool",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},m=N.runKernel(Lo,l,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var dc=A({maxPool_:AY});function wY(r,e=[1,1,1],t,n,o,s="NDHWC"){let a=v(r,"x","maxPool3d"),i=a,u=!1;a.rank===4&&(u=!0,i=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),_t("maxPool3d",n,o);let l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},m=N.runKernel(Yu,l,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var fy=A({maxPool3d_:wY});function NY(r,e,t,n,o=!1){let a={x:v(r,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:n,includeBatchInIndex:o},u=N.runKernel(zm,a,i);return{result:u[0],indexes:u[1]}}var l2=A({maxPoolWithArgmax_:NY});function DY(r,e){let t=v(r,"a","maximum"),n=v(e,"b","maximum");[t,n]=Ye(t,n),t.dtype==="bool"&&(t=re(t,"int32"),n=re(n,"int32")),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Fo,o)}var ds=A({maximum_:DY});function _Y(r,e=null,t=!1){let o={x:v(r,"x","mean")},s={axis:e,keepDims:t};return N.runKernel($o,o,s)}var Lt=A({mean_:_Y});function Ct(r,e="float32"){if(Ut(r),e==="complex64"){let n=Ct(r,"float32"),o=Ct(r,"float32");return Mn(n,o)}let t=vm(nt(r),e);return N.makeTensor(t,r,e)}function Tr(r,e="float32"){if(Ut(r),e==="complex64"){let n=Tr(r,"float32"),o=Ct(r,"float32");return Mn(n,o)}let t=oh(nt(r),e);return N.makeTensor(t,r,e)}function p2(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=v(r,"x","meshgrid",r instanceof We?r.dtype:"float32");if(e===void 0)return[n];let o=v(e,"y","meshgrid",e instanceof We?e.dtype:"float32"),s=nt(n.shape),a=nt(o.shape);return t==="xy"?(n=F(n,[1,-1]),o=F(o,[-1,1]),[Ue(Tr([a,1],n.dtype),n),Ue(o,Tr([1,s],o.dtype))]):(n=F(n,[-1,1]),o=F(o,[1,-1]),[Ue(n,Tr([1,a],n.dtype)),Ue(Tr([s,1],o.dtype),o)])}function MY(r,e){let t=v(r,"a","minimum"),n=v(e,"b","minimum");[t,n]=Ye(t,n),t.dtype==="bool"&&(t=re(t,"int32"),n=re(n,"int32")),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Oo,o)}var Il=A({minimum_:MY});function RY(r,e,t){D(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let n=v(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let i=0;i<n.rank;i++)D(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(e[i][0]>=0&&e[i][0]<=n.shape[i]-o&&e[i][1]>=0&&e[i][1]<=n.shape[i]-o,()=>`Padding in dimension ${i} cannot be greater than or equal to ${n.shape[i]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:e,mode:t},a={x:n};return N.runKernel(zo,a,s)}var m2=A({mirrorPad_:RY});function PY(r,e){let t=v(r,"a","mod"),n=v(e,"b","mod");[t,n]=Ye(t,n);let o={a:t,b:n};return N.runKernel(Ua,o)}var c2=A({mod_:PY});function EY(r,e=null,t=!1){r=v(r,"x","moments");let n=gr(e,r.shape),o=Lt(r,n,t),s=o.shape;t||(s=Hs(o.shape,n));let a=He(de(re(r,"float32"),F(o,s))),i=Lt(a,n,t);return{mean:o,variance:i}}var up=A({moments_:EY});function FY(r,e,t,n){let o=v(e,"data","multiRNNCell"),s=uu(t,"c","multiRNNCell"),a=uu(n,"h","multiRNNCell"),i=o,u=[];for(let m=0;m<r.length;m++){let c=r[m](i,s[m],a[m]);u.push(c[0]),u.push(c[1]),i=c[1]}let l=[],p=[];for(let m=0;m<u.length;m+=2)l.push(u[m]),p.push(u[m+1]);return[l,p]}var d2=A({multiRNNCell_:FY});function LY(r,e,t,n=!1){let o=v(r,"logits","multinomial"),s=o.size,a=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();let u={logits:a===1?F(o,[1,-1]):o},l={numSamples:e,seed:t,normalized:n},p=N.runKernel(Gm,u,l);return a===1?F(p,[p.size]):p}var f2=A({multinomial_:LY});function $Y(r,e){let t=v(r,"a","notEqual","string_or_numeric"),n=v(e,"b","notEqual","string_or_numeric");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Ka,o)}var du=A({notEqual_:$Y});function BY(r){let t={x:v(r,"x","onesLike")};return N.runKernel(As,t)}var zr=A({onesLike_:BY});function OY(r,e){let t=v(r,"v1","outerProduct"),n=v(e,"v2","outerProduct");D(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);let o=F(t,[-1,1]),s=F(n,[1,-1]);return Ue(o,s)}var h2=A({outerProduct_:OY});function zY(r,e,t=0){let n=v(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:n};return N.runKernel(Uo,s,o)}var Yn=A({pad_:zY});function GY(r,e,t=0){return D(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Yn(r,[e],t)}var g2=A({pad1d_:GY});function WY(r,e,t=0){return D(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yn(r,e,t)}var b2=A({pad2d_:WY});function UY(r,e,t=0){return D(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yn(r,e,t)}var y2=A({pad3d_:UY});function KY(r,e,t=0){return D(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Yn(r,e,t)}var T2=A({pad4d_:KY});function VY(r,e,t){let n=v(r,"x","spaceToBatchND");D(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),D(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),D(n.shape.reduce((a,i,u)=>u>0&&u<=e.length?a&&(i+t[u-1][0]+t[u-1][1])%e[u-1]===0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:n},s={blockShape:e,paddings:t};return N.runKernel(Ms,o,s)}var fc=A({spaceToBatchND_:VY});function HY(r,e,t,n,o,s,a){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let i=v(r,"x","maxPool"),u=i,l=!1;i.rank===3&&(l=!0,u=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),D(Or(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let p=pA(u.shape,e,s,o,n),m=[p.dilationHeight,p.dilationWidth],c;n==="same"?c=jY([p.filterHeight,p.filterWidth],m):c=[[0,0],[0,0]];let d=m[0]===1&&m[1]===1,[f,h]=qY([p.inHeight,p.inWidth],m,c),g=d?n:"valid",b=d?u:fc(u,m,f),x=(t==="avg"?()=>ac(b,e,s,g,a):()=>dc(b,e,s,g,a))(),I=d?x:ic(x,m,h);return l?F(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function qY(r,e,t){let n=t.map(p=>p[0]),o=t.map(p=>p[1]),s=r.concat(n,o),a=e.map((p,m)=>(p-s[m]%p)%p),i=o.map((p,m)=>p+a[m]),u=e.map((p,m)=>[n[m],i[m]]),l=e.map((p,m)=>[0,a[m]]);return[u,l]}function jY(r,e){let n=r.map((a,i)=>a+(a-1)*(e[i]-1)).map(a=>a-1),o=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-o[i]);return n.map((a,i)=>[o[i],s[i]])}var x2=A({pool_:HY});function XY(r,e){let t=v(r,"x","prelu"),n=v(e,"alpha","prelu"),o={x:t,alpha:n};return N.runKernel(Vo,o)}var hc=A({prelu_:XY});function YY(r,e=null,t=!1){let n=v(r,"x","prod");n.dtype==="bool"&&(n=re(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(Ho,o,s)}var I2=A({prod_:YY});function ZY(r,e,t,n){let o=r.map((p,m)=>v(p,`tensors${m}`,"raggedGather","int32")),s=v(e,"paramsDenseValues","raggedGather"),a=v(t,"indices","raggedGather","int32"),i={paramsNestedSplits:o,paramsDenseValues:s,indices:a},u={outputRaggedRank:n},l=N.runKernel(Wm,i,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}var C2=A({raggedGather_:ZY});function QY(r,e,t){let n=v(r,"starts","raggedRange"),o=v(e,"limits","raggedRange",n.dtype),s=v(t,"deltas","raggedRange",n.dtype),a={starts:n,limits:o,deltas:s},i=N.runKernel(Um,a);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}var S2=A({raggedRange_:QY});function JY(r,e,t,n,o){let s=v(r,"shape","raggedTensorToTensor","int32"),a=v(e,"values","raggedTensorToTensor"),i=v(t,"defaultValue","raggedTensorToTensor",a.dtype),u=n.map((m,c)=>v(m,`tensors${c}`,"raggedTensorToTensor","int32")),l={shape:s,values:a,defaultValue:i,rowPartitionTensors:u},p={rowPartitionTypes:o};return N.runKernel(Km,l,p)}var k2=A({raggedTensorToTensor_:JY});function eZ(r,e,t){Ut(r);let n=nt(r),o=null;if(t==null||t==="float32")o=new Float32Array(n);else if(t==="int32")o=new Int32Array(n);else if(t==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<n;s++)o[s]=e();return N.makeTensor(o,r,t)}var v2=A({rand_:eZ});var yy=Vl(_h());var pp=class{mean;stdDev;nextVal;dtype;truncated;upper;lower;random;constructor(e,t,n,o,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=yy.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,n=!1;for(;!n;){let o,s,a;do o=2*this.random()-1,s=2*this.random()-1,a=o*o+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*o*i,t=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},gy=class{alpha;beta;d;c;dtype;randu;randn;constructor(e,t,n,o){this.alpha=e,this.beta=1/t,this.dtype=n;let s=o||Math.random();this.randu=yy.alea(s.toString()),this.randn=new pp(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,o,s,a;for(;;){do o=this.randn.nextValue(),a=1+this.c*o;while(a<=0);if(a*=a*a,e=o*o,t=1-.331*e*e,n=.5*e+this.d*(1-a+Math.log(a)),s=this.randu(),s<t||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},by=class{min;range;random;dtype;constructor(e=0,t=1,n,o){if(this.min=e,this.range=t-e,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=yy.alea(o)}canReturnFloat=()=>this.dtype==null||this.dtype==="float32";convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function iZ(r,e,t=1,n="float32",o){if(Ut(r),t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new gy(e,t,n,o),a=Ie(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var W2=A({randomGamma_:iZ});function uZ(r,e=0,t=1,n,o){if(Ut(r),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new pp(e,t,n,!1,o),a=Ie(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var mp=A({randomNormal_:uZ});function lZ(r,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return mp(r,0,1,e,t)}var U2=A({randomStandardNormal_:lZ});function pZ(r,e=0,t=1,n="float32",o){Ut(r);let s=Ie(r,n),a=new by(e,t,null,o);for(let i=0;i<s.values.length;i++)s.values[i]=a.nextValue();return s.toTensor()}var Ei=A({randomUniform_:pZ});function Fi(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:e,step:t,dtype:n};return N.runKernel(wi,{},o)}function mZ(r){let t={x:v(r,"x","reciprocal")};return N.runKernel(qo,t)}var K2=A({reciprocal_:mZ});function cZ(r){let t={x:v(r,"x","relu")};return N.runKernel(jo,t)}var an=A({relu_:cZ});function dZ(r){let t={x:v(r,"x","relu6")};return N.runKernel(Zo,t)}var Ty=A({relu6_:dZ});function fZ(r,e){let n={x:v(r,"x","reverse")},o={dims:e};return N.runKernel(Qo,n,o)}var _r=A({reverse_:fZ});function hZ(r){let e=v(r,"x","reverse");return D(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),_r(e,0)}var V2=A({reverse1d_:hZ});function gZ(r,e){let t=v(r,"x","reverse");return D(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),_r(t,e)}var H2=A({reverse2d_:gZ});function bZ(r,e){let t=v(r,"x","reverse");return D(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),_r(t,e)}var q2=A({reverse3d_:bZ});function yZ(r,e){let t=v(r,"x","reverse");return D(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),_r(t,e)}var j2=A({reverse4d_:yZ});function TZ(r){let t={x:v(r,"x","round")};return N.runKernel(qa,t)}var xy=A({round_:TZ});function xZ(r){let t={x:v(r,"x","rsqrt","float32")};return N.runKernel(Jo,t)}var Iy=A({rsqrt_:xZ});function IZ(r){let t={x:v(r,"x","selu")};return N.runKernel(tu,t)}var Cy=A({selu_:IZ});function CZ(r,e,t,n,o,s=[1,1],a="NHWC"){let i=v(r,"x","separableConv2d"),u=v(e,"depthwiseFilter","separableConv2d"),l=v(t,"pointwiseFilter","separableConv2d"),p=i,m=!1;if(i.rank===3&&(m=!0,p=F(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),D(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let c=u.shape[2],d=u.shape[3];D(l.shape[2]===c*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${c*d}, but got ${l.shape[2]}.`);let f=bl(p,u,n,o,a,s),g=cs(f,l,1,"valid",a);return m?F(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Sy=A({separableConv2d_:CZ});async function SZ(r,e){let t=v(r,"x","setdiff1d"),n=v(e,"y","setdiff1d");D(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),D(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),D(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await t.data(),s=await n.data(),a=new Set(s),i=0;for(let p=0;p<o.length;p++)a.has(o[p])||i++;let u=new bt([i],t.dtype),l=new bt([i],"int32");for(let p=0,m=0;p<o.length;p++)a.has(o[p])||(u.values[m]=o[p],l.values[m]=p,m++);return[u.toTensor(),l.toTensor()]}var X2=SZ;function kZ(r){let t={x:v(r,"x","sign")};return N.runKernel(ru,t)}var Y2=A({sign_:kZ});function vZ(r){let t={x:v(r,"x","sin","float32")};return N.runKernel(es,t)}var ky=A({sin_:vZ});function AZ(r){let t={x:v(r,"x","sinh")};return N.runKernel(Xa,t)}var vy=A({sinh_:AZ});function wZ(r,e,t){let n=v(r,"x","slice1d");return D(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),ze(n,[e],[t])}var gc=A({slice1d_:wZ});function NZ(r,e,t){let n=v(r,"x","slice2d");return D(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var Mh=A({slice2d_:NZ});function DZ(r,e,t){let n=v(r,"x","slice3d");return D(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var bc=A({slice3d_:DZ});function _Z(r,e,t){let n=v(r,"x","slice4d");return D(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var cp=A({slice4d_:_Z});function MZ(r,e=-1){let t=v(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let n={logits:t},o={dim:e};return N.runKernel(os,n,o)}var yc=A({softmax_:MZ});function RZ(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(Hu,e)}var Tc=A({fft_:RZ});function PZ(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(qu,e)}var dp=A({ifft_:PZ});function EZ(r){let e=r.shape[r.shape.length-1],t=r.size/e,n;if(e<=2){let o=F(r,[t,e]);n=dp(o)}else{let o=[t,2*(e-1)],s=F(mu(r),[t,e]),a=F(cl(r),[t,e]),i=_r(ze(s,[0,1],[t,e-2]),1),u=P(_r(ze(a,[0,1],[t,e-2]),1),ge(-1)),l=ct([s,i],1),p=ct([a,u],1),m=F(Mn(l,p),[o[0],o[1]]);n=dp(m)}if(n=mu(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=F(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var Ay=A({irfft_:EZ});function FZ(r,e,t=0){let o={x:v(r,"x","split")},s={numOrSizeSplits:e,axis:t};return N.runKernel(Rs,o,s)}var Mr=A({split_:FZ});function LZ(r,e){D(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1],n=r.size/t,o;if(e!=null&&e<t){let f=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=e,o=ze(r,f,h),t=e}else if(e!=null&&e>t){let f=r.shape.map(h=>h);f[r.shape.length-1]=e-t,o=ct([r,Ct(f)],r.shape.length-1),t=e}else o=r;let s=we(o),a=F(Mn(o,s),[n,t]),i=Tc(a),u=Math.floor(t/2)+1,l=mu(i),p=cl(i),m=Mr(l,[u,t-u],l.shape.length-1),c=Mr(p,[u,t-u],p.shape.length-1),d=o.shape.slice();return d[o.shape.length-1]=u,F(Mn(m[0],c[0]),d)}var xc=A({rfft_:LZ});function $Z(r,e){let t=v(r,"a","squaredDifference"),n=v(e,"b","squaredDifference");[t,n]=Ye(t,n),Oe(t.shape,n.shape);let o={a:t,b:n},s={};return N.runKernel(ss,o,s)}var wy=A({squaredDifference_:$Z});function BZ(r,e){let t=v(r,"x","squeeze","string_or_numeric");return F(t,Tv(t.shape,e).newShape)}var js=A({squeeze_:BZ});function OZ(r,e=0){let t=uu(r,"tensors","stack","string_or_numeric");D(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&D(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let n=t,o={axis:e};return N.runKernel(ws,n,o)}var cr=A({stack_:OZ});function zZ(r,e=0){let n={x:v(r,"x","step")},o={alpha:e};return N.runKernel(Fs,n,o)}var Li=A({step_:zZ});function GZ(r,e,t,n,o=0,s=0,a=0,i=0,u=0){let p={x:v(r,"x","stridedSlice","string_or_numeric")},m={begin:e,end:t,strides:n,beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};return N.runKernel(Ya,p,m)}var Z2=A({stridedSlice_:GZ});function WZ(r){let t={x:v(r,"x","tan","float32")};return N.runKernel(is,t)}var Q2=A({tan_:WZ});function Jt(r,e){mo(r);let t=Vr(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return hn(r,null,t,e)}function ri(r,e,t){if(mo(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Vr(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return hn(r,e,n,t)}function J2(r,e,t){if(mo(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Vr(r,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return hn(r,e,n,t)}function eM(r,e,t){if(mo(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Vr(r,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return hn(r,e,n,t)}function tM(r,e,t){if(mo(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Vr(r,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,hn(r,e,n,t)}function UZ(r,e=1,t=!0){let n=v(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:n},a={k:e,sorted:t},[i,u]=N.runKernel(Za,s,a);return{values:i,indices:u}}var rM=A({topk_:UZ});function KZ(r,e=0,t=1,n,o){if(Ut(r),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new pp(e,t,n,!0,o),a=Ie(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var Ic=A({truncatedNormal_:KZ});function VZ(r,e=0){let t=v(r,"x","unique","string_or_numeric");D(t.rank>0,()=>"The input tensor must be at least 1D");let n={x:t},o={axis:e},[s,a]=N.runKernel(qm,n,o);return{values:s,indices:a}}var nM=A({unique_:VZ});function HZ(r,e,t){let n=v(r,"x","unsortedSegmentSum"),o=v(e,"segmentIds","unsortedSegmentSum","int32");D(Qi(t),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},a={numSegments:t};return N.runKernel(sl,s,a)}var Ny=A({unsortedSegmentSum_:HZ});function qZ(r,e=0){let t=v(r,"x","unstack","string_or_numeric");D(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let n={value:t},o={axis:e};return N.runKernel(Ps,n,o)}var Rr=A({unstack_:qZ});function oM(r,e){return Dh(r,e,"right")}function Dy(r,e=!0,t,n){return N.makeVariable(r,e,t,n)}function _y(r,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let n=Ie(r,"int32"),o=Ie([t.length,r.length],"int32");for(let s=0;s<t.length;s++){let a=n.indexToLoc(t[s]),i=s*r.length;o.values.set(a,i)}return o.toTensor()}async function jZ(r){let e=v(r,"condition","whereAsync","bool"),t=await e.data(),n=_y(e.shape,t);return r!==e&&e.dispose(),n}var My=jZ;async function XZ(r,e,t){let n=v(r,"tensor","boolMask"),o=v(e,"mask","boolMask","bool"),s=t??0,a=o.rank,i=n.shape;D(a>0,()=>"mask cannot be scalar"),Bt(i.slice(s,s+a),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+a;h++)u*=i[h];let l=i.slice(0,s).concat([u],i.slice(s+a)),p=F(n,l),m=F(o,[-1]),c=await My(m),d=js(c,[1]),f=xl(p,d,s);return r!==n&&n.dispose(),e!==o&&o.dispose(),d.dispose(),p.dispose(),m.dispose(),c.dispose(),f}var YZ=XZ;function ZZ(r,e,t,n,o=!0){let s=v(r,"v","movingAverage"),a=v(e,"x","movingAverage"),i=v(t,"decay","movingAverage");Lv(s,a),D(Wn(s.shape,a.shape),()=>"Shape mismatch in v and x");let u=ge(1),l=de(u,i),p=P(de(a,s),l);if(o){D(n!=null,()=>"When using zeroDebias: true, step is required.");let m=v(n,"step","movingAverage");p=fe(p,de(u,jn(i,m)))}return Z(s,p)}var QZ=A({movingAverage_:ZZ});function JZ(r,e,t){Ut(t);let n=v(r,"indices","scatterND","int32"),o=v(e,"updates","scatterND");zb(o,n,t);let s={indices:n,updates:o},a={shape:t};return N.runKernel(ja,s,a)}var eQ=A({scatterND_:JZ});function sM(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let a=e.size;if(!(e.rank===0||e.rank===1&&a===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function rQ(r,e,t,n=0){Ut(t);let o=v(r,"sparseIndices","sparseToDense","int32"),s=v(e,"sparseValues","sparseToDense","string_or_numeric"),a=v(n,"defaultValue","sparseToDense",s.dtype);sM(o,s,t,a);let i={sparseIndices:o,sparseValues:s,defaultValue:a},u={outputShape:t};return N.runKernel(rl,i,u)}var nQ=A({sparseToDense_:rQ});function oQ(r,e){let t=v(e,"indices","gatherND","int32"),o={params:v(r,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(Ea,o)}var sQ=A({gatherND_:oQ});function aM(r,e){if(e==null)return r.shape.slice();if(Wn(r.shape,e))return e;if(r.shape.length===e.length){let t=[];for(let n=0;n<r.shape.length;n++)e[n]==null&&r.shape[n]!=null?t.push(r.shape[n]):t.push(e[n]);return t}return e}function aQ(r,e,t,n){let o=v(r,"x","dropout");if(D(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),D(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof We?o.clone():o;let s=aM(o,t),a=1-e,i=fe(Tl(Z(Ei(s,0,1,"float32",n),a)),a);return P(o,i)}var CA=A({dropout_:aQ});function SA(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Rh(r,e,t){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let a=2*Math.PI*s/(r+n-1);o[s]=e-t*Math.cos(a)}return Jt(o,"float32")}async function iQ(r,e,t=1){let n=v(r,"predictions","inTopK"),o=v(e,"targets","inTopK");D(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),D(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Bt(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];D(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let a=await n.data(),i=await o.data(),[u,l]=[a.length/s,s],p=xv("bool",u);for(let m=0;m<u;m++){let c=m*l,d=a.subarray(c,c+l),f=[];for(let h=0;h<d.length;h++)f.push({value:d[h],index:h});f.sort((h,g)=>g.value-h.value),p[m]=0;for(let h=0;h<t;h++)if(f[h].index===i[m]){p[m]=1;break}}return r!==n&&n.dispose(),e!==o&&o.dispose(),mr(p,o.shape,"bool")}var uQ=iQ;var Cl={};qe(Cl,{conv2d:()=>iM,depthwiseConv2d:()=>uM,matMul:()=>lM});function lQ(r,e,t,n,o,s="NHWC",a){let i=r;r.rank===3&&(i=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=F(e,[1,e.shape[0],e.shape[1],e.shape[2]])),D(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),D(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),D(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let l=s==="NHWC"?i.shape[3]:i.shape[1],p=s==="NHWC"?u.shape[3]:u.shape[1];D(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),D(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),_t("conv2dDerFilter",o,a);let m={x:i,dy:u},c={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,filterShape:t};return N.runKernel(Dm,m,c)}var Cc=A({conv2DBackpropFilter_:lQ});function fp(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return P(r,Li(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function hp(r,e){let t=e,n=vt(r.shape,e.shape);return n.length>0&&(t=be(t,n)),F(t,r.shape)}function gp(r,e,t,n){if(e==="linear")return r;if(e==="relu")return an(r);if(e==="elu")return yl(r);if(e==="relu6")return Ty(r);if(e==="prelu")return hc(r,t);if(e==="leakyrelu")return pc(r,n);if(e==="sigmoid")return Pn(r);throw new Error(`Unknown fused activation ${e}.`)}var bp=(r,e)=>!(r>0)||e==="linear";function pQ({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(u=u||"linear",bp(N.state.gradientDepth,u)===!1){D(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let w=cs(r,e,t,n,o,s,a);return i!=null&&(w=Z(w,i)),gp(w,u,l,p)}let m=v(r,"x","conv2d","float32"),c=v(e,"filter","conv2d","float32"),d=m,f=!1;m.rank===3&&(f=!0,d=F(m,[1,m.shape[0],m.shape[1],m.shape[2]])),D(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),D(c.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${c.rank}.`),_t("fused conv2d",n,a);let h=o==="NHWC"?d.shape[3]:d.shape[1];D(c.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${c.shape[2]}.`),D(Or(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let g=op(d.shape,c.shape,t,s,n,a),b;i!=null&&(b=v(i,"bias","fused conv2d"),[b]=Ye(b,m),o==="NHWC"?Oe(g.outShape,b.shape):(D(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),D(b.shape.length===0||b.shape[0]===g.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let T;if(l!=null){let w=l.shape;if(D(w.length<=1||w.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${w.length}.`),w.length===1)D(w[0]===1||w[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the number of output channels (${g.outChannels}).`);else if(w.length===3)try{Oe(w,g.outShape)}catch{let M=`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(M)}T=v(l,"prelu weights","fused conv2d")}let x=(w,_)=>{D(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[M,R,E,O]=_,G=fp(w,E,u);D(ps(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let W=uc(R.shape,G,M,t,n),H=Cc(R,G,M.shape,t,n),U=[W,H];if(O!=null){let V=hp(O,G);U.push(V)}return U},I={x:d,filter:c,bias:b,preluActivationWeights:T},S={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return i==null?bn((_,M,R)=>{let E=N.runKernel($s,I,S);return R([M,_,E]),f&&(E=F(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:x}})(d,c):bn((_,M,R,E)=>{let O=N.runKernel($s,I,S);return E([M,_,O,R]),f&&(O=F(O,[O.shape[1],O.shape[2],O.shape[3]])),{value:O,gradFunc:x}})(d,c,b)}var iM=A({fusedConv2d_:pQ});function mQ(r,e,t,n,o,s=[1,1],a){let i=r;r.rank===3&&(i=F(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=F(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={x:i,dy:u},p={strides:n,pad:o,dimRoundingMode:a,dilations:s,filterShape:t};return N.runKernel(Rm,l,p)}var Ry=A({depthwiseConv2dNativeBackpropFilter_:mQ});function cQ(r,e,t,n,o,s=[1,1],a){let i=e,u=!1;e.rank===3&&(u=!0,i=F(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={dy:i,filter:t},p={strides:n,pad:o,dimRoundingMode:a,dilations:s,inputShape:r},m=N.runKernel(Pm,l,p);return u?F(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Py=A({depthwiseConv2dNativeBackpropInput_:cQ});function dQ({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(bp(N.state.gradientDepth,u)===!1){let S=bl(r,e,t,n,o,s,a);return i!=null&&(S=Z(S,i)),gp(S,u,l,p)}let m=v(r,"x","depthwiseConv2d","float32"),c=v(e,"filter","depthwiseConv2d","float32"),d=m,f=!1;m.rank===3&&(f=!0,d=F(m,[1,m.shape[0],m.shape[1],m.shape[2]])),D(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),D(c.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`),D(d.shape[3]===c.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),s==null&&(s=[1,1]),D(Or(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),_t("fused depthwiseConv2d",n,a);let h=op(d.shape,c.shape,t,s,n,a,!0),g;i!=null&&(g=v(i,"bias","fused conv2d"),[g]=Ye(g,m),Oe(h.outShape,g.shape));let b;l!=null&&(b=v(l,"prelu weights","fused depthwiseConv2d"));let T=(S,w)=>{D(ps(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[_,M,R,E]=w,O=fp(S,R,u),G=Py(M.shape,O,_,t,n,s,a),W=Ry(M,O,_.shape,t,n,s,a);if(E!=null){let H=hp(g,O);return[G,W,H]}return[G,W]},x={x:d,filter:c,bias:g,preluActivationWeights:b},I={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:p};return i==null?bn((w,_,M)=>{let R=N.runKernel(Bs,x,I);return M([_,w,R]),f&&(R=F(R,[R.shape[1],R.shape[2],R.shape[3]])),{value:R,gradFunc:T}})(d,c):bn((w,_,M,R)=>{let E=N.runKernel(Bs,x,I);return R([_,w,E,M]),f&&(E=F(E,[E.shape[1],E.shape[2],E.shape[3]])),{value:E,gradFunc:T}})(d,c,g)}var uM=A({fusedDepthwiseConv2d_:dQ});function fQ({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(bp(N.state.gradientDepth,s)===!1){let O=Ue(r,e,t,n);return o!=null&&(O=Z(O,o)),gp(O,s,a,i)}let u=v(r,"a","fused matMul"),l=v(e,"b","fused matMul");[u,l]=Ye(u,l);let p=t?u.shape[u.rank-2]:u.shape[u.rank-1],m=n?l.shape[l.rank-1]:l.shape[l.rank-2],c=t?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=nt(f),b=nt(h);D(p===m,()=>`Error in fused matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${n} must match.`);let x=Oe(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([c,d]),I=t?F(u,[g,p,c]):F(u,[g,c,p]),S=n?F(l,[b,d,m]):F(l,[b,m,d]),w;o!=null&&(w=v(o,"bias","fused matMul"),[w]=Ye(w,u),Oe(x,w.shape));let _;a!=null&&(_=v(a,"prelu weights","fused matMul"));let M=(O,G)=>{let[W,H,U,V]=G,Y=fp(F(O,U.shape),U,s),j,te;if(!t&&!n?(j=Ue(Y,H,!1,!0),te=Ue(W,Y,!0,!1)):!t&&n?(j=Ue(Y,H,!1,!1),te=Ue(Y,W,!0,!1)):t&&!n?(j=Ue(H,Y,!1,!0),te=Ue(W,Y,!1,!1)):(j=Ue(H,Y,!0,!0),te=Ue(Y,W,!0,!0)),o!=null){let ne=hp(V,Y);return[j,te,ne]}else return[j,te]},R={a:I,b:S,bias:w,preluActivationWeights:_},E={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:i};return o==null?bn((G,W,H)=>{let U=N.runKernel(Ls,R,E);return H([G,W,U]),{value:F(U,x),gradFunc:M}})(I,S):bn((G,W,H,U)=>{let V=N.runKernel(Ls,R,E);return U([G,W,V,H]),{value:F(V,x),gradFunc:M}})(I,S,w)}var lM=A({fusedMatMul_:fQ});function hQ(r){return Rh(r,.54,.46)}var pM=A({hammingWindow_:hQ});function gQ(r){return Rh(r,.5,.5)}var Ey=A({hannWindow_:gQ});function bQ(r,e,t,n=!1,o=0){let s=0,a=[];for(;s+e<=r.size;)a.push(ze(r,s,e)),s+=t;if(n)for(;s<r.size;){let i=s+e-r.size,u=ct([ze(r,s,e-i),Vs([i],o)]);a.push(u),s+=t}return a.length===0?ri([],[0,e]):F(ct(a),[a.length,e])}var Fy=A({frame_:bQ});function yQ(r,e,t,n,o=Ey){n==null&&(n=SA(e));let s=Fy(r,e,t),a=P(s,o(e));return xc(a,n)}var mM=A({stft_:yQ});function TQ(r,e,t,n,o="bilinear",s=0){let a=v(r,"image","cropAndResize"),i=v(e,"boxes","cropAndResize","float32"),u=v(t,"boxInd","cropAndResize","int32"),l=i.shape[0];D(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),D(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),D(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),D(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),D(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),D(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let p={image:a,boxes:i,boxInd:u},m={method:o,extrapolationValue:s,cropSize:n};return N.runKernel(Na,p,m)}var cM=A({cropAndResize_:TQ});function xQ(r){let e=v(r,"image","flipLeftRight","float32");D(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return N.runKernel(Pa,t,{})}var dM=A({flipLeftRight_:xQ});function IQ(r){let e=v(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];D(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),D(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,on(e,o)}var fM=A({grayscaleToRGB_:IQ});function CQ(r,e,t=0,n=.5){let o=v(r,"image","rotateWithOffset","float32");D(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},a={radians:e,fillValue:t,center:n};return N.runKernel(Ja,s,a)}var hM=A({rotateWithOffset_:CQ});function Xs(r,e,t,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let a=r.shape[0];return t=Math.min(t,a),D(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),D(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),D(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),D(e.rank===1,()=>"scores must be a 1D tensor"),D(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function SQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppression","float32"),a=v(e,"scores","nonMaxSuppression","float32"),i=Xs(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u={maxOutputSize:t,iouThreshold:n,scoreThreshold:o};return N.runKernel(Va,{boxes:s,scores:a},u)}var gM=A({nonMaxSuppression_:SQ});function bM(r,e,t){let n=kQ(r,e,t),o=n<0?-(n+1):n;r.splice(o,0,e)}function kQ(r,e,t){return AQ(r,e,t||vQ)}function vQ(r,e){return r>e?1:r<e?-1:0}function AQ(r,e,t){let n=0,o=r.length,s=0,a=!1;for(;n<o;){s=n+(o-n>>>1);let i=t(e,r[s]);i>0?n=s+1:(o=s,a=!i)}return a?n:-n-1}function Ly(r,e,t,n,o){return kA(r,e,t,n,o,0)}function $y(r,e,t,n,o,s){return kA(r,e,t,n,o,0,!1,s,!0)}function By(r,e,t,n,o,s){return kA(r,e,t,n,o,s,!0)}function kA(r,e,t,n,o,s,a=!1,i=!1,u=!1){let l=[];for(let g=0;g<e.length;g++)e[g]>o&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(yM);let p=s>0?-.5/s:0,m=[],c=[];for(;m.length<t&&l.length>0;){let g=l.pop(),{score:b,boxIndex:T,suppressBeginIndex:x}=g;if(b<o)break;let I=!1;for(let S=m.length-1;S>=x;--S){let w=wQ(r,T,m[S]);if(w>=n){I=!0;break}if(g.score=g.score*NQ(n,p,w),g.score<=o)break}g.suppressBeginIndex=m.length,I||(g.score===b?(m.push(T),c.push(g.score)):g.score>o&&bM(l,g,yM))}let d=m.length,f=t-d;i&&f>0&&(m.push(...new Array(f).fill(0)),c.push(...new Array(f).fill(0)));let h={selectedIndices:m};return a&&(h.selectedScores=c),u&&(h.validOutputs=d),h}function wQ(r,e,t){let n=r.subarray(e*4,e*4+4),o=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),i=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),p=Math.min(o[1],o[3]),m=Math.max(o[0],o[2]),c=Math.max(o[1],o[3]),d=(i-s)*(u-a),f=(m-l)*(c-p);if(d<=0||f<=0)return 0;let h=Math.max(s,l),g=Math.max(a,p),b=Math.min(i,m),T=Math.min(u,c),x=Math.max(b-h,0)*Math.max(T-g,0);return x/(d+f-x)}function NQ(r,e,t){let n=Math.exp(e*t*t);return t<=r?n:0}function yM(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}async function DQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppressionAsync"),a=v(e,"scores","nonMaxSuppressionAsync"),i=Xs(s,a,t,n,o);t=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u=await Promise.all([s.data(),a.data()]),l=u[0],p=u[1],{selectedIndices:m}=Ly(l,p,t,n,o);return s!==r&&s.dispose(),a!==e&&a.dispose(),Jt(m,"int32")}var TM=DQ;function _Q(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=v(r,"boxes","nonMaxSuppression"),i=v(e,"scores","nonMaxSuppression"),u=Xs(a,i,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:a,scores:i},p={maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},m=N.runKernel(Ha,l,p);return{selectedIndices:m[0],selectedScores:m[1]}}var xM=A({nonMaxSuppressionWithScore_:_Q});async function MQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),u=Xs(a,i,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([a.data(),i.data()]),p=l[0],m=l[1],{selectedIndices:c,selectedScores:d}=By(p,m,t,n,o,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Jt(c,"int32"),selectedScores:Jt(d)}}var IM=MQ;function RQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=v(r,"boxes","nonMaxSuppression"),i=v(e,"scores","nonMaxSuppression"),u=Xs(a,i,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,m=u.scoreThreshold,c={boxes:a,scores:i},d={maxOutputSize:l,iouThreshold:p,scoreThreshold:m,padToMaxOutputSize:s},f=N.runKernel(eu,c,d);return{selectedIndices:f[0],validOutputs:f[1]}}var CM=A({nonMaxSuppressionPadded_:RQ});async function PQ(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),u=Xs(a,i,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,m=u.scoreThreshold,[c,d]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:h}=$y(c,d,l,p,m,s);return a!==r&&a.dispose(),i!==e&&i.dispose(),{selectedIndices:Jt(f,"int32"),validOutputs:ge(h,"int32")}}var SM=PQ;function EQ(r,e,t=!1,n=!1){let o=v(r,"images","resizeBilinear");D(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),D(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(Yo,i,u);return a?F(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var kM=A({resizeBilinear_:EQ});function FQ(r,e,t=!1,n=!1){let o=v(r,"images","resizeNearestNeighbor");D(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),D(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=F(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,i={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(Xo,i,u);return a?F(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var vM=A({resizeNearestNeighbor_:FQ});function LQ(r,e="binary",t=!1,n=.5){let o=v(r,"image","threshold"),s=.2989,a=.587,i=.114,u=o.shape[0]*o.shape[1],l=P(Jt([n]),255),p,m,c,d;if(D(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),D(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),D(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),D(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[p,m,c]=Mr(o,[1,1,1],-1);let g=P(p,s),b=P(m,a),T=P(c,i);d=Z(Z(g,b),T)}else d=r;if(e==="otsu"){let g=Xb(re(xy(d),"int32"),mr([]),256);l=$Q(g,u)}let f=t?qs(d,l):Qt(d,l);return re(P(f,255),"int32")}function $Q(r,e){let t=Jt([-1]),n=Jt([0]),o=Jt([0]),s,a,i,u,l,p;for(let m=0;m<r.size-1;m++){s=ze(r,0,m+1),a=ze(r,m+1),l=fe(be(s),e),p=fe(be(a),e);let c=be(P(s,Fi(0,s.size)));i=fe(c,be(s));let d=Vs(a.shape,s.size),f=Z(Fi(0,a.size),d),h=P(a,f);u=fe(be(h),be(a));let g=de(i,u),b=de(i,u),T=P(l,p);o=P(P(T,g),b);let x=Qt(o,n);n=zt(x,o,n),t=zt(x,Jt([m]),t)}return t}var AM=A({threshold_:LQ});function BQ(r,e,t="nearest",n="constant",o=0,s){let a=v(r,"image","transform","float32"),i=v(e,"transforms","transform","float32");D(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),D(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:a,transforms:i},l={interpolation:t,fillMode:n,fillValue:o,outputShape:s};return N.runKernel(Qa,u,l)}var wM=A({transform_:BQ});function OQ(r,e,t){D(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),D(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);let n=v(r,"a","bandPart");D(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,a]=n.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=s),t<0&&(t=a);let i=F(Fi(0,s,1,"int32"),[-1,1]),u=Fi(0,a,1,"int32"),l=de(i,u),p=sn(qs(l,ge(+e,"int32")),Xn(l,ge(-t,"int32"))),m=Ct([s,a],n.dtype);return F(cr(Rr(F(n,[-1,s,a])).map(c=>zt(p,c,m))),o)}var NM=A({bandPart_:OQ});function zQ(r){let e;if(Array.isArray(r)){e=!1,D(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)D(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else e=!0,r=Mr(r,r.shape[0],0).map(o=>js(o,[0]));D(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let t=[],n=r;for(let o=0;o<r.length;++o)t.push(N.tidy(()=>{let s=n[o];if(o>0)for(let a=0;a<o;++a){let i=P(be(P(t[a],s)),t[a]);s=de(s,i)}return fe(s,ap(s,"euclidean"))}));return e?cr(t,0):t}var DM=A({gramSchmidt_:zQ});function GQ(r,e=!1){if(D(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return _M(r,e);{let t=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=Rr(F(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,p]=_M(u,e);o.push(l),s.push(p)});let a=F(cr(o,0),r.shape),i=F(cr(s,0),r.shape);return[a,i]}}function _M(r,e=!1){return N.tidy(()=>{D(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let t=r.shape[0],n=r.shape[1],o=ip(t),s=gn(r),a=ri([[1]],[1,1]),i=gn(a),u=t>=n?n:t;for(let l=0;l<u;++l){let p=s,m=i,c=o;[i,s,o]=N.tidy(()=>{let d=ze(s,[l,l],[t-l,1]),f=ap(d),h=ze(s,[l,l],[1,1]),g=zt(Qt(h,0),ri([[-1]]),ri([[1]])),b=de(h,P(g,f)),T=fe(d,b);T.shape[0]===1?i=gn(a):i=ct([a,ze(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);let x=tt(fe(Ue(g,b),f)),I=ze(s,[l,0],[t-l,n]),S=P(x,i),w=Ge(i);if(l===0)s=de(I,Ue(S,Ue(w,I)));else{let R=de(I,Ue(S,Ue(w,I)));s=ct([ze(s,[0,0],[l,n]),R],0)}let _=Ge(S),M=ze(o,[0,l],[t,o.shape[1]-l]);if(l===0)o=de(M,Ue(Ue(M,i),_));else{let R=de(M,Ue(Ue(M,i),_));o=ct([ze(o,[0,0],[t,l]),R],1)}return[i,s,o]}),_e([p,m,c])}return!e&&t>n&&(o=ze(o,[0,0],[t,n]),s=ze(s,[0,0],[n,n])),[o,s]})}var MM=A({qr_:GQ});var ni=(o=>(o[o.NONE=0]="NONE",o[o.MEAN=1]="MEAN",o[o.SUM=2]="SUM",o[o.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",o))(ni||{});function WQ(r,e,t=3){let n=v(r,"losses","computeWeightedLoss"),o=null;e!=null&&(o=v(e,"weights","computeWeightedLoss"));let s=o==null?n:P(n,o);if(t===0)return s;if(t===2)return be(s);if(t===1){if(o==null)return Lt(s);{let a=n.size/o.size,i=fe(be(s),be(o));return a>1?fe(i,ge(a)):i}}if(t===3){if(o==null)return fe(be(s),ge(n.size));{let a=P(o,Tr(n.shape)),i=re(be(du(a,ge(0))),"float32");return fe(be(s),i)}}throw Error(`Unknown reduction: ${t}`)}var Xr=A({computeWeightedLoss_:WQ});function UQ(r,e,t,n=3){let o=v(r,"labels","absoluteDifference"),s=v(e,"predictions","absoluteDifference"),a=null;t!=null&&(a=v(t,"weights","absoluteDifference")),Bt(o.shape,s.shape,"Error in absoluteDifference: ");let i=Ot(de(o,s));return Xr(i,a,n)}var RM=A({absoluteDifference_:UQ});function KQ(r,e,t,n,o=3){let s=v(r,"labels","cosineDistance"),a=v(e,"predictions","cosineDistance"),i=null;n!=null&&(i=v(n,"weights","cosineDistance")),Bt(s.shape,a.shape,"Error in cosineDistance: ");let u=ge(1),l=de(u,be(P(s,a),t,!0));return Xr(l,i,o)}var PM=A({cosineDistance_:KQ});function VQ(r,e,t,n=3){let o=v(r,"labels","hingeLoss"),s=v(e,"predictions","hingeLoss"),a=null;t!=null&&(a=v(t,"weights","hingeLoss")),Bt(o.shape,s.shape,"Error in hingeLoss: ");let i=ge(1);o=de(P(ge(2),o),i);let u=an(de(i,P(o,s)));return Xr(u,a,n)}var EM=A({hingeLoss_:VQ});function HQ(r,e,t,n=1,o=3){let s=v(r,"labels","huberLoss"),a=v(e,"predictions","huberLoss"),i=null;t!=null&&(i=v(t,"weights","huberLoss")),Bt(s.shape,a.shape,"Error in huberLoss: ");let u=ge(n),l=Ot(de(a,s)),p=Il(l,u),m=de(l,p),c=Z(P(ge(.5),He(p)),P(u,m));return Xr(c,i,o)}var FM=A({huberLoss_:HQ});function qQ(r,e,t,n=1e-7,o=3){let s=v(r,"labels","logLoss"),a=v(e,"predictions","logLoss"),i=null;t!=null&&(i=v(t,"weights","logLoss")),Bt(s.shape,a.shape,"Error in logLoss: ");let u=ge(1),l=ge(n),p=tt(P(s,jr(Z(a,l)))),m=P(de(u,s),jr(Z(de(u,a),l))),c=de(p,m);return Xr(c,i,o)}var LM=A({logLoss_:qQ});function jQ(r,e,t,n=3){let o=v(r,"labels","meanSquaredError"),s=v(e,"predictions","meanSquaredError"),a=null;t!=null&&(a=v(t,"weights","meanSquaredError")),Bt(o.shape,s.shape,"Error in meanSquaredError: ");let i=wy(o,s);return Xr(i,a,n)}var $M=A({meanSquaredError_:jQ});function XQ(r,e){let t=v(r,"labels","sigmoidCrossEntropyWithLogits"),n=v(e,"logits","sigmoidCrossEntropyWithLogits");Bt(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=an(n),s=P(n,t),a=mc(br(tt(Ot(n))));return Z(de(o,s),a)}function YQ(r,e,t,n=0,o=3){let s=v(r,"multiClassLabels","sigmoidCrossEntropy"),a=v(e,"logits","sigmoidCrossEntropy"),i=null;if(t!=null&&(i=v(t,"weights","sigmoidCrossEntropy")),Bt(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=ge(n),p=ge(1),m=ge(.5);s=Z(P(s,de(p,l)),P(m,l))}let u=XQ(s,a);return Xr(u,i,o)}var BM=A({sigmoidCrossEntropy_:YQ});function ZQ(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return bn((o,s,a)=>{let u=my(s,[t],!0),l=de(re(s,"float32"),u);a([o,l]);let p=tt(P(l,o));return{value:be(p,[t]),gradFunc:(d,f)=>{let[h,g]=f,b=Hs(d.shape,[t]);return[P(F(d,b),de(re(h,"float32"),br(g))),P(F(d,b),de(br(g),re(h,"float32")))]}}})(r,e)}function QQ(r,e,t,n=0,o=3){let s=v(r,"onehotLabels","softmaxCrossEntropy"),a=v(e,"logits","softmaxCrossEntropy"),i=null;if(t!=null&&(i=v(t,"weights","softmaxCrossEntropy")),Bt(s.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){let l=ge(n),p=ge(1),m=ge(s.shape[1]);s=Z(P(s,de(p,l)),fe(l,m))}let u=ZQ(s,a);return Xr(u,i,o)}var OM=A({softmaxCrossEntropy_:QQ});function JQ(r,e,t,n){let o=v(r,"indices","sparseFillEmptyRows","int32"),s=v(e,"values","sparseFillEmptyRows"),a=v(t,"denseShape","sparseFillEmptyRows","int32"),i=v(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let u={indices:o,values:s,denseShape:a,defaultValue:i},l=N.runKernel(Ju,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var zM=A({sparseFillEmptyRows_:JQ});function e7(r,e,t){let n=v(r,"inputIndices","sparseReshape","int32"),o=v(e,"inputShape","sparseReshape","int32"),s=v(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let a={inputIndices:n,inputShape:o,newShape:s},i=N.runKernel(ou,a);return{outputIndices:i[0],outputShape:i[1]}}var GM=A({sparseReshape_:e7});function t7(r,e,t){let n=v(r,"data","sparseSegmentMean"),o=v(e,"indices","sparseSegmentMean","int32"),s=v(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return N.runKernel(el,a)}var WM=A({sparseSegmentMean_:t7});function r7(r,e,t){let n=v(r,"data","sparseSegmentSum"),o=v(e,"indices","sparseSegmentSum","int32"),s=v(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return N.runKernel(tl,a)}var UM=A({sparseSegmentSum_:r7});function n7(r,e,t,n,o,s,a,i){let u=v(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=v(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let p={separator:t,nGramWidths:n,leftPad:o,rightPad:s,padWidth:a,preserveShortSequences:i},m={data:u,dataSplits:l},c=N.runKernel(Di,m,p);return{nGrams:c[0],nGramsSplits:c[1]}}var KM=A({stringNGrams_:n7});function o7(r,e,t=!0){let n=v(r,"input","stringSplit","string"),o=v(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},a={input:n,delimiter:o},i=N.runKernel(nl,a,s);return{indices:i[0],values:i[1],shape:i[2]}}var VM=A({stringSplit_:o7});function s7(r,e){let t=v(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return N.runKernel(ol,o,n)}var HM=A({stringToHashBucketFast_:s7});var a7={fft:Tc,ifft:dp,rfft:xc,irfft:Ay},i7={hammingWindow:pM,hannWindow:Ey,frame:Fy,stft:mM},fs={flipLeftRight:dM,grayscaleToRGB:fM,resizeNearestNeighbor:vM,resizeBilinear:kM,rotateWithOffset:hM,cropAndResize:cM,nonMaxSuppression:gM,nonMaxSuppressionAsync:TM,nonMaxSuppressionWithScore:xM,nonMaxSuppressionWithScoreAsync:IM,nonMaxSuppressionPadded:CM,nonMaxSuppressionPaddedAsync:SM,threshold:AM,transform:wM},vA={bandPart:NM,gramSchmidt:DM,qr:MM},u7={absoluteDifference:RM,computeWeightedLoss:Xr,cosineDistance:PM,hingeLoss:EM,huberLoss:FM,logLoss:LM,meanSquaredError:$M,sigmoidCrossEntropy:BM,softmaxCrossEntropy:OM},l7={sparseFillEmptyRows:zM,sparseReshape:GM,sparseSegmentMean:WM,sparseSegmentSum:UM},p7={stringNGrams:KM,stringSplit:VM,stringToHashBucketFast:HM};var Yr=class extends kh{iterations_;minimize(e,t=!1,n){let{value:o,grads:s}=this.computeGradients(e,n);if(n!=null){let a=n.map(i=>({name:i.name,tensor:s[i.name]}));this.applyGradients(a)}else this.applyGradients(s);return _e(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return uy(e,t)}dispose(){this.iterations_!=null&&_e(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ge(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Yr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var Sl=class extends Yr{constructor(t,n,o=null){super();this.learningRate=t;this.rho=n;this.epsilon=o;o==null&&(this.epsilon=N.backend.epsilon())}accumulatedGrads=[];accumulatedUpdates=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${o}/accum_grad`,variable:z(()=>we(a).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${o}/accum_var`,variable:z(()=>we(a).variable(i))});let u=Array.isArray(t)?t[s].tensor:t[o];if(u==null)return;let l=this.accumulatedGrads[s].variable,p=this.accumulatedUpdates[s].variable;z(()=>{let m=Z(P(l,this.rho),P(He(u),1-this.rho)),c=P(fe(Ft(Z(p,this.epsilon)),Ft(Z(l,this.epsilon))),u),d=Z(P(p,this.rho),P(He(c),1-this.rho));l.assign(m),p.assign(d);let f=Z(P(c,-this.learningRate),a);a.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(_e(this.accumulatedGrads.map(t=>t.variable)),_e(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=t.length/2,o=!1;this.accumulatedGrads=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedUpdates=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}};K(Sl,"className","Adadelta");Rn(Sl);var kl=class extends Yr{constructor(t,n=.1){super();this.learningRate=t;this.initialAccumulatorValue=n}accumulatedGrads=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${o}/accumulator`,variable:z(()=>Vs(a.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(t)?t[s].tensor:t[o];if(i==null)return;let u=this.accumulatedGrads[s].variable;z(()=>{let l=Z(u,He(i));u.assign(l);let p=Z(P(fe(i,Ft(Z(l,N.backend.epsilon()))),-this.learningRate),a);a.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&_e(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=!1;this.accumulatedGrads=t.map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}};K(kl,"className","Adagrad");Rn(kl);var vl=class extends Yr{constructor(t,n,o,s=null){super();this.learningRate=t;this.beta1=n;this.beta2=o;this.epsilon=s;z(()=>{this.accBeta1=ge(n).variable(),this.accBeta2=ge(o).variable()}),s==null&&(this.epsilon=N.backend.epsilon())}accBeta1;accBeta2;accumulatedFirstMoment=[];accumulatedSecondMoment=[];applyGradients(t){let n=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);z(()=>{let o=de(1,this.accBeta1),s=de(1,this.accBeta2);n.forEach((a,i)=>{let u=N.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:z(()=>we(u).variable(l))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:z(()=>we(u).variable(l))});let p=Array.isArray(t)?t[i].tensor:t[a];if(p==null)return;let m=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,d=Z(P(m,this.beta1),P(p,1-this.beta1)),f=Z(P(c,this.beta2),P(He(p),1-this.beta2)),h=fe(d,o),g=fe(f,s);m.assign(d),c.assign(f);let b=Z(P(fe(h,Z(Ft(g),this.epsilon)),-this.learningRate),u);u.assign(b)}),this.accBeta1.assign(P(this.accBeta1,this.beta1)),this.accBeta2.assign(P(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&_e(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),z(()=>{this.accBeta1.assign(jn(this.beta1,this.iterations_+1)),this.accBeta2.assign(jn(this.beta2,this.iterations_+1))});let n=t.length/2,o=!1;this.accumulatedFirstMoment=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}};K(vl,"className","Adam");Rn(vl);var Al=class extends Yr{constructor(t,n,o,s=null,a=0){super();this.learningRate=t;this.beta1=n;this.beta2=o;this.epsilon=s;this.decay=a;z(()=>{this.iteration=ge(0).variable(),this.accBeta1=ge(n).variable()}),s==null&&(this.epsilon=N.backend.epsilon())}accBeta1;iteration;accumulatedFirstMoment=[];accumulatedWeightedInfNorm=[];applyGradients(t){let n=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);z(()=>{let o=de(1,this.accBeta1),s=fe(-this.learningRate,Z(P(this.iteration,this.decay),1));n.forEach((a,i)=>{let u=N.registeredVariables[a],l=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:we(u).variable(l)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:we(u).variable(l)});let p=Array.isArray(t)?t[i].tensor:t[a];if(p==null)return;let m=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,d=Z(P(m,this.beta1),P(p,1-this.beta1)),f=P(c,this.beta2),h=Ot(p),g=ds(f,h);m.assign(d),c.assign(g);let b=Z(P(fe(s,o),fe(d,Z(g,this.epsilon))),u);u.assign(b)}),this.iteration.assign(Z(this.iteration,1)),this.accBeta1.assign(P(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&_e(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&_e(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}};K(Al,"className","Adamax");Rn(Al);var $i=class extends Yr{constructor(t){super();this.learningRate=t;this.setLearningRate(t)}c;applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=Array.isArray(t)?t[s].tensor:t[o];if(a==null)return;let i=N.registeredVariables[o];z(()=>{let u=Z(P(this.c,a),i);i.assign(u)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Et(ge(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}};K($i,"className","SGD");Rn($i);var wl=class extends $i{constructor(t,n,o=!1){super(t);this.learningRate=t;this.momentum=n;this.useNesterov=o;this.m=ge(this.momentum)}m;accumulations=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${o}/momentum`,variable:z(()=>we(a).variable(!1))});let i=this.accumulations[s].variable,u=Array.isArray(t)?t[s].tensor:t[o];u!=null&&z(()=>{let l,p=Z(P(this.m,i),u);this.useNesterov?l=Z(P(this.c,Z(u,P(p,this.m))),a):l=Z(P(this.c,p),a),i.assign(p),a.assign(l)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&_e(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=!1;this.accumulations=t.map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}};K(wl,"className","Momentum");Rn(wl);var Nl=class extends Yr{constructor(t,n=.9,o=0,s=null,a=!1){super();this.learningRate=t;this.decay=n;this.momentum=o;this.epsilon=s;if(this.centered=a,s==null&&(this.epsilon=N.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}centered;accumulatedMeanSquares=[];accumulatedMoments=[];accumulatedMeanGrads=[];applyGradients(t){(Array.isArray(t)?t.map(o=>o.name):Object.keys(t)).forEach((o,s)=>{let a=N.registeredVariables[o],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${o}/rms`,variable:z(()=>we(a).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${o}/momentum`,variable:z(()=>we(a).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${o}/mg`,variable:z(()=>we(a).variable(i))});let u=Array.isArray(t)?t[s].tensor:t[o];if(u==null)return;let l=this.accumulatedMeanSquares[s].variable,p=this.accumulatedMoments[s].variable;z(()=>{let m=Z(P(l,this.decay),P(He(u),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[s].variable,d=Z(P(c,this.decay),P(u,1-this.decay)),f=fe(P(u,this.learningRate),Ft(de(m,Z(He(d),this.epsilon)))),h=Z(P(p,this.momentum),f);l.assign(m),c.assign(d),p.assign(h);let g=de(a,h);a.assign(g)}else{let c=Z(P(l,this.decay),P(He(u),1-this.decay)),d=Z(P(p,this.momentum),fe(P(u,this.learningRate),Ft(Z(c,this.epsilon))));l.assign(c),p.assign(d);let f=de(a,d);a.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&_e(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&_e(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&_e(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);let n=this.centered?t.length/3:t.length/2,o=!1;this.accumulatedMeanSquares=t.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedMoments=t.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}};K(Nl,"className","RMSProp");Rn(Nl);var oi=class{static sgd(e){return new $i(e)}static momentum(e,t,n=!1){return new wl(e,t,n)}static rmsprop(e,t=.9,n=0,o=null,s=!1){return new Nl(e,t,n,o,s)}static adam(e=.001,t=.9,n=.999,o=null){return new vl(e,t,n,o)}static adadelta(e=.001,t=.95,n=null){return new Sl(e,t,n)}static adamax(e=.002,t=.9,n=.999,o=null,s=0){return new Al(e,t,n,o,s)}static adagrad(e,t=.1){return new kl(e,t)}};var yp={sgd:oi.sgd,momentum:oi.momentum,adadelta:oi.adadelta,adagrad:oi.adagrad,rmsprop:oi.rmsprop,adamax:oi.adamax,adam:oi.adam};var m7=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r())();function Ph(){return new Promise(r=>m7(()=>r()))}var C={};qe(C,{ERF_A1:()=>A7,ERF_A2:()=>w7,ERF_A3:()=>N7,ERF_A4:()=>D7,ERF_A5:()=>_7,ERF_P:()=>v7,PARALLELIZE_THRESHOLD:()=>Oy,RowPartitionType:()=>qM,SELU_SCALE:()=>wA,SELU_SCALEALPHA:()=>AA,applyActivation:()=>gp,assertAndGetBroadcastShape:()=>Oe,assertAxesAreInnerMostDims:()=>BX,assertParamsConsistent:()=>c7,assignToTypedArray:()=>L7,axesAreInnerMostDims:()=>cA,calculateShapes:()=>h1,checkEinsumDimSizes:()=>W7,checkPadOnDimRoundingMode:()=>_t,combineLocations:()=>Z1,combineRaggedTensorToTensorShapes:()=>f7,complexWithEvenIndex:()=>P7,complexWithOddIndex:()=>E7,computeConv2DInfo:()=>op,computeConv3DInfo:()=>B1,computeDefaultPad:()=>mA,computeDilation2DInfo:()=>z5,computeOptimalWindowSize:()=>y7,computeOutAndReduceShapes:()=>dA,computeOutShape:()=>d7,computePool2DInfo:()=>pA,computePool3DInfo:()=>G5,convertConv2DDataFormat:()=>O1,decodeEinsumEquation:()=>z7,eitherStridesOrDilationsAreOne:()=>Or,expandShapeToKeepDim:()=>Hs,exponent:()=>B7,exponents:()=>$7,fromStringArrayToUint8:()=>lJ,fromUint8ToStringArray:()=>uJ,getAxesPermutation:()=>fA,getBroadcastDims:()=>c1,getComplexWithIndex:()=>F7,getEinsumComputePath:()=>U7,getEinsumPermutation:()=>G7,getFusedBiasGradient:()=>hp,getFusedDyActivation:()=>fp,getImageCenter:()=>T7,getInnerMostAxes:()=>OX,getPermuted:()=>I7,getRaggedRank:()=>g7,getReductionAxes:()=>vt,getReshaped:()=>x7,getReshapedPermuted:()=>C7,getRowPartitionTypesHelper:()=>h7,getSliceBeginCoords:()=>S7,getSliceSize:()=>k7,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>q7,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>j7,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>X7,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Q7,getSparseReshapeInputOutputMismatchErrorMessage:()=>eJ,getSparseReshapeInputOutputMultipleErrorMessage:()=>J7,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Y7,getSparseReshapeNegativeOutputDimErrorMessage:()=>Z7,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>oJ,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>tJ,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>rJ,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>nJ,getUndoAxesPermutation:()=>Nh,isIdentityPermutation:()=>K7,log:()=>X6,mergeRealAndImagArrays:()=>M7,prepareAndValidate:()=>f1,prepareSplitSize:()=>H7,segment_util:()=>DA,shouldFuse:()=>bp,slice_util:()=>It,splitRealAndImagArrays:()=>R7,tupleValuesAreOne:()=>ps,upcastType:()=>Pt,validateDefaultValueShape:()=>b7,validateInput:()=>zb,validateUpdateShape:()=>oA,warn:()=>_i});function c7(r,e){let t=r[0].length;r.forEach((o,s)=>{D(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),D(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let n=r[0];r.forEach((o,s)=>{for(let a=0;a<t;a++)D(a===e||o[a]===n[a],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function d7(r,e){let t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}var qM=(a=>(a[a.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",a[a.VALUE_ROWIDS=1]="VALUE_ROWIDS",a[a.ROW_LENGTHS=2]="ROW_LENGTHS",a[a.ROW_SPLITS=3]="ROW_SPLITS",a[a.ROW_LIMITS=4]="ROW_LIMITS",a[a.ROW_STARTS=5]="ROW_STARTS",a))(qM||{});function f7(r,e,t){let n=new Array;if(t==null&&e==null)return n;if(e==null)for(;n.length<r+t.length;)n.push(-1);else n=e.slice();if(t==null)return n;if(r+t.length!==n.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${r+t.length}, but shape.rank = ${n.length}`);for(let o=1;o<t.length;++o){let s=t[o],a=n[n.length-t.length+o],i=n[a];if(s>=0)if(i>=0){if(i!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${o+r}] = ${s} but shape[${o+r}] = ${i}`)}else n[a]=s}return n}function h7(r){let e={FIRST_DIM_SIZE:0,VALUE_ROWIDS:1,ROW_LENGTHS:2,ROW_SPLITS:3,ROW_LIMITS:4,ROW_STARTS:5},t=[];for(let n of r)if(n in e)t.push(e[n]);else break;return t}function g7(r){return r.length===0?0:r[0]===0?r.length-1:r.length}function b7(r,e){if(r==null||e==null)return;let t=r.length,n=e.length;if(t>=n)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${n})`);for(let o=0;o<Math.min(t,n-1);++o){let s=r[o],a=e[o+1];if(s>=0&&a>=0&&s!==1&&s!==a)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${o-r.length}] = ${s} but ragged tensor input.flatValues.shape[${o-r.length}] = ${a}`)}}var Oy=30;function y7(r){return r<=Oy?r:km(r,Math.floor(Math.sqrt(r)))}function T7(r,e,t){let n=t*(typeof r=="number"?r:r[0]),o=e*(typeof r=="number"?r:r[1]);return[n,o]}function x7(r,e,t,n=!0){let o=[];if(n)o=o.concat(e.slice(0)),o.push(r[0]/t),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=e.length;for(let a=0;a<s;++a)o=o.concat([r[a+1]/e[a],e[a]]);o=o.concat(r.slice(s+1))}return o}function I7(r,e,t=!0){let n=[];if(t){n.push(e);for(let o=e+1;o<r;++o)o<=2*e?(n.push(o),n.push(o-(e+1))):n.push(o)}else{let o=[],s=[];for(let a=1;a<r;++a)a>=e*2+1||a%2===1?s.push(a):o.push(a);n.push(...o),n.push(0),n.push(...s)}return n}function C7(r,e,t,n=!0){let o=[];n?o.push(r[0]/t):o.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?o.push(e[s-1]*r[s]):o.push(r[s]/e[s-1]):o.push(r[s]);return o}function S7(r,e){let t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function k7(r,e,t){let n=r.slice(0,1);for(let o=0;o<t;++o)n.push(r[o+1]-e[o][0]-e[o][1]);return n}var AA=1.7580993408473768,wA=1.0507009873554805;var v7=.3275911,A7=.254829592,w7=-.284496736,N7=1.421413741,D7=-1.453152027,_7=1.061405429;function M7(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);let t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}function R7(r){let e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)e[n/2]=r[n],t[n/2]=r[n+1];return{real:e,imag:t}}function P7(r){let e=Math.ceil(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=0;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function E7(r){let e=Math.floor(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=2;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function F7(r,e){let t=r[e*2],n=r[e*2+1];return{real:t,imag:n}}function L7(r,e,t,n){r[n*2]=e,r[n*2+1]=t}function $7(r,e){let t=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(e?2:-2)*Math.PI*(o/r);t[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:t,imag:n}}function B7(r,e,t){let n=(t?2:-2)*Math.PI*(r/e),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var NA="->",O7=/->/g,jM=",",XM="...";function z7(r,e){r=r.replace(/\s/g,"");let t=(r.length-r.replace(O7,"").length)/NA.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${NA}").`);let[n,o]=r.split(NA);D(n.indexOf(XM)===-1,()=>`The ellipsis notation ("${XM}") is not supported yet.`);let s=n.split(jM),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let c=0;c<o.length;++c){let d=o[c];if(!s.some(f=>f.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);i.indexOf(d)===-1&&i.push(d)}for(let c=0;c<n.length;++c){let d=n[c];i.indexOf(d)===-1&&d!==jM&&i.push(d)}let u=new Array(s.length);for(let c=0;c<a;++c){if(new Set(s[c].split("")).size!==s[c].length)throw new Error(`Found duplicate axes in input component ${s[c]}. Support for duplicate axes in input is not implemented yet.`);u[c]=[];for(let d=0;d<s[c].length;++d)u[c].push(i.indexOf(s[c][d]))}let l=i.length,p=o.length,m=[];for(let c=p;c<l;++c)m.push(c);return{allDims:i,summedDims:m,idDims:u}}function G7(r,e){let t=new Array(r);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let n=[];for(let o=0;o<r;++o)t[o]===-1&&n.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:n}}function W7(r,e,t){let n=new Array(r);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let a=0;a<e[o].length;++a)n[e[o][a]]===void 0?n[e[o][a]]=s[a]:D(n[e[o][a]]===s[a],()=>`Expected dimension ${n[e[o][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function U7(r,e){let t=r,n=[],o=0;r.length===0&&t.push(-1),o=r.length+1;for(let a=0;a<o;++a)n.push([]);let s=[];for(let a=0;a<t.length;++a){let i=t[a],u=V7(e,i);for(let l of u)s.indexOf(l)===-1&&(n[a].push(l),s.push(l))}return{path:t,steps:n}}function K7(r){return r.every((e,t)=>e===t)}function V7(r,e){let t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function H7(r,e,t=0){let n=[];if(typeof e=="number")D(r.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{let o=e.reduce((a,i)=>(i===-1&&(a+=1),a),0);D(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let a=e.reduce((i,u)=>u>0?i+u:i);e[s]=r.shape[t]-a}D(r.shape[t]===e.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}function q7(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function j7(r,e){return`indices(${r}, 0) is invalid: ${e} < 0`}function X7(r,e,t){return`indices(${r}, 0) is invalid: ${e} >= ${t}`}function Y7(r,e){return`only one output dimension may be -1, not both ${r} and ${e}`}function Z7(r,e){return`size ${r} must be non-negative, not ${e}`}function Q7(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function J7(r,e){let t=nt(r),n=nt(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${e}`}function eJ(r,e){let t=nt(r),n=nt(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${e}`}function tJ(){return"segment ids must be >= 0"}function rJ(){return"segment ids are not increasing"}function nJ(r,e){return`Segment id ${r} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function oJ(r,e,t){return`Bad: indices[${r}] == ${e} out of range [0, ${t})`}var DA={};qe(DA,{collectGatherOpShapeInfo:()=>iJ,computeOutShape:()=>aJ,segOpComputeOptimalWindowSize:()=>sJ});function sJ(r,e){let t=!1,n;for(r<=Oy?(n=r,t=!0):n=km(r,Math.floor(Math.sqrt(r)));!t;)n>e||n===r?t=!0:n=km(r,n+1);return n}function aJ(r,e,t){let n=[],o=r.length;for(let s=0;s<o;s++)s!==e?n.push(r[s]):n.push(t);return n}function iJ(r,e,t,n){let o=e.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let m=0;m<n;++m)if(r.shape[m]!==e.shape[m])throw new Error(`x.shape[${m}]: ${r.shape[m]} should be equal to indices.shape[${m}]: ${e.shape[m]}.`);let a=r.shape[t],i=[],u=1,l=1,p=1;for(let m=0;m<n;++m)i.push(r.shape[m]),u*=r.shape[m];for(let m=n;m<t;m++)i.push(r.shape[m]),l*=r.shape[m];for(let m=n;m<o;m++)i.push(e.shape[m]);for(let m=t+1;m<s;m++)i.push(r.shape[m]),p*=r.shape[m];return{batchSize:u,sliceSize:p,outerSize:l,dimSize:a,outputShape:i}}function uJ(r){try{return r.map(e=>Qm(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function lJ(r){return r.map(e=>il(e))}var xr={};qe(xr,{nonMaxSuppressionV3Impl:()=>Ly,nonMaxSuppressionV4Impl:()=>$y,nonMaxSuppressionV5Impl:()=>By,whereImpl:()=>_y});var En=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,En.prototype)}},Zr=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Zr.prototype)}},B=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,B.prototype)}},Ne=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ne.prototype)}},Sc=class extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Sc.prototype)}};var Eh=class{cache;maxEntries;constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=e}};function Zs(r,e){if(Array.isArray(r)){let t=[];for(let n=0;n<e;n++)t=t.concat(r);return t}else{let t=new Array(e);return t.fill(r),t}}function hs(r,e){if(!r)throw new Sc(e)}function MA(r,e){let t=0;for(let n of r)n===e&&t++;return t}function Pr(r){return r.length===1?r[0]:r}function At(r){return Array.isArray(r)?r:[r]}function Qs(r){let t=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function fu(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}var Ys={};function kc(r){if(r==null)return null;let e={};return e.className=r.getClassName(),e.config=r.getConfig(),e}function _A(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(e=>_A(e));else{let e=Object.keys(r);for(let t of e){let n=r[t];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[t]=n.value:_A(n))}}}function Bi(r,e={},t={},n="object",o=!1){if(typeof r=="string"){let s=r,a;if(s in t)a=t[s];else if(s in Ys)a=Ys[s];else if(a=e[s],a==null)throw new B(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let s=r;if(s.className==null||s.config==null)throw new B(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let a=s.className,i,u;if(a in t?[i,u]=t[a]:a in Ys?[i,u]=Ys.className:a in e&&([i,u]=e[a]),i==null)throw new B(`Unknown ${n}: ${a}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let d of Object.keys(Ys))l[d]=Ys[d];for(let d of Object.keys(t))l[d]=t[d];let p=s.config;p.customObjects=l;let m={...Ys};for(let d of Object.keys(t))Ys[d]=t[d];_A(s.config);let c=u(i,s.config,t,o);return Ys={...m},c}else{let l={...Ys};for(let m of Object.keys(t))Ys[m]=t[m];let p=new i(s.config);return Ys={...l},p}}}function pJ(r,e){return r<e?-1:r>e?1:0}function Fh(r,e){return-1*pJ(r,e)}function Js(r){if(r==null)return r;let e=[];for(let t of r)e.indexOf(t)===-1&&e.push(t);return e}function YM(r){if(r==null)throw new B(`Invalid value in obj: ${JSON.stringify(r)}`);for(let e in r)if(r.hasOwnProperty(e))return!1;return!0}function Oi(r,e,t){if(t!=null&&r.indexOf(t)<0)throw new B(`${t} is not a valid ${e}.  Valid values are ${r} or null/undefined.`)}function zy(r,e,t=0,n=1/0){return hs(t>=0),hs(n>=t),Array.isArray(r)&&r.length>=t&&r.length<=n&&r.every(o=>typeof o===e)}function sr(r,e){Array.isArray(r)?(y.assert(r.length>0,()=>`${e} is unexpectedly an empty array.`),r.forEach((t,n)=>sr(t,`element ${n+1} of ${e}`))):y.assert(Number.isInteger(r)&&r>0,()=>`Expected ${e} to be a positive integer, but got ${ZM(r)}.`)}function ZM(r){return r===null?"null":Array.isArray(r)?"["+r.map(e=>ZM(e)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function QM(r,e,t){let n=t!=null?t():y.now(),o;return(...a)=>{let i=t!=null?t():y.now();return i-n<e||(n=i,o=r(...a)),o}}function Gy(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var mJ=0;function Uy(){return mJ++}var Wy={};function Dl(r=""){return r in Wy||(Wy[r]=0),Wy[r]+=1,r+Wy[r].toString()}var JM=["channelsFirst","channelsLast"],eR=["nearest","bilinear"],tR=["valid","same","causal"],rR=["max","avg"],nR=["sum","mul","concat","ave"];var vc=new Map;function Gt(r){Oi(JM,"DataFormat",r)}function sR(r){Oi(eR,"InterpolationFormat",r)}function yn(r){Oi(tR,"PaddingMode",r)}function RA(r){Oi(rR,"PoolMode",r)}var Lh=[],oR="/";function ai(r,e){Lh.push(r);try{let t=e();return Lh.pop(),t}catch(t){throw Lh.pop(),t}}function cJ(){return Lh.length===0?"":Lh.join(oR)+oR}function Ky(r){if(!aR(r))throw new Error("Not a valid tensor name: '"+r+"'");return cJ()+r}function Vy(r){if(!aR(r))throw new Error("Not a valid tensor name: '"+r+"'");vc.has(r)||vc.set(r,0);let e=vc.get(r);if(vc.set(r,vc.get(r)+1),e>0){let t=`${r}_${e}`;return vc.set(t,1),t}else return r}var dJ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function aR(r){return!!r.match(dJ)}function iR(r){return r===parseInt(r.toString(),10)}function ea(r,e,t){e==null&&(e=0),t==null&&(t=r.length);let n=1;for(let o=e;o<t;++o)n*=r[o];return n}function Tp(r){if(r.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n<e&&(e=n)}return e}function ii(r){if(r.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n>e&&(e=n)}return e}function Tn(r,e){if(e<r)throw new B(`end (${e}) < begin (${r}) is forbidden.`);let t=[];for(let n=r;n<e;++n)t.push(n);return t}var PA;function fr(){return PA==null&&(PA=l1().epsilon()),PA}function xn(){return"channelsLast"}function un(r,e){return re(r,e)}function gu(r,e=-1){let t=r.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),F(r,t)}function uR(r,e){return z(()=>{if(r.shape.length!==2)throw new B(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let t=gu(r,1);return qy(t,[1,e,1])})}function lR(r){let e=[ea(r.shape)];return F(r,e)}function pR(r){if(r.rank<=1)throw new B(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let e=[r.shape[0],ea(r.shape,1)];return F(r,e)}function hu(r,e,t){return z(()=>{switch(r.rank){case 1:return gc(r,e,t);case 2:return Mh(r,[e,0],[t,r.shape[1]]);case 3:return bc(r,[e,0,0],[t,r.shape[1],r.shape[2]]);case 4:return cp(r,[e,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3]]);case 5:return ze(r,[e,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return ze(r,[e,0,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new B(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function EA(r,e,t){return z(()=>{switch(r.rank){case 1:return gc(r,e,t);case 2:return Mh(r,[0,e],[r.shape[0],t]);case 3:return bc(r,[0,0,e],[r.shape[0],r.shape[1],t]);case 4:return cp(r,[0,0,0,e],[r.shape[0],r.shape[1],r.shape[2],t]);default:throw new B(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function $h(r,e,t,n){return z(()=>{switch(r.rank){case 1:return gc(r,e,t);case 2:switch(n){case 1:return hu(r,e,t);case 2:return EA(r,e,t);default:throw new B(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return hu(r,e,t);case 2:return bc(r,[0,e,0],[r.shape[0],t,r.shape[2]]);case 3:return EA(r,e,t);default:throw new B(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return hu(r,e,t);case 2:return cp(r,[0,e,0,0],[r.shape[0],t,r.shape[2],r.shape[3]]);case 3:return cp(r,[0,0,e,0],[r.shape[0],r.shape[1],t,r.shape[3]]);case 4:return EA(r,e,t);default:throw new B(`The axis is not within the rank of the tensor ${n}`)}default:throw new B(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Ac(r,e=-1){let t;return e<0&&(t=r[0].rank,t!==0?e=t:e=0),e===r[0].rank&&(e=-1),ct(r,e)}function LA(r,e){switch(r.rank){case 1:return Yb([r,e]);case 2:return Zb([r,e],0);case 3:return Qb([r,e],0);case 4:return Jb([r,e],0);default:throw new B(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function qy(r,e){if(Array.isArray(e)||(e=[e]),r.rank!==e.length)throw new B(`The length of input n (${e.length}) does not match the number of dimensions in input x (${r.rank})`);return on(r,e)}function wc(r,e=0,t=1,n,o){return mp(r,e,t,n,o)}function ta(r,e,t,n){if(r.rank<2||e.rank<2)throw new Ne(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${e.shape}`);if(e.rank>=3){let o=r.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(o!==s)throw new Ne(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${e.shape}`)}if(r.rank===2&&e.rank===2)return Cl.matMul({a:r,b:e,transposeA:!1,transposeB:!1,bias:n?FA(r.rank,n,xn()):null,activation:t});{let o=r.shape.slice(),s=o.pop();r=F(r,[-1,s]);let a=e.shape.slice(),i=a.pop(),u=a.pop(),l=[...a,i],p=Array.from({length:e.rank},(f,h)=>h===0?e.rank-2:h<=e.rank-2?h-1:h);e=F(Ge(e,p),[u,-1]);let m=[...o,...l],c=!1,d=!1;return F(Cl.matMul({a:r,b:e,transposeA:c,transposeB:d,bias:n?FA(r.rank,n,xn()):null,activation:t}),m)}}function jy(r,e,t){return z(()=>(Array.isArray(e)?e=Jt(e,"int32"):e=re(e,"int32"),xl(r,e,t)))}function xp(r){return P(r,r)}function FA(r,e,t){let n=e.shape;if(e.rank!==1&&e.rank!==r)throw new B(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${r}`);if(r===5){if(t==="channelsFirst")return n.length===1?F(e,[1,n[0],1,1,1]):F(e,[1,n[3],n[0],n[1],n[2]]);if(t==="channelsLast")return n.length===1?F(e,[1,1,1,1,n[0]]):F(e,[1].concat(n))}else if(r===4){if(t==="channelsFirst")return n.length===1?F(e,[1,n[0],1,1]):F(e,[1,n[2],n[0],n[1]]);if(t==="channelsLast")return n.length===1?F(e,[1,1,1,n[0]]):F(e,[1].concat(n))}else if(r===3){if(t==="channelsFirst")return n.length===1?F(e,[1,n[0],1]):F(e,[1,n[1],n[0]]);if(t==="channelsLast")return n.length===1?F(e,[1,1,n[0]]):F(e,[1].concat(n))}else if(r<3)return e;throw new B(`Unsupported input rank by biasAdd: ${e.rank}`)}function In(r,e,t){return z(()=>(t==null&&(t=xn()),Gt(t),Z(r,FA(r.rank,e,t))))}function mR(r,e=1){if(e!==1)throw new Ne(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return yl(r)}function cR(r){return z(()=>fe(r,Z(Ot(r),1)))}function Xy(r,e,t,n){return z(()=>CA(r,e,t,n))}function dR(r){return z(()=>{let e=Z(.5,P(.2,r));return Hr(e,0,1)})}function _l(r,e,t=!1){return t?r():e()}var fR=["fanIn","fanOut","fanAvg"],hR=["normal","uniform","truncatedNormal"];function fJ(r){Oi(fR,"FanMode",r)}function hJ(r){Oi(hR,"Distribution",r)}var Cn=class extends Q.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},Nc=class extends Cn{apply(e,t){return Ct(e,t)}};K(Nc,"className","Zeros");Q.registerClass(Nc);var Ml=class extends Cn{apply(e,t){return Tr(e,t)}};K(Ml,"className","Ones");Q.registerClass(Ml);var Dc=class extends Cn{value;constructor(e){if(super(),typeof e!="object")throw new B(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new B(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return z(()=>P(ge(this.value),Tr(e,t)))}getConfig(){return{value:this.value}}};K(Dc,"className","Constant");Q.registerClass(Dc);var _c=class extends Cn{DEFAULT_MINVAL=-.05;DEFAULT_MAXVAL=.05;minval;maxval;seed;constructor(e){super(),this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Ei(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};K(_c,"className","RandomUniform");Q.registerClass(_c);var Mc=class extends Cn{DEFAULT_MEAN=0;DEFAULT_STDDEV=.05;mean;stddev;seed;constructor(e){super(),this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ne(`randomNormal does not support dType ${t}.`);return wc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};K(Mc,"className","RandomNormal");Q.registerClass(Mc);var Rc=class extends Cn{DEFAULT_MEAN=0;DEFAULT_STDDEV=.05;mean;stddev;seed;constructor(e){super(),this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ne(`truncatedNormal does not support dType ${t}.`);return Ic(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};K(Rc,"className","TruncatedNormal");Q.registerClass(Rc);var Pc=class extends Cn{gain;constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return z(()=>{if(e.length!==2||e[0]!==e[1])throw new B("Identity matrix initializer can only be used for 2D square matrices.");return P(this.gain,ip(e[0]))})}getConfig(){return{gain:this.gain}}};K(Pc,"className","Identity");Q.registerClass(Pc);function gJ(r,e="channelsLast"){let t,n;if(Gt(e),r.length===2)t=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(e==="channelsFirst"){let o=ea(r,2);t=r[1]*o,n=r[0]*o}else if(e==="channelsLast"){let o=ea(r,0,r.length-2);t=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=ea(r);t=Math.sqrt(o),n=Math.sqrt(o)}return[t,n]}var Qr=class extends Cn{scale;mode;distribution;seed;constructor(e){if(super(),e.scale<0)throw new B(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,fJ(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,hJ(this.distribution),this.seed=e.seed}apply(e,t){let n=gJ(e),o=n[0],s=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,o):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(o+s)/2),this.distribution==="normal"){let i=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Ne(`${this.getClassName()} does not support dType ${t}.`);return Ic(e,0,i,t,this.seed)}else{let i=Math.sqrt(3*a);return Ei(e,-i,i,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};K(Qr,"className","VarianceScaling");Q.registerClass(Qr);var Ip=class extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(Ip,"className","GlorotUniform");Q.registerClass(Ip);var Cp=class extends Qr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(Cp,"className","GlorotNormal");Q.registerClass(Cp);var Sp=class extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(Sp,"className","HeNormal");Q.registerClass(Sp);var kp=class extends Qr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(kp,"className","HeUniform");Q.registerClass(kp);var vp=class extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(vp,"className","LeCunNormal");Q.registerClass(vp);var Ap=class extends Qr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Qr.className}};K(Ap,"className","LeCunNormal");Q.registerClass(Ap);var Ec=class extends Cn{DEFAULT_GAIN=1;gain;seed;constructor(e){if(super(),this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Ne("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return z(()=>{if(e.length<2)throw new Ne("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,o=wc(n,0,1,"float32"),s=vA.gramSchmidt(o);return e[0]>e[1]&&(s=Ge(s)),P(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};K(Ec,"className","Orthogonal");Q.registerClass(Ec);var gR={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function bR(r,e={}){return Bi(r,Q.SerializationMap.getMap().classNameMap,e,"initializer")}function Mt(r){return kc(r)}function St(r){if(typeof r=="string"){let e=r in gR?gR[r]:r;if(e==="GlorotNormal")return new Cp;if(e==="GlorotUniform")return new Ip;if(e==="HeNormal")return new Sp;if(e==="HeUniform")return new kp;if(e==="LeCunNormal")return new vp;if(e==="LeCunUniform")return new Ap;{let t={};return t.className=e,t.config={},bR(t)}}else return r instanceof Cn?r:bR(r)}function Yy(r){return Array.isArray(r)&&Array.isArray(r[0])}function Fc(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function De(r){let e;if(Array.isArray(r)){if(r.length!==1)throw new B(`Expected Tensor length to be 1; got ${r.length}`);e=r[0]}else e=r;return e}function Ke(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new B(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function Lc(r){let e=0;for(let t of r)t.shape.length===0?e+=1:e+=t.shape.reduce((n,o)=>n*o);return e}var TR="Variable",Bh=class{dtype;shape;id;name;originalName;trainable_;val;constraint;constructor(e,t="float32",n=TR,o=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Uy(),n=n??TR,this.originalName=Ky(n),this.name=Vy(this.originalName),this.trainable_=o,this.constraint=s,this.val=Dy(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),yJ(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function yJ(r,e){if(r.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(e.shape))}function Oh(r){return r.map(e=>e.read())}function $c(r){r.forEach(e=>{e[0].write(e[1])})}var wt=class{dtype;shape;ndim;maxNDim;minNDim;axes;constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},ln=class{constructor(e,t,n,o,s,a,i){this.dtype=e;this.shape=t;this.sourceLayer=n;this.inputs=o;this.callArgs=s;this.outputTensorIndex=i;this.id=Uy(),a!=null&&(this.originalName=Ky(a),this.name=Vy(this.originalName)),this.rank=t.length}id;name;originalName;rank;nodeIndex;tensorIndex},TJ=0,bu=class{constructor(e,t){this.callArgs=t;this.id=TJ++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}outboundLayer;inboundLayers;nodeIndices;tensorIndices;inputTensors;outputTensors;inputMasks;outputMasks;inputShapes;outputShapes;id;getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},xJ=0,Ee=class extends Q.Serializable{name;inputSpec;supportsMasking;trainable_;batchInputShape;dtype;initialWeights;inboundNodes;outboundNodes;activityRegularizer;_trainableWeights;_nonTrainableWeights;_losses;_updates;_built;_callHook=null;_addedWeightNames=[];id;_stateful=!1;_refCount;fastWeightInitDuringBuild;constructor(e={}){super(),this.id=xJ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Qs(n)+"_"+Dl(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let o=e.dtype;o==null&&(o=e.inputDType),o==null&&(o="float32"),this.dtype=o}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new Zr(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new B(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Pr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Pr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} is not connected, no input to return.`);return Pr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new En(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new En(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Pr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=At(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=At(this.inputSpec);if(e.length!==t.length)throw new B(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let o=e[n],s=t[n];if(s==null)continue;let a=o.rank;if(s.ndim!=null&&a!==s.ndim)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${a}`);if(s.maxNDim!=null&&a>s.maxNDim)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${a}`);if(s.minNDim!=null&&a<s.minNDim)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${a}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new B(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let i=o.shape;for(let u in s.axes){let l=Number(u),p=s.axes[u],m=l>=0?i[l]:i[i.length+l];if(p!=null&&[p,null].indexOf(m)===-1)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${p} but got shape ${i}.`)}}if(s.shape!=null)for(let i=0;i<s.shape.length;++i){let u=s.shape[i],l=o.shape[i];if(u!=null&&l!=null&&u!==l)throw new B(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=At(e),o=!0;for(let a of n)if(!(a instanceof ln)){o=!1;break}let s=!0;for(let a of n)if(a instanceof ln){s=!1;break}if(o===s)throw new B("Arguments to apply() must be all SymbolicTensors or all Tensors");return ai(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let a=[];for(let i of At(e))a.push(i.shape);this.build(Pr(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t),i=At(a),u=[];for(let l of i)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(a=Pr(u),this.activityRegularizer!=null)throw new Ne("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=IJ(e),i=this.computeOutputShape(a),u,l=CJ(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),i!=null&&i.length>0&&Array.isArray(i[0])?u=i.map((p,m)=>new ln(l,p,this,At(e),t,this.name,m)):u=new ln(l,i,this,At(e),t,this.name),this.addInboundNode(e,u,null,null,a,i,t),this._refCount++,this.activityRegularizer!=null)throw new Ne("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&e[o]!=null&&e[o]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new En(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new En(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Zr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Lc(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Oh(e?this.trainableWeights:this.weights)}setWeights(e){z(()=>{let t=this.weights;if(t.length!==e.length)throw new B(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],o=Oh(t);for(let s=0;s<o.length;++s){let a=o[s],i=t[s],u=e[s];if(!y.arraysEqual(a.shape,u.shape))throw new B(`Layer weight shape ${a.shape} not compatible with provided weight shape ${u.shape}`);n.push([i,u])}$c(n)})}addWeight(e,t,n,o,s,a,i,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new B(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():St("zeros"));let l=o.apply(t,n),p=new Bh(l,n,e,a,i);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(p.read())),a==null&&(a=!0),a?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=At(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,o,s,a,i=null){let u=At(e);t=At(t),n=At(n),o=At(o),s=Fc(s),a=Fc(a);let l=[],p=[],m=[];for(let c of u)l.push(c.sourceLayer),p.push(c.nodeIndex),m.push(c.tensorIndex);new bu({outboundLayer:this,inboundLayers:l,nodeIndices:p,tensorIndices:m,inputTensors:u,outputTensors:t,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:a},i);for(let c=0;c<t.length;c++)t[c].sourceLayer=this,t[c].nodeIndex=this.inboundNodes.length-1,t[c].tensorIndex=c}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function IJ(r){r=At(r);let e=[];for(let t of r)e.push(t.shape);return Pr(e)}function CJ(r){return"float32"}function $A(r,e,t){if((e==null||t!=null&&t>0)&&(e=r.sourceLayer,t=r.nodeIndex),e.inboundNodes.length===0)return[r];{let n=e.inboundNodes[t];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let a=n.inputTensors[s],i=n.inboundLayers[s],u=n.nodeIndices[s],l=$A(a,i,u);for(let p of l)o.indexOf(p)===-1&&o.push(p)}return o}}}var ui=class extends Ee{sparse;constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Dl("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new B("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new B("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new B("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let o=new ln(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new bu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new B(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};K(ui,"className","InputLayer");Q.registerClass(ui);function Zy(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new B("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=r.batchShape;r.shape!=null&&e==null&&(e=[null].concat(r.shape));let t=r.dtype;return t==null&&(t="float32"),new ui({batchInputShape:e,name:r.name,dtype:t,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function SJ(r,e){if(r.dtype==null||r.dtype===e.dtype)return e;try{return re(e,r.dtype)}catch{throw new B(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var ra=class{id2Value={};id2Mask={};name2Id={};constructor(e){if(e instanceof ra)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=SJ(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new B(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof ln){if(this.id2Value[e.id]==null)throw new B(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new B(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof ln){if(this.id2Value[e.id]==null)throw new B(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new B(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&_e(this.id2Mask)}},Qy=new Eh,Jy=new Eh;function IR(r){Qy?.setMaxEntries(r),Jy?.setMaxEntries(r)}function wp(r,e,t,n){let o=t==null?!1:t.training,s=Array.isArray(r),a=s?r:[r],i=a.map(f=>f.name),u=[],l=e.names();for(let f of i)l.indexOf(f)!==-1?u.push(e.getValue(f)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let p=i.join(",")+"|"+e.names().sort().join(","),m=Qy.get(p),c;if(m==null){let f=kJ(a,e);m=f.sorted,c=f.recipientCounts,Qy.put(p,m),Jy.put(p,c)}c={},o||Object.assign(c,Jy.get(p));let d=new ra(e);for(let f=0;f<m.length;++f){if(n!=null){let R=Ih().numTensors;R>n.maxNumTensors&&(n.maxNumTensors=R),R<n.minNumTensors&&(n.minNumTensors=R)}let h=m[f],g=h.sourceLayer;if(g instanceof ui)continue;let b=[],T=[],x=[],I=!1;for(let R of h.inputs){let E=d.getValue(R),O=d.getMask(R);b.push(E),T.push(O),O!=null&&(I=!0),o||(c[R.name]--,c[R.name]===0&&!e.hasKey(R)&&i.indexOf(R.name)===-1&&!E.isDisposed&&R.sourceLayer.stateful!==!0&&x.push(E))}I&&(t=t||{},t.mask=T[0]);let S=At(g.apply(b,t)),w=null;g.supportsMasking&&(w=g.computeMask(b,T));let _=AJ(h),M=Array.isArray(_)?_:[_];for(let R=0;R<M.length;++R){d.hasKey(M[R])||d.add(M[R],S[R],Array.isArray(w)?w[0]:w);let E=i.indexOf(M[R].name);E!==-1&&(u[E]=S[R])}o||_e(x)}return d.disposeMasks(),s?u:u[0]}function kJ(r,e){y.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let t=[],n={};if(r.length===1){let o=xR(r[0],e);t=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:a,recipientMap:i}=xR(s,e);for(let u of a)o.has(u.name)||(t.push(u),o.add(u.name));for(let u in i)n[u]==null&&(n[u]=new Set),i[u].forEach(l=>n[u].add(l))}}return{sorted:t,recipientCounts:vJ(n)}}function vJ(r){let e={};for(let t in r)e[t]=r[t].size;return e}function xR(r,e){let t=new Set,n=[],o={};for(let i of e.names())t.add(i);let s=[],a=[];for(s.push(r);s.length>0;){let i=s[s.length-1];if(t.has(i.name)){s.pop();continue}let u=a[a.length-1]===s.length-1;if(i.inputs.length===0||u)s.pop(),n.push(i),t.add(i.name),u&&a.pop();else{a.push(s.length-1);for(let l of i.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(i.name),!t.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function AJ(r){let e;if(r.sourceLayer.inboundNodes.length===1)e=r.sourceLayer.output;else{let t=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){t=n;break}e=r.sourceLayer.getOutputAt(t)}return e}var wJ=$();wJ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,IR);var eT={kernelName:xs,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,Li(re(t,"float32"),-1))}}};var CR={kernelName:ya,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=He(re(t,"float32")),o=Ft(de(ge(1),n));return tt(fe(r,o))}}}};var SR={kernelName:Ta,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Ft(de(He(re(t,"float32")),1));return fe(r,n)}}}};var kR={kernelName:Nn,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=r,u=vt(t.shape,o);return u.length>0&&(i=be(i,u)),F(i,t.shape)},b:()=>{let i=r,u=vt(n.shape,o);return u.length>0&&(i=be(i,u)),F(i,n.shape)}}}};var vR={kernelName:co,saveAllInputs:!0,gradFunc:(r,e)=>{let t={};return e.forEach((n,o)=>{t[o]=()=>r.clone()}),t}};var AR={kernelName:fo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>we(t)}}};var wR={kernelName:vi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>we(t)}}};var NR={kernelName:Ca,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,Ft(de(ge(1),He(re(t,"float32")))))}}};var DR={kernelName:Sa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Ft(Z(ge(1),He(re(t,"float32"))));return fe(r,n)}}}};var _R={kernelName:Aa,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=Z(He(t),He(n)),u=P(r,fe(n,i)),l=vt(t.shape,o);return l.length>0&&(u=be(u,l)),F(u,t.shape)},b:()=>{let i=Z(He(t),He(n)),u=tt(P(r,fe(t,i))),l=vt(n.shape,o);return l.length>0&&(u=be(u,l)),F(u,n.shape)}}}};var MR={kernelName:ka,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,Z(He(re(t,"float32")),1))}}};var RR={kernelName:va,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,de(ge(1),He(re(t,"float32"))))}}};function NJ(r,e,t,n,o,s){let a=v(r,"dy","avgPool3dGrad"),i=v(e,"input","avgPool3dGrad"),u=a,l=i,p=!1;i.rank===4&&(p=!0,u=F(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),l=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),D(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),_t("avgPool3dGrad",o,s);let m={dy:u,input:l},c={filterSize:t,strides:n,pad:o,dimRoundingMode:s},d=N.runKernel(wm,m,c);return p?F(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var PR=A({avgPool3dGrad_:NJ});var ER={kernelName:Bu,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a,dimRoundingMode:i}=t;return{x:()=>PR(r,n,o,s,a,i)}}};function DJ(r,e,t,n,o){let s=v(r,"dy","avgPoolGrad"),a=v(e,"input","avgPoolGrad");D(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let i=a,u=s,l=!1;a.rank===3&&(l=!0,i=F(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=F(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),D(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let p={dy:u,input:i},m={filterSize:t,strides:n,pad:o},c=N.runKernel(Am,p,m);return l?F(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var FR=A({avgPoolGrad_:DJ});var LR={kernelName:ho,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:a}=t;return{x:()=>FR(r,n,o,s,a)}}};var $R={kernelName:go,inputsToSave:["a","b"],gradFunc:(r,e,t)=>{let[n,o]=e,{transposeA:s,transposeB:a}=t;return!s&&!a?{a:()=>Ue(r,o,!1,!0),b:()=>Ue(n,r,!0,!1)}:!s&&a?{a:()=>Ue(r,o,!1,!1),b:()=>Ue(r,n,!0,!1)}:s&&!a?{a:()=>Ue(o,r,!1,!0),b:()=>Ue(n,r,!1,!1)}:{a:()=>Ue(o,r,!0,!0),b:()=>Ue(r,n,!0,!0)}}};var BR={kernelName:Is,gradFunc:(r,e,t)=>{let{blockShape:n,crops:o}=t;return{x:()=>fc(r,n,o)}}};var OR={kernelName:J0,gradFunc:(r,e,t)=>{let n=t,o=n.inputShape,s=n.shape,a=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])a[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let i=[];for(let u=0;u<a.length;u++)a[u]>1&&i.push(u);return{x:()=>be(r,i,!0)}}};var zR={kernelName:Un,gradFunc:r=>({x:()=>r.clone()})};var GR={kernelName:bo,gradFunc:r=>({x:()=>we(r)})};var WR={kernelName:Kn,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{clipValueMin:o,clipValueMax:s}=t;return{x:()=>zt(sn(Xn(n,o),qs(n,s)),r,we(r))}}};var UR={kernelName:Gu,inputsToSave:["x"],gradFunc:eT.gradFunc};var KR={kernelName:Cs,saveAllInputs:!0,gradFunc:(r,e,t)=>{let n=e.map(u=>u.shape),{axis:o}=t,s=gr(o,e[0].shape)[0],a=n.map(u=>u[s]);return Mr(r,a,s).map(u=>()=>u)}};var VR={kernelName:yo,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{dilations:s,strides:a,pad:i,dataFormat:u}=t;return D(ps(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>uc(n.shape,r,o,a,i,u),filter:()=>Cc(n,r,o.shape,a,i,u)}}};var HR={kernelName:To,inputsToSave:["dy","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{strides:s,pad:a,dataFormat:i,dimRoundingMode:u}=t;return{dy:()=>cs(r,o,s,a,i,1,u),filter:()=>Cc(r,n,o.shape,s,a,i,u)}}};function _J(r,e,t,n,o){let s=r;r.rank===4&&(s=F(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let a=e;a.rank===4&&(a=F(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),D(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),D(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),D(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),D(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),D(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);let i={x:s,dy:a},u={strides:n,pad:o,filterShape:t};return N.runKernel(_m,i,u)}var qR=A({conv3DBackpropFilter_:_J});var jR={kernelName:Wu,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s}=t;D(ps(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[a,i]=e;return{x:()=>ny(a.shape,r,i,o,s),filter:()=>qR(a,r,i.shape,o,s)}}};var XR={kernelName:xo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(tt(ky(re(t,"float32"))),r)}}};var YR={kernelName:Io,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(vy(re(t,"float32")),r)}}};var ZR={kernelName:Co,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o,exclusive:s,reverse:a}=t;return{x:()=>{let i=fA([o],n.rank),u=ay(r,o,s,!a);return i!=null&&(u=Ge(u,i)),u}}}};var QR={kernelName:So,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:a}=t,i=n??[1,1];D(ps(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[u,l]=e;return D(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),D(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),D(Or(o,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${i}'.`),_t("depthwiseConv2d",s,a),{x:()=>Py(u.shape,r,l,o,s,i,a),filter:()=>Ry(u,r,l.shape,o,s,i,a)}}};var JR={kernelName:Ku,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,s={x:n,filter:o,dy:r},a={x:n,filter:o,dy:r};return{x:()=>N.runKernel(uh,s,t),filter:()=>N.runKernel(lh,a,t)}}};var eP={kernelName:vo,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e,n={dy:r,y:t};return{x:()=>N.runKernel(Fm,n)}}};var tP={kernelName:_a,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=P(br(tt(He(t))),2/Math.sqrt(Math.PI));return{x:()=>P(r,n)}}};var rP={kernelName:Ao,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,t)}}};var nP={kernelName:Ss,inputsToSave:["input"],gradFunc:(r,e)=>{let[t]=e;return{input:()=>F(r,t.shape)}}};var oP={kernelName:Ra,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,br(t))}}};var sP={kernelName:wo,gradFunc:r=>({x:()=>we(r)})};var aP={kernelName:No,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=fe(r,re(n,"float32")),u=vt(t.shape,o);return u.length>0?F(be(i,u),t.shape):i},b:()=>{let i=P(r,re(t,"float32")),u=vt(n.shape,o);u.length>0&&(i=F(be(i,u),n.shape));let l=He(n);return tt(fe(i,re(l,"float32")))}}}};var iP={kernelName:Do,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,e,t)=>{let{varianceEpsilon:n}=t,[o,s,a,i]=e,u=i??ge(1),l=vt(s.shape,o.shape),p=[];if(s.rank===1){for(let I=0;I<o.shape.length-1;++I)p.push(o.shape[I]);p.push(1)}let m=de(o,s),c=P(r,u),d=Iy(Z(a,ge(n))),f=P(P(P(d,d),d),ge(-.5));return{x:()=>s.rank===1?F(P(P(r,on(F(d,[1,1,1,s.shape[0]]),p)),u),o.shape):F(P(P(r,d),u),o.shape),mean:()=>{let I=P(P(d,ge(-1)),c);return s.rank===1&&(I=be(I,l)),F(I,s.shape)},variance:()=>{let I=P(P(f,m),c);return s.rank===1&&(I=be(I,l)),F(I,s.shape)},scale:()=>{let I=P(m,d),S=P(r,I);return s.rank===1&&(S=be(S,l)),F(S,s.shape)},offset:()=>{let I=r;return s.rank===1&&(I=be(I,l)),F(I,s.shape)}}}};var pP={kernelName:ks,inputsToSave:["x","indices"],gradFunc:(r,e,t)=>{let[n,o]=e,{axis:s}=t,a=gr(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,p=u.slice(0,a),m=p.length,c=u.slice(s,u.length).slice(1),d=c.length,f=uP(0,m),h=uP(m+1,m+1+d),g=lP([p,[l],c]),b=F(r,g),T=F(o,[l]),x=lP([[m],f,h]),I=Ge(b,x),S=Ny(I,T,n.shape[a]),w=Nh(x);return S=Ge(S,w),S},indices:()=>o}}};function uP(r,e){let t=[];for(let n=r;n<e;++n)t.push(n);return t}function lP(r){let e=[];for(let t=0;t<r.length;++t)for(let n=0;n<r[t].length;++n)e.push(r[t][n]);return e}var mP={kernelName:_o,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>we(t),b:()=>we(n)}}};var cP={kernelName:Vn,gradFunc:r=>({x:()=>re(r,"float32")})};var dP={kernelName:La,gradFunc:r=>({x:()=>we(r)})};var fP={kernelName:$a,gradFunc:r=>({x:()=>we(r)})};var hP={kernelName:Mo,gradFunc:r=>({x:()=>we(r)})};var gP={kernelName:Ro,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{alpha:o}=t,s=Qt(n,0);return{x:()=>zt(s,r,P(r,o))}}};var bP={kernelName:za,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,Z(t,1))}}};var yP={kernelName:Po,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,re(t,"float32"))}}};var TP={kernelName:t_,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t;return{logits:()=>{let a=br(n);return de(r,P(be(r,o,!0),a))}}}};function MJ(r,e,t,n=5,o=1,s=1,a=.5){let i={x:r,y:e,dy:t},u={depthRadius:n,bias:o,alpha:s,beta:a};return N.runKernel($m,i,u)}var xP=A({localResponseNormalizationBackprop_:MJ});var IP={kernelName:Xu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{depthRadius:s,bias:a,alpha:i,beta:u}=t;return{x:()=>xP(n,o,r,s,a,i,u)}}};function tT(r,e,t,n){return e.rank<t.rank&&(e=F(e,Hs(e.shape,n))),r.rank<t.rank&&(r=F(r,Hs(r.shape,n))),{x:()=>P(r,re(nn(t,e),r.dtype))}}var BA={kernelName:Eo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{reductionIndices:o}=n,s=e[0],a=e[1],i=gr(o,s.shape),u=tT(r,a,s,i);return{x:()=>u.x()}}};var CP={kernelName:Fo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>P(r,re(Xn(t,n),"float32")),b:()=>P(r,re(iy(t,n),"float32"))}}};function RJ(r,e,t,n,o,s,a){let i=v(r,"dy","maxPool3dGrad"),u=v(e,"input","maxPool3dGrad"),l=v(t,"output","maxPool3dGrad"),p=i,m=u,c=l,d=!1;u.rank===4&&(d=!0,p=F(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),m=F(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),c=F(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),D(p.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),D(m.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${m.rank}.`),D(c.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${c.rank}.`),_t("maxPool3dGrad",s,a);let f={dy:p,input:m,output:c},h={filterSize:n,strides:o,pad:s,dimRoundingMode:a},g=N.runKernel(Om,f,h);return d?F(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var SP=A({maxPool3dGrad_:RJ});var kP={kernelName:Yu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=t;return{x:()=>SP(r,n,o,s,a,i,u)}}};function PJ(r,e,t,n,o,s,a){let i=v(r,"dy","maxPoolGrad"),u=v(e,"input","maxPoolGrad"),l=v(t,"output","maxPoolGrad");D(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),D(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),D(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),_t("maxPoolGrad",s,a);let p={dy:i,input:u,output:l},m={filterSize:n,strides:o,pad:s,dimRoundingMode:a};return N.runKernel(Bm,p,m)}var vP=A({maxPoolGrad_:PJ});var AP={kernelName:Lo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:a,pad:i}=t;return{x:()=>vP(r,n,o,s,a,i)}}};var wP={kernelName:$o,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t,s=gr(o,n.shape),i=dA(n.shape,s)[1],u=nt(i);return{x:()=>{let p=n.shape.slice();s.forEach(d=>{p[d]=1});let m=F(r,p);return fe(P(m,Tr(n.shape,"float32")),u)}}}};var NP={kernelName:Bo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{axis:o}=n,[s,a]=e,i=gr(o,s.shape),u=tT(r,a,s,i);return{x:()=>u.x()}}};var DP={kernelName:Oo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>P(r,re(qs(t,n),"float32")),b:()=>P(r,re(Qt(t,n),"float32"))}}};var _P={kernelName:zo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>ze(r,s,n.shape)}}};var MP={kernelName:Ua,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=vt(t.shape,o);return i.length>0?F(be(r,i),t.shape):r},b:()=>{let i=P(r,tt(Tl(fe(t,n)))),u=vt(n.shape,o);return u.length>0?F(be(i,u),n.shape):i}}}};var RP={kernelName:Go,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=P(r,re(n,"float32")),u=vt(t.shape,o);return u.length>0?F(be(i,u),t.shape):i},b:()=>{let i=P(r,re(t,"float32")),u=vt(n.shape,o);return u.length>0?F(be(i,u),n.shape):i}}}};var PP={kernelName:vs,gradFunc:r=>({x:()=>tt(r)})};var EP={kernelName:Wo,inputsToSave:["indices"],gradFunc:(r,e)=>{let t=e[0];return{indices:()=>Ct(t.shape,"float32")}}};var FP={kernelName:As,gradFunc:r=>({x:()=>we(r)})};var LP={kernelName:ws,saveAllInputs:!0,gradFunc:(r,e,t)=>{let{axis:n}=t;return Rr(r,n).map(s=>()=>s)}};var OA={kernelName:Uo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(a=>a[0]);return{x:()=>ze(r,s,n.shape)}}};var $P={kernelName:Ko,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,e)=>{let[t,n,o]=e,s=t,a=n,i=Oe(s.shape,a.shape);return{a:()=>{let p=re(a,"float32"),m=P(r,P(p,jn(s,de(p,ge(1))))),c=vt(s.shape,i);return c.length>0&&(m=be(m,c)),F(m,s.shape)},b:()=>{let p=Qt(s,0),m=zt(p,jr(s),we(s)),c=P(r,P(o,m)),d=vt(a.shape,i);return d.length>0&&(c=be(c,d)),F(c,a.shape)}}}};var BP={kernelName:Vo,inputsToSave:["x","alpha"],gradFunc:(r,e)=>{let[t,n]=e,o=Qt(t,0);return{x:()=>zt(o,r,P(r,n)),alpha:()=>{let s=zt(o,we(r),P(r,t)),a=vt(n.shape,r.shape);return a.length>0&&(s=be(s,a)),F(s,n.shape)}}}};function EJ(r,e,t){let n=r.shape.slice();n[t]=1;let o=F(e,n),s=Ah(r,t,!0,!1),a=Ah(r,t,!0,!0),i=P(s,a);return P(o,i)}function FJ(r,e,t){let n=r.shape.length,o=n-t.length,s=C.getAxesPermutation(t,n),a=r;s!=null&&(a=Ge(r,s));let i=a.shape.slice(),l=i.splice(n-t.length,t.length).reduce((c,d)=>c*d,1);i.push(l);let p=a.reshape(i),m=EJ(p,e,o);if(m=m.reshape(a.shape),s!=null){let c=C.getUndoAxesPermutation(s);m=Ge(m,c)}return m}var OP={kernelName:Ho,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t,s=[];return o==null?s=n.shape.map((a,i)=>i):typeof o=="number"?s=[o]:s=o,{x:()=>FJ(n,r,s)}}};var zP={kernelName:ko,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=fe(r,re(n,"float32")),u=vt(t.shape,o);return u.length>0?F(be(i,u),t.shape):i},b:()=>{let i=P(r,re(t,"float32")),u=vt(n.shape,o);u.length>0&&(i=F(be(i,u),n.shape));let l=He(n);return tt(fe(i,re(l,"float32")))}}}};var GP={kernelName:qo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,tt(He(t)))}}};var WP={kernelName:Zo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=P(qs(t,6),Li(t));return{x:()=>P(r,re(n,"float32"))}}};var UP={kernelName:jo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,re(Li(t),"float32"))}}};var KP={kernelName:Ns,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>F(r,t.shape)}}};var VP={kernelName:Yo,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(Hm,o,t)}}};var HP={kernelName:Xo,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(Vm,o,t)}}};var qP={kernelName:Qo,gradFunc:(r,e,t)=>{let{dims:n}=t,o=gr(n,r.shape);return{x:()=>_r(r,o)}}};var jP={kernelName:qa,gradFunc:r=>({x:()=>we(r)})};var XP={kernelName:Jo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>tt(fe(r,P(jn(t,1.5),2)))}}};var YP={kernelName:Ds,inputsToSave:["condition"],gradFunc:(r,e)=>{let[t]=e;return{condition:()=>re(we(t),"float32"),t:()=>P(r,re(t,r.dtype)),e:()=>P(r,re(cc(t),r.dtype))}}};var ZP={kernelName:tu,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Qt(t,ge(0)),o=ge(AA),s=ge(wA),a=P(r,s),i=P(P(r,o),br(re(t,"float32")));return zt(n,a,i)}}}};var QP={kernelName:ts,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,P(t,de(ge(1),t)))}}};var JP={kernelName:ru,gradFunc:r=>({x:()=>we(r)})};var eE={kernelName:es,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(lc(re(t,"float32")),r)}}};var tE={kernelName:Xa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(sy(re(t,"float32")),r)}}};var rE={kernelName:_s,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{begin:o,size:s}=t,a=n.shape,[i,u]=aA(n,o,s),l=[];for(let p=0;p<r.rank;p++)l.push([i[p],a[p]-i[p]-u[p]]);return{x:()=>Yn(r,l)}}};var nE={kernelName:os,outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{dim:o}=t,s=!0,a=P(r,n);return{logits:()=>de(a,P(be(a,[o],s),n))}}};var oE={kernelName:nu,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,Pn(t))}}};var zA={kernelName:Ms,gradFunc:(r,e,t)=>{let{blockShape:n,paddings:o}=t;return{x:()=>ic(r,n,o)}}};var GA={kernelName:Rs,gradFunc:(r,e,t)=>{let{axis:n}=t;return{x:()=>ct(r,n)}}};var sE={kernelName:rs,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,P(Ft(re(t,"float32")),2))}}};var aE={kernelName:Ni,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(r,P(re(t,"float32"),2))}}};var iE={kernelName:ss,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=ge(2);return{a:()=>P(r,P(o,de(t,n))),b:()=>P(r,P(o,de(n,t)))}}};var uE={kernelName:Fs,gradFunc:r=>({x:()=>we(r)})};var lE={kernelName:as,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Oe(t.shape,n.shape);return{a:()=>{let i=r,u=vt(t.shape,o);return u.length>0&&(i=be(i,u)),F(i,t.shape)},b:()=>{let i=r,u=vt(n.shape,o);return u.length>0&&(i=be(i,u)),F(tt(i),n.shape)}}}};var pE={kernelName:ns,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,o=n.shape.slice(),{axis:s}=t;gr(s,n.shape).forEach(l=>{o[l]=1});let i=F(r,o),u=P(i,Tr(n.shape,"float32"));return{x:()=>u}}};var mE={kernelName:is,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>fe(r,He(lc(t)))}}};var cE={kernelName:us,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>P(de(ge(1),He(t)),r)}}};var dE={kernelName:Dn,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{reps:o}=t;return{x:()=>{let a=we(n);if(n.rank===1)for(let i=0;i<o[0];++i)a=Z(a,ze(r,[i*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)a=Z(a,ze(r,[i*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)a=Z(a,ze(r,[i*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let p=0;p<o[3];++p)a=Z(a,ze(r,[i*n.shape[0],u*n.shape[1],l*n.shape[2],p*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return a}}}};var fE={kernelName:_n,gradFunc:(r,e,t)=>{let n=t,{perm:o}=n,s=Nh(o);return{x:()=>Ge(r,s)}}};var hE={kernelName:Ps,gradFunc:(r,e,t)=>{let n=t,{axis:o}=n;return{value:()=>cr(r,o)}}};var gE={kernelName:sl,inputsToSave:["segmentIds"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>LJ(r,t)}}};function LJ(r,e){let t=ds(e,we(e)),n=xl(r,t),o=Xn(e,ge(0,"int32")),s=n.rank-o.rank;for(let i=0;i<s;++i)o=yr(o,i+1);o=sn(o,Tr(n.shape,"bool"));let a=we(n);return zt(o,n,a)}var bE={kernelName:Es,gradFunc:r=>({x:()=>we(r)})};var $J=[eT,CR,SR,kR,vR,AR,wR,NR,DR,_R,MR,RR,ER,LR,$R,BR,OR,zR,GR,WR,UR,KR,HR,VR,jR,XR,YR,ZR,QR,JR,zP,eP,tP,rP,nP,oP,aP,sP,iP,pP,mP,cP,dP,fP,hP,gP,bP,yP,TP,IP,BA,BA,CP,kP,AP,wP,NP,DP,_P,MP,RP,PP,EP,FP,LP,OA,OA,$P,BP,OP,GP,WP,UP,KP,VP,HP,qP,jP,XP,YP,ZP,QP,JP,eE,tE,rE,nE,oE,zA,zA,GA,GA,sE,iE,aE,uE,lE,pE,mE,cE,dE,fE,hE,gE,bE];for(let r of $J)n_(r);var xE={};qe(xE,{maxNorm:()=>BJ,minMaxNorm:()=>GJ,nonNeg:()=>zJ,unitNorm:()=>OJ});function WA(r,e){return z(()=>Ft(be(P(r,r),e,!0)))}var Np=class extends Q.Serializable{getConfig(){return{}}},Bc=class extends Np{maxValue;axis;defaultMaxValue=2;defaultAxis=0;constructor(e){super(),this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return z(()=>{let t=WA(e,this.axis),n=Hr(t,0,this.maxValue);return P(e,fe(n,Z(fr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};K(Bc,"className","MaxNorm");Q.registerClass(Bc);var Oc=class extends Np{axis;defaultAxis=0;constructor(e){super(),this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return z(()=>fe(e,Z(fr(),WA(e,this.axis))))}getConfig(){return{axis:this.axis}}};K(Oc,"className","UnitNorm");Q.registerClass(Oc);var zc=class extends Np{apply(e){return an(e)}};K(zc,"className","NonNeg");Q.registerClass(zc);var Gc=class extends Np{minValue;maxValue;rate;axis;defaultMinValue=0;defaultMaxValue=1;defaultRate=1;defaultAxis=0;constructor(e){super(),this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return z(()=>{let t=WA(e,this.axis),n=Z(P(this.rate,Hr(t,this.minValue,this.maxValue)),P(1-this.rate,t));return P(e,fe(n,Z(fr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};K(Gc,"className","MinMaxNorm");Q.registerClass(Gc);var yE={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Vt(r){return kc(r)}function TE(r,e={}){return Bi(r,Q.SerializationMap.getMap().classNameMap,e,"constraint")}function Ht(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in yE?yE[r]:r,config:{}};return TE(t)}else return r instanceof Np?r:TE(r)}function BJ(r){return new Bc(r)}function OJ(r){return new Oc(r)}function zJ(){return new zc}function GJ(r){return new Gc(r)}var IE={};qe(IE,{constant:()=>KJ,glorotNormal:()=>ZJ,glorotUniform:()=>YJ,heNormal:()=>QJ,heUniform:()=>JJ,identity:()=>jJ,leCunNormal:()=>e9,leCunUniform:()=>t9,ones:()=>UJ,orthogonal:()=>r9,randomNormal:()=>HJ,randomUniform:()=>VJ,truncatedNormal:()=>qJ,varianceScaling:()=>XJ,zeros:()=>WJ});function WJ(){return new Nc}function UJ(){return new Ml}function KJ(r){return new Dc(r)}function VJ(r){return new _c(r)}function HJ(r){return new Mc(r)}function qJ(r){return new Rc(r)}function jJ(r){return new Pc(r)}function XJ(r){return new Qr(r)}function YJ(r){return new Ip(r)}function ZJ(r){return new Cp(r)}function QJ(r){return new Sp(r)}function JJ(r){return new kp(r)}function e9(r){return new vp(r)}function t9(r){return new Ap(r)}function r9(r){return new Ec(r)}var JE={};qe(JE,{Layer:()=>Ee,RNN:()=>gs,RNNCell:()=>xu,activation:()=>yee,add:()=>wee,alphaDropout:()=>pte,average:()=>Nee,averagePooling1d:()=>aw,averagePooling2d:()=>iw,averagePooling3d:()=>uw,avgPool1d:()=>$ee,avgPool2d:()=>Oee,avgPool3d:()=>Gee,avgPooling1d:()=>Bee,avgPooling2d:()=>zee,avgPooling3d:()=>Wee,batchNormalization:()=>Eee,bidirectional:()=>rte,categoryEncoding:()=>hte,centerCrop:()=>dte,concatenate:()=>Dee,conv1d:()=>lee,conv2d:()=>pee,conv2dTranspose:()=>mee,conv3d:()=>cee,conv3dTranspose:()=>dee,convLstm2d:()=>Qee,convLstm2dCell:()=>Jee,cropping2D:()=>hee,dense:()=>Tee,depthwiseConv2d:()=>bee,dot:()=>Pee,dropout:()=>xee,elu:()=>nee,embedding:()=>Aee,flatten:()=>Cee,gaussianDropout:()=>lte,gaussianNoise:()=>ute,globalAveragePooling1d:()=>Uee,globalAveragePooling2d:()=>Kee,globalMaxPool1d:()=>ote,globalMaxPool2d:()=>ste,globalMaxPooling1d:()=>XE,globalMaxPooling2d:()=>YE,gru:()=>Hee,gruCell:()=>qee,input:()=>YA,inputLayer:()=>ree,layerNormalization:()=>Fee,leakyReLU:()=>see,lstm:()=>jee,lstmCell:()=>Xee,masking:()=>mte,maxPool1d:()=>ate,maxPool2d:()=>ite,maxPooling1d:()=>ZE,maxPooling2d:()=>QE,maxPooling3d:()=>Vee,maximum:()=>_ee,minimum:()=>Mee,multiply:()=>Ree,permute:()=>vee,prelu:()=>aee,reLU:()=>oee,repeatVector:()=>See,rescaling:()=>cte,reshape:()=>kee,resizing:()=>fte,rnn:()=>ete,separableConv2d:()=>fee,simpleRNN:()=>Yee,simpleRNNCell:()=>Zee,softmax:()=>iee,spatialDropout1d:()=>Iee,stackedRNNCells:()=>tte,thresholdedReLU:()=>uee,timeDistributed:()=>nte,upSampling2d:()=>gee,zeroPadding2d:()=>Lee});async function zi(r){if(r==null)return;let e=[],t=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let a=s;e.push(a.data()),t.push(o),n.push(a)}}if(e.length>0){let o=await Promise.all(e);for(let s=0;s<o.length;++s)r[t[s]]=o[s][0];_e(n)}}function rT(r){if(r!=null)for(let e in r){let t=r[e];typeof t!="number"&&t.dispose()}}var n9=125,yu=class{validationData=null;params;setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},nT=class{callbacks;queueLength;constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},UA=class extends yu{seen;totals;constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let o in t){let s=t[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let a;o in this.totals?a=this.totals[o]:this.totals[o]=0;let i=z(()=>Z(this.totals[o],P(s,n)));this.totals[o]=i,a?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:z(()=>{let o=P(fe(1,this.seen),this.totals[n]);t[n]=o,this.totals[n].dispose(),Et(t[n])}))}},oT=class extends yu{epoch;history;async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let a=this.history[s];for(let i=0;i<a.length;++i)if(typeof a[i]!="number"){let u=a[i];e.push(u.data()),t.push(s),n.push(i)}}let o=await Promise.all(e);for(let s=0;s<o.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=o[s][0]}},sT=class extends yu{trainBegin;trainEnd;epochBegin;epochEnd;batchBegin;batchEnd;yield;yieldEvery;currentEpoch=0;nowFunc;nextFrameFunc;constructor(e,t){if(super(),this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Ph,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=n9),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");y.isNumber(this.yieldEvery)&&(this.maybeWait=QM(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let o=[];this.yield!=null&&(await zi(n),o.push(this.yield(e,t,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await zi(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await zi(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await zi(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await zi(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):y.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await zi(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await zi(e),await this.trainEnd(e))}};function aT(r,e){return r==null&&(r={}),r instanceof yu?[r]:Array.isArray(r)&&r[0]instanceof yu?r:At(r).map(n=>new sT(n,e))}var li=class{constructor(){}static registerCallbackConstructor(e,t){y.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),li.checkForDuplicate(t),li.constructors[e]==null&&(li.constructors[e]=[]),li.constructors[e].push(t)}static checkForDuplicate(e){for(let t in li.constructors)li.constructors[+t].forEach(o=>{if(o===e)throw new B("Duplicate callback constructor.")})}static clear(){li.constructors={}}static createCallbacks(e){let t=[];for(let n in li.constructors){let o=+n;e>=o&&t.push(...li.constructors[o])}return t.map(n=>new n)}},Wc=li;K(Wc,"constructors",{});function iT(r,e,t,n,o,s,a,i,u){let l=new oT,p=[new UA,...Wc.createCallbacks(e)];r!=null&&p.push(...r),p.push(l);let m=new nT(p);return m.setParams({epochs:t,initialEpoch:n,samples:o,steps:s,batchSize:a,verbose:e,doValidation:i,metrics:u}),{callbackList:m,history:l}}function Sn(r,e={},t=!1){return Bi(r,Q.SerializationMap.getMap().classNameMap,e,"layer",t)}function zh(r,e){return z(()=>{r.dtype!=="float32"&&(r=re(r,"float32"));let t=be(xp(r),e,!0),n=Vs(t.shape,fr()),o=Ft(ds(t,n));return fe(r,o)})}function Gi(r,e){return z(()=>Lt(xp(de(e,r)),-1))}function Uc(r,e){return z(()=>Lt(Ot(de(e,r)),-1))}function Rl(r,e){return z(()=>{let t=de(r,e),n=Hr(Ot(r),fr(),Number.MAX_VALUE),o=Ot(fe(t,n));return P(100,Lt(o,-1))})}function o9(r,e){return z(()=>{let t=Hr(e,fr(),Number.MAX_VALUE),n=jr(Z(1,t)),o=Hr(r,fr(),Number.MAX_VALUE),s=jr(Z(1,o));return Lt(xp(de(n,s)),-1)})}function s9(r,e){return z(()=>{let t=ds(0,de(1,P(r,e)));return Lt(xp(t),-1)})}function a9(r,e){return z(()=>{let t=ds(0,de(1,P(r,e)));return Lt(t,-1)})}function i9(r,e){return z(()=>{let t=be(P(r,e),-1),n=qr(P(de(1,r),e),-1);return ds(0,Z(1,de(n,t)))})}function u9(r,e){return z(()=>{let t=Math.log(2),n=de(e,r),o=de(Z(n,cu(P(-2,n))),t);return Lt(o,-1)})}function Dp(r,e,t=!1){return z(()=>{if(t)e=yc(e);else{let n=be(e,e.shape.length-1,!0);e=fe(e,n)}return e=Hr(e,fr(),1-fr()),tt(be(P(re(r,"float32"),jr(e)),e.shape.length-1))})}function Kc(r,e,t=!1){return z(()=>{let n=re(Tl(lR(r)),"int32");e=Hr(e,fr(),1-fr());let o=e.shape,s=F(pl(n,o[o.length-1]),o);return Dp(s,e,t)})}function l9(r,e){if(!y.arraysEqual(r.shape,e.shape))throw new B(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(e.shape)}`);return z(()=>{let t=an(e),n=tt(Ot(e));return Z(de(t,P(e,r)),mc(br(n)))})}function Vc(r,e){return z(()=>{let t;return t=Hr(e,fr(),1-fr()),t=jr(fe(t,de(1,t))),Lt(l9(r,t),-1)})}function p9(r,e){return z(()=>{let t=Hr(r,fr(),1),n=Hr(e,fr(),1);return be(P(r,jr(fe(t,n))),-1)})}function m9(r,e){return z(()=>{let t=jr(Z(fr(),e));return Lt(de(e,P(r,t)),-1)})}function Wh(r,e){return z(()=>{let t=zh(r,-1),n=zh(e,-1),o=P(t,n);return tt(be(o,-1))})}var Gh={meanSquaredError:Gi,meanAbsoluteError:Uc,meanAbsolutePercentageError:Rl,meanSquaredLogarithmicError:o9,squaredHinge:s9,hinge:a9,categoricalHinge:i9,logcosh:u9,categoricalCrossentropy:Dp,sparseCategoricalCrossentropy:Kc,binaryCrossentropy:Vc,kullbackLeiblerDivergence:p9,poisson:m9,cosineProximity:Wh};function uT(r){if(typeof r=="string"){if(r in Gh)return Gh[r];let e=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new B(e)}else return r}function Uh(r,e){return z(()=>{let t=P(.5,zr(e)),n=un(Qt(e,t),r.dtype);return Lt(nn(r,n),-1)})}function Kh(r,e){return z(()=>un(nn(dl(r,-1),dl(e,-1)),"float32"))}function SE(r,e){return z(()=>re(be(sn(nn(r,1),nn(e,1))),"float32"))}function c9(r,e){return z(()=>re(be(sn(nn(r,1),nn(e,0))),"float32"))}function d9(r,e){return z(()=>re(be(sn(nn(r,0),nn(e,1))),"float32"))}function KA(r,e){return z(()=>{let t=SE(r,e),n=d9(r,e),o=Z(t,n);return re(zt(Qt(o,0),fe(t,o),0),"float32")})}function kE(r,e){return z(()=>{let t=SE(r,e),n=c9(r,e),o=Z(t,n);return re(zt(Qt(o,0),fe(t,o),0),"float32")})}function pT(r,e){return Vc(r,e)}function mT(r,e){return r.rank===e.rank&&(r=js(r,[r.rank-1])),e=dl(e,-1),e.dtype!==r.dtype&&(e=re(e,r.dtype)),re(nn(r,e),"float32")}var f9=Gi,h9=Gi,g9=Uc,b9=Uc,y9=Rl,T9=Rl,Vh=Dp,x9=Wh,VA=Kc,lT={binaryAccuracy:Uh,categoricalAccuracy:Kh,precision:KA,categoricalCrossentropy:Vh,sparseCategoricalCrossentropy:VA,mse:f9,MSE:h9,mae:g9,MAE:b9,mape:y9,MAPE:T9,cosine:x9};function vE(r){if(typeof r=="string"&&r in lT)return lT[r];if(typeof r!="string"&&r!=null)return r;throw new B(`Unknown metric ${r}`)}function Hh(r){if(hs(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let e;for(let t of Object.keys(Gh))if(Gh[t]===r){e=t;break}if(e!==void 0)return e;for(let t of Object.keys(lT))if(lT[t]===r){e=t;break}return e!==void 0?e:r.name}}function wE(r){let e={Adagrad:()=>yp.adagrad(.01),Adadelta:()=>yp.adadelta(1,.95,fr()),Adam:()=>yp.adam(.001,.9,.999,fr()),Adamax:()=>yp.adamax(.002,.9,.999,fr(),0),RMSProp:()=>yp.rmsprop(.001,.9,0,fr()),SGD:()=>yp.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,r in e)return e[r]();throw new B(`Unknown Optimizer ${r}`)}function qA(r,e,t=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!HA(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function HA(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let e=Object.keys(r);for(let t of e)if(typeof t!="string"||!HA(r[t]))return!1;return!0}else if(Array.isArray(r)){for(let e of r)if(!HA(e))return!1;return!0}else return!1;else{let e=typeof r;return e==="string"||e==="number"||e==="boolean"}}function NE(r,e,t,n=console.log){let o=S9(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(p=>Math.floor(e*p)));let a;if(!o){s.push("Receives inputs"),a=[];for(let p in r.nodesByDepth)a.push(...r.nodesByDepth[p])}n("_".repeat(e)),cT(s,t,n),n("=".repeat(e));let i=r.layers;for(let p=0;p<i.length;++p)o?k9(i[p],t,n):v9(i[p],t,a,n),n((p===i.length-1?"=":"_").repeat(e));r.checkTrainableWeightsConsistency();let u=C9(r),l=Lc(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(e))}function C9(r){let e;return r.collectedTrainableWeights!=null?e=Lc(r.collectedTrainableWeights):e=Lc(r.trainableWeights),e}function S9(r){let e=!0,t=[],n=[];for(let o in r.nodesByDepth)t.push(r.nodesByDepth[o]);for(let o of t){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){e=!1;break}n.push(...o)}if(e)for(let o of r.layers){let s=!1;for(let a of o.inboundNodes)if(n.indexOf(a)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function cT(r,e,t=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,e[o]),n+=" ".repeat(e[o]-n.length);t(n)}function k9(r,e,t){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{o="multiple"}try{n=JSON.stringify(r.outputShape)}catch{n="multiple"}let s=r.name,a=r.getClassName(),i=[`${s} (${a})`,o,n,r.countParams().toString()];cT(i,e,t)}function v9(r,e,t,n){let o,s;try{s=r.inboundNodes.map(m=>JSON.stringify(m.inputShapes)).join(",")}catch{s="multiple"}try{o=JSON.stringify(r.outputShape)}catch{o="multiple"}let a=[];for(let m of r.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(m)===-1))for(let c=0;c<m.inboundLayers.length;++c){let d=m.inboundLayers[c].name,f=m.nodeIndices[c],h=m.tensorIndices[c];a.push(`${d}[${f}][${h}]`)}let i=r.name,u=r.getClassName(),l=a.length===0?"":a[0],p=[`${i} (${u})`,s,o,r.countParams().toString(),l];cT(p,e,n);for(let m=1;m<a.length;++m)cT(["","","","",a[m]],e,n)}function DE(r,e,t){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&e===0&&typeof t=="string"}function _p(r,e){if(r===null)return null;if(typeof r=="string")return fu(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];DE(e,o,s)?t.push(s):t.push(_p(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")t[n]=o;else{let s=fu(n);t[s]=_p(o,s)}}return t}}function dT(r,e){if(r==null)return null;if(typeof r=="string")return Qs(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];DE(e,o,s)?t.push(s):t.push(dT(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n],s=Qs(n);(n==="name"||n==="className")&&typeof o=="string"?t[s]=o:t[s]=dT(o,n)}return t}}var qh="0.0.0";var Zn=class extends Ee{inputs;outputs;inputLayers;inputLayersNodeIndices;inputLayersTensorIndices;outputLayers;outputLayersNodeIndices;outputLayersTensorIndices;layers;layersByDepth;nodesByDepth;internalContainerRefs;containerNodes=new Set;inputNames;outputNames;feedInputShapes;internalInputShapes;internalOutputShapes;feedInputNames;feedOutputNames;constructor(e){if(super({}),this.name=e.name,this.name==null){let T=this.getClassName().toLowerCase();this.name=Dl(T)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Js(this.inputs).length!==this.inputs.length)throw new B(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(T=>T.name)}`);Js(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(T=>T.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let T of this.outputs){let x=T.sourceLayer,I=T.nodeIndex,S=T.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(I),this.outputLayersTensorIndices.push(S)}for(let T of this.inputs){let x=T.sourceLayer,I=T.nodeIndex,S=T.tensorIndex;hs(I===0,"input layer has >1 nodes"),hs(S===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(I),this.inputLayersTensorIndices.push(S)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let T=0;T<this.inputLayers.length;T++){let x=this.inputLayers[T];if(!(x instanceof ui))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${T} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(let T of this.outputLayers)this.outputNames.push(T.name);this.internalInputShapes=this.inputs.map(T=>T.shape),this.internalOutputShapes=this.outputs.map(T=>T.shape);let t={},n={},o={},s={},a={},i=[],u=(T,x,I,S,w,_)=>{(S==null||w==null||_==null)&&(S=T.sourceLayer,w=T.nodeIndex,_=T.tensorIndex);let M=S.inboundNodes[w];if(I.indexOf(M)!==-1)throw new Zr(`The tensor ${T.name} at layer "${S.name}" is part of a cycle.`);if(x.indexOf(M)!==-1)return;this.containerNodes.add(Zn.nodeKey(S,w)),S.id in a||(a[S.id]=Object.keys(a).length),I.indexOf(M)===-1&&I.push(M);let R=M.inboundLayers.length;for(let E=0;E<R;E++){let O=M.inputTensors[E],G=M.inboundLayers[E],W=M.nodeIndices[E],H=M.tensorIndices[E];u(O,x,I,G,W,H)}for(x.push(M);I.indexOf(M)>=0;)I.splice(I.indexOf(M),1);i.push(M)},l=[],p=[];for(let T of this.outputs)u(T,l,p);let m=i.slice().reverse();for(let T of m){n[T.id]=T,T.id in t||(t[T.id]=0);let x=t[T.id],I=o[T.outboundLayer.id]==null?0:o[T.outboundLayer.id];x=Math.max(x,I),o[T.outboundLayer.id]=x,s[T.outboundLayer.id]=T.outboundLayer,t[T.id]=x;for(let S=0;S<T.inboundLayers.length;S++){let w=T.inboundLayers[S],_=T.nodeIndices[S],M=w.inboundNodes[_],R=t[M.id]==null?0:t[M.id];t[M.id]=Math.max(x+1,R),n[M.id]=M}}let c={};for(let T in t){let x=t[T];x in c||(c[x]=[]),c[x].push(n[T])}let d={};for(let T in o){let x=o[T];x in d||(d[x]=[]),d[x].push(s[T])}let f=Object.keys(d).map(T=>parseInt(T,10)).sort(Fh);this.layers=[];for(let T of f){let x=d[T];x.sort((I,S)=>{let w=a[I.id],_=a[S.id];return w<_?-1:w>_?1:0});for(let I of x)I instanceof Zn&&this.internalContainerRefs.push(I),this.layers.push(I)}this.layersByDepth=d,f=Object.keys(c).map(T=>parseInt(T,10)).sort(Fh);let h=this.inputs.slice(),g=[];for(let T of f)for(let x of c[T]){let I=x.outboundLayer;if(I!=null){for(let S of x.inputTensors)if(h.indexOf(S)===-1)throw new Zr(`Graph disconnected: cannot obtain value for tensor ${S} at layer "${I.name}". The following previous layers were accessed without issue: ${g}`);for(let S of x.outputTensors)h.push(S);g.push(I.name)}}this.nodesByDepth=c;let b=this.layers.map(T=>T.name);for(let T of b){let x=b.filter(I=>I===T).length;if(x!==1)throw new Zr(`The name "${T}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(b))}this.outboundNodes=[],this.inboundNodes=[],new bu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(T=>null),outputMasks:this.outputs.map(T=>null),inputShapes:this.inputs.map(T=>T.shape),outputShapes:this.outputs.map(T=>T.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new B("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},o=0;for(let a of this.layers)for(let i of a.weights){if(n[i.originalName]!=null)throw new B(`Duplicate weight name: ${i.originalName}`);n[i.originalName]=i,o++}let s=[];for(let a in e){let i=a;if(n[a]==null){let u=a.split("/");i=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[i]!=null)s.push([n[i],e[a]]);else if(t)throw new B(`Provided weight data has no target variable: ${a}`);delete n[i]}if(t){let a=[];for(let i in n)a.push(i);if(a.length>0)throw new B(`${a.length} of ${o} weights are not set: ${a}`)}$c(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${qh}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=dT(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return z(()=>{e=At(e);let n=new ra;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],e[o]);return wp(this.outputs,n,t)})}computeMask(e,t){return z(()=>{e=At(e);let n;return t==null?n=Zs(null,e.length):n=At(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=Fc(e);if(t.length!==this.inputLayers.length)throw new B(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let i=0;i<t.length;i++){let u=this.inputLayers[i],l=t[i],p=u.name+"_0_0";n[p]=l}let o=Object.keys(this.nodesByDepth).map(i=>parseInt(i,10)).sort(Fh);if(o.length>1)for(let i of o){let u=this.nodesByDepth[i];for(let l of u){let p=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(p.id)!==-1)continue;let m=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],b=l.nodeIndices[h],T=l.tensorIndices[h],x=`${g.name}_${b}_${T}`,I=n[x];m.push(I)}let c=p.computeOutputShape(Pr(m)),d=Fc(c),f=p.inboundNodes.indexOf(l);for(let h=0;h<d.length;h++){let g=`${p.name}_${f}_${h}`;n[g]=d[h]}}}let s=[],a=[];for(let i=0;i<this.outputLayers.length;i++){let u=this.outputLayers[i],l=this.outputLayersNodeIndices[i],p=this.outputLayersTensorIndices[i],m=`${u.name}_${l}_${p}`;a.push(m)}for(let i=0;i<a.length;i++){let u=a[i];hs(u in n),s.push(n[u])}return Pr(s)}runInternalGraph(e,t){t==null&&(t=Zs(null,e.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],p=e[u],m=t[u];n[l.id]=[p,m]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Fh);for(let u of o){let l=this.nodesByDepth[u];for(let p of l){let m=p.outboundLayer,c=p.inputTensors,d=p.outputTensors,f=new Array;for(let h of c)h.id in n&&f.push(n[h.id]);if(f.length===c.length){let h={},g,b,T,x;if(p.callArgs!=null&&(h=p.callArgs),f.length===1){let[I,S]=f[0];h.mask==null&&(h.mask=S),T=At(m.call(I,h)),x=At(m.computeMask(I,S)),g=[I],b=[S]}else g=f.map(I=>I[0]),b=f.map(I=>I[1]),h.mask==null&&(h.mask=b),T=At(m.call(g,h)),x=At(m.computeMask(g,b));if(m.activityRegularizer)throw new Ne("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let I=0;I<d.length;++I){let S=d[I],w=T[I],_=x[I];n[S.id]=[w,_]}}}}let s=[],a=[],i=[];for(let u of this.outputs){hs(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,p]=n[u.id];i.push(l.shape),s.push(l),a.push(p)}return[s,a,i]}buildNodeConversionMap(e){let t={},n;for(let o of this.layers){n=o instanceof Zn?1:0;for(let s=0;s<o.inboundNodes.length;s++){let a=Zn.nodeKey(o,s);this.containerNodes.has(a)&&(t[a]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new B(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new B("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new B(`No such layer: ${e}`)}calculateLosses(){return z(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let o=Zn.nodeKey(t,n);this.containerNodes.has(o)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let i=a.getClassName(),u=a.getConfig(),l=[];for(let m=0;m<a.inboundNodes.length;m++){let c=a.inboundNodes[m],d=Zn.nodeKey(a,m),f={};if(this.containerNodes.has(d)){if(c.callArgs)try{JSON.stringify(c.callArgs),f=c.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${c.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(c.inboundLayers.length>0){let h=[];for(let g=0;g<c.inboundLayers.length;g++){let b=c.inboundLayers[g],T=c.nodeIndices[g],x=c.tensorIndices[g],I=Zn.nodeKey(b,T),S=t[I];S==null&&(S=0),h.push([b.name,S,x,f])}l.push(h)}}}let p={};p.name=a.name,p.className=i,p.config=u,p.inboundNodes=l,n.push(p)}e.layers=n;let o=[];for(let a=0;a<this.inputLayers.length;a++){let i=this.inputLayers[a],u=this.inputLayersNodeIndices[a],l=Zn.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let m=this.inputLayersTensorIndices[a];o.push([i.name,p,m])}e.inputLayers=o;let s=[];for(let a=0;a<this.outputLayers.length;a++){let i=this.outputLayers[a],u=this.outputLayersNodeIndices[a],l=Zn.nodeKey(i,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let m=this.outputLayersTensorIndices[a];s.push([i.name,p,m])}return e.outputLayers=s,e}static fromConfig(e,t,n={},o=!1){let s={},a={};function i(g,b){g.name in a?a[g.name].push(b):a[g.name]=[b]}function u(g,b){let T=[],x;for(let I of b){let S=I[0],w=I[1],_=I[2];if(x=I[3]==null?{}:I[3],!(S in s)){i(g,b);return}let M=s[S];if(M.inboundNodes.length<=w){i(g,b);return}let R=M.inboundNodes[w];T.push(R.outputTensors[_])}T.length>0&&g.apply(Pr(T),x)}function l(g){let b=g.name,T=Sn(g,t.customObjects!=null?t.customObjects:{});T.setFastWeightInitDuringBuild(o),s[b]=T,g.inboundNodes.forEach(I=>{if(!(I instanceof Array))throw new B(`Corrupted configuration, expected array for nodeData: ${I}`);i(T,I)})}let p=t.name,m=t.layers;for(let g of m)l(g);for(;!YM(a);)for(let g of m){let b=s[g.name];if(b.name in a){let T=a[b.name];delete a[b.name];for(let x of T)u(b,x)}}let c=[],d=[],f=t.inputLayers;for(let g of f){let b=g[0],T=g[1],x=g[2];hs(b in s);let S=s[b].inboundNodes[T].outputTensors;c.push(S[x])}let h=t.outputLayers;for(let g of h){let b=g[0],T=g[1],x=g[2];hs(b in s);let S=s[b].inboundNodes[T].outputTensors;d.push(S[x])}return new e({inputs:c,outputs:d,name:p})}get stateful(){if(this._stateful)throw new B("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){z(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function A9(r,e,t){let n=e.length;if(r==null||Array.isArray(r)&&r.length===0)return e.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&e[0]in r?[r[e[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${t} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return e.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${t} must be either an array with ${n} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(r)}`)}function fT(r,e){return A9(r,e,"classWeight")}async function hT(r,e,t,n){if(e!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){let o=z(()=>{if(r.shape.length===1)return gn(r);if(r.shape.length===2){if(r.shape[1]>1)return dl(r,1);if(r.shape[1]===1)return F(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());_e(o);let a=[];return s.forEach(i=>{if(t[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(t[i])}),Jt(a,"float32")}else return null}function _E(r,e){return P(r,e)}var w9=32;function PE(r,e){let t,n,o=e;t=o.xs,n=o.ys,y.assert(t!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);let s=ME("input",r.inputNames,t),a=ME("output",r.outputNames,n),i=s[0].shape[0];y.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),y.assert(a.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)y.assert(s[u].shape[0]===i,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);for(let u=0;u<a.length;u++)y.assert(a[u].shape[0]===i,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${a[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);return{xs:s,ys:a}}function ME(r,e,t){if(t instanceof We)return[t];if(Array.isArray(t))return y.assert(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${r} keys ${e}.`),t;{let n=[];for(let o of e){if(t[o]==null)throw new B(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(t[o])}return n}}function N9(r){if(r.length===3)throw new Ne("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function EE(r,e,t){let n=t.batchesPerEpoch!=null;if(y.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),y.assert(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),y.assert(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),y.assert(!n||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),y.assert(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=t.validationData!=null,s,a;if(o)if(RE(t.validationData))y.assert(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{let g=N9(t.validationData);s=g.xs,a=g.ys}let i=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let p=aT(t.callbacks,t.yieldEvery),m=t.verbose==null?1:t.verbose,{callbackList:c,history:d}=iT(p,m,t.epochs,null,null,D9(e,t),null,o,l);c.setModel(r),r.history=d,await c.onTrainBegin(),r.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,h=await e.iterator();for(;f<t.epochs;){let g={};await c.onEpochBegin(f);let b=0,T=0;for(n||(h=await e.iterator());!n||b<t.batchesPerEpoch;){let x=await h.next();if(n&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:I,ys:S}=PE(r,x.value),w={};w.batch=T,w.size=I[0].shape[0],await c.onBatchBegin(T,w);let _=[];if(t.classWeight!=null){let E=fT(t.classWeight,r.outputNames);for(let O=0;O<E.length;++O)_.push(await hT(S[O],null,E[O]))}let M=I.concat(S).concat(_),R=i(M);_e(M);for(let E=0;E<u.length;++E){let O=u[E],G=R[E];w[O]=G,Et(G)}await c.onBatchEnd(T,w),rT(w),T++,b++}if(n?b>=t.batchesPerEpoch:x.done){if(o){let I;RE(t.validationData)?I=At(await r.evaluateDataset(t.validationData,{batches:t.validationBatches})):I=At(r.evaluate(s,a,{batchSize:t.validationBatchSize==null?w9:t.validationBatchSize,verbose:0}));for(let S=0;S<r.metricsNames.length;++S)g[`val_${r.metricsNames[S]}`]=I[S]}break}if(r.stopTraining_)break}if(await c.onEpochEnd(f,g),f++,r.stopTraining_)break}return await c.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function D9(r,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(r.size)&&(t=r.size),t}function RE(r){return typeof r.iterator=="function"}function _9(r){return typeof r.next=="function"}async function FE(r,e,t){t=t||{};let n=t.batches!=null,o=r.testFunction,s=[];if(t.verbose>0)throw new Ne("Verbose mode is not implemented yet.");y.assert(!n||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);let a=_9(e)?e:await e.iterator(),i=0,u=0;for(;!n||u<t.batches;){let l=await a.next();if(s=z(()=>{if(l.value){let{xs:p,ys:m}=PE(r,l.value),c=p.concat(m),d=z(()=>o(c));if(_e(c),u===0)for(let h=0;h<d.length;++h)s.push(ge(0));let f=c[0].shape[0];for(let h=0;h<d.length;++h){let g=d[h],b=s[h];s[h]=z(()=>Z(s[h],P(f,g))),u>0&&_e(b)}_e(d),i+=f,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let p=s[l];s[l]=fe(s[l],i),_e(p)}return Pr(s)}function gT(r){y.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function Hc(r,e,t){return r==null?[null]:Array.isArray(r)?r.map(n=>hu(n,e,t-e)):hu(r,e,t-e)}function bT(r,e){return z(()=>r==null?null:Array.isArray(r)?r.map(t=>bT(t,e)):jy(r,e.dtype==="int32"?e:re(e,"int32")))}function yT(r,e){let t=[],n=0,o=null;for(;n<r;)o=n+e,o>=r&&(o=r),t.push([n,o]),n=o;return t}function jA(r){let e=[];r instanceof We&&(r=[r]);for(let t=0;t<r.length;++t){let n=r[t];if(n.rank===1)e.push(gu(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(n)}}return e}function na(r,e){if(r==null)return;let t=[];if(e instanceof We)t.push(e.id);else if(Array.isArray(e))e.forEach(o=>t.push(o.id));else if(e!=null)for(let o in e){let s=e[o];t.push(s.id)}let n=[];if(r instanceof We)t.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{t.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];t.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function M9(r){return r instanceof We}function XA(r){return Array.isArray(r)}function LE(r){return!M9(r)&&!XA(r)}function $E(r,e,t,n=!0,o=""){if(e==null||e.length===0){if(r!=null){let a=!1;if(XA(r)&&r.length>0)a=!0;else if(LE(r)){for(let i in r)if(r.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new B(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return e.map(a=>null);let s;if(LE(r)){r=r,s=[];for(let a of e){if(r[a]==null)throw new B(`No data provided for "${a}". Need data for each key in: ${e}`);s.push(r[a])}}else if(XA(r)){if(r=r,r.length!==e.length)throw new B(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,e.length>1)throw new B(`The model ${o} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=jA(s),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new B(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<t[a].length;++u){if(u===0&&!n)continue;let l=i.shape[u],p=t[a][u];if(p!=null&&p>=0&&l!==p)throw new B(`${o} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${o} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function R9(r,e,t){let n=Js(r.map(s=>s.shape[0]));n.sort();let o=Js(e.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new B(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new B(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!y.arraysEqual(n,o))throw new B(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function P9(r,e,t){let n=[Gi,Vc,Dp];for(let o=0;o<r.length;++o){let s=r[o],a=e[o],i=t[o];if(a!=null){if(a===Dp&&s.shape[s.shape.length-1]===1)throw new B(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(a)!==-1){let u=s.shape.slice(1),l=i.slice(1);for(let p=0;p<u.length;++p){let m=u[p],c=l[p];if(c!=null&&m!==c)throw new B(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function BE(r,e,t,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==e.length)throw new B(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(e.length>1)throw new B(`The model expects ${e.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;let i=s[a];if(i.shape.length!==t[a].length)throw new B(`Error when checking ${o}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<t[a].length;++u){if(u===0&&!n)continue;let l=i.shape[u],p=t[a][u];if(p!=null&&p!==l)throw new B(`Error when checking ${o}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function E9(r,e){if(r==null||Array.isArray(r)&&r.length===0)return e.map(n=>[]);let t;if(typeof r=="string"||typeof r=="function")t=[r];else if(Array.isArray(r)||typeof r=="object")t=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(t))return e.map(n=>t);{let n=[];for(let o of e){let s=t.hasOwnProperty(o)?t[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var F9="layers-model",Qn=class extends Zn{optimizer_;isOptimizerOwned;loss;lossFunctions;feedOutputShapes;feedLossFns;collectedTrainableWeights;testFunction;history;stopTraining_;isTraining;metrics;metricsNames;metricsTensors;userDefinedMetadata;constructor(e){super(e),this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new B("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");NE(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=wE(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Yr))throw new B("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new B(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(uT(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new B(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(i=>uT(i))}else{let a=uT(e.loss);this.outputs.forEach(i=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let i=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(i),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],ai("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([i,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let o=E9(e.metrics,this.outputNames),s=(a,i,u)=>{this.outputNames.length>1&&(i=this.outputNames[a]+"_"+i),this.metricsNames.push(i),this.metricsTensors.push([u,a])};ai("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let i=o[a];(l=>{let p="",m,c,d;for(let f of l){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){let g=this.internalOutputShapes[a];g[g.length-1]===1||this.lossFunctions[a]===Vc?["accuracy","acc"].indexOf(f)!==-1?c=Uh:["crossentropy","ce"].indexOf(f)!==-1&&(c=pT):this.lossFunctions[a]===Kc?["accuracy","acc"].indexOf(f)!==-1?c=mT:["crossentropy","ce"].indexOf(f)!==-1&&(c=VA):["accuracy","acc"].indexOf(f)!==-1?c=Kh:["crossentropy","ce"].indexOf(f)!==-1&&(c=Vh);let b;["accuracy","acc"].indexOf(f)!==-1?b="acc":["crossentropy","ce"].indexOf(f)!==-1&&(b="ce"),d=c,m=p+b}else d=vE(f),m=p+Hh(f);let h;ai(m,()=>{h=d}),s(a,m,h)}})(i)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let o=n.batchSize==null?32:n.batchSize;gT(o);let s=!0,a=this.standardizeUserDataXY(e,t,s,o);try{let i=a[0].concat(a[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,i,o,n.verbose,n.steps);return Pr(l)}finally{na(a[0],e),na(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),FE(this,e,t)}checkNumSamples(e,t,n,o="steps"){let s;if(n!=null){if(s=null,t!=null)throw new B(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new B(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new B("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),o=n?t:[t],s=this.retrieveSymbolicTensors(o),a=new ra;if(e instanceof We&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new B(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],e[u])}else for(let u of this.inputs){let l=e[u.name];if(l==null)throw new B(`No value is provided for the model's input ${u.name}`);a.add(u,l)}let i=wp(s,a);return n?i:i[0]}retrieveSymbolicTensors(e){let t=Zs(null,e.length),n=e.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],a=s.map(i=>i.name);for(let i=0;i<e.length;++i){let u=a.indexOf(e[i]);if(u!==-1&&(t[i]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw t.forEach((s,a)=>{s==null&&o.push(e[a])}),new B(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return t}predictLoop(e,t=32,n=!1){return z(()=>{let o=this.checkNumSamples(e);if(n)throw new Ne("Verbose predictLoop() is not implemented yet.");let s=yT(o,t),a=this.outputs.map(i=>[]);for(let i=0;i<s.length;++i)z(()=>{let l=s[i][0],p=s[i][1],m=Hc(e,l,p),c=[];if(Array.isArray(m))for(let f=0;f<m.length;++f)c.push({key:this.inputs[f],value:m[f]});else c.push({key:this.inputs[0],value:m});let d=new ra(c);return wp(this.outputs,d)}).forEach((l,p)=>a[p].push(l));return Pr(a.map(i=>ct(i,0)))})}predict(e,t={}){let n=jA(e);BE(n,this.inputNames,this.feedInputShapes,!1);try{let o=t.batchSize==null?32:t.batchSize;return gT(o),this.predictLoop(n,o)}finally{na(n,e)}}predictOnBatch(e){BE(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,o){if(this.optimizer_==null)throw new Zr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let a=0;a<this.feedOutputShapes.length;++a){let i=this.feedOutputShapes[a];this.feedLossFns[a]===Kc?s.push(i.slice(0,i.length-1).concat([1])):s.push(i)}if(e=$E(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=$E(t,this.feedOutputNames,s,!1,"target"),R9(e,t,null),P9(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&e[0].shape[0]%o!==0)throw new B(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,o,s=!0,a){let[i,u]=this.standardizeUserDataXY(e,t,s,a);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let p=fT(o,this.outputNames);l=[];for(let m=0;m<p.length;++m)l.push(await hT(u[m],null,p[m]))}return[i,u,l]}testLoop(e,t,n,o=0,s){return z(()=>{let a=this.checkNumSamples(t,n,s,"steps"),i=[];if(o>0)throw new Ne("Verbose mode is not implemented yet.");if(s!=null)throw new Ne("steps mode in testLoop() is not implemented yet");{let u=yT(a,n),l=Jt(Tn(0,a));for(let p=0;p<u.length;++p){let m=u[p][0],c=u[p][1],d=hu(l,m,c-m),f=bT(t,d),h=e(f);if(p===0)for(let g=0;g<h.length;++g)i.push(ge(0));for(let g=0;g<h.length;++g){let b=h[g];i[g]=Z(i[g],P(c-m,b))}}for(let p=0;p<i.length;++p)i[p]=fe(i[p],a)}return i})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let o=e[n],s=o;if(MA(e,o)>1){let a=MA(e.slice(0,n),o);s+=`_${a}`}t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],i=()=>{let m=[];for(let h=0;h<this.inputs.length;++h)m.push({key:this.inputs[h],value:n[h]});let c=new ra(m),d=wp(this.outputs,c,{training:!0}),f;for(let h=0;h<this.lossFunctions.length;++h){let g=this.lossFunctions[h],b=g(o[h],d[h]);s[h]!=null&&(b=_E(b,s[h]));let T=Lt(b);t.push(T),h===0?f=b:f=Z(f,b)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=t[h];else{let b=this.metricsTensors[h][0],T=this.metricsTensors[h][1];g=Lt(b(o[T],d[T]))}Et(g),a.push(g)}return f=Lt(f),this.calculateLosses().forEach(h=>{f=Z(f,h)}),f},u=this.collectedTrainableWeights.map(m=>m.read()),l=!0;return[this.optimizer_.minimize(i,l,u)].concat(a)}}makeTestFunction(){this.testFunction=e=>z(()=>{let t=[],n,o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:o[l]});let i=new ra(a),u=wp(this.outputs,i);for(let l=0;l<this.lossFunctions.length;++l){let p=this.lossFunctions[l],m=Lt(p(s[l],u[l]));l===0?n=m:n=Z(n,m),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let p=this.metricsTensors[l][0],m=this.metricsTensors[l][1],c=Lt(p(s[m],u[m]));t.push(c)}return t})}async fit(e,t,n={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let o,s,a,i,u,l,p,m,c;try{let d=n.batchSize==null?32:n.batchSize;gT(d);let f=!1,h=await this.standardizeUserData(e,t,n.sampleWeight,n.classWeight,f,d);o=h[0],s=h[1],c=h[2];let g=!1,b;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)u=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new Ne("validationData including sample weights is not supported yet."):new B(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let R=!0,E=await this.standardizeUserData(u,l,null,null,R,d);p=E[0],m=E[1],b=p.concat(m)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let R=Math.floor(o[0].shape[0]*(1-n.validationSplit)),E=o[0].shape[0];p=Hc(o,R,E),a=o,o=Hc(o,0,R),m=Hc(s,R,E),i=s,s=Hc(s,0,R),b=p.concat(m)}else n.validationSteps!=null&&(g=!0);let T=o.concat(s).concat(c);this.checkTrainableWeightsConsistency();let x=this.makeTrainFunction(),I=this.getDedupedMetricsNames(),S,w;g?(this.makeTestFunction(),S=this.testFunction,w=I.slice().concat(I.map(R=>"val_"+R))):(S=null,b=[],w=I.slice());let _=aT(n.callbacks,n.yieldEvery);return await this.fitLoop(x,T,I,d,n.epochs,n.verbose,_,S,b,n.shuffle,w,n.initialEpoch,null,null)}finally{this.isTraining=!1,na(o,e),na(s,t),na(a,e),na(i,t),na(p,u),na(m,l),c!=null&&_e(c)}}async fitLoop(e,t,n,o,s,a,i,u,l,p,m,c,d,f){o==null&&(o=32),s==null&&(s=1),p==null&&(p=!0),c==null&&(c=0);let h=!1;if(u!=null&&l!=null&&(h=!0),f!=null&&(h=!0,d==null))throw new B("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=this.checkNumSamples(t,o,d,"steps_per_epoch"),b;g!=null&&(b=Tn(0,g)),a==null&&(a=1);let{callbackList:T,history:x}=iT(i,a,s,c,g,d,o,h,m);T.setModel(this),this.history=x,await T.onTrainBegin(),this.stopTraining_=!1;for(let I=c;I<s;++I){await T.onEpochBegin(I);let S={};if(d!=null)throw new Ne("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new Ne("batch shuffling is not implemneted yet");p&&y.shuffle(b);let w=Jt(b),_=yT(g,o);for(let M=0;M<_.length;++M){let R={};if(await T.onBatchBegin(M,R),z(()=>{let E=_[M][0],O=_[M][1],G=hu(w,E,O-E);R.batch=M,R.size=O-E;let W=bT(t,G),H=e(W);for(let U=0;U<n.length;++U){let V=n[U],Y=H[U];R[V]=Y,Et(Y)}if(M===_.length-1&&h){let U=this.testLoop(u,l,o);for(let V=0;V<n.length;++V){let Y=n[V],j=U[V];Et(j),S["val_"+Y]=j}}}),await T.onBatchEnd(M,R),rT(R),this.stopTraining_)break}w.dispose()}if(await T.onEpochEnd(I,S),this.stopTraining_)break}return await T.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return EE(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),o=n[0],s=n[1],i=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of i){let p=await l.data();u.push(p[0])}return _e(i),na(n[0],e),na(n[1],t),Pr(u)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let a=0;a<o.length;++a)n&&!o[a].trainable||t.push({name:o[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=Ih().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Ih().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Qs(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Qs(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let o of t)if(typeof n[o]=="string")e[o]=Qs(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Qs(Hh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Qs(Hh(e)));{let e={};for(let t in this.metrics)e[t]=Qs(Hh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=_p(e.optimizer_config),n=Sn(t),o;if(typeof e.loss=="string")o=fu(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(a=>fu(a));else if(e.loss!=null){o={};for(let a in e.loss)o[a]=fu(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>fu(a));else if(e.metrics!=null){s={};for(let a in e.metrics)s[a]=fu(e.metrics[a])}this.compile({loss:o,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let l=Br.getSaveHandlers(e);if(l.length===0)throw new B(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new B(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new B("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Br.encodeWeights(this.getNamedWeights(t)),o=!1,s=null,i={modelTopology:this.toJSON(s,o),format:F9,generatedBy:`TensorFlow.js tfjs-layers v${qh}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){i.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:p,specs:m}=await Br.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...m),n.data=Br.concatenateArrayBuffers([n.data,p])}return this.userDefinedMetadata!=null&&(qA(this.userDefinedMetadata,this.name,!0),i.userDefinedMetadata=this.userDefinedMetadata),i.weightData=n.data,i.weightSpecs=n.specs,e.save(i)}setUserDefinedMetadata(e){qA(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};K(Qn,"className","Model");Q.registerClass(Qn);var TT=class extends Qn{};K(TT,"className","Functional");Q.registerClass(TT);async function OE(r,e){"modelTopology"in r||(r={modelTopology:r}),r=r;let t=r.modelTopology;t.model_config!=null&&(t=t.model_config);let n=_p(t),o=Sn(n,e);if(r.weightsManifest!=null){let s=await Br.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(i=>i.originalName)),a={};for(let i of o.weights)a[i.originalName]=s[i.originalName];o.loadWeights(a),_e(s)}return o}async function zE(r,e){if(e==null&&(e={}),typeof r=="string"){let t=Br.getLoadHandlers(r,e);if(t.length===0)t.push(Br.browserHTTPRequest(r,e));else if(t.length>1)throw new B(`Found more than one (${t.length}) load handlers for URL '${r}'`);r=t[0]}return L9(r,void 0,e)}async function L9(r,e,t){if(t==null&&(t={}),r.load==null)throw new B("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=t.strict==null?!0:t.strict,a=n.weightData!=null&&n.weightSpecs!=null&&s,i=Sn(_p(o),e,a),u=n.trainingConfig;if(u!=null&&i.loadTrainingConfig(u),n.userDefinedMetadata!=null&&i.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new B("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:p}=$9(n.weightData,n.weightSpecs);i.loadWeights(l,s),i.optimizer!=null&&p.length>0&&await i.optimizer.setWeights(p),_e(l),_e(p.map(m=>m.tensor))}return i}function $9(r,e){let t=Br.decodeWeights(r,e),n={},o=[];return e.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:t[s.name]}):n[s.name]=t[s.name]}),{modelWeights:n,optimizerWeights:o}}var xT=class extends Qn{model;constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Dl("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new B(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof xT||e instanceof Qn,n;if(t){if(n=e,n.outputs.length!==1)throw new B("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new B("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new B("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=Zy({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new B(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new B("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=$A(this.outputs[0])}this.inboundNodes=[],new bu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Zs(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Ke(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Qn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Zr("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},o=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new B("Legacy serialization format not supported yet.");s=t}else y.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;let i=new e(a);if(!(i instanceof xT))throw new Ne(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(let u of s){let p=Sn(u,void 0,o);o&&p.setFastWeightInitDuringBuild(!0),i.add(p)}return i}set stopTraining(e){if(this.model==null)throw new B("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new B("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}},Mp=xT;K(Mp,"className","Sequential");Q.registerClass(Mp);function B9(r){return new Qn(r)}function O9(r){return new Mp(r)}function YA(r){return Zy(r)}function z9(r,e){Wc.registerCallbackConstructor(r,e)}var pn=class extends Q.Serializable{getConfig(){return{}}},IT=class extends pn{apply(e,t=1){return mR(e,t)}};K(IT,"className","elu");Q.registerClass(IT);var CT=class extends pn{apply(e){return Cy(e)}};K(CT,"className","selu");Q.registerClass(CT);var ST=class extends pn{apply(e){return an(e)}};K(ST,"className","relu");Q.registerClass(ST);var kT=class extends pn{apply(e){return z(()=>Il(6,an(e)))}};K(kT,"className","relu6");Q.registerClass(kT);var vT=class extends pn{apply(e){return e}};K(vT,"className","linear");Q.registerClass(vT);var AT=class extends pn{apply(e){return Pn(e)}};K(AT,"className","sigmoid");Q.registerClass(AT);var wT=class extends pn{apply(e){return dR(e)}};K(wT,"className","hardSigmoid");Q.registerClass(wT);var NT=class extends pn{apply(e){return cu(e)}};K(NT,"className","softplus");Q.registerClass(NT);var DT=class extends pn{apply(e){return cR(e)}};K(DT,"className","softsign");Q.registerClass(DT);var _T=class extends pn{apply(e){return fl(e)}};K(_T,"className","tanh");Q.registerClass(_T);var qc=class extends pn{apply(e,t=-1){return yc(e,t)}};K(qc,"className","softmax");Q.registerClass(qc);var MT=class extends pn{apply(e,t=-1){return py(e,t)}};K(MT,"className","logSoftmax");Q.registerClass(MT);var RT=class extends pn{apply(e,t=1){return z(()=>P(Pn(P(e,t)),e))}};K(RT,"className","swish");Q.registerClass(RT);var PT=class extends pn{apply(e){return z(()=>P(e,fl(cu(e))))}};K(PT,"className","mish");Q.registerClass(PT);function pi(r){return r.getClassName()}function ZA(r,e={}){return Bi(r,Q.SerializationMap.getMap().classNameMap,e,"activation")}function mi(r){if(r==null){let e={};return e.className="linear",e.config={},ZA(e)}if(typeof r=="string"){let e={};return e.className=r,e.config={},ZA(e)}else return r instanceof pn?r:ZA(r)}function QA(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var ET=class extends Q.Serializable{},Pl=class extends ET{l1;l2;hasL1;hasL2;constructor(e){super(),QA(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return z(()=>{let t=Ct([1]);return this.hasL1&&(t=Z(t,be(P(this.l1,Ot(e))))),this.hasL2&&(t=Z(t,be(P(this.l2,xp(e))))),F(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};K(Pl,"className","L1L2");Q.registerClass(Pl);function UE(r){return QA(r),new Pl({l1:r!=null?r.l1:null,l2:0})}function KE(r){return QA(r),new Pl({l2:r!=null?r.l2:null,l1:0})}var GE={l1l2:"L1L2"};function yt(r){return kc(r)}function WE(r,e={}){return Bi(r,Q.SerializationMap.getMap().classNameMap,e,"regularizer")}function Nt(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in GE?GE[r]:r,config:{}};return WE(t)}else return r instanceof ET?r:WE(r)}var jc=class extends Ee{maxValue;constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=De(e);let n=an(e);return this.maxValue!=null&&(n=Hr(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};K(jc,"className","ReLU");Q.registerClass(jc);var Xc=class extends Ee{alpha;DEFAULT_ALPHA=.3;constructor(e){super(e??{}),e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=De(e);return pc(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};K(Xc,"className","LeakyReLU");Q.registerClass(Xc);var Yc=class extends Ee{alphaInitializer;alphaRegularizer;alphaConstraint;sharedAxes;alpha;DEFAULT_ALPHA_INITIALIZER="zeros";constructor(e){if(super(e??{}),e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=St(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Nt(e.alphaRegularizer),this.alphaConstraint=Ht(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new B(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Ke(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)t[o-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<e.length;++o)n[o]=e[o];this.inputSpec=[new wt({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=De(e),hc(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Mt(this.alphaInitializer),alphaRegularizer:yt(this.alphaRegularizer),alphaConstraint:Vt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};K(Yc,"className","PReLU");Q.registerClass(Yc);var Zc=class extends Ee{alpha;DEFAULT_ALPHA=1;constructor(e){if(super(e??{}),e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ne(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=De(e);return yl(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};K(Zc,"className","ELU");Q.registerClass(Zc);var Qc=class extends Ee{theta;DEFAULT_THETA=1;constructor(e){super(e??{}),e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=De(e);return P(n,re(Qt(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};K(Qc,"className","ThresholdedReLU");Q.registerClass(Qc);var Jc=class extends Ee{axis;softmax;DEFAULT_AXIS=1;constructor(e){super(e??{}),e==null&&(e={}),this.softmax=new qc().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=De(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};K(Jc,"className","Softmax");Q.registerClass(Jc);function El(r,e,t){if(typeof r=="number")return Zs(r,e);if(r.length!==e)throw new B(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${r.length} elements.`);for(let n=0;n<e;++n){let o=r[n];if(!iR(o))throw new B(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function Fn(r,e,t,n,o=1){if(r==null)return r;let s=e+(e-1)*(o-1),a;return t==="same"?a=r:a=r-s+1,Math.floor((a+n-1)/n)}function ci(r,e,t,n){if(r==null)return null;if(n==="valid")r=r*e+ii([t-e,0]);else if(n==="same")r=r*e;else throw new B(`Unsupport padding mode: ${n}.`);return r}function jh(r,e){return z(()=>(Gt(e),e==="channelsFirst"?Ge(r,[0,2,3,1]):r))}function JA(r,e){return z(()=>(Gt(e),e==="channelsFirst"?Ge(r,[0,2,3,4,1]):r))}function W9(r,e,t,n=1,o="valid",s,a=1){return z(()=>{if(s==null&&(s=xn()),Gt(s),r.shape.length!==3)throw new B(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(e.shape.length!==3)throw new B(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new B(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(r=Ge(r,[0,2,1])),o==="causal")throw new Ne("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=ey(r,e,n,o==="same"?"same":"valid","NWC",a);return t!=null&&(i=In(i,t)),i})}function VE(r,e,t,n=[1,1],o="valid",s,a,i=null){return z(()=>{if(s==null&&(s=xn()),Gt(s),r.rank!==3&&r.rank!==4)throw new B(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(e.rank!==3&&e.rank!==4)throw new B(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=jh(r,s);if(o==="causal")throw new Ne("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Cl.conv2d({x:u,filter:e,strides:n,pad:o==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:i}),s==="channelsFirst"&&(u=Ge(u,[0,3,1,2])),u})}function U9(r,e,t,n=[1,1,1],o="valid",s,a){return z(()=>{if(s==null&&(s=xn()),Gt(s),r.rank!==4&&r.rank!==5)throw new B(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(e.rank!==4&&e.rank!==5)throw new B(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let i=JA(r,s);if(o==="causal")throw new Ne("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=ry(i,e,n,o==="same"?"same":"valid","NDHWC",a),t!=null&&(i=In(i,t)),s==="channelsFirst"&&(i=Ge(i,[0,4,1,2,3])),i})}var Ep=class extends Ee{rank;kernelSize;strides;padding;dataFormat;activation;useBias;dilationRate;biasInitializer;biasConstraint;biasRegularizer;bias=null;DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_BIAS_INITIALIZER="zeros";constructor(e,t){if(super(t),Ep.verifyArgs(t),this.rank=e,sr(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ne(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=El(t.kernelSize,e,"kernelSize"),this.strides=El(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,yn(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,Gt(this.dataFormat),this.activation=mi(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=St(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Ht(t.biasConstraint),this.biasRegularizer=Nt(t.biasRegularizer),this.activityRegularizer=Nt(t.activityRegularizer),this.dilationRate=El(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new B(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new B(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new B(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(hs("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!zy(e.kernelSize,"number",1,3))throw new B(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:pi(this.activation),useBias:this.useBias,biasInitializer:Mt(this.biasInitializer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),biasConstraint:Vt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},Fl=class extends Ep{filters;kernel=null;kernelInitializer;kernelConstraint;kernelRegularizer;constructor(e,t){super(e,t),Fl.verifyArgs(t),this.filters=t.filters,sr(this.filters,"filters"),this.kernelInitializer=St(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Ht(t.kernelConstraint),this.kernelRegularizer=Nt(t.kernelRegularizer)}build(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return z(()=>{e=De(e);let n,o=this.bias==null?null:this.bias.read(),s=Gy(this.activation.getClassName());if(s!=null&&this.rank===2)n=VE(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=W9(e,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=VE(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=U9(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ne("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=Ke(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let a=Fn(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let o=[e[0]];return this.dataFormat==="channelsLast"?(o=o.concat(t),o.push(this.filters)):(o.push(this.filters),o=o.concat(t)),o}getConfig(){let e={filters:this.filters,kernelInitializer:Mt(this.kernelInitializer),kernelRegularizer:yt(this.kernelRegularizer),kernelConstraint:Vt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new B(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},ew=class extends Fl{constructor(e){super(2,e),ew.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!zy(e.kernelSize,"number",1,2))throw new B(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}},Rp=ew;K(Rp,"className","Conv2D");Q.registerClass(Rp);var tw=class extends Fl{constructor(e){super(3,e),tw.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new B(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}},Pp=tw;K(Pp,"className","Conv3D");Q.registerClass(Pp);var ed=class extends Rp{constructor(e){if(super(e),this.inputSpec=[new wt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new B(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ke(e),e.length!==4)throw new B("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wt({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return z(()=>{let n=De(e);if(n.shape.length!==4)throw new B(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i;this.dataFormat==="channelsFirst"?(a=2,i=3):(a=1,i=2);let u=o[a],l=o[i],p=this.kernelSize[0],m=this.kernelSize[1],c=this.strides[0],d=this.strides[1],f=ci(u,c,p,this.padding),h=ci(l,d,m,this.padding),g=[s,f,h,this.filters];this.dataFormat!=="channelsLast"&&(n=Ge(n,[0,2,3,1]));let b=ty(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(b=Ge(b,[0,3,1,2])),this.bias!=null&&(b=In(b,this.bias.read(),this.dataFormat)),this.activation!=null&&(b=this.activation.apply(b)),b})}computeOutputShape(e){e=Ke(e);let t=e.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let a=this.kernelSize[0],i=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[o]=ci(t[o],u,a,this.padding),t[s]=ci(t[s],l,i,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};K(ed,"className","Conv2DTranspose");Q.registerClass(ed);var td=class extends Pp{constructor(e){if(super(e),this.inputSpec=[new wt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new B(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ke(e),e.length!==5)throw new B("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wt({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return z(()=>{let n=De(e);if(n.shape.length!==5)throw new B(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],a,i,u;this.dataFormat==="channelsFirst"?(u=2,a=3,i=4):(u=1,a=2,i=3);let l=o[u],p=o[a],m=o[i],c=this.kernelSize[0],d=this.kernelSize[1],f=this.kernelSize[2],h=this.strides[0],g=this.strides[1],b=this.strides[2],T=ci(l,h,c,this.padding),x=ci(p,g,d,this.padding),I=ci(m,b,f,this.padding),S=[s,T,x,I,this.filters];this.dataFormat!=="channelsLast"&&(n=Ge(n,[0,2,3,4,1]));let w=oy(n,this.kernel.read(),S,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(w=Ge(w,[0,4,1,2,3])),this.bias!==null&&(w=In(w,this.bias.read(),this.dataFormat)),this.activation!==null&&(w=this.activation.apply(w)),w})}computeOutputShape(e){e=Ke(e);let t=e.slice(),n,o,s,a;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,a=4):(n=4,o=1,s=2,a=3);let i=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],p=this.strides[0],m=this.strides[1],c=this.strides[2];return t[n]=this.filters,t[o]=ci(t[o],p,i,this.padding),t[s]=ci(t[s],m,u,this.padding),t[a]=ci(t[a],c,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};K(td,"className","Conv3DTranspose");Q.registerClass(td);var FT=class extends Fl{depthMultiplier;depthwiseInitializer;depthwiseRegularizer;depthwiseConstraint;pointwiseInitializer;pointwiseRegularizer;pointwiseConstraint;DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";DEFAULT_POINTWISE_INITIALIZER="glorotUniform";depthwiseKernel=null;pointwiseKernel=null;constructor(e,t){if(super(e,t),t.filters==null)throw new B("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new B("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new B(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=St(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Nt(t.depthwiseRegularizer),this.depthwiseConstraint=Ht(t.depthwiseConstraint),this.pointwiseInitializer=St(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Nt(t.pointwiseRegularizer),this.pointwiseConstraint=Ht(t.pointwiseConstraint)}build(e){if(e=Ke(e),e.length<this.rank+2)throw new B(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new B(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let i=0;i<this.rank;++i)s.push(1);s.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new wt({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return z(()=>{e=De(e);let n;if(this.rank===1)throw new Ne("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ge(e,[0,2,3,1])),n=Sy(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=In(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Ge(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.pointwiseInitializer=Mt(this.pointwiseInitializer),e.depthwiseRegularizer=yt(this.depthwiseRegularizer),e.pointwiseRegularizer=yt(this.pointwiseRegularizer),e.depthwiseConstraint=Vt(this.depthwiseConstraint),e.pointwiseConstraint=Vt(this.pointwiseConstraint),e}};K(FT,"className","SeparableConv");var rd=class extends FT{constructor(e){super(2,e)}};K(rd,"className","SeparableConv2D");Q.registerClass(rd);var rw=class extends Fl{constructor(e){super(1,e),rw.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!zy(e.kernelSize,"number",1,1))throw new B(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}},nd=rw;K(nd,"className","Conv1D");Q.registerClass(nd);var od=class extends Ee{cropping;dataFormat;constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return z(()=>{if(e=De(e),this.dataFormat==="channelsLast"){let n=$h(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return $h(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=$h(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return $h(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};K(od,"className","Cropping2D");Q.registerClass(od);var sd=class extends Ee{DEFAULT_SIZE=[2,2];size;dataFormat;interpolation;constructor(e){super(e),this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,sR(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return z(()=>{let n=De(e),o=n.shape;if(this.dataFormat==="channelsFirst"){n=Ge(n,[0,2,3,1]);let s=this.size[0]*o[2],a=this.size[1]*o[3],i=this.interpolation==="nearest"?fs.resizeNearestNeighbor(n,[s,a]):fs.resizeBilinear(n,[s,a]);return Ge(i,[0,3,1,2])}else{let s=this.size[0]*o[1],a=this.size[1]*o[2];return this.interpolation==="nearest"?fs.resizeNearestNeighbor(n,[s,a]):fs.resizeBilinear(n,[s,a])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};K(sd,"className","UpSampling2D");Q.registerClass(sd);function K9(r,e,t=[1,1],n="valid",o,s){return z(()=>{o==null&&(o=xn()),Gt(o);let a=jh(r,o);if(r.rank!==4)throw new B(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(e.rank!==4)throw new B(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=bl(a,e,t,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(a=Ge(a,[0,3,1,2])),a})}var ad=class extends Ep{depthMultiplier;depthwiseInitializer;depthwiseConstraint;depthwiseRegularizer;depthwiseKernel=null;constructor(e){super(2,e),this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=St(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Ht(e.depthwiseConstraint),this.depthwiseRegularizer=Nt(e.depthwiseRegularizer)}build(e){if(e=Ke(e),e.length<4)throw new B(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new B(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return z(()=>{e=De(e);let n=K9(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=In(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Fn(t,this.kernelSize[0],this.padding,this.strides[0]),a=Fn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],o,s,a]:[e[0],s,a,o]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.depthwiseRegularizer=yt(this.depthwiseRegularizer),e.depthwiseConstraint=Vt(this.depthwiseRegularizer),e}};K(ad,"className","DepthwiseConv2D");Q.registerClass(ad);function nw(r,e,t,n){if(Array.isArray(r)){if(e!=null||t!=null)throw new B("When inputs is an array, neither initialState or constants should be provided");n!=null&&(t=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(e=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return e=o(e),t=o(t),{inputs:r,initialState:e,constants:t}}function ow(r,e,t,n=!1,o,s,a=!1,i=!1){return z(()=>{let u=e.shape.length;if(u<3)throw new B(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(Tn(2,u));if(e=Ge(e,l),s!=null)throw new Ne("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=re(re(o,"bool"),"float32"),o.rank===u-1&&(o=yr(o,-1)),o=Ge(o,l)),n&&(e=_r(e,0),o!=null&&(o=_r(o,0)));let p=[],m,c=t,d=e.shape[0],f=Rr(e),h;o!=null&&(h=Rr(o));for(let b=0;b<d;++b){let T=f[b],x=z(()=>r(T,c));if(o==null)m=x[0],c=x[1];else{let I=z(()=>{let S=h[b],w=de(zr(S),S),_=Z(P(x[0],S),P(c[0],w)),M=c.map((R,E)=>Z(P(x[1][E],S),P(R,w)));return{output:_,newStates:M}});m=I.output,c=I.newStates}i&&p.push(m)}let g;return i&&(g=cr(p,1)),[m,g,c]})}var sw=class extends Ee{cell;returnSequences;returnState;goBackwards;unroll;stateSpec;states_;keptStates;numConstants;constructor(e){super(e);let t;if(e.cell==null)throw new B("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new $p({cells:e.cell}):t=e.cell,t.stateSize==null)throw new B("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new wt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Tn(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Yy(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],o;if(this.returnSequences?o=[e[0],e[1],n]:o=[e[0],n],this.returnState){let s=[];for(let a of t)s.push([e[0],a]);return[o].concat(s)}else return o}computeMask(e,t){return z(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ne("Constants support is not implemented in RNN yet.");Yy(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new wt({shape:[n,null,...o]});let s=[e[0]].concat(e.slice(2));this.cell.build(s);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!y.arraysEqual(this.stateSpec.map(i=>i.shape[i.shape.length-1]),a))throw new B(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(i=>new wt({shape:[null,i]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){z(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new B("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Ct([n,o])):this.states_=[Ct([n,this.cell.stateSize])];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Ct([n,o])):this.states_[0]=Ct([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new B(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let o=0;o<this.states_.length;++o){let s=e[o],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,i=[n,a];if(!y.arraysEqual(s.shape,i))throw new B(`State ${o} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Et(o.clone()))})}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=nw(e,n,o,this.numConstants);e=s.inputs,n=s.initialState,o=s.constants;let a=[],i=[];if(n!=null){t.initialState=n,a=a.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new wt({shape:l.shape}));i=i.concat(this.stateSpec)}if(o!=null&&(t.constants=o,a=a.concat(o),this.numConstants=o.length),a[0]instanceof ln){let l=[e].concat(a),p=this.inputSpec.concat(i),m=this.inputSpec;this.inputSpec=p;let c=super.apply(l,t);return this.inputSpec=m,c}else return super.apply(e,t)}call(e,t){return z(()=>{let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;e=De(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new B(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let i={training:o},l=ow((f,h)=>{let g=this.cell.call([f].concat(h),i);return[g[0],g.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),p=l[0],m=l[1],c=l[2];this.stateful&&this.resetStates(c,o);let d=this.returnSequences?m:p;return this.returnState?[d].concat(c):d})}getInitialState(e){return z(()=>{let t=Ct(e.shape);return t=be(t,[1,2]),t=gu(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?qy(t,[1,n]):t):this.cell.stateSize>1?[qy(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===sw.className&&(t.cell={className:this.cell.getClassName(),config:n}),{...n,...e,...t}}static fromConfig(e,t,n={}){let o=t.cell,s=Sn(o,n);return new e(Object.assign(t,{cell:s}))}},gs=sw;K(gs,"className","RNN");Q.registerClass(gs);var xu=class extends Ee{dropoutMask;recurrentDropoutMask},Fp=class extends xu{units;activation;useBias;kernelInitializer;recurrentInitializer;biasInitializer;kernelConstraint;recurrentConstraint;biasConstraint;kernelRegularizer;recurrentRegularizer;biasRegularizer;dropout;recurrentDropout;dropoutFunc;stateSize;kernel;recurrentKernel;bias;DEFAULT_ACTIVATION="tanh";DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_RECURRENT_INITIALIZER="orthogonal";DEFAULT_BIAS_INITIALIZER="zeros";constructor(e){super(e),this.units=e.units,sr(this.units,"units"),this.activation=mi(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Ht(e.kernelConstraint),this.recurrentConstraint=Ht(e.recurrentConstraint),this.biasConstraint=Ht(e.biasConstraint),this.dropout=Tp([1,ii([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Tp([1,ii([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return z(()=>{if(e=e,e.length!==2)throw new B(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let o=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,a=this.dropoutMask,i=this.recurrentDropoutMask;a!=null?s=ta(P(e,a),this.kernel.read()):s=ta(e,this.kernel.read()),this.bias!=null&&(s=In(s,this.bias.read())),i!=null&&(n=P(n,i));let u=Z(s,ta(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:pi(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),recurrentConstraint:Vt(this.recurrentConstraint),biasConstraint:Vt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return{...e,...t}}};K(Fp,"className","SimpleRNNCell");Q.registerClass(Fp);var id=class extends gs{constructor(e){e.cell=new Fp(e),super(e)}call(e,t){return z(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return new e(t)}};K(id,"className","SimpleRNN");Q.registerClass(id);var Lp=class extends xu{units;activation;recurrentActivation;useBias;kernelInitializer;recurrentInitializer;biasInitializer;kernelRegularizer;recurrentRegularizer;biasRegularizer;kernelConstraint;recurrentConstraint;biasConstraint;dropout;recurrentDropout;dropoutFunc;stateSize;implementation;DEFAULT_ACTIVATION="tanh";DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_RECURRENT_INITIALIZER="orthogonal";DEFAULT_BIAS_INITIALIZER="zeros";kernel;recurrentKernel;bias;constructor(e){if(super(e),e.resetAfter)throw new B("GRUCell does not support reset_after parameter set to true.");this.units=e.units,sr(this.units,"units"),this.activation=mi(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=mi(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Ht(e.kernelConstraint),this.recurrentConstraint=Ht(e.recurrentConstraint),this.biasConstraint=Ht(e.biasConstraint),this.dropout=Tp([1,ii([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Tp([1,ii([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return z(()=>{if(e=e,e.length!==2)throw new B(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,a=this.recurrentDropoutMask,i,u,l;0<this.dropout&&this.dropout<1&&(e=P(e,s[0]));let p=ta(e,this.kernel.read());this.useBias&&(p=In(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,a[0]));let m=this.recurrentKernel.read(),[c,d]=Mr(m,[2*this.units,this.units],m.rank-1),f=ta(o,c),[h,g,b]=Mr(p,3,p.rank-1),[T,x]=Mr(f,2,f.rank-1);i=this.recurrentActivation.apply(Z(h,T)),u=this.recurrentActivation.apply(Z(g,x));let I=ta(P(u,o),d);l=this.activation.apply(Z(b,I));let S=Z(P(i,o),P(Z(1,tt(i)),l));return[S,S]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:pi(this.activation),recurrentActivation:pi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),recurrentConstraint:Vt(this.recurrentConstraint),biasConstraint:Vt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return{...e,...t}}};K(Lp,"className","GRUCell");Q.registerClass(Lp);var ud=class extends gs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Lp(e),super(e)}call(e,t){return z(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};K(ud,"className","GRU");Q.registerClass(ud);var Tu=class extends xu{units;activation;recurrentActivation;useBias;kernelInitializer;recurrentInitializer;biasInitializer;unitForgetBias;kernelConstraint;recurrentConstraint;biasConstraint;kernelRegularizer;recurrentRegularizer;biasRegularizer;dropout;recurrentDropout;dropoutFunc;stateSize;implementation;DEFAULT_ACTIVATION="tanh";DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_RECURRENT_INITIALIZER="orthogonal";DEFAULT_BIAS_INITIALIZER="zeros";kernel;recurrentKernel;bias;constructor(e){super(e),this.units=e.units,sr(this.units,"units"),this.activation=mi(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=mi(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=St(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Nt(e.kernelRegularizer),this.recurrentRegularizer=Nt(e.recurrentRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.kernelConstraint=Ht(e.kernelConstraint),this.recurrentConstraint=Ht(e.recurrentConstraint),this.biasConstraint=Ht(e.biasConstraint),this.dropout=Tp([1,ii([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Tp([1,ii([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ke(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let n;if(this.useBias){if(this.unitForgetBias){let o=this.biasInitializer,s=this.units;n=new class extends Cn{static className="CustomInit";apply(i,u){let l=o.apply([s]),p=new Ml().apply([s]),m=o.apply([s*2]);return LA(LA(l,p),m)}}}else n=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return z(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new B(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,u,l,p,m;0<this.dropout&&this.dropout<1&&(e=P(e,a[0]));let c=ta(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,i[0])),c=Z(c,ta(o,this.recurrentKernel.read())),this.useBias&&(c=In(c,this.bias.read()));let[d,f,h,g]=Mr(c,4,c.rank-1);u=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(f),p=Z(P(l,s),P(u,this.activation.apply(h))),m=this.recurrentActivation.apply(g);let b=P(m,this.activation.apply(p));return[b,b,p]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:pi(this.activation),recurrentActivation:pi(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),recurrentConstraint:Vt(this.recurrentConstraint),biasConstraint:Vt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return{...e,...t}}};K(Tu,"className","LSTMCell");Q.registerClass(Tu);var ld=class extends gs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Tu(e),super(e)}call(e,t){return z(()=>{this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};K(ld,"className","LSTM");Q.registerClass(ld);var $p=class extends xu{cells;constructor(e){super(e),this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return z(()=>{e=e;let n=e.slice(1),o=[];for(let i of this.cells.slice().reverse())Array.isArray(i.stateSize)?o.push(n.splice(0,i.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],a;for(let i=0;i<this.cells.length;++i){let u=this.cells[i];n=o[i],i===0?a=[e[0]].concat(n):a=[a[0]].concat(n),a=u.call(a,t),s.push(a.slice(1))}n=[];for(let i of s.slice().reverse())n.push(...i);return[a[0]].concat(n)})}build(e){Yy(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,o)=>{ai(`RNNCell_${o}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(t)};return{...e,...o}}static fromConfig(e,t,n={}){let o=[];for(let s of t.cells)o.push(Sn(s,n));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return Oh(e)}setWeights(e){let t=[];for(let n of this.cells){let o=n.weights.length,s=e.splice(o);for(let a=0;a<n.weights.length;++a)t.push([n.weights[a],s[a]])}$c(t)}};K($p,"className","StackedRNNCells");Q.registerClass($p);function Iu(r){let{ones:e,rate:t,training:n=!1,count:o=1,dropoutFunc:s}=r,a=()=>s!=null?s(e(),t):Xy(e(),t),i=()=>_l(a,e,n);return!o||o<=1?Et(i().clone()):Array(o).fill(void 0).map(i).map(l=>Et(l.clone()))}var LT=class extends gs{constructor(e){if(e.unroll)throw new Ne("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ne("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new wt({ndim:5})]}call(e,t){return z(()=>{if(this.cell.dropoutMask!=null&&(_e(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(_e(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new B("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return z(()=>{let{stateSize:t}=this.cell,n=e.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],a=Ct(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){z(()=>{if(!this.stateful)throw new En("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new B("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(s)):this.states_=[Ct(s)];else if(e==null)_e(this.states_),this.keptStates!=null&&(_e(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(s)):this.states_[0]=Ct(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new B(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):_e(this.states_);for(let i=0;i<this.states_.length;++i){let u=e[i],l=s;if(!y.arraysEqual(u.shape,l))throw new B(`State ${i} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[i]=u}}this.states_=this.states_.map(i=>Et(i.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:o,padding:s,strides:a,dilationRate:i}=this.cell,u=t==="channelsFirst",l=e[u?3:2],p=e[u?4:3],m=Fn(l,o[0],s,a[0],i[0]),c=Fn(p,o[1],s,a[1],i[1]);return[...e.slice(0,2),...u?[n,m,c]:[m,c,n]]}};K(LT,"className","ConvRNN2D");var Bp=class extends Tu{filters;kernelSize;strides;padding;dataFormat;dilationRate;constructor(e){let{filters:t,kernelSize:n,strides:o,padding:s,dataFormat:a,dilationRate:i}=e;super({...e,units:t}),this.filters=t,sr(this.filters,"filters"),this.kernelSize=El(n,2,"kernelSize"),this.kernelSize.forEach(u=>sr(u,"kernelSize")),this.strides=El(o||1,2,"strides"),this.strides.forEach(u=>sr(u,"strides")),this.padding=s||"valid",yn(this.padding),this.dataFormat=a||"channelsLast",Gt(this.dataFormat),this.dilationRate=El(i||1,2,"dilationRate"),this.dilationRate.forEach(u=>sr(u,"dilationRate"))}build(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new B(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=4,s=this.kernelSize.concat([n,this.filters*o]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let a=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",a,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let i;if(this.unitForgetBias){let u=this.biasInitializer,l=this.filters;i=new class extends Cn{static className="CustomInit";apply(m,c){let d=u.apply([l]),f=Tr([l]),h=u.apply([l*2]);return Ac([d,f,h])}}}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,i,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return z(()=>{if(e.length!==3)throw new B(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,o=e[0],s=e[1],a=e[2],i=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Iu({ones:()=>zr(o),rate:this.dropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(ne,oe,ae)=>!oe||!oe[ae]?ne:P(oe[ae],ne),p=l(o,u,0),m=l(o,u,1),c=l(o,u,2),d=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Iu({ones:()=>zr(s),rate:this.recurrentDropout,training:n,count:i,dropoutFunc:this.dropoutFunc}));let f=this.recurrentDropoutMask,h=l(s,f,0),g=l(s,f,1),b=l(s,f,2),T=l(s,f,3),x=3,[I,S,w,_]=Mr(this.kernel.read(),i,x),[M,R,E,O]=this.useBias?Mr(this.bias.read(),i):[null,null,null,null];p=this.inputConv(p,I,M,this.padding),m=this.inputConv(m,S,R,this.padding),c=this.inputConv(c,w,E,this.padding),d=this.inputConv(d,_,O,this.padding);let[G,W,H,U]=Mr(this.recurrentKernel.read(),i,x);h=this.recurrentConv(h,G),g=this.recurrentConv(g,W),b=this.recurrentConv(b,H),T=this.recurrentConv(T,U);let V=this.recurrentActivation.apply(Z(p,h)),Y=this.recurrentActivation.apply(Z(m,g)),j=Z(P(Y,a),P(V,this.activation.apply(Z(c,b)))),te=P(this.recurrentActivation.apply(Z(d,T)),this.activation.apply(j));return[te,te,j]})}getConfig(){let{units:e,...t}=super.getConfig(),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return{...t,...n}}inputConv(e,t,n,o){let s=cs(e,t,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?In(s,n,this.dataFormat):s}recurrentConv(e,t){return cs(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};K(Bp,"className","ConvLSTM2DCell");Q.registerClass(Bp);var pd=class extends LT{constructor(e){let t=new Bp(e);super({...e,cell:t})}static fromConfig(e,t){return new e(t)}};K(pd,"className","ConvLSTM2D");Q.registerClass(pd);var Op=class extends Ee{rate;noiseShape;seed;constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?t[o]:this.noiseShape[o]);return n}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);if(0<this.rate&&this.rate<1){let o=t.training==null?!1:t.training,s=this.getNoiseShape(n);return _l(()=>Xy(n,this.rate,s,this.seed),()=>n,o)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};K(Op,"className","Dropout");Q.registerClass(Op);var md=class extends Op{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};K(md,"className","SpatialDropout1D");Q.registerClass(md);var cd=class extends Ee{units;activation=null;useBias=!0;kernelInitializer;biasInitializer;kernel=null;bias=null;DEFAULT_KERNEL_INITIALIZER="glorotNormal";DEFAULT_BIAS_INITIALIZER="zeros";kernelConstraint;biasConstraint;kernelRegularizer;biasRegularizer;constructor(e){if(super(e),e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,sr(this.units,"units"),this.activation=mi(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=St(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=St(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Ht(e.kernelConstraint),this.biasConstraint=Ht(e.biasConstraint),this.kernelRegularizer=Nt(e.kernelRegularizer),this.biasRegularizer=Nt(e.biasRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Ke(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Ke(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e),o=Gy(this.activation.getClassName()),s;return o!=null?s=ta(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=ta(n,this.kernel.read()),this.bias!=null&&(s=In(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:pi(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Vt(this.kernelConstraint),biasConstraint:Vt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};K(cd,"className","Dense");Q.registerClass(cd);var dd=class extends Ee{dataFormat;constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ke(e);for(let t of e.slice(1))if(t==null)throw new B(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ea(e,1)]}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=Ge(n,o)}return pR(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};K(dd,"className","Flatten");Q.registerClass(dd);var fd=class extends Ee{activation;constructor(e){super(e),this.supportsMasking=!0,this.activation=mi(e.activation)}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);return this.activation.apply(n)})}getConfig(){let e={activation:pi(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};K(fd,"className","Activation");Q.registerClass(fd);var hd=class extends Ee{n;constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return z(()=>(e=De(e),uR(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};K(hd,"className","RepeatVector");Q.registerClass(hd);var gd=class extends Ee{targetShape;constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",o=t.slice(),s=1,a=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(a===null)a=u;else throw new B("Can only specifiy one unknown dimension.");else s*=l}let i=ea(e);if(a!==null){if(s===0||i%s!==0)throw new B(n);o[a]=i/s}else if(i!==s)throw new B(n);return o}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return F(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};K(gd,"className","Reshape");Q.registerClass(gd);var bd=class extends Ee{dims;dimsIncludingBatch;constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=Tn(1,e.dims.length+1);if(!y.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new wt({ndim:this.dims.length+1})]}computeOutputShape(e){e=Ke(e);let t=e.slice();return this.dims.forEach((n,o)=>{t[o+1]=e[n]}),t}call(e,t){return Ge(De(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};K(bd,"className","Permute");Q.registerClass(bd);var yd=class extends Ee{maskValue;constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=De(e),o=-1;return vh(du(n,this.maskValue),o)}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e),o=-1,s=!0,a=vh(du(n,this.maskValue),o,s);return P(n,re(a,n.dtype))})}};K(yd,"className","Masking");Q.registerClass(yd);var Td=class extends Ee{inputDim;outputDim;embeddingsInitializer;maskZero;inputLength;embeddings=null;DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform";embeddingsRegularizer;embeddingsConstraint;constructor(e){if(super(e),e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(At(e.inputLength))}this.inputDim=e.inputDim,sr(this.inputDim,"inputDim"),this.outputDim=e.outputDim,sr(this.outputDim,"outputDim"),this.embeddingsInitializer=St(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Nt(e.embeddingsRegularizer),this.activityRegularizer=Nt(e.activityRegularizer),this.embeddingsConstraint=Ht(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return z(()=>this.maskZero?(e=De(e),du(e,we(e))):null)}computeOutputShape(e){if(e=Ke(e),this.inputLength==null)return[...e,this.outputDim];let t=At(this.inputLength);if(t.length!==e.length-1)throw new B(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let o=0;o<t.length;++o){let s=t[o],a=e[o+1];if(s!=null&&a!=null&&s!==a)throw new B(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=a),n++}}return[e[0],...t,this.outputDim]}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);n.dtype!=="int32"&&(n=un(n,"int32"));let o=jy(this.embeddings.read(),F(n,[n.size]));return F(o,Ke(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Mt(this.embeddingsInitializer),embeddingsRegularizer:yt(this.embeddingsRegularizer),activityRegularizer:yt(this.activityRegularizer),embeddingsConstraint:Vt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};K(Td,"className","Embedding");Q.registerClass(Td);var Cu=class extends Ee{reshapeRequired;constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ne}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let o=0;o<t.length;++o){let s=e[e.length-t.length+o],a=t[o];if(s==null||a==null||s<0||a<0)n.push(null);else if(s===1)n.push(a);else if(a===1)n.push(s);else{if(s!==a)throw new B("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ke(e)]),e=e,e.length<2)throw new B(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Js(t),t.length>1)throw new B(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let o=e.map(s=>s.length);e.indexOf(null)===-1&&Js(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return z(()=>{if(e=e,this.reshapeRequired){let n=[],o=e.map(s=>s.rank);if(o.indexOf(null)===-1){let s=ii(o);for(let a of e){let i=a.rank;for(let u=0;u<s-i;++u)a=gu(a,1);n.push(a)}return this.mergeFunction(n)}else{let s=!1;for(let u of e){let l=u.rank;if(l==null){let p=u.shape,m=p[0],c=p.slice(1).concat([m]),d=F(u,[m].concat(ea(p.slice(1))));d=Ge(d,[1,0]),d=F(d,c),n.push(d),s=!0}else if(l>1){let p=Tn(1,l).concat([0]);n.push(Ge(u,p)),s=!0}else n.push(u)}let a=this.mergeFunction(n),i=a.rank;if(s){if(i==null){let u=a.shape,l=u.length,p=u[l-1],m=[p].concat(u.slice(0,u.length-1));a=F(Ge(F(a,[-1,p]),[1,0]),m)}else if(i>1){let u=[i-1].concat(Tn(0,i-1));a=Ge(a,u)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let o=1;o<e.length;++o){let s=e[o]==null?null:e[o].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let o of e)o!=null&&o[0]!==null&&n.push(o[0]);return n=Js(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return z(()=>{if(t==null)return null;if(!Array.isArray(t))throw new B("`mask` should be an Array");if(!Array.isArray(e))throw new B("`inputs` should be an Array");if(t.length!==e.length)throw new B(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(o=>o==null))return null;t=t.map(o=>o==null?o:yr(o,0));let n=t[0];for(let o=1;o<t.length-1;++o)n=sn(n,t[o]);return n})}},xd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return t})}};K(xd,"className","Add");Q.registerClass(xd);var Id=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=P(t,e[n]);return t})}};K(Id,"className","Multiply");Q.registerClass(Id);var Cd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Z(t,e[n]);return P(1/e.length,t)})}};K(Cd,"className","Average");Q.registerClass(Cd);var Sd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=ds(t,e[n]);return t})}};K(Sd,"className","Maximum");Q.registerClass(Sd);var kd=class extends Cu{constructor(e){super(e)}mergeFunction(e){return z(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Il(t,e[n]);return t})}};K(kd,"className","Minimum");Q.registerClass(kd);var vd=class extends Cu{DEFAULT_AXIS=-1;axis;constructor(e){super(e),e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new B("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let o of e)if(o!=null){t=!1;break}if(t)return;let n=[];for(let o=0;o<e.length;++o){let s=e[o].slice();s.splice(this.axis,1);let a=!1;for(let i of n)if(y.arraysEqual(i,s)){a=!0;break}a||n.push(s)}if(n.length>1)throw new B("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return z(()=>Ac(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new B("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new B("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new B("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new B(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return z(()=>{let n=!0;if(t.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let o=[];for(let a=0;a<e.length;++a)t[a]==null?o.push(re(zr(e[a]),"bool")):t[a].rank<e[a].rank?o.push(yr(t[a],-1)):o.push(t[a]);let s=ct(o,this.axis);return Ub(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};K(vd,"className","Concatenate");Q.registerClass(vd);function Xh(r,e){for(;r<0;)r+=e;return r}function V9(r,e,t){if(r.shape.length>3||e.shape.length>3)throw new Ne("batchDot is not implemented for tensors of 4D or higher rank yet");if(y.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),y.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),r.dtype==="complex64"||e.dtype==="complex64")throw new Ne("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=e.shape.length;t==null&&(t=[n-1,o-2]);let s=t;return z(()=>{let a;if(n>o){a=n-o;let u=[];for(let l=0;l<a;++l)u.push(1);e=F(e,e.shape.concat(u))}else if(o>n){a=o-n;let u=[];for(let l=0;l<a;++l)u.push(1);r=F(r,r.shape.concat(u))}else a=0;let i;if(r.shape.length===2&&e.shape.length===2)s[0]===s[1]?i=be(P(r,e),s[0]):i=be(P(Ge(r,[1,0]),e),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===e.shape.length-1;i=Ue(r,e,u,l)}if(a>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let p=u;p<u+a;++p)l.push(p);i=js(i,l)}return i.shape.length===1&&(i=yr(i,1)),i})}var Ad=class extends Cu{axes;normalize;constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Ne("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);if(t[o[0]]!==n[o[1]])throw new B(`Dimension incompatibility: ${t[o[0]]} !== ${n[o[1]]}`)}mergeFunction(e){if(e.length!==2)throw new B(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,a)=>Xh(s,e[a].shape.length)):o=[Xh(this.axes,t.shape.length),Xh(this.axes,n.shape.length)],this.normalize&&(t=zh(t,o[0]),n=zh(n,o[1])),V9(t,n,o)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[Xh(this.axes,e.length),Xh(this.axes,t.length)],n}computeOutputShape(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Ne("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);t.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};K(Ad,"className","Dot");Q.registerClass(Ad);var wd=class extends Ee{stddev;constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);return _l(()=>Z(wc(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};K(wd,"className","GaussianNoise");Q.registerClass(wd);var Nd=class extends Ee{rate;constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return z(()=>{this.invokeCallHook(e,t);let n=De(e);return this.rate>0&&this.rate<1?_l(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return P(n,wc(n.shape,1,s))},()=>n,t.training||!1):n})}};K(Nd,"className","GaussianDropout");Q.registerClass(Nd);var Dd=class extends Ee{rate;noiseShape;constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||De(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return z(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return _l(()=>{let s=De(e),a=1.6732632423543772,i=1.0507009873554805,u=-a*i,l=Xn(Ei(n),this.rate);l=un(l,"float32");let p=((1-this.rate)*(1+this.rate*u**2))**-.5,m=-p*u*this.rate,c=Z(P(s,l),P(Z(l,-1),u));return Z(P(c,p),m)},()=>De(e),t.training||!1)}return e})}};K(Dd,"className","AlphaDropout");Q.registerClass(Dd);function Yh(r,e,t,n,o,s=.001){let a;if(r.rank===2)a=Hb(r,e,t,n,o,s);else if(r.rank===3)a=qb(r,e,t,n,o,s);else if(r.rank===4)a=jb(r,e,t,n,o,s);else throw new Ne(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return a}function H9(r,e,t,n,o=.001){return z(()=>{let s=up(r,n),a=s.mean,i=s.variance;return[Yh(r,a,i,t,e,o),a,i]})}function q9(r,e,t,n,o=.001){return z(()=>{let s=up(r,n),a=s.mean,i=s.variance,u=[];for(let f of Tn(0,r.rank))n.indexOf(f)!==-1?u.push(1):u.push(r.shape[f]);let l=F(a,u),p=F(i,u),m=e==null?null:F(e,u),c=t==null?null:F(t,u);return[Yh(r,l,p,c,m,o),a,i]})}function j9(r,e,t,n,o=.001){return y.arraysEqual(n.slice().sort(),Tn(0,r.rank-1))?H9(r,e,t,n,o):q9(r,e,t,n,o)}var _d=class extends Ee{axis;momentum;epsilon;center;scale;betaInitializer;gammaInitializer;movingMeanInitializer;movingVarianceInitializer;betaConstraint;gammaConstraint;betaRegularizer;gammaRegularizer;gamma;beta;movingMean;movingVariance;constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=St(e.betaInitializer||"zeros"),this.gammaInitializer=St(e.gammaInitializer||"ones"),this.movingMeanInitializer=St(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=St(e.movingVarianceInitializer||"ones"),this.betaConstraint=Ht(e.betaConstraint),this.gammaConstraint=Ht(e.gammaConstraint),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer)}build(e){e=Ke(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new B(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new wt({ndim:e.length,axes:{[t]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return z(()=>{let n=t.training==null?!1:t.training,o=De(e),s=o.shape,a=s.length,i=Tn(0,a),u=this.axis>=0?this.axis:this.axis+a;i.splice(u,1);let l=Zs(1,a);l[u]=s[u];let p=i.slice();p.sort();let m=!y.arraysEqual(p,Tn(0,a).slice(0,a-1)),c=()=>{if(m){let T=F(this.movingMean.read(),l),x=F(this.movingVariance.read(),l),I=this.center?F(this.beta.read(),l):null,S=this.scale?F(this.gamma.read(),l):null;return Yh(o,T,x,I,S,this.epsilon)}else return Yh(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return c();let[d,f,h]=j9(o,this.gamma.read(),this.beta.read(),i,this.epsilon),g=(T,x,I)=>{z(()=>{let S=1-I,w=T.read(),_=P(de(w,x),S);T.write(de(w,_))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,h,this.momentum)})(),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),movingMeanInitializer:Mt(this.movingMeanInitializer),movingVarianceInitializer:Mt(this.movingVarianceInitializer),betaRegularizer:yt(this.betaRegularizer),gammaRegularizer:yt(this.gammaRegularizer),betaConstraint:Vt(this.betaConstraint),gammaConstraint:Vt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};K(_d,"className","BatchNormalization");Q.registerClass(_d);var Md=class extends Ee{axis;epsilon;center;scale;betaInitializer;gammaInitializer;betaRegularizer;gammaRegularizer;gamma;beta;constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=St(e.betaInitializer||"zeros"),this.gammaInitializer=St(e.gammaInitializer||"ones"),this.betaRegularizer=Nt(e.betaRegularizer),this.gammaRegularizer=Nt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Ke(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Js(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(e,t){let n=De(e),o=n.shape,s=o.length;return z(()=>{let{mean:i,variance:u}=up(n,this.axis,!0),l=Zs(1,s);for(let h of this.axis)l[h]=o[h];let p=h=>h!=null&&h.shape.length!==s?F(h,l):h,m=this.scale?p(this.gamma.read()):null,c=this.center?p(this.beta.read()):null,d=[],f=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(d.push(o[h]),f.push(1)):(d.push(1),f.push(o[h]));return i=on(i,d),u=on(u,d),m!=null&&(m=on(m,f)),c!=null&&(c=on(c,f)),Yh(n,i,u,c,m,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),betaRegularizer:yt(this.betaRegularizer),gammaRegularizer:yt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};K(Md,"className","LayerNormalization");Q.registerClass(Md);function X9(r,e,t){return z(()=>{if(r.rank!==4)throw new B(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new B("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=xn()),t!=="channelsLast"&&t!=="channelsFirst")throw new B(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return t==="channelsFirst"?n=[[0,0],[0,0],e[0],e[1]]:n=[[0,0],e[0],e[1],[0,0]],Yn(r,n)})}var Rd=class extends Ee{dataFormat;padding;constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?xn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new B(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new B(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new B(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new wt({ndim:4})]}computeOutputShape(e){e=Ke(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return z(()=>X9(De(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};K(Rd,"className","ZeroPadding2D");Q.registerClass(Rd);function WT(r,e,t,n,o,s){return z(()=>{Gt(o),RA(s),yn(n),t==null&&(t=[1,1]),n==null&&(n="valid"),o==null&&(o=xn()),s==null&&(s="max"),r=jh(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=dc(r,e,t,i):a=ac(r,e,t,i),o==="channelsFirst"&&(a=Ge(a,[0,3,1,2])),a})}function HE(r,e,t,n,o,s){return z(()=>{Gt(o),RA(s),yn(n),t==null&&(t=[1,1,1]),n==null&&(n="valid"),o==null&&(o=xn()),s==null&&(s="max"),r=JA(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=fy(r,e,t,i):a=Vb(r,e,t,i),o==="channelsFirst"&&(a=Ge(a,[0,4,1,2,3])),a})}var $T=class extends Ee{poolSize;strides;padding;constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new B(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(sr(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new B(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,yn(this.padding),this.inputSpec=[new wt({ndim:3})]}computeOutputShape(e){e=Ke(e);let t=Fn(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return z(()=>{this.invokeCallHook(e,t),e=gu(De(e),2);let n=this.poolingFunction(De(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return js(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},Pd=class extends $T{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),WT(e,t,n,o,s,"max")}};K(Pd,"className","MaxPooling1D");Q.registerClass(Pd);var Ed=class extends $T{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),WT(e,t,n,o,s,"avg")}};K(Ed,"className","AveragePooling1D");Q.registerClass(Ed);var BT=class extends Ee{poolSize;strides;padding;dataFormat;constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new B(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];sr(this.poolSize,"poolSize"),sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),yn(this.padding),this.inputSpec=[new wt({ndim:4})]}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Fn(t,this.poolSize[0],this.padding,this.strides[0]),n=Fn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return z(()=>(this.invokeCallHook(e,t),this.poolingFunction(De(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Fd=class extends BT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),WT(e,t,n,o,s,"max")}};K(Fd,"className","MaxPooling2D");Q.registerClass(Fd);var Ld=class extends BT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),WT(e,t,n,o,s,"avg")}};K(Ld,"className","AveragePooling2D");Q.registerClass(Ld);var OT=class extends Ee{poolSize;strides;padding;dataFormat;constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new B(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];sr(this.poolSize,"poolSize"),sr(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),yn(this.padding),this.inputSpec=[new wt({ndim:5})]}computeOutputShape(e){e=Ke(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Fn(t,this.poolSize[0],this.padding,this.strides[0]),n=Fn(n,this.poolSize[1],this.padding,this.strides[1]),o=Fn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,o]:[e[0],t,n,o,e[4]]}call(e,t){return z(()=>(this.invokeCallHook(e,t),this.poolingFunction(De(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},$d=class extends OT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),HE(e,t,n,o,s,"max")}};K($d,"className","MaxPooling3D");Q.registerClass($d);var Bd=class extends OT{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return Gt(s),yn(o),HE(e,t,n,o,s,"avg")}};K(Bd,"className","AveragePooling3D");Q.registerClass(Bd);var zT=class extends Ee{constructor(e){super(e),this.inputSpec=[new wt({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ne}},Od=class extends zT{constructor(e){super(e||{})}call(e,t){return z(()=>{let n=De(e);return Lt(n,1)})}};K(Od,"className","GlobalAveragePooling1D");Q.registerClass(Od);var zd=class extends zT{constructor(e){super(e||{})}call(e,t){return z(()=>{let n=De(e);return qr(n,1)})}};K(zd,"className","GlobalMaxPooling1D");Q.registerClass(zd);var GT=class extends Ee{dataFormat;constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Gt(this.dataFormat),this.inputSpec=[new wt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ne}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Gd=class extends GT{call(e,t){return z(()=>{let n=De(e);return this.dataFormat==="channelsLast"?Lt(n,[1,2]):Lt(n,[2,3])})}};K(Gd,"className","GlobalAveragePooling2D");Q.registerClass(Gd);var Wd=class extends GT{call(e,t){return z(()=>{let n=De(e);return this.dataFormat==="channelsLast"?qr(n,[1,2]):qr(n,[2,3])})}};K(Wd,"className","GlobalMaxPooling2D");Q.registerClass(Wd);var UT=class extends Ee{layer;constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let o=t.layer,s=Sn(o,n);delete t.layer;let a={layer:s};return Object.assign(a,t),new e(a)}},Ud=class extends UT{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Ke(e),e.length<3)throw new B(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Ke(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),o=e[1];return[n[0],o].concat(n.slice(1))}call(e,t){return z(()=>(e=De(e),ow((a,i)=>[De(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};K(Ud,"className","TimeDistributed");Q.registerClass(Ud);function Y9(r){Oi(nR,"BidirectionalMergeMode",r)}var Z9="concat",Kd=class extends UT{mergeMode;forwardLayer;backwardLayer;returnSequences;returnState;numConstants;_trainable;constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Sn(n),t.goBackwards=t.goBackwards!==!0;let o={};if(o.className=e.layer.getClassName(),o.config=t,this.backwardLayer=Sn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Z9:e.mergeMode,Y9(this.mergeMode),e.weights)throw new Ne("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,o,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Pr(o)}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=nw(e,n,o,this.numConstants);if(e=s.inputs,n=s.initialState,o=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&o==null)return super.apply(e,t);let a=[],i=[];if(n!=null){let l=n.length;if(l%2>0)throw new B("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,a.push(...n);let p=n.map(m=>new wt({shape:m.shape}));this.forwardLayer.stateSpec=p.slice(0,l/2),this.backwardLayer.stateSpec=p.slice(l/2),i.push(...p)}if(o!=null)throw new Ne("Support for constants in Bidirectional layers is not implemented yet.");let u=a[0]instanceof ln;for(let l of a)if(l instanceof ln!==u)throw new B("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[e].concat(a),p=this.inputSpec.concat(i),m=this.inputSpec;this.inputSpec=p;let c=super.apply(l,t);return this.inputSpec=m,c}else return super.apply(e,t)}call(e,t){return z(()=>{let n=t.initialState,o,s;if(n==null)o=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(o)&&(a=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=_r(s,1));let i;return this.mergeMode==="concat"?i=Ac([o,s]):this.mergeMode==="sum"?i=Z(o,s):this.mergeMode==="ave"?i=P(.5,Z(o,s)):this.mergeMode==="mul"?i=P(o,s):this.mergeMode==null&&(i=[o,s]),this.returnState?this.mergeMode==null?i.concat(a):[i].concat(a):i})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){ai(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),ai(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=Sn(t.layer);if(delete t.layer,t.numConstants!=null)throw new Ne("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=t;return o.layer=n,new e(o)}};K(Kd,"className","Bidirectional");Q.registerClass(Kd);var Vd=class extends Ee{scale;offset;constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){let e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return z(()=>(e=De(e),e.dtype!=="float32"&&(e=un(e,"float32")),Z(P(e,this.scale),this.offset)))}};K(Vd,"className","Rescaling");Q.registerClass(Vd);var{resizeBilinear:Q9,cropAndResize:J9}=fs,Hd=class extends Ee{height;width;constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,o,s,a,i,u){return z(()=>{let l,p=!1,m=t/a,c=n/i,d=(o+t)/a,f=(s+n)/i,h=[m,c,d,f],g=[];e.rank===3?(p=!0,l=cr([e])):l=e;for(let S=0;S<l.shape[0];S++)g.push(h);let b=mr(g,[g.length,4]),T=Fi(0,g.length,1,"int32"),I=J9(l,b,T,[o,s],"nearest");return p?un(De(Rr(I)),u):un(I,u)})}upsize(e,t,n,o){return z(()=>{let s=Q9(e,[t,n]);return un(s,o)})}call(e,t){return z(()=>{let n=De(e),o=n.dtype,s=n.shape,a=s[s.length-3],i=s[s.length-2],u=0;a!==this.height&&(u=Math.floor((a-this.height)/2));let l=0;return i!==this.width&&(l=Math.floor((i-this.width)/2),l===0&&(l=1)),u>=0&&l>=0?this.centerCrop(n,u,l,this.height,this.width,a,i,o):this.upsize(e,this.height,this.width,o)})}getConfig(){let e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=Ke(e);let t=e.length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}};K(Hd,"className","CenterCrop");Q.registerClass(Hd);function qE(r,e,t,n){let o=De(r);if(o.dtype!=="int32"&&(o=un(o,"int32")),e==="int")return o;let s=o.shape;if(o.rank===0&&(o=yr(o,-1)),e==="oneHot"&&o.shape[o.shape.length-1]!==1&&(o=yr(o,-1)),o.rank>2)throw new B(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${s} which would result in output rank ${o.rank}.`);let a=["multiHot","oneHot"].includes(e),i=o,u;if(typeof n<"u"&&e==="count"?u=wh(i,n,t,a):u=wh(i,[],t,a),e!=="tfIdf")return u;if(n)return P(u,n);throw new B("When outputMode is 'tfIdf', weights must be provided.")}var qd=class extends Ee{numTokens;outputMode;constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){let e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=Ke(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return z(()=>{e=De(e),e.dtype!=="int32"&&(e=un(e,"int32"));let n;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new B(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);n=De(t.countWeights)}let o=qr(e),s=sp(e),a=Qt(this.numTokens,o).bufferSync().get(0),i=Xn(s,0).bufferSync().get(0);if(!(a&&i))throw new B(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return qE(e,this.outputMode,this.numTokens,n)})}};K(qd,"className","CategoryEncoding");Q.registerClass(qd);var tee=["bilinear","nearest"],jE=new Set(tee),jd=class extends Ee{height;width;interpolation;cropToAspectRatio;constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(jE.has(e.interpolation))this.interpolation=e.interpolation;else throw new B(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){e=Ke(e);let t=e[2];return[this.height,this.width,t]}getConfig(){let e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return z(()=>{let n=[this.height,this.width];if(this.interpolation==="bilinear")return fs.resizeBilinear(e,n,!this.cropToAspectRatio);if(this.interpolation==="nearest")return fs.resizeNearestNeighbor(e,n,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...jE]} are supported`)})}};K(jd,"className","Resizing");Q.registerClass(jd);function ree(r){return new ui(r)}function nee(r){return new Zc(r)}function oee(r){return new jc(r)}function see(r){return new Xc(r)}function aee(r){return new Yc(r)}function iee(r){return new Jc(r)}function uee(r){return new Qc(r)}function lee(r){return new nd(r)}function pee(r){return new Rp(r)}function mee(r){return new ed(r)}function cee(r){return new Pp(r)}function dee(r){return new td(r)}function fee(r){return new rd(r)}function hee(r){return new od(r)}function gee(r){return new sd(r)}function bee(r){return new ad(r)}function yee(r){return new fd(r)}function Tee(r){return new cd(r)}function xee(r){return new Op(r)}function Iee(r){return new md(r)}function Cee(r){return new dd(r)}function See(r){return new hd(r)}function kee(r){return new gd(r)}function vee(r){return new bd(r)}function Aee(r){return new Td(r)}function wee(r){return new xd(r)}function Nee(r){return new Cd(r)}function Dee(r){return new vd(r)}function _ee(r){return new Sd(r)}function Mee(r){return new kd(r)}function Ree(r){return new Id(r)}function Pee(r){return new Ad(r)}function Eee(r){return new _d(r)}function Fee(r){return new Md(r)}function Lee(r){return new Rd(r)}function aw(r){return new Ed(r)}function $ee(r){return aw(r)}function Bee(r){return aw(r)}function iw(r){return new Ld(r)}function Oee(r){return iw(r)}function zee(r){return iw(r)}function uw(r){return new Bd(r)}function Gee(r){return uw(r)}function Wee(r){return uw(r)}function Uee(r){return new Od(r)}function Kee(r){return new Gd(r)}function XE(r){return new zd(r)}function YE(r){return new Wd(r)}function ZE(r){return new Pd(r)}function QE(r){return new Fd(r)}function Vee(r){return new $d(r)}function Hee(r){return new ud(r)}function qee(r){return new Lp(r)}function jee(r){return new ld(r)}function Xee(r){return new Tu(r)}function Yee(r){return new id(r)}function Zee(r){return new Fp(r)}function Qee(r){return new pd(r)}function Jee(r){return new Bp(r)}function ete(r){return new gs(r)}function tte(r){return new $p(r)}function rte(r){return new Kd(r)}function nte(r){return new Ud(r)}var ote=XE,ste=YE,ate=ZE,ite=QE;function ute(r){return new wd(r)}function lte(r){return new Nd(r)}function pte(r){return new Dd(r)}function mte(r){return new yd(r)}function cte(r){return new Vd(r)}function dte(r){return new Hd(r)}function fte(r){return new jd(r)}function hte(r){return new qd(r)}var eF={};qe(eF,{MAPE:()=>Ate,MSE:()=>Dte,binaryAccuracy:()=>gte,binaryCrossentropy:()=>bte,categoricalAccuracy:()=>Tte,categoricalCrossentropy:()=>xte,cosineProximity:()=>Ste,mape:()=>wte,meanAbsoluteError:()=>kte,meanAbsolutePercentageError:()=>vte,meanSquaredError:()=>Nte,mse:()=>_te,precision:()=>Ite,recall:()=>Cte,sparseCategoricalAccuracy:()=>yte});function gte(r,e){return Uh(r,e)}function bte(r,e){return pT(r,e)}function yte(r,e){return mT(r,e)}function Tte(r,e){return Kh(r,e)}function xte(r,e){return Vh(r,e)}function Ite(r,e){return KA(r,e)}function Cte(r,e){return kE(r,e)}function Ste(r,e){return Wh(r,e)}function kte(r,e){return Uc(r,e)}function vte(r,e){return Rl(r,e)}function Ate(r,e){return Rl(r,e)}function wte(r,e){return Rl(r,e)}function Nte(r,e){return Gi(r,e)}function Dte(r,e){return Gi(r,e)}function _te(r,e){return Gi(r,e)}var tF={};qe(tF,{modelFromJSON:()=>OE});var rF={};qe(rF,{l1:()=>Rte,l1l2:()=>Mte,l2:()=>Pte});function Mte(r){return new Pl(r)}function Rte(r){return UE(r)}function Pte(r){return KE(r)}var VT=class extends yu{model=null;setModel(e){if(!(e instanceof Qn))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function KT(r,e){return r<e}function nF(r,e){return r>e}var HT=class extends VT{monitor;minDelta;patience;baseline;verbose;mode;monitorFunc;wait;stoppedEpoch;best;constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new Ne("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=KT:this.mode==="max"?this.monitorFunc=nF:this.monitor.indexOf("acc")!==-1?this.monitorFunc=nF:this.monitorFunc=KT,this.monitorFunc===KT&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===KT?1/0:-1/0}async onEpochEnd(e,t){await zi(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function Ete(r){return new HT(r)}var Fte={earlyStopping:Ete};var Lte=$();Lte.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var lw=(J=>(J[J.DT_INVALID=0]="DT_INVALID",J[J.DT_FLOAT=1]="DT_FLOAT",J[J.DT_DOUBLE=2]="DT_DOUBLE",J[J.DT_INT32=3]="DT_INT32",J[J.DT_UINT8=4]="DT_UINT8",J[J.DT_INT16=5]="DT_INT16",J[J.DT_INT8=6]="DT_INT8",J[J.DT_STRING=7]="DT_STRING",J[J.DT_COMPLEX64=8]="DT_COMPLEX64",J[J.DT_INT64=9]="DT_INT64",J[J.DT_BOOL=10]="DT_BOOL",J[J.DT_QINT8=11]="DT_QINT8",J[J.DT_QUINT8=12]="DT_QUINT8",J[J.DT_QINT32=13]="DT_QINT32",J[J.DT_BFLOAT16=14]="DT_BFLOAT16",J[J.DT_QINT16=15]="DT_QINT16",J[J.DT_QUINT16=16]="DT_QUINT16",J[J.DT_UINT16=17]="DT_UINT16",J[J.DT_COMPLEX128=18]="DT_COMPLEX128",J[J.DT_HALF=19]="DT_HALF",J[J.DT_RESOURCE=20]="DT_RESOURCE",J[J.DT_VARIANT=21]="DT_VARIANT",J[J.DT_UINT32=22]="DT_UINT32",J[J.DT_UINT64=23]="DT_UINT64",J[J.DT_FLOAT_REF=101]="DT_FLOAT_REF",J[J.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",J[J.DT_INT32_REF=103]="DT_INT32_REF",J[J.DT_UINT8_REF=104]="DT_UINT8_REF",J[J.DT_INT16_REF=105]="DT_INT16_REF",J[J.DT_INT8_REF=106]="DT_INT8_REF",J[J.DT_STRING_REF=107]="DT_STRING_REF",J[J.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",J[J.DT_INT64_REF=109]="DT_INT64_REF",J[J.DT_BOOL_REF=110]="DT_BOOL_REF",J[J.DT_QINT8_REF=111]="DT_QINT8_REF",J[J.DT_QUINT8_REF=112]="DT_QUINT8_REF",J[J.DT_QINT32_REF=113]="DT_QINT32_REF",J[J.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",J[J.DT_QINT16_REF=115]="DT_QINT16_REF",J[J.DT_QUINT16_REF=116]="DT_QUINT16_REF",J[J.DT_UINT16_REF=117]="DT_UINT16_REF",J[J.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",J[J.DT_HALF_REF=119]="DT_HALF_REF",J[J.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",J[J.DT_VARIANT_REF=121]="DT_VARIANT_REF",J[J.DT_UINT32_REF=122]="DT_UINT32_REF",J[J.DT_UINT64_REF=123]="DT_UINT64_REF",J))(lw||{}),$te;(e=>{let r;(s=>(s[s.LEGACY=0]="LEGACY",s[s.V1=1]="V1",s[s.V2=2]="V2"))(r=e.CheckpointFormatVersion||={})})($te||={});var pw={};function Ote(r,e){let t={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:e};pw[r]=t}function qT(r){return pw[r]}function zte(r){delete pw[r]}function k(r,e,t,n,o){let s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){let i=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?i+1:s.inputIndexEnd;if(s.type==="tensor")return Ar(e.inputNames[s.inputIndexStart],t,n,o);if(s.type==="tensors")return e.inputNames.slice(i,u).map(c=>Ar(c,t,n,o));let l=Ar(e.inputNames.slice(i)[0],t,n,o),p=l.dataSync();return s.type==="number"?p[0]:y.toNestedArray(l.shape,p)}let a=e.attrParams[r];return a&&a.value}function Ar(r,e,t,n){let[o,s]=kn(r);if(n!=null){let i=n.getHashTableHandleByName(o);if(i!=null)return i}let a=t.currentContextIds.find(i=>!!e[jT(o,i)]);return a!==void 0?e[jT(o,a)][s]:void 0}function oF(r,e,t){return e[jT(r,t.currentContextId)]}function di(r,e){let[t,n,o]=kn(r);return[jT(t,e&&e.currentContextId),n,o]}function jT(r,e){return e?`${r}-${e}`:r}function kn(r){let e=r.split(":");if(e.length===1)return[r,0,void 0];let t=e[0],n=e.length===3?e[1]:void 0,o=Number(e[e.length-1]);return[t,o,n]}function Zh(r,e,t){let n=k("pad",r,e,t);if(n==="explicit"){n=k("explicitPaddings",r,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function fi(r){return r.kept?r:gn(r)}var mw={};qe(mw,{json:()=>Gte});var Gte=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var cw={};qe(cw,{json:()=>Wte});var Wte=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var dw={};qe(dw,{json:()=>Ute});var Ute=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var fw={};qe(fw,{json:()=>Kte});var Kte=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var hw={};qe(hw,{json:()=>Vte});var Vte=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var gw={};qe(gw,{json:()=>Hte});var Hte=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var bw={};qe(bw,{json:()=>qte});var qte=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var yw={};qe(yw,{json:()=>jte});var jte=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var Tw={};qe(Tw,{json:()=>Xte});var Xte=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var xw={};qe(xw,{json:()=>Yte});var Yte=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var Iw={};qe(Iw,{json:()=>Zte});var Zte=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Cw={};qe(Cw,{json:()=>Qte});var Qte=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var Sw={};qe(Sw,{json:()=>Jte});var Jte=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var kw={};qe(kw,{json:()=>ere});var ere=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var vw={};qe(vw,{json:()=>tre});var tre=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var Aw={};qe(Aw,{json:()=>rre});var rre=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var ww={};qe(ww,{json:()=>nre});var nre=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var Nw={};qe(Nw,{json:()=>ore});var ore=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var Dw={};qe(Dw,{json:()=>sre});var sre=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Xd=class{opMappers;static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[mw,cw,dw,fw,hw,gw,bw,yw,Tw,xw,Iw,Cw,Sw,kw,vw,Aw,ww,Nw,Dw],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(e,t={}){let n=e.node,o=[],s=[],a=[],i=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&a.push(h[g.name]),h),{}),u=[],l=[],p={},m={};t!=null&&(p=this.mapSignatureEntries(t.inputs),m=this.mapSignatureEntries(t.outputs));let c=Object.keys(i);c.forEach(h=>{let g=i[h];g.inputNames.forEach((b,T)=>{let[x,,I]=di(b),S=i[x];if(S.outputs!=null){let w=S.outputs.indexOf(I);if(w!==-1){let _=`${x}:${w}`;g.inputNames[T]=_}}g.inputs.push(S),S.children.push(g)})}),Object.keys(m).length===0?c.forEach(h=>{let g=i[h];g.children.length===0&&l.push(g)}):Object.keys(m).forEach(h=>{let[g]=di(h),b=i[g];b!=null&&(b.signatureKey=m[h],l.push(b))}),Object.keys(p).length>0?Object.keys(p).forEach(h=>{let[g]=di(h),b=i[g];b&&(b.signatureKey=p[h],u.push(b))}):u=o;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let f={nodes:i,inputs:u,outputs:l,weights:s,placeholders:o,signature:t,functions:d};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=qT(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((o,s)=>{let a=s.type,i;switch(s.type){case"string":i=XT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=XT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=rx(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=rx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=ZT(e.attr,s.tfName,s.defaultValue||0),i===void 0&&!!s.tfDeprecatedName&&(i=ZT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=tx(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=tx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=YT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=YT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=ox(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ox(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=ex(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ex(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=nx(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=nx(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=QT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=QT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=JT(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=JT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=sF(e.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=sF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:i,type:a},o},{})),n}mapFunction(e){let t=e.nodeDef,n=[],o=[],s={};t!=null&&(s=t.reduce((m,c)=>(m[c.name]=this.mapNode(c),c.op==="Const"&&o.push(m[c.name]),m),{}));let a=[],i=[];e.signature.inputArg.forEach(m=>{let[c]=di(m.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:_w(m.type),type:"dtype"}},children:[]};d.signatureKey=m.name,a.push(d),s[c]=d}),Object.keys(s).forEach(m=>{let c=s[m];c.inputNames.forEach((d,f)=>{let[h,,g]=di(d),b=s[h];if(b.outputs!=null){let T=b.outputs.indexOf(g);if(T!==-1){let x=`${h}:${T}`;c.inputNames[f]=x}}c.inputs.push(b),b.children.push(c)})});let l=e.ret;e.signature.outputArg.forEach(m=>{let[c,d]=di(l[m.name]),f=s[c];f!=null&&(f.defaultOutput=d,i.push(f))});let p=this.mapArgsToSignature(e);return{nodes:s,inputs:a,outputs:i,weights:o,placeholders:n,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};K(Xd,"_instance");function are(r){let e=$().global;if(typeof e.atob<"u")return e.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function aF(r,e){let t=Array.isArray(r)?String.fromCharCode.apply(null,r):are(r);return e?t:t.toLowerCase()}function XT(r,e,t,n=!1){let o=r[e];return o!=null?aF(o.s,n):t}function YT(r,e,t){let n=r[e];return n?n.b:t}function ZT(r,e,t){let n=r[e]||{},o=n.i!=null?n.i:n.f!=null?n.f:t;return typeof o=="number"?o:parseInt(o,10)}function _w(r){switch(typeof r=="string"&&(r=lw[r]),r){case 1:case 19:return"float32";case 3:case 9:case 6:case 4:return"int32";case 10:return"bool";case 2:return"float32";case 7:return"string";default:return null}}function sF(r,e,t){let n=r[e];return n&&n.func?n.func.name:t}function QT(r,e,t){let n=r[e];return n&&n.type?_w(n.type):t}function JT(r,e,t){let n=r[e];return n&&n.list&&n.list.type?n.list.type.map(o=>_w(o)):t}function iF(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function ex(r,e,t){let n=r[e];return n&&n.shape?iF(n.shape):t}function tx(r,e,t){let n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function rx(r,e,t,n=!1){let o=r[e];return o&&o.list&&o.list.s?o.list.s.map(s=>aF(s,n)):t}function nx(r,e,t){let n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(o=>iF(o)):t}function ox(r,e,t){let n=r[e];return n&&n.list&&n.list.b?n.list.b:t}var sx=class{constructor(e,t,n){this.node=e;this.tensorMap=t;this.context=n;this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}inputs=[];attrs={};getInput(e){return Ar(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return Ar(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return ZT(this.node.rawAttrs,e,t);if(n.s!=null)return XT(this.node.rawAttrs,e,t);if(n.b!=null)return YT(this.node.rawAttrs,e,t);if(n.shape!=null)return ex(this.node.rawAttrs,e,t);if(n.type!=null)return QT(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return tx(this.node.rawAttrs,e,t);if(n.list.s!=null)return rx(this.node.rawAttrs,e,t);if(n.list.shape!=null)return nx(this.node.rawAttrs,e,t);if(n.list.b!=null)return ox(this.node.rawAttrs,e,t);if(n.list.type!=null)return JT(this.node.rawAttrs,e,t)}return t}};var lt={};qe(lt,{OP_SCOPE_SUFFIX:()=>Gv,abs:()=>Ot,acos:()=>D1,acosh:()=>_1,add:()=>Z,addN:()=>M1,all:()=>Ub,any:()=>vh,argMax:()=>dl,argMin:()=>R1,asin:()=>P1,asinh:()=>E1,atan:()=>F1,atan2:()=>L1,atanh:()=>$1,avgPool:()=>ac,avgPool3d:()=>Vb,basicLSTMCell:()=>z1,batchNorm:()=>hl,batchNorm2d:()=>Hb,batchNorm3d:()=>qb,batchNorm4d:()=>jb,batchToSpaceND:()=>ic,bincount:()=>Xb,booleanMaskAsync:()=>YZ,broadcastArgs:()=>W1,broadcastTo:()=>gl,buffer:()=>Ie,cast:()=>re,ceil:()=>U1,clipByValue:()=>Hr,clone:()=>gn,complex:()=>Mn,concat:()=>ct,concat1d:()=>Yb,concat2d:()=>Zb,concat3d:()=>Qb,concat4d:()=>Jb,conv1d:()=>ey,conv2d:()=>cs,conv2dTranspose:()=>ty,conv3d:()=>ry,conv3dTranspose:()=>oy,cos:()=>lc,cosh:()=>sy,cosineWindow:()=>Rh,cumprod:()=>Ah,cumsum:()=>ay,denseBincount:()=>wh,depthToSpace:()=>K1,depthwiseConv2d:()=>bl,diag:()=>V1,dilation2d:()=>H1,div:()=>fe,divNoNan:()=>q1,dot:()=>j1,dropout:()=>CA,einsum:()=>X1,elu:()=>yl,enclosingPowerOfTwo:()=>SA,equal:()=>nn,erf:()=>Y1,euclideanNorm:()=>J1,exp:()=>br,expandDims:()=>yr,expm1:()=>e2,eye:()=>ip,fft:()=>Tc,fill:()=>Vs,floor:()=>Tl,floorDiv:()=>Wb,fused:()=>Cl,gather:()=>xl,gatherND:()=>sQ,greater:()=>Qt,greaterEqual:()=>Xn,ifft:()=>dp,imag:()=>cl,image:()=>fs,inTopKAsync:()=>uQ,irfft:()=>Ay,isFinite:()=>t2,isInf:()=>r2,isNaN:()=>n2,leakyRelu:()=>pc,less:()=>iy,lessEqual:()=>qs,linalg:()=>vA,linspace:()=>o2,localResponseNormalization:()=>s2,log:()=>jr,log1p:()=>mc,logSigmoid:()=>a2,logSoftmax:()=>py,logSumExp:()=>my,logicalAnd:()=>sn,logicalNot:()=>cc,logicalOr:()=>cy,logicalXor:()=>i2,losses:()=>u7,lowerBound:()=>u2,matMul:()=>Ue,max:()=>qr,maxPool:()=>dc,maxPool3d:()=>fy,maxPoolWithArgmax:()=>l2,maximum:()=>ds,mean:()=>Lt,meshgrid:()=>p2,min:()=>sp,minimum:()=>Il,mirrorPad:()=>m2,mod:()=>c2,moments:()=>up,movingAverage:()=>QZ,mul:()=>P,multiRNNCell:()=>d2,multinomial:()=>f2,neg:()=>tt,norm:()=>ap,notEqual:()=>du,oneHot:()=>pl,ones:()=>Tr,onesLike:()=>zr,op:()=>A,outerProduct:()=>h2,pad:()=>Yn,pad1d:()=>g2,pad2d:()=>b2,pad3d:()=>y2,pad4d:()=>T2,pool:()=>x2,pow:()=>jn,prelu:()=>hc,print:()=>Rb,prod:()=>I2,raggedGather:()=>C2,raggedRange:()=>S2,raggedTensorToTensor:()=>k2,rand:()=>v2,randomGamma:()=>W2,randomNormal:()=>mp,randomStandardNormal:()=>U2,randomUniform:()=>Ei,range:()=>Fi,real:()=>mu,reciprocal:()=>K2,relu:()=>an,relu6:()=>Ty,reshape:()=>F,reverse:()=>_r,reverse1d:()=>V2,reverse2d:()=>H2,reverse3d:()=>q2,reverse4d:()=>j2,rfft:()=>xc,round:()=>xy,rsqrt:()=>Iy,scalar:()=>ge,scatterND:()=>eQ,searchSorted:()=>Dh,selu:()=>Cy,separableConv2d:()=>Sy,setdiff1dAsync:()=>X2,sigmoid:()=>Pn,sign:()=>Y2,signal:()=>i7,sin:()=>ky,sinh:()=>vy,slice:()=>ze,slice1d:()=>gc,slice2d:()=>Mh,slice3d:()=>bc,slice4d:()=>cp,softmax:()=>yc,softplus:()=>cu,spaceToBatchND:()=>fc,sparse:()=>l7,sparseToDense:()=>nQ,spectral:()=>a7,split:()=>Mr,sqrt:()=>Ft,square:()=>He,squaredDifference:()=>wy,squeeze:()=>js,stack:()=>cr,step:()=>Li,stridedSlice:()=>Z2,string:()=>p7,sub:()=>de,sum:()=>be,tan:()=>Q2,tanh:()=>fl,tensor:()=>mr,tensor1d:()=>Jt,tensor2d:()=>ri,tensor3d:()=>$b,tensor4d:()=>J2,tensor5d:()=>eM,tensor6d:()=>tM,tile:()=>on,topk:()=>rM,transpose:()=>Ge,truncatedNormal:()=>Ic,unique:()=>nM,unsortedSegmentSum:()=>Ny,unstack:()=>Rr,upperBound:()=>oM,variable:()=>Dy,where:()=>zt,whereAsync:()=>My,zeros:()=>Ct,zerosLike:()=>we});var uF=(r,e,t,n=lt)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(k("a",r,e,t),k("b",r,e,t))];case"AddN":return[n.addN(k("tensors",r,e,t))];case"FloorMod":case"Mod":return[n.mod(k("a",r,e,t),k("b",r,e,t))];case"Mul":return[n.mul(k("a",r,e,t),k("b",r,e,t))];case"RealDiv":case"Div":return[n.div(k("a",r,e,t),k("b",r,e,t))];case"DivNoNan":return[n.divNoNan(k("a",r,e,t),k("b",r,e,t))];case"FloorDiv":return[n.floorDiv(k("a",r,e,t),k("b",r,e,t))];case"Sub":return[n.sub(k("a",r,e,t),k("b",r,e,t))];case"Minimum":return[n.minimum(k("a",r,e,t),k("b",r,e,t))];case"Maximum":return[n.maximum(k("a",r,e,t),k("b",r,e,t))];case"Pow":return[n.pow(k("a",r,e,t),k("b",r,e,t))];case"SquaredDifference":return[n.squaredDifference(k("a",r,e,t),k("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var lF=(r,e,t,n=lt)=>{switch(r.op){case"Abs":case"ComplexAbs":return[n.abs(k("x",r,e,t))];case"Acos":return[n.acos(k("x",r,e,t))];case"Acosh":return[n.acosh(k("x",r,e,t))];case"Asin":return[n.asin(k("x",r,e,t))];case"Asinh":return[n.asinh(k("x",r,e,t))];case"Atan":return[n.atan(k("x",r,e,t))];case"Atan2":return[n.atan2(k("x",r,e,t),k("y",r,e,t))];case"Atanh":return[n.atanh(k("x",r,e,t))];case"Ceil":return[n.ceil(k("x",r,e,t))];case"Complex":return[n.complex(k("real",r,e,t),k("imag",r,e,t))];case"Cos":return[n.cos(k("x",r,e,t))];case"Cosh":return[n.cosh(k("x",r,e,t))];case"Elu":return[n.elu(k("x",r,e,t))];case"Erf":return[n.erf(k("x",r,e,t))];case"Exp":return[n.exp(k("x",r,e,t))];case"Expm1":return[n.expm1(k("x",r,e,t))];case"Floor":return[n.floor(k("x",r,e,t))];case"Log":return[n.log(k("x",r,e,t))];case"Log1p":return[n.log1p(k("x",r,e,t))];case"Imag":return[n.imag(k("x",r,e,t))];case"Neg":return[n.neg(k("x",r,e,t))];case"Reciprocal":return[n.reciprocal(k("x",r,e,t))];case"Real":return[n.real(k("x",r,e,t))];case"Relu":return[n.relu(k("x",r,e,t))];case"Round":return[n.round(k("x",r,e,t))];case"Selu":return[n.selu(k("x",r,e,t))];case"Sigmoid":return[n.sigmoid(k("x",r,e,t))];case"Sin":return[n.sin(k("x",r,e,t))];case"Sign":return[n.sign(k("x",r,e,t))];case"Sinh":return[n.sinh(k("x",r,e,t))];case"Softplus":return[n.softplus(k("x",r,e,t))];case"Sqrt":return[n.sqrt(k("x",r,e,t))];case"Square":return[n.square(k("x",r,e,t))];case"Tanh":return[n.tanh(k("x",r,e,t))];case"Tan":return[n.tan(k("x",r,e,t))];case"ClipByValue":return[n.clipByValue(k("x",r,e,t),k("clipValueMin",r,e,t),k("clipValueMax",r,e,t))];case"Relu6":return[n.relu6(k("x",r,e,t))];case"Rsqrt":return[n.rsqrt(Ar(r.inputNames[0],e,t))];case"Prod":return[n.prod(k("x",r,e,t),k("axes",r,e,t))];case"LeakyRelu":return[n.leakyRelu(k("x",r,e,t),k("alpha",r,e,t))];case"Prelu":return[n.prelu(k("x",r,e,t),k("alpha",r,e,t))];case"IsNan":return[n.isNaN(Ar(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Jn(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){y.assert(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=e[n];y.assert(o<0||s<0||o===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function pF(r){return!(typeof r=="number"||r.some(e=>e<0))}function Yd(r,e,t){let n=ax(r,t),o=!pF(n);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&e.forEach(s=>{n=ax(s.shape,n)}),!pF(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function ax(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);let t=[];for(let n=0;n<r.length;++n){let o=r[n],s=e[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=o>=0?o:s}return t}var ix=class{constructor(e,t,n,o,s,a,i){this.name=e;this.dtype=t;this.maxSize=n;this.elementShape=o;this.identicalElementShapes=s;this.dynamicSize=a;this.clearAfterRead=i;this.idTensor=ge(0),Et(this.idTensor)}tensors=[];closed_=!1;idTensor;get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Jn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Et(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,o)=>this.write(n,t[o]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return mr([],[0].concat(this.elementShape));let n=this.readMany(e);return Jn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),cr(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return mr([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let n=this.readMany(t);return Jn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),ct(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Rr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,o=e.map(u=>(n+=u,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,a=[];z(()=>{t=F(t,[1,n,s]);for(let u=0;u<e.length;++u){let p=[0,u===0?0:o[u-1],0],m=[1,e[u],s];a[u]=F(ze(t,p,m),this.elementShape)}return a});let i=[];for(let u=0;u<e.length;u++)i[u]=u;this.writeMany(i,a)}};var Su=class{constructor(e,t,n,o=-1){this.tensors=e;this.elementShape=t;this.elementDtype=n;e?.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Jn(t,s.shape,"TensorList shape mismatch: "),Et(s)}),this.idTensor=ge(0),this.maxNumElements=o,Et(this.idTensor)}idTensor;maxNumElements;get id(){return this.idTensor.id}copy(){return new Su([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Jn(e,this.elementShape,"TensorList shape mismatch: ");let o=Yd(this.elementShape,this.tensors,e);return z(()=>{let s=this.tensors.map(a=>F(a,o));return cr(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Yd(this.elementShape,this.tensors,e),o=this.tensors.pop();return o.kept=!1,Jn(o.shape,e,"TensorList shape mismatch: "),F(o,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Jn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Et(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);let t=new Su([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Jn(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=Yd(this.elementShape,this.tensors,t);return F(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Jn(this.elementShape,t.shape,"TensorList shape mismatch: "),Et(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Jn(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=Yd(this.elementShape,this.tensors,n);return e.length===0?mr([],[0].concat(o)):z(()=>{let s=e.map(a=>F(this.tensors[a],o));return cr(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Jn(this.elementShape,t,"TensorList shape mismatch: ");let n=Yd(this.elementShape,this.tensors,t);return this.size()===0?mr([],[0].concat(n)):z(()=>{let o=this.tensors.map(s=>F(s,n));return ct(o,0)})}};function mF(r,e,t){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);let o=r.shape.slice(1);Jn(o,e,"TensorList shape mismatch: ");let s=Rr(r);return new Su(s,e,n)}function cF(r,e,t,n){return new Su([],r,e,n)}function dF(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);let o=Math.max(...e);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new Su([],t,r.dtype,n),a=Rr(r,0);return e.forEach((i,u)=>{s.setItem(i,a[u])}),s}function fF(r,e,t){let n=0,o=e.map(p=>(n+=p,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),a=ax(s,t),i=n===0?0:r.size/n,u=z(()=>{let p=[];r=F(r,[1,n,i]);for(let m=0;m<e.length;++m){let d=[0,m===0?0:o[m-1],0],f=[1,e[m],i];p[m]=F(ze(r,d,f),a)}return r.dispose(),p}),l=new Su([],t,r.dtype,e.length);for(let p=0;p<u.length;p++)l.setItem(p,u[p]);return l}var hF=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{let n=k("thenBranch",r,e,t),o=k("elseBranch",r,e,t),s=k("cond",r,e,t),a=k("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let n=k("body",r,e,t),o=k("cond",r,e,t),s=k("args",r,e,t),a=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),i=s.map(p=>p.id),u=await a[0].data();a.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&p.dispose()});let l=s;for(;u[0];){let p=l;l=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);let m=l.map(d=>d.id);p.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&m.indexOf(d.id)===-1&&d.dispose()});let c=await t.functionMap[o].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await c[0].data(),c.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&m.indexOf(d.id)===-1&&d.dispose()})}return l}case"LoopCond":{let n=k("pred",r,e,t);return[fi(n)]}case"Switch":{let n=k("pred",r,e,t),o=k("data",r,e,t);return o.kept||(o=fi(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>Ar(o,e,t)!==void 0);if(n){let o=Ar(n,e,t);return[fi(o)]}return}case"Enter":{let n=k("frameName",r,e,t),o=k("tensor",r,e,t);return t.enterFrame(n),[fi(o)]}case"Exit":{let n=k("tensor",r,e,t);return t.exitFrame(),[fi(n)]}case"NextIteration":{let n=k("tensor",r,e,t);return t.nextIteration(),[fi(n)]}case"TensorArrayV3":{let n=k("size",r,e,t),o=k("dtype",r,e,t),s=k("elementShape",r,e,t),a=k("dynamicSize",r,e,t),i=k("clearAfterRead",r,e,t),u=k("identicalElementShapes",r,e,t),l=k("name",r,e,t),p=new ix(l,o,n,s,u,a,i);return t.addTensorArray(p),[p.idTensor,ge(1)]}case"TensorArrayWriteV3":{let n=k("tensorArrayId",r,e,t),o=k("index",r,e,t),s=k("tensor",r,e,t),a=t.getTensorArray(n.id);return a.write(o,s),[a.idTensor]}case"TensorArrayReadV3":{let n=k("tensorArrayId",r,e,t),o=k("index",r,e,t);return[t.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=k("tensorArrayId",r,e,t),o=k("indices",r,e,t),s=k("dtype",r,e,t);return[t.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=k("tensorArrayId",r,e,t),o=k("indices",r,e,t),s=k("tensor",r,e,t),a=t.getTensorArray(n.id);return a.scatter(o,s),[a.idTensor]}case"TensorArrayConcatV3":{let n=k("tensorArrayId",r,e,t),o=t.getTensorArray(n.id),s=k("dtype",r,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let n=k("tensorArrayId",r,e,t),o=k("tensor",r,e,t),s=k("lengths",r,e,t),a=t.getTensorArray(n.id);return a.split(s,o),[a.idTensor]}case"TensorArraySizeV3":{let n=k("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return[ge(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=k("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=k("tensorListId",r,e,t),o=k("index",r,e,t),s=k("tensor",r,e,t),a=t.getTensorList(n.id);return a.setItem(o,s),[a.idTensor]}case"TensorListGetItem":{let n=k("tensorListId",r,e,t),o=k("index",r,e,t),s=k("elementShape",r,e,t),a=k("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(o,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{let n=k("indices",r,e,t),o=k("tensor",r,e,t),s=k("elementShape",r,e,t),a=k("numElements",r,e,t),i=dF(o,n,s,a);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=k("elementShape",r,e,t),o=k("elementDType",r,e,t),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let a=k(s,r,e,t),i=r.op==="TensorListReserve"?-1:a,u=cF(n,o,a,i);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{let n=k("tensorListId",r,e,t),o=k("indices",r,e,t),s=k("elementShape",r,e,t),a=k("elementDType",r,e,t);return[t.getTensorList(n.id).gather(o,a,s)]}case"TensorListStack":{let n=k("tensorListId",r,e,t),o=k("elementShape",r,e,t),s=k("elementDType",r,e,t),a=k("numElements",r,e,t);return[t.getTensorList(n.id).stack(o,s,a)]}case"TensorListFromTensor":{let n=k("tensor",r,e,t),o=k("elementShape",r,e,t),s=k("elementDType",r,e,t),a=mF(n,o,s);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=k("tensorListId",r,e,t),o=t.getTensorList(n.id),s=k("dtype",r,e,t),a=k("elementShape",r,e,t);return[o.concat(s,a)]}case"TensorListPushBack":{let n=k("tensorListId",r,e,t),o=k("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=k("tensorListId",r,e,t),o=k("elementShape",r,e,t),s=k("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=k("tensor",r,e,t),o=k("elementShape",r,e,t),s=k("lengths",r,e,t),a=fF(n,s,o);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{let n=k("tensorListId",r,e,t),o=t.getTensorList(n.id);return[ge(o.size(),"int32")]}case"TensorListResize":{let n=k("tensorListId",r,e,t),o=k("size",r,e,t),a=t.getTensorList(n.id).resize(o);return t.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function gF(r,e,t){let[n,o]=k("fusedOps",r,e,t),s=n==="biasadd",a=!s,i=o==="prelu",u=n==="fusedbatchnorm",l=k("numArgs",r,e,t);if(s){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=k("strides",r,e,t),m=Zh(r,e,t),c=k("dataFormat",r,e,t).toUpperCase(),d=k("dilations",r,e,t),[f,h]=k("args",r,e,t);a&&(h=f,f=void 0);let g=k("leakyreluAlpha",r,e,t);return{stride:p,pad:m,dataFormat:c,dilations:d,biasArg:f,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var bF=(r,e,t,n=lt)=>{switch(r.op){case"Conv1D":{let o=k("stride",r,e,t),s=k("pad",r,e,t),a=k("dataFormat",r,e,t).toUpperCase(),i=k("dilation",r,e,t);return[n.conv1d(k("x",r,e,t),k("filter",r,e,t),o,s,a,i)]}case"Conv2D":{let o=k("strides",r,e,t),s=Zh(r,e,t),a=k("dataFormat",r,e,t).toUpperCase(),i=k("dilations",r,e,t);return[n.conv2d(k("x",r,e,t),k("filter",r,e,t),[o[1],o[2]],s,a,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:a,dilations:i,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:m}=gF(r,e,t);return[n.fused.conv2d({x:k("x",r,e,t),filter:k("filter",r,e,t),strides:[o[1],o[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:a,dilations:i,biasArg:u,preluArg:l,activationFunc:p,leakyreluAlpha:m}=gF(r,e,t);return[n.fused.depthwiseConv2d({x:k("x",r,e,t),filter:k("filter",r,e,t),strides:[o[1],o[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:p,preluActivationWeights:l,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=k("outputShape",r,e,t),s=k("strides",r,e,t),a=Zh(r,e,t);return[n.conv2dTranspose(k("x",r,e,t),k("filter",r,e,t),o,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=k("strides",r,e,t),s=Zh(r,e,t),a=k("dilations",r,e,t),i=k("dataFormat",r,e,t).toUpperCase();return[n.depthwiseConv2d(k("input",r,e,t),k("filter",r,e,t),[o[1],o[2]],s,i,[a[1],a[2]])]}case"Conv3D":{let o=k("strides",r,e,t),s=k("pad",r,e,t),a=k("dataFormat",r,e,t).toUpperCase(),i=k("dilations",r,e,t);return[n.conv3d(k("x",r,e,t),k("filter",r,e,t),[o[1],o[2],o[3]],s,a,[i[1],i[2],i[3]])]}case"AvgPool":{let o=k("strides",r,e,t),s=k("pad",r,e,t),a=k("kernelSize",r,e,t);return[n.avgPool(k("x",r,e,t),[a[1],a[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=k("strides",r,e,t),s=k("pad",r,e,t),a=k("kernelSize",r,e,t);return[n.maxPool(k("x",r,e,t),[a[1],a[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=k("strides",r,e,t),s=k("pad",r,e,t),a=k("kernelSize",r,e,t),i=k("includeBatchInIndex",r,e,t),{result:u,indexes:l}=n.maxPoolWithArgmax(k("x",r,e,t),[a[1],a[2]],[o[1],o[2]],s,i);return[u,l]}case"AvgPool3D":{let o=k("strides",r,e,t),s=k("pad",r,e,t),a=k("kernelSize",r,e,t);return[n.avgPool3d(k("x",r,e,t),[a[1],a[2],a[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=k("strides",r,e,t),s=k("pad",r,e,t),a=k("kernelSize",r,e,t);return[n.maxPool3d(k("x",r,e,t),[a[1],a[2],a[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=k("strides",r,e,t),s=k("pad",r,e,t),a=k("dilations",r,e,t),i=o[1],u=o[2],l=a[1],p=a[2];return[n.dilation2d(k("x",r,e,t),k("filter",r,e,t),[i,u],s,[l,p],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var yF=(r,e,t,n=lt)=>{switch(r.op){case"Fill":{let o=k("shape",r,e,t),s=k("dtype",r,e,t),a=k("value",r,e,t);return[n.fill(o,a,s)]}case"LinSpace":{let o=k("start",r,e,t),s=k("stop",r,e,t),a=k("num",r,e,t);return[n.linspace(o,s,a)]}case"Multinomial":{let o=k("logits",r,e,t),s=k("numSamples",r,e,t),a=k("seed",r,e,t);return[n.multinomial(o,s,a)]}case"OneHot":{let o=k("indices",r,e,t),s=k("depth",r,e,t),a=k("onValue",r,e,t),i=k("offValue",r,e,t),u=k("dtype",r,e,t);return[n.oneHot(o,s,a,i,u)]}case"Ones":return[n.ones(k("shape",r,e,t),k("dtype",r,e,t))];case"OnesLike":return[n.onesLike(k("x",r,e,t))];case"RandomStandardNormal":return[n.randomStandardNormal(k("shape",r,e,t),k("dtype",r,e,t),k("seed",r,e,t))];case"RandomUniform":return[n.randomUniform(k("shape",r,e,t),k("minval",r,e,t),k("maxval",r,e,t),k("dtype",r,e,t))];case"Range":{let o=k("start",r,e,t),s=k("stop",r,e,t),a=k("step",r,e,t);return[n.range(o,s,a,k("dtype",r,e,t))]}case"TruncatedNormal":{let o=k("shape",r,e,t),s=k("mean",r,e,t),a=k("stdDev",r,e,t),i=k("seed",r,e,t);return[n.truncatedNormal(o,s,a,k("dtype",r,e,t),i)]}case"Zeros":return[n.zeros(k("shape",r,e,t),k("dtype",r,e,t))];case"ZerosLike":return[n.zerosLike(k("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Mw(r,e,t){let n=k("boxes",r,e,t),o=k("scores",r,e,t),s=k("maxOutputSize",r,e,t),a=k("iouThreshold",r,e,t),i=k("scoreThreshold",r,e,t),u=k("softNmsSigma",r,e,t);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}}var TF=async(r,e,t,n,o=lt)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:l,softNmsSigma:p}=Mw(r,e,t),m=await o.image.nonMaxSuppressionWithScoreAsync(s,a,i,u,l,p);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Mw(r,e,t),p=k("padToMaxOutputSize",r,e,t),m=await o.image.nonMaxSuppressionPaddedAsync(s,a,i,u,l,p);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:l}=Mw(r,e,t);return[await o.image.nonMaxSuppressionAsync(s,a,i,u,l)]}case"Where":{let s=o.cast(k("condition",r,e,t),"bool"),a=[await o.whereAsync(s)];return s.dispose(),a}case"ListDiff":return o.setdiff1dAsync(k("x",r,e,t),k("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var xF=(r,e,t,n=lt)=>{switch(r.op){case"LowerBound":{let o=k("sortedSequence",r,e,t),s=k("values",r,e,t);return[n.lowerBound(o,s)]}case"TopKV2":{let o=k("x",r,e,t),s=k("k",r,e,t),a=k("sorted",r,e,t),i=n.topk(o,s,a);return[i.values,i.indices]}case"UpperBound":{let o=k("sortedSequence",r,e,t),s=k("values",r,e,t);return[n.upperBound(o,s)]}case"Unique":{let o=k("x",r,e,t),s=n.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=k("x",r,e,t),s=k("axis",r,e,t),a=n.unique(o,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var IF=(r,e,t,n=lt)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":let o=k("default",r,e,t);return[Ar(r.name,e,t)||o];case"Placeholder":return[Ar(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let p=k("x",r,e,t);return[fi(p)]}case"IdentityN":return k("x",r,e,t).map(p=>fi(p));case"Snapshot":let s=k("x",r,e,t);return[fi(s)];case"Shape":return[n.tensor1d(k("x",r,e,t).shape,"int32")];case"ShapeN":return k("x",r,e,t).map(p=>n.tensor1d(p.shape));case"Size":return[n.scalar(k("x",r,e,t).size,"int32")];case"Rank":return[n.scalar(k("x",r,e,t).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let a=k("x",r,e,t),i=k("data",r,e,t),u=k("message",r,e,t),l=k("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let p=0;p<i.length;p++)console.log(Array.prototype.slice.call(i[p].dataSync()).slice(0,l));return[a];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var ux=class{constructor(e,t){this.keyDType=e;this.valueDType=t;this.handle=ge(0),this.tensorMap=new Map,Et(this.handle)}handle;tensorMap;get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ge(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),z(()=>{let o=Rr(t),s=n.length,a=o.length;y.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let u=n[i],l=o[i];Et(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return z(()=>{let o=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,t);o.push(i)}return cr(o)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};var CF=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=n.getHashTableHandleByName(r.name);if(o!=null)return[o];{let s=k("keyDType",r,e,t),a=k("valueDType",r,e,t),i=new ux(s,a);return n.addHashTable(r.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{let o=k("tableHandle",r,e,t,n),s=k("keys",r,e,t),a=k("values",r,e,t);return[await n.getHashTableById(o.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{let o=k("tableHandle",r,e,t,n),s=k("keys",r,e,t),a=k("defaultValue",r,e,t);return[await n.getHashTableById(o.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=k("tableHandle",r,e,t,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var SF=(r,e,t,n=lt)=>{switch(r.op){case"ResizeBilinear":{let o=k("images",r,e,t),s=k("size",r,e,t),a=k("alignCorners",r,e,t),i=k("halfPixelCenters",r,e,t);return[n.image.resizeBilinear(o,[s[0],s[1]],a,i)]}case"ResizeNearestNeighbor":{let o=k("images",r,e,t),s=k("size",r,e,t),a=k("alignCorners",r,e,t),i=k("halfPixelCenters",r,e,t);return[n.image.resizeNearestNeighbor(o,[s[0],s[1]],a,i)]}case"CropAndResize":{let o=k("image",r,e,t),s=k("boxes",r,e,t),a=k("boxInd",r,e,t),i=k("cropSize",r,e,t),u=k("method",r,e,t),l=k("extrapolationValue",r,e,t);return[n.image.cropAndResize(o,s,a,i,u,l)]}case"ImageProjectiveTransformV3":{let o=k("images",r,e,t),s=k("transforms",r,e,t),a=k("outputShape",r,e,t),i=k("fillValue",r,e,t),u=k("interpolation",r,e,t),l=k("fillMode",r,e,t);return[n.image.transform(o,s,u.toLowerCase(),l.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var kF=(r,e,t,n=lt)=>{switch(r.op){case"Equal":return[n.equal(k("a",r,e,t),k("b",r,e,t))];case"NotEqual":return[n.notEqual(k("a",r,e,t),k("b",r,e,t))];case"Greater":return[n.greater(k("a",r,e,t),k("b",r,e,t))];case"GreaterEqual":return[n.greaterEqual(k("a",r,e,t),k("b",r,e,t))];case"Less":return[n.less(k("a",r,e,t),k("b",r,e,t))];case"LessEqual":return[n.lessEqual(k("a",r,e,t),k("b",r,e,t))];case"LogicalAnd":return[n.logicalAnd(k("a",r,e,t),k("b",r,e,t))];case"LogicalNot":return[n.logicalNot(k("a",r,e,t))];case"LogicalOr":return[n.logicalOr(k("a",r,e,t),k("b",r,e,t))];case"Select":case"SelectV2":return[n.where(k("condition",r,e,t),k("a",r,e,t),k("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var vF=(r,e,t,n=lt)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(k("a",r,e,t),k("b",r,e,t),k("transposeA",r,e,t),k("transposeB",r,e,t))];case"Einsum":return[n.einsum(k("equation",r,e,t),...k("tensors",r,e,t))];case"Transpose":return[n.transpose(k("x",r,e,t),k("perm",r,e,t))];case"_FusedMatMul":let[o,s]=k("fusedOps",r,e,t),a=o==="biasadd",i=s==="prelu",u=k("numArgs",r,e,t),l=k("leakyreluAlpha",r,e,t);if(a){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[p,m]=k("args",r,e,t);return[n.fused.matMul({a:k("a",r,e,t),b:k("b",r,e,t),transposeA:k("transposeA",r,e,t),transposeB:k("transposeB",r,e,t),bias:p,activation:s,preluActivationWeights:m,leakyreluAlpha:l})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var AF=(r,e,t,n=lt)=>{switch(r.op){case"EuclideanNorm":return[n.euclideanNorm(k("x",r,e,t),k("axis",r,e,t),k("keepDims",r,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(k("x",r,e,t),k("mean",r,e,t),k("variance",r,e,t),k("offset",r,e,t),k("scale",r,e,t),k("epsilon",r,e,t))];case"FusedBatchNormV3":return[n.batchNorm(k("x",r,e,t),k("mean",r,e,t),k("variance",r,e,t),k("offset",r,e,t),k("scale",r,e,t),k("epsilon",r,e,t))];case"LRN":return[n.localResponseNormalization(k("x",r,e,t),k("radius",r,e,t),k("bias",r,e,t),k("alpha",r,e,t),k("beta",r,e,t))];case"Softmax":return[n.softmax(k("x",r,e,t))];case"LogSoftmax":return[n.logSoftmax(k("x",r,e,t))];case"SparseToDense":return[n.sparseToDense(k("sparseIndices",r,e,t),k("outputShape",r,e,t),k("sparseValues",r,e,t),k("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var wF=(r,e,t,n=lt)=>{switch(r.op){case"RaggedGather":{let{outputNestedSplits:o,outputDenseValues:s}=n.raggedGather(k("paramsNestedSplits",r,e,t),k("paramsDenseValues",r,e,t),k("indices",r,e,t),k("outputRaggedRank",r,e,t));return o.concat(s)}case"RaggedRange":{let{rtNestedSplits:o,rtDenseValues:s}=n.raggedRange(k("starts",r,e,t),k("limits",r,e,t),k("splits",r,e,t));return[o,s]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(k("shape",r,e,t),k("values",r,e,t),k("defaultValue",r,e,t),k("rowPartitionTensors",r,e,t),k("rowPartitionTypes",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var NF=(r,e,t,n=lt)=>{switch(r.op){case"Max":{let i=k("axis",r,e,t),u=k("keepDims",r,e,t);return[n.max(k("x",r,e,t),i,u)]}case"Mean":{let i=k("axis",r,e,t),u=k("keepDims",r,e,t);return[n.mean(k("x",r,e,t),i,u)]}case"Min":{let i=k("axis",r,e,t),u=k("keepDims",r,e,t);return[n.min(k("x",r,e,t),i,u)]}case"Sum":{let i=k("axis",r,e,t),u=k("keepDims",r,e,t);return[n.sum(k("x",r,e,t),i,u)]}case"All":{let i=k("axis",r,e,t),u=k("keepDims",r,e,t);return[n.all(k("x",r,e,t),i,u)]}case"Any":{let i=k("axis",r,e,t),u=k("keepDims",r,e,t);return[n.any(k("x",r,e,t),i,u)]}case"ArgMax":{let i=k("axis",r,e,t);return[n.argMax(k("x",r,e,t),i)]}case"ArgMin":{let i=k("axis",r,e,t);return[n.argMin(k("x",r,e,t),i)]}case"Prod":{let i=k("axis",r,e,t),u=k("keepDims",r,e,t);return[n.prod(k("x",r,e,t),i,u)]}case"Cumprod":{let i=k("axis",r,e,t),u=k("exclusive",r,e,t),l=k("reverse",r,e,t);return[n.cumprod(k("x",r,e,t),i,u,l)]}case"Cumsum":{let i=k("axis",r,e,t),u=k("exclusive",r,e,t),l=k("reverse",r,e,t);return[n.cumsum(k("x",r,e,t),i,u,l)]}case"Bincount":let o=k("x",r,e,t),s=k("weights",r,e,t),a=k("size",r,e,t);return[n.bincount(o,s,a)];case"DenseBincount":{let i=k("x",r,e,t),u=k("weights",r,e,t),l=k("size",r,e,t),p=k("binaryOutput",r,e,t);return[n.denseBincount(i,u,l,p)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var DF=(r,e,t,n=lt)=>{switch(r.op){case"ConcatV2":case"Concat":{let o=k("n",r,e,t),s=k("axis",r,e,t),a=k("tensors",r,e,t);return a=a.slice(0,o),[n.concat(a,s)]}case"Gather":{let o=k("x",r,e,t),s=k("indices",r,e,t);return[n.gather(o,n.cast(s,"int32"),0)]}case"GatherV2":{let o=k("axis",r,e,t),s=k("batchDims",r,e,t),a=k("x",r,e,t),i=k("indices",r,e,t);return[n.gather(a,n.cast(i,"int32"),o,s)]}case"Reverse":{let o=k("dims",r,e,t),s=[];for(let i=0;i<o.length;i++)o[i]&&s.push(i);let a=k("x",r,e,t);return[n.reverse(a,s)]}case"ReverseV2":{let o=k("axis",r,e,t),s=k("x",r,e,t);return[n.reverse(s,o)]}case"Slice":{let o=k("begin",r,e,t),s=k("size",r,e,t);return[n.slice(k("x",r,e,t),o,s)]}case"StridedSlice":{let o=k("begin",r,e,t),s=k("end",r,e,t),a=k("strides",r,e,t),i=k("beginMask",r,e,t),u=k("endMask",r,e,t),l=k("ellipsisMask",r,e,t),p=k("newAxisMask",r,e,t),m=k("shrinkAxisMask",r,e,t),c=k("x",r,e,t);return[n.stridedSlice(c,o,s,a,i,u,l,p,m)]}case"Pack":return z(()=>{let o=k("axis",r,e,t),s=k("tensors",r,e,t),a=s[0].shape,i=n.squeeze(s[0]).shape,u=s.map(l=>{let p=y.arraysEqual(l.shape,a);if(!p&&!y.arraysEqual(n.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return p?l:n.reshape(l,a)});return[n.stack(u,o)]});case"Unpack":{let o=k("axis",r,e,t),s=k("tensor",r,e,t);return n.unstack(s,o)}case"Tile":{let o=k("reps",r,e,t);return[n.tile(k("x",r,e,t),o)]}case"Split":case"SplitV":{let o=k("axis",r,e,t),s=k("numOrSizeSplits",r,e,t),a=k("x",r,e,t);return n.split(a,s,o)}case"ScatterNd":{let o=k("indices",r,e,t),s=k("values",r,e,t),a=k("shape",r,e,t);return[n.scatterND(o,s,a)]}case"GatherNd":{let o=k("x",r,e,t),s=k("indices",r,e,t);return[n.gatherND(o,s)]}case"SparseToDense":{let o=k("sparseIndices",r,e,t),s=k("outputShape",r,e,t),a=k("sparseValues",r,e,t),i=k("defaultValue",r,e,t);return[n.sparseToDense(o,a,s,a.dtype===i.dtype?i:n.cast(i,a.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var _F=(r,e,t,n=lt)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:a,reverseIndexMap:i}=n.sparse.sparseFillEmptyRows(k("indices",r,e,t),k("values",r,e,t),k("denseShape",r,e,t),k("defaultValue",r,e,t));return[o,s,a,i]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=n.sparse.sparseReshape(k("inputIndices",r,e,t),k("inputShape",r,e,t),k("newShape",r,e,t));return[o,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(k("data",r,e,t),k("indices",r,e,t),k("segmentIds",r,e,t))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(k("data",r,e,t),k("indices",r,e,t),k("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var MF=(r,e,t,n=lt)=>{switch(r.op){case"FFT":return[n.fft(k("x",r,e,t))];case"IFFT":return[n.ifft(k("x",r,e,t))];case"RFFT":return[n.rfft(k("x",r,e,t))];case"IRFFT":return[n.irfft(k("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var RF=(r,e,t,n=lt)=>{switch(r.op){case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=n.string.stringNGrams(k("data",r,e,t),k("dataSplits",r,e,t),k("separator",r,e,t),k("nGramWidths",r,e,t),k("leftPad",r,e,t),k("rightPad",r,e,t),k("padWidth",r,e,t),k("preserveShortSequences",r,e,t));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:a}=n.string.stringSplit(k("input",r,e,t),k("delimiter",r,e,t),k("skipEmpty",r,e,t));return[o,s,a]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(k("input",r,e,t),k("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var PF=(r,e,t,n=lt)=>{switch(r.op){case"Cast":return[n.cast(k("x",r,e,t),k("dtype",r,e,t))];case"ExpandDims":{let o=k("axis",r,e,t);return[n.expandDims(k("x",r,e,t),o)]}case"Squeeze":{let o=k("axis",r,e,t);return[n.squeeze(k("x",r,e,t),o)]}case"Reshape":return[n.reshape(k("x",r,e,t),k("shape",r,e,t))];case"MirrorPad":return[n.mirrorPad(k("x",r,e,t),k("padding",r,e,t),k("mode",r,e,t))];case"PadV2":case"Pad":return[n.pad(k("x",r,e,t),k("padding",r,e,t),k("constantValue",r,e,t))];case"SpaceToBatchND":{let o=k("blockShape",r,e,t),s=k("paddings",r,e,t);return[n.spaceToBatchND(k("x",r,e,t),o,s)]}case"BatchToSpaceND":{let o=k("blockShape",r,e,t),s=k("crops",r,e,t);return[n.batchToSpaceND(k("x",r,e,t),o,s)]}case"DepthToSpace":{let o=k("blockSize",r,e,t),s=k("dataFormat",r,e,t).toUpperCase();return[n.depthToSpace(k("x",r,e,t),o,s)]}case"BroadcastTo":return[n.broadcastTo(k("x",r,e,t),k("shape",r,e,t))];case"BroadcastArgs":return[n.broadcastArgs(k("s0",r,e,t),k("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Rw(r,e,t,n,o=z){let s=((a,i,u)=>{switch(a.category){case"arithmetic":return o(()=>uF(a,i,u));case"basic_math":return o(()=>lF(a,i,u));case"control":return hF(a,i,u);case"convolution":return o(()=>bF(a,i,u));case"creation":return o(()=>yF(a,i,u));case"dynamic":return TF(a,i,u);case"evaluation":return o(()=>xF(a,i,u));case"image":return o(()=>SF(a,i,u));case"graph":return o(()=>IF(a,i,u));case"logical":return o(()=>kF(a,i,u));case"matrices":return o(()=>vF(a,i,u));case"normalization":return o(()=>AF(a,i,u));case"ragged":return o(()=>wF(a,i,u));case"reduction":return o(()=>NF(a,i,u));case"slice_join":return o(()=>DF(a,i,u));case"sparse":return o(()=>_F(a,i,u));case"spectral":return o(()=>MF(a,i,u));case"string":return o(()=>RF(a,i,u));case"transformation":return o(()=>PF(a,i,u));case"hash_table":return CF(a,i,u,n);case"custom":let l=qT(a.op);if(l&&l.customExecutor)return l.customExecutor(new sx(a,i,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return y.isPromise(s)?s.then(a=>[].concat(a)):[].concat(s)}var Qh=class{constructor(e={},t={},n={},o={}){this.weightMap=e;this.tensorArrayMap=t;this.tensorListMap=n;this.functionMap=o;this.generateCurrentContextIds()}rootContext={id:0,frameName:"",iterationId:0};contexts=[this.rootContext];lastId=0;_currentContextIds;newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function Pw(r,e,t,n){let o=new Set,s=[],a=null,i=null,u=new Set,l=Object.keys(r).map(c=>kn(c)[0]),p=[];n!=null&&(p=n.map(c=>kn(c.name)[0]));let m=[...e];for(;m.length>0;){let c=m.pop();if((Ew(c)||_re(c)||Mre(c))&&a==null&&(a=c,i=a.children.map(d=>d.name).filter(d=>o.has(d))),o.add(c.name),t[c.name]==null&&l.indexOf(c.name)===-1&&p.indexOf(c.name)===-1){if(c.inputs.length===0){s.push(c.name);continue}c.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),m.push(d))})}}return{inputs:r,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:a,syncInputs:i}}function EF(r,e,t){let{usedNodes:n,inputs:o}=t,s=[],a=Object.keys(o).map(p=>kn(p)[0]).map(p=>r.nodes[p]),i=r.initNodes;a.forEach(p=>{n.has(p.name)&&s.push(p)}),r.weights.forEach(p=>{n.has(p.name)&&s.push(p)}),i?.forEach(p=>{n.has(p.name)&&s.push(p)});let u=new Set,l=[];for(;s.length>0;){let p=s.pop();u.add(p.name),e[p.name]||l.push(p),p.children.forEach(m=>{!u.has(m.name)&&n.has(m.name)&&m.inputs.every(c=>u.has(c.name))&&s.push(m)})}return l}var wre=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Nre=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],Dre=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Ew(r){return wre.indexOf(r.op)>=0}function _re(r){return Nre.indexOf(r.op)>=0}function Mre(r){return Dre.indexOf(r.op)>=0}var zp=class{constructor(e,t){this.graph=e;this.parent=t;this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new zp(e.functions[n],this)})}compiledMap=new Map;_weightMap={};_weightIds;_signature;_inputs;_outputs;_initNodes;SEPERATOR=",";_functions={};_functionExecutorMap={};_resourceManager;clonedTensorsMap;keepIntermediateTensors=!1;get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,t){let n=Pw(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(o.length>0){let i=t.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return EF(this.graph,this.weightMap,n)}cloneAndKeepTensor(e){if(e==null)return null;let t=e.clone();return Et(t),t}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=n.map(m=>this.graph.nodes[kn(m)[0]]),s=t.map(m=>kn(m)[0]),a=s.map(m=>this.graph.nodes[m]);a.length===0&&(a=this._outputs);let i=this.getCompilationKey(o,a),u=this.compiledMap.get(i);u==null&&(u=this.compile(e,a),this.compiledMap.set(i,u));try{this.keepIntermediateTensors=$().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(m){this.keepIntermediateTensors=!1,console.warn(m.message)}let l={},p={};return z(()=>{let m=new Qh(this.weightMap,l,p,this.functionExecutorMap),c={...this.weightMap};this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(h=>{let[g,b]=kn(h),T=[];T[b]=e[h],c[g]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[g]=this.cloneTensorList(T))});let d=this.getFrozenTensorIds(c),f={};for(let h=0;h<u.length;h++){let g=u[h];if(!c[g.name]){let b=Rw(g,c,m,this._resourceManager);if(y.isPromise(b))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);c[g.name]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[g.name]=this.cloneTensorList(b)),this.checkTensorForDisposal(g.name,g,c,m,d,s,f)}}return this.parent==null&&m.dispose(d),t.map(h=>Ar(h,c,m))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,n,o,s,a,i){t.category==="control"||a.indexOf(e)!==-1||(n[e].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){let l=oF(u.name,n,o);l?.forEach(p=>{if(p&&!p.kept&&!s.has(p.id)){let m=i[p.id];m===1?(p.dispose(),delete i[p.id]):m!=null&&i[p.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.clonedTensorsMap||(Object.values(this.clonedTensorsMap).forEach(e=>{for(let t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,o={},s={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=$().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(c){this.keepIntermediateTensors=!1,console.warn(c.message)}let a=new Qh(this.weightMap,o,s,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));let i=await this.executeWithControlFlow(e,a,t,n),u=t.map(c=>Ar(c,i,a)),l=u.map(c=>c.id),p=Object.keys(e).map(c=>e[c].id),m=new Set([...l,...p,...this.weightIds]);return Object.values(i).forEach(c=>{c.forEach(d=>{d&&!d.isDisposed&&!m.has(d.id)&&d.dispose()})}),this.parent==null&&a.dispose(m),u}async executeFunctionAsync(e,t,n){let o=e.reduce((s,a,i)=>(s[this.inputs[i].name]=a,s),{});return this._executeAsync(o,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,o){let s=Object.keys(e),a=s.map(x=>this.graph.nodes[kn(x)[0]]),i=n.map(x=>kn(x)[0]),u=i.map(x=>this.graph.nodes[x]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:p,dynamicNode:m,syncInputs:c}=Pw(e,u,this.weightMap,this._initNodes),d=[...a,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),f={...this.weightMap};Object.keys(e).forEach(x=>{let[I,S]=kn(x),w=[];w[S]=e[x],f[I]=w});let h={},g=this.getFrozenTensorIds(f),b={};for(;d.length>0;){let x=this.processStack(a,d,t,f,b,g,i,h,l);await Promise.all(x)}m==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let T=u.filter(x=>!Ew(x)&&!Ar(x.name,f,t)).map(x=>x.name);if(T.length>0){let x="";throw m!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${c}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${x}`)}return f}processStack(e,t,n,o,s,a,i,u,l){let p=[];for(;t.length>0;){let m=t.pop();n.currentContext=m.contexts;let c="";if(m.node.op==="Enter"&&k("isConstant",m.node,o,n)&&([c]=di(m.node.name,n)),o[m.node.name]==null){let d=Rw(m.node,o,n,this._resourceManager);c||([c]=di(m.node.name,n));let f=n.currentContext;y.isPromise(d)?p.push(d.then(h=>(o[c]=h,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(h)),n.currentContext=f,this.checkTensorForDisposal(c,m.node,o,n,a,i,u),this.processChildNodes(m.node,t,n,o,s,l),h))):(o[c]=d,this.keepIntermediateTensors&&(this.clonedTensorsMap[c]=this.cloneTensorList(d)),this.checkTensorForDisposal(c,m.node,o,n,a,i,u),this.processChildNodes(m.node,t,n,o,s,l))}else this.processChildNodes(m.node,t,n,o,s,l)}return p}processChildNodes(e,t,n,o,s,a){e.children.forEach(i=>{let[u]=di(i.name,n);s[u]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!Ar(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:i})):i.inputNames.every(l=>!!Ar(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[o]=kn(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,i=a.length===n.shape.length&&n.shape.every((u,l)=>a[l]===-1||a[l]===u);y.assert(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e){let o=this._signature?.inputs?.[n];o!=null?t[o.name]=e[n]:t[n]=e[n]}return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[o]=kn(n);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{let n=this._signature?.outputs?.[t];return n!=null?n.name:t},{})}checkOutputs(e){e.forEach(t=>{let[n]=kn(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}};var lx=class{constructor(e={},t={}){this.hashTableNameToHandle=e;this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};var Rre="?tfjs-format=file",Pre="model.json",Jh=class{constructor(e,t={},n=Br){this.modelUrl=e;this.loadOptions=t;this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new lx}executor;version="n/a";handler;artifacts;initializer;resourceIdToCapturedInput;resourceManager;signature;initializerSignature;structuredOutputKeys;io;get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{let t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=this.handler.load();return y.isPromise(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(n=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let o=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new zp(Xd.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=Xd.Instance.transformGraph(e.modelInitializer);this.initializer=new zp(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){let n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){let t=e instanceof We?[e]:e,n={};return t.forEach((o,s)=>n[this.structuredOutputKeys[s]]=o),n}return e}predict(e,t){let n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){let n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){if(!(e instanceof We)&&!Array.isArray(e)){let o=this.signature?.inputs;if(o!=null)for(let s in o){let a=o[s];a.resourceId!=null&&(e[s]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];let t=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+t!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-t} non-resource placeholders, while there are ${e.length} input tensors provided.`);let n=0;return this.inputNodes.reduce((o,s)=>{let a=this.signature?.inputs?.[s]?.resourceId;return a!=null?o[s]=this.resourceIdToCapturedInput[a]:o[s]=e[n++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){let t=this.initializerSignature.outputs,n=Object.keys(t);for(let o=0;o<n.length;o++){let s=n[o],a=t[s];this.resourceIdToCapturedInput[a.resourceId]=e[o]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&_e(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}};async function Ere(r,e={},t=Br){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof r=="string"&&(r=Lre(r));let n=new Jh(r,e,t);return await n.load(),n}function Fre(r){if(r==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(r instanceof Array){let[n,o]=r;if(!n)throw new Error("modelJSON must be the first element of the array");if(!o||!(o instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");let s=Br.getWeightSpecs(n.weightsManifest),a=Br.getModelArtifactsForJSONSync(n,s,o);e=Br.fromMemorySync(a)}else if("load"in r)e=r;else if("modelTopology"in r&&"weightSpecs"in r&&"weightData"in r)e=Br.fromMemorySync(r);else throw new Error("Unknown model format");let t=new Jh(e);return t.load(),t}function Lre(r){return r.endsWith("/")||(r=r+"/"),`${r}${Pre}${Rre}`}var $re="0.0.0";var tL={};qe(tL,{CSVDataset:()=>Jd,Dataset:()=>hi,FileDataSource:()=>of,TextLineDataset:()=>Qd,URLDataSource:()=>sf,array:()=>KF,csv:()=>XF,func:()=>YF,generator:()=>ZF,microphone:()=>JF,version_data:()=>eL,webcam:()=>QF,zip:()=>VF});var UF=Vl(_h());var zF=Vl(_h());function FF(r,e){return px(r,e)}function px(r,e,t=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(t.has(r))return t.get(r);let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(Ll(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let i=r[a],u=px(i,e,t,n);s[a]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return t.set(r,o.value),o.value}function LF(r,e=Lw){return $F(r,e)}function $F(r,e,t=new Set){let n=r[0];if(t.has(n))throw new Error("Circular references are not supported.");let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(Ll(n)){let s=Array.isArray(n)?[]:{};t.add(n);for(let a in n){let i=r.map(l=>l[a]),u=$F(i,e,t);s[a]=u}return t.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function Lw(r){return r===null?null:Ll(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function mx(r,e){let t=new Map;px(r,e,t);for(let o of Array.from(t.keys())){let s=t.get(o);if(y.isPromise(s)){let a=await s;t.set(o,a)}}return px(r,e,t)}function Ll(r){let e=!1;if($().get("IS_BROWSER"))e=r instanceof TextDecoder;else{let{StringDecoder:t}=Fw();e=r instanceof t}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof We)&&!(r instanceof Promise)&&!e)}function BF(r){return r==null||Bre(r)||Array.isArray(r)||typeof r=="object"&&r instanceof We||y.isTypedArray(r)}function Bre(r){return r===null||typeof r!="object"&&typeof r!="function"}function OF(r){return FF(r,Ore)}function Ore(r){return r instanceof We?{value:r.clone(),recurse:!1}:Ll(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var Zd=class{constructor(e){this.capacity=e;if(e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}begin=0;end=0;doubledCapacity;data;wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}};var $w=class extends Zd{constructor(){super($w.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let o=0;o<n;o++)t[o]=this.get(this.wrap(this.begin+o));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},eg=$w;K(eg,"INITIAL_CAPACITY",32);function Yw(r){return new Bw(r)}function tg(r){return new Ow(r)}function GF(r,e){return new dx(r,e)}function WF(r,e=Zw.FAIL){return new jw(r,e)}var ar=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new Hw(this,e)}filter(e){return new Kw(this,e)}map(e){return new Vw(this,e)}mapAsync(e){return new cx(this,e)}serialMapAsync(e){return new cx(this,e).serial()}flatmap(e){return new qw(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new Uw(this,e,t)}columnMajorBatch(e,t=!0,n=Lw){return this.rowMajorBatch(e,t).map(s=>LF(s,n))}concatenate(e,t){return new dx(Yw([this,e]),t)}take(e){return e<0||e==null?this:new Ww(this,e)}skip(e){return e<0||e==null?this:new Gw(this,e)}prefetch(e){return new fx(this,e)}shuffle(e,t){return new Xw(this,e,t)}serial(){return new zw(this)}},Bw=class extends ar{constructor(t){super();this.items=t}trav=0;summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:OF(t),done:!1}}},Ow=class extends ar{constructor(t){super();this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},zw=class extends ar{constructor(t){super();this.upstream=t;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},Gw=class extends ar{constructor(t,n){super();this.upstream=t;this.maxCount=n;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;count=0;summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;_e(t.value)}return this.upstream.next()}},Ww=class extends ar{constructor(t,n){super();this.upstream=t;this.maxCount=n}count=0;summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},Uw=class extends ar{constructor(t,n,o=!0){super();this.upstream=t;this.batchSize=n;this.enableSmallLastBatch=o;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(n.value)}return{value:t,done:!1}}},Kw=class extends ar{constructor(t,n){super();this.upstream=t;this.predicate=n;this.lastRead=Promise.resolve({value:null,done:!1})}lastRead;summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;_e(t.value)}}},Vw=class extends ar{constructor(t,n){super();this.upstream=t;this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let n=Ws.getTensorsInContainer(t.value),o=this.transform(t.value),s=Ws.getTensorsInContainer(o);for(let a of n)Ws.isTensorInList(a,s)||a.dispose();return{value:o,done:!1}}},Hw=class extends ar{constructor(t,n){super();this.upstream=t;this.handler=n;this.lastRead=Promise.resolve({value:null,done:!1})}count=0;summary(){return`${this.upstream.summary()} -> handleErrors`}lastRead;async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},cx=class extends ar{constructor(t,n){super();this.upstream=t;this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let n=Ws.getTensorsInContainer(t.value),o=await this.transform(t.value),s=Ws.getTensorsInContainer(o);for(let a of n)Ws.isTensorInList(a,s)||a.dispose();return{value:o,done:!1}}},Gp=class extends ar{lastRead;outputQueue;constructor(){super(),this.outputQueue=new eg,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},qw=class extends Gp{constructor(t,n){super();this.upstream=t;this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let n=Ws.getTensorsInContainer(t.value),o=this.transform(t.value),s=Ws.getTensorsInContainer(o);this.outputQueue.pushAll(o);for(let a of n)Ws.isTensorInList(a,s)||a.dispose();return!0}},dx=class extends ar{constructor(t,n){super();this.baseErrorHandler=n;this.moreIterators=t}lastRead=null;iterator=null;moreIterators;summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let o=await this.moreIterators.next();if(o.done)return{value:null,done:!0};this.iterator=o.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(t)):n}},Zw=(n=>(n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST",n))(Zw||{}),jw=class extends ar{constructor(t,n=0){super();this.iterators=t;this.mismatchMode=n}count=0;currentPromise=null;summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(t){await t;let n=0,o=0;function s(i){return i instanceof ar?{value:i.next().then(l=>(n++,l.done&&o++,l.value)),recurse:!1}:{value:null,recurse:!0}}let a=await mx(this.iterators,s);if(n===o)return{value:null,done:!0};if(o>0)switch(this.mismatchMode){case 0:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case 1:return{value:null,done:!0};case 2:default:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},fx=class extends ar{constructor(t,n){super();this.upstream=t;this.bufferSize=n;this.buffer=new Zd(n)}buffer;summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},Xw=class extends fx{constructor(t,n,o){super(t,n);this.upstream=t;this.windowSize=n;this.random=zF.alea(o||y.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}random;lastRead;upstreamExhausted=!1;async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),n=await this.buffer.shuffleExcise(t);if(n.done)this.upstreamExhausted=!0;else return this.refill(),n}return{value:null,done:!0}}};var hi=class{size=null;batch(e,t=!0){let n=this;y.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let o;return this.size===1/0||this.size==null?o=this.size:t?o=Math.ceil(this.size/e):o=Math.floor(this.size/e),Ln(async()=>(await n.iterator()).columnMajorBatch(e,t,zre),o)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Ln(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Ln(async()=>(await t.iterator()).filter(o=>z(()=>e(o))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Ln(async()=>(await t.iterator()).map(n=>z(()=>e(n))),this.size)}mapAsync(e){let t=this;return Ln(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Ln(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Ln(async()=>{let o=tg(async()=>({value:await t.iterator(),done:!1}));return GF(o.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Ln(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=UF.alea(t||y.now().toString());return Ln(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await o.iterator()).shuffle(e,a.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Ln(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};K(hi,"MAX_BUFFER_SIZE",1e4);function Ln(r,e=null){return new class extends hi{size=e;async iterator(){return r()}}}function KF(r){return Ln(async()=>Yw(r),r.length)}function VF(r){if(!Ll(r))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(r))for(let t=0;t<r.length;t++)e=e==null?r[t].size:Math.min(e,r[t].size);else if(r instanceof Object)for(let t in r)e=e==null?r[t].size:Math.min(e,r[t].size);return Ln(async()=>{let t=await mx(r,n=>{if(n instanceof hi)return{value:n.iterator(),recurse:!1};if(Ll(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return WF(t,1)},e)}function zre(r){if(r===null)return null;let e=r[0];return BF(e)?{value:Gre(r),recurse:!1}:{value:null,recurse:!0}}function Gre(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof We?cr(r):mr(r)}var Qd=class extends hi{constructor(t){super();this.input=t}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(s=>(s.endsWith("\r")&&(s=s.slice(0,-1)),s))}};var hx='"',rg=Symbol("out"),HF=Symbol("field"),gx=Symbol("quote"),Qw=Symbol("quoteafterquote"),qF=Symbol("quoteinquote"),Jd=class extends hi{constructor(t,n){super();this.input=t;this.base=new Qd(t),n||(n={}),this.hasHeader=n.hasHeader!==!1,this.fullColumnNames=n.columnNames,this.columnConfigs=n.columnConfigs,this.configuredColumnsOnly=n.configuredColumnsOnly,n.delimWhitespace?(y.assert(n.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=n.delimiter?n.delimiter:","}base;hasHeader=!0;fullColumnNames=null;columnNamesValidated=!1;columnConfigs=null;configuredColumnsOnly=!1;delimiter=",";delimWhitespace=!1;async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let t=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!t)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&t&&y.assert(t.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+t.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=t);let n=this.fullColumnNames.reduce((s,a)=>(s[a]=s[a]+1||1,s),{}),o=Object.keys(n).filter(s=>n[s]>1);if(y.assert(o.length===0,()=>"Duplicate column names found: "+o.toString()),this.columnConfigs){for(let s of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(s)===-1)throw new Error('The key "'+s+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let n=await(await this.base.iterator()).next();if(n.done)throw new Error("No data was found for CSV parsing.");let o=n.value;return this.parseRow(o,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let t=await this.base.iterator();return this.hasHeader&&(t=t.skip(1)),t.map(n=>this.makeDataElement(n))}makeDataElement(t){let n=this.parseRow(t),o={},s={};for(let a=0;a<this.fullColumnNames.length;a++){let i=this.fullColumnNames[a],u=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!u)){let l=n[a],p=null;if(l==="")if(u&&u.default!==void 0)p=u.default;else{if(u&&(u.required||u.isLabel))throw new Error(`Required column ${i} is empty in this line: ${t}`);p=void 0}else{let m=Number(l);if(isNaN(m))u&&u.dtype==="bool"?p=this.getBoolean(l):p=l;else if(!u||!u.dtype)p=m;else switch(u.dtype){case"float32":p=m;break;case"int32":p=Math.floor(m);break;case"bool":p=this.getBoolean(l);break;default:p=m}}u&&u.isLabel?s[i]=p:o[i]=p}}return Object.keys(s).length===0?o:{xs:o,ys:s}}getBoolean(t){return t==="1"||t.toLowerCase()==="true"?1:0}parseRow(t,n=!0){let o=[],s=0,a=t.length,i=rg;for(let u=0;u<a;u++)switch(i){case rg:switch(t.charAt(u)){case hx:s=u+1,i=gx;break;case this.delimiter:if(s=u+1,this.delimiter===" "&&this.delimWhitespace)break;o.push(""),i=rg;break;default:i=HF,s=u;break}break;case HF:switch(t.charAt(u)){case this.delimiter:o.push(t.substring(s,u)),i=rg,s=u+1;break;default:}break;case gx:switch(t.charAt(u)){case hx:i=Qw;break;default:}break;case Qw:switch(t.charAt(u)){case this.delimiter:o.push(t.substring(s,u-1)),i=rg,s=u+1;break;case hx:i=gx;break;default:i=qF;break}break;case qF:switch(t.charAt(u)){case hx:i=gx;break;default:}break;default:}if(i===Qw?o.push(t.substring(s,a-1)):o.push(t.substring(s)),n&&o.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${o}`);return o}};var ef=class extends ar{constructor(t){super();this.microphoneConfig=t;this.fftSize=t.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=t.numFramesPerSpectrogram||43,this.sampleRateHz=t.sampleRateHz,this.columnTruncateLength=t.columnTruncateLength||this.fftSize,this.audioTrackConstraints=t.audioTrackConstraints,this.smoothingTimeConstant=t.smoothingTimeConstant||0,this.includeSpectrogram=t.includeSpectrogram!==!1,this.includeWaveform=t.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}isClosed=!1;stream;fftSize;columnTruncateLength;freqData;timeData;numFrames;analyser;audioContext;sampleRateHz;audioTrackConstraints;smoothingTimeConstant;includeSpectrogram;includeWaveform;summary(){return"microphone"}static async create(t={}){if(!$().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new ef(t);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(o){throw new Error(`Error thrown while initializing video stream: ${o.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let t=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new t,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let t,n,o=await this.getAudioData();if(this.includeSpectrogram){let s=this.flattenQueue(o.freqDataQueue);t=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let s=this.flattenQueue(o.timeDataQueue);n=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:t,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let t=[],n=[],o=0;return new Promise(s=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&s({freqDataQueue:t,timeDataQueue:n}),t.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++o===this.numFrames&&(clearInterval(a),s({freqDataQueue:t,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(t){let n=t[0].length,o=new Float32Array(t.length*n);return t.forEach((s,a)=>o.set(s,a*n)),o}getTensorFromAudioDataArray(t,n){let o=new Float32Array(y.sizeFromShape(n));return o.set(t,o.length-t.length),mr(o,n)}};var tf=class extends ar{constructor(t,n){super();this.webcamVideoElement=t;this.webcamConfig=n;if(this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Jt([0],"int32"),this.webcamConfig.centerCrop){let o=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-o)/2,i=(1-s)/2,u=a+o,l=s+i;this.cropBox=ri([i,a,l,u],[1,4])}else this.cropBox=ri([0,0,1,1],[1,4])}isClosed=!0;stream;resize=!1;cropSize;cropBox;cropBoxInd;summary(){return"webcam"}static async create(t,n={}){if(!$().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!t){if(t=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");t.width=n.resizeWidth,t.height=n.resizeHeight}let o=new tf(t,n);return await o.start(),o}async start(){this.webcamConfig.facingMode&&y.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(t){throw t.message=`Error thrown while initializing video stream: ${t.message}`,t}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(t){console.log(t),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(t=>{this.webcamVideoElement.onloadedmetadata=()=>{t()}})}async next(){if(this.isClosed)return{value:null,done:!0};let t;try{t=Bb.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(t),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{t.dispose()}else return{value:t,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(t){return z(()=>{let n=yr(re(t,"float32"),0),o;o=fs.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let s=o.shape;return F(o,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(n=>n.stop());try{this.webcamVideoElement.srcObject=null}catch(n){console.log(n),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var rf=class{};var ng=class extends ar{split(e){return new Jw(this,e)}},Jw=class extends ng{constructor(t,n){super();this.upstream=t;this.impl=new eN(t,n)}impl;summary(){return this.impl.summary()}async next(){return this.impl.next()}},eN=class extends Gp{constructor(t,n){super();this.upstream=t;this.separator=n}carryover="";summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let t=await this.upstream.next();if(t.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let n=t.value.split(this.separator);n[0]=this.carryover+n[0];for(let o of n.slice(0,-1))this.outputQueue.push(o);return this.carryover=n[n.length-1],!0}};var bx=class extends ar{decodeUTF8(){return new tN(this)}},tN=class extends ng{constructor(t){super();this.upstream=t;this.impl=new rN(t)}impl;summary(){return this.impl.summary()}async next(){return this.impl.next()}},rN=class extends Gp{constructor(t){super();this.upstream=t;if($().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:n}=Fw();this.decoder=new n("utf8")}}decoder;summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let t=await this.upstream.next(),n;if(t.done)return!1;n=t.value;let o;return $().get("IS_BROWSER")?o=this.decoder.decode(n,{stream:!0}):o=this.decoder.write(Buffer.from(n.buffer)),this.outputQueue.push(o),!0}};var nf=class extends bx{constructor(t,n={}){super();this.file=t;this.options=n;y.assert(t instanceof Uint8Array||($().get("IS_BROWSER")?t instanceof File||t instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=n.offset||0,this.chunkSize=n.chunkSize||1024*1024}offset;chunkSize;summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((n,o)=>{let s=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)n(new Uint8Array(this.file.slice(this.offset,s)));else{let a=new FileReader;a.onload=u=>{let l=a.result;if(l instanceof ArrayBuffer&&(l=new Uint8Array(l)),!(l instanceof Uint8Array))return o(new TypeError("FileReader returned unknown type."));n(l)},a.onabort=u=>o(new Error("Aborted")),a.onerror=u=>o(new Error(u.type));let i=this.file.slice(this.offset,s);a.readAsArrayBuffer(i)}this.offset=s}),done:!1}}};async function jF(r,e={},t){let n,o;typeof r=="string"?n=r:(n=r.url,o=Wre(r));let s=await(t||y.fetch)(n,o);if(s.ok){let a=new Uint8Array(await s.arrayBuffer());return new nf(a,e)}else throw new Error(s.statusText)}var Wre=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function yx(r){return typeof r=="string"&&r.slice(0,7)==="file://"}var of=class extends rf{constructor(t,n={}){super();this.input=t;this.options=n}async iterator(){if(yx(this.input)&&$().get("IS_NODE")){let t=Tx();this.input=t.readFileSync(this.input.slice(7))}return new nf(this.input,this.options)}};var sf=class extends rf{constructor(t,n={}){super();this.url=t;this.fileOptions=n}async iterator(){return yx(this.url)?new of(this.url,this.fileOptions).iterator():jF(this.url,this.fileOptions)}};function XF(r,e={}){return new Jd(new sf(r),e)}function YF(r){let e=tg(r);return Ln(async()=>e)}function ZF(r){return Ln(async()=>{let e=await r();return tg(()=>e.next())})}async function QF(r,e){return tf.create(r,e)}async function JF(r){return ef.create(r)}var eL="0.0.0";function ee(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var Ure=xr.whereImpl,nN=class extends po{blockSize=48;data;firstUse=!0;nextDataId(){return nN.nextDataId++}constructor(){super(),this.data=new ha(this,rn())}write(e,t,n){this.firstUse&&(this.firstUse=!1,$().get("IS_NODE")&&C.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:n,refCount:1}),o}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(a=>y.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,o,s){this.data.set(e,{values:t,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return C.mergeRealAndImagArrays(o,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(o=>y.decodeString(o));return Ie(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ie(e.shape,e.dtype,t)}makeOutput(e,t,n){return rn().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=y.now();return e(),{kernelMs:y.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ee([e],"where");let t=this.readSync(e.dataId);return Ure(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},af=nN;K(af,"nextDataId",0);var ff={};qe(ff,{addImpl:()=>aN,bincountImpl:()=>pf,bincountReduceImpl:()=>xx,castImpl:()=>sN,ceilImpl:()=>iN,concatImpl:()=>Wp,equalImpl:()=>uN,expImpl:()=>pN,expm1Impl:()=>cN,floorImpl:()=>dN,gatherNdImpl:()=>Ix,gatherV2Impl:()=>Cx,greaterEqualImpl:()=>hN,greaterImpl:()=>fN,lessEqualImpl:()=>bN,lessImpl:()=>gN,linSpaceImpl:()=>Sx,logImpl:()=>yN,maxImpl:()=>kx,maximumImpl:()=>TN,minimumImpl:()=>xN,multiplyImpl:()=>og,negImpl:()=>IN,notEqualImpl:()=>CN,prodImpl:()=>SN,raggedGatherImpl:()=>vx,raggedRangeImpl:()=>Ax,raggedTensorToTensorImpl:()=>wx,rangeImpl:()=>Kp,rsqrtImpl:()=>kN,scatterImpl:()=>ku,sigmoidImpl:()=>_L,simpleAbsImpl:()=>oN,sliceImpl:()=>Vp,sparseFillEmptyRowsImpl:()=>Nx,sparseReshapeImpl:()=>Dx,sparseSegmentReductionImpl:()=>df,sqrtImpl:()=>PL,squaredDifferenceImpl:()=>AN,stridedSliceImpl:()=>_x,stringNGramsImpl:()=>Hp,stringSplitImpl:()=>qp,stringToHashBucketFastImpl:()=>jp,subImpl:()=>NN,tileImpl:()=>Mx,topKImpl:()=>Rx,transposeImpl:()=>mf,uniqueImpl:()=>Px});function oN(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}var Kre=r=>{let{x:e}=r.inputs,t=r.backend;ee(e,"abs");let n=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId).values;return n=oN(o),t.makeOutput(n,e.shape,e.dtype)},rL={kernelName:xs,backendName:"cpu",kernelFunc:Kre};function ot(r){return(e,t,n,o,s)=>{let a=C.assertAndGetBroadcastShape(e,t),i=a.length,u=y.computeStrides(a),l=y.sizeFromShape(a),p=y.getTypedArrayFromDType(s,l),m=e.length,c=t.length,d=y.computeStrides(e),f=y.computeStrides(t),h=C.getBroadcastDims(e,a),g=C.getBroadcastDims(t,a);if(h.length+g.length===0)for(let b=0;b<p.length;++b)p[b]=r(n[b%n.length],o[b%o.length]);else for(let b=0;b<p.length;++b){let T=y.indexToLoc(b,i,u),x=T.slice(-m);h.forEach(_=>x[_]=0);let I=y.locToIndex(x,m,d),S=T.slice(-c);g.forEach(_=>S[_]=0);let w=y.locToIndex(S,c,f);p[b]=r(n[I],o[w])}return[p,a]}}function wr(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,i=t.makeTensorInfo(n.shape,"complex64"),u=t.data.get(i.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",a)},i}var nL={kernelName:zu,backendName:"cpu",kernelFunc:wr};function uf(r,e,t="float32"){if(t==="complex64"){let o=uf(r,e,"float32"),s=uf(r,e,"float32");return wr({inputs:{real:o,imag:s},backend:r})}let n=y.makeZerosTypedArray(y.sizeFromShape(e),t);return r.makeTensorInfo(e,t,n)}function Jr(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var oL={kernelName:Vn,backendName:"cpu",kernelFunc:Jr};function oa(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var sL={kernelName:Zu,backendName:"cpu",kernelFunc:oa};function sN(r,e,t,n){if(n==="int32"){let o=Int32Array.from(r);return[e,"int32",o]}if(n==="bool"){let o=y.toTypedArray([0],t),[s,a]=ot((i,u)=>i!==u?1:0)(e,[],r,o,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${n}`)}function sa(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Jr({inputs:{x:o},backend:t});let p=uf(t,o.shape,o.dtype),m=sa({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),c=wr({inputs:{real:m,imag:p},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),c}if(o.dtype==="complex64"){let p=oa({inputs:{input:o},backend:t}),m=sa({inputs:{x:p},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(p),m}if(!y.hasEncodingLoss(o.dtype,s)){let p=Jr({inputs:{x:o},backend:t});return{dataId:p.dataId,shape:p.shape,dtype:s}}let a=t.data.get(o.dataId).values,[i,u,l]=sN(a,o.shape,o.dtype,s);return t.makeTensorInfo(i,u,l)}var aL={kernelName:Un,backendName:"cpu",kernelFunc:sa};function pt(r,e,t,n){return t==null?({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;ee([a,i],r);let l=u.data.get(a.dataId).values,p=u.data.get(i.dataId).values,m=a.dtype==="string"?C.fromUint8ToStringArray(l):l,c=a.dtype==="string"?C.fromUint8ToStringArray(p):p,d=n||a.dtype,[f,h]=e(a.shape,i.shape,m,c,d);return u.makeTensorInfo(h,d,f)}:({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(a.dtype==="complex64"||i.dtype==="complex64"){let l=sa({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(l.dataId),m=p.complexTensorInfos.real,c=p.complexTensorInfos.imag,d=u.data.get(m.dataId).values,f=u.data.get(c.dataId).values,h=sa({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),b=g.complexTensorInfos.real,T=g.complexTensorInfos.imag,x=u.data.get(b.dataId).values,I=u.data.get(T.dataId).values,[S,w,_]=t(a.shape,i.shape,d,f,x,I),M=u.makeTensorInfo(_,"float32",S),R=u.makeTensorInfo(_,"float32",w),E=wr({inputs:{real:M,imag:R},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(M),u.disposeIntermediateTensorInfo(R),E}else{let l=u.data.get(a.dataId).values,p=u.data.get(i.dataId).values,m=n||a.dtype,[c,d]=e(a.shape,i.shape,l,p,m);return u.makeTensorInfo(d,m,c)}}}function lf(r){return(e,t,n,o,s,a)=>{let i=C.assertAndGetBroadcastShape(e,t),u=y.sizeFromShape(i),l=i.length,p=y.computeStrides(i),m=y.getTypedArrayFromDType("float32",u),c=y.getTypedArrayFromDType("float32",u),d=C.getBroadcastDims(e,i),f=C.getBroadcastDims(t,i),h=C.mergeRealAndImagArrays(n,o),g=C.mergeRealAndImagArrays(s,a),b=e.length,T=y.computeStrides(e),x=t.length,I=y.computeStrides(t);if(d.length+f.length===0)for(let S=0;S<m.length;S++){let w=S%h.length,_=S%g.length,M=r(h[w*2],h[w*2+1],g[_*2],g[_*2+1]);m[S]=M.real,c[S]=M.imag}else for(let S=0;S<m.length;S++){let w=y.indexToLoc(S,l,p),_=w.slice(-b);d.forEach(G=>_[G]=0);let M=y.locToIndex(_,b,T),R=w.slice(-x);f.forEach(G=>R[G]=0);let E=y.locToIndex(R,x,I),O=r(h[M*2],h[M*2+1],g[E*2],g[E*2+1]);m[S]=O.real,c[S]=O.imag}return[m,c,i]}}var aN=ot((r,e)=>r+e),Vre=lf((r,e,t,n)=>({real:r+t,imag:e+n})),Wi=pt(Nn,aN,Vre),iL={kernelName:Nn,backendName:"cpu",kernelFunc:Wi};function pf(r,e,t,n,o){let s=y.sizeFromShape(n),a=y.makeZerosTypedArray(o,t);for(let i=0;i<r.length;i++){let u=r[i];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?a[u]+=e[i]:a[u]+=1)}return a}function xx(r,e,t,n=!1){let o=r.shape[0],s=r.shape[1],a=Ie([o,t],e.dtype);for(let i=0;i<o;i++)for(let u=0;u<s;u++){let l=r.get(i,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(n?a.set(1,i,l):e.size>0?a.set(a.get(i,l)+e.get(i,u),i,l):a.set(a.get(i,l)+1,i,l))}return a}function vn(r){return(e,t,n)=>{let o=y.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=r(e[s],n);return o}}function Fe(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(ee(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,l=y.sizeFromShape(a.shape),p=t||a.dtype,m=y.getArrayFromDType(p,l);for(let c=0;c<l;++c)m[c]=e(u[c],o);return i.makeTensorInfo(a.shape,p,m)}}function aa(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(ee(a,r),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,l=t||a.dtype,p=e(u,l,o);return i.makeTensorInfo(a.shape,l,p)}}var iN=vn(r=>Math.ceil(r)),Hre=aa(bo,iN),uL={kernelName:bo,backendName:"cpu",kernelFunc:Hre};function Wp(r,e,t,n){let o=y.getArrayFromDType(t,y.sizeFromShape(e));if(n&&t!=="string"){let s=0;r.forEach(a=>{let i=y.sizeFromShape(a.shape);o.set(a.vals,s),s+=i})}else{let s=0;r.forEach(a=>{let i=t==="string"?C.fromUint8ToStringArray(a.vals):a.vals,u=0;for(let l=0;l<a.shape[0];++l){let p=l*e[1]+s;for(let m=0;m<a.shape[1];++m)o[p+m]=i[u++]}s+=a.shape[1]})}return o}var uN=ot((r,e)=>r===e?1:0),lN=pt(Ma,uN,null,"bool"),lL={kernelName:Ma,backendName:"cpu",kernelFunc:lN};var pN=vn(r=>Math.exp(r)),mN=aa(Ao,pN,"float32"),pL={kernelName:Ao,backendName:"cpu",kernelFunc:mN};var cN=vn(r=>Math.expm1(r)),qre=aa(Ra,cN),mL={kernelName:Ra,backendName:"cpu",kernelFunc:qre};var dN=vn(r=>Math.floor(r)),jre=aa(wo,dN),cL={kernelName:wo,backendName:"cpu",kernelFunc:jre};function Ix(r,e,t,n,o,s,a,i,u){let l=Ie([n,s],t);for(let p=0;p<n;p++){let m=[],c=0;for(let d=0;d<o;d++){let f=r[p*o+d];c+=f*a[d],m.push(f)}if(c<0||c>=u/s)throw new Error(`Invalid indices: ${m} does not index into ${i}`);for(let d=0;d<s;d++)l.values[p*s+d]=e.get(...e.indexToLoc(c*s+d))}return l}function Cx(r,e,t){let n=Ie(t,r.dtype);for(let o=0;o<n.size;++o){let a=n.indexToLoc(o).slice(),i=a[0],u=a[2],l=e.locToIndex([i,u]);a[2]=e.values[l];let p=r.locToIndex(a);0<=p&&p<r.values.length&&(n.values[o]=r.values[p])}return n}var fN=ot((r,e)=>r>e?1:0),Xre=pt(Fa,fN,null,"bool"),dL={kernelName:Fa,backendName:"cpu",kernelFunc:Xre};var hN=ot((r,e)=>r>=e?1:0),Yre=pt(_o,hN,null,"bool"),fL={kernelName:_o,backendName:"cpu",kernelFunc:Yre};var gN=ot((r,e)=>r<e?1:0),Zre=pt(Ba,gN,null,"bool"),hL={kernelName:Ba,backendName:"cpu",kernelFunc:Zre};var bN=ot((r,e)=>r<=e?1:0),Qre=pt(Oa,bN,null,"bool"),gL={kernelName:Oa,backendName:"cpu",kernelFunc:Qre};function Sx(r,e,t){let n=(e-r)/(t-1),o=y.makeZerosTypedArray(t,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var yN=vn(r=>Math.log(r)),Jre=aa(Po,yN),bL={kernelName:Po,backendName:"cpu",kernelFunc:Jre};function kx(r,e,t,n){let o=y.getTypedArrayFromDType(n,y.sizeFromShape(t));for(let s=0;s<o.length;++s){let a=s*e,i=r[a];for(let u=0;u<e;++u){let l=r[a+u];(Number.isNaN(l)||l>i)&&(i=l)}o[s]=i}return o}var TN=ot((r,e)=>Math.max(r,e)),ene=pt(Fo,TN),yL={kernelName:Fo,backendName:"cpu",kernelFunc:ene};var xN=ot((r,e)=>Math.min(r,e)),tne=pt(Oo,xN),TL={kernelName:Oo,backendName:"cpu",kernelFunc:tne};var og=ot((r,e)=>r*e),rne=lf((r,e,t,n)=>({real:r*t-e*n,imag:r*n+e*t})),Up=pt(Go,og,rne),xL={kernelName:Go,backendName:"cpu",kernelFunc:Up};function IN(r,e,t){let n=y.createScalarValue(-1,t);return og([],e,n,r,t)}function nne(r){let{inputs:e,backend:t}=r,{x:n}=e;ee(n,"neg");let o=t.data.get(n.dataId).values,[s,a]=IN(o,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,s)}var IL={kernelName:vs,backendName:"cpu",kernelFunc:nne};var CN=ot((r,e)=>r!==e?1:0),one=pt(Ka,CN,null,"bool"),CL={kernelName:Ka,backendName:"cpu",kernelFunc:one};function mf(r,e,t,n,o){let s=e.length,a=y.sizeFromShape(e),i=y.computeStrides(e),u=y.computeStrides(o),l=y.getTypedArrayFromDType(t,y.sizeFromShape(o));for(let p=0;p<a;++p){let m=y.indexToLoc(p,s,i),c=new Array(m.length);for(let f=0;f<c.length;f++)c[f]=m[n[f]];let d=y.locToIndex(c,s,u);l[d]=r[p]}return l}function qt(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{perm:s}=t;ee(o,"transpose");let a=o.shape.length,i=new Array(a);for(let m=0;m<i.length;m++)i[m]=o.shape[s[m]];let u=n.data.get(o.dataId).values,l=mf(u,o.shape,o.dtype,s,i);return{dataId:n.write(l,i,o.dtype),shape:i,dtype:o.dtype}}var SL={kernelName:_n,backendName:"cpu",kernelFunc:qt};function SN(r,e,t,n){let[o,s]=C.computeOutAndReduceShapes(r,n),a=Pt(e,"int32"),i=y.makeZerosTypedArray(y.sizeFromShape(o),a),u=y.sizeFromShape(s);for(let l=0;l<i.length;++l){let p=l*u,m=1;for(let c=0;c<u;++c)m*=t[p+c];i[l]=m}return{outVals:i,outShape:o,outDtype:a}}function sne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"prod");let i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=C.getAxesPermutation(u,i),p=u,m=o,c=[];l!=null&&(m=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),c.push(m),p=C.getInnerMostAxes(p.length,i));let d=t.data.get(m.dataId).values,{outVals:f,outShape:h,outDtype:g}=SN(m.shape,m.dtype,d,p),b=h;return a&&(b=C.expandShapeToKeepDim(h,u)),c.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.makeTensorInfo(b,g,f)}var kL={kernelName:Ho,backendName:"cpu",kernelFunc:sne};function ane(r,e,t){r.forEach((n,o)=>{if(n<0||n>=t){let s=y.indexToLoc(o,e.length,y.computeStrides(e)).join(",");throw new Error(`indices[${s}] = ${n} is not in [0, ${t})`)}})}function ine(r,e){for(let t=0;t<r.length;++t){let n=r[t],o=t===r.length-1?e:r[t+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>o)throw new Error("Ragged splits must not point past values");for(let s=1;s<n.length;++s)if(n[s-1]>n[s])throw new Error("Ragged splits must be sorted in ascending order")}}function une(r,e,t,n){let o=[],s=0,a=e.length-1+t.length,i=new Array(a).fill(null).map(()=>[0]);ine(t,n);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];let p=e[l+1];for(let m=1;m<u+1;++m)i[l].push(m*p)}for(let l=0;l<r.length;++l){let p=r[l],m=r[l]+1;for(let c=0;c<t.length;++c){let d=t[c],f=c+e.length-1;if(f>=0){let h=i[f],g=h[h.length-1]-d[p];for(let b=p;b<m;++b)i[f].push(d[b+1]+g)}p=d[p],m=d[m]}m!==p&&(o.push([p,m]),s+=m-p)}return{outSplits:i,valueSlices:o,numValues:s}}function lne(r){let e=[];for(let t=0;t<r.length;++t){let n=r[t].length,o=y.getArrayFromDType("int32",n);e.push(o),r[t].forEach((s,a)=>o[a]=s)}return e}function vL(r,e){let t=r.slice(0,e);for(;t.length<e;)t.push(1);for(let n=e;n<r.length;n++)t[e-1]*=r[n];return t}function pne(r,e,t,n,o,s){let a=vL(e,2)[1],i=vL(s,2)[1],u=0;for(let l of t)for(let p=l[0];p<l[1];++p){for(let m=0;m<n;++m)o[u*i+m]=r[p*a+m];++u}}function mne(r,e,t,n,o){let s=e.slice();s[0]=o;let a=y.getArrayFromDType(t,y.sizeFromShape(s)),i=r.length,u=i===0?0:i/e[0];return pne(r,e,n,u,a,s),[a,s]}function vx(r,e,t,n,o,s,a,i){if(r.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");let u=e[0][0]-1;if(ane(s,a,u),n.length===0)throw new Error("params.rank must be nonzero");let l=n[0],{outSplits:p,valueSlices:m,numValues:c}=une(s,a,r,l),d=lne(p),f=mne(t,n,o,m,c);return[d,f[0],f[1]]}var AL=2147483647;function Ax(r,e,t,n,o,s,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(o.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");let i=e.length===0,u=o.length===0,l=a.length===0,p=[];i||p.push(e[0]),u||p.push(o[0]),l||p.push(a[0]);for(let g=1;g<p.length;++g)if(p[g]!==p[g-1])throw new Error("starts, limits, and deltas must have the same shape");let m=p.length===0?1:p[0],c=y.getArrayFromDType("int32",m+1);c[0]=0;for(let g=0;g<m;++g){let b=i?r[0]:r[g],T=u?n[0]:n[g],x=l?s[0]:s[g];if(x===0)throw new Error("Requires delta != 0");let I;if(x>0&&T<b||x<0&&T>b)I=0;else if(I=Math.ceil(Math.abs((T-b)/x)),I>AL)throw new Error(`Requires ((limit - start) / delta) <= ${AL}`);c[g+1]=c[g]+I}let d=c[m],f=y.getArrayFromDType(t,d),h=0;for(let g=0;g<m;++g){let b=c[g+1]-c[g],T=i?r[0]:r[g],x=l?s[0]:s[g];for(let I=0;I<b;++I)f[h++]=T,T+=x}return[c,f]}var ia=C.RowPartitionType,cf=class{constructor(e,t,n,o,s,a,i,u,l,p){this.shape=e;this.shapeShape=t;this.values=n;this.valuesShape=o;this.valuesDType=s;this.defaultValue=a;this.defaultValueShape=i;this.rowPartitionValues=u;this.rowPartitionValuesShapes=l;this.rowPartitionTypes=C.getRowPartitionTypesHelper(p),this.raggedRank=C.getRaggedRank(this.rowPartitionTypes)}rowPartitionTypes;raggedRank;getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ia.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ia.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){let t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ia.VALUE_ROWIDS:return cf.getMaxWidthValueRowID(t);case ia.ROW_SPLITS:return cf.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${ia[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){let t=e.length;if(t===0||t===1)return 0;let n=0;for(let o=0;o<t-1;++o){let s=e[o+1]-e[o];s>n&&(n=s)}return n}static getMaxWidthValueRowID(e){let t=e.length;if(t===0)return 0;let n=0,o=e[0],s=0;for(let a=1;a<t;++a){let i=e[a];i!==o&&(o=i,s=Math.max(a-n,s),n=a)}return Math.max(t-n,s)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return NL(e,n)}calculateOutputSize(e){let t=this.valuesShape,n=this.defaultValueShape;C.validateDefaultValueShape(n,t);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=C.combineRaggedTensorToTensorShapes(this.raggedRank,o,t);a[0]<0&&(a[0]=e);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(e,t,n){let o=Math.min(e,n),s=[],a=0;for(let i=0;i<o;++i,a+=t)s.push(a);for(let i=o;i<e;++i)s.push(-1);return y.assert(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,n,o){let s=e.length,a=[];for(let i=0;i<s-1;++i){let u=e[i+1]-e[i],l=Math.min(o,u),p=t[i];p===-1&&(l=0);for(let m=0;m<l;++m)a.push(p),p+=n;for(let m=0;m<u-l;++m)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,o){let s=e.length,a=[];if(s===0)return[];let i=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let l=t[u];a.push(l);for(let p=1;p<s;++p){let m=e[p];if(m===u)l>=0&&(++i,i<o?l+=n:l=-1);else{if(i=0,u=m,m>=t.length)throw new Error(`Got nextValueRowId=${m} which is not less than ${t.length}`);l=t[m]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,o){let s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case ia.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,n,o);case ia.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,n,o);default:throw new Error(`Unsupported partition type: ${ia[a]}`)}}getFirstDimensionSize(){let e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let t=this.rowPartitionTypes[0];switch(t){case ia.FIRST_DIM_SIZE:return e[0];case ia.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ia.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ia[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let t=this.getFirstDimensionSize(),n=this.calculateOutputSize(t),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let u=o.length-2;u>=0;--u)o[u]=o[u+1]*n[u+1];let s=NL(n,!1),a=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(o[0]*n[0]>0){let u=this.calculateFirstParentOutputIndex(t,o[0],n[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,o[l],n[l]);this.setOutput(this.raggedRank,u,a,s)}return[s,a]}setOutput(e,t,n,o){if(n.length===0)return;let s=this.values,a=n,i=o.slice();i=i.slice(e+1);let u=y.sizeFromShape(i),l=t.length,p=this.defaultValue;if(p.length!==u&&p.length!==1){let f=this.defaultValueShape;z(()=>{let h=F(p,f);p=gl(h,i).dataSync()})}let m=0,c=0,d=0;for(let f=0;f<=l;++f){let h=f<l?t[f]:-1;if(h===d){++d;continue}if(c<d){let g=s.subarray(m*u),b=a.subarray(c*u),T=(d-c)*u;wL(b,g,T)}if(f>=l){let g=n.length;h=Math.floor(g/u)}if(h>d)if(this.defaultValue.length===1)a.subarray(d*u,h*u).fill(this.defaultValue[0]),d=h;else for(;h>d;){let g=a.slice(d*u);wL(g,p,u),++d}h<0?(m=f+1,c=d):(m=f,c=d,d=c+1)}}};function wL(r,e,t){for(let n=0;n<t;n++)r[n]=e[n]}function NL(r,e){let t=[];for(let n of r){if(n<0){if(!e)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}t.push(n)}return t}function wx(r,e,t,n,o,s,a,i,u,l){return new cf(r,e,t,n,o,s,a,i,u,l).compute()}function Kp(r,e,t,n){let o=r===e,s=r<e&&t<0,a=e<r&&t>1;if(o||s||a)return y.makeZerosTypedArray(0,n);let i=Math.abs(Math.ceil((e-r)/t)),u=y.makeZerosTypedArray(i,n);e<r&&t===1&&(t=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}var kN=vn(r=>1/Math.sqrt(r)),cne=aa(Jo,kN),DL={kernelName:Jo,backendName:"cpu",kernelFunc:cne};function ku(r,e,t,n,o,s,a,i,u,l){let p=[n/o,o],m=r.values,c=e.values;if(n===0)return Ie(t,e.dtype);let d=Ie(p,e.dtype);typeof u=="string"||typeof u=="number"?d.values.fill(u):typeof u=="boolean"&&d.values.fill(+u);for(let f=0;f<s;f++){let h=[],g=0;for(let b=0;b<a;b++){let T=m[f*a+b];h.push(T),g+=T*i[b]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let b=0;b<o;b++)l?d.values[g*o+b]+=c[f*o+b]:d.values[g*o+b]=e.rank===0?c[0]:c[f*o+b]}return d}var _L=vn(r=>1/(1+Math.exp(-r))),vN=Fe(ts,r=>1/(1+Math.exp(-r))),ML={kernelName:ts,backendName:"cpu",kernelFunc:vN};function Vp(r,e,t,n,o){let s=It.isSliceContinous(n,e,t),a=y.sizeFromShape(t),i=y.computeStrides(n);if(s){let m=It.computeFlatOffset(e,i);return o==="string"?r.slice(m,m+a):r.subarray(m,m+a)}let u=o==="string"?C.fromUint8ToStringArray(r):r,l=Ie(n,o,u),p=Ie(t,o);for(let m=0;m<p.size;++m){let c=p.indexToLoc(m),d=c.map((f,h)=>f+e[h]);p.set(l.get(...d),...c)}return o==="string"?C.fromStringArrayToUint8(p.values):p.values}function ua(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n;ee(o,"slice");let[i,u]=It.parseSliceParams(o,s,a);It.assertParamsValid(o,i,u);let l=t.data.get(o.dataId).values,p=Vp(l,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,p)}var RL={kernelName:_s,backendName:"cpu",kernelFunc:ua};function Nx(r,e,t,n,o,s,a){let i=e[0],u=s[0],l=new Array(u),p=new Array(i),m=e[1];if(u===0){if(i!==0)throw new Error(C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));let g=y.getArrayFromDType(t,0),b=y.getArrayFromDType(o,0);return[g,[0,m],b,l,p]}let c=!0,d=0,f=new Array(u).fill(0);for(let g=0;g<i;++g){let b=r[g*m];if(b<0)throw new Error(C.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,b));if(b>=u)throw new Error(C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,b,u));++f[b],c=c&&b>=d,d=b}let h=!0;for(let g=0;g<u;++g){let b=f[g]===0;l[g]=b,h=h&&!b,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(h&&c){let g=r,b=n;for(let T=0;T<i;++T)p[T]=T;return[g,[i,m],b,l,p]}else{let g=f[u-1],b=y.getArrayFromDType(t,g*m),T=y.getArrayFromDType(o,g),x=new Array(u).fill(0);for(let I=0;I<i;++I){let S=r[I*m],w=x[S],_=(S===0?0:f[S-1])+w;x[S]++;for(let M=0;M<m;++M)b[_*m+M]=r[I*m+M];T[_]=n[I],p[I]=_}for(let I=0;I<u;++I)if(x[I]===0){let w=I===0?0:f[I-1];b[w*m+0]=I;for(let _=1;_<m;++_)b[w*m+_]=0;T[w]=a}return[b,[g,m],T,l,p]}}function Dx(r,e,t,n,o){let s=y.sizeFromShape(n),a=e[0],i=o.length,u=[],l=1,p=-1;for(let g=0;g<i;++g){let b=o[g];if(b===-1){if(p!==-1)throw new Error(C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,g));p=g,u.push(1)}else{if(b<0)throw new Error(C.getSparseReshapeNegativeOutputDimErrorMessage(g,b));l*=b,u.push(b)}}if(p!==-1){if(l<=0)throw new Error(C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(C.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[p]=g}if(y.sizeFromShape(u)!==s)throw new Error(C.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let c=n.length,d=[];if(c>0){d[c-1]=1;for(let g=c-2;g>=0;--g)d[g]=d[g+1]*n[g+1]}let f=[];if(i>0){f[i-1]=1;for(let g=i-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}let h=y.getArrayFromDType(t,a*i);for(let g=0;g<a;++g){let b=0;for(let T=0;T<c;++T)b+=r[g*c+T]*d[T];for(let T=0;T<i;++T)h[g*i+T]=Math.trunc(b/f[T]),b%=f[T]}return[h,[a,i],u]}function df(r,e,t,n,o,s=!1,a=0){let i=n.length,u=[e[0],r.length/e[0]],l=u[1],m=i>0?o[i-1]+1:0;if(m<0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=e.slice();c[0]=m;let d=c.reduce((x,I)=>x*I,1),f=y.getArrayFromDType(t,d);if(i===0)return m>0&&f.fill(a),[f,c];if(m<=0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,b=0,T=o[h];for(;;){let x=0;if(g<i){if(x=o[g],T===x){++g;continue}if(T>=x)throw new Error(C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(T<0||T>=m)throw new Error(C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(T,m));T>b&&f.fill(a,b*l,T*l);for(let I=h;I<g;++I){let S=n[I];if(S<0||S>=u[0])throw new Error(C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,n[I],u[0]));for(let w=0;w<l;w++)f[T*l+w]+=r[S*l+w]}if(s)for(let I=0;I<l;I++)f[T*l+I]/=g-h;if(h=g,++g,b=T+1,T=x,g>i)break}return b<m&&f.fill(a,b*l,m*l),[f,c]}var PL=vn(r=>Math.sqrt(r)),dne=Fe(rs,r=>Math.sqrt(r)),EL={kernelName:rs,backendName:"cpu",kernelFunc:dne};var AN=ot((r,e)=>{let t=r-e;return t*t}),fne=pt(ss,AN),FL={kernelName:ss,backendName:"cpu",kernelFunc:fne};function _x(r,e,t,n){let o=Ie(r,e.dtype);for(let s=0;s<o.size;s++){let a=o.indexToLoc(s),i=new Array(a.length);for(let u=0;u<i.length;u++)i[u]=a[u]*t[u]+n[u];o.set(e.get(...i),...a)}return o}var wN=class{separator;nGramWidths;padWidth;leftPad;rightPad;preserveShort;constructor(e,t,n,o,s,a){this.separator=y.encodeString(e),this.nGramWidths=t,this.leftPad=y.encodeString(n),this.rightPad=y.encodeString(o),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,o,s,a){for(let i=0;i<s;++i){let u=this.getPadWidth(a),l=Math.max(0,u-i),p=Math.max(0,u-(s-(i+1))),m=a-(l+p),c=t+(l>0?0:i-u),d=0;d+=l*this.leftPad.length;for(let T=0;T<m;++T)d+=e[c+T].length;d+=p*this.rightPad.length;let f=l+p+m-1;d+=f*this.separator.length,n[o+i]=new Uint8Array(d);let h=n[o+i],g=0,b=T=>T.forEach(x=>h[g++]=x);for(let T=0;T<l;++T)b(this.leftPad),b(this.separator);for(let T=0;T<m-1;++T)b(e[c+T]),b(this.separator);if(m>0){b(e[c+m-1]);for(let T=0;T<p;++T)b(this.separator),b(this.rightPad)}else{for(let T=0;T<p-1;++T)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){let n=e.length,o=t.length;if(o>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let p=t[l]>=u;if(p=p&&t[l]<=n,!p)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${n}]`);u=t[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,a=y.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)a[l]=0;return[u,a]}a[0]=0;for(let u=1;u<=s;++u){let l=t[u]-t[u-1],p=0;this.nGramWidths.forEach(m=>{p+=this.getNumNGrams(l,m)}),this.preserveShort&&l>0&&p===0&&(p=1),a[u]=a[u-1]+p}let i=new Array(a[s]);for(let u=0;u<s;++u){let l=t[u],p=a[u];if(this.nGramWidths.forEach(m=>{let c=t[u+1]-t[u],d=this.getNumNGrams(c,m);this.createNGrams(e,l,i,p,d,m),p+=d}),this.preserveShort&&p===a[u]){let m=t[u+1]-t[u];if(m===0)continue;let c=m+2*this.padWidth,d=1;this.createNGrams(e,l,i,p,d,c)}}return[i,a]}};function Hp(r,e,t,n,o,s,a,i){return new wN(t,n,o,s,a,i).compute(r,e)}function hne(r,e,t,n){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(e.length===1){let s=e[0],a=r.indexOf(s);for(;a!==-1;){let i=r.subarray(0,a);(!t||i.length!==0)&&n.push(i),r=r.subarray(a+1),a=r.indexOf(s)}(!t||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){let a=r.subarray(o,s);(!t||a.length!==0)&&n.push(a),o=s+1}}function qp(r,e,t){let n=r.length,o=[],s=0,a=0,i=new Array(n);for(let c=0;c<n;++c){let d=o.length;hne(r[c],e,t,o);let f=o.length-d;i[c]=f,s+=f,a=Math.max(a,f)}let u=y.getArrayFromDType("int32",s*2),l=new Array(s),p=[n,a],m=0;for(let c=0;c<n;++c)for(let d=0;d<i[c];++d)u[m*2]=c,u[m*2+1]=d,l[m]=o[m],++m;return[u,l,p]}function jp(r,e){let t=y.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)t[n]=y.fingerPrint64(r[n]).modulo(e).getLowBitsUnsigned();return t}var NN=ot((r,e)=>r-e),gne=lf((r,e,t,n)=>({real:r-t,imag:e-n})),sg=pt(as,NN,gne),LL={kernelName:as,backendName:"cpu",kernelFunc:sg};function Mx(r,e){let t=new Array(r.rank);for(let o=0;o<t.length;o++)t[o]=r.shape[o]*e[o];let n=Ie(t,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),a=new Array(r.rank);for(let u=0;u<a.length;u++)a[u]=s[u]%r.shape[u];let i=r.locToIndex(a);n.values[o]=r.values[i]}return n}var ag=(r,e)=>{let t=e.value-r.value;return t===0?r.index-e.index:t};function $L(r,e,t=0,n=r.length-1){for(;n>t;){if(n-t>600){let i=n-t+1,u=e-t+1,l=Math.log(i),p=.5*Math.exp(2*l/3),m=.5*Math.sqrt(l*p*(i-p)/i)*Math.sign(u-i/2),c=Math.max(t,Math.floor(e-u*p/i+m)),d=Math.min(n,Math.floor(e+(i-u)*p/i+m));$L(r,e,c,d)}let o=r[e],s=t,a=n;for(y.swap(r,t,e),ag(r[n],o)>0&&y.swap(r,t,n);s<a;){for(y.swap(r,s,a),s++,a--;ag(r[s],o)<0;)s=s+1;for(;ag(r[a],o)>0;)a=a-1}ag(r[t],o)===0?y.swap(r,t,a):(a=a+1,y.swap(r,a,n)),a<=e&&(t=a+1),e<=a&&(n=a-1)}}function Rx(r,e,t,n,o){let s=e[e.length-1],[a,i]=[r.length/s,s],u=y.getTypedArrayFromDType(t,a*n),l=y.getTypedArrayFromDType("int32",a*n);for(let m=0;m<a;m++){let c=m*i,d=r.subarray(c,c+i),f=new Array(d.length);d.forEach((T,x)=>f[x]={value:T,index:x}),n<f.length&&($L(f,n),f=f.slice(0,n)),o&&f.sort(ag);let h=m*n,g=u.subarray(h,h+n),b=l.subarray(h,h+n);for(let T=0;T<n;T++)g[T]=f[T].value,b[T]=f[T].index}let p=e.slice();return p[p.length-1]=n,[Ie(p,t,u),Ie(p,"int32",l)]}function Px(r,e,t,n){let o=y.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let f=0;f<o;f++)s[0]*=t[f];s[1]=t[o];for(let f=o+1;f<t.length;f++)s[2]*=t[f];let a={},i=new Int32Array(t[o]),u=new bt(s,n,r),l=[],p=s[0]===1&&s[2]===1;for(let f=0;f<t[o];f++){let h;if(p)h=r[f].toString();else{let g=[];for(let b=0;b<s[0];b++)for(let T=0;T<s[2];T++)g.push(u.get(b,f,T));h=g.join(",")}if(a[h]!==void 0)i[f]=a[h];else{let g=Object.keys(a).length;a[h]=g,i[f]=g,l.push(f)}}let m=s.slice();m[1]=Object.keys(a).length;let c=new bt(m,n);l.forEach((f,h)=>{for(let g=0;g<s[0];g++)for(let b=0;b<s[2];b++)c.set(u.get(g,f,b),g,h,b)});let d=t.slice();return d[o]=m[1],{outputValues:c.values,outputShape:d,indices:i}}var bne="0.0.0";ml("cpu",()=>new af,1);var DN=Fe(vo,r=>r>=0?r:Math.exp(r)-1),BL={kernelName:vo,backendName:"cpu",kernelFunc:DN};function _N(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n;ee([o],"leakyRelu");let a=y.sizeFromShape(o.shape),i=t.data.get(o.dataId).values,u=y.getTypedArrayFromDType("float32",a);for(let l=0;l<i.length;l++)u[l]=i[l]<0?s*i[l]:i[l];return t.makeTensorInfo(o.shape,"float32",u)}var OL={kernelName:Ro,backendName:"cpu",kernelFunc:_N};var yne=ot((r,e)=>r<0?e*r:r);function MN(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e;ee([n,o],"prelu");let s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,[i,u]=yne(n.shape,o.shape,s,a,"float32");return t.makeTensorInfo(u,"float32",i)}var zL={kernelName:Vo,backendName:"cpu",kernelFunc:MN};var RN=Fe(jo,r=>Math.max(0,r)),GL={kernelName:jo,backendName:"cpu",kernelFunc:RN};var PN=Fe(Zo,r=>Math.min(Math.max(0,r),6)),WL={kernelName:Zo,backendName:"cpu",kernelFunc:PN};function Xp(r,e,t,n,o){if(t==="linear")return Jr({inputs:{x:e},backend:r});if(t==="relu")return RN({inputs:{x:e},backend:r});if(t==="elu")return DN({inputs:{x:e},backend:r});if(t==="relu6")return PN({inputs:{x:e},backend:r});if(t==="prelu")return MN({inputs:{x:e,alpha:n},backend:r});if(t==="leakyrelu")return _N({inputs:{x:e},backend:r,attrs:{alpha:o}});if(t==="sigmoid")return vN({inputs:{x:e},backend:r});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function rt(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=y.sizeFromShape(o.shape),i=y.inferFromImplicitShape(s,a),u=y.sizeFromShape(i);y.assert(a===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let l=t.data.get(o.dataId);if(l.complexTensorInfos!=null){let p=l.complexTensorInfos.real,m=l.complexTensorInfos.imag;p.shape=i,m.shape=i}return{dataId:o.dataId,shape:i,dtype:o.dtype}}var UL={kernelName:Ns,backendName:"cpu",kernelFunc:rt};function EN(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;ee([o,s],"matMul");let u=o.shape.length,l=s.shape.length,p=a?o.shape[u-2]:o.shape[u-1],m=i?s.shape[l-1]:s.shape[l-2],c=a?o.shape[u-1]:o.shape[u-2],d=i?s.shape[l-2]:s.shape[l-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(f),b=y.sizeFromShape(h),x=Dr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,d]);y.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,p,c]:[g,c,p],S=i?[b,d,m]:[b,m,d],w=rt({inputs:{x:o},backend:t,attrs:{shape:I}}),_=rt({inputs:{x:s},backend:t,attrs:{shape:S}}),M=a?w.shape[1]:w.shape[2],R=a?w.shape[2]:w.shape[1],E=i?_.shape[1]:_.shape[2],O=Math.max(g,b),G=t.data.get(w.dataId).values,W=t.data.get(_.dataId).values,H=y.computeStrides(w.shape),U=y.computeStrides(_.shape),[V,Y,j]=a?[H[0],1,H[1]]:[H[0],H[1],1],[te,ne,oe]=i?[1,U[1],U[0]]:[U[1],1,U[0]],ae=R*E,se=Ie([O,R,E],w.dtype),ie=se.values,he=t.blockSize;for(let Te=0;Te<O;Te++)for(let ve=0;ve<R;ve+=he)for(let Pe=0;Pe<E;Pe+=he)for(let Le=0;Le<M;Le+=he){let je=Math.min(ve+he,R),J=Math.min(Pe+he,E),gt=Math.min(Le+he,M);for(let kt=ve;kt<je;kt++)for(let Je=Pe;Je<J;Je++){let Rt=0;for(let xt=Le;xt<gt;xt++){let $t=Math.min(Te,g-1)*V,Xt=Math.min(Te,b-1)*oe,On=G[$t+kt*Y+xt*j],dr=W[xt*te+Je*ne+Xt];Rt+=On*dr}ie[Te*ae+(kt*E+Je)]+=Rt}}return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(x,se.dtype,se.values)}var KL={kernelName:go,backendName:"cpu",kernelFunc:EN};function Tne(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n,c,d,f,h=[];c=EN({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:t}),a&&(d=Wi({inputs:{a:c,b:a},backend:t}),h.push(c),c=d),p&&(f=Xp(t,c,p,i,m),h.push(c),c=f);for(let b of h)t.disposeIntermediateTensorInfo(b);return c}var VL={kernelName:Ls,backendName:"cpu",kernelFunc:Tne};var xne=Fe(ya,r=>Math.acos(r)),HL={kernelName:ya,backendName:"cpu",kernelFunc:xne};var Ine=Fe(Ta,r=>Math.acosh(r)),qL={kernelName:Ta,backendName:"cpu",kernelFunc:Ine};function Cne(r){let{inputs:e,backend:t}=r,n=e;ee(e,"addN");let o=n.map(i=>t.data.get(i.dataId).values),s=Ie(n[0].shape,n[0].dtype),a=s.values;for(let i=0;i<n.length;i++){let u=o[i];for(let l=0;l<a.length;l++)a[l]+=u[l]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var jL={kernelName:co,backendName:"cpu",kernelFunc:Cne};function Sne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"all");let i=y.parseAxisParam(s,o.shape),u=i,l=C.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("all",u,p.shape.length);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),p.dtype),h=t.data.get(p.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let S=h[T+I];x=x&&S}f[b]=x}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(m,p.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=rt({inputs:{x:g},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(g),T}return g}var XL={kernelName:xa,backendName:"cpu",kernelFunc:Sne};function kne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"any");let i=y.parseAxisParam(s,o.shape),u=i,l=C.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("any",u,p.shape.length);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),p.dtype),h=t.data.get(p.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let S=h[T+I];x=x||S}f[b]=x}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(m,p.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=rt({inputs:{x:g},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(g),T}return g}var YL={kernelName:Ia,backendName:"cpu",kernelFunc:kne};function vne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;ee(o,"argMax");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=qt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMax",a,u.shape.length);let[p,m]=C.computeOutAndReduceShapes(u.shape,a),c=y.sizeFromShape(p),d=y.makeZerosTypedArray(c,"int32"),f=y.sizeFromShape(m),h=t.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let b=g*f,T=h[b],x=0;for(let I=0;I<f;++I){let S=h[b+I];S>T&&(T=S,x=I)}d[g]=x}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",d)}var ZL={kernelName:fo,backendName:"cpu",kernelFunc:vne};function Ane(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;ee(o,"argMin");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=qt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMin",a,u.shape.length);let[p,m]=C.computeOutAndReduceShapes(u.shape,a),c=y.sizeFromShape(p),d=y.makeZerosTypedArray(c,"int32"),f=y.sizeFromShape(m),h=t.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let b=g*f,T=h[b],x=0;for(let I=0;I<f;++I){let S=h[b+I];S<T&&(T=S,x=I)}d[g]=x}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",d)}var QL={kernelName:vi,backendName:"cpu",kernelFunc:Ane};var wne=Fe(Ca,r=>Math.asin(r)),JL={kernelName:Ca,backendName:"cpu",kernelFunc:wne};var Nne=Fe(Sa,r=>Math.asinh(r)),e$={kernelName:Sa,backendName:"cpu",kernelFunc:Nne};var Dne=Fe(ka,r=>Math.atan(r)),t$={kernelName:ka,backendName:"cpu",kernelFunc:Dne};var _ne=ot((r,e)=>Math.atan2(r,e)),Mne=pt(Aa,_ne),r$={kernelName:Aa,backendName:"cpu",kernelFunc:Mne};var Rne=Fe(va,r=>Math.atanh(r)),n$={kernelName:va,backendName:"cpu",kernelFunc:Rne};function hf(r,e,t,n,o,s){let a=o.strideHeight,i=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,p=o.effectiveFilterHeight,m=o.effectiveFilterWidth,c=o.padInfo.top,d=o.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=Ie(o.outShape,t),g=h.values,b=o.outShape[1]*o.outShape[2]*o.outShape[3],T=o.outShape[2]*o.outShape[3],x=o.outShape[3];for(let I=0;I<o.batchSize;++I){let S=I*b,w=I*n[0];for(let _=0;_<o.inChannels;++_)for(let M=0;M<o.outHeight;++M){let R=M*a-c,E=Math.max(0,R),O=Math.min(o.inHeight,p+R),G=S+M*T;for(let W=0;W<o.outWidth;++W){let H=W*i-d,U=Math.max(0,H),V=Math.min(o.inWidth,m+H),Y=f,j=0,te=0;for(let oe=E;oe<O;oe+=u){let ae=w+oe*n[1];for(let se=U;se<V;se+=l){let ie=ae+se*n[2],he=r[ie+_];s==="max"&&he>Y?Y=he:s==="avg"&&(j+=he,te++)}if(isNaN(Y))break}let ne=G+W*x+_;g[ne]=s==="avg"?j/te:Y}}}return h}function Ex(r,e,t,n,o=!1,s=!1){let a=Ie(n.outShape,"int32"),i=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,p=n.dilationWidth,m=n.effectiveFilterHeight,c=n.effectiveFilterWidth,d=n.padInfo.top,f=n.padInfo.left,h=Ie(e,t,r);for(let g=0;g<n.batchSize;++g)for(let b=0;b<n.inChannels;++b)for(let T=0;T<n.outHeight;++T){let x=T*i-d,I=x;for(;I<0;)I+=l;let S=Math.min(n.inHeight,m+x);for(let w=0;w<n.outWidth;++w){let _=w*u-f,M=_;for(;M<0;)M+=p;let R=Math.min(n.inWidth,c+_),E=Number.NEGATIVE_INFINITY,O=-1;for(let G=I;G<S;G+=l){let W=G-x;for(let H=M;H<R;H+=p){let U=H-_,V=h.get(g,G,H,b);V>E&&(E=V,o?O=s?((g*n.inHeight+G)*n.inWidth+H)*n.inChannels+b:(G*n.inWidth+H)*n.inChannels+b:O=W*c+U)}}a.set(O,g,T,w,b)}}return a}function Fx(r,e,t,n,o,s){let a=o.strideDepth,i=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,p=o.dilationHeight,m=o.dilationWidth,c=o.effectiveFilterDepth,d=o.effectiveFilterHeight,f=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,b=o.padInfo.left,T=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=Ie(o.outShape,t),I=x.values,S=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],w=o.outShape[2]*o.outShape[3]*o.outShape[4],_=o.outShape[3]*o.outShape[4],M=o.outShape[4];for(let R=0;R<o.batchSize;++R){let E=R*S,O=R*n[0];for(let G=0;G<o.inChannels;++G)for(let W=0;W<o.outDepth;++W){let H=W*a-h,U=H;for(;U<0;)U+=l;let V=Math.min(o.inDepth,c+H),Y=E+W*w;for(let j=0;j<o.outHeight;++j){let te=j*i-g,ne=te;for(;ne<0;)ne+=p;let oe=Math.min(o.inHeight,d+te),ae=Y+j*_;for(let se=0;se<o.outWidth;++se){let ie=se*u-b,he=ie;for(;he<0;)he+=m;let Te=Math.min(o.inWidth,f+ie),ve=ae+se*M,Pe=T,Le=0,je=0;for(let gt=U;gt<V;gt+=l){let kt=O+gt*n[1];for(let Je=ne;Je<oe;Je+=p){let Rt=kt+Je*n[2];for(let xt=he;xt<Te;xt+=m){let $t=Rt+xt*n[3],Xt=r[$t+G];if(s==="max"&&Xt>Pe?Pe=Xt:s==="avg"&&(Le+=Xt,je++),isNaN(Pe))break}if(isNaN(Pe))break}if(isNaN(Pe))break}let J=ve+G;I[J]=s==="avg"?Le/je:Pe}}}}return x}function o$(r,e){let t=Ie(e.outShape,"int32"),n=e.strideDepth,o=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,i=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,p=e.effectiveFilterHeight,m=e.effectiveFilterWidth,c=e.padInfo.front,d=e.padInfo.top,f=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let b=0;b<e.outDepth;++b){let T=b*n-c,x=T;for(;x<0;)x+=a;let I=Math.min(e.inDepth,l+T);for(let S=0;S<e.outHeight;++S){let w=S*o-d,_=w;for(;_<0;)_+=i;let M=Math.min(e.inHeight,p+w);for(let R=0;R<e.outWidth;++R){let E=R*s-f,O=E;for(;O<0;)O+=u;let G=Math.min(e.inWidth,m+E),W=Number.NEGATIVE_INFINITY,H=-1;for(let U=x;U<I;U+=a){let V=U-T;for(let Y=_;Y<M;Y+=i){let j=Y-w;for(let te=O;te<G;te+=u){let ne=te-E,oe=r.get(h,U,Y,te,g);oe>=W&&(W=oe,H=V*p*m+j*p+ne)}}}t.set(H,h,b,S,R,g)}}}return t}function Pne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;ee(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u),m;if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))m=Jr({inputs:{x:o},backend:t});else{let c=t.data.get(o.dataId).values,d=y.computeStrides(o.shape),f=hf(c,o.shape,o.dtype,d,p,"avg");m=t.makeTensorInfo(p.outShape,o.dtype,f.values)}return m}var s$={kernelName:ho,backendName:"cpu",kernelFunc:Pne};function Ene(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n;ee(o,"avgPool3d");let p=C.computePool3DInfo(o.shape,s,a,1,i,u,l),m=t.data.get(o.dataId).values,c=Fx(m,o.shape,o.dtype,y.computeStrides(o.shape),p,"avg");return t.makeTensorInfo(c.shape,"float32",c.values)}var a$={kernelName:Bu,backendName:"cpu",kernelFunc:Ene};function Fne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=n;ee([o,s],"avgPool3DGrad");let p=C.computePool3DInfo(s.shape,a,i,1,u,l),m=p.strideDepth,c=p.strideHeight,d=p.strideWidth,f=p.filterDepth,h=p.filterHeight,g=p.filterWidth,b=p.dilationDepth,T=p.dilationHeight,x=p.dilationWidth,I=p.effectiveFilterDepth,S=p.effectiveFilterHeight,w=p.effectiveFilterWidth,_=I-1-p.padInfo.front,M=w-1-p.padInfo.left,R=S-1-p.padInfo.top,E=Ie(s.shape,"float32"),O=1/(f*h*g),G=t.bufferSync(o);for(let W=0;W<p.batchSize;++W)for(let H=0;H<p.inChannels;++H)for(let U=0;U<p.inDepth;++U)for(let V=0;V<p.inHeight;++V)for(let Y=0;Y<p.inWidth;++Y){let j=U-_,te=V-R,ne=Y-M,oe=0;for(let ae=0;ae<I;ae+=b){let se=(j+ae)/m;if(!(se<0||se>=p.outDepth||Math.floor(se)!==se))for(let ie=0;ie<S;ie+=T){let he=(te+ie)/c;if(!(he<0||he>=p.outHeight||Math.floor(he)!==he))for(let Te=0;Te<w;Te+=x){let ve=(ne+Te)/d;if(ve<0||ve>=p.outWidth||Math.floor(ve)!==ve)continue;let Pe=G.get(W,se,he,ve,H);oe+=Pe}}}E.set(oe*O,W,U,V,Y,H)}return t.makeTensorInfo(E.shape,E.dtype,E.values)}var i$={kernelName:wm,backendName:"cpu",kernelFunc:Fne};function Lne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;ee([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=n,p=C.computePool2DInfo(a.shape,i,u,1,l),m=p.strideHeight,c=p.strideWidth,d=p.filterHeight,f=p.filterWidth,h=p.dilationHeight,g=p.dilationWidth,b=p.effectiveFilterHeight,T=p.effectiveFilterWidth,x=T-1-p.padInfo.left,I=b-1-p.padInfo.top,S=Ie(a.shape,"float32"),w=1/(d*f),_=t.data.get(o.dataId).values,M=Ie(o.shape,"float32",_);for(let R=0;R<p.batchSize;++R)for(let E=0;E<p.inChannels;++E)for(let O=0;O<p.inHeight;++O)for(let G=0;G<p.inWidth;++G){let W=O-I,H=G-x,U=0;for(let V=0;V<b;V+=h){let Y=(W+V)/m;if(!(Y<0||Y>=p.outHeight||Math.floor(Y)!==Y))for(let j=0;j<T;j+=g){let te=(H+j)/c;if(te<0||te>=p.outWidth||Math.floor(te)!==te)continue;let ne=M.get(R,Y,te,E);U+=ne}}S.set(U*w,R,O,G,E)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}var u$={kernelName:Am,backendName:"cpu",kernelFunc:Lne};function $ne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,scale:s,offset:a,mean:i,variance:u}=e;y.assert(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ee([o,i,u,s,a],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let p=t.data.get(o.dataId).values,m=t.data.get(i.dataId).values,c=t.data.get(u.dataId).values,d=s?t.data.get(s.dataId).values:new Float32Array([1]),f=a?t.data.get(a.dataId).values:new Float32Array([0]),h=new Float32Array(p.length),g=f.length,b=d.length,T=c.length,x=m.length,I=0,S=0,w=0,_=0;for(let M=0;M<p.length;++M)h[M]=f[I++]+(p[M]-m[S++])*d[w++]/Math.sqrt(c[_++]+l),I>=g&&(I=0),S>=x&&(S=0),w>=b&&(w=0),_>=T&&(_=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var l$={kernelName:Do,backendName:"cpu",kernelFunc:$ne};function Bne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;ee([o],"batchToSpaceND");let i=s.reduce((b,T)=>b*T),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=rt({inputs:{x:o},backend:t,attrs:{shape:u}}),f=qt({inputs:{x:d},backend:t,attrs:{perm:l}}),h=rt({inputs:{x:f},backend:t,attrs:{shape:p}}),g=ua({inputs:{x:h},backend:t,attrs:{begin:m,size:c}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var p$={kernelName:Is,backendName:"cpu",kernelFunc:Bne};function One(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=pf(i,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}var m$={kernelName:Ou,backendName:"cpu",kernelFunc:One};function zne(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,i=C.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var c$={kernelName:Nm,backendName:"cpu",kernelFunc:zne};var Gne=Fe(Kn,(r,e)=>{let t=e;return r>t.clipValueMax?t.clipValueMax:r<t.clipValueMin?t.clipValueMin:r}),d$={kernelName:Kn,backendName:"cpu",kernelFunc:Gne};var Wne=r=>{let{x:e}=r.inputs,t=r.backend,n=new Float32Array(y.sizeFromShape(e.shape)),o=t.data.get(e.dataId),s=o.complexTensorInfos.real,a=o.complexTensorInfos.imag,i=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values;for(let l=0;l<i.length;l++){let p=i[l],m=u[l];n[l]=Math.hypot(p,m)}return t.makeOutput(n,e.shape,"float32")},f$={kernelName:Gu,backendName:"cpu",kernelFunc:Wne};function Ui(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var h$={kernelName:ju,backendName:"cpu",kernelFunc:Ui};function $l(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=e.map(h=>h.shape);C.assertParamsConsistent(a,s);let i=C.computeOutShape(e.map(h=>h.shape),s);if(y.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let u=e.filter(h=>y.sizeFromShape(h.shape)>0);if(u.length===1)return Jr({inputs:{x:u[0]},backend:t});if(u[0].dtype==="complex64"){let h=u.map(I=>oa({inputs:{input:I},backend:t})),g=u.map(I=>Ui({inputs:{input:I},backend:t})),b=$l({inputs:h,backend:t,attrs:{axis:s}}),T=$l({inputs:g,backend:t,attrs:{axis:s}}),x=wr({inputs:{real:b,imag:T},backend:t});return h.forEach(I=>t.disposeIntermediateTensorInfo(I)),g.forEach(I=>t.disposeIntermediateTensorInfo(I)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(T),x}let l=u.map(h=>{let b=[-1,y.sizeFromShape(h.shape.slice(s))];return rt({inputs:{x:h},backend:t,attrs:{shape:b}})}),p=l.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));i=C.computeOutShape(l.map(h=>h.shape),1);let m=l[0].shape[0]===1,c=Wp(p,i,e[0].dtype,m),d=C.computeOutShape(u.map(h=>h.shape),s),f=t.makeTensorInfo(d,e[0].dtype,c);return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),f}var g$={kernelName:Cs,backendName:"cpu",kernelFunc:$l};function FN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n;ee([o,s],"conv2d");let m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,m),d=c.filterHeight,f=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,b=c.padInfo.left,T=c.padInfo.top,x=c.dataFormat==="channelsLast",I=new bt(c.outShape,o.dtype),S=y.computeStrides(o.shape),w=y.computeStrides(s.shape),_=S[0],M=x?S[1]:S[2],R=x?S[2]:1,E=x?1:S[1],O=I.strides[0],G=x?I.strides[1]:I.strides[2],W=x?I.strides[2]:1,H=x?1:I.strides[1],U=t.data.get(o.dataId).values,V=t.data.get(s.dataId).values,Y=I.values;for(let j=0;j<c.batchSize;++j){let te=j*_,ne=j*O;for(let oe=0;oe<c.outHeight;++oe){let ae=ne+oe*G,se=oe*c.strideHeight-T;for(let ie=0;ie<d;++ie){let he=se+ie*h;if(he<0||he>=c.inHeight)continue;let Te=ie*w[0],ve=te+he*M;for(let Pe=0;Pe<c.outWidth;++Pe){let Le=ae+Pe*W,je=Pe*c.strideWidth-b;for(let J=0;J<f;++J){let gt=je+J*g;if(gt<0||gt>=c.inWidth)continue;let kt=Te+J*w[1],Je=ve+gt*R,Rt=kt;for(let xt=0;xt<c.inChannels;++xt){let $t=U[Je+xt*E];for(let Xt=0;Xt<c.outChannels;++Xt)Y[Le+Xt*H]+=$t*V[Rt+Xt];Rt+=c.outChannels}}}}}}return t.makeTensorInfo(I.shape,I.dtype,Y)}var b$={kernelName:yo,backendName:"cpu",kernelFunc:FN};function Une(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:p}=n;ee([o,s],"conv2dBackpropFilter");let m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,p,a,1,i,l,!1,m),{strideHeight:d,strideWidth:f,filterHeight:h,filterWidth:g}=c,b=c.dataFormat==="channelsLast",T=new bt(c.filterShape,"float32"),x=c.padInfo.left,I=c.padInfo.top,S=t.data.get(o.dataId).values,w=t.data.get(s.dataId).values,_=new bt(o.shape,o.dtype,S),M=new bt(s.shape,s.dtype,w);for(let R=0;R<h;++R){let E=Math.max(0,Math.ceil((I-R)/d)),O=Math.min(c.outHeight,(c.inHeight+I-R)/d);for(let G=0;G<g;++G){let W=Math.max(0,Math.ceil((x-G)/f)),H=Math.min(c.outWidth,(c.inWidth+x-G)/f);for(let U=0;U<c.inChannels;++U)for(let V=0;V<c.outChannels;++V){let Y=0;for(let j=0;j<c.batchSize;++j)for(let te=E;te<O;++te){let ne=R+te*d-I;for(let oe=W;oe<H;++oe){let ae=G+oe*f-x;b?Y+=_.get(j,ne,ae,U)*M.get(j,te,oe,V):Y+=_.get(j,U,ne,ae)*M.get(j,V,te,oe)}}T.set(Y,R,G,U,V)}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}var y$={kernelName:Dm,backendName:"cpu",kernelFunc:Une};function Kne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n;ee([o,s],"conv2dBackpropInput");let m=y.computeStrides(s.shape),c=y.computeStrides(o.shape),d=C.convertConv2DDataFormat(l),f=C.computeConv2DInfo(a,s.shape,i,1,u,p,!1,d),h=new bt(f.inShape,"float32"),g=h.values,b=t.data.get(o.dataId).values,T=t.data.get(s.dataId).values,[x,I,S]=m,{batchSize:w,filterHeight:_,filterWidth:M,inChannels:R,inHeight:E,inWidth:O,outChannels:G,outHeight:W,outWidth:H,strideHeight:U,strideWidth:V}=f;d=f.dataFormat;let Y=_-1-f.padInfo.top,j=M-1-f.padInfo.left,te=d==="channelsLast",ne=h.strides[0],oe=te?h.strides[1]:h.strides[2],ae=te?h.strides[2]:1,se=te?1:h.strides[1],ie=c[0],he=te?c[1]:c[2],Te=te?c[2]:1,ve=te?1:c[1];for(let Pe=0;Pe<w;++Pe)for(let Le=0;Le<R;++Le)for(let je=0;je<E;++je){let J=je-Y,gt=Math.max(0,Math.ceil(J/U)),kt=Math.min(W,(_+J)/U);for(let Je=0;Je<O;++Je){let Rt=Je-j,xt=Math.max(0,Math.ceil(Rt/V)),$t=Math.min(H,(M+Rt)/V),Xt=0;for(let dr=gt;dr<kt;++dr){let so=dr*U-J;for(let Wr=xt;Wr<$t;++Wr){let rr=Wr*V-Rt,Ur=ie*Pe+he*dr+Te*Wr,Kr=x*(_-1-so)+I*(M-1-rr)+S*Le;for(let ao=0;ao<G;++ao){let io=b[Ur+ve*ao],tn=T[Kr+ao];Xt+=io*tn}}}let On=ne*Pe+oe*je+ae*Je+se*Le;g[On]=Xt}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var T$={kernelName:To,backendName:"cpu",kernelFunc:Kne};function Vne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n;ee([o,s],"conv3d");let l=C.computeConv3DInfo(o.shape,s.shape,a,u,i),{filterDepth:p,filterHeight:m,filterWidth:c,dilationDepth:d,dilationHeight:f,dilationWidth:h,padInfo:g}=l,b=g.front,T=g.left,x=g.top,I=new bt(l.outShape,o.dtype),S=t.data.get(o.dataId).values,w=t.data.get(s.dataId).values,_=I.values,M=y.computeStrides(o.shape),R=y.computeStrides(s.shape);for(let E=0;E<l.batchSize;++E){let O=E*M[0],G=E*I.strides[0];for(let W=0;W<l.outDepth;++W){let H=G+W*I.strides[1],U=W*l.strideDepth-b;for(let V=0;V<p;++V){let Y=U+V*d;if(Y<0||Y>=l.inDepth)continue;let j=V*R[0],te=O+Y*M[1];for(let ne=0;ne<l.outHeight;++ne){let oe=H+ne*I.strides[2],ae=ne*l.strideHeight-x;for(let se=0;se<m;++se){let ie=ae+se*f;if(ie<0||ie>=l.inHeight)continue;let he=j+se*R[1],Te=te+ie*M[2];for(let ve=0;ve<l.outWidth;++ve){let Pe=oe+ve*l.outChannels,Le=ve*l.strideWidth-T;for(let je=0;je<c;++je){let J=Le+je*h;if(J<0||J>=l.inWidth)continue;let gt=he+je*R[2],kt=Te+J*l.inChannels,Je=gt;for(let Rt=0;Rt<l.inChannels;++Rt){let xt=S[kt+Rt];for(let $t=0;$t<l.outChannels;++$t)_[Pe+$t]+=xt*w[Je+$t];Je+=l.outChannels}}}}}}}}return t.makeTensorInfo(I.shape,I.dtype,I.values)}var x$={kernelName:Wu,backendName:"cpu",kernelFunc:Vne};function Hne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:u}=n;ee([o,s],"conv3dBackpropFilterV2");let l=y.computeStrides(o.shape),p=y.computeStrides(s.shape),m=C.computeConv3DInfo(o.shape,u,a,1,i),c=m.strideDepth,d=m.strideHeight,f=m.strideWidth,h=m.filterDepth,g=m.filterHeight,b=m.filterWidth,T=new bt(m.filterShape,"float32"),x=T.values,[I,S,w,_]=T.strides,M=t.data.get(s.dataId).values,[R,E,O,G]=p,W=t.data.get(o.dataId).values,[H,U,V,Y]=l,j=m.padInfo.front,te=m.padInfo.left,ne=m.padInfo.top;for(let oe=0;oe<h;++oe){let ae=Math.max(0,Math.ceil((j-oe)/c)),se=Math.min(m.outDepth,(m.inDepth+j-oe)/c),ie=oe*I;for(let he=0;he<g;++he){let Te=Math.max(0,Math.ceil((ne-he)/d)),ve=Math.min(m.outHeight,(m.inHeight+ne-he)/d),Pe=he*S+ie;for(let Le=0;Le<b;++Le){let je=Math.max(0,Math.ceil((te-Le)/f)),J=Math.min(m.outWidth,(m.inWidth+te-Le)/f),gt=Le*w+Pe;for(let kt=0;kt<m.inChannels;++kt){let Je=kt*_+gt;for(let Rt=0;Rt<m.outChannels;++Rt){let xt=0;for(let $t=0;$t<m.batchSize;++$t){let Xt=$t*H,On=$t*R;for(let dr=ae;dr<se;++dr){let Wr=(oe+dr*c-j)*U+Xt,rr=dr*E+On;for(let Ur=Te;Ur<ve;++Ur){let ao=(he+Ur*d-ne)*V+Wr,io=Ur*O+rr;for(let tn=je;tn<J;++tn){let fa=(Le+tn*f-te)*Y+ao,Eu=tn*G+io;xt+=W[fa+kt]*M[Eu+Rt]}}}}x[Je+Rt]=xt}}}}}return t.makeTensorInfo(T.shape,T.dtype,T.values)}var I$={kernelName:_m,backendName:"cpu",kernelFunc:Hne};function qne(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:u}=n;ee([o],"conv3dBackpropInputV2");let l=y.computeStrides(o.shape),p=y.computeStrides(s.shape),m=C.computeConv3DInfo(u,s.shape,i,1,a),c=new bt(m.inShape,"float32"),d=c.values,[f,h,g,b]=c.strides,T=t.data.get(o.dataId).values,[x,I,S,w]=l,_=t.data.get(s.dataId).values,[M,R,E,O]=p,{batchSize:G,filterDepth:W,filterHeight:H,filterWidth:U,inChannels:V,inDepth:Y,inHeight:j,inWidth:te,outChannels:ne,outDepth:oe,outHeight:ae,outWidth:se,strideDepth:ie,strideHeight:he,strideWidth:Te}=m,ve=W-1-m.padInfo.front,Pe=H-1-m.padInfo.top,Le=U-1-m.padInfo.left;for(let je=0;je<G;++je)for(let J=0;J<V;++J)for(let gt=0;gt<Y;++gt){let kt=gt-ve,Je=Math.max(0,Math.ceil(kt/ie)),Rt=Math.min(oe,(W+kt)/ie);for(let xt=0;xt<j;++xt){let $t=xt-Pe,Xt=Math.max(0,Math.ceil($t/he)),On=Math.min(ae,(H+$t)/he);for(let dr=0;dr<te;++dr){let so=dr-Le,Wr=Math.max(0,Math.ceil(so/Te)),rr=Math.min(se,(U+so)/Te),Ur=0;for(let Kr=Je;Kr<Rt;++Kr){let ao=Kr*ie-kt;for(let io=Xt;io<On;++io){let tn=io*he-$t;for(let qi=Wr;qi<rr;++qi){let fa=qi*Te-so,Eu=x*je+I*Kr+S*io+w*qi,Lr=M*(W-1-ao)+R*(H-1-tn)+E*(U-1-fa)+O*J;for(let ji=0;ji<ne;++ji){let Yf=T[Eu+ji],Zf=_[Lr+ji];Ur+=Yf*Zf}}}}d[f*je+h*gt+g*xt+b*dr+J]=Ur}}}return t.makeTensorInfo(c.shape,c.dtype,c.values)}var C$={kernelName:Mm,backendName:"cpu",kernelFunc:qne};var jne=Fe(xo,r=>Math.cos(r)),S$={kernelName:xo,backendName:"cpu",kernelFunc:jne};var Xne=Fe(Io,r=>Math.cosh(r)),k$={kernelName:Io,backendName:"cpu",kernelFunc:Xne};function Yne(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,[p,m,c,d]=o.shape,f=s.shape[0],[h,g]=i,b=Ie([f,h,g,d],"float32"),T=t.data.get(s.dataId).values,x=t.data.get(a.dataId).values,I=t.data.get(o.dataId).values,S=y.computeStrides(o.shape),w=y.computeStrides(b.shape);for(let _=0;_<f;_++){let M=_*4,R=T[M],E=T[M+1],O=T[M+2],G=T[M+3],W=x[_];if(W>=p)continue;let H=h>1?(O-R)*(m-1)/(h-1):0,U=g>1?(G-E)*(c-1)/(g-1):0;for(let V=0;V<h;V++){let Y=h>1?R*(m-1)+V*H:.5*(R+O)*(m-1);if(Y<0||Y>m-1){for(let j=0;j<g;j++)for(let te=0;te<d;te++){let ne=te+j*w[2]+V*w[1]+_*w[0];b.values[ne]=l}continue}if(u==="bilinear"){let j=Math.floor(Y),te=Math.ceil(Y),ne=Y-j;for(let oe=0;oe<g;oe++){let ae=g>1?E*(c-1)+oe*U:.5*(E+G)*(c-1);if(ae<0||ae>c-1){for(let Te=0;Te<d;Te++){let ve=Te+oe*w[2]+V*w[1]+_*w[0];b.values[ve]=l}continue}let se=Math.floor(ae),ie=Math.ceil(ae),he=ae-se;for(let Te=0;Te<d;Te++){let ve=Te+se*S[2]+j*S[1]+W*S[0],Pe=I[ve];ve=Te+ie*S[2]+j*S[1]+W*S[0];let Le=I[ve];ve=Te+se*S[2]+te*S[1]+W*S[0];let je=I[ve];ve=Te+ie*S[2]+te*S[1]+W*S[0];let J=I[ve],gt=Pe+(Le-Pe)*he,kt=je+(J-je)*he;ve=Te+oe*w[2]+V*w[1]+_*w[0],b.values[ve]=gt+(kt-gt)*ne}}}else for(let j=0;j<g;++j){let te=g>1?E*(c-1)+j*U:.5*(E+G)*(c-1);if(te<0||te>c-1){for(let ae=0;ae<d;ae++){let se=ae+j*w[2]+V*w[1]+_*w[0];b.values[se]=l}continue}let ne=Math.round(te),oe=Math.round(Y);for(let ae=0;ae<d;ae++){let se=ae+ne*S[2]+oe*S[1]+W*S[0],ie=ae+j*w[2]+V*w[1]+_*w[0];b.values[ie]=I[se]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}var v$={kernelName:Na,backendName:"cpu",kernelFunc:Yne};function Zne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;ee(o,"cumprod");let u=C.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=qt({inputs:{x:o},backend:t,attrs:{perm:u}}));let p=C.getInnerMostAxes(1,o.shape.length)[0];if(p!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${p}`);let m=Pt(l.dtype,"int32"),c=y.makeOnesTypedArray(y.sizeFromShape(l.shape),m),d=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],h=i?(b,T)=>b+f-T-1:(b,T)=>b+T;for(let b=0;b<d.length;b+=f)for(let T=0;T<f;T++){let x=h(b,T);if(T===0)c[x]=a?1:d[x];else{let I=h(b,T-1);c[x]=a?d[I]*c[I]:d[x]*c[I]}}let g=t.makeTensorInfo(l.shape,m,c);if(u!=null){let b=C.getUndoAxesPermutation(u),T=qt({inputs:{x:g},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),T}return g}var A$={kernelName:wa,backendName:"cpu",kernelFunc:Zne};function Qne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;ee(o,"cumsum");let u=C.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=qt({inputs:{x:o},backend:t,attrs:{perm:u}}));let p=C.getInnerMostAxes(1,o.shape.length)[0];if(p!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${p}`);let m=Pt(l.dtype,"int32"),c=y.makeZerosTypedArray(y.sizeFromShape(l.shape),m),d=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],h=i?(b,T)=>b+f-T-1:(b,T)=>b+T;for(let b=0;b<d.length;b+=f)for(let T=0;T<f;T++){let x=h(b,T);if(T===0)c[x]=a?0:d[x];else{let I=h(b,T-1);c[x]=a?d[I]+c[I]:d[x]+c[I]}}let g=t.makeTensorInfo(l.shape,m,c);if(u!=null){let b=C.getUndoAxesPermutation(u),T=qt({inputs:{x:g},backend:t,attrs:{perm:b}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),T}return g}var w$={kernelName:Co,backendName:"cpu",kernelFunc:Qne};function Jne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=pf(u,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=xx(u,l,a,i);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var N$={kernelName:Uu,backendName:"cpu",kernelFunc:Jne};function eoe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n;y.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);let i=o.shape[0],u=o.shape[1],l=o.shape[2],p=o.shape[3],m=u*s,c=l*s,d=p/(s*s),f=t.data.get(o.dataId).values,h=new Float32Array(i*m*c*d),g=0;for(let b=0;b<i;++b)for(let T=0;T<m;++T){let x=Math.floor(T/s),I=T%s;for(let S=0;S<c;++S){let w=Math.floor(S/s),_=S%s,M=(I*s+_)*d;for(let R=0;R<d;++R){let O=R+M+p*(w+l*(x+u*b));h[g++]=f[O]}}}return t.makeTensorInfo([i,m,c,d],o.dtype,h)}var D$={kernelName:Da,backendName:"cpu",kernelFunc:eoe};function LN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:l}=n;ee([o,s],"depthwiseConv2DNative");let p=y.computeStrides(o.shape),m=y.computeStrides(s.shape),c=u;c==null&&(c=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let d=C.computeConv2DInfo(o.shape,s.shape,a,c,i,l,!0),{filterHeight:f,filterWidth:h,dilationHeight:g,dilationWidth:b,padInfo:T}=d,x=T.left,I=T.top,S=d.outChannels/d.inChannels,w=new bt(d.outShape,o.dtype),_=t.data.get(o.dataId).values,M=t.data.get(s.dataId).values,R=w.values;for(let E=0;E<d.batchSize;++E){let O=E*p[0],G=E*w.strides[0];for(let W=0;W<d.outHeight;++W){let H=G+W*w.strides[1],U=W*d.strideHeight-I;for(let V=0;V<f;++V){let Y=U+V*g;if(Y<0||Y>=d.inHeight)continue;let j=V*m[0],te=O+Y*p[1];for(let ne=0;ne<d.outWidth;++ne){let oe=H+ne*w.strides[2],ae=ne*d.strideWidth-x;for(let se=0;se<h;++se){let ie=ae+se*b;if(ie<0||ie>=d.inWidth)continue;let he=j+se*m[1],Te=te+ie*d.inChannels,ve=oe,Pe=he;for(let Le=0;Le<d.inChannels;++Le){let je=_[Te+Le];for(let J=0;J<S;++J)R[ve+J]+=je*M[Pe+J];ve+=S,Pe+=S}}}}}}return t.makeTensorInfo(w.shape,w.dtype,w.values)}var _$={kernelName:So,backendName:"cpu",kernelFunc:LN};function toe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,filterShape:p}=n;ee([o,s],"depthwiseConv2dNativeBackpropFilter");let m=C.computeConv2DInfo(o.shape,p,a,i,u,l,!0),{strideHeight:c,strideWidth:d,filterHeight:f,filterWidth:h}=m,g=new bt(m.filterShape,"float32"),b=m.padInfo.left,T=m.padInfo.top,x=m.outChannels/m.inChannels,I=t.data.get(o.dataId).values,S=new bt(o.shape,o.dtype,I),w=t.data.get(s.dataId).values,_=new bt(s.shape,s.dtype,w);for(let M=0;M<f;++M){let R=Math.max(0,Math.ceil((T-M)/c)),E=Math.min(m.outHeight,(m.inHeight+T-M)/c);for(let O=0;O<h;++O){let G=Math.max(0,Math.ceil((b-O)/d)),W=Math.min(m.outWidth,(m.inWidth+b-O)/d);for(let H=0;H<m.outChannels;++H){let U=Math.trunc(H/x),V=H%x,Y=0;for(let j=0;j<m.batchSize;++j)for(let te=R;te<E;++te){let ne=M+te*c-T;for(let oe=G;oe<W;++oe){let ae=O+oe*d-b;Y+=S.get(j,ne,ae,U)*_.get(j,te,oe,H)}}g.set(Y,M,O,U,V)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var M$={kernelName:Rm,backendName:"cpu",kernelFunc:toe};function roe(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,inputShape:p}=n;ee([o,s],"depthwiseConv2DNativeBackpropInput");let m=y.computeStrides(o.shape),c=y.computeStrides(s.shape),d=C.computeConv2DInfo(p,s.shape,a,i,u,l,!0),f=new bt(d.inShape,"float32"),h=f.values,[g,b,T]=f.strides,x=t.data.get(o.dataId).values,[I,S,w]=m,_=t.data.get(s.dataId).values,[M,R,E]=c,{batchSize:O,filterHeight:G,filterWidth:W,inChannels:H,inHeight:U,inWidth:V,outChannels:Y,outHeight:j,outWidth:te,strideHeight:ne,strideWidth:oe}=d,ae=G-1-d.padInfo.top,se=W-1-d.padInfo.left,ie=Y/H;for(let he=0;he<O;++he)for(let Te=0;Te<H;++Te)for(let ve=0;ve<U;++ve){let Pe=ve-ae,Le=Math.max(0,Math.ceil(Pe/ne)),je=Math.min(j,(G+Pe)/ne);for(let J=0;J<V;++J){let gt=J-se,kt=Math.max(0,Math.ceil(gt/oe)),Je=Math.min(te,(W+gt)/oe),Rt=0;for(let xt=Le;xt<je;++xt){let $t=xt*ne-Pe;for(let Xt=kt;Xt<Je;++Xt){let On=Xt*oe-gt,dr=I*he+S*xt+w*Xt,so=M*(G-1-$t)+R*(W-1-On)+E*Te;for(let Wr=0;Wr<ie;++Wr){let rr=Te*ie+Wr,Ur=x[dr+rr],Kr=_[so+Wr];Rt+=Ur*Kr}}}h[g*he+b*ve+T*J+Te]=Rt}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}var R$={kernelName:Pm,backendName:"cpu",kernelFunc:roe};function noe(r){let{inputs:e,backend:t}=r,{x:n}=e,o=y.sizeFromShape(n.shape),s=t.data.get(n.dataId).values,a=Ie([o,o],n.dtype),i=a.values;for(let l=0;l<s.length;l++)i[l*o+l]=s[l];let u=[...n.shape,...n.shape];return t.makeTensorInfo(u,a.dtype,a.values)}var P$={kernelName:Em,backendName:"cpu",kernelFunc:noe};var E$={kernelName:Ku,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o}=r,{strides:s,pad:a,dilations:i}=t,u=e,l=u.data.get(n.dataId).values,p=n.shape.length,m=u.data.get(o.dataId).values,c=o.shape.length,{batchSize:d,inHeight:f,inWidth:h,inChannels:g,outHeight:b,outWidth:T,padInfo:x,strideHeight:I,strideWidth:S,filterHeight:w,filterWidth:_,dilationHeight:M,dilationWidth:R,outShape:E}=C.computeDilation2DInfo(n.shape,o.shape,s,a,"NHWC",i),O=y.sizeFromShape(E),G=E.length,W=y.getArrayFromDType(n.dtype,O);for(let U=0;U<d;++U)for(let V=0;V<b;++V){let Y=V*I-x.top;for(let j=0;j<T;++j){let te=j*S-x.left;for(let ne=0;ne<g;++ne){let oe=Number.MIN_SAFE_INTEGER;for(let se=0;se<w;++se){let ie=Y+se*M;if(ie>=0&&ie<f)for(let he=0;he<_;++he){let Te=te+he*R;if(Te>=0&&Te<h){let ve=y.locToIndex([U,ie,Te,ne],p,y.computeStrides(n.shape)),Pe=y.locToIndex([se,he,ne],c,y.computeStrides(o.shape)),Le=l[ve]+m[Pe];Le>oe&&(oe=Le)}}}let ae=y.locToIndex([U,V,j,ne],G,y.computeStrides(E));W[ae]=oe}}}return{dataId:u.write(y.toTypedArray(W,n.dtype),E,n.dtype),shape:E,dtype:n.dtype}}};var F$={kernelName:lh,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=t,l=e,p=y.toNestedArray(n.shape,l.data.get(n.dataId).values),m=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:c,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:b,padInfo:T,strideHeight:x,strideWidth:I,filterHeight:S,filterWidth:w,dilationHeight:_,dilationWidth:M,outShape:R}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);y.assert(s.rank===R.length,()=>`Error in ${lh}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let E=y.toNestedArray(R,l.data.get(s.dataId).values),O=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let W=0;W<c;++W)for(let H=0;H<g;++H){let U=H*x-T.top;for(let V=0;V<b;++V){let Y=V*I-T.left;for(let j=0;j<h;++j){let te=Number.MIN_SAFE_INTEGER,ne=0,oe=0;for(let ae=0;ae<S;++ae){let se=U+ae*_;if(se>=0&&se<d)for(let ie=0;ie<w;++ie){let he=Y+ie*M;if(he>=0&&he<f){let Te=p[W][se][he][j]+m[ae][ie][j];Te>te&&(te=Te,ne=ae,oe=ie)}}}O[ne][oe][j]+=E[W][H][V][j]}}}return{dataId:l.write(y.toTypedArray(O,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var L$={kernelName:uh,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=t,l=e,p=y.toNestedArray(n.shape,l.data.get(n.dataId).values),m=y.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:c,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:b,padInfo:T,strideHeight:x,strideWidth:I,filterHeight:S,filterWidth:w,dilationHeight:_,dilationWidth:M,outShape:R}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);y.assert(s.rank===R.length,()=>`Error in ${uh}, dy must have the same rank as output ${R.length}, but got ${s.rank}`);let E=y.toNestedArray(R,l.data.get(s.dataId).values),O=y.makeZerosNestedTypedArray(n.shape,n.dtype);for(let W=0;W<c;++W)for(let H=0;H<g;++H){let U=H*x-T.top;for(let V=0;V<b;++V){let Y=V*I-T.left;for(let j=0;j<h;++j){let te=Number.MIN_SAFE_INTEGER,ne=U<0?0:U,oe=Y<0?0:Y;for(let ae=0;ae<S;++ae){let se=U+ae*_;if(se>=0&&se<d)for(let ie=0;ie<w;++ie){let he=Y+ie*M;if(he>=0&&he<f){let Te=p[W][se][he][j]+m[ae][ie][j];Te>te&&(te=Te,ne=se,oe=he)}}}O[W][ne][oe][j]+=E[W][H][V][j]}}}return{dataId:l.write(y.toTypedArray(O,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function vu(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"sum");let i;o.dtype==="bool"?i=sa({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):i=Jr({inputs:{x:o},backend:t});let u=i.shape.length,l=y.parseAxisParam(s,i.shape),p=C.getAxesPermutation(l,u),m=l,c=i;p!=null&&(c=qt({inputs:{x:i},backend:t,attrs:{perm:p}}),m=C.getInnerMostAxes(m.length,u)),C.assertAxesAreInnerMostDims("sum",m,c.shape.length);let[d,f]=C.computeOutAndReduceShapes(c.shape,m),h=C.upcastType(c.dtype,"int32"),g=uf(t,d,h),b=y.sizeFromShape(f),T=t.data.get(g.dataId).values,x=t.data.get(c.dataId).values;for(let I=0;I<T.length;++I){let S=I*b,w=0;for(let _=0;_<b;++_)w+=x[S+_];T[I]=w}if(a){let I=C.expandShapeToKeepDim(g.shape,l),S=g;g=rt({inputs:{x:g},backend:t,attrs:{shape:I}}),t.disposeIntermediateTensorInfo(S)}return t.disposeIntermediateTensorInfo(i),p!=null&&t.disposeIntermediateTensorInfo(c),g}var $$={kernelName:ns,backendName:"cpu",kernelFunc:vu};function ooe(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=C.getEinsumComputePath(i,u),m=p.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of p[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=qt({inputs:{x:s[g]},backend:t,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let S=0;S<T.length;++S)I.splice(T[S],0,1);y.arraysEqual(x.shape,I)||(x=rt({inputs:{x},backend:t,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=Up({inputs:{a:x,b:c},backend:t}),f.push(c))}h<m-1&&(l[h]>=0&&(c=vu({inputs:{x:c},backend:t,attrs:{axis:l[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&t.disposeIntermediateTensorInfo(h);return c}var B$={kernelName:Vu,backendName:"cpu",kernelFunc:ooe};function soe(r){let{inputs:e,backend:t}=r,{dy:n,y:o}=e;ee([n,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),a=t.data.get(o.dataId).values,i=t.data.get(n.dataId).values;for(let u=0;u<a.length;++u){let l=a[u];l>=1?s[u]=i[u]:s[u]=i[u]*(l+1)}return t.makeTensorInfo(o.shape,"float32",s)}var O$={kernelName:Fm,backendName:"cpu",kernelFunc:soe};var aoe=C.ERF_P,ioe=C.ERF_A1,uoe=C.ERF_A2,loe=C.ERF_A3,poe=C.ERF_A4,moe=C.ERF_A5,coe=Fe(_a,r=>{let e=Math.sign(r),t=Math.abs(r),n=1/(1+aoe*t);return e*(1-((((moe*n+poe)*n+loe)*n+uoe)*n+ioe)*n*Math.exp(-t*t))}),z$={kernelName:_a,backendName:"cpu",kernelFunc:coe};function gf(r){let{inputs:e,backend:t,attrs:n}=r,{input:o}=e,{dim:s}=n,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),rt({inputs:{x:o},backend:t,attrs:{shape:i}})}var G$={kernelName:Ss,backendName:"cpu",kernelFunc:gf};var doe=ot((r,e)=>r/e),ig=pt(ko,doe),ug={kernelName:ko,backendName:"cpu",kernelFunc:ig};function Lx(r,e,t){let n=r.shape,o=n[0],s=n[1],a=t.data.get(r.dataId),i=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,l=[o,s],p=y.sizeFromShape(l),m=y.getTypedArrayFromDType("float32",p),c=y.getTypedArrayFromDType("float32",p);for(let g=0;g<o;g++){let b=ua({inputs:{x:i},backend:t,attrs:{begin:[g,0],size:[1,s]}}),T=ua({inputs:{x:u},backend:t,attrs:{begin:[g,0],size:[1,s]}}),x=wr({inputs:{real:b,imag:T},backend:t}),{real:I,imag:S}=foe(x,e,t),w=C.mergeRealAndImagArrays(I,S);for(let _=0;_<s;_++){let M=C.getComplexWithIndex(w,_);m[g*s+_]=M.real,c[g*s+_]=M.imag}t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(T),t.disposeIntermediateTensorInfo(x)}let d=t.makeTensorInfo(l,"float32",m),f=t.makeTensorInfo(l,"float32",c),h=wr({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),h}function foe(r,e,t){let n=y.sizeFromShape(r.shape),o=t.data.get(r.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,a=t.data.get(o.complexTensorInfos.imag.dataId).values;if(hoe(n)){let i=$N(s,a,n,e,t),u=[r.shape[0],r.shape[1]];if(e){let l=t.makeTensorInfo(u,"float32",i.real),p=t.makeTensorInfo(u,"float32",i.imag),m=t.makeTensorInfo([],"float32",y.createScalarValue(n,"float32")),c=Jr({inputs:{x:m},backend:t}),d=ug.kernelFunc({inputs:{a:l,b:m},backend:t}),f=ug.kernelFunc({inputs:{a:p,b:c},backend:t}),h=t.data.get(d.dataId).values,g=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),{real:h,imag:g}}return i}else{let i=C.mergeRealAndImagArrays(s,a),u=goe(i,n,e);return C.splitRealAndImagArrays(u)}}function hoe(r){return(r&r-1)===0}function $N(r,e,t,n,o){if(t===1)return{real:r,imag:e};let s=C.mergeRealAndImagArrays(r,e),a=t/2,i=C.complexWithEvenIndex(s),u=i.real,l=i.imag,p=[u.length],m=o.makeTensorInfo(p,"float32",u),c=o.makeTensorInfo(p,"float32",l),d=wr({inputs:{real:m,imag:c},backend:o}),f=C.complexWithOddIndex(s),h=f.real,g=f.imag,b=[h.length],T=o.makeTensorInfo(b,"float32",h),x=o.makeTensorInfo(b,"float32",g),I=wr({inputs:{real:T,imag:x},backend:o}),S=$N(u,l,a,n,o),w=S.real,_=S.imag,M=[w.length],R=o.makeTensorInfo(M,"float32",w),E=o.makeTensorInfo(M,"float32",_),O=wr({inputs:{real:R,imag:E},backend:o}),G=$N(h,g,a,n,o),W=G.real,H=G.imag,U=[W.length],V=o.makeTensorInfo(U,"float32",W),Y=o.makeTensorInfo(U,"float32",H),j=wr({inputs:{real:V,imag:Y},backend:o}),te=C.exponents(t,n),ne=[te.real.length],oe=o.makeTensorInfo(ne,"float32",te.real),ae=o.makeTensorInfo(ne,"float32",te.imag),se=wr({inputs:{real:oe,imag:ae},backend:o}),ie=Up({inputs:{a:se,b:j},backend:o}),he=Wi({inputs:{a:O,b:ie},backend:o}),Te=sg({inputs:{a:O,b:ie},backend:o}),ve=oa({inputs:{input:he},backend:o}),Pe=oa({inputs:{input:Te},backend:o}),Le=Ui({inputs:{input:he},backend:o}),je=Ui({inputs:{input:Te},backend:o}),J=$l({inputs:[ve,Pe],backend:o,attrs:{axis:0}}),gt=$l({inputs:[Le,je],backend:o,attrs:{axis:0}}),kt=o.data.get(J.dataId).values,Je=o.data.get(gt.dataId).values;return o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(R),o.disposeIntermediateTensorInfo(E),o.disposeIntermediateTensorInfo(O),o.disposeIntermediateTensorInfo(V),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(j),o.disposeIntermediateTensorInfo(oe),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(se),o.disposeIntermediateTensorInfo(ie),o.disposeIntermediateTensorInfo(he),o.disposeIntermediateTensorInfo(Te),o.disposeIntermediateTensorInfo(ve),o.disposeIntermediateTensorInfo(Le),o.disposeIntermediateTensorInfo(Pe),o.disposeIntermediateTensorInfo(je),o.disposeIntermediateTensorInfo(J),o.disposeIntermediateTensorInfo(gt),{real:kt,imag:Je}}function goe(r,e,t){let n=new Float32Array(e*2);for(let o=0;o<e;o++){let s=0,a=0;for(let i=0;i<e;i++){let u=C.exponent(o*i,e,t),l=C.getComplexWithIndex(r,i);s+=l.real*u.real-l.imag*u.imag,a+=l.real*u.imag+l.imag*u.real}t&&(s/=e,a/=e),C.assignToTypedArray(n,s,a,o)}return n}function boe(r){let{inputs:e,backend:t}=r,{input:n}=e,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=rt({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),u=Lx(i,!1,t),l=rt({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var W$={kernelName:Hu,backendName:"cpu",kernelFunc:boe};function lg(r){let{backend:e,attrs:t}=r,{shape:n,value:o,dtype:s}=t,a=s||y.inferDtype(o),i=y.getArrayFromDType(a,y.sizeFromShape(n));return yoe(i,o,a),e.makeTensorInfo(n,a,i)}var U$={kernelName:Ai,backendName:"cpu",kernelFunc:lg};function yoe(r,e,t){r.fill(e)}var K$={kernelName:Pa,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,o=t,s=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[a,i,u,l]=n.shape,p=o.data.get(n.dataId).values;for(let c=0;c<a;c++){let d=c*u*i*l;for(let f=0;f<i;f++){let h=f*(u*l);for(let g=0;g<u;g++){let b=g*l;for(let T=0;T<l;T++){let x=Math.round(u-g-1),I=d+h+b+T,S=p[I];if(x>=0&&x<u){let w=x*l,_=d+h+w+T;S=p[_]}s[I]=S}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Toe=ot((r,e)=>Math.floor(r/e)),xoe=pt(No,Toe,null,"int32"),V$={kernelName:No,backendName:"cpu",kernelFunc:xoe};function Ioe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=FN({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c}});if(a){let g=h;if(p==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){let b=rt({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});h=Wi({inputs:{a:h,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else h=Wi({inputs:{a:h,b:a},backend:t});t.disposeIntermediateTensorInfo(g)}if(d){let g=h;if(p==="NCHW"&&d==="prelu"&&i.shape.length===1&&i.shape[0]!==1){let b=rt({inputs:{x:i},backend:t,attrs:{shape:[i.shape[0],1,1]}});h=Xp(t,h,d,b,f),t.disposeIntermediateTensorInfo(b)}else h=Xp(t,h,d,i,f);t.disposeIntermediateTensorInfo(g)}return h}var H$={kernelName:$s,backendName:"cpu",kernelFunc:Ioe};function Coe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=LN({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c}});if(a){let g=h;h=Wi({inputs:{a:h,b:a},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){let g=h;h=Xp(t,h,d,i,f),t.disposeIntermediateTensorInfo(g)}return h}var q$={kernelName:Bs,backendName:"cpu",kernelFunc:Coe};function Soe(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=y.sizeFromShape(n.shape),a=o.shape,i=a[a.length-1],[u,l,p,m]=C.prepareAndValidate(n,o);if(l===0)return t.makeTensorInfo(u,n.dtype,[]);let c=t.data.get(o.dataId).values,d=t.bufferSync(n),f=Ix(c,d,n.dtype,l,i,p,m,n.shape,s);return t.makeTensorInfo(u,n.dtype,f.values)}var j$={kernelName:Ea,backendName:"cpu",kernelFunc:Soe};function koe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n;ee([o,s],"gatherV2");let u=y.parseAxisParam(a,o.shape)[0],l=t.data.get(s.dataId).values,p=o.shape[u];for(let I=0;I<l.length;++I){let S=l[I];y.assert(S<=p-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${p-1}]`)}let m=i;i==null&&(m=0);let c=y.sizeFromShape(s.shape),d=C.segment_util.collectGatherOpShapeInfo(o,s,u,m),f=rt({inputs:{x:o},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),h=rt({inputs:{x:s},backend:t,attrs:{shape:[d.batchSize,c/d.batchSize]}}),g=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize],b=t.bufferSync(h),T=t.bufferSync(f),x=Cx(T,b,g);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(d.outputShape,x.dtype,x.values)}var X$={kernelName:ks,backendName:"cpu",kernelFunc:koe};function voe(r){let{inputs:e,backend:t}=r,{input:n}=e,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=rt({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),u=Lx(i,!0,t),l=rt({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var Y$={kernelName:qu,backendName:"cpu",kernelFunc:voe};var Aoe=Fe(La,r=>Number.isFinite(r)?1:0,"bool"),Z$={kernelName:La,backendName:"cpu",kernelFunc:Aoe};var woe=Fe($a,r=>Math.abs(r)===1/0?1:0,"bool"),Q$={kernelName:$a,backendName:"cpu",kernelFunc:woe};var Noe=Fe(Mo,r=>Number.isNaN(r)?1:0,"bool"),J$={kernelName:Mo,backendName:"cpu",kernelFunc:Noe};function Doe(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=Sx(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var eB={kernelName:Lm,backendName:"cpu",kernelFunc:Doe};var _oe=Fe(za,r=>Math.log1p(r)),tB={kernelName:za,backendName:"cpu",kernelFunc:_oe};var Moe=ot((r,e)=>r&&e),Roe=pt(Ga,Moe,null,"bool"),rB={kernelName:Ga,backendName:"cpu",kernelFunc:Roe};var Poe=Fe(Wa,r=>r?0:1,"bool"),nB={kernelName:Wa,backendName:"cpu",kernelFunc:Poe};var Eoe=ot((r,e)=>r||e),Foe=pt(Ji,Eoe,null,"bool"),oB={kernelName:Ji,backendName:"cpu",kernelFunc:Foe};function Loe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:u}=n;ee(o,"LRN");let l=o.shape[3],p=l-1,m=t.data.get(o.dataId).values,c=y.sizeFromShape(o.shape),d=new Float32Array(c);function f(h){let g=h%l,b=h-g+Math.max(0,g-s),T=h-g+Math.min(g+s,p),x=0;for(;b<=T;b++){let I=m[b];x+=I*I}return x}for(let h=0;h<c;h++){let g=f(h),b=m[h]*Math.pow(a+i*g,-u);d[h]=b}return t.makeTensorInfo(o.shape,o.dtype,d)}var sB={kernelName:Xu,backendName:"cpu",kernelFunc:Loe};function $oe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:u,alpha:l,beta:p}=n;ee(a,"LRNGrad");let m=y.sizeFromShape(a.shape),c=a.shape[3],d=t.data.get(a.dataId).values,f=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(m),b=m;for(let T=0;T<b;T++){let x=T%c,I=T-x+Math.max(0,x-i),S=T-x+Math.min(c,x+i+1),w=0;for(let _=I;_<S;_++)w+=Math.pow(f[_],2);w=l*w+u;for(let _=I;_<S;_++){let M=-2*l*p*f[_]*h[T]/w;T===_&&(M+=Math.pow(w,-p)),M*=d[T],g[_]+=M}}return t.makeTensorInfo(a.shape,o.dtype,g)}var aB={kernelName:$m,backendName:"cpu",kernelFunc:$oe};function BN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=t,u=o.shape,l=u.length,p=y.parseAxisParam(s,u),m=p,c=C.getAxesPermutation(m,l),d=i.data.get(o.dataId).values;if(c!=null){let I=new Array(l);for(let S=0;S<I.length;S++)I[S]=u[c[S]];d=mf(d,u,o.dtype,c,I),m=C.getInnerMostAxes(m.length,l),u=I}ee(o,"max"),C.assertAxesAreInnerMostDims("max",m,l);let[f,h]=C.computeOutAndReduceShapes(u,m),g=y.sizeFromShape(h),b=kx(d,g,f,o.dtype),T=i.write(b,f,o.dtype),x=f;return a&&(x=C.expandShapeToKeepDim(f,p)),{dataId:T,shape:x,dtype:o.dtype}}var iB={kernelName:Eo,backendName:"cpu",kernelFunc:BN};function Boe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;ee(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u),m;if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))m=Jr({inputs:{x:o},backend:t});else{let c=t.data.get(o.dataId).values,d=y.computeStrides(o.shape),f=hf(c,o.shape,o.dtype,d,p,"max");m=t.makeTensorInfo(p.outShape,o.dtype,f.values)}return m}var uB={kernelName:Lo,backendName:"cpu",kernelFunc:Boe};function Ooe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n;ee(o,"maxPool3d");let p=C.computePool3DInfo(o.shape,s,a,1,i,u,l),m=t.data.get(o.dataId).values,c=Fx(m,o.shape,o.dtype,y.computeStrides(o.shape),p,"max");return t.makeTensorInfo(c.shape,"float32",c.values)}var lB={kernelName:Yu,backendName:"cpu",kernelFunc:Ooe};function zoe(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=n;ee([o,s],"maxPool3DGrad");let p=C.computePool3DInfo(s.shape,a,i,1,u,l),m=t.bufferSync(s),c=o$(m,p),d=p.strideDepth,f=p.strideHeight,h=p.strideWidth,g=p.dilationDepth,b=p.dilationHeight,T=p.dilationWidth,x=p.effectiveFilterDepth,I=p.effectiveFilterHeight,S=p.effectiveFilterWidth,w=x-1-p.padInfo.front,_=S-1-p.padInfo.left,M=I-1-p.padInfo.top,R=Ie(s.shape,"float32"),E=t.bufferSync(o);for(let O=0;O<p.batchSize;++O)for(let G=0;G<p.inChannels;++G)for(let W=0;W<p.inDepth;++W)for(let H=0;H<p.inHeight;++H)for(let U=0;U<p.inWidth;++U){let V=W-w,Y=H-M,j=U-_,te=0;for(let ne=0;ne<x;ne+=g){let oe=(V+ne)/d;if(!(oe<0||oe>=p.outDepth||Math.floor(oe)!==oe))for(let ae=0;ae<I;ae+=b){let se=(Y+ae)/f;if(!(se<0||se>=p.outHeight||Math.floor(se)!==se))for(let ie=0;ie<S;ie+=T){let he=(j+ie)/h;if(he<0||he>=p.outWidth||Math.floor(he)!==he)continue;let Te=x*I*S-1-c.get(O,oe,se,he,G),ve=ne*I*S+ae*S+ie,Pe=Te===ve?1:0;if(Pe===0)continue;let Le=E.get(O,oe,se,he,G);te+=Le*Pe}}}R.set(te,O,W,H,U,G)}return t.makeTensorInfo(R.shape,R.dtype,R.values)}var pB={kernelName:Om,backendName:"cpu",kernelFunc:zoe};function Goe(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;ee([s,a],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:m}=n,c=C.computePool2DInfo(i.shape,u,l,1,p,m),d=t.data.get(i.dataId).values,f=Ie(c.outShape,i.dtype,Ex(d,i.shape,i.dtype,c).values),h=c.strideHeight,g=c.strideWidth,b=c.dilationHeight,T=c.dilationWidth,x=c.effectiveFilterHeight,I=c.effectiveFilterWidth,S=I-1-c.padInfo.left,w=x-1-c.padInfo.top,_=Ie(i.shape,"float32"),M=t.data.get(o.dataId).values,R=Ie(o.shape,"float32",M);for(let E=0;E<c.batchSize;++E)for(let O=0;O<c.inChannels;++O)for(let G=0;G<c.inHeight;++G)for(let W=0;W<c.inWidth;++W){let H=G-w,U=W-S,V=0;for(let Y=0;Y<x;Y+=b){let j=(H+Y)/h;if(!(j<0||j>=c.outHeight||Math.floor(j)!==j))for(let te=0;te<I;te+=T){let ne=(U+te)/g;if(ne<0||ne>=c.outWidth||Math.floor(ne)!==ne)continue;let oe=x*I-1-f.get(E,j,ne,O),ae=Y*I+te,se=oe===ae?1:0;if(se===0)continue;let ie=R.get(E,j,ne,O);V+=ie*se}}_.set(V,E,G,W,O)}return t.makeTensorInfo(_.shape,_.dtype,_.values)}var mB={kernelName:Bm,backendName:"cpu",kernelFunc:Goe};function cB(r,e,t,n,o){let s=y.computeStrides(e),a=hf(r,e,t,s,o,"max"),i=Ex(r,e,t,o,!0,n);return[a.values,i.values]}var dB={kernelName:zm,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,u=t;ee(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,p=C.computePool2DInfo(n.shape,o,s,[1,1],a),[m,c]=cB(l,n.shape,n.dtype,i,p),d=u.write(m,p.outShape,n.dtype),f=u.write(c,p.outShape,n.dtype);return[{dataId:d,shape:p.outShape,dtype:n.dtype},{dataId:f,shape:p.outShape,dtype:"int32"}]}};function Woe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=y.parseAxisParam(s,o.shape),l=C.computeOutAndReduceShapes(o.shape,i)[1],p=y.sizeFromShape(l),m=[],c=t.makeTensorInfo([],"float32",new Float32Array([p]));m.push(c);let d=sa({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});m.push(d);let f=ig({inputs:{a:d,b:c},backend:t});m.push(f);let h=vu({inputs:{x:f},backend:t,attrs:{axis:s,keepDims:a}});return m.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var fB={kernelName:$o,backendName:"cpu",kernelFunc:Woe};function Uoe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;ee(o,"min");let i=y.parseAxisParam(s,o.shape),u=i,l=C.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=qt({inputs:{x:o},backend:t,attrs:{perm:l}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",u,p.shape.length);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),p.dtype),h=t.data.get(p.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let S=h[T+I];(Number.isNaN(S)||S<x)&&(x=S)}f[b]=x}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(m,p.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=rt({inputs:{x:g},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(g),T}return g}var hB={kernelName:Bo,backendName:"cpu",kernelFunc:Uoe};function Koe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,mode:a}=n;ee(o,"mirrorPad");let i=s.map((x,I)=>x[0]+o.shape[I]+x[1]),u=s.map(x=>x[0]),l=s.map((x,I)=>x[0]+o.shape[I]),p=a==="reflect"?0:1,m=t.data.get(o.dataId).values,c=o.shape.length,d=y.computeStrides(o.shape),f=y.sizeFromShape(i),h=i.length,g=y.computeStrides(i),b=y.getTypedArrayFromDType(o.dtype,f);for(let x=0;x<f;x++){let I=y.indexToLoc(x,h,g);for(let w=0;w<h;w++)I[w]<u[w]?I[w]=u[w]*2-I[w]-p:I[w]>=l[w]&&(I[w]=(l[w]-1)*2-I[w]+p);I=I.map((w,_)=>w-u[_]);let S=y.locToIndex(I,c,d);b[x]=m[S]}return{dataId:t.write(b,i,o.dtype),shape:i,dtype:o.dtype}}var gB={kernelName:zo,backendName:"cpu",kernelFunc:Koe};var Voe=ot((r,e)=>{let t=r%e;return r<0&&e<0||r>=0&&e>=0?t:(t+e)%e}),Hoe=pt(Ua,Voe),bB={kernelName:Ua,backendName:"cpu",kernelFunc:Hoe};var TB=Vl(_h());function ON(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=o.shape.length,i=s;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let u=y.parseAxisParam([i],o.shape),l=BN({inputs:{x:o},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),p=C.expandShapeToKeepDim(l.shape,u),m=rt({inputs:{x:l},backend:t,attrs:{shape:p}}),c=sg({inputs:{a:o,b:m},backend:t}),d=mN({inputs:{x:c},backend:t}),f=vu({inputs:{x:d},backend:t,attrs:{axis:u,keepDims:!1}}),h=rt({inputs:{x:f},backend:t,attrs:{shape:p}}),g=ig({inputs:{a:d,b:h},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var yB={kernelName:os,backendName:"cpu",kernelFunc:ON};function qoe(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n;ee(o,"multinomial");let u=i?o:ON({inputs:{logits:o},backend:t,attrs:{dim:-1}}),l=u.shape[0],p=u.shape[1],m=t.data.get(u.dataId).values,c=[l,s],d=y.makeZerosTypedArray(y.sizeFromShape(c),"int32");for(let f=0;f<l;++f){let h=f*p,g=new Float32Array(p-1);g[0]=m[h];for(let x=1;x<g.length;++x)g[x]=g[x-1]+m[h+x];let b=TB.alea(a.toString()),T=f*s;for(let x=0;x<s;++x){let I=b();d[T+x]=g.length;for(let S=0;S<g.length;S++)if(I<g[S]){d[T+x]=S;break}}}return i||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(c,"int32",d)}var xB={kernelName:Gm,backendName:"cpu",kernelFunc:qoe};var joe=xr.nonMaxSuppressionV3Impl;function Xoe(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n;ee(o,"NonMaxSuppression");let l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:m}=joe(l,p,a,i,u);return t.makeTensorInfo([m.length],"int32",new Int32Array(m))}var IB={kernelName:Va,backendName:"cpu",kernelFunc:Xoe};var Yoe=xr.nonMaxSuppressionV4Impl;function Zoe(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n;ee(o,"NonMaxSuppressionPadded");let p=t.data.get(o.dataId).values,m=t.data.get(s.dataId).values,{selectedIndices:c,validOutputs:d}=Yoe(p,m,a,i,u,l);return[t.makeTensorInfo([c.length],"int32",new Int32Array(c)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}var CB={kernelName:eu,backendName:"cpu",kernelFunc:Zoe};var Qoe=xr.nonMaxSuppressionV5Impl;function Joe(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n;ee(o,"NonMaxSuppressionWithScore");let p=t.data.get(o.dataId).values,m=t.data.get(s.dataId).values,c=a,d=i,f=u,h=l,{selectedIndices:g,selectedScores:b}=Qoe(p,m,c,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var SB={kernelName:Ha,backendName:"cpu",kernelFunc:Joe};function ese(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n;ee(o,"oneHot");let l=y.sizeFromShape(o.shape),p=new Float32Array(l*a);p.fill(u);let m=t.data.get(o.dataId).values;for(let c=0;c<l;++c)m[c]>=0&&m[c]<a&&(p[c*a+m[c]]=i);return t.makeTensorInfo([...o.shape,a],s,p)}var kB={kernelName:Wo,backendName:"cpu",kernelFunc:ese};function pg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=oa({inputs:{input:n},backend:t}),s=pg({inputs:{x:o},backend:t}),a=Ui({inputs:{input:n},backend:t}),i=pg({inputs:{x:a},backend:t}),u=wr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return lg({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var vB={kernelName:Es,backendName:"cpu",kernelFunc:pg};function AB(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=oa({inputs:{input:n},backend:t}),s=AB({inputs:{x:o},backend:t}),a=Ui({inputs:{input:n},backend:t}),i=pg({inputs:{x:a},backend:t}),u=wr({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return lg({backend:t,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var wB={kernelName:As,backendName:"cpu",kernelFunc:AB};function zN(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return gf({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=gf({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=$l({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var NB={kernelName:ws,backendName:"cpu",kernelFunc:zN};function tse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;ee(o,"pad");let i=s.map((T,x)=>T[0]+o.shape[x]+T[1]),u=s.map(T=>T[0]),l=t.data.get(o.dataId).values,p=y.sizeFromShape(o.shape),m=o.shape.length,c=y.computeStrides(o.shape),d=y.sizeFromShape(i),f=i.length,h=y.computeStrides(i),g=y.getTypedArrayFromDType(o.dtype,d);a!==0&&g.fill(a);for(let T=0;T<p;T++){let I=y.indexToLoc(T,m,c).map((w,_)=>w+u[_]),S=y.locToIndex(I,f,h);g[S]=l[T]}return{dataId:t.write(g,i,o.dtype),shape:i,dtype:o.dtype}}var $x={kernelName:Uo,backendName:"cpu",kernelFunc:tse};var rse=ot((r,e)=>Math.pow(r,e)),nse=pt(Ko,rse),DB={kernelName:Ko,backendName:"cpu",kernelFunc:nse};function ose(r){let{inputs:e,backend:t,attrs:n}=r,{paramsNestedSplits:o,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:i}=n,u=o.map(b=>t.data.get(b.dataId).values),l=o.map(b=>b.shape),p=t.data.get(s.dataId).values,m=t.data.get(a.dataId).values,[c,d,f]=vx(u,l,p,s.shape,s.dtype,m,a.shape,i),h=c.map(b=>t.makeTensorInfo([b.length],"int32",b)),g=t.makeTensorInfo(f,s.dtype,d);return h.concat([g])}var _B={kernelName:Wm,backendName:"cpu",kernelFunc:ose};function sse(r){let{inputs:e,backend:t}=r,{starts:n,limits:o,deltas:s}=e,a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=Ax(a,n.shape,n.dtype,i,o.shape,u,s.shape),m=t.makeTensorInfo([l.length],"int32",l),c=t.makeTensorInfo([p.length],n.dtype,p);return[m,c]}var MB={kernelName:Um,backendName:"cpu",kernelFunc:sse};function ase(r){let{inputs:e,backend:t,attrs:n}=r,{shape:o,values:s,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=n,l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,m=t.data.get(a.dataId).values,c=i.map(g=>t.data.get(g.dataId).values),d=i.map(g=>g.shape),[f,h]=wx(l,o.shape,p,s.shape,s.dtype,m,a.shape,c,d,u);return t.makeTensorInfo(f,s.dtype,h)}var RB={kernelName:Km,backendName:"cpu",kernelFunc:ase};function ise(r){let{backend:e,attrs:t}=r,{start:n,stop:o,dtype:s,step:a}=t,i=Kp(n,o,a,s);return e.makeTensorInfo([i.length],s,i)}var PB={kernelName:wi,backendName:"cpu",kernelFunc:ise};var use=Fe(qo,r=>1/r),EB={kernelName:qo,backendName:"cpu",kernelFunc:use};function lse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;ee(o,"resizeBilinear");let u=y.computeStrides(o.shape),[l,p]=i,[m,c,d,f]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([m,l,p,f])),b=[s&&l>1?c-1:c,s&&p>1?d-1:d],T=[s&&l>1?l-1:l,s&&p>1?p-1:p],x=0,I=b[0]/T[0],S=b[1]/T[1];for(let w=0;w<m;w++)for(let _=0;_<l;_++){let M;a?M=I*(_+.5)-.5:M=I*_;let R=Math.max(0,Math.floor(M)),E=M-R,O=Math.min(c-1,Math.ceil(M)),G=w*u[0]+R*u[1],W=w*u[0]+O*u[1];for(let H=0;H<p;H++){let U;a?U=S*(H+.5)-.5:U=S*H;let V=Math.max(0,Math.floor(U)),Y=U-V,j=Math.min(d-1,Math.ceil(U)),te=G+V*u[2],ne=W+V*u[2],oe=G+j*u[2],ae=W+j*u[2];for(let se=0;se<f;se++){let ie=h[te+se],he=h[ne+se],Te=h[oe+se],ve=h[ae+se],Pe=ie+(Te-ie)*Y,Le=he+(ve-he)*Y,je=Pe+(Le-Pe)*E;g[x++]=je}}}return t.makeTensorInfo([m,l,p,f],"float32",g)}var FB={kernelName:Yo,backendName:"cpu",kernelFunc:lse};function pse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;ee([s,o],"resizeBilinearGrad");let i=y.computeStrides(o.shape),[u,l,p,m]=o.shape,[,c,d]=s.shape,f=new Float32Array(u*l*p*m),h=[a&&c>1?l-1:l,a&&d>1?p-1:p],g=[a&&c>1?c-1:c,a&&d>1?d-1:d],b=h[0]/g[0],T=h[1]/g[1],x=t.data.get(s.dataId).values,I=0;for(let S=0;S<u;S++){let w=S*i[0];for(let _=0;_<c;_++){let M=_*b,R=Math.floor(M),E=Math.min(Math.ceil(M),l-1),O=w+R*i[1],G=w+E*i[1],W=M-R,H=1-W;for(let U=0;U<d;U++){let V=U*T,Y=Math.floor(V),j=Math.min(Math.ceil(V),p-1),te=V-Y,ne=1-te,oe=O+Y*i[2],ae=O+j*i[2],se=G+Y*i[2],ie=G+j*i[2],he=H*ne,Te=H*te,ve=W*ne,Pe=W*te;for(let Le=0;Le<m;Le++){let je=x[I++];f[oe+Le]+=je*he,f[ae+Le]+=je*Te,f[se+Le]+=je*ve,f[ie+Le]+=je*Pe}}}}return t.makeTensorInfo([u,p,l,m],"float32",f)}var LB={kernelName:Hm,backendName:"cpu",kernelFunc:pse};function mse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n;ee(o,"resizeNearestNeighbor");let u=y.computeStrides(o.shape),[l,p]=i,[m,c,d,f]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(m*l*p*f),b=[s&&l>1?c-1:c,s&&p>1?d-1:d],T=[s&&l>1?l-1:l,s&&p>1?p-1:p],x=b[0]/T[0],I=b[1]/T[1],S=0;for(let w=0;w<m;w++){let _=w*u[0];for(let M=0;M<l;M++){let R=a?x*(M+.5):x*M,E=Math.min(c-1,s?Math.round(R):Math.floor(R));a&&(E=Math.max(0,E));let O=_+E*u[1];for(let G=0;G<p;G++){let W=a?I*(G+.5):I*G,H=Math.min(d-1,s?Math.round(W):Math.floor(W));a&&(H=Math.max(0,H));let U=O+H*u[2];for(let V=0;V<f;V++){let Y=h[U+V];g[S++]=Y}}}}return t.makeTensorInfo([m,l,p,f],o.dtype,g)}var $B={kernelName:Xo,backendName:"cpu",kernelFunc:mse};function cse(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n;ee([s,o],"resizeNearestNeighborGrad");let i=y.computeStrides(o.shape),u=y.computeStrides(s.shape),[l,p,m,c]=o.shape,[,d,f]=s.shape,h=new Float32Array(l*p*m*c),g=t.data.get(s.dataId).values,b=[a&&d>1?p-1:p,a&&f>1?m-1:m],T=[a&&d>1?d-1:d,a&&f>1?f-1:f],x=b[0]/T[0],I=b[1]/T[1],S=1/x,w=1/I,_=Math.ceil(S)*2+2,M=Math.ceil(w)*2+2;for(let R=0;R<l;R++){let E=R*i[0];for(let O=0;O<p;O++){let G=E+O*i[1],W=Math.floor(O*S),H=Math.floor(W-_/2);for(let U=0;U<m;U++){let V=G+U*i[2],Y=Math.floor(U*w),j=Math.floor(Y-M/2);for(let te=0;te<c;te++){let ne=0;for(let oe=0;oe<_;oe++){let ae=oe+H;if(ae<0||ae>=d)continue;let se=E+ae*u[1],ie=ae*x,he=Math.min(p-1,a?Math.round(ie):Math.floor(ie));if(O===he)for(let Te=0;Te<M;Te++){let ve=Te+j;if(ve<0||ve>=f)continue;let Pe=se+ve*u[2],Le=ve*I,je=Math.min(m-1,a?Math.round(Le):Math.floor(Le));U===je&&(ne+=g[Pe+te])}}h[V+te]=ne}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var BB={kernelName:Vm,backendName:"cpu",kernelFunc:cse};function dse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n;ee(o,"reverse");let a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return Jr({inputs:{x:o},backend:t});let u=new bt(o.shape,o.dtype),l=t.bufferSync(o);for(let p=0;p<u.size;p++){let m=u.indexToLoc(p),c=m.slice();i.forEach(d=>c[d]=o.shape[d]-1-c[d]),u.set(l.get(...c),...m)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}var OB={kernelName:Qo,backendName:"cpu",kernelFunc:dse};var zB={kernelName:Ja,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[l,p,m,c]=n.shape,[d,f]=C.getImageCenter(a,p,m),h=255,g=Math.sin(o),b=Math.cos(o),T=i.data.get(n.dataId).values;for(let I=0;I<l;I++){let S=I*m*p*c;for(let w=0;w<p;w++){let _=w*(m*c);for(let M=0;M<m;M++){let R=M*c;for(let E=0;E<c;E++){let O=[l,w,M,E],G=O[2],W=O[1],H=(G-d)*b-(W-f)*g,U=(G-d)*g+(W-f)*b;H=Math.round(H+d),U=Math.round(U+f);let V=s;if(typeof s!="number"&&(E===3?V=h:V=s[E]),H>=0&&H<m&&U>=0&&U<p){let j=U*(m*c),te=H*c,ne=S+j+te+E;V=T[ne]}let Y=S+_+R+E;u[Y]=V}}}}return{dataId:i.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var fse=Fe(qa,r=>{let e=Math.floor(r);return r-e<.5?Math.floor(r):r-e>.5?Math.ceil(r):e%2===0?e:e+1}),GB={kernelName:qa,backendName:"cpu",kernelFunc:fse};function hse(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:m}=C.calculateShapes(s,o,a),c=!0,d=t.bufferSync(o),f=t.bufferSync(s),h=ku(d,f,a,m,l,u,i,p,0,c);return t.makeTensorInfo(a,h.dtype,h.values)}var WB={kernelName:ja,backendName:"cpu",kernelFunc:hse};function gse(r,e){let t=0,n=r.length,o=0;for(;t<n;)o=Math.floor((t+n)/2),r[o]<e?t=o+1:n=o;return n}function bse(r,e){let t=0,n=r.length,o=0;for(;t<n;)o=Math.floor((t+n)/2),r[o]<=e?t=o+1:n=o;return n}function UB(r,e,t,n,o,s){let a=y.getArrayFromDType("int32",t*o);for(let i=0;i<t;++i){let u=r.slice(i*n,(i+1)*n),l=i*o;for(let p=0;p<o;++p)a[l+p]=s==="left"?gse(u,e[p+l]):bse(u,e[p+l])}return a}function yse(r){let{inputs:e,backend:t,attrs:n}=r,{sortedSequence:o,values:s}=e,{side:a}=n,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=UB(i,u,o.shape[0],o.shape[1],s.shape[1],a);return t.makeTensorInfo(s.shape,"int32",l)}var KB={kernelName:Qu,backendName:"cpu",kernelFunc:yse};function Tse(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e;ee([n,o,s],"select");let a=n.shape.length,i=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=Pt(o.dtype,s.dtype),m=y.makeZerosTypedArray(y.sizeFromShape(o.shape),p),c=0,d=a===0||a>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let f=0;f<i.length;f++)for(let h=0;h<d;h++)i[f]===1?m[c++]=u[f]:m[c++]=l[f];return t.makeTensorInfo(o.shape,p,m)}var VB={kernelName:Ds,backendName:"cpu",kernelFunc:Tse};var xse=C.SELU_SCALEALPHA,Ise=C.SELU_SCALE,Cse=Fe(tu,r=>r>=0?Ise*r:xse*(Math.exp(r)-1)),HB={kernelName:tu,backendName:"cpu",kernelFunc:Cse};var Sse=Fe(ru,r=>r<0?-1:r>0?1:0),qB={kernelName:ru,backendName:"cpu",kernelFunc:Sse};var kse=Fe(es,r=>Math.sin(r)),jB={kernelName:es,backendName:"cpu",kernelFunc:kse};var vse=Fe(Xa,r=>Math.sinh(r)),XB={kernelName:Xa,backendName:"cpu",kernelFunc:vse};var Ase=11920928955078125e-23,YB=Math.log(Ase)+2,wse=Fe(nu,r=>{let e=r>-YB,t=r<YB,n=Math.exp(r),o;return t?o=n:e?o=r:o=Math.log(1+n),o}),ZB={kernelName:nu,backendName:"cpu",kernelFunc:wse};function Nse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;ee([o],"spaceToBatchND");let i=y.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let w=1+s.length;w<o.shape.length;++w)u.push([0,0]);let l=$x.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=C.getReshaped(l.shape,s,i,!1),m=C.getPermuted(p.length,s.length,!1),c=C.getReshapedPermuted(l.shape,s,i,!1),h=rt({inputs:{x:l},backend:t,attrs:{shape:p}}),T=qt({inputs:{x:h},backend:t,attrs:{perm:m}}),S=rt({inputs:{x:T},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(T),S}var QB={kernelName:Ms,backendName:"cpu",kernelFunc:Nse};function Dse(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=t.data.get(a.dataId).values[0],[m,c,d,f,h]=Nx(i,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(c,n.dtype,m),t.makeTensorInfo([c[0]],o.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var JB={kernelName:Ju,backendName:"cpu",kernelFunc:Dse};function _se(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.data.get(o.dataId).values),i=t.data.get(n.dataId).values,u=Array.from(t.data.get(s.dataId).values),[l,p,m]=Dx(i,n.shape,n.dtype,a,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}var eO={kernelName:ou,backendName:"cpu",kernelFunc:_se};function Mse(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=df(a,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var tO={kernelName:el,backendName:"cpu",kernelFunc:Mse};function Rse(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=df(a,n.shape,n.dtype,i,u);return t.makeTensorInfo(p,n.dtype,l)}var rO={kernelName:tl,backendName:"cpu",kernelFunc:Rse};function Pse(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1,f=t.bufferSync(o),h;switch(s.dtype){case"bool":{let g=t.bufferSync(s),b=Boolean(t.data.get(a.dataId).values[0]);h=ku(f,g,i,c,p,l,u,m,b,d);break}case"float32":{let g=t.bufferSync(s),b=t.data.get(a.dataId).values[0];h=ku(f,g,i,c,p,l,u,m,b,d);break}case"int32":{let g=t.bufferSync(s),b=t.data.get(a.dataId).values[0];h=ku(f,g,i,c,p,l,u,m,b,d);break}case"string":{let g=t.bufferSync(s),b=y.decodeString(t.data.get(a.dataId).values[0]);h=ku(f,g,i,c,p,l,u,m,b,d);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(i,h.dtype,h.values)}var nO={kernelName:rl,backendName:"cpu",kernelFunc:Pse};function Ese(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(m=>{let c=[...p];c[i]=m;let d=ua({inputs:{x:o},backend:t,attrs:{begin:l,size:c}});return l[i]+=m,d})}var oO={kernelName:Rs,backendName:"cpu",kernelFunc:Ese};var sO={kernelName:Ni,backendName:"cpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e;ee(t,"square");let o=n.data.get(t.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){let u=o[i];s[i]=u*u}return{dataId:n.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};var Fse=Fe(Fs,(r,e)=>{let t=e;return isNaN(r)?NaN:r>0?1:t.alpha}),aO={kernelName:Fs,backendName:"cpu",kernelFunc:Fse};function Lse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n;ee(o,"stridedSlice");let{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),S;if(h)S=rt({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),_=ua({inputs:{x:o},backend:t,attrs:{begin:T,size:w}});S=rt({inputs:{x:_},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(_)}else{let w=t.bufferSync(o),_=_x(d,w,I,T);S=t.makeTensorInfo(f,_.dtype,_.values)}return S}var iO={kernelName:Ya,backendName:"cpu",kernelFunc:Lse};function $se(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:m}=e,c=t.data.get(p.dataId).values,d=t.data.get(m.dataId).values,[f,h]=Hp(c,d,o,s,a,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(m.shape,"int32",h)]}var uO={kernelName:Di,backendName:"cpu",kernelFunc:$se};function Bse(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values[0],[l,p,m]=qp(i,u,o),c=p.length;return[t.makeTensorInfo([c,2],"int32",l),t.makeTensorInfo([c],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(m))]}var lO={kernelName:nl,backendName:"cpu",kernelFunc:Bse};function Ose(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=t.data.get(s.dataId).values,i=jp(a,o);return t.makeTensorInfo(s.shape,"int32",i)}var pO={kernelName:ol,backendName:"cpu",kernelFunc:Ose};var zse=Fe(is,r=>Math.tan(r)),mO={kernelName:is,backendName:"cpu",kernelFunc:zse};var Gse=Fe(us,r=>Math.tanh(r)),cO={kernelName:us,backendName:"cpu",kernelFunc:Gse};function Wse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;ee(o,"tile");let a=Mx(t.bufferSync(o),s);return t.makeTensorInfo(a.shape,a.dtype,a.values)}var dO={kernelName:Dn,backendName:"cpu",kernelFunc:Wse};function Use(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n;ee(o,"topk");let i=t.data.get(o.dataId).values,[u,l]=Rx(i,o.shape,o.dtype,s,a);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}var fO={kernelName:Za,backendName:"cpu",kernelFunc:Use};function Kse(r){let{inputs:e,attrs:t,backend:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=t,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=y.computeStrides(o.shape),T=b[0],x=b[1],I=b[2],S=y.computeStrides(g),w=S[0],_=S[1],M=S[2],R=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));R.fill(u);let E=n.data.get(o.dataId).values,O=n.data.get(s.dataId).values;for(let W=0;W<p;++W){let H=s.shape[0]===1?O:O.subarray(W*8,W*8+8);for(let U=0;U<f;++U)for(let V=0;V<h;++V)for(let Y=0;Y<d;++Y){let j,te=H[6]*V+H[7]*U+1;if(te===0)continue;let ne=(H[0]*V+H[1]*U+H[2])/te,oe=(H[3]*V+H[4]*U+H[5])/te,ae=hO(ne,c,i),se=hO(oe,m,i);switch(a){case"nearest":j=Xse(E,m,c,T,x,I,W,se,ae,Y,u);break;case"bilinear":j=Yse(E,m,c,T,x,I,W,se,ae,Y,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let ie=W*w+U*_+V*M+Y;R[ie]=j}return n.makeTensorInfo(g,o.dtype,R)}return{dataId:n.write(R,g,o.dtype),shape:o.shape,dtype:o.dtype}}var gO={kernelName:Qa,backendName:"cpu",kernelFunc:Kse};function hO(r,e,t){switch(t){case"reflect":return Vse(r,e);case"wrap":return Hse(r,e);case"nearest":return jse(r,e);case"constant":default:return qse(r,e)}}function Vse(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{let n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return y.clamp(0,t,e-1)}function Hse(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{let n=e-1;t-=e*Math.trunc(t/n)}return y.clamp(0,t,e-1)}function qse(r,e){return r}function jse(r,e){return y.clamp(0,r,e-1)}function mg(r,e,t,n,o,s,a,i,u,l,p){let m=a*n+i*o+u*s+l;return 0<=i&&i<e&&0<=u&&u<t?r[m]:p}function Xse(r,e,t,n,o,s,a,i,u,l,p){let m=Math.round(i),c=Math.round(u);return mg(r,e,t,n,o,s,a,m,c,l,p)}function Yse(r,e,t,n,o,s,a,i,u,l,p){let m=Math.floor(i),c=Math.floor(u),d=m+1,f=c+1,h=(f-u)*mg(r,e,t,n,o,s,a,m,c,l,p)+(u-c)*mg(r,e,t,n,o,s,a,m,f,l,p),g=(f-u)*mg(r,e,t,n,o,s,a,d,c,l,p)+(u-c)*mg(r,e,t,n,o,s,a,d,f,l,p);return(d-i)*h+(i-m)*g}function Zse(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;ee(s,"unique");let a=n.data.get(s.dataId).values,{outputValues:i,outputShape:u,indices:l}=Px(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}var bO={kernelName:qm,backendName:"cpu",kernelFunc:Zse};function Qse(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape.length,i=o.shape[s],u=new Array(a-1),l=0;for(let d=0;d<a;d++)d!==s&&(u[l++]=o.shape[d]);let p=new Array(a).fill(0),m=o.shape.slice();m[s]=1;let c=new Array(i);for(let d=0;d<c.length;d++){p[s]=d;let f=ua({inputs:{x:o},backend:t,attrs:{begin:p,size:m}});c[d]=rt({inputs:{x:f},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(f)}return c}var yO={kernelName:Ps,backendName:"cpu",kernelFunc:Qse};function Jse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n;ee(o,"unsortedSegmentSum");let i=o.shape.length,u=s.shape.length,l=[],p=[],m=i-u,c=s;for(let f=0;f<m;++f){let h=gf({inputs:{input:c},backend:t,attrs:{dim:f+1}});c=h,p.push(h)}for(let f=0;f<a;++f){let h=y.createScalarValue(f,"int32"),g=t.makeTensorInfo([],"int32",h),b=lN({inputs:{a:g,b:c},backend:t}),T=sa({inputs:{x:b},backend:t,attrs:{dtype:"float32"}}),x=Up({inputs:{a:T,b:o},backend:t}),I=vu({inputs:{x},backend:t,attrs:{axis:0,keepDims:!1}});l.push(I),p.push(g),p.push(b),p.push(T),p.push(x),p.push(I)}let d=zN({inputs:l,backend:t,attrs:{axis:0}});return p.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}var TO={kernelName:sl,backendName:"cpu",kernelFunc:Jse};var eae=[VL,rL,HL,qL,iL,jL,XL,YL,ZL,QL,JL,e$,t$,r$,n$,s$,a$,i$,u$,KL,l$,p$,m$,c$,aL,uL,d$,nL,f$,g$,b$,y$,T$,x$,I$,C$,S$,k$,v$,A$,w$,N$,D$,_$,M$,R$,P$,E$,F$,L$,B$,BL,O$,lL,z$,pL,G$,mL,W$,U$,K$,cL,V$,H$,q$,j$,X$,dL,fL,oL,Y$,h$,Z$,Q$,J$,OL,hL,gL,eB,bL,tB,rB,nB,oB,sB,aB,iB,yL,uB,lB,pB,mB,dB,fB,hB,TL,gB,bB,xB,xL,IL,IB,CB,SB,CL,kB,wB,NB,$x,DB,zL,kL,_B,MB,RB,PB,sL,ug,EB,GL,WL,UL,FB,LB,$B,BB,OB,zB,GB,DL,WB,KB,VB,HB,ML,qB,jB,XB,RL,yB,ZB,QB,JB,eO,tO,rO,nO,oO,EL,sO,FL,aO,iO,uO,lO,pO,LL,$$,mO,cO,dO,fO,gO,SL,bO,yO,TO,vB];for(let r of eae)su(r);var xf={};qe(xf,{assertNotComplex:()=>gi,bindCanvasToFramebuffer:()=>lae,bindColorTextureToFramebuffer:()=>hg,bindTextureToProgramUniformSampler:()=>rD,bindTextureUnit:()=>SO,bindVertexBufferToProgramAttribute:()=>Ux,callAndCheck:()=>xe,canBeRepresented:()=>KN,createFragmentShader:()=>HN,createFramebuffer:()=>JN,createProgram:()=>qN,createStaticIndexBuffer:()=>YN,createStaticVertexBuffer:()=>XN,createTexture:()=>ZN,createVertexShader:()=>VN,getBatchDim:()=>wu,getExtensionOrThrow:()=>bf,getFramebufferErrorMessage:()=>kO,getMaxTexturesInShader:()=>sD,getNumChannels:()=>iae,getProgramUniformLocation:()=>tD,getProgramUniformLocationOrThrow:()=>eD,getRowsCols:()=>Nu,getShapeAs3D:()=>Tf,getTextureShapeFromLogicalShape:()=>nD,getWebGLDisjointQueryTimerVersion:()=>aD,getWebGLErrorMessage:()=>CO,getWebGLMaxTextureSize:()=>oD,hasExtension:()=>to,isCapableOfRenderingToFloatTexture:()=>iD,isDownloadFloatTextureEnabled:()=>uD,isReshapeFree:()=>Bl,isWebGLFenceEnabled:()=>lD,isWebGLVersionEnabled:()=>Vx,linkProgram:()=>jN,logShaderSourceAndInfoLog:()=>Wx,resetMaxTextureSize:()=>pae,resetMaxTexturesInShader:()=>mae,unbindColorTextureFromFramebuffer:()=>Kx,unbindTextureUnit:()=>uae,validateFramebuffer:()=>yf,validateProgram:()=>fg,validateTextureSize:()=>QN});var Yp={},Bx={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function GN(r,e){Yp[r]=e}function eo(r,e){if(!(r in Yp)||e!=null){let n=rae(r,e);if(n!==null)Yp[r]=n;else return console.log("Could not get context for WebGL version",r),null}let t=Yp[r];return t==null||t.isContextLost()?(delete Yp[r],eo(r)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Yp[r])}function tae(r){if(typeof OffscreenCanvas<"u"&&r===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function rae(r,e){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=e??tae(r);return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete Yp[r]},!1),$().getBool("SOFTWARE_WEBGL_ENABLED")&&(Bx.failIfMajorPerformanceCaveat=!1),r===1?t.getContext("webgl",Bx)||t.getContext("experimental-webgl",Bx):t.getContext("webgl2",Bx)}function Zp(r,e){return[e,r]}function xO(r,e){return r*e}function cg(r){let e=y.sizeFromShape(r),t=Math.ceil(e/4);return y.sizeToSquarishShape(t)}function Ki(r,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(r/2))]}function IO(r,e){let[t,n]=Ki(r,e);return t*n*4}function dg(r,e){let t=r,n,o,s,a,i,u,l,p,m,c;return $().getNumber("WEBGL_VERSION")===2?(n=t.R32F,o=t.R16F,s=t.RGBA16F,a=t.RGBA32F,i=t.RED,l=4,p=1,m=t.HALF_FLOAT,c=t.FLOAT,u=t.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,a=t.RGBA,i=r.RGBA,l=4,p=4,m=e!=null?e.HALF_FLOAT_OES:null,c=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:p,textureTypeHalfFloat:m,textureTypeFloat:c}}function xe(r,e){let t=e();return $().getBool("DEBUG")&&nae(r),t}function nae(r){let e=r.getError();if(e!==r.NO_ERROR)throw new Error("WebGL Error: "+CO(r,e))}var oae=596e-10,sae=65504;function KN(r){return!!($().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||oae<Math.abs(r)&&Math.abs(r)<sae)}function CO(r,e){switch(e){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function bf(r,e){return Au(r,()=>r.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function VN(r,e){let t=Au(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(xe(r,()=>r.shaderSource(t,e)),xe(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function HN(r,e){let t=Au(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(xe(r,()=>r.shaderSource(t,e)),xe(r,()=>r.compileShader(t)),$().get("ENGINE_COMPILE_ONLY"))return t;if(r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw Wx(e,r.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var aae=/ERROR: [0-9]+:([0-9]+):/g;function Wx(r,e){let t=aae.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(r);return}let n=+t[1],o=r.split(`
`),s=o.length.toString().length+2,a=o.map((m,c)=>y.rightPad((c+1).toString(),s)+m),i=0;for(let m=0;m<a.length;m++)i=Math.max(a[m].length,i);let u=a.slice(0,n-1),l=a.slice(n-1,n),p=a.slice(n);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${y.rightPad(l[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join(`
`))}function qN(r){return Au(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function jN(r,e){if(xe(r,()=>r.linkProgram(e)),!$().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(e,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function fg(r,e){if(xe(r,()=>r.validateProgram(e)),r.getProgramParameter(e,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function XN(r,e){let t=Au(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return xe(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),xe(r,()=>r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function YN(r,e){let t=Au(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return xe(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t)),xe(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function iae(){return $().getNumber("WEBGL_VERSION")===2?1:4}function ZN(r){return Au(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function QN(r,e){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||e<=0){let n=`[${r}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>t||e>t){let n=`[${r}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function JN(r){return Au(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Ux(r,e,t,n,o,s,a){let i=r.getAttribLocation(e,t);return i===-1?!1:(xe(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),xe(r,()=>r.vertexAttribPointer(i,o,r.FLOAT,!1,s,a)),xe(r,()=>r.enableVertexAttribArray(i)),!0)}function SO(r,e,t){vO(r,t),xe(r,()=>r.activeTexture(r.TEXTURE0+t)),xe(r,()=>r.bindTexture(r.TEXTURE_2D,e))}function uae(r,e){vO(r,e),xe(r,()=>r.activeTexture(r.TEXTURE0+e)),xe(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function eD(r,e,t){return Au(r,()=>r.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function tD(r,e,t){return r.getUniformLocation(e,t)}function rD(r,e,t,n){xe(r,()=>SO(r,e,n)),xe(r,()=>r.uniform1i(t,n))}function lae(r){xe(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),xe(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),xe(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function hg(r,e,t){xe(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),xe(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0))}function Kx(r,e){xe(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),xe(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function yf(r){let e=r.checkFramebufferStatus(r.FRAMEBUFFER);if(e!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+kO(r,e))}function kO(r,e){switch(e){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Au(r,e,t){let n=xe(r,()=>e());if(n==null)throw new Error(t);return n}function vO(r,e){let t=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+r.TEXTURE0;if(n<r.TEXTURE0||n>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function wu(r,e=2){return y.sizeFromShape(r.slice(0,r.length-e))}function Nu(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Tf(r){let e=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(e=[wu(r),...Nu(r)]),e}function nD(r,e=!1){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=$().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&$().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=t/2),e&&(t=t*2,n=n*2,r=r.map((i,u)=>u>=r.length-2?y.nearestLargerEven(r[u]):r[u]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=y.squeezeShape(r).newShape);let o=y.sizeFromShape(r),s=null;r.length<=1&&o<=t?s=[1,o]:r.length===2&&r[0]<=t&&r[1]<=t?s=r:r.length===3&&r[0]*r[1]<=t&&r[2]<=t?s=[r[0]*r[1],r[2]]:r.length===3&&r[0]<=t&&r[1]*r[2]<=t?s=[r[0],r[1]*r[2]]:r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t?s=[r[0]*r[1]*r[2],r[3]]:r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t&&(s=[r[0],r[1]*r[2]*r[3]]);let a=s!=null&&Math.max(...s)>n&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||a)if(e){let i=wu(r),u=2,l=2;r.length&&([u,l]=Nu(r)),o=i*(u/2)*(l/2),s=y.sizeToSquarishShape(o).map(p=>p*2)}else s=y.sizeToSquarishShape(o);return s}function Ox(r){return r%2===0}function Bl(r,e){if(r=r.slice(-2),e=e.slice(-2),y.arraysEqual(r,e)||!r.length||!e.length||r[0]===0||r[1]===0||e[0]===0||e[1]===0)return!0;if(r.length!==e.length){let t=r.slice(-1)[0],n=e.slice(-1)[0];if(t===n||Ox(t)&&Ox(n)&&(r[0]===1||e[0]===1))return!0}return r[1]===e[1]&&Ox(r[0])&&Ox(e[0])}var zx,Gx;function oD(r){if(zx==null){let e=eo(r);zx=e.getParameter(e.MAX_TEXTURE_SIZE)}return zx}function pae(){zx=null}function mae(){Gx=null}function sD(r){if(Gx==null){let e=eo(r);Gx=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Gx)}function aD(r){if(r===0)return 0;let e,t=eo(r);return to(t,"EXT_disjoint_timer_query_webgl2")&&r===2?e=2:to(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function to(r,e){return r.getExtension(e)!=null}function Vx(r){try{if(eo(r)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function iD(r){if(r===0)return!1;let e=eo(r);if(r===1){if(!to(e,"OES_texture_float"))return!1}else if(!to(e,"EXT_color_buffer_float"))return!1;return UN(e)}function uD(r){if(r===0)return!1;let e=eo(r);if(r===1){if(!to(e,"OES_texture_float")||!to(e,"WEBGL_color_buffer_float"))return!1}else{if(to(e,"EXT_color_buffer_float"))return UN(e);let n="EXT_color_buffer_half_float";if(to(e,n)){let o=e.getExtension(n);return cae(e,o)}return!1}return UN(e)}function UN(r){let e=dg(r),t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatFloat,n,o,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(t),r.deleteFramebuffer(s),a}function cae(r,e){let t=dg(r,e),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatHalfFloat,o,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(a),i}function lD(r){return r!==2?!1:eo(r).fenceSync!=null}function gi(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&y.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var Me=$();Me.registerFlag("HAS_WEBGL",()=>Me.getNumber("WEBGL_VERSION")>0);Me.registerFlag("WEBGL_VERSION",()=>Vx(2)?2:Vx(1)?1:0);Me.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Me.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Me.get("WEBGL_VERSION")===2);Me.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Me.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Me.registerFlag("WEBGL_PACK",()=>Me.getBool("HAS_WEBGL"));Me.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_CLIP",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_PACK_REDUCE",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_LAZILY_UNPACK",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_CONV_IM2COL",()=>Me.getBool("WEBGL_PACK"));Me.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>oD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>sD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Me.getNumber("WEBGL_VERSION");return r===0?0:aD(r)});Me.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Me.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ul.isMobile());Me.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>iD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Me.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Me.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Me.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>uD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_FENCE_API_ENABLED",()=>lD(Me.getNumber("WEBGL_VERSION")));Me.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Me.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Me.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Me.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>ul.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Me.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Me.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Me.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Me.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Me.registerFlag("WEBGL_EXP_CONV",()=>!1);Me.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Me.getBool("IS_TEST"));Me.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Me.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Me.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Me.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function jt(){let r,e,t,n,o,s,a,i,u,l;return $().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",e="in",t="out",n="in",o="texture",s="outputColor",a="out vec4 outputColor;",i=$().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",e="attribute",t="varying",n="varying",o="texture2D",s="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:e,varyingVs:t,varyingFs:n,texture2D:o,output:s,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:u,defineRound:l}}function bi(r,e,t="index"){let n=y.computeStrides(e);return n.map((o,s)=>{let a=`int ${r[s]} = ${t} / ${o}`,i=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${a}; ${i};`}).join("")}function Qp(r,e,t="index"){let n=y.computeStrides(e);return n.map((o,s)=>{let a=`int ${r[s]} = ${t} / outShapeStrides[${s}]`,i=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${a}; ${i};`}).join("")}function dae(r,e){let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function AO(r,e,t="index"){let n=r.map((s,a)=>a),o=dae(n,e);return o.map((s,a)=>{let i=`int ${r[a]} = ${t} / ${o[a]}`,u=a===o.length-1?`int ${r[a+1]} = ${t} - ${r[a]} * ${o[a]}`:`index -= ${r[a]} * ${o[a]}`;return`${i}; ${u};`}).join("")}function If(r){let e=y.computeStrides(r).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Cf(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Hx=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:wO}=C;function NO(r,e,t){let n=[];if(r.forEach(d=>{let f=y.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?n.push(`uniform float ${d.name}${f>1?`[${f}]`:""};`):(n.push(`uniform sampler2D ${d.name};`),n.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){let{uniformShape:h}=qx(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${d.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{n.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(d=>fae(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,i=jt(),u=bae(i),l,p,m=xae(i);return e.isPacked?(l=hae(e.logicalShape,a,t.enableShapeUniforms),p=Tae(i)):(l=gae(e.logicalShape,a,t.enableShapeUniforms),p=yae(i)),t.packedInputs&&(m+=kae),[m,u,p,o,l,s,t.userCode].join(`
`)}function kf(r,e=!1){let t=r.shapeInfo.logicalShape;switch(t.length){case 0:return Lae(r,e);case 1:return Bae(r,e);case 2:return zae(r,e);case 3:return Wae(r,e);case 4:return Kae(r,e);case 5:return Vae(r);case 6:return Hae(r);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function DO(r,e){switch(r.shapeInfo.logicalShape.length){case 0:return Fae(r);case 1:return $ae(r,e);case 2:return Oae(r,e);case 3:return Gae(r,e);default:return Uae(r,e)}}function fae(r,e,t=!1,n){let o="";t?o+=DO(r,n):o+=kf(r,n);let s=r.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(t?o+=qae(r,e):o+=jae(r,e)),o}function hae(r,e,t){switch(r.length){case 0:return _O();case 1:return vae(r,e,t);case 2:return Pae(r,e,t);case 3:return wae(r,e,t);default:return Dae(r,e,t)}}function gae(r,e,t){switch(r.length){case 0:return _O();case 1:return Aae(r,e,t);case 2:return Eae(r,e,t);case 3:return Nae(r,e,t);case 4:return _ae(r,e,t);case 5:return Mae(r,e);case 6:return Rae(r,e);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function bae(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function yae(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function Tae(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function xae(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Iae}
    ${Cae}
    ${Sae}
  `}var Iae=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Cae=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Sae=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,kae=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function _O(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function vae(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function Aae(r,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function wae(r,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Nae(r,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Qp(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=bi(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function Dae(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),a=s,i="",u="b, r, c";for(let l=2;l<r.length-1;l++)a*=r[r.length-l-1],i=`
      int b${l} = index / ${a};
      index -= b${l} * ${a};
    `+i,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${i}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function _ae(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Qp(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=bi(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function Mae(r,e){let t=bi(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Rae(r,e){let t=bi(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Pae(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(y.arraysEqual(r,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function Eae(r,e,t){return y.arraysEqual(r,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:r[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Jp(r){return`offset${r}`}function Fae(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=jt();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function Lae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Jp(t);if(e)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;let[i,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function $ae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape,s=jt();if(e)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function Bae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${vf(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],a=o[1];if(a===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Jp(t);return a===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${i});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Oae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=s[0],i=s[1],u=jt();if(s!=null&&y.arraysEqual(t,s))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function zae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&y.arraysEqual(t,s)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let c=s[0],d=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${c}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:a,keptDims:i}=y.squeezeShape(t),u=a;if(u.length<t.length){let c=Af(r,u),d=["row","col"];return`
      ${kf(c,e)}
      float ${o}(int row, int col) {
        return ${o}(${wf(d,i)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${vf(r)}
      }
    `;let l=s[0],p=s[1],m=Jp(n);return p===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${m}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${m}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${m}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${m}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${m};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${m};
    vec2 uv = uvFromFlat(${l}, ${p}, index);
    return sampleTexture(${n}, uv);
  }
`}function Gae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let c=t.slice(1),d=[1,2],f=Af(r,c),h=["b","row","col"];return`
        ${DO(f,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${wf(h,d)});
        }
      `}let i=jt();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `;let u=a[0],l=a[1],p=Math.ceil(t[2]/2),m=p*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${m}, ${p}, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `}function Wae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],a=t[2],{newShape:i,keptDims:u}=y.squeezeShape(t),l=i;if(l.length<t.length){let h=Af(r,l),g=["row","col","depth"];return`
        ${kf(h,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${wf(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${vf(r)}
      }
    `;let p=r.shapeInfo.texShape,m=p[0],c=p[1],d=r.shapeInfo.flatOffset;if(c===s&&d==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${c}.0, ${m}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(c===a&&d==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `;let f=Jp(n);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${m}, ${c}, index);
        return sampleTexture(${n}, uv);
      }
  `}function Uae(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=jt();if(e)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,a=s.length,i=r.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=u[0],p=u[1],m=Math.ceil(s[a-1]/2),c=m*Math.ceil(s[a-2]/2),d="int b, int row, int col",f=`b * ${c} + (row / 2) * ${m} + (col / 2)`;for(let h=2;h<a-1;h++)d=`int b${h}, `+d,c*=s[a-h-1],f=`b${h} * ${c} + `+f;return`
    vec4 ${n}(${d}) {
      int index = ${f};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});
      return ${o.texture2D}(${t}, uv);
    }
  `}function Kae(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],a=t[2]*s,i=t[1]*a,{newShape:u,keptDims:l}=y.squeezeShape(t);if(u.length<t.length){let T=Af(r,u),x=["row","col","depth","depth2"];return`
      ${kf(T,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${wf(x,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${s}, 1)));
        ${vf(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,c=m[0],d=m[1],f=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(d===i&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${f}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(d===s&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;let b=Jp(n);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${b});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${c}, ${d}, index + ${b});
      return sampleTexture(${n}, uv);
    }
  `}function Vae(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,a=e[2]*s,i=e[1]*a,{newShape:u,keptDims:l}=y.squeezeShape(e);if(u.length<e.length){let h=Af(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${kf(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${wf(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${s}, ${o})) +
          depth3;
        ${vf(r)}
      }
    `;let p=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,c=m[0],d=m[1];if(d===i&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${c}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===o&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${c}.0);
        return sampleTexture(${t}, uv);
      }
    `;let f=Jp(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${s} +
          depth2 * ${o} + depth3 + ${f};
      vec2 uv = uvFromFlat(${c}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Hae(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(e);if(o.length<e.length){let g=Af(r,o),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${kf(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${wf(b,s)});
      }
    `}let a=e[5],i=e[4]*a,u=e[3]*i,l=e[2]*u,p=e[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${l}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${vf(r)}
      }
    `;let m=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,d=c[0],f=c[1];if(f===p&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===a&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Jp(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${l} + depth * ${u} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function vf(r){let e=r.name,t=y.sizeFromShape(r.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function qae(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,a=e.logicalShape.length,i=wO(r.shapeInfo.logicalShape,e.logicalShape),u=Ve(a),l=a-s,p,m=["x","y","z","w","u","v"];s===0?p="":a<2&&i.length>=1?p="coords = 0;":p=i.map(T=>`coords.${m[T+l]} = 0;`).join(`
`);let c="";a<2&&s>0?c="coords":c=r.shapeInfo.logicalShape.map((T,x)=>`coords.${m[x+l]}`).join(", ");let d="return outputValue;",h=y.sizeFromShape(r.shapeInfo.logicalShape)===1,b=y.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!b)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!b)a===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(i.length){let T=s-2,x=s-1;i.indexOf(T)>-1&&i.indexOf(x)>-1?d="return vec4(outputValue.x);":i.indexOf(T)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(x)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${p}
      vec4 outputValue = get${n}(${c});
      ${d}
    }
  `}function jae(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=e.texShape,a=r.shapeInfo.texShape,i=r.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!r.shapeInfo.isUniform&&i===u&&r.shapeInfo.flatOffset==null&&y.arraysEqual(a,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let l=Ve(u),p=wO(r.shapeInfo.logicalShape,e.logicalShape),m=u-i,c,d=["x","y","z","w","u","v"];i===0?c="":u<2&&p.length>=1?c="coords = 0;":c=p.map(h=>`coords.${d[h+m]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=r.shapeInfo.logicalShape.map((h,g)=>`coords.${d[g+m]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${c}
      return get${n}(${f});
    }
  `}function Ve(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function qx(r,e,t){let{newShape:n,keptDims:o}=y.squeezeShape(e),s=e.length,a=r&&s===3&&e[0]===1,i=a?e.slice(1):n,u=!r&&s>1&&!y.arraysEqual(e,t)&&n.length<s||a;return{useSqueezeShape:u,uniformShape:u?i:e,keptDims:o}}function Af(r,e){let t=JSON.parse(JSON.stringify(r));return t.shapeInfo.logicalShape=e,t}function wf(r,e){return e.map(t=>r[t]).join(", ")}function RO(r,e,t,n){let o=t.map((p,m)=>{let c={logicalShape:p.shape,texShape:p.isUniform?null:p.texData.texShape,isUniform:p.isUniform,isPacked:p.isUniform?!1:p.texData.isPacked,flatOffset:null};return p.texData!=null&&p.texData.slice!=null&&p.texData.slice.flatOffset>0&&(c.flatOffset=p.texData.slice.flatOffset),{name:e.variableNames[m],shapeInfo:c}}),s=o.map(p=>p.shapeInfo),a={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},i=NO(o,a,e),u=HN(r.gl,i),l=r.createProgram(u);return $().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:{program:e,fragmentShader:u,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:a,...pD(r,e,l)}}function pD(r,e,t){let n={},o={},s={},a=[],i,u,l,p=null,m=null;m=r.getUniformLocation(t,"NAN",!1),$().getNumber("WEBGL_VERSION")===1&&(p=r.getUniformLocation(t,"INFINITY",!1));let c=!1;for(let d=0;d<e.variableNames.length;d++){let f=e.variableNames[d];n[f]=r.getUniformLocation(t,f,c),n[`offset${f}`]=r.getUniformLocation(t,`offset${f}`,c),e.enableShapeUniforms&&(o[`${f}Shape`]=r.getUniformLocation(t,`${f}Shape`,c),s[`${f}TexShape`]=r.getUniformLocation(t,`${f}TexShape`,c))}return e.enableShapeUniforms&&(i=r.getUniformLocation(t,"outShape",c),l=r.getUniformLocation(t,"outShapeStrides",c),u=r.getUniformLocation(t,"outTexShape",c)),e.customUniforms&&e.customUniforms.forEach((d,f)=>{a[f]=r.getUniformLocation(t,d.name,c)}),{uniformLocations:n,customUniformLocations:a,infLoc:p,nanLoc:m,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:l,outTexShapeLocation:u}}function MO(r,e){if(r.length!==e.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${e.length} inputs`);r.forEach((t,n)=>{let o=t.logicalShape,s=e[n],a=s.shape;if(!y.arraysEqual(o,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${a} must match`);if(t.isUniform&&s.isUniform)return;let i=t.texShape,u=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function PO(r,e,t,n,o){e.program.enableShapeUniforms||(MO(e.inShapeInfos,t),MO([e.outShapeInfo],[n]));let s=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):r.setOutputMatrixTexture(s.texture,a[0],a[1]),r.setProgram(e.webGLProgram),$().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&r.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&r.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,l)=>{let p=e.program.variableNames[l],m=e.uniformLocations[p],c=e.uniformLocations[`offset${p}`],d=e.inShapesLocations[`${p}Shape`],f=e.inTexShapesLocations[`${p}TexShape`];if(d){let{uniformShape:h}=qx(e.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(d,new Int32Array(h));break;case 2:r.gl.uniform2iv(d,new Int32Array(h));break;case 3:r.gl.uniform3iv(d,new Int32Array(h));break;case 4:r.gl.uniform4iv(d,new Int32Array(h));break;default:break}}if(f&&r.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),m!=null){if(u.isUniform){if(y.sizeFromShape(u.shape)<2)r.gl.uniform1f(m,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(m,h)}return}u.texData.slice!=null&&c!=null&&r.gl.uniform1i(c,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture.texture,m,l)}});let i=e.outShapeLocation;if(i)switch(n.shape.length){case 1:r.gl.uniform1iv(i,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(i,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(i,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(i,new Int32Array(n.shape));break;default:break}if(e.outShapeStridesLocation){let u=y.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break;default:break}}e.outTexShapeLocation&&r.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&o&&e.program.customUniforms.forEach((u,l)=>{let p=e.customUniformLocations[l],m=o[l];if(u.type==="float")r.gl.uniform1fv(p,m);else if(u.type==="vec2")r.gl.uniform2fv(p,m);else if(u.type==="vec3")r.gl.uniform3fv(p,m);else if(u.type==="vec4")r.gl.uniform4fv(p,m);else if(u.type==="int")r.gl.uniform1iv(p,m);else if(u.type==="ivec2")r.gl.uniform2iv(p,m);else if(u.type==="ivec3")r.gl.uniform3iv(p,m);else if(u.type==="ivec4")r.gl.uniform4iv(p,m);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function EO(r,e,t){let n="";e.concat(t).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!a.isUniform){let u=a.texData.texShape,{useSqueezeShape:l,uniformShape:p,keptDims:m}=qx(r.packedInputs,a.shape,u),c="",d="",f="";if(p.length===1&&r.packedInputs){let S=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];c=`${S[0]>1}_${S[1]>1}`}else if(p.length===2&&!r.packedInputs)d=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!r.packedInputs){let S=y.computeStrides(p);f=`${S[0]===u[1]}_${S[S.length-1]===u[1]}`}let h=a.shape.length,g=p.length===2&&y.arraysEqual(a.shape,u),b=y.sizeFromShape(a.shape)===1,T=C.getBroadcastDims(a.shape,t.shape),x=!r.packedInputs&&h===t.shape.length&&y.arraysEqual(u,t.texData.texShape),I=r.packedInputs||p.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${x}_${l?m:""}_${p.length}_${b}_${T}_${g}_${c}_${d}_${f}_${I}_${i}`}else{let u=a.isUniform?"uniform":a.texData.texShape;n+=`${a.shape}_${u}_${i}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${$().getNumber("WEBGL_VERSION")}`,s}function Dt(r){return $().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var jx=class{variableNames=["A"];userCode;outputShape;packedInputs=!1;packedOutput=!0;outPackingScheme=0;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e){let t=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Qp(["r","c","d"],e):bi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var Xx=class{variableNames=["A"];userCode;packedInputs=!0;packedOutput=!0;outputShape;outPackingScheme=0;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e){let t=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Qp(["r","c","d"],e):bi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var Yx=class{variableNames=["A"];userCode;outputShape;outTexUsage=3;constructor(e){let t=jt();this.outputShape=e,this.userCode=`
      ${Hx}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var Qx=class{variableNames=["A"];userCode;outputShape;packedInputs=!0;packedOutput=!1;outTexUsage=3;constructor(e){let t=jt();this.outputShape=e,this.userCode=`
      ${Hx}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var Zae={R:0,G:1,B:2,A:3},gg=class{variableNames=["A"];userCode;outputShape;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e,t=!1,n="RGBA"){let o=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let i=0;i<n.length;i++){let u=n[i];a+=`
          if(offset == ${i}) {
            result = values[${Zae[u]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?Cf():If(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${n.length});

        flatIndex = idiv(flatIndex, ${n.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${o.texture2D}(A, uv);
          ${a}
        }
        ${o.output} = vec4(${s}, 0., 0., 0.);
      }
    `}};var Jx=class{variableNames=["A"];userCode;outputShape;packedInputs=!1;packedOutput=!0;enableShapeUniforms;customUniforms=[{name:"texShape",type:"ivec2"}];constructor(e,t=!1){let n=jt();this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let u=a*2+i;o+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Cf():If(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var wD={};qe(wD,{bindVertexProgramAttributeStreams:()=>TD,createBufferFromOutputTexture:()=>CD,createFloat16MatrixTexture:()=>hD,createFloat16PackedMatrixTexture:()=>yD,createFloat32MatrixTexture:()=>fD,createIndexBuffer:()=>dD,createPackedMatrixTexture:()=>bD,createUnsignedBytesMatrixTexture:()=>gD,createVertexBuffer:()=>cD,createVertexShader:()=>mD,downloadByteEncodedFloatMatrixFromOutputTexture:()=>kD,downloadFloat32MatrixFromBuffer:()=>SD,downloadMatrixFromPackedOutputTexture:()=>AD,downloadPackedMatrixFromBuffer:()=>vD,getInternalFormatForFloat16MatrixTexture:()=>tI,getInternalFormatForFloat16PackedMatrixTexture:()=>oI,getInternalFormatForFloat32MatrixTexture:()=>eI,getInternalFormatForPackedMatrixTexture:()=>nI,getInternalFormatForUnsignedBytesMatrixTexture:()=>rI,uploadDenseMatrixToTexture:()=>xD,uploadPixelDataToTexture:()=>ID});function mD(r){let e=jt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return VN(r,t)}function cD(r){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return XN(r,e)}function dD(r){let e=new Uint16Array([0,1,2,2,1,3]);return YN(r,e)}function bg(r,e,t,n,o,s){QN(e,t);let a=ZN(r),i=r.TEXTURE_2D;return xe(r,()=>r.bindTexture(i,a)),xe(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),xe(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),xe(r,()=>r.texParameteri(i,r.TEXTURE_MIN_FILTER,r.NEAREST)),xe(r,()=>r.texParameteri(i,r.TEXTURE_MAG_FILTER,r.NEAREST)),$().getNumber("WEBGL_VERSION")===1?xe(r,()=>r.texImage2D(i,0,n,e,t,0,o,s,null)):xe(r,()=>r.texStorage2D(i,1,n,e,t)),xe(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function eI(r){return r.internalFormatFloat}function fD(r,e,t,n){let[o,s]=Zp(e,t);return bg(r,o,s,eI(n),n.textureFormatFloat,r.FLOAT)}function tI(r){return r.internalFormatHalfFloat}function hD(r,e,t,n){let[o,s]=Zp(e,t);return bg(r,o,s,tI(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function rI(r){return r.downloadTextureFormat}function gD(r,e,t,n){let[o,s]=Zp(e,t);return bg(r,o,s,rI(n),r.RGBA,r.UNSIGNED_BYTE)}function nI(r){return r.internalFormatPackedFloat}function bD(r,e,t,n){let[o,s]=Ki(e,t);return bg(r,o,s,nI(n),r.RGBA,r.FLOAT)}function oI(r){return r.internalFormatPackedHalfFloat}function yD(r,e,t,n){let[o,s]=Ki(e,t);return bg(r,o,s,oI(n),r.RGBA,n.textureTypeHalfFloat)}function TD(r,e,t){return xe(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Ux(r,e,"clipSpacePos",t,3,20,0)&&Ux(r,e,"uv",t,2,20,12)}function xD(r,e,t,n,o,s){xe(r,()=>r.bindTexture(r.TEXTURE_2D,e));let a,i,u;o instanceof Uint8Array?(a=new Uint8Array(t*n*4),i=r.UNSIGNED_BYTE,u=r.RGBA):(a=new Float32Array(t*n*4),i=r.FLOAT,u=s.internalFormatPackedFloat),a.set(o),$().getNumber("WEBGL_VERSION")===2?xe(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t,n,r.RGBA,i,a)):xe(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,t,n,0,r.RGBA,i,a)),xe(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function ID(r,e,t){xe(r,()=>r.bindTexture(r.TEXTURE_2D,e)),t.data instanceof Uint8Array?$().getNumber("WEBGL_VERSION")===2?xe(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t.width,t.height,r.RGBA,r.UNSIGNED_BYTE,t.data)):xe(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,t.data)):$().getNumber("WEBGL_VERSION")===2?xe(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,t)):xe(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)),xe(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function CD(r,e,t,n){let o=r.createBuffer();xe(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let i=4*4*e*t;return xe(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,i,r.STREAM_READ)),xe(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,0)),xe(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function SD(r,e,t){let n=r,o=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function kD(r,e,t,n){let[o,s]=Zp(e,t),a=4,i=new Uint8Array(xO(e*t,a));return xe(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function vD(r,e,t,n,o,s,a,i){let u=r,l=new Float32Array(IO(s,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function AD(r,e,t){let n=new Float32Array(e*t*4);return xe(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,n)),n}var em=class{gl;textureFloatExtension;textureHalfFloatExtension;colorBufferFloatExtension;colorBufferHalfFloatExtension;disjointQueryTimerExtension;parallelCompilationExtension;vertexBuffer;indexBuffer;framebuffer;outputTexture=null;program=null;disposed=!1;disjoint;vertexShader;textureConfig;createVertexArray;bindVertexArray;deleteVertexArray;getVertexArray;constructor(e){let t=$().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,GN(t,e)):this.gl=eo(t),e=this.gl,$().getNumber("WEBGL_VERSION")===2){let s=e;this.createVertexArray=()=>xe(s,()=>s.createVertexArray()),this.bindVertexArray=a=>xe(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>xe(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>xe(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){let s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>xe(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>xe(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>xe(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>xe(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),$().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=bf(this.gl,s),to(this.gl,a))this.textureHalfFloatExtension=bf(this.gl,a);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),to(this.gl,o))this.colorBufferHalfFloatExtension=bf(this.gl,o);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",to(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(to(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=cD(this.gl),this.indexBuffer=dD(this.gl),this.framebuffer=JN(this.gl),this.textureConfig=dg(this.gl,this.textureHalfFloatExtension)}get debug(){return $().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;xe(e,()=>e.finish()),xe(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),xe(e,()=>e.deleteFramebuffer(this.framebuffer)),xe(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),xe(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),xe(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),fD(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),hD(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),gD(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),ID(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,o){this.throwIfDisposed(),xD(this.gl,e,t,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),yD(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),bD(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Kx(this.gl,this.framebuffer),this.outputTexture=null),xe(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>kD(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,o,s,a){return vD(this.gl,e,t,n,o,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return SD(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let o=CD(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if($().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let a=o.clientWaitSync(s,0,0);return a===o.ALREADY_SIGNALED||a===o.CONDITION_SATISFIED},t=s}else $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>AD(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=mD(t));let n=qN(t);xe(t,()=>t.attachShader(n,this.vertexShader)),xe(t,()=>t.attachShader(n,e)),jN(t,n);let o;return o=Object.assign(n,{vao:this.createVertexArray()}),this.bindVertexArray(o.vao),xe(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(TD(t,o,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&fg(t,o),this.setProgram(o),o}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(xe(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&fg(this.gl,this.program)),xe(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?eD(this.gl,e,t):tD(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),xe(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),rD(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[o,s]=Ki(t,n);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,n,o){this.setOutputMatrixWriteRegionDriver(n,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&fg(this.gl,this.program),yf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;if(this.debug){let t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}xe(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),xe(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=bf(this.gl,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}itemsToPoll=[];pollItems(){let e=Qae(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in $().platform&&(n=$().platform.setTimeoutCustom.bind($().platform)),y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),hg(this.gl,e,this.framebuffer),this.debug&&yf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(hg(this.gl,this.outputTexture,this.framebuffer),this.debug&&yf(this.gl)):Kx(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let o=this.gl;hg(o,e,this.framebuffer),this.debug&&yf(o),this.outputTexture=e,xe(o,()=>o.viewport(0,0,t,n)),xe(o,()=>o.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,o){this.throwIfDisposed(),xe(this.gl,()=>this.gl.scissor(e,t,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Qae(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var{addImpl:LO,bincountImpl:sI,bincountReduceImpl:$O,castImpl:BO,ceilImpl:OO,concatImpl:zO,equalImpl:GO,expImpl:WO,expm1Impl:UO,floorImpl:KO,gatherNdImpl:VO,gatherV2Impl:HO,greaterImpl:qO,greaterEqualImpl:jO,lessImpl:XO,lessEqualImpl:YO,linSpaceImpl:ZO,logImpl:QO,maxImpl:JO,maximumImpl:ez,minimumImpl:tz,multiplyImpl:rz,negImpl:nz,notEqualImpl:oz,prodImpl:sz,raggedGatherImpl:az,raggedRangeImpl:iz,raggedTensorToTensorImpl:uz,rangeImpl:lz,rsqrtImpl:pz,scatterImpl:mz,sigmoidImpl:cz,simpleAbsImpl:aI,sliceImpl:dz,sparseFillEmptyRowsImpl:fz,sparseReshapeImpl:hz,sparseSegmentReductionImpl:iI,sqrtImpl:gz,stridedSliceImpl:bz,stringNGramsImpl:yz,stringSplitImpl:Tz,stringToHashBucketFastImpl:xz,subImpl:Iz,tileImpl:Cz,topKImpl:Sz,transposeImpl:tm,uniqueImpl:kz}=ff;function ND(r,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${r}.${t}`)}function ir(r,e){return e===1?[r]:ND(r,e)}function vz(r,e){if(r===1)return"rc";let t="";for(let n=0;n<r;n++)t+=e[n],n<r-1&&(t+=",");return t}var uI=class{variableNames=["A"];outputShape;userCode;packedInputs=!1;packedOutput=!0;enableShapeUniforms;rank;constructor(e){if(this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Dt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=ir("rc",this.rank),n=Ve(this.rank),o=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}};var Nf=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"inputShape",type:"ivec3"}];constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Jae(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Cf():If(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function Jae(r,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?AO(["r","c","d"],"inputShape"):bi(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var lI=class{constructor(e){this.gpgpu=e}numUsedTextures=0;numFreeTextures=0;_numBytesAllocated=0;_numBytesFree=0;freeTextures={};logEnabled=!1;usedTextures={};acquireTexture(e,t,n){let o=wz(t,n),s=Nz(e,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=Az(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let i;return o===3?i=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===4?i=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===1?i=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===0?i=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===2&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(e,t,n,o){if(this.freeTextures==null)return;let s=wz(n,o),a=Nz(t,s,o);a in this.freeTextures||(this.freeTextures[a]=[]);let i=Az(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=$().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let l=this.usedTextures[a],p=l.indexOf(e);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(p,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function eie(r,e){let t=r;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===r.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function Az(r,e,t,n,o){let s=tie(e,n),a;if(o){let[u,l]=Ki(r[0],r[1]);a=u*l}else{let[u,l]=Zp(r[0],r[1]);a=u*l}let i=eie(t,s);return a*i}function tie(r,e){switch(r){case 3:return nI(e);case 4:return oI(e);case 1:return eI(e);case 0:return tI(e);case 2:return rI(e);default:throw new Error(`Unknown physical texture type ${r}`)}}function rie(r){return $().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?3:1:r?4:0}function wz(r,e){if(r===1)return 3;if(r===0||r==null)return rie(e);if(r===3||r===2)return 2;throw new Error(`Unknown logical texture type ${r}`)}function Nz(r,e,t){return`${r[0]}_${r[1]}_${e}_${t}`}var Gr=class{variableNames=["A"];userCode;outputShape;enableShapeUniforms;constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Ir="if (isnan(x)) return x;",Dz="return x;",DD="return abs(x);";var _z="return (x >= 0.0) ? x : (exp(x) - 1.0);",Mz=Ir+`
  return (x < 0.0) ? 0.0 : x;
`,Rz=Ir+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Vi="return x;",Pz="return 1.0 / (1.0 + exp(-1.0 * x));";var Fz="return x;",Lz=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,$z=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Bz=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Oz="return 1.0 / (1.0 + exp(-1.0 * x));",$n=class{variableNames=["A"];userCode;enableShapeUniforms;outputShape;packedInputs=!0;packedOutput=!0;constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var pI=class{variableNames=["A"];packedInputs=!0;packedOutput=!1;outputShape;userCode;enableShapeUniforms;constructor(e){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let t=e.length,n=ir("rc",t),o=Ve(t),s=vz(t,n),a=n.slice(-2),i=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}};var oie=xr.whereImpl,sie=1e-7,aie=1e-4,mI={};function iie(r){return r in mI||(mI[r]={}),mI[r]}var uie=$().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),lie=600;function pie(){return $().global.screen==null?1024:$().global.screen.height*$().global.screen.width*window.devicePixelRatio*lie/1024/1024}var _D=class extends po{texData;gpgpu;nextDataId(){return _D.nextDataId++}pendingRead=new WeakMap;pendingDisposal=new WeakSet;dataRefCount=new WeakMap;numBytesInGPU=0;canvas;programTimersStack;activeTimers;uploadWaitMs=0;downloadWaitMs=0;lastGlFlushTime=0;floatPrecisionValue;textureManager;binaryCache;gpgpuCreatedLocally;numMBBeforeWarning;warnedAboutMemory=!1;constructor(e){if(super(),!$().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof em)t=e;else{let n=eo($().getNumber("WEBGL_VERSION"),e);t=new em(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let n=eo($().getNumber("WEBGL_VERSION"));t=new em(n),this.binaryCache=iie($().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new lI(this.gpgpu),this.numMBBeforeWarning=pie(),this.texData=new ha(this,rn())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,o,s,a){let i=this.makeTensorInfo(t,n),u=this.texData.get(i.dataId);u.isPacked=!1,u.texture={texture:e,texShape:[o,s]},u.texShape=[o,s];let l=Tf(t),p=new gg(l,!1,a),m=this.runWebGLProgram(p,[i],n,[[o,s]]);return m.shape=t,u.texture=null,this.disposeIntermediateTensorInfo(i),m.dataId}write(e,t,n){if(($().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||$().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:t,dtype:n,values:e,usage:1,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,o,s){if($().getBool("DEBUG")&&this.checkNumericalProblems(t),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:o,values:t,usage:1,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:s,slice:a,shape:i,isPacked:u}=t;if(a!=null){let c;u?c=new $n(i,Vi):c=new Gr(i,Vi);let d=this.runWebGLProgram(c,[{dataId:e,shape:i,dtype:o}],o),f=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),f}if(n!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return n;let l=this.activeTimers!=null,p;l&&(p=y.now());let m;if(o==="complex64"){let c=this.readSync(s.real.dataId),d=this.readSync(s.imag.dataId);m=C.mergeRealAndImagArrays(c,d)}else m=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=y.now()-p),this.convertAndCacheOnCPU(e,m)}async read(e){if(this.pendingRead.has(e)){let f=this.pendingRead.get(e);return new Promise(h=>f.push(h))}let t=this.texData.get(e),{values:n,shape:o,slice:s,dtype:a,complexTensorInfos:i,isPacked:u}=t;if(s!=null){let f;u?f=new $n(o,Vi):f=new Gr(o,Vi);let h=this.runWebGLProgram(f,[{dataId:e,shape:o,dtype:a}],a),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(e);if($().getBool("DEBUG")&&!$().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&$().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,p;if(a!=="complex64"&&$().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let f=this.texData.get(p.dataId);l=this.gpgpu.createBufferFromTexture(f.texture.texture,...cg(o))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let m;if(a==="complex64"){let f=await Promise.all([this.read(i.real.dataId),this.read(i.imag.dataId)]),h=f[0],g=f[1];m=C.mergeRealAndImagArrays(h,g)}else if(l==null)m=this.getValuesFromTexture(e);else{let f=y.sizeFromShape(o);m=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(p!=null&&this.disposeIntermediateTensorInfo(p),l!=null){let f=this.gpgpu.gl;xe(f,()=>f.deleteBuffer(l))}let c=this.convertAndCacheOnCPU(e,m),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(f=>f(c)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&rn().removeDataId(e,this),this.pendingDeletes--),c}readToGPU(e,t={}){let n=this.texData.get(e),{values:o,shape:s,slice:a,dtype:i,isPacked:u,texture:l}=n;if(i==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let d;u?d=new $n(s,Vi):d=new Gr(s,Vi);let f=this.runWebGLProgram(d,[{dataId:e,shape:s,dtype:i}],i),h=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),h}if(l==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let p=this.decode(e,t.customTexShape),m=rn().makeTensorFromTensorInfo(p),c=this.texData.get(p.dataId);return{tensorRef:m,...c.texture}}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(o=>y.decodeString(o));return Ie(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ie(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!KN(n))throw $().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:o}=this.texData.get(e),s=y.sizeFromShape(t);if($().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let c=this.decode(e),d=this.texData.get(c.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(d.texture.texture,...cg(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(c),f}let a=$().getBool("WEBGL_PACK")&&o===!0,i=a?Tf(t):t,u=a?new Qx(i):new Yx(i),l=this.runWebGLProgram(u,[{shape:i,dtype:n,dataId:e}],"float32"),p=this.texData.get(l.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),m}timerAvailable(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=y.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=y.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);i.kernelMs=y.sum(u),i.getExtraProfileInfo=()=>u.map((l,p)=>({name:a[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else i.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,i})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(e){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=y.now(),e)}async getQueryTime(e){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}pendingDeletes=0;disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:o,usage:s,isPacked:a,slice:i}=this.texData.get(e),u=i&&i.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(t,o,s,a)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=uie){return $().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&y.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){C.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return oie(e.shape,t)}packedUnaryOp(e,t,n){let o=new $n(e.shape,t),s=this.compileAndRun(o,[e],n);return rn().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let o=aI(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if($().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,DD,e.dtype);let t=new Gr(e.shape,DD),n=this.compileAndRun(t,[e]);return rn().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&y.isString(n[0])){let s=n.map(a=>y.encodeString(a));o=this.write(s,e,t)}else o=this.write(n,e,t);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:t}}makeOutput(e,t,n){return rn().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){let t=new pI(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new uI(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[wu(e.shape),...Nu(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},s=[wu(t),...Nu(t)],a=new Nf(s,n),i=!0,u=[n],l=this.runWebGLProgram(a,[o],e.dtype,u,i);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){let n=this.texData.get(e),{isPacked:o,shape:s,dtype:a}=n;if(t!=null){let c=y.sizeFromShape(s),d=t[0]*t[1]*4;y.assert(c<=d,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let i=Tf(s),u;o?u=new Xx(i):u=new jx(i);let l=!0,p=[t??cg(i)],m=this.runWebGLProgram(u,[{shape:i,dtype:a,dataId:e}],a,p,l,t);return{dtype:a,shape:s,dataId:m.dataId}}runWebGLProgram(e,t,n,o,s=!1,a){let i=this.makeTensorInfo(e.outputShape,n),u=this.texData.get(i.dataId);if(e.packedOutput&&(u.isPacked=!0),e.outPackingScheme===0){let b=a??cg(e.outputShape);u.texShape=b.map(T=>T*2)}if(e.outTexUsage!=null&&(u.usage=e.outTexUsage),y.sizeFromShape(i.shape)===0)return u.values=y.getTypedArrayFromDType(i.dtype,0),i;let l=[],p=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(b.dataId);if(T.texture==null){if(!e.packedInputs&&y.sizeFromShape(b.shape)<=$().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:T.values};e.packedInputs&&(T.isPacked=!0,T.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!T.isPacked!=!!e.packedInputs)b=T.isPacked?this.unpackTensor(b):this.packTensor(b),l.push(b),T=this.texData.get(b.dataId);else if(T.isPacked&&!Bl(T.shape,b.shape)){let x=b,I=b.shape;b.shape=T.shape,b=this.packedReshape(b,I),l.push(b),T=this.texData.get(b.dataId),x.shape=I}return{shape:b.shape,texData:T,isUniform:!1}});this.uploadToGPU(i.dataId);let m={shape:i.shape,texData:u,isUniform:!1},c=EO(e,p,m),d=this.getAndSaveBinary(c,()=>RO(this.gpgpu,e,p,m)),f=this.activeTimers!=null,h;f&&(h=this.startTimer()),$().get("ENGINE_COMPILE_ONLY")||PO(this.gpgpu,d,p,m,o),l.forEach(b=>this.disposeIntermediateTensorInfo(b)),f&&(h=this.endTimer(h),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(h)}));let g=$().get("WEBGL_FLUSH_THRESHOLD");if(g>0){let b=y.now();b-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!$().getBool("WEBGL_LAZILY_UNPACK")&&u.isPacked&&s===!1){let b=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),b}return i}compileAndRun(e,t,n,o,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,o,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}disposed=!1;dispose(){this.disposed||($().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=z(()=>{if(!$().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=$().getBool("DEBUG");$().set("DEBUG",!1);let t=this.abs(ge(1e-8)).dataSync()[0];if($().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?sie:aie}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:o,values:s,texture:a,usage:i,isPacked:u}=t;if(a!=null)return;let l=this.activeTimers!=null,p;l&&(p=y.now());let m=t.texShape;if(m==null&&(m=nD(n,u),t.texShape=m),s!=null){let c=Tf(n),d,f=m[1],h=m[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!g)&&([f,h]=Ki(m[0],m[1])),u?d=new Jx(c,g):d=new gg(c,g);let b=g?[h,f]:m,T=this.makeTensorInfo(b,o),x=this.texData.get(T.dataId);g?x.usage=2:x.usage=1,x.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),f,h,s);let I=[[h,f]],S=!0,w=this.runWebGLProgram(d,[T],o,I,S),_=this.texData.get(w.dataId);t.texShape=_.texShape,t.isPacked=_.isPacked,t.usage=_.usage,$().get("ENGINE_COMPILE_ONLY")?this.disposeData(w.dataId):(t.texture=_.texture,t.values=null,this.texData.delete(w.dataId)),this.disposeIntermediateTensorInfo(T),l&&(this.uploadWaitMs+=y.now()-p)}else{let c=this.acquireTexture(m,i,o,u);t.texture=c}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:o}=n;return t!=null&&(n.values=mie(t,o)),n.values}acquireTexture(e,t,n,o){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,o)}computeBytes(e,t){return e[0]*e[1]*y.bytesPerElement(t)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(let[,t]of Object.entries(this.binaryCache)){let n=new Promise(o=>{try{this.checkCompletion_(t),o(!0)}catch(s){throw s}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Ph(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(Wx(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,e]of Object.entries(this.binaryCache)){let{uniformLocations:t,customUniformLocations:n,infLoc:o,nanLoc:s,inShapesLocations:a,inTexShapesLocations:i,outShapeLocation:u,outShapeStridesLocation:l,outTexShapeLocation:p}=pD(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=n,e.infLoc=o,e.nanLoc=s,e.inShapesLocations=a,e.inTexShapesLocations=i,e.outShapeLocation=u,e.outShapeStridesLocation=l,e.outTexShapeLocation=p}}createTensorFromTexture(e,t,n){let{texture:o,height:s,width:a,channels:i}=e,u=rn().backend;if(!u.gpgpu.gl.isTexture(o))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");let l=u.writeTexture(o,t,n,s,a,i);return rn().makeTensorFromDataId(l,t,n,u)}},Df=_D;K(Df,"nextDataId",0);function mie(r,e){if(e==="float32"||e==="complex64")return r;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<t.length;++n)t[n]=Math.round(r[n]);return t}else throw new Error(`Unknown dtype ${e}`)}var cie="0.0.0";function zz(){$().set("WEBGL_FORCE_F16_TEXTURES",!0)}ul.isBrowser()&&ml("webgl",()=>new Df,2);var n7t={forceHalfFloat:zz};var _f=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var bs=class{variableNames=["A","B"];outputShape;userCode;enableShapeUniforms;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Dt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Hi=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;var la=class{variableNames=["A","B"];outputShape;userCode;supportsBroadcasting=!0;packedInputs=!0;packedOutput=!0;enableShapeUniforms;constructor(e,t,n,o=!1){this.outputShape=C.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=Dt(s);let a="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ve(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=ir("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ur(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var Gz={kernelName:Vn,backendName:"webgl",kernelFunc:ur};function Bn(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),a=t.texData.get(s.dataId),i=ur({inputs:{x:n},backend:t}),u=ur({inputs:{x:o},backend:t});return a.complexTensorInfos={real:i,imag:u},s}var Wz={kernelName:zu,backendName:"webgl",kernelFunc:Bn};var MD="return (a < 0.) ? b * a : a;",RD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function die(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,a=t.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),i=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new la(RD,o.shape,a.shape):new bs(MD,o.shape,a.shape),u=t.runWebGLProgram(i,[o,a],"float32");return t.disposeIntermediateTensorInfo(a),u}var Uz={kernelName:Ro,backendName:"webgl",kernelFunc:die};var PD="return (a < 0.) ? b * a : a;",ED=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function fie(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new la(ED,n.shape,o.shape):new bs(PD,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],"float32")}var Kz={kernelName:Vo,backendName:"webgl",kernelFunc:fie};var pa="if (isnan(x)) return x;";function Ae({opSnippet:r,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:o,backend:s})=>{let{x:a}=o,i=s,u=n||a.dtype;if(i.shouldExecuteOnCPU([a])&&t!=null){let m=i.texData.get(a.dataId),c=t(m.values,u);return i.makeTensorInfo(a.shape,u,c)}let l=$().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,p;return l?p=new $n(a.shape,e):p=new Gr(a.shape,r),i.runWebGLProgram(p,[a],u)}}function dt({opSnippet:r,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:a,backend:i})=>{let{a:u,b:l}=a,p=i;if(n&&u.dtype==="complex64"){let f=p.texData.get(u.dataId),h=p.texData.get(l.dataId),[g,b]=[[f.complexTensorInfos.real,h.complexTensorInfos.real],[f.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(x=>{let[I,S]=x,w={dataId:I.dataId,dtype:I.dtype,shape:u.shape},_={dataId:S.dataId,dtype:S.dtype,shape:l.shape},M=new bs(r,u.shape,l.shape);return p.runWebGLProgram(M,[w,_],Pt(I.dtype,S.dtype))}),T=Bn({inputs:{real:g,imag:b},backend:p});return p.disposeIntermediateTensorInfo(g),p.disposeIntermediateTensorInfo(b),T}let m=s||Pt(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||p.shouldExecuteOnCPU([u,l]))&&o!=null){let f=p.texData.get(u.dataId).values,h=p.texData.get(l.dataId).values,g=u.dtype==="string"?C.fromUint8ToStringArray(f):f,b=u.dtype==="string"?C.fromUint8ToStringArray(h):h,[T,x]=o(u.shape,l.shape,g,b,m),I=p.makeTensorInfo(x,m),S=p.texData.get(I.dataId);return S.values=T,I}let c=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,d;return c?d=new la(e,u.shape,l.shape,t):d=new bs(r,u.shape,l.shape),p.runWebGLProgram(d,[u,l],m)}}function Du(r,e=!1){if(r==="linear")return e?Fz:Dz;if(r==="relu")return e?$z:Mz;if(r==="elu")return e?Lz:_z;if(r==="relu6")return e?Bz:Rz;if(r==="prelu")return e?ED:PD;if(r==="leakyrelu")return e?RD:MD;if(r==="sigmoid")return e?Oz:Pz;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var Mf=class{variableNames=["matrixA","matrixB"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;constructor(e,t,n,o=!1,s=!1,a=!1,i=null,u=!1,l=!1){this.outputShape=n,this.enableShapeUniforms=Dt(this.outputShape.length);let p=o?e[1]:e[2],m=Math.ceil(p/2),c=o?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",f=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",b="";i&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,b="result = activation(result);");let T=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let x="rc.x",I="rc.x";e[0]<t[0]?x=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(I=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${m}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${m}; i++) {
          int batchA = ${x};
          int batchB = ${I};
          vec4 a = getMatrixA(batchA, ${c});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${h[0]});
          result += (${f[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${b}

        setOutput(result);
      }
    `}};var FD={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},yg=class{variableNames=["AReal","AImag","BReal","BImag"];userCode;outputShape;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var Vz="return a * b;";function Tg(r){let{inputs:e,backend:t}=r,{a:n,b:o}=e,s=C.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let i=t.texData.get(n.dataId),u=t.texData.get(o.dataId),l=new yg(FD.REAL,n.shape,o.shape),p=new yg(FD.IMAG,n.shape,o.shape),m=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:n.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],c=t.runWebGLProgram(l,m,"float32"),d=t.runWebGLProgram(p,m,"float32"),f=Bn({inputs:{real:c,imag:d},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),f}if(t.shouldExecuteOnCPU([n,o])){let i=t.texData.get(n.dataId),u=t.texData.get(o.dataId),[l,p]=rz(n.shape,o.shape,i.values,u.values,s),m=t.makeTensorInfo(p,s),c=t.texData.get(m.dataId);return c.values=l,m}let a;return $().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new la(Vz,n.shape,o.shape):a=new bs(Vz,n.shape,o.shape),t.runWebGLProgram(a,[n,o],s)}var Hz={kernelName:Go,backendName:"webgl",kernelFunc:Tg};function qz(r,e,t){let n=[wu(r.shape),...Nu(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[wu(e),...Nu(e)],a=new Nf(s,n),i=!0,u=[n],l=t.runWebGLProgram(a,[o],r.dtype,u,i);return{dataId:l.dataId,shape:e,dtype:l.dtype}}function ue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,a=t,i=y.sizeFromShape(o.shape),u=y.inferFromImplicitShape(s,i),l=y.sizeFromShape(u);y.assert(i===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let p=a.texData.get(o.dataId);return p.isPacked&&!Bl(o.shape,u)&&!(p.texture!==null&&Bl(p.shape,u))?qz(o,u,a):(a.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var jz={kernelName:Ns,backendName:"webgl",kernelFunc:ue};var xg=class{variableNames=["x"];outputShape;userCode;constructor(e,t){let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(t!=null){let m=1/t;l=`sumValue += dot(values * ${y.isInt(m)?m.toPrecision(2):m}, ones);`}let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var cI=class{variableNames=["x"];outputShape;userCode;constructor(e,t){let{windowSize:n,batchSize:o,inSize:s,outSize:a}=e;this.outputShape=[o,a];let i="0.0",u="";t==="prod"?i="1.0":t==="min"?(i="1.0 / 1e-20",u="min"):t==="max"&&(i="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let p=Math.floor(n/4)*4,m=n%4,c=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(i="1.0",c=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(i="0.0",c=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${p};
        if (${m===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${m===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${m===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${c}
        }
        setOutput(${l});
      }
    `}};function gie(r){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:r[1],n=C.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function ro(r,e,t,n){let o=gie(r.shape),s=r;for(let a=0;a<o.length;a++){let{inSize:i,windowSize:u,outSize:l}=o[a],p,m;t==="mean"?p=a===0?new xg({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l},i):new xg({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l}):p=new cI({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:l},t),m=s,s=n.runWebGLProgram(p,[s],e),m.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(m)}return s}var dI=class{variableNames=["A"];outputShape;userCode;rank;constructor(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=bie(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function bie(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let o=0;o<r.length;o++)n[r[o]]=t[o];return n.join()}var fI=class{variableNames=["A"];outputShape;userCode;rank;packedInputs=!0;packedOutput=!0;constructor(e,t){let n=new Array(e.length);for(let p=0;p<n.length;p++)n[p]=e[t[p]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Ve(this.rank),s=ND("rc",this.rank),a=new Array(this.rank);for(let p=0;p<t.length;p++)a[t[p]]=s[p];let i=`vec2(${a.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function Ol(r,e,t){let n=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fI(r.shape,e):new dI(r.shape,e);return t.runWebGLProgram(n,[r],r.dtype)}function Xz(r,e,t,n){let o=e,s=r.shape.length,a=y.parseAxisParam(o,r.shape),i=a,u=C.getAxesPermutation(i,s),l=u!=null,p=r;l&&(p=Ol(r,u,n),i=C.getInnerMostAxes(i.length,s)),C.assertAxesAreInnerMostDims("sum",i,s);let[m,c]=C.computeOutAndReduceShapes(p.shape,i),d=m;t&&(d=C.expandShapeToKeepDim(m,a));let f=y.sizeFromShape(c),g=y.sizeFromShape(r.shape)/f,b=ue({inputs:{x:p},attrs:{shape:[g,f]},backend:n}),T=iu(r.dtype),x=ro(b,T,"sum",n),I=ue({inputs:{x},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),l&&n.disposeIntermediateTensorInfo(p),I}function rm(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return Xz(o,s,a,t)}var Yz={kernelName:ns,backendName:"webgl",kernelFunc:rm};function Wt(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,a=t,i=o.shape.length,u=new Array(i);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];let l;if(a.shouldExecuteOnCPU([o])){let m=a.texData.get(o.dataId).values,c=tm(m,o.shape,o.dtype,s,u);l=a.makeTensorInfo(u,o.dtype);let d=a.texData.get(l.dataId);d.values=c}else l=Ol(o,s,a);return l}var Zz={kernelName:_n,backendName:"webgl",kernelFunc:Wt};var LD=1e3;function nm({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,m=t?r.shape[l-2]:r.shape[l-1],c=n?e.shape[p-1]:e.shape[p-2],d=t?r.shape[l-1]:r.shape[l-2],f=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),b=y.sizeFromShape(h),T=y.sizeFromShape(g),I=Dr.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);y.assert(m===c,()=>`Error in matMul: inner shapes (${m}) and (${c}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let S=t?[b,m,d]:[b,d,m],w=n?[T,f,c]:[T,c,f],_=ue({inputs:{x:r},backend:o,attrs:{shape:S}}),M=ue({inputs:{x:e},backend:o,attrs:{shape:w}}),R=[_,M],E=Math.max(b,T),O=t?_.shape[1]:_.shape[2],G=s!=null,W=a!=null,H=u==="leakyrelu",U=u!=null?Du(u,!0):null,V=G||W||H||U!=null,Y;if((d===1||f===1)&&O>LD&&V===!1){let te=_,ne=M;t&&(te=Wt({inputs:{x:_},backend:o,attrs:{perm:[0,2,1]}}),R.push(te)),n&&(ne=Wt({inputs:{x:M},backend:o,attrs:{perm:[0,2,1]}}),R.push(ne));let oe=f!==1,ae=f===1,se=te;oe&&(se=ue({inputs:{x:te},backend:o,attrs:{shape:[E,O,1]}}),R.push(se));let ie=f===1?2:1,he=ne;ae&&(he=ue({inputs:{x:ne},backend:o,attrs:{shape:[E,1,O]}}),R.push(he));let Te=Tg({inputs:{a:se,b:he},backend:o});Y=rm({inputs:{x:Te},backend:o,attrs:{axis:ie,keepDims:!0}}),R.push(Te)}else{let te=Pt(r.dtype,e.dtype),ne=new Mf(S,w,[E,d,f],t,n,G,U,W,H),oe=[_,M];if(s!=null&&oe.push(s),W&&oe.push(a),H){let ae=o.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));oe.push(ae),R.push(ae)}Y=o.runWebGLProgram(ne,oe,te)}let j=ue({inputs:{x:Y},backend:o,attrs:{shape:I}});R.push(Y);for(let te of R)o.disposeIntermediateTensorInfo(te);return j}function yie(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n;return nm({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:m,activation:p})}var Qz={kernelName:Ls,backendName:"webgl",kernelFunc:yie};var Jz="return abs(x);";function Tie(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=t.texData.get(n.dataId),a=aI(s.values);return t.makeTensorInfo(n.shape,n.dtype,a)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new $n(n.shape,Jz):o=new Gr(n.shape,Jz),t.runWebGLProgram(o,[n],n.dtype)}var e3={kernelName:xs,backendName:"webgl",kernelFunc:Tie};var xie=Ir+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Iie=Ae({opSnippet:xie}),t3={kernelName:ya,backendName:"webgl",kernelFunc:Iie};var Cie=Ir+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Sie=Ae({opSnippet:Cie}),r3={kernelName:Ta,backendName:"webgl",kernelFunc:Sie};var n3="return a + b;",kie=dt({opSnippet:n3,packedOpSnippet:n3,supportsComplex:!0,cpuKernelImpl:LO}),o3={kernelName:Nn,backendName:"webgl",kernelFunc:kie};var hI=class{variableNames;outputShape=[];userCode;constructor(e,t){this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var gI=class{variableNames;outputShape=[];userCode;packedInputs=!0;packedOutput=!0;constructor(e,t){this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function bI(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return ur({inputs:{x:n[0]},backend:t});if(n.length>$().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=bI({inputs:n.slice(0,u),backend:t}),p=bI({inputs:n.slice(u),backend:t});return bI({inputs:[l,p],backend:t})}let o=n.map(u=>u.dtype).reduce((u,l)=>Pt(u,l)),s=n.map(u=>u.shape),i=$().getBool("WEBGL_PACK")?new gI(n[0].shape,s):new hI(n[0].shape,s);return t.runWebGLProgram(i,n,o)}var s3={kernelName:co,backendName:"webgl",kernelFunc:bI};function vie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=C.getInnerMostAxes(l.length,i)),C.assertAxesAreInnerMostDims("all",l,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,l),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,f]}}),g=ro(h,h.dtype,"all",t),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:t,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(m),b}var a3={kernelName:xa,backendName:"webgl",kernelFunc:vie};function Aie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=C.getInnerMostAxes(l.length,i)),C.assertAxesAreInnerMostDims("any",l,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,l),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,f]}}),g=ro(h,h.dtype,"any",t),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:t,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(m),b}var i3={kernelName:Ia,backendName:"webgl",kernelFunc:Aie};var yI=class{variableNames=["A"];outputShape;userCode;constructor(e,t,n){let{windowSize:o,batchSize:s,outSize:a}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=t==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var TI=class{variableNames=["A"];outputShape;userCode;packedInputs=!0;packedOutput=!0;constructor(e,t,n,o){y.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),o||this.variableNames.push("bestIndicesA");let i=this.outputShape,u=i.length,l=Ve(u),p=ir("coords",u),m,c;if(a===1){c=u+1;let M=Ve(c);m=`
        ${M} sourceLocR = ${M}(${p.join()}, 0);
        ++${p[u-1]};
        ${M} sourceLocG = ${M}(${p.join()}, 0);
        ++${p[u-2]};
        ${M} sourceLocA = ${M}(${p.join()}, 0);
        --${p[u-1]};
        ${M} sourceLocB = ${M}(${p.join()}, 0);
        --${p[u-2]};`}else c=u,m=`
        ${l} sourceLocR = coords;
        ++${p[u-1]};
        ${l} sourceLocG = coords;
        ++${p[u-2]};
        ${l} sourceLocA = coords;
        --${p[u-1]};
        ${l} sourceLocB = coords;
        --${p[u-2]};`;let d=["x","y","z","w","u","v"].slice(0,c),f="."+d[c-1],h=d.map(M=>"int "+M),g=ir("sourceLocR",c-1).concat("inIdx.r"),b=ir("sourceLocG",c-1).concat("inIdx.g"),T=ir("sourceLocB",c-1).concat("inIdx.b"),x=ir("sourceLocA",c-1).concat("inIdx.a"),I=n==="max"?"greaterThan":"lessThan",S=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${x.join()})));`,w=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,_=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${_}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${p[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${p[u-2]} < ${i[u-2]-1};
        ${m}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${S}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function u3(r,e,t,n=null){let o=e.shape[0],s=e.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let a=C.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:o,outSize:Math.ceil(s/a)},u=new yI(i,t,n==null),l=[e];n!=null&&l.push(n);let p=r.runWebGLProgram(u,l,"int32");if(p.shape[1]===1)return p;let m=u3(r,e,t,p);return r.disposeIntermediateTensorInfo(p),m}function l3(r,e,t,n=null){let o=n!=null?n.shape:e.shape,s=o[o.length-1],a=C.computeOptimalWindowSize(s),i=new TI(o,a,t,n==null),u=n==null?[e]:[e,n],l=r.runWebGLProgram(i,u,"int32");if(l.shape.length===e.shape.length){let p=l3(r,e,t,l);return r.disposeIntermediateTensorInfo(l),p}return l}function xI(r,e,t,n){let o=[t];if(C.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.shape.length),!$().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],a=r.texData.get(e.dataId),i=a!==null&&a.isPacked,u=e;i&&(u=r.unpackTensor(e),s.push(u));let[l,p]=C.computeOutAndReduceShapes(u.shape,o),m=y.sizeFromShape(p),c=ue({inputs:{x:u},backend:r,attrs:{shape:[-1,m]}});s.push(c);let d=u3(r,c,n);s.push(d);let f=ue({inputs:{x:d},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),f}return l3(r,e,n)}function wie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=Wt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let p=xI(t,u,a[0],"max");return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}var p3={kernelName:fo,backendName:"webgl",kernelFunc:wie};function Nie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=Wt({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let p=xI(t,u,a[0],"min");return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),p}var m3={kernelName:vi,backendName:"webgl",kernelFunc:Nie};var Die=Ir+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,_ie=Ae({opSnippet:Die}),c3={kernelName:Ca,backendName:"webgl",kernelFunc:_ie};var Mie=Ir+"return log(x + sqrt(x * x + 1.0));",Rie=Ae({opSnippet:Mie}),d3={kernelName:Sa,backendName:"webgl",kernelFunc:Rie};var Pie=Ir+`
  return atan(x);
`,Eie=Ae({opSnippet:Pie}),f3={kernelName:ka,backendName:"webgl",kernelFunc:Eie};var Fie=_f+`
  return atan(a, b);
`,Lie=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hi+`
  return result;
`,$ie=dt({opSnippet:Fie,packedOpSnippet:Lie}),h3={kernelName:Aa,backendName:"webgl",kernelFunc:$ie};var Bie=Ir+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Oie=Ae({opSnippet:Bie}),g3={kernelName:va,backendName:"webgl",kernelFunc:Oie};var yi=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n,o=!1,s=!1){if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,p=e.dilationWidth,m=e.effectiveFilterHeight,c=e.effectiveFilterWidth,d=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,b=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,T="0.0";if(h||(T="-1.0 / 1e-20"),n){let M=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${c};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${M} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:b:`wR * ${c} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",I=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(I="avgValue / count");let S=Math.floor(a/4)*4,w=a%4,_=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${m};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${S}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${_}
          }

          int xC = xCCorner + ${S};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${_}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${_}
          }
        }
        setOutput(${I});
      }
    `}},zl=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n,o=!1,s=!1){if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=e.filterWidth,i=e.strideDepth,u=e.strideHeight,l=e.strideWidth,p=e.dilationDepth,m=e.dilationHeight,c=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,b=e.padInfo.top,T=e.padInfo.left;this.outputShape=e.outShape;let x=t==="avg",I="0.0";if(x||(I="-1.0 / 1e-20"),n){let E=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${b}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${m}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${c}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${E} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let S="max",w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / count");let _=Math.floor(a/4)*4,M=a%4,R=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${b}, ${T});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${m}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${_}; wC += 4) {
              int xC = xCCorner + wC * ${c};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                getValue(batch, xD, xR, xC + 3 * ${c}, ch)
              );

              ${R}
            }

            int xC = xCCorner + ${_};
            if (${M===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${M===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                initializationValue,
                initializationValue
              );

              ${R}
            } else if (${M===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                initializationValue
              );

              ${R}
            }
          }
          setOutput(${w});
        }
      }
    `}};function zie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;gi(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u);if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))return ur({inputs:{x:o},backend:t});let m=new yi(p,"avg",!1);return t.runWebGLProgram(m,[o],"float32")}var b3={kernelName:ho,backendName:"webgl",kernelFunc:zie};function Gie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:l}=n,p=[1,1,1],m=C.computePool3DInfo(o.shape,s,a,p,i,u,l),c=new zl(m,"avg",!1);return t.runWebGLProgram(c,[o],"float32")}var y3={kernelName:Bu,backendName:"webgl",kernelFunc:Gie};var II=class{variableNames=["dy"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=u-1-e.padInfo.top,m=l-1-e.padInfo.left,c=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${p}, ${m});
      const float avgMultiplier = float(${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},CI=class{variableNames=["dy"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,m=e.effectiveFilterDepth,c=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=m-1-e.padInfo.front,h=c-1-e.padInfo.top,g=d-1-e.padInfo.left,b=1/(t*n*o);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${h}, ${g});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Wie(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:p}=n,m=[1,1,1],c=C.computePool3DInfo(a.shape,i,u,m,l,p),d=new CI(c);return t.runWebGLProgram(d,[o],a.dtype)}var T3={kernelName:wm,backendName:"webgl",kernelFunc:Wie};function Uie(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s;gi([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:l}=n,p=C.computePool2DInfo(a.shape,i,u,1,l),m=new II(p);return t.runWebGLProgram(m,[o],a.dtype)}var x3={kernelName:Am,backendName:"webgl",kernelFunc:Uie};function Kie(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;return nm({a:o,b:s,transposeA:a,transposeB:i,backend:t})}var I3={kernelName:go,backendName:"webgl",kernelFunc:Kie};var SI=class{variableNames;outputShape=[];userCode;constructor(e,t,n,o,s,a){this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n);let i="0.0";o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var kI=class{variableNames;outputShape;userCode;packedInputs=!0;packedOutput=!0;constructor(e,t,n,o,s,a){this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n);let i="vec4(0.0)";o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var Vie=({inputs:r,backend:e,attrs:t})=>{let{x:n,mean:o,variance:s,offset:a,scale:i}=r;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);let l=[n,o,s],p=null;a!=null&&(p=a.shape,l.push(a));let m=null;i!=null&&(m=i.shape,l.push(i));let c=$().getBool("WEBGL_PACK_NORMALIZATION")?new kI(n.shape,o.shape,s.shape,p,m,u):new SI(n.shape,o.shape,s.shape,p,m,u);return e.runWebGLProgram(c,l,l[0].dtype)},C3={kernelName:Do,backendName:"webgl",kernelFunc:Vie};var vI=class{variableNames=["source"];outputShape;userCode;rank;customUniforms;constructor(e){this.outputShape=e,this.rank=e.length;let t=Ve(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=Hie(this.rank),o,s=e.map((a,i)=>`sourceLoc.${$D[i]} = start[${i}] + coords.${$D[i]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},$D=["x","y","z","w","u","v"];function Hie(r){if(r===1)return"sourceLoc";if(r<=6)return $D.slice(0,r).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var AI=class{variableNames=["source"];packedInputs=!0;packedOutput=!0;outputShape;userCode;rank;customUniforms;constructor(e){this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=Ve(this.rank),n=ir("coords",this.rank),o=ir("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,a=`getChannel(getSource(${o.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${a};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((p,m)=>`start[${m}]`).join()});`:e.map((p,m)=>`${o[m]} = ${n[m]} + start[${m}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}};function qie(r,e,t,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(t,r.dtype),a=n.texData.get(s.dataId);Object.assign(a,o),a.refCount=1,a.shape=t,a.dtype=r.dtype;let i=It.computeFlatOffset(e,y.computeStrides(r.shape));o.slice&&(i+=o.slice.flatOffset),a.slice={flatOffset:i,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,u+1),s}function Ti(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n,[i,u]=It.parseSliceParams(o,s,a);if(It.assertParamsValid(o,i,u),y.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let m=t.texData.get(o.dataId),c=dz(m.values,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,c)}let{isPacked:l}=t.texData.get(o.dataId),p=It.isSliceContinous(o.shape,i,u);if(l||!p){let m=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new AI(u):new vI(u),c=[i];return t.runWebGLProgram(m,[o],o.dtype,c)}return t.uploadToGPU(o.dataId),qie(o,i,u,t)}var S3={kernelName:_s,backendName:"webgl",kernelFunc:Ti};var jie=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((T,x)=>T*x),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=[],f=ue({inputs:{x:o},backend:t,attrs:{shape:u}}),h=Wt({inputs:{x:f},backend:t,attrs:{perm:l}}),g=ue({inputs:{x:h},backend:t,attrs:{shape:p}}),b=Ti({inputs:{x:g},backend:t,attrs:{begin:m,size:c}});return d.push(f),d.push(h),d.push(g),d.forEach(T=>t.disposeIntermediateTensorInfo(T)),b},k3={kernelName:Is,backendName:"webgl",kernelFunc:jie};function Xie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=t.readSync(o.dataId),u=t.readSync(s.dataId),l=sI(i,u,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}var v3={kernelName:Ou,backendName:"webgl",kernelFunc:Xie};function Yie(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.readSync(n.dataId),a=t.readSync(o.dataId),i=C.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return t.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var A3={kernelName:Nm,backendName:"webgl",kernelFunc:Yie};var Zie="return float(a != b);",BD=dt({opSnippet:Zie,cpuKernelImpl:oz,dtype:"bool"}),w3={kernelName:Ka,backendName:"webgl",kernelFunc:BD};function _u(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ur({inputs:{x:o.complexTensorInfos.real},backend:t})}var N3={kernelName:Zu,backendName:"webgl",kernelFunc:_u};var Qie="return float(int(x));";function D3(r,e){let t=new Gr(r.shape,Qie),n=e.runWebGLProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function OD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return ur({inputs:{x:o},backend:t});let a=Ct(o.shape),i=OD({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=Bn({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(i),u}if(o.dtype==="complex64"){let a=_u({inputs:{input:o},backend:t}),i=OD({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=ur({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(t.shouldExecuteOnCPU([o])){let a=t.texData.get(o.dataId).values,[i,u,l]=BO(a,o.shape,o.dtype,s);return t.makeTensorInfo(i,u,l)}if(s==="int32")return D3(o,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),u=BD({inputs:{a:o,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var _3={kernelName:Un,backendName:"webgl",kernelFunc:OD};var M3="return ceil(x);",Jie=Ae({opSnippet:M3,packedOpSnippet:M3,cpuKernelImpl:OO}),R3={kernelName:bo,backendName:"webgl",kernelFunc:Jie};var wI=class{variableNames=["A"];userCode;outputShape;customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];constructor(e){this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var NI=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;userCode;outputShape;customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];constructor(e){this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function eue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i;$().getBool("WEBGL_PACK_CLIP")?i=new NI(o.shape):i=new wI(o.shape);let u=[[s],[a]];return t.runWebGLProgram(i,[o],o.dtype,u)}var P3={kernelName:Kn,backendName:"webgl",kernelFunc:eue};var DI=class{variableNames=["real","imag"];userCode;outputShape;constructor(e){this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function E3(r,e){return{dataId:e.dataId,dtype:e.dtype,shape:r.shape}}function tue(r){let{inputs:e,backend:t}=r,{x:n}=e,o=t.texData.get(n.dataId),s=new DI(n.shape),a=[E3(n,o.complexTensorInfos.real),E3(n,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,a,a[0].dtype)}var F3={kernelName:Gu,backendName:"webgl",kernelFunc:tue};var _I=class{variableNames;outputShape=[];userCode;constructor(e){this.outputShape=C.computeOutShape(e,1),this.variableNames=e.map((a,i)=>`T${i}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){let i=t[a-1];n.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let o=t.length,s=t[t.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var RI=class{variableNames;packedInputs=!0;packedOutput=!0;outputShape=[];userCode;constructor(e,t){this.outputShape=C.computeOutShape(e,t);let n=this.outputShape,o=n.length,s=Ve(o),a=ir("coords",o),i=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let u=new Array(e.length-1);u[0]=e[0][t];for(let h=1;h<u.length;h++)u[h]=u[h-1]+e[h][t];let l=i[t],p=i.slice(-2),m=i.join(),c=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${m}), vec2(${p.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];c+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${MI(i,l,g)}),
            vec2(${MI(p,l,g)}));
        }`}let d=u.length,f=u[u.length-1];c+=`
        return getChannel(
          getT${d}(${MI(i,l,f)}),
          vec2(${MI(p,l,f)}));`,this.userCode=`
      float getValue(${i.map(h=>"int "+h)}) {
        ${c}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[o-1]} = ${a[o-1]} + 1;
        if (${a[o-1]} < ${n[o-1]}) {
          result.g = getValue(${a});
        }

        ${a[o-2]} = ${a[o-2]} + 1;
        if (${a[o-2]} < ${n[o-2]}) {
          result.a = getValue(${a});
        }

        ${a[o-1]} = ${a[o-1]} - 1;
        if (${a[o-2]} < ${n[o-2]} &&
            ${a[o-1]} < ${n[o-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function MI(r,e,t){let n=r.indexOf(e);return r.map((s,a)=>a===n?`${s} - ${t}`:s).join()}function om(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ur({inputs:{x:o.complexTensorInfos.imag},backend:t})}var L3={kernelName:ju,backendName:"webgl",kernelFunc:om};function Rf(r,e,t){let n=r[0].dtype;if(n==="complex64"){let d=r.map(T=>_u({inputs:{input:T},backend:t})),f=r.map(T=>om({inputs:{input:T},backend:t})),h=Rf(d,e,t),g=Rf(f,e,t),b=Bn({inputs:{real:h,imag:g},backend:t});return d.forEach(T=>t.disposeIntermediateTensorInfo(T)),f.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),b}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let d=r.map(I=>{let w=[-1,y.sizeFromShape(I.shape.slice(e))];return ue({inputs:{x:I},backend:t,attrs:{shape:w}})}),f=d.map(I=>({vals:t.readSync(I.dataId),shape:I.shape})),h=C.computeOutShape(d.map(I=>I.shape),1),g=d[0].shape[0]===1,b=zO(f,h,n,g),T=C.computeOutShape(r.map(I=>I.shape),e),x=t.makeTensorInfo(T,n,b);return d.forEach(I=>t.disposeIntermediateTensorInfo(I)),x}let s=r.filter(d=>y.sizeFromShape(d.shape)>0),a=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){let d=a?new Gr(r[0].shape,Vi):new $n(r[0].shape,Vi);return t.runWebGLProgram(d,r,n)}let i=$().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>i){let d=[];for(let h=0;h<s.length;h+=i){let g=s.slice(h,h+i);d.push(Rf(g,e,t))}let f=Rf(d,e,t);for(let h of d)t.disposeIntermediateTensorInfo(h);return f}if(a){let d=new RI(s.map(f=>f.shape),e);return t.runWebGLProgram(d,s,n)}let{tensors2D:u,outShape:l}=rue(s,e,t),p=new _I(u.map(d=>d.shape)),m=t.runWebGLProgram(p,u,n);u.forEach(d=>t.disposeIntermediateTensorInfo(d));let c=ue({inputs:{x:m},attrs:{shape:l},backend:t});return t.disposeIntermediateTensorInfo(m),c}function rue(r,e,t){let n=C.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>ue({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:n}}function zD(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=e.map(l=>l.shape);C.assertParamsConsistent(a,s);let i=C.computeOutShape(e.map(l=>l.shape),s);if(y.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let u=e.filter(l=>y.sizeFromShape(l.shape)>0);return u.length===1?ur({inputs:{x:u[0]},backend:t}):Rf(u,s,t)}var $3={kernelName:Cs,backendName:"webgl",kernelFunc:zD};var Pf=class{variableNames=["x","W"];outputShape;userCode;constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape;let a=e.padInfo.top,i=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,p=e.dilationHeight,m=e.dilationWidth,c=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",b=g?1:2,T=g?2:3,x=g?3:1,I="",S="";n&&(o?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:I=`
          float activation(float x) {
            ${n}
          }
        `,S="result = activation(result);");let w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${m};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${S}
        setOutput(result);
      }
    `}},PI=class{variableNames=["x","W"];outputShape;userCode;constructor(e){this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,m=e.filterDepth,c=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${t}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${m}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Ef=class{variableNames=["x","W"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape,this.enableShapeUniforms=Dt(this.outputShape.length);let a=e.padInfo.left,i=e.strideWidth,u=e.dilationWidth,l=e.filterHeight,p=e.filterWidth,m=p,c=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<p;g++)c+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;c+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let g=0;g<p;g++)c+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;c+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(m+1)/2;g++){let b=g*2;if(c+=`
           xC = xCCorner + ${b*u};
           `,i===1){if(b<p&&(a%2===1?(c+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,u===1&&b>0?c+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:c+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):c+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<p)){let T=a%2===0?y.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(c+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,u>1?c+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:c+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):T===1?c+=`
                     xC${b+1} = xTexelC${b};
                     `:c+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<p&&(a%2===1?(c+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<p&&(c+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(c+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<p&&(c+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<p&&(c+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<p&&(c+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}c+=`
     }
   `,c+=`
     }
   `,c+=`
     }
   `;let d="",f="";n&&(o?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,f="result = activation(result);");let h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${c}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${f}
         setOutput(result);
       }
     `}};var EI=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}];constructor(e,t){this.outputShape=e,this.enableShapeUniforms=Dt(this.outputShape.length);let{dataFormat:n}=t,o=jt(),s=n==="channelsLast",a=s?1:2,i=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`,l="";for(let p=0;p<=1;p++)for(let m=0;m<=1;m++)l+=`
          blockIndex = rc.z + ${m};
          pos = rc.y + ${p};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${p*2+m}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${p*2+m}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function FI(r,e){let t=r.length;return t>=3?e?[...r.slice(0,-3),r[t-3]*r[t-2],r[t-1]]:[...r.slice(0,-3),r[t-3],r[t-2]*r[t-1]]:!e&&t===1&&r[0]>1?[r[0],1]:null}function LI({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=r.shape,l=n.texData.get(r.dataId),p=t.inChannels,m=u[0]*u[1]*u[2],c=t.outChannels,d=t.dataFormat==="channelsLast",f=!1,h=!1,g,b=[];if(s!=null){let I=FI(s.shape,d);I!=null&&(s=ue({inputs:{x:s},backend:n,attrs:{shape:I}}),b.push(s))}if(o!=null){let I=FI(o.shape,d);I!=null&&(o=ue({inputs:{x:o},backend:n,attrs:{shape:I}}),b.push(o))}if(!((m===1||c===1)&&p>LD)&&l.isPacked&&d&&l.texture!=null&&u[2]%2!==0&&y.arraysEqual(l.shape.slice(-3),u.slice(-3))){let I=u[0]*u[1]*(u[2]+1),S={dataId:r.dataId,shape:[1,I,t.inChannels],dtype:r.dtype},w=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,y.assert(Bl(l.shape,S.shape),()=>`packed reshape ${l.shape} to ${S.shape} isn't free`);let _=ue({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(_);let M=nm({a:S,b:_,backend:n,transposeA:f,transposeB:h,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),R=n.texData.get(M.dataId);y.assert(R.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=w,R.shape=t.outShape,g=ur({inputs:{x:M},backend:n}),g.shape=t.outShape,b.push(M)}else{let I=t.outHeight*t.outWidth,S=ue({inputs:{x:r},backend:n,attrs:{shape:d?[t.batchSize,I,t.inChannels]:[t.batchSize,t.inChannels,I]}}),w=ue({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),_=nm({a:d?S:w,b:d?w:S,transposeA:!d,transposeB:h,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});g=ue({inputs:{x:_},backend:n,attrs:{shape:t.outShape}}),b.push(S),b.push(w),b.push(_)}for(let I of b)n.disposeIntermediateTensorInfo(I);return g}function $I({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:p,outWidth:m,outHeight:c,dataFormat:d}=t,f=d==="channelsLast",h=u*l*p,g=c*m,b=[t.batchSize,h,g],T=!0,x=!1,I=[];if(s!=null){let j=FI(s.shape,f);j!=null&&(s=ue({inputs:{x:s},backend:n,attrs:{shape:j}}),I.push(s))}if(o!=null){let j=FI(o.shape,f);j!=null&&(o=ue({inputs:{x:o},backend:n,attrs:{shape:j}}),I.push(o))}let S=ue({inputs:{x:e},backend:n,attrs:{shape:[1,h,y.sizeFromShape(e.shape)/h]}});I.push(S);let w=new EI(b,t),_=[r.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],M=n.runWebGLProgram(w,[r],"float32",_),R=ue({inputs:{x:M},backend:n,attrs:{shape:b}});I.push(M),I.push(R);let E=o!=null,O=s!=null,G=i==="leakyrelu",W=i?Du(i,!0):null,H=new Mf(f?R.shape:S.shape,f?S.shape:R.shape,f?[t.batchSize,g,t.outChannels]:[t.batchSize,t.outChannels,g],T,x,E,W,O,G),U=f?[R,S]:[S,R];if(o&&U.push(o),O&&U.push(s),G){let j=n.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));U.push(j),I.push(j)}let V=n.runWebGLProgram(H,U,"float32"),Y=ue({inputs:{x:V},backend:n,attrs:{shape:t.outShape}});I.push(V);for(let j of I)n.disposeIntermediateTensorInfo(j);return Y}function nue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,m),d;if(c.filterHeight===1&&c.filterWidth===1&&c.dilationHeight===1&&c.dilationWidth===1&&c.strideHeight===1&&c.strideWidth===1&&(c.padInfo.type==="SAME"||c.padInfo.type==="VALID"))d=LI({x:o,filter:s,convInfo:c,backend:t});else if(c.strideWidth<=2&&m==="channelsLast"&&$().getBool("WEBGL_EXP_CONV")){let h=new Ef(c),g=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];d=t.runWebGLProgram(h,[o,s],"float32",g)}else if($().getBool("WEBGL_CONV_IM2COL"))d=$I({x:o,filter:s,convInfo:c,backend:t});else{let h=new Pf(c);d=t.runWebGLProgram(h,[o,s],"float32")}let f=ue({inputs:{x:d},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(d),f}var B3={kernelName:yo,backendName:"webgl",kernelFunc:nue};var BI=class{variableNames=["x","dy"];outputShape;userCode;constructor(e){this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},OI=class{variableNames=["dy","W"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",i=t-1-e.padInfo.top,u=n-1-e.padInfo.left,l=a?1:2,p=a?2:3,m=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${m}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},zI=class{variableNames=["x","dy"];outputShape;userCode;constructor(e){this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,i=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${i};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},GI=class{variableNames=["dy","W"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,a=e.strideHeight,i=e.strideWidth,u=t-1-e.padInfo.front,l=n-1-e.padInfo.top,p=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function oue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,filterShape:p}=n,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,p,a,1,i,l,!1,m),d=new BI(c);return t.runWebGLProgram(d,[o,s],"float32")}var O3={kernelName:Dm,backendName:"webgl",kernelFunc:oue};function sue(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(l),c=C.computeConv2DInfo(a,s.shape,i,1,u,p,!1,m),d=new OI(c);return t.runWebGLProgram(d,[o,s],"float32")}var z3={kernelName:To,backendName:"webgl",kernelFunc:sue};function aue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n,l=C.computeConv3DInfo(o.shape,s.shape,a,u,i),p=new PI(l);return t.runWebGLProgram(p,[o,s],"float32")}var G3={kernelName:Wu,backendName:"webgl",kernelFunc:aue};function iue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,pad:i,filterShape:u}=n,l=C.computeConv3DInfo(o.shape,u,a,1,i),p=new zI(l);return t.runWebGLProgram(p,[o,s],"float32")}var W3={kernelName:_m,backendName:"webgl",kernelFunc:iue};function uue(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:a,strides:i,inputShape:u}=n,l=C.computeConv3DInfo(u,s.shape,i,1,a),p=new GI(l);return t.runWebGLProgram(p,[o,s],"float32")}var U3={kernelName:Mm,backendName:"webgl",kernelFunc:uue};var lue=pa+`
  return cos(x);
`,pue=Ae({opSnippet:lue}),K3={kernelName:xo,backendName:"webgl",kernelFunc:pue};var mue=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,cue=Ae({opSnippet:mue}),V3={kernelName:Io,backendName:"webgl",kernelFunc:cue};var WI=class{variableNames=["Image","Boxes","BoxInd"];outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e,[p]=t,[m,c]=n;this.outputShape=[p,m,c,l];let d=o==="bilinear"?1:0,[f,h]=[`${i-1}.0`,`${u-1}.0`],[g,b,T]=m>1?[`${(i-1)/(m-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,I,S]=c>1?[`${(u-1)/(c-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${I};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${S};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var due=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,p=new WI(o.shape,s.shape,i,u,l);return t.runWebGLProgram(p,[o,s,a],"float32")},H3={kernelName:Na,backendName:"webgl",kernelFunc:due};var Ig=class{constructor(e,t,n,o){this.op=e;this.outputShape=t;let s=this.outputShape.length,a=this.op==="*"?"1.0":"0.0",i=n?a:`getX(${q3(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1],l="",p="";n?(l=o?`end != ${u-1}`:"end != 0",p=o?"end + 1":"end - 1"):(l=o?`end + pow2 < ${u}`:"end >= pow2",p=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ve(s)} coords = getOutputCoords();
        int end = ${j3(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${p};
          ${j3(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${q3(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}variableNames=["x"];userCode;customUniforms=[{name:"index",type:"float"}]};function q3(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function j3(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function UI(r,e,t,n,o,s){let a=e.shape.length,i=C.getAxesPermutation([n],a),u=e;i!=null&&(u=Wt({inputs:{x:e},backend:t,attrs:{perm:i}}));let l=C.getInnerMostAxes(1,a)[0];if(l!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${n}`);let p=u.shape[l],m=ur({inputs:{x:u},backend:t});for(let c=0;c<=Math.ceil(Math.log2(p))-1;c++){let d=new Ig(r,u.shape,!1,s),f=[[c]],h=m;m=t.runWebGLProgram(d,[m],m.dtype,f),t.disposeIntermediateTensorInfo(h)}if(o){let c=new Ig(r,u.shape,o,s),d=m;m=t.runWebGLProgram(c,[m],m.dtype),t.disposeIntermediateTensorInfo(d)}if(i!=null){let c=C.getUndoAxesPermutation(i),d=Wt({inputs:{x:m},backend:t,attrs:{perm:c}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(u),d}return m}function hue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return UI("*",o,t,s,a,i)}var X3={kernelName:wa,backendName:"webgl",kernelFunc:hue};function gue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return UI("+",o,t,s,a,i)}var Y3={kernelName:Co,backendName:"webgl",kernelFunc:gue};function bue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=sI(u,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=$O(u,l,a,i);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Z3={kernelName:Uu,backendName:"webgl",kernelFunc:bue};var KI=class{variableNames=["x"];outputShape=[];userCode;blockSize;dataFormat;constructor(e,t,n){this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function yue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=l*s,d=p/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=new KI(f,s,a);return t.runWebGLProgram(h,[o],o.dtype)}var Q3={kernelName:Da,backendName:"webgl",kernelFunc:yue};var Ff=class{variableNames=["x","W"];outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape,this.enableShapeUniforms=Dt(this.outputShape.length);let a=e.filterHeight,i=e.filterWidth,u=e.outChannels/e.inChannels,l="",p="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,p="result = activation(result);");let m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${m}
        ${p}
        setOutput(result);
      }
    `}};var Lf=class{variableNames=["x","W"];packedInputs=!0;packedOutput=!0;outputShape;userCode;enableShapeUniforms;customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];constructor(e,t=!1,n=null,o=!1,s=!1){this.outputShape=e.outShape,this.enableShapeUniforms=Dt(this.outputShape.length);let a=e.outChannels/e.inChannels,i=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,p=e.filterHeight,m=e.filterWidth,c=m,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<m;b++)d+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;d+=`
    for (int r = 0; r < ${p}; r++) {
      `;for(let b=0;b<m;b++)d+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(c+1)/2;b++){let T=b*2;if(d+=`
          xC = xCCorner + ${T*l};
          `,u===1){if(T<m&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,l===1&&T>0?d+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<m)){let x=i%2===0?y.nearestLargerEven(l):l;l%2===0&&i%2===1||l%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,l>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:d+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):x===1?d+=`
                    xC${T+1} = xTexelC${T};
                    `:d+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<m&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<m&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<m&&(d+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<m&&(d+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<m&&(d+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let f="",h="";n&&(o?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function Tue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u,dimRoundingMode:l}=n,p=u;p==null&&(p=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let m=C.computeConv2DInfo(o.shape,s.shape,a,p,i,l,!0),c;$().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1?c=new Lf(m):c=new Ff(m);let d=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];return t.runWebGLProgram(c,[o,s],"float32",d)}var J3={kernelName:So,backendName:"webgl",kernelFunc:Tue};var VI=class{variableNames=["x","dy"];outputShape;userCode;constructor(e){this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},HI=class{variableNames=["dy","W"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,i=n-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function xue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,filterShape:p}=n,m=C.computeConv2DInfo(o.shape,p,a,i,u,l,!0),c=new VI(m);return t.runWebGLProgram(c,[o,s],"float32")}var eG={kernelName:Rm,backendName:"webgl",kernelFunc:xue};function Iue(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,dilations:i,pad:u,dimRoundingMode:l,inputShape:p}=n,m=C.computeConv2DInfo(p,s.shape,a,i,u,l,!0),c=new HI(m);return t.runWebGLProgram(c,[o,s],"float32")}var tG={kernelName:Pm,backendName:"webgl",kernelFunc:Iue};var qI=class{variableNames=["X"];outputShape;userCode;constructor(e){this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Cue(r){let{inputs:e,backend:t}=r,{x:n}=e,o=[...n.shape,...n.shape],s=y.sizeFromShape(n.shape),a=ue({inputs:{x:n},backend:t,attrs:{shape:[s]}}),i=new qI(s),u=t.runWebGLProgram(i,[a],a.dtype),l=ue({inputs:{x:u},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),l}var rG={kernelName:Em,backendName:"webgl",kernelFunc:Cue};var jI=class{variableNames=["x","W"];outputShape;userCode;constructor(e){this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:o,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:u,dilationHeight:l,dilationWidth:p}=e,{top:m,left:c}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${m}, ${c});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Sue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dilations:u}=n,l=C.computeDilation2DInfo(o.shape,s.shape,a,i,"NHWC",u),p,m=new jI(l);p=t.runWebGLProgram(m,[o,s],"float32");let c=ue({inputs:{x:p},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(p),c}var nG={kernelName:Ku,backendName:"webgl",kernelFunc:Sue};function kue(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=C.getEinsumComputePath(i,u),m=p.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of p[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=Wt({inputs:{x:s[g]},backend:t,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let S=0;S<T.length;++S)I.splice(T[S],0,1);y.arraysEqual(x.shape,I)||(x=ue({inputs:{x},backend:t,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=Tg({inputs:{a:x,b:c},backend:t}),f.push(c))}h<m-1&&(l[h]>=0&&(c=rm({inputs:{x:c},backend:t,attrs:{axis:l[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&t.disposeIntermediateTensorInfo(h);return c}var oG={kernelName:Vu,backendName:"webgl",kernelFunc:kue};var vue="return (x >= 0.0) ? x : (exp(x) - 1.0);",Aue=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,wue=Ae({opSnippet:vue,packedOpSnippet:Aue}),sG={kernelName:vo,backendName:"webgl",kernelFunc:wue};var Nue="return (b >= 1.0) ? a : a * (b + 1.0);",Due=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,_ue=r=>{let{inputs:e,backend:t}=r,{dy:n,y:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new la(Due,n.shape,o.shape):new bs(Nue,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)},aG={kernelName:Fm,backendName:"webgl",kernelFunc:_ue};var Mue=`
  return vec4(equal(a, b));
`,Rue="return float(a == b);",Pue=dt({opSnippet:Rue,packedOpSnippet:Mue,dtype:"bool",cpuKernelImpl:GO}),iG={kernelName:Ma,backendName:"webgl",kernelFunc:Pue};var Eue=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${C.ERF_P};
  float a1 = ${C.ERF_A1};
  float a2 = ${C.ERF_A2};
  float a3 = ${C.ERF_A3};
  float a4 = ${C.ERF_A4};
  float a5 = ${C.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Fue=Ae({opSnippet:Eue}),uG={kernelName:_a,backendName:"webgl",kernelFunc:Fue};var Lue=pa+`
  return exp(x);
`,$ue=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,GD=Ae({opSnippet:Lue,packedOpSnippet:$ue,cpuKernelImpl:WO,dtype:"float32"}),lG={kernelName:Ao,backendName:"webgl",kernelFunc:GD};function XI(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(y.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),ue({inputs:{x:s},backend:n,attrs:{shape:i}})}var pG={kernelName:Ss,backendName:"webgl",kernelFunc:XI};var mG="return exp(x) - 1.0;",Bue=Ae({opSnippet:mG,packedOpSnippet:mG,cpuKernelImpl:UO}),cG={kernelName:Ra,backendName:"webgl",kernelFunc:Bue};var Cg=class{variableNames=["real","imag"];outputShape;userCode;constructor(e,t,n){let o=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${o}.0`:"1.0",i;if(e==="real")i="return real * expR - imag * expI;";else if(e==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function YI(r,e,t){let n=t.texData.get(r.dataId),o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=o/s,i=ue({inputs:{x:r},backend:t,attrs:{shape:[a,s]}}),u=i.shape,l=new Cg("real",u,e),p=new Cg("imag",u,e),m=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],c=t.runWebGLProgram(l,m,"float32"),d=t.runWebGLProgram(p,m,"float32"),f=Bn({inputs:{real:c,imag:d},backend:t});t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d);let h=ue({inputs:{x:f},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(f),h}function Oue(r){let{inputs:e,backend:t}=r,{input:n}=e;return YI(n,!1,t)}var dG={kernelName:Hu,backendName:"webgl",kernelFunc:Oue};var ZI=class{variableNames;outputShape=[];userCode;customUniforms=[{name:"value",type:"float"}];constructor(e,t){this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Mu(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let a=y.getArrayFromDType(s,y.sizeFromShape(n));return a.fill(o),e.makeTensorInfo(n,s,a)}else{let a=new ZI(n,o),i=[[o]];return e.runWebGLProgram(a,[],s,i)}}var fG={kernelName:Ai,backendName:"webgl",kernelFunc:Mu};var QI=class{variableNames=["Image"];outputShape=[];userCode;constructor(e){let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var hG={kernelName:Pa,backendName:"webgl",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new QI(t.shape);return n.runWebGLProgram(o,[t],t.dtype)}};var gG="return floor(x);",zue=Ae({opSnippet:gG,packedOpSnippet:gG,cpuKernelImpl:KO}),bG={kernelName:wo,backendName:"webgl",kernelFunc:zue};var Gue=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Wue=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Uue=dt({opSnippet:Gue,packedOpSnippet:Wue,dtype:"int32"}),yG={kernelName:No,backendName:"webgl",kernelFunc:Uue};var JI=class{variableNames=["A"];userCode;outputShape;constructor(e){let t=jt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var eC=class{variableNames=["A"];userCode;outputShape;packedInputs=!1;packedOutput=!0;constructor(e){let t=jt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var TG={kernelName:jl,backendName:"webgl",kernelFunc:Kue},$f,WD=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function Kue(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n,a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[u,l]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],p=[l,u],m=[l,u,s];if(i||a){let h=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");($f==null||h!==WD)&&(WD=h,$f=document.createElement("canvas").getContext("2d",{willReadFrequently:WD})),$f.canvas.width=u,$f.canvas.height=l,$f.drawImage(o,0,0,u,l),o=$f.canvas}let c=t.makeTensorInfo(p,"int32");t.texData.get(c.dataId).usage=2,t.gpgpu.uploadPixelDataToTexture(t.getTexture(c.dataId),o);let d=$().getBool("WEBGL_PACK")?new eC(m):new JI(m),f=t.runWebGLProgram(d,[c],"int32");return t.disposeData(c.dataId),f}function Vue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=C.convertConv2DDataFormat(p),g=C.computeConv2DInfo(o.shape,s.shape,u,m,l,c,!1,h),b,T=[],x=a!=null,I=i!=null,S=d==="leakyrelu",w=()=>{let M=[o,s],R=(E,O)=>{if(O==="NCHW"&&E.shape.length===1&&E.shape[0]!==1){let G=ue({inputs:{x:E},backend:t,attrs:{shape:[E.shape[0],1,1]}});return T.push(G),G}return E};if(x&&M.push(R(a,p)),I&&M.push(R(i,p)),S){let E=t.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));M.push(E),T.push(E)}return M};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))b=LI({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else if(g.strideWidth<=2&&h==="channelsLast"&&$().getBool("WEBGL_EXP_CONV")){let M=d?Du(d,!0):null,R=new Ef(g,x,M,I,S),E=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],O=w();b=t.runWebGLProgram(R,O,"float32",E)}else if($().getBool("WEBGL_CONV_IM2COL"))b=$I({x:o,filter:s,convInfo:g,backend:t,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else{let M=d?Du(d,!1):null,R=new Pf(g,x,M,I,S),E=w();b=t.runWebGLProgram(R,E,"float32")}let _=ue({inputs:{x:b},backend:t,attrs:{shape:g.outShape}});return T.push(b),T.forEach(M=>t.disposeIntermediateTensorInfo(M)),_}var xG={kernelName:$s,backendName:"webgl",kernelFunc:Vue};function Hue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:m,activation:c,leakyreluAlpha:d}=n,f=[],h=p;h==null&&(h=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=C.computeConv2DInfo(o.shape,s.shape,u,h,l,m,!0),b=$().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,T=c?Du(c,b):null,x=[o,s],I=a!=null,S=i!=null,w=c==="leakyrelu";if(I&&x.push(a),S&&x.push(i),w){let E=t.makeTensorInfo([],"float32",y.createScalarValue(d,"float32"));x.push(E),f.push(E)}let _;b?_=new Lf(g,I,T,S,w):_=new Ff(g,I,T,S,w);let M=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],R=t.runWebGLProgram(_,x,"float32",M);return f.forEach(E=>t.disposeIntermediateTensorInfo(E)),R}var IG={kernelName:Bs,backendName:"webgl",kernelFunc:Hue};var tC=class{constructor(e,t,n,o){this.sliceDim=e;this.strides=t;this.paramsShape=o;this.outputShape=n;let s=Ve(n.length),a=`
    int index;`;for(let i=0;i<this.sliceDim;i++)a+=`
          index = round(getIndices(coords[0], ${i}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[i]};
          flattenIndex += index * ${this.strides[i]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}variableNames=["x","indices"];outputShape;userCode};function que(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,a=s[s.length-1],i=y.sizeFromShape(n.shape),[u,l,p,m]=C.prepareAndValidate(n,o),c=ue({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),d=ue({inputs:{x:n},backend:t,attrs:{shape:[y.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let b=t.readSync(o.dataId),T=t.bufferSync(n),x=VO(b,T,n.dtype,l,a,p,m,n.shape,i);return t.makeTensorInfo(u,n.dtype,x.values)}let f=new tC(a,m,[l,p],n.shape),h=t.runWebGLProgram(f,[d,c],d.dtype),g=ue({inputs:{x:h},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var CG={kernelName:Ea,backendName:"webgl",kernelFunc:que};var rC=class{variableNames=["A","indices"];outputShape;userCode;rank;constructor(e,t){this.outputShape=t,this.rank=t.length;let n=Ve(this.rank),o=jue(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function jue(r,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${t[o]}`);return n.join()}function UD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0];if($().get("DEBUG")){let T=t.readSync(s.dataId),x=o.shape[u];for(let I=0;I<T.length;++I){let S=T[I];y.assert(S<=x-1&&S>=0,()=>`GatherV2: the index value ${S} is not in [0, ${x-1}]`)}}let l=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),p=y.sizeFromShape(s.shape),m=[],c=ue({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=ue({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,p/l.batchSize]}});m.push(c),m.push(d);let f=[l.batchSize,l.outerSize,p/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let T=t.bufferSync(d),x=t.bufferSync(c),I=HO(x,T,f);return m.forEach(S=>t.disposeIntermediateTensorInfo(S)),t.makeTensorInfo(l.outputShape,I.dtype,I.values)}let h=new rC(c.shape,f),g=t.runWebGLProgram(h,[c,d],c.dtype);m.push(g);let b=ue({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return m.forEach(T=>t.disposeIntermediateTensorInfo(T)),b}var SG={kernelName:ks,backendName:"webgl",kernelFunc:UD};var Xue="return float(a > b);",Yue=`
  return vec4(greaterThan(a, b));
`,Zue=dt({opSnippet:Xue,packedOpSnippet:Yue,cpuKernelImpl:qO,dtype:"bool"}),kG={kernelName:Fa,backendName:"webgl",kernelFunc:Zue};var Que="return float(a >= b);",Jue=`
  return vec4(greaterThanEqual(a, b));
`,ele=dt({opSnippet:Que,packedOpSnippet:Jue,dtype:"bool",cpuKernelImpl:jO}),vG={kernelName:_o,backendName:"webgl",kernelFunc:ele};function tle(r){let{inputs:e,backend:t}=r,{input:n}=e;return YI(n,!0,t)}var AG={kernelName:qu,backendName:"webgl",kernelFunc:tle};var rle="return float(!isnan(x) && !isinf(x));",nle=Ae({opSnippet:rle,dtype:"bool"}),wG={kernelName:La,backendName:"webgl",kernelFunc:nle};var ole="return float(isinf(x));",sle=Ae({opSnippet:ole,dtype:"bool"}),NG={kernelName:$a,backendName:"webgl",kernelFunc:sle};var ale="return float(isnan(x));",ile=Ae({opSnippet:ale,dtype:"bool"}),DG={kernelName:Mo,backendName:"webgl",kernelFunc:ile};var ule="return float(a < b);",lle=`
  return vec4(lessThan(a, b));
`,ple=dt({opSnippet:ule,packedOpSnippet:lle,cpuKernelImpl:XO,dtype:"bool"}),_G={kernelName:Ba,backendName:"webgl",kernelFunc:ple};var mle="return float(a <= b);",cle=`
  return vec4(lessThanEqual(a, b));
`,dle=dt({opSnippet:mle,packedOpSnippet:cle,cpuKernelImpl:YO,dtype:"bool"}),MG={kernelName:Oa,backendName:"webgl",kernelFunc:dle};function fle(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,a=ZO(n,o,s);return e.makeTensorInfo([a.length],"float32",a)}var RG={kernelName:Lm,backendName:"webgl",kernelFunc:fle};var hle=pa+`
  return x < 0.0 ? 0./0. : log(x);
`,gle=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ble=Ae({opSnippet:hle,packedOpSnippet:gle,cpuKernelImpl:QO}),PG={kernelName:Po,backendName:"webgl",kernelFunc:ble};var yle=pa+`
  return log(1.0 + x);
`,Tle=Ae({opSnippet:yle}),EG={kernelName:za,backendName:"webgl",kernelFunc:Tle};var xle="return float(a >= 1.0 && b >= 1.0);",Ile=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Cle=dt({opSnippet:xle,packedOpSnippet:Ile,dtype:"bool"}),FG={kernelName:Ga,backendName:"webgl",kernelFunc:Cle};var Sle="return float(!(x >= 1.0));",kle=Ae({opSnippet:Sle}),LG={kernelName:Wa,backendName:"webgl",kernelFunc:kle};var vle="return float(a >= 1.0 || b >= 1.0);",Ale=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,wle=dt({opSnippet:vle,packedOpSnippet:Ale,dtype:"bool"}),$G={kernelName:Ji,backendName:"webgl",kernelFunc:wle};var nC=class{variableNames=["x"];outputShape=[];userCode;constructor(e,t,n,o,s){let a=t,i=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var oC=class{variableNames=["x"];outputShape=[];userCode;packedInputs=!0;packedOutput=!0;constructor(e,t,n,o,s){let a=t,i=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var Nle=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:a,alpha:i,beta:u}=n,l=$().getBool("WEBGL_PACK_NORMALIZATION")?new oC(o.shape,s,a,i,u):new nC(o.shape,s,a,i,u);return t.runWebGLProgram(l,[o],o.dtype)},BG={kernelName:Xu,backendName:"webgl",kernelFunc:Nle};var sC=class{variableNames=["inputImage","outputImage","dy"];outputShape=[];userCode;depthRadius;bias;alpha;beta;depth;constructor(e,t,n,o,s){this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Dle=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:a}=e,{depthRadius:i,bias:u,alpha:l,beta:p}=n,m=new sC(o.shape,i,u,l,p);return t.runWebGLProgram(m,[o,s,a],o.dtype)},OG={kernelName:$m,backendName:"webgl",kernelFunc:Dle};function zG(r,e,t,n){let o=y.sizeFromShape(e),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=ro(i,r.dtype,"max",n),l=ue({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}function KD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=p!=null,c=t.shouldExecuteOnCPU([o]),d=o;if(m){if(c){let x=t.texData.get(d.dataId).values,I=new Array(i);for(let _=0;_<I.length;_++)I[_]=o.shape[p[_]];let S=tm(x,o.shape,o.dtype,p,I);d=t.makeTensorInfo(I,o.dtype);let w=t.texData.get(d.dataId);w.values=S}else d=Ol(o,p,t);l=C.getInnerMostAxes(l.length,i)}C.assertAxesAreInnerMostDims("max",l,i);let[f,h]=C.computeOutAndReduceShapes(d.shape,l),g=f;a&&(g=C.expandShapeToKeepDim(f,u));let b;if(c){let x=t.texData.get(d.dataId).values,I=JO(x,y.sizeFromShape(h),g,o.dtype);b=t.makeTensorInfo(g,o.dtype);let S=t.texData.get(b.dataId);S.values=I}else b=zG(d,h,g,t);return m&&t.disposeIntermediateTensorInfo(d),b}var GG={kernelName:Eo,backendName:"webgl",kernelFunc:KD};var _le=_f+`
  return max(a, b);
`,Mle=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hi+`
  return result;
`,Rle=dt({opSnippet:_le,packedOpSnippet:Mle,cpuKernelImpl:ez}),WG={kernelName:Fo,backendName:"webgl",kernelFunc:Rle};function Ple(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;gi(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1;y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let p=C.computePool2DInfo(o.shape,s,a,l,i,u);if(p.filterWidth===1&&p.filterHeight===1&&y.arraysEqual(p.inShape,p.outShape))return ur({inputs:{x:o},backend:t});let m=new yi(p,"max",!1);return t.runWebGLProgram(m,[o],o.dtype)}var UG={kernelName:Lo,backendName:"webgl",kernelFunc:Ple};function Ele(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dataFormat:u,dimRoundingMode:l}=n,p=[1,1,1],m=C.computePool3DInfo(o.shape,s,a,p,i,l,u),c=new zl(m,"max",!1);return t.runWebGLProgram(c,[o],o.dtype)}var KG={kernelName:Yu,backendName:"webgl",kernelFunc:Ele};var aC=class{variableNames=["dy","maxPos"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,i=s-1-e.padInfo.top,u=a-1-e.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},iC=class{variableNames=["dy","maxPos"];outputShape;userCode;constructor(e){this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,i=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=u-1-e.padInfo.front,c=l-1-e.padInfo.top,d=p-1-e.padInfo.left,f=u*l*p-1;this.userCode=`
      const ivec3 pads = ivec3(${m}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Fle(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,a=s,{filterSize:i,strides:u,pad:l,dimRoundingMode:p}=n,m=[1,1,1],c=C.computePool3DInfo(a.shape,i,u,m,l,p),d=new zl(c,"max",!0),f=t.runWebGLProgram(d,[a],a.dtype),h=new iC(c),g=t.runWebGLProgram(h,[o,f],a.dtype);return t.disposeIntermediateTensorInfo(f),g}var VG={kernelName:Om,backendName:"webgl",kernelFunc:Fle};function Lle(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:a}=e,i=s;gi([s,a],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:m}=n,c=C.computePool2DInfo(i.shape,u,l,1,p,m),d=!0,f=new yi(c,"max",d),h=t.runWebGLProgram(f,[i],i.dtype),g=new aC(c),b=t.runWebGLProgram(g,[o,h],i.dtype);return t.disposeIntermediateTensorInfo(h),b}var HG={kernelName:Bm,backendName:"webgl",kernelFunc:Lle};function qG(r,e,t,n){let o=new yi(t,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new yi(t,"max",!0,!0,e);let a=n.runWebGLProgram(o,[r],"float32");return[s,a]}var jG={kernelName:zm,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=e,u=t;y.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];y.assert(C.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let p=C.computePool2DInfo(n.shape,o,s,l,a),[m,c]=qG(n,i,p,u);return[m,c]}};function XG(r,e,t,n){let o=y.sizeFromShape(e),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=ro(i,"float32","mean",n),l=ue({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),l}var YG={kernelName:$o,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{keepDims:o,axis:s}=e,a=t,i=n.shape.length,u=y.parseAxisParam(s,n.shape),l=u,p=C.getAxesPermutation(l,i),m=p!=null,c=a.shouldExecuteOnCPU([n]),d=[],f=n;if(m){if(c){let I=a.texData.get(f.dataId).values,S=new Array(i);for(let M=0;M<S.length;M++)S[M]=n.shape[p[M]];let w=tm(I,n.shape,n.dtype,p,S);f=a.makeTensorInfo(S,n.dtype);let _=a.texData.get(f.dataId);_.values=w}else f=Ol(n,p,a);d.push(f),l=C.getInnerMostAxes(l.length,i)}C.assertAxesAreInnerMostDims("sum",l,i);let[h,g]=C.computeOutAndReduceShapes(f.shape,l),b=h;o&&(b=C.expandShapeToKeepDim(h,u));let T=XG(f,g,b,a);for(let x of d)a.disposeIntermediateTensorInfo(x);return T}};function $le(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),l=u,p=C.getAxesPermutation(l,i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),l=C.getInnerMostAxes(l.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",l,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,l),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,f]}}),g=ro(h,h.dtype,"min",t),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:t,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(m),b}var ZG={kernelName:Bo,backendName:"webgl",kernelFunc:$le};var Ble=_f+`
  return min(a, b);
`,Ole=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Hi+`
  return result;
`,zle=dt({opSnippet:Ble,packedOpSnippet:Ole,cpuKernelImpl:tz}),QG={kernelName:Oo,backendName:"webgl",kernelFunc:zle};var uC=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n){this.outputShape=t.map((p,m)=>p[0]+e[m]+p[1]);let o=e.length,s=Ve(o),a=t.map(p=>p[0]).join(","),i=t.map((p,m)=>p[0]+e[m]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var lC=class{variableNames=["x"];packedInputs=!0;packedOutput=!0;outputShape;userCode;constructor(e,t,n){this.outputShape=t.map((f,h)=>f[0]+e[h]+f[1]);let o=e.length,s=Ve(o),a=t.map(f=>f[0]).join(","),i=t.map((f,h)=>f[0]+e[h]).join(","),u=ir("rc",o),l=ir("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,m=o===1?"source":`vec2(${l.slice(-2).join()})`,c=n==="reflect"?0:1,d="";if(o===1){let f=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${c};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${c};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${m});
        ${u[o-1]} += 1;
        if(${p}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${m});
        }
      `}else{let f=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${c}) +
                gte * ((end - 1) * 2 - source + ${c});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${m});
        ${u[o-1]} += 1;
        if(${p}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${m});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${m});
          ${u[o-1]} += 1;
          if(${p}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${m});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var Gle=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{paddings:o,mode:s}=t,a=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new lC(n.shape,o,s):new uC(n.shape,o,s);return e.runWebGLProgram(a,[n],n.dtype)},JG={kernelName:zo,backendName:"webgl",kernelFunc:Gle};var Wle=`if (b == 0.0) return NAN;
  return mod(a, b);`,Ule=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Hi+`
  return result;
`,Kle=dt({opSnippet:Wle,packedOpSnippet:Ule}),eW={kernelName:Ua,backendName:"webgl",kernelFunc:Kle};var pC=class{variableNames=["probs"];outputShape;userCode;customUniforms=[{name:"seed",type:"float"}];constructor(e,t,n){this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};var Vle=`
if (a == b) {
  return 1.0;
};
return a / b;`,Hle=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,VD=dt({opSnippet:Vle,packedOpSnippet:Hle,checkOutOfBounds:!0}),tW={kernelName:ko,backendName:"webgl",kernelFunc:VD};var rW="return a - b;",HD=dt({opSnippet:rW,packedOpSnippet:rW,supportsComplex:!0,cpuKernelImpl:Iz}),nW={kernelName:as,backendName:"webgl",kernelFunc:HD};function qD(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=y.parseAxisParam([s],o.shape),i=KD({inputs:{x:o},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=C.expandShapeToKeepDim(i.shape,a),l=ue({inputs:{x:i},backend:t,attrs:{shape:u}}),p=HD({inputs:{a:o,b:l},backend:t}),m=GD({inputs:{x:p},backend:t}),c=rm({inputs:{x:m},backend:t,attrs:{axis:a,keepDims:!1}}),d=ue({inputs:{x:c},backend:t,attrs:{shape:u}}),f=VD({inputs:{a:m,b:d},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(d),f}var oW={kernelName:os,backendName:"webgl",kernelFunc:qD};function qle(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:a,normalized:i}=n,u=i?o:qD({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),l=u.shape[0],p=u.shape[1],m=new pC(l,p,s),c=[[a]],d=t.runWebGLProgram(m,[u],"int32",c);return i||t.disposeIntermediateTensorInfo(u),d}var sW={kernelName:Gm,backendName:"webgl",kernelFunc:qle};var jle=Ir+`
  return -x;
`,Xle=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Yle(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.texData.get(n.dataId),[a,i]=nz(s.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,a)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new $n(n.shape,Xle):o=new Gr(n.shape,jle),t.runWebGLProgram(o,[n],n.dtype)}var aW={kernelName:vs,backendName:"webgl",kernelFunc:Yle};var Zle=xr.nonMaxSuppressionV3Impl;function Qle(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:m}=Zle(l,p,a,i,u);return t.makeTensorInfo([m.length],"int32",new Int32Array(m))}var iW={kernelName:Va,backendName:"webgl",kernelFunc:Qle};var Jle=xr.nonMaxSuppressionV4Impl;function epe(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:l}=n,p=t.readSync(o.dataId),m=t.readSync(s.dataId),{selectedIndices:c,validOutputs:d}=Jle(p,m,a,i,u,l);return[t.makeTensorInfo([c.length],"int32",new Int32Array(c)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}var uW={kernelName:eu,backendName:"webgl",kernelFunc:epe};var tpe=xr.nonMaxSuppressionV5Impl;function rpe(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),m=t.readSync(s.dataId),c=a,d=i,f=u,h=l,{selectedIndices:g,selectedScores:b}=tpe(p,m,c,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var lW={kernelName:Ha,backendName:"webgl",kernelFunc:rpe};var mC=class{variableNames=["indices"];outputShape;userCode;seedLoc;constructor(e,t,n,o){this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var npe=r=>{let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n,l=y.sizeFromShape(o.shape),p=new mC(l,a,i,u),m=ue({inputs:{x:o},backend:t,attrs:{shape:[l]}}),c=t.runWebGLProgram(p,[m],s);t.disposeIntermediateTensorInfo(m);let d=[...o.shape,a],f=ue({inputs:{x:c},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(c),f},pW={kernelName:Wo,backendName:"webgl",kernelFunc:npe};function Sg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=_u({inputs:{input:n},backend:t}),s=Sg({inputs:{x:o},backend:t}),a=om({inputs:{input:n},backend:t}),i=Sg({inputs:{x:a},backend:t}),u=Bn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Mu({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var mW={kernelName:Es,backendName:"webgl",kernelFunc:Sg};function cW(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=_u({inputs:{input:n},backend:t}),s=cW({inputs:{x:o},backend:t}),a=om({inputs:{input:n},backend:t}),i=Sg({inputs:{x:a},backend:t}),u=Bn({inputs:{real:s,imag:i},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(i),u}else return Mu({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var dW={kernelName:As,backendName:"webgl",kernelFunc:cW};function ope(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return XI({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=XI({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=zD({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var fW={kernelName:ws,backendName:"webgl",kernelFunc:ope};var cC=class{variableNames=["x"];outputShape;userCode;customUniforms=[{name:"value",type:"float"}];constructor(e,t,n){this.outputShape=t.map((l,p)=>l[0]+e[p]+l[1]);let o=e.length,s=Ve(o),a=t.map(l=>l[0]).join(","),i=t.map((l,p)=>l[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var dC=class{variableNames=["x"];packedInputs=!0;packedOutput=!0;outputShape;userCode;customUniforms=[{name:"value",type:"float"}];constructor(e,t,n){this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=Ve(o),a=t.map(h=>h[0]).join(","),i=t.map((h,g)=>h[0]+e[g]).join(","),u=ir("rc",o),l=ir("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,m=o===1?"source":`vec2(${l.slice(-2).join()})`,c=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${p}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${p}) {`],d=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="";for(let h=0,g=o===1?2:4;h<g;h++)f+=`
        ${c[h]}
        if (${d}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${m});
        }
      `;f+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var jD=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;if(y.sizeFromShape(o.shape)===0){let l=s.map((p,m)=>p[0]+o.shape[m]+p[1]);return Mu({backend:t,attrs:{shape:l,value:a,dtype:o.dtype}})}let i=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new dC(o.shape,s,a):new cC(o.shape,s,a),u=[[a]];return t.runWebGLProgram(i,[o],o.dtype,u)},hW={kernelName:Uo,backendName:"webgl",kernelFunc:jD};var spe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,ape=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Hi+`
  return result;
`,ipe=dt({opSnippet:spe,packedOpSnippet:ape}),gW={kernelName:Ko,backendName:"webgl",kernelFunc:ipe};function upe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n,i=o.shape.length,u=[],l=y.parseAxisParam(s,o.shape),p=l,m=C.getAxesPermutation(p,i),c=o;m!=null&&(c=Wt({inputs:{x:o},backend:t,attrs:{perm:m}}),p=C.getInnerMostAxes(p.length,i),u.push(c)),C.assertAxesAreInnerMostDims("prod",p,i);let d;if(t.shouldExecuteOnCPU([c])){let f=t.texData.get(c.dataId).values,{outVals:h,outShape:g,outDtype:b}=sz(c.shape,c.dtype,f,p);d=t.makeTensorInfo(g,b,h)}else{let[f,h]=C.computeOutAndReduceShapes(c.shape,p),g=y.sizeFromShape(h),b=ue({inputs:{x:c},backend:t,attrs:{shape:[-1,g]}}),T=iu(o.dtype),x=ro(b,T,"prod",t);d=ue({inputs:{x},backend:t,attrs:{shape:f}}),u.push(b),u.push(x)}if(a){u.push(d);let f=C.expandShapeToKeepDim(d.shape,l);d=ue({inputs:{x:d},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}var bW={kernelName:Ho,backendName:"webgl",kernelFunc:upe};function lpe(r){let{inputs:e,backend:t,attrs:n}=r,{paramsNestedSplits:o,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:i}=n,u=o.map(b=>t.readSync(b.dataId)),l=o.map(b=>b.shape),p=t.readSync(s.dataId),m=t.readSync(a.dataId),[c,d,f]=az(u,l,p,s.shape,s.dtype,m,a.shape,i),h=c.map(b=>t.makeTensorInfo([b.length],"int32",b)),g=t.makeTensorInfo(f,s.dtype,d);return h.concat([g])}var yW={kernelName:Wm,backendName:"webgl",kernelFunc:lpe};function ppe(r){let{inputs:e,backend:t}=r,{starts:n,limits:o,deltas:s}=e,a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=iz(a,n.shape,n.dtype,i,o.shape,u,s.shape),m=t.makeTensorInfo([l.length],"int32",l),c=t.makeTensorInfo([p.length],n.dtype,p);return[m,c]}var TW={kernelName:Um,backendName:"webgl",kernelFunc:ppe};function mpe(r){let{inputs:e,backend:t,attrs:n}=r,{shape:o,values:s,defaultValue:a,rowPartitionTensors:i}=e,{rowPartitionTypes:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),m=t.readSync(a.dataId),c=i.map(g=>t.readSync(g.dataId)),d=i.map(g=>g.shape),[f,h]=uz(l,o.shape,p,s.shape,s.dtype,m,a.shape,c,d,u);return t.makeTensorInfo(f,s.dtype,h)}var xW={kernelName:Km,backendName:"webgl",kernelFunc:mpe};var XD=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=lz(n,o,s,a);return e.makeTensorInfo([i.length],a,i)},IW={kernelName:wi,backendName:"webgl",kernelFunc:XD};var cpe="return 1.0 / x;",dpe=Ae({opSnippet:cpe}),CW={kernelName:qo,backendName:"webgl",kernelFunc:dpe};var fpe=Ir+`
  return (x < 0.0) ? 0.0 : x;
`,hpe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gpe=Ae({opSnippet:fpe,packedOpSnippet:hpe}),SW={kernelName:jo,backendName:"webgl",kernelFunc:gpe};var bpe=Ir+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,ype=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Tpe=Ae({opSnippet:bpe,packedOpSnippet:ype}),kW={kernelName:Zo,backendName:"webgl",kernelFunc:Tpe};var fC=class{variableNames=["A"];outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c;s?c="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":c="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/m[0]},
          ${p[1]/m[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var hC=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c;s?c="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":c="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/m[0]},
          ${p[1]/m[1]},
          ${p[1]/m[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function xpe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new hC(o.shape,u,l,s,a):new fC(o.shape,u,l,s,a);return t.runWebGLProgram(p,[o],"float32")}var vW={kernelName:Yo,backendName:"webgl",kernelFunc:xpe};var gC=class{variableNames=["dy"];outputShape=[];userCode;constructor(e,t,n){this.outputShape=t;let[,o,s]=t,[,a,i]=e,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],p=u[0]/l[0],m=u[1]/l[1],c=1/p,d=1/m,f=Math.ceil(c)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${m});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Ipe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new gC(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var AW={kernelName:Hm,backendName:"webgl",kernelFunc:Ipe};var bC=class{variableNames=["A"];outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c=o?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/m[0]},
          ${p[1]/m[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var yC=class{variableNames=["A"];packedInputs=!0;packedOutput=!0;outputShape=[];userCode;constructor(e,t,n,o,s){let[a,i,u,l]=e;this.outputShape=[a,t,n,l];let p=[o&&t>1?i-1:i,o&&n>1?u-1:u],m=[o&&t>1?t-1:t,o&&n>1?n-1:n],c=o?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/m[0]},
          ${p[1]/m[1]},
          ${p[1]/m[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Cpe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new yC(o.shape,u,l,s,a):new bC(o.shape,u,l,s,a);return t.runWebGLProgram(p,[o],o.dtype)}var wW={kernelName:Xo,backendName:"webgl",kernelFunc:Cpe};var TC=class{variableNames=["dy"];outputShape=[];userCode;constructor(e,t,n){this.outputShape=t;let[,o,s]=t,[,a,i]=e,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],l=[n&&a>1?a-1:a,n&&i>1?i-1:i],p=u[0]/l[0],m=u[1]/l[1],c=1/p,d=1/m,f=Math.ceil(c)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${m});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Spe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:a}=n,i=new TC(s.shape,o.shape,a);return t.runWebGLProgram(i,[s],s.dtype)}var NW={kernelName:Vm,backendName:"webgl",kernelFunc:Spe};var xC=class{variableNames=["x"];outputShape;userCode;constructor(e,t){let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=i=>t.indexOf(i)!==-1&&e[i]!==1?`${e[i]} - coords[${i}] - 1`:`coords[${i}]`,s=e.map((i,u)=>o(u)).join(","),a=Ve(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var IC=class{variableNames=["x"];outputShape;userCode;packedInputs=!0;packedOutput=!0;constructor(e,t){let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let o=ir("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Ve(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${a}) {
            result.b = ${p(o.slice())};
            if(${s}) {
              result.a = ${m(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return c(f)}function l(f){return f[n-1]="("+f[n-1]+" + 1)",c(f)}function p(f){return f[n-2]="("+f[n-2]+" + 1)",c(f)}function m(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",c(f)}function c(f){let h=e.map((T,x)=>d(x,f)),g=h.join(","),b=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${b}))`}function d(f,h){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${h[f]} - 1`:`${h[f]}`}}};function kpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return ur({inputs:{x:o},backend:t});let u=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IC(o.shape,i):new xC(o.shape,i);return t.runWebGLProgram(u,[o],o.dtype)}var DW={kernelName:Qo,backendName:"webgl",kernelFunc:kpe};var CC=class{variableNames=["Image"];outputShape=[];userCode;customUniforms=[{name:"params",type:"vec4"}];constructor(e,t){let n=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var _W={kernelName:Ja,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=new CC(n.shape,s),[l,p]=C.getImageCenter(a,n.shape[1],n.shape[2]),m=[[l,p,Math.sin(o),Math.cos(o)]];return i.runWebGLProgram(u,[n],n.dtype,m)}};var vpe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Ape=Ae({opSnippet:vpe}),MW={kernelName:qa,backendName:"webgl",kernelFunc:Ape};var wpe="return inversesqrt(x);",Npe=Ae({opSnippet:wpe,cpuKernelImpl:pz}),RW={kernelName:Jo,backendName:"webgl",kernelFunc:Npe};var Bf=class{variableNames=["updates","indices","defaultValue"];outputShape;userCode;constructor(e,t,n,o,s,a,i=!0){this.outputShape=a;let u=Ve(s.length),l=Ve(a.length),p="";n===1?p="i":n===2&&(p="i, j");let m=`getIndices(${p})`,c="";o===1?c="i":o===2&&(c="i, coords[1]");let d=`getUpdates(${c})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Dpe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:m}=C.calculateShapes(s,o,a),c=[m/l,l];if(m===0)return t.makeTensorInfo(a,o.dtype);let d=ue({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),f=ue({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new Bf(u,i,d.shape.length,f.shape.length,p,c),b=t.runWebGLProgram(g,[f,d,h],f.dtype),T=ue({inputs:{x:b},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(h),T}var PW={kernelName:ja,backendName:"webgl",kernelFunc:Dpe};var SC=class{variableNames=["sortedSequence","values"];outputShape;userCode;customUniforms=[{name:"numInputs",type:"int"}];constructor(e,t,n,o){this.outputShape=[e,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=$().getNumber("WEBGL_VERSION")===2?s:a,u=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function _pe(r){let{inputs:e,backend:t,attrs:n}=r,{sortedSequence:o,values:s}=e,{side:a}=n,i=new SC(o.shape[0],o.shape[1],s.shape[1],a),u=[[o.shape[1]]];return t.runWebGLProgram(i,[o,s],"int32",u)}var EW={kernelName:Qu,backendName:"webgl",kernelFunc:_pe};var kC=class{variableNames=["c","a","b"];outputShape;userCode;constructor(e,t,n){this.outputShape=t;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let p=0;p<t.length;p++)l.push(`${i[p]}`),p<e&&u.push(`${i[p]}`);o=u.join(),s=l.join()}let a=Ve(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Mpe(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=new kC(n.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(a,[n,o,s],Pt(o.dtype,s.dtype))}var FW={kernelName:Ds,backendName:"webgl",kernelFunc:Mpe};var Rpe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${C.SELU_SCALEALPHA};
  float scale = ${C.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Ppe=Ae({opSnippet:Rpe}),LW={kernelName:tu,backendName:"webgl",kernelFunc:Ppe};var Epe=pa+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Fpe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Lpe=Ae({opSnippet:Epe,packedOpSnippet:Fpe,cpuKernelImpl:cz}),$W={kernelName:ts,backendName:"webgl",kernelFunc:Lpe};var $pe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Bpe=Ae({opSnippet:$pe}),BW={kernelName:ru,backendName:"webgl",kernelFunc:Bpe};var Ope=pa+`
  return sin(x);
`,zpe=Ae({opSnippet:Ope}),OW={kernelName:es,backendName:"webgl",kernelFunc:zpe};var Gpe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Wpe=Ae({opSnippet:Gpe}),zW={kernelName:Xa,backendName:"webgl",kernelFunc:Wpe};var Upe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Kpe=Ae({opSnippet:Upe}),GW={kernelName:nu,backendName:"webgl",kernelFunc:Kpe};var Vpe=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((b,T)=>b*T),u=[[0,0]];u.push(...a);for(let b=1+s.length;b<o.shape.length;++b)u.push([0,0]);let l=[],p=jD({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),m=C.getReshaped(p.shape,s,i,!1),c=C.getPermuted(m.length,s.length,!1),d=C.getReshapedPermuted(p.shape,s,i,!1),f=ue({inputs:{x:p},backend:t,attrs:{shape:m}}),h=Wt({inputs:{x:f},backend:t,attrs:{perm:c}}),g=ue({inputs:{x:h},backend:t,attrs:{shape:d}});return l.push(p),l.push(f),l.push(h),l.forEach(b=>t.disposeIntermediateTensorInfo(b)),g},WW={kernelName:Ms,backendName:"webgl",kernelFunc:Vpe};function Hpe(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=t.readSync(n.dataId),u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=t.readSync(a.dataId)[0],[m,c,d,f,h]=fz(i,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(c,n.dtype,m),t.makeTensorInfo([c[0]],o.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var UW={kernelName:Ju,backendName:"webgl",kernelFunc:Hpe};function qpe(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(t.readSync(o.dataId)),i=t.readSync(n.dataId),u=Array.from(t.readSync(s.dataId)),[l,p,m]=hz(i,n.shape,n.dtype,a,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}var KW={kernelName:ou,backendName:"webgl",kernelFunc:qpe};function jpe(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=iI(a,n.shape,n.dtype,i,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var VW={kernelName:el,backendName:"webgl",kernelFunc:jpe};function Xpe(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let a=t.readSync(n.dataId),i=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=iI(a,n.shape,n.dtype,i,u);return t.makeTensorInfo(p,n.dtype,l)}var HW={kernelName:tl,backendName:"webgl",kernelFunc:Xpe};function Ype(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1;if(s.dtype==="string"){let b=t.bufferSync(o),T=t.bufferSync(s),x=y.decodeString(t.readSync(a.dataId)[0]),I=mz(b,T,i,c,p,l,u,m,x,d);return t.makeTensorInfo(i,I.dtype,I.values)}let f=new Bf(l,u,o.shape.length,s.shape.length,m,[c,1],d),h=t.runWebGLProgram(f,[s,o,a],s.dtype),g=ue({inputs:{x:h},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(h),g}var qW={kernelName:rl,backendName:"webgl",kernelFunc:Ype};function Zpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=o.shape.length,p=new Array(l).fill(0),m=o.shape.slice();return u.map(c=>{let d=[...m];d[i]=c;let f=Ti({inputs:{x:o},backend:t,attrs:{begin:p,size:d}});return p[i]+=c,f})}var jW={kernelName:Rs,backendName:"webgl",kernelFunc:Zpe};var XW="return sqrt(x);",Qpe=Ae({opSnippet:XW,packedOpSnippet:XW,cpuKernelImpl:gz}),YW={kernelName:rs,backendName:"webgl",kernelFunc:Qpe};var Jpe="return x * x;",eme=Ae({opSnippet:Jpe}),ZW={kernelName:Ni,backendName:"webgl",kernelFunc:eme};var QW="return (a - b) * (a - b);",tme=dt({opSnippet:QW,packedOpSnippet:QW}),JW={kernelName:ss,backendName:"webgl",kernelFunc:tme};function rme({inputs:r,attrs:e,backend:t}){let{x:n}=r,o=Ir+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new Gr(n.shape,o);return t.runWebGLProgram(s,[n],n.dtype)}var eU={kernelName:Fs,backendName:"webgl",kernelFunc:rme};var vC=class{variableNames=["x"];outputShape;userCode;constructor(e,t,n){this.outputShape=n;let o=n.length,s=Ve(n.length),a=Ve(n.length),i="";if(o===1)i="coords * strides + begin";else{let u=0;i=n.map((l,p)=>(u++,n.length===1?`coords * strides[${p}] + begin[${p}]`:`coords[${u-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function nme(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),S;if(h)S=ue({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let _=It.computeOutShape(T,x,I),M=Ti({inputs:{x:o},backend:t,attrs:{begin:T,size:_}});S=ue({inputs:{x:M},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(M)}else if(t.shouldExecuteOnCPU([o])){let M=t.readSync(o.dataId),R=Ie(o.shape,o.dtype,M),E=bz(d,R,I,T);S=t.makeTensorInfo(f,o.dtype,E.values)}else{let M=new vC(T,I,d);S=t.runWebGLProgram(M,[o],o.dtype)}let w=ue({inputs:{x:S},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(S),w}var tU={kernelName:Ya,backendName:"webgl",kernelFunc:nme};function ome(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:m}=e,c=t.readSync(p.dataId),d=t.readSync(m.dataId),[f,h]=yz(c,d,o,s,a,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(m.shape,"int32",h)]}var rU={kernelName:Di,backendName:"webgl",kernelFunc:ome};function sme(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=t.readSync(s.dataId),u=t.readSync(a.dataId)[0],[l,p,m]=Tz(i,u,o),c=p.length;return[t.makeTensorInfo([c,2],"int32",l),t.makeTensorInfo([c],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(m))]}var nU={kernelName:nl,backendName:"webgl",kernelFunc:sme};function ame(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=t.readSync(s.dataId),i=xz(a,o);return t.makeTensorInfo(s.shape,"int32",i)}var oU={kernelName:ol,backendName:"webgl",kernelFunc:ame};var ime="return tan(x);",ume=Ae({opSnippet:ime}),sU={kernelName:is,backendName:"webgl",kernelFunc:ume};var lme=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,pme=Ae({opSnippet:lme}),aU={kernelName:us,backendName:"webgl",kernelFunc:pme};var AC=class{variableNames=["A"];outputShape;userCode;rank;constructor(e,t){let n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=mme(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function mme(r){let e=r.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${r[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${t[o]}, ${r[o]})`);return n.join()}function YD(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(c=>y.decodeString(c)):u,p=Ie(o.shape,o.dtype,l),m=Cz(p,s);return t.makeTensorInfo(m.shape,m.dtype,m.values)}let a=new AC(o.shape,s);return t.runWebGLProgram(a,[o],o.dtype)}var iU={kernelName:Dn,backendName:"webgl",kernelFunc:YD};var wC=class{variableNames=["x","indices"];outputShape;userCode;customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}];constructor(e){this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},NC=class{variableNames=["x","indices"];outputShape;userCode;customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}];constructor(e){this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function sm(r,e){e!==null&&r.disposeIntermediateTensorInfo(e)}function uU(r){let e=1;for(;e<r;)e*=2;return e}function cme(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n,i=$().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=$().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,p=l[l.length-1];if(t.shouldExecuteOnCPU([o])||p<i||s>u){let E=t.readSync(o.dataId),[O,G]=Sz(E,l,o.dtype,s,a);return[t.makeTensorInfo(O.shape,O.dtype,O.values),t.makeTensorInfo(G.shape,G.dtype,G.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,o.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(p===1)return[o,Mu({attrs:{shape:l,dtype:"int32",value:0},backend:t})];let m=t.texData.get(o.dataId),c=m!==null&&m.isPacked,d=c?t.unpackTensor(o):o,h=y.sizeFromShape(l)/p,g=ue({inputs:{x:d},attrs:{shape:[h,p]},backend:t});c&&sm(t,d);let b=uU(s),T=uU(p),x=null,I=()=>x===null?[g,g]:[g,x],S=(E,O,G)=>{let W=I(),H=new wC(G),V=[[p],[x===null?1:0],[Number.NEGATIVE_INFINITY],[E],[O]],Y=x;x=t.runWebGLProgram(H,W,"int32",V),sm(t,Y)};for(let E=1;E<b;E*=2){let O=E*2;for(let G=E;G>=1;G/=2)S(O,G,[h,T])}for(let E=T;E>b;E/=2){let O=I(),G=new NC([h,E/2]),H=[[p],[x===null?1:0],[b]],U=x;x=t.runWebGLProgram(G,O,"int32",H),sm(t,U);let V=b/2,Y=V*2;for(let j=V;j>=1;j/=2)S(Y,j,x.shape)}let w=x;x=Ti({inputs:{x},backend:t,attrs:{begin:0,size:[h,s]}}),sm(t,w);let _=UD({inputs:{x:g,indices:x},backend:t,attrs:{axis:1,batchDims:1}});sm(t,g);let M=l.slice(0,-1);M.push(s),w=x,x=ue({inputs:{x},attrs:{shape:M},backend:t}),sm(t,w);let R=_;return _=ue({inputs:{x:_},attrs:{shape:M},backend:t}),sm(t,R),[_,x]}var lU={kernelName:Za,backendName:"webgl",kernelFunc:cme};var DC=class{variableNames=["Image","Transforms"];outputShape;userCode;constructor(e,t,n,o,s,a){this.outputShape=a;let i=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function dme(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=new DC(m,c,a,i,u,g);return t.runWebGLProgram(b,[o,s],"float32")}var pU={kernelName:Qa,backendName:"webgl",kernelFunc:dme};function fme(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;gi(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=n.readSync(s.dataId),{outputValues:i,outputShape:u,indices:l}=kz(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([l.length],"int32",l)]}var mU={kernelName:qm,backendName:"webgl",kernelFunc:fme};function hme(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],l=new Array(i-1),p=0;for(let h=0;h<i;h++)h!==s&&(l[p++]=a.shape[h]);let m=[],c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){c[s]=h;let g=Ti({inputs:{x:a},backend:t,attrs:{begin:c,size:d}}),b=ue({inputs:{x:g},backend:t,attrs:{shape:l}});f[h]=b,m.push(g)}return m.forEach(h=>t.disposeIntermediateTensorInfo(h)),f}var cU={kernelName:Ps,backendName:"webgl",kernelFunc:hme};var _C=class{variableNames=["x","segmentIds"];outputShape;userCode;constructor(e,t){let n=e.windowSize,o=e.batchSize,s=e.inSize,a=e.numSegments,i=a*Math.ceil(s/n);this.outputShape=[o,i];let u="0.0",l="sumValue",p=Math.floor(n/4)*4,m=n%4,c=`
        sumValue += dot(values, segFilter);
    `,d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${c}
        }

        int inIdx = inOffset + ${p};
        if (${m===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${c}
        } else if (${m===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${c}
        } else if (${m===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${c}
        }
        setOutput(${l});
      }
    `}};function gme(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:a}=n,i=o.shape.length,u=[],l=0,p=C.getAxesPermutation([l],i),m=o;p!=null&&(m=Wt({inputs:{x:o},backend:t,attrs:{perm:p}}),u.push(m),l=C.getInnerMostAxes(1,i)[0]);let c=C.segment_util.computeOutShape(m.shape,l,a),d=y.sizeFromShape([m.shape[l]]),f=ue({inputs:{x:m},backend:t,attrs:{shape:[-1,d]}});u.push(f);let h=iu(o.dtype),g=(I,S,w,_,M)=>{let R=I.shape[0],E=I.shape[1],O=C.segment_util.segOpComputeOptimalWindowSize(E,M),G={windowSize:O,inSize:E,batchSize:R,numSegments:M},W=new _C(G,S),H=t.compileAndRun(W,[I,w],_);if(u.push(H),H.shape[1]===M)return H;let U=XD({backend:t,attrs:{start:0,stop:M,step:1,dtype:"float32"}}),V=YD({inputs:{x:U},backend:t,attrs:{reps:[E/O]}});return u.push(U),u.push(V),g(H,S,V,_,M)},b=g(f,"unsortedSegmentSum",s,h,a),T=ue({inputs:{x:b},backend:t,attrs:{shape:c}}),x=T;if(p!=null){u.push(T);let I=C.getUndoAxesPermutation(p);x=Wt({inputs:{x},backend:t,attrs:{perm:I}})}return u.forEach(I=>t.disposeIntermediateTensorInfo(I)),x}var dU={kernelName:sl,backendName:"webgl",kernelFunc:gme};var bme=[Qz,e3,t3,r3,o3,s3,a3,i3,p3,m3,c3,d3,f3,h3,g3,b3,y3,T3,x3,I3,C3,k3,v3,A3,_3,R3,P3,Wz,F3,$3,B3,O3,z3,G3,W3,U3,K3,V3,H3,X3,Y3,Z3,Q3,J3,eG,tG,rG,nG,oG,sG,aG,iG,uG,lG,pG,cG,dG,fG,hG,bG,yG,TG,xG,IG,CG,SG,kG,vG,Gz,AG,L3,wG,NG,DG,Uz,_G,MG,RG,PG,EG,FG,LG,$G,BG,OG,GG,WG,UG,KG,VG,HG,jG,YG,ZG,QG,JG,eW,sW,Hz,aW,iW,uW,lW,w3,pW,dW,fW,hW,gW,Kz,bW,yW,TW,xW,IW,N3,tW,CW,SW,kW,jz,vW,AW,wW,NW,DW,_W,MW,RW,PW,EW,FW,LW,$W,BW,OW,zW,S3,oW,GW,WW,UW,KW,VW,HW,qW,jW,YW,ZW,JW,eU,tU,rU,nU,oU,nW,Yz,sU,aU,iU,lU,pU,Zz,mU,cU,dU,mW];for(let r of bme)su(r);var xi=$();xi.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);xi.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);xi.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);xi.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1);xi.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);xi.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);xi.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);xi.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);xi.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);xi.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>0);xi.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);var MC=class{vendor;architecture;intelGPUGeneration;constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}};var RC=class{constructor(e){this.device=e}numUsedBuffers=0;numFreeBuffers=0;freeBuffers=new Map;usedBuffers=new Map;numBytesUsed=0;numBytesAllocated=0;acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){let o=fU(e,t);if(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(o).length>0){this.numFreeBuffers--;let a=this.freeBuffers.get(o).shift();return this.usedBuffers.get(o).push(a),a}this.numBytesAllocated+=e;let s=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(o).push(s),s}releaseBuffer(e,t,n){if(this.freeBuffers.size===0)return;let o=fU(t,n);this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).push(e),this.numFreeBuffers++,this.numUsedBuffers--;let s=this.usedBuffers.get(o),a=s.indexOf(e);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(a,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(e,t,n)},o=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function fU(r,e){return`${r}_${e}`}var PC=class{constructor(e){this.device=e}numUsedTextures=0;numFreeTextures=0;freeTextures=new Map;usedTextures=new Map;numBytesUsed=0;numBytesAllocated=0;acquireTexture(e,t,n,o){let s=gU(n),a=e*t*s,i=hU(e,t,n,o);if(this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.usedTextures.has(i)||this.usedTextures.set(i,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(i).length>0){this.numFreeTextures--;let l=this.freeTextures.get(i).shift();return this.usedTextures.get(i).push(l),l}this.numBytesAllocated+=a;let u=this.device.createTexture({size:[e,t],format:n,usage:o});return this.usedTextures.get(i).push(u),u}releaseTexture(e,t,n,o,s){if(this.freeTextures.size===0)return;let a=hU(t,n,o,s);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(e),this.numFreeTextures++,this.numUsedTextures--;let i=this.usedTextures.get(a),u=i.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");i.splice(u,1);let l=gU(o),p=t*n*l;this.numBytesUsed-=p}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function hU(r,e,t,n){return`${r}_${e}_${t}_${n}`}function gU(r){if(r==="rgba8unorm")return 16;throw new Error(`${r} is not supported!`)}function bU(r,e){if(Math.max(...r)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}var CU=(r,e,t,n)=>{let o={dtype:n.dtype,shape:n.shape},s=Tme(t,o,e),a=r.createShaderModule({code:s,label:e.constructor.name});return r.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})};function lr(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";if(r===5)return"vec5";if(r===6)return"vec6";throw Error(`GPU for rank ${r} is not yet supported`)}function ma(r){if(r===0)return"x";if(r===1)return"y";if(r===2)return"z";if(r===3)return"w";if(r===4)return"u";if(r===5)return"v";throw Error(`Index ${r} is not yet supported`)}function ce(...r){let e;switch(r.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${r[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function yU(r){let e;return e=`
     ${yme()}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${r?"main(getGlobalIndex());":"main();"};
      }
    `,e}function yme(){return`
  @compute @workgroup_size(workgroupSizeX, workgroupSizeY, workgroupSizeZ)
`}function Tme(r,e,t){let n=[],o=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(n.push(`
      const workgroupSizeX = ${t.workgroupSize[0]}u;
      const workgroupSizeY = ${t.workgroupSize[1]}u;
      const workgroupSizeZ = ${t.workgroupSize[2]}u;

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${kU(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${o} +
                localIndex);
        `}
      }
    `),t.isFromPixels){n.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${Of(e.dtype,t.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);let f=IU(t);return[TU,n.join(`
`),xU(e.shape),t.getUserCode(),yU(f)].join(`
`)}let s="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((f,h)=>{let g=lr(r[h].shape.length);s+=`${f.charAt(0).toLowerCase()+f.slice(1)}Shape : ${g}, `});let a=lr(e.shape.length);s+=`outShape : ${a}, `;let i=e.shape.length-1,u=lr(i);s+=`
         outShapeStrides: ${u}, `,t.size&&(s+="size : i32, "),t.uniforms&&(s+=t.uniforms),s+="};",s=wme(s),n.push(s),t.atomic?n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Of(e.dtype,t.isVec4)}>;
    `),t.variableNames.forEach((f,h)=>{n.push(`
      @group(0) @binding(${1+h}) var<storage, read> ${f}: array<${t.variableTypes?t.variableTypes[h]:Of(r[h].dtype,t.isVec4)}>;
        `)}),s!==""&&n.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);let l=kme(e.shape,t.dispatchLayout),p=[TU+xme,n.join(`
`),xU(e.shape),l,vme(e.shape.length)];t.atomic||p.push(Ame(e.shape,e.dtype,t.isVec4));let m=r.map((f,h)=>Sme(f,e.shape,t.variableTypes?t.variableTypes[h]==="vec4<f32>":t.isVec4,t.dispatchLayout.x.length===e.shape.length)).join(`
`);p.push(m),p.push(t.getUserCode());let c=IU(t);return p.push(yU(c)),p.join(`
`)}function SU(r,e,t,n){let o=r.shaderKey;if(r.isFromPixels)return o;let s=t.map(p=>p.dtype).concat(n.dtype),a=t.map(p=>C.getBroadcastDims(p.shape,n.shape)),i=t.map(p=>y.arraysEqual(p.shape,n.shape)).join("_"),u=a.map(p=>p.join("_")).join(";"),l=kU(r)?"flatDispatch":"";return o+="_"+(r.workgroupSize?r.workgroupSize.join(","):"")+e.map(p=>p.length).join(",")+s.join(",")+r.variableNames.join(",")+u+i+l,o}var TU=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`,xme=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function xU(r){let e=r.length;if(e<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";let t=y.computeStrides(r),n=lr(e),o=[];for(let a=0;a<e;a++)o.push(`d${a}`);if(t.length===1)return`    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let s;return s="var index2 = index;"+t.map((a,i)=>{let u=`let ${o[i]} = index2 / uniforms.outShapeStrides.${ma(i)}`,l=i===t.length-1?`let ${o[i+1]} = index2 - ${o[i]} * uniforms.outShapeStrides.${ma(i)}`:`index2 = index2 - ${o[i]} * uniforms.outShapeStrides.${ma(i)}`;return`${u}; ${l};`}).join(""),`
    fn getCoordsFromIndex(index : i32) -> ${n} {
      ${s}
      return ${n}(${o.join(",")});
    }
  `}function Ime(r,e){let t=r.name,n=r.shape.length,o=lr(n),s="get"+t.charAt(0).toUpperCase()+t.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,n),i=a.map(p=>`${p} : i32`).join(", ");if(n<1)return e?`
        fn ${s}() -> vec4<f32> {
          return vec4<f32>(${t}[0]);
        }
      `:`
      fn ${s}() ->f32 {
        return f32(${t}[0]);
      }
    `;let u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`,l=`${n}D`;return n===0&&(l="1D"),e?`
      fn ${s}(${i}) -> vec4<f32> {
        return vec4<f32>(${t}[getIndexFromCoords${l}(${o}(${a.join(",")}),
          ${u}) / 4]);
      }
      `:`
    fn ${s}(${i}) -> f32 {
      return f32(${t}[getIndexFromCoords${l}(${o}(${a.join(",")}),
        ${u})]);
    }
   `}function Cme(r,e,t,n){let o=r.name,s=o.charAt(0).toUpperCase()+o.slice(1),a="get"+s+"ByOutput",i=r.shape.length,u=e.length,l=lr(u);if(y.arraysEqual(r.shape,e)&&n)return t?`
      fn ${a}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${o}[globalIndex]);
      }

      fn ${a}Coords(coords : ${l}) -> vec4<f32> {
        return vec4<f32>(${o}[${u>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);
      }
      `:`
    fn ${a}Index(globalIndex : i32) -> f32 {
      return f32(${o}[globalIndex]);
    }

    fn ${a}Coords(coords : ${l}) -> f32 {
      return f32(${o}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}]);
    }
    `;let p=C.getBroadcastDims(r.shape,e),m=u-i,c="";if(i===0)return t?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      return get${s}();
    }

    fn ${a}Coords(coords : ${l}) -> vec4<f32> {
      return get${s}();
    }
  `:`
    fn ${a}Index(globalIndex : i32) -> f32{
      return get${s}();
    }

    fn ${a}Coords(coords : ${l}) -> f32{
      return get${s}();
    }
  `;u<2&&p.length>=1?c="coords = 0;":c=p.map(g=>`coords.${ma(g+m)} = 0;`).join(`
`);let d="";if(u<2&&i>0)d="coords";else if(u>1){let g=lr(i),b=r.shape.map((T,x)=>`coords.${ma(x+m)}`).join(", ");d=`${g}(${b})`}else d="coords";let f=`uniforms.${o.charAt(0).toLowerCase()+o.slice(1)}Shape`,h=`${i}D`;return t?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${c}
      return ${o}[getIndexFromCoords${h}(${d}, ${f}) / 4];
    }

    fn ${a}Coords(coordsIn : ${l}) -> vec4<f32> {
      var coords = coordsIn;
      ${c}
      return ${o}[getIndexFromCoords${h}(${d}, ${f}) / 4];
    }
  `:`
  fn ${a}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${c}
    return f32(${o}[getIndexFromCoords${h}(${d}, ${f})]);
  }

  fn ${a}Coords(coordsIn : ${l}) -> f32 {
    var coords = coordsIn;
    ${c}
    return f32(${o}[getIndexFromCoords${h}(${d}, ${f})]);
  }
`}function Sme(r,e,t,n){let o=Ime(r,t);return r.shape.length<=e.length&&(o+=Cme(r,e,t,n)),o}function kme(r,e){let{x:t,y:n=[],z:o=[]}=e,s=r.length,a=t.length+n.length+o.length;if(a!==s)return"";if(t.length===s)return`fn getOutputCoords() -> ${lr(s)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let i="",u=[t,n,o];for(let c=0;c<u.length;c++){let d=u[c];if(d.length!==0)if(d.length===1)i+=`let d${d[0]} = i32(globalId[${c}]);`;else{let f=bU(d,"uniforms.outShape");i+=`var index${c} = i32(globalId[${c}]);`;for(let h=0;h<f.length;h++)i+=`let d${d[h]} = index${c} / ${f[h]};`,h===f.length-1?i+=`let d${d[h+1]} = index${c} - d${d[h]} * ${f[h]};`:i+=`index${c} = index${c} - d${d[h]} * ${f[h]};`}}let l=[];for(let c=0;c<a;c++)l.push(`d${c}`);let p=lr(a),m=`fn getOutputCoords() -> ${p} {
  ${i}
`;return l.length===0?m+=`return ${p}(0); }`:m+=`return ${p}(${l.join(",")}); }`,m}function vme(r){let e="";switch(r){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:y.assert(!1,()=>`Unsupported ${r}D shape`);break}return e}function kU(r){return r.dispatch[1]===1&&r.dispatch[2]===1}function Of(r,e){return r==="float32"?e?"vec4<f32>":"f32":r==="int32"||r==="bool"?e?"vec4<i32>":"i32":r}function Ame(r,e,t){let n=r.length,o=Of(e,t),s;if(t?s=`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${o}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${o}(value);
    }`:s=`fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${o}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${o}(value);
    }`,n>=2){let a=["d0","d1","d2","d3","d4","d5"].slice(0,n),i=lr(n);t?s+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `:s+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `}return s}function wme(r){let e=/(\w+)\s*:\s*vec(5|6)/g;r=r.replace(e,n=>"@align(16) "+n);let t=/vec(5|6)\s*,\s*(\w+)/g;return r=r.replace(t,(n,o,s)=>`vec${o}, @align(16) ${s}`),r}function IU(r){return!(r.dispatchLayout.hasOwnProperty("y")&&r.dispatchLayout.y.length!==0||r.dispatchLayout.hasOwnProperty("z")&&r.dispatchLayout.z.length!==0)}var t0={};qe(t0,{ArrayBufferToTypedArray:()=>JD,GPUBytesPerElement:()=>QD,MatMulProgramType:()=>e0,computeDispatch:()=>le,computeWorkPerThreadForConv2d:()=>vg,computeWorkgroupInfoForMatMul:()=>ZD,computeWorkgroupSizeForConv2d:()=>kg,flatDispatchLayout:()=>ye,isWebGPUSupported:()=>Ag,tilesFitEvenlyIntoShape:()=>Dme});var am=r=>{let e=1;for(let t=0;t<r.length;t++)e*=r[t];return e};function Dme(r,e){if(r.length!==e.length)throw new Error(`Cannot compute whether rank ${r.length} tiles fit evenly into rank ${e.length} shape - ranks must match.`);return e.every((t,n)=>t%r[n]===0)}function le(r,e,t=[1,1,1],n=[1,1,1]){let[o,s,a]=[Math.ceil(am(r.x.map(i=>e[i]))/(t[0]*n[0])),r.y?Math.ceil(am(r.y.map(i=>e[i]))/(t[1]*n[1])):1,r.z?Math.ceil(am(r.z.map(i=>e[i]))/(t[2]*n[2])):1];return[o,s,a]}function ZD(r,e,t,n=!1){let o=[8,8,1],s=[4,4,1];return n||(r<=8&&(s[1]=1),e<=16&&t<=16&&(o[0]=4)),{workgroupSize:o,elementsPerThread:s}}function kg(r,e,t=!1){if(t)return[8,8,1];let n=am(r.x.map(s=>e[s])),o=am(r.y.map(s=>e[s]));return n<=4?[4,16,1]:o<=4?[16,4,1]:[16,16,1]}function vg(r,e,t=!1){if(t)return[4,4,1];let n=am(r.x.map(s=>e[s])),o=am(r.y.map(s=>e[s]));return n<=4?[1,2,1]:o<=4?[2,1,1]:[2,2,1]}function ye(r){return{x:r.map((e,t)=>t)}}function QD(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function JD(r,e){if(e==="float32")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${e}`)}function Ag(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}var e0=(s=>(s[s.MatMulReduceProgram=0]="MatMulReduceProgram",s[s.MatMulSplitKProgram=1]="MatMulSplitKProgram",s[s.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",s[s.MatMulPackedProgram=3]="MatMulPackedProgram",s[s.MatMulMax=4]="MatMulMax",s))(e0||{});var _me=$().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Mme=(r,e)=>{let t=r.limits.maxComputeWorkgroupsPerDimension,n=e.dispatchLayout,o=e.dispatch;if(o.every(a=>a<=t))return o;y.assert(o[0]>t&&n.y===void 0&&n.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let s=Math.ceil(Math.sqrt(o[0]));return s>t?(s=Math.ceil(Math.cbrt(o[0])),y.assert(s<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[s,s,s]):[s,s,1]},r0=class extends po{bufferManager;adapterInfo;device;queue;tensorMap;textureManager;thresholdToIncreaseWorkgroups;activeTimers;currentCommandEncoder;currentComputePass;commandQueueOwnedIds=new WeakSet;dispatchNumberInEncoder=0;disposed=!1;downloadWaitMs=0;dummyCanvas;dummyContext;tensorDataPendingDisposal=[];pipelineCache;programTimersStack;querySet;stagingPendingDisposal=[];supportTimeQuery;uniformPendingDisposal=[];uploadWaitMs=0;nextDataId(){return r0.nextDataId++}constructor(e,t){if(super(),!Ag())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new MC(t),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new RC(this.device),this.textureManager=new PC(this.device),this.tensorMap=new ha(this,rn()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),$().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;let n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;let{complexTensorInfos:o}=this.tensorMap.get(e);return o!=null&&(this.disposeData(o.real.dataId,t),this.disposeData(o.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){let t=this.tensorMap.get(e);if(!(!t||!t.resourceInfo)){if("texture"in t.resourceInfo){let n=t.resourceInfo;n.texture instanceof GPUTexture&&this.textureManager.releaseTexture(n.texture,n.width,n.height,n.format,n.usage),n.texture=null}else{let n=t.resourceInfo;this.bufferManager.releaseBuffer(n.buffer,n.size,n.usage),n.buffer=null}t.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);t.refCount--}}write(e,t,n){if(n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.tensorMap.set(o,{dtype:n,shape:t,values:e,refCount:1}),o}move(e,t,n,o,s){if(o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:o,shape:n,values:t,refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){let n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);let o=n.getMappedRange().slice(0);return n.unmap(),n!=null&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),$().getBool("WEBGPU_USE_PROFILE_TOOL")&&(y.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),o}convertAndCacheOnCPU(e,t){let n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){let t=this.tensorMap.get(e),{values:n}=t;if(n==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let t=this.tensorMap.get(e),{values:n}=t;if(n!=null)return this.convertAndCacheOnCPU(e,n);let o;if(t.dtype==="complex64"){let s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),a=s[0],i=s[1];o=C.mergeRealAndImagArrays(a,i)}else{let s=t.resourceInfo,a=await this.getBufferData(s.buffer,s.size);o=JD(a,t.dtype)}return this.convertAndCacheOnCPU(e,o),o}readToGPU(e){let t=this.tensorMap.get(e),{values:n,dtype:o,shape:s,resourceInfo:a}=t;if(o==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(a==null)throw n!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let i=a.size,u=this.bufferManager.acquireBuffer(i,a.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a.buffer,0,u,0,i),this.submitQueue();let l=this.makeTensorInfo(s,o),p=rn().makeTensorFromTensorInfo(l),m=this.tensorMap.get(l.dataId);return m.resourceInfo={size:i,usage:this.defaultGpuBufferUsage(),buffer:u},{tensorRef:p,buffer:u,bufSize:i}}bufferSync(e){let t=this.readSync(e.dataId);if(e.dtype==="string")try{let n=t.map(o=>y.decodeString(o));return Ie(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ie(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=y.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=y.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let i={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(s);return i.kernelMs=y.sum(u),i.getExtraProfileInfo=()=>u.map((l,p)=>({name:a[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,i}makeTensorInfo(e,t,n){return t==="string"&&n!=null&&n.length>0&&y.isString(n[0])&&(n=n.map(s=>y.encodeString(s))),{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;let t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){let o=t.resourceInfo;return o.texture instanceof GPUExternalTexture?o.texture:o.texture.createView()}let n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){let t=this.tensorMap.get(e);if(t.resourceInfo)return;let n=QD(t.dtype)*y.sizeFromShape(t.shape),o=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:o},t.values){let s=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),a=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),s.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s,0,o,0,n);let i={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:s};this.stagingPendingDisposal.push(i)}}makeUniforms(e){let t=0,n=0,o=[];e.forEach(u=>{u.data.length===0&&(u.data=[1]);let l;switch(u.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:y.assert(!1,()=>`Unsupported ${u.data.length}D shape`)}(n===5||n===6)&&(l=16),t=Math.ceil(t/l)*l,n=u.data.length,o.push(t),t+=u.data.length*4});let s=new ArrayBuffer(t);e.forEach((u,l)=>{let p=o[l];u.type==="int32"?new Int32Array(s,p,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(s,p,u.data.length).set(u.data):new Float32Array(s,p,u.data.length).set(u.data)});let a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,s,0,t);let i={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(i),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,n,o,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),y.sizeFromShape(s.shape)===0)return this.tensorMap.get(s.dataId).values=y.getTypedArrayFromDType(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=Mme(this.device,e);let a=[],i=[];if(!e.isFromPixels){a.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=t.concat(s).map(b=>b.shape);let h="int32";i.map(b=>{a.push({type:h,data:b})});let g=y.computeStrides(s.shape);if(a.push({type:h,data:g}),e.size){let b=y.sizeFromShape(e.outputShape);a.push({type:h,data:[e.isVec4?b/4:b]})}}let u=t.map((h,g)=>{if(h.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(h.dataId),{dtype:this.tensorMap.get(h.dataId).dtype,shape:h.shape,name:e.variableNames[g]}}),l=SU(e,i,u,s),p;l in this.pipelineCache?p=this.pipelineCache[l]:(p=CU(this.device,e,u,s),this.pipelineCache[l]=p),o&&(a=[...a,...o]);let m=[this.tensorToBinding(s),...t.map(h=>this.tensorToBinding(h)),this.makeUniforms(a)],c=this.device.createBindGroup({layout:p.getBindGroupLayout(0),entries:m.map((h,g)=>({binding:g,resource:h}))});this.ensureCommandEncoderReady();let d=this.getComputePass(),f=this.activeTimers!=null;return f&&this.supportTimeQuery&&d.writeTimestamp(this.querySet,0),d.setPipeline(p),d.setBindGroup(0,c),d.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),f&&this.supportTimeQuery&&d.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(h=>{this.commandQueueOwnedIds.add(h.dataId)}),this.commandQueueOwnedIds.add(s.dataId),$().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),f&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}async getTimeFromQuerySet(e){let t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);let o=new BigUint64Array(n.getMappedRange()),s=Number(o[1]-o[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,t=_me){return $().getBool("WEBGPU_CPU_FORWARD")&&e.every(n=>this.tensorMap.get(n.dataId).resourceInfo==null&&y.sizeFromShape(n.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}},zf=r0;K(zf,"nextDataId",0);Ag()&&ml("webgpu",async()=>{$().set("CHECK_COMPUTATION_FOR_ERRORS",!1);let r={powerPreference:$().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(r),t={};e.features.has("timestamp-query-inside-passes")&&(t.requiredFeatures=["timestamp-query-inside-passes"]);let n=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:n.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:n.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:n.maxStorageBufferBindingSize};let o=await e.requestDevice(t),s=await e.requestAdapterInfo();return new zf(o,s)},3);var vU=`
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `,AU=`
  if (isNaN.r) {
    resultTemp.r = valueForNaN;
  }
  if (isNaN.g) {
    resultTemp.g = valueForNaN;
  }
  if (isNaN.b) {
    resultTemp.b = valueForNaN;
  }
  if (isNaN.a) {
    resultTemp.a = valueForNaN;
  }
  `,o0=`
  let isNaN = isnanVec4(a) | isnanVec4(b);
  ${AU}
  `,Rme="return a + b;",Pme="return areal * breal - aimag * bimag;",Eme="return areal * bimag + aimag * breal;",Fme="return a / b;",Lme="return f32(a == b);",$me="return vec4<f32>(a == b);",Bme="return f32(a > b);",Ome="return vec4<f32>(a > b);",zme="return f32(a >= b);",Gme="return vec4<f32>(a >= b);",Wme=`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
`,Ume=`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
`,Kme="return f32(a < b);",Vme="return vec4<f32>(a < b);",Hme="return f32(a <= b);",qme="return vec4<f32>(a <= b);",jme="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",Xme=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Yme=`
  ${vU}
  if (b == 0.) {
    return uniforms.NAN;
  }
  var resultTemp = a % b;
  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {
    return resultTemp;
  } else {
    return (resultTemp + b) % b;
  }
`,Zme=`
  let valueForNaN = uniforms.NAN;
  var resultTemp = vec4<f32>(a % b);
  ${o0}

  if (b[0] == 0.) {
    resultTemp[0] = uniforms.NAN;
  }
  if (b[1] == 0.) {
    resultTemp[1] = uniforms.NAN;
  }
  if (b[2] == 0.) {
    resultTemp[2] = uniforms.NAN;
  }
  if (b[3] == 0.) {
    resultTemp[3] = uniforms.NAN;
  }

  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }

  return resultTemp;
`,Qme="return a * b;",Jme=`
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`,ece=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${o0}

  return resultTemp;
`,tce=`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
`,rce=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
  let valueForNaN = uniforms.NAN;
  ${AU}
  return resultTemp;
`,nce="if (a < 0.0) { return b * a; }  return a;",oce=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,sce="return (a - b) * (a - b);",ace="return a - b;";function n0(r,e,t="uniforms.NAN"){let n=e?o0:vU;return e?`
    let valueForNaN = ${t};
    var resultTemp = vec4<f32>(${r}(a, b));
    `+n+`
    return resultTemp;
  `:n+`
    return ${r}(a, b);
  `}function Gf(r,e){switch(r){case 0:return Rme;case 1:return n0("atan2",e);case 2:return Eme;case 3:return Pme;case 4:return Fme;case 5:return e?$me:Lme;case 6:return e?Ome:Bme;case 7:return e?Gme:zme;case 8:return e?Ume:Wme;case 9:return e?Vme:Kme;case 10:return e?qme:Hme;case 11:return e?Xme:jme;case 12:return n0("max",e);case 13:return n0("min",e);case 14:return e?Zme:Yme;case 15:return Qme;case 16:return e?ece:Jme;case 17:return e?rce:tce;case 18:return e?oce:nce;case 19:return sce;case 20:return ace;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var ice="return abs(a);",uce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,lce=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,pce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,mce="return asinh(a);",cce=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,dce=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,fce="return ceil(a);",hce="return cos(a);",gce=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,bce="return exp(a) - 1.0;",yce="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Tce=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,xce=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${C.ERF_P};
  let a1 = ${C.ERF_A1};
  let a2 = ${C.ERF_A2};
  let a3 = ${C.ERF_A3};
  let a4 = ${C.ERF_A4};
  let a5 = ${C.ERF_A5};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,Ice="return exp(a);",Cce="return floor(a);",Sce="return f32(!isnan(a) && !isinf(a));",kce="return f32(isinf(a));",vce="return f32(isnan(a));",Ace="return a;",wce=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,Nce=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,Dce="return f32(!(a >= 1.0));",_ce="return -a;",Mce="if (a < 0.0) { return uniforms.alpha * a; } return a;",Rce=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Pce="return 1.0 / a;",Ece="return select(a, 0.0, a < 0.0);",Fce="return clamp(a, 0.0, 6.0);",Lce="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",$ce=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,Bce="return inverseSqrt(a);",Oce="return 1.0 / (1.0 + exp(-1.0 * a));",zce="return sin(a);",Gce=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,Wce="return sqrt(a);",Uce="return a * a;",Kce="return tan(a);",Vce=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Hce="return f32(i32((a)));";function Ru(r,e){switch(r){case 0:return ice;case 1:return uce;case 2:return lce;case 3:return pce;case 4:return mce;case 5:return cce;case 6:return dce;case 8:return hce;case 9:return gce;case 7:return fce;case 10:return e?Tce:yce;case 11:return xce;case 12:return Ice;case 13:return bce;case 14:return Cce;case 15:return Sce;case 16:return kce;case 17:return vce;case 18:return Ace;case 19:return wce;case 20:return Nce;case 21:return Dce;case 22:return _ce;case 25:return e?Rce:Mce;case 26:return Pce;case 23:return e?$ce:Ece;case 24:return e?Lce:Fce;case 27:return Bce;case 30:return Oce;case 28:return zce;case 29:return Gce;case 31:return Wce;case 32:return Uce;case 33:return Kce;case 34:return Vce;case 35:return Hce;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var tr=r=>{switch(r){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${r}-component is not supported.`)}};function en(r,e=!1,t=!1,n=3){if(r===null)return"";let o="";if(r==="linear")o=Ru(18);else if(r==="relu")o=Ru(23,t);else if(r==="elu")o=Ru(10,t);else if(r==="relu6")o=Ru(24,t);else if(r==="prelu")o=Gf(18,t);else if(r==="sigmoid")o=Ru(30,t);else if(r==="leakyrelu")o=Ru(25,t);else throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);let a=tr(t?4:1),i="";return e?i=`
      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${o}
      }`:i=`
      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {
        ${o}
      }`,i}function no(r,e){return`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}function s0(r,e,t,n,o=!1,s=!1,a=!1,i=1){y.assert(t&&i===1||!t,()=>`transposeA ${t} is not compatible with component size ${i}`);let u=`
      let batch = ${r?"0":"batchIn"};
      ${t?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,l=n?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${tr(i)} {
    var value = ${tr(i)}(0.0);
    let col = colIn * ${i};
    ${o&&a?u:`
    ${t?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${u}
    }
    `}
    return value;
  }

  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${tr(i)} {
    let col = colIn * ${i};
    let batch = ${e?"0":"batchIn"};
    var value = ${tr(i)}(0.0);
    ${l}
    return value;
  }
  `}function wg(r,e,t,n,o,s,a=!1,i=!1,u=!1,l=1){return`
  ${s0(t,n,o,s,a,i,u,l)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${tr(l)}) {
    let col = colIn * ${l};
    ${a&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${no(r,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}var qce=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `,jce=(r,e)=>r?`
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${e===3?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${e===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;function im(r,e,t=!1,n=32,o=!1,s=32,a=!1){let i=e[1]*r[1],u=e[0]*r[0],l=t?i:n,p=t?n:i,m=l/e[0],c=n/e[1];return y.assert((t&&m===4&&r[1]===4||!t&&(m===3||m===4))&&l%e[0]===0&&n%e[1]===0&&r[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${m} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${m} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}. tileInner ${n} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${r[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${m}<f32>, ${l/m}>, ${p}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/r[0]}>, ${n}>;

  const rowPerThread = ${r[1]};
  const colPerThread = ${r[0]};
  const innerElementSize = ${m};
  const tileInner = ${n};

  ${ce()} {
    let localRow = i32(localId.y);
    let tileRow = ${a?"0":"localRow * rowPerThread"};
    let tileCol = i32(localId.x);

    let globalRow = ${a?"0":"i32(globalId.y) * rowPerThread"};
    let globalCol = i32(globalId.x);
    let batch = ${o?"0":"i32(globalId.z)"};
    let globalRowStart = i32(workgroupId.y) * ${i};

    let numTiles = ${o?`${Math.ceil(s/n)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

    var acc: array<vec4<f32>, rowPerThread>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${c};
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${qce(t)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
        }
        kStart = kStart + tileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
            let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
            let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
            let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
            ${m===3?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

            ${jce(t,m)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}var wU=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Xce=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function um(r,e,t=!1,n=32,o=!1,s=32,a=!1){let i=r[1]*e[1],u=r[0]*e[0],l=t?i:n,p=t?n:i;y.assert(p%e[1]===0&&l%e[0]===0&&n%e[1]===0,()=>`tileAHight ${p} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}, tileInner ${n} must be divisible by workgroupSize[1]${e[1]}`);let m=p/e[1],c=l/e[0],d=n/e[1],f=a?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${i};
      let globalColStart = i32(workgroupId.x) * ${u};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${e[0]}) {
            ${wU(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batch,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + tileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, colPerThread>;
        for (var k = 0; k < tileInner; k = k + 1) {
          for (var inner = 0; inner < colPerThread; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                  ACached * BCached[innerCol];
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * rowPerThread;
  let tileCol = i32(localId.x) * colPerThread;

  let globalRow = i32(globalId.y) * rowPerThread;
  let globalCol = i32(globalId.x) * colPerThread;
  let globalRowStart = i32(workgroupId.y) * ${i};

  let tileRowA = i32(localId.y) * ${m};
  let tileColA = i32(localId.x) * ${c};
  let tileRowB = i32(localId.y) * ${d};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t = t + 1) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < ${c}; innerCol = innerCol + 1) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${wU(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batch,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + tileInner;
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, colPerThread>;
    for (var k = 0; k < tileInner; k = k + 1) {
      for (var inner = 0; inner < colPerThread; inner = inner + 1) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        ${Xce(t)}
        for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${l}>, ${p}>;
    var<workgroup> mm_Bsub : array<array<f32, ${u}>, ${n}>;
    const rowPerThread = ${r[1]};
    const colPerThread = ${r[0]};
    const tileInner = ${n};

    ${ce()} {
      let batch = ${o?"0":"i32(globalId.z)"};
      let numTiles = ${o?`${Math.ceil(s/n)}`:"(uniforms.dimInner - 1) / tileInner + 1"};
      var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

      var acc : array<array<f32, colPerThread>, rowPerThread>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${f}
    }
  `}var Yce=r=>r?`
      mm_readA(batch, colA, globalRow),
      mm_readA(batch, colA + 1, globalRow),
      mm_readA(batch, colA + 2, globalRow),
      mm_readA(batch, colA + 3, globalRow)
  `:`
      mm_readA(batch, globalRow, colA),
      mm_readA(batch, globalRow, colA + 1),
      mm_readA(batch, globalRow, colA + 2),
      mm_readA(batch, globalRow, colA + 3)
  `;function Zce(r,e=!1){return y.assert(r[1]===1&&r[2]===1,()=>`A linear work group size is required. But got ${r}.`),`
    const tileSize = ${r[0]*4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${ce()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / tileSize + 1;
      let batch = i32(globalId.z);
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * tileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Yce(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < tileSize / 4; k = k + 1) {
          let rowB = t * tileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),
                              mm_readB(batch, rowB + 1, globalCol),
                              mm_readB(batch, rowB + 2, globalCol),
                              mm_readB(batch, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}var EC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize;elementsPerThread;transposeA;transposeB;addBias;activation;hasPreluActivationWeights;batchAEqualOne;batchBEqualOne;fitAOuter;fitBOuter;fitInner;tileInner;isVectorA;isVec4;sequentialAccessByThreads;constructor(e,t,n,o,s=!1,a=!1,i=null,u=null,l=null,p=!1){this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};let m=s?e[1]:e[2];if(this.isVec4=(m%4===0&&!s||t[1]%4===0&&s)&&t[2]%4===0&&!a,this.isVectorA=t[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{let f=ZD(t[1],m,t[2],s);this.workgroupSize=f.workgroupSize,this.elementsPerThread=f.elementsPerThread}this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);let c=i!=null,d=l!=null;c&&this.variableNames.push("bias"),d&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=p,this.transposeA=s,this.transposeB=a,this.addBias=c,this.activation=u,this.hasPreluActivationWeights=d,this.batchAEqualOne=n,this.batchBEqualOne=o,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],m),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${a}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){let o=this.workgroupSize[1]*this.elementsPerThread[1],s=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=s;let a=e%o===0,i=t%s===0,u=n%this.tileInner===0;return[a,i,u]}getUserCode(){return`
      ${en(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${wg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?im(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?Zce(this.workgroupSize,this.transposeA):um(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads)}
    `}};function Qce(){return`
    var<workgroup> sumValues : array<f32, workgroupSizeX>;
    ${ce()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workgroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workgroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}var FC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize=[256,1,1];transposeA;transposeB;addBias;activation;hasPreluActivationWeights;batchAEqualOne;batchBEqualOne;constructor(e,t,n,o=!1,s=!1,a=null,i=null,u=null){this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize);let l=a!=null,p=u!=null;l&&this.variableNames.push("bias"),p&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=s,this.addBias=l,this.activation=i,this.hasPreluActivationWeights=p,this.batchAEqualOne=t,this.batchBEqualOne=n,this.shaderKey=`matMulReduce_${this.activation}_${o}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${en(this.activation,this.hasPreluActivationWeights)}
      ${wg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${Qce()}
    `}};function Jce(r){let e=r[1],t=r[0],n=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${n}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${ce()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batch, globalRow, globalColA);
    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${n};
    globalRowB = globalRowB + ${n};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batch, globalRow, globalColA);
      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${n};
      globalRowB = globalRowB + ${n};

      for (var k = 0; k < ${n}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}var LC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize=[16,8,1];transposeA;transposeB;addBias;activation;hasPreluActivationWeights;batchAEqualOne;batchBEqualOne;constructor(e,t,n,o=!1,s=!1,a=null,i=null,u=null){this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];let l=a!=null;l&&this.variableNames.push("bias");let p=u!=null;p&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=s,this.addBias=l,this.activation=i,this.hasPreluActivationWeights=p,this.batchAEqualOne=e[0]===1,this.batchBEqualOne=t[0]===1,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${o}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${en(this.activation,this.hasPreluActivationWeights)}
      ${wg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${Jce(this.workgroupSize)}
    `}};var $C=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","B"];uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize=[8,8,1];elementsPerThread;transposeA;transposeB;atomic=!0;batchAEqualOne;batchBEqualOne;isVec4=!1;splitedDimInner=128;constructor(e,t,n,o,s=!1,a=!1){y.assert(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(s&&this.outputShape[1]%4===0||!s&&t%4===0)&&this.outputShape[2]%4===0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=le(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=a,this.batchAEqualOne=n,this.batchBEqualOne=o,this.shaderKey=`matMulSplitK_${s}_${a}_${n}_${o}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){let e=o=>`
      for (var i = 0; i < ${o}; i = i + 1)
      {
        var oldValue = atomicLoad(&(result[flatIndex + i]));
        var exchanged = false;
        for (; !exchanged;) {
          let newValueF32 = bitcast<f32>(oldValue) + ${o>1?"value[i]":"value"};
          let newValue = bitcast<i32>(newValueF32);
          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);
          oldValue = res.old_value;
          exchanged = res.exchanged;
        }
      }
      `,t=this.isVec4?4:1;return`
      ${s0(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,t)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${tr(t)}) {
        let col = colIn * ${t};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          ${e(t)}
        }
      }
      ${this.isVec4?im(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):um(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}},BC=class{outputShape;shaderKey;uniforms="";dispatchLayout;dispatch;variableNames=["x"];workgroupSize=[64,1,1];size=!0;addBias;activation;hasPreluActivationWeights;constructor(e,t=null,n=null,o=null){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=o!=null,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`
    ${en(this.activation,this.hasPreluActivationWeights)}
    ${ce("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${no(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}};var OC=class{variableNames=[];outputShape=[];shaderKey;dispatchLayout;dispatch;uniforms="value : f32,";workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${ce("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};function mn(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||y.inferDtype(o),s==="string"){let a=y.getArrayFromDType(s,y.sizeFromShape(n));return a.fill(o),e.makeTensorInfo(n,s,a)}else{let a=new OC(n),i=[{type:"float32",data:[o]}];return e.runWebGPUProgram(a,[],s,i)}}var NU={kernelName:Ai,backendName:"webgpu",kernelFunc:mn};function Se(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(o,s),i=y.sizeFromShape(a);return y.assert(s===i,()=>`The new shape (${a}) has ${i} elements and the old shape (${n.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var DU={kernelName:Ns,backendName:"webgpu",kernelFunc:Se};function lm({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,m=t?r.shape[l-2]:r.shape[l-1],c=n?e.shape[p-1]:e.shape[p-2],d=t?r.shape[l-1]:r.shape[l-2],f=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),b=y.sizeFromShape(h),T=y.sizeFromShape(g),I=Dr.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);y.assert(m===c,()=>`Error in matMul: inner shapes (${m}) and (${c}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let S=t?[b,m,d]:[b,d,m],w=n?[T,f,c]:[T,c,f],_=Se({inputs:{x:r},backend:o,attrs:{shape:S}}),M=Se({inputs:{x:e},backend:o,attrs:{shape:w}}),R=[_,M],E=Math.max(b,T),O=b===1,G=T===1,W=[_,M],H=[{type:"int32",data:[d]},{type:"int32",data:[f]},{type:"int32",data:[m]}],U,V,Y=[E,d,f],j=$().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(j<0){let ne=$().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),oe=ne>0?ne:o.thresholdToIncreaseWorkgroups,ae=E*Math.ceil(d/32)*Math.ceil(f/32);ae<=oe||d<=8&&ae<=oe*2?E*d*f<=128?j=0:E===1&&c>=2e3?j=1:j=2:j=3}switch(j){case 0:U=new FC(Y,O,G,t,n,s,u,a);break;case 1:{if(V=mn({backend:o,attrs:{shape:Y,value:0,dtype:r.dtype}}),U=new $C(Y,c,O,G,t,n),s||u){V=o.runWebGPUProgram(U,W,r.dtype,H,V);let oe=new BC(V.shape,s,u,a),ae=null,se=[V];s&&se.push(s),a&&se.push(a),u==="leakyrelu"&&(ae=[{type:"float32",data:[i]}],oe.uniforms+=" alpha : f32,");let ie=o.runWebGPUProgram(oe,se,V.dtype,ae);R.push(V);let he=Se({inputs:{x:ie},backend:o,attrs:{shape:I}});R.push(ie);for(let Te of R)o.disposeData(Te.dataId);return he}break}case 2:U=new LC(S,w,Y,t,n,s,u,a);break;case 3:let ne=o.adapterInfo.isIntel();U=new EC(S,Y,O,G,t,n,s,u,a,ne);break;default:throw new Error(`Unsupported MatMulProgramType ${j}.`)}s&&W.push(s),a&&W.push(a),u==="leakyrelu"&&(H.push({type:"float32",data:[i]}),U.uniforms+=" alpha : f32,"),V=o.runWebGPUProgram(U,W,r.dtype,H,V);let te=Se({inputs:{x:V},backend:o,attrs:{shape:I}});R.push(V);for(let ne of R)o.disposeData(ne.dataId);return te}function ede(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n;return lm({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:m,activation:p})}var _U={kernelName:Ls,backendName:"webgpu",kernelFunc:ede};var Ng=class{variableNames=["AReal","AImag","BReal","BImag"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[128,1,1];op;size=!0;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Gf(this.op,!1)}
      }

      ${ce("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};var pm=class{dispatch;dispatchLayout;isVec4;op;outputShape;shaderKey;size=!0;variableNames=["A","B"];workgroupSize;workPerThread;lastDimensionSize;useSharedMemoryWithA;useSharedMemoryWithB;type;constructor(e,t,n){this.outputShape=C.assertAndGetBroadcastShape(t,n),this.dispatchLayout=ye(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(y.arraysEqual(t,n)&&y.sizeFromShape(t)%4===0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workgroupSize=[128,1,1]),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}getUserCode(){let e,t=this.isVec4?"vec4<f32>":"f32",n=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${Gf(this.op,this.isVec4)}
    };
    `;if(this.type==="shared"){let o=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",s=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${o}];`:`let a = sharedBuf[${o}];
          let b = getBByOutputIndex(index);`;e=`
        ${n}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${ce("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${n}
       ${ce("index")} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}};function pr(r){let{inputs:e}=r,{x:t}=e;return r.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var MU={kernelName:Vn,backendName:"webgpu",kernelFunc:pr};function ys(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),a=t.tensorMap.get(s.dataId),i=pr({inputs:{x:n},backend:t}),u=pr({inputs:{x:o},backend:t});return a.complexTensorInfos={real:i,imag:u},s}var RU={kernelName:zu,backendName:"webgpu",kernelFunc:ys};var ca=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A"];workgroupSize;op;uniforms;size=!0;constructor(e,t){this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Ru(this.op,!1)}
      }
      ${ce("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};function Re({opType:r,cpuKernelImpl:e,dtype:t}){return({inputs:n,backend:o})=>{let{x:s}=n,a=o,i=t||s.dtype;if(a.shouldExecuteOnCPU([s])&&e!=null){let l=a.tensorMap.get(s.dataId),p=e(l.values,i);return a.makeTensorInfo(s.shape,i,p)}let u=new ca(s.shape,r);return a.runWebGPUProgram(u,[s],i)}}function ft({opType:r,cpuKernelImpl:e,supportsComplex:t=!1,dtype:n}){return({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(t&&a.dtype==="complex64"){let m=u.tensorMap.get(a.dataId),c=u.tensorMap.get(i.dataId),d,f;if(r!==15)[d,f]=[[m.complexTensorInfos.real,c.complexTensorInfos.real],[m.complexTensorInfos.imag,c.complexTensorInfos.imag]].map(g=>{let[b,T]=g,x={dataId:b.dataId,dtype:b.dtype,shape:a.shape},I={dataId:T.dataId,dtype:T.dtype,shape:i.shape},S=new pm(r,a.shape,i.shape);return u.runWebGPUProgram(S,[x,I],Pt(b.dtype,T.dtype))});else{let g=new Ng(3,a.shape,i.shape),b=new Ng(2,a.shape,i.shape),T=[{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:a.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape}];d=u.runWebGPUProgram(g,T,"float32"),f=u.runWebGPUProgram(b,T,"float32")}let h=ys({inputs:{real:d,imag:f},backend:u});return u.disposeData(d.dataId),u.disposeData(f.dataId),h}let l=n||Pt(a.dtype,i.dtype);if((a.dtype==="string"||i.dtype==="string"||u.shouldExecuteOnCPU([a,i]))&&e!=null){let m=u.tensorMap.get(a.dataId).values,c=u.tensorMap.get(i.dataId).values,d=a.dtype==="string"?C.fromUint8ToStringArray(m):m,f=a.dtype==="string"?C.fromUint8ToStringArray(c):c,[h,g]=e(a.shape,i.shape,d,f,l);return u.makeTensorInfo(g,l,h)}let p=new pm(r,a.shape,i.shape);return u.runWebGPUProgram(p,[a,i],l)}}var{addImpl:PU,castImpl:EU,ceilImpl:FU,concatImpl:LU,equalImpl:$U,expImpl:BU,expm1Impl:OU,floorImpl:zU,gatherNdImpl:GU,gatherV2Impl:WU,greaterEqualImpl:UU,greaterImpl:KU,lessEqualImpl:VU,lessImpl:HU,logImpl:qU,maxImpl:jU,maximumImpl:XU,minimumImpl:YU,multiplyImpl:ZU,negImpl:QU,notEqualImpl:JU,prodImpl:eK,rangeImpl:tK,rsqrtImpl:rK,scatterImpl:nK,simpleAbsImpl:oK,sliceImpl:sK,stridedSliceImpl:aK,stringNGramsImpl:iK,subImpl:uK,tileImpl:lK,topKImpl:pK,transposeImpl:mK,uniqueImpl:i_r}=ff;var tde=Re({opType:0,cpuKernelImpl:oK}),cK={kernelName:xs,backendName:"webgpu",kernelFunc:tde};var rde=Re({opType:1}),dK={kernelName:ya,backendName:"webgpu",kernelFunc:rde};var nde=Re({opType:2}),fK={kernelName:Ta,backendName:"webgpu",kernelFunc:nde};var ode=ft({opType:0,cpuKernelImpl:PU,supportsComplex:!0}),hK={kernelName:Nn,backendName:"webgpu",kernelFunc:ode};var zC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames;workPerThread=1;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e[0],this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let e=[];this.variableNames.forEach(o=>{e.push(`let v${o} = get${o}ByOutputCoords(coords);`)});let t=this.variableNames.map(o=>`v${o}`).join(" + ");return`
      ${ce("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}};function sde(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return pr({inputs:{x:n[0]},backend:t});let o=n.map(i=>i.dtype).reduce((i,u)=>Pt(i,u)),s=n.map(i=>i.shape),a=new zC(s);return t.runWebGPUProgram(a,n,o)}var gK={kernelName:co,backendName:"webgpu",kernelFunc:sde};var GC=class{variableNames=["A"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[16,16,1];constructor(e,t){let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return y.assert(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`),`
      const tileSize = ${this.workgroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${ce()} {
        var x = i32(workgroupId.x) * tileSize + i32(localId.x);
        var y = i32(workgroupId.y) * tileSize + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * tileSize + i32(localId.x);
        y = i32(workgroupId.x) * tileSize + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}};var WC=class{variableNames=["A"];shaderKey;outputShape;dispatchLayout;dispatch;workPerThread=1;workgroupSize=[64,1,1];newDim;size=!0;constructor(e,t){let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){let e=lr(this.outputShape.length),t=ade(this.newDim);return`
      ${ce("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function ade(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=new Array(e);for(let n=0;n<r.length;n++)t[r[n]]=`resRC.${ma(n)}`;return t.join()}function An(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,a=t,i=o.shape.length,u=new Array(i);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];if(t.shouldExecuteOnCPU([o])){let m=a.tensorMap.get(o.dataId).values,c=mK(m,o.shape,o.dtype,s,u);return t.makeTensorInfo(u,o.dtype,c)}if(o.shape.length===2&&y.arraysEqual(s,[1,0])){let p=new GC(o.shape,s);return a.runWebGPUProgram(p,[o],o.dtype)}let l=new WC(o.shape,s);return a.runWebGPUProgram(l,[o],o.dtype)}var bK={kernelName:_n,backendName:"webgpu",kernelFunc:An};var UC=class{outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];variableNames=["x"];uniforms="reduceSize : i32,";reduceType;inputShape;size=!0;constructor(e,t){this.inputShape=[e.batchSize,e.inSize];let[n]=C.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=n.length===0?[1]:n,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");let n=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workgroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${ce("index")} {
         let outputIndex = index / i32(workgroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workgroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workgroupSizeX)) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workgroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n}
        }
       }
     `}};function oo(r,e,t,n,o){let s=r.shape.length,a=[],i=y.parseAxisParam(e,r.shape),u=i,l=C.getAxesPermutation(u,s),p=r;l!=null&&(p=An({inputs:{x:r},attrs:{perm:l},backend:o}),u=C.getInnerMostAxes(u.length,s),a.push(p)),C.assertAxesAreInnerMostDims(n,u,s);let[m,c]=C.computeOutAndReduceShapes(p.shape,u),d=m;t&&(d=C.expandShapeToKeepDim(m,i));let f;if((n==="max"||n==="prod")&&o.shouldExecuteOnCPU([p])){let h=o.tensorMap.get(p.dataId).values;switch(n){case"max":let g=jU(h,y.sizeFromShape(c),d,r.dtype);f=o.makeTensorInfo(d,r.dtype,g);break;case"prod":let{outVals:b,outShape:T,outDtype:x}=eK(p.shape,p.dtype,h,u);f=o.makeTensorInfo(T,x,b);break;default:throw new Error(`${n} CPU implementation is not yet supported.`)}}else{let h=y.sizeFromShape(c),b=y.sizeFromShape(p.shape)/h,T={windowSize:h,inSize:h,batchSize:b,outSize:1},x=n==="mean"?"float32":iu(r.dtype),I=[{type:"int32",data:[h]}],S=new UC(T,n),w=o.runWebGPUProgram(S,[p],x,I);a.push(w),f=Se({inputs:{x:w},attrs:{shape:d},backend:o})}return a.forEach(h=>o.disposeData(h.dataId)),f}function ide(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:a}=n;return oo(o,a,s,"all",t)}var yK={kernelName:xa,backendName:"webgpu",kernelFunc:ide};function ude(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:a}=n;return oo(o,a,s,"any",t)}var TK={kernelName:Ia,backendName:"webgpu",kernelFunc:ude};var Wf=class{outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];variableNames=["x"];uniforms="infinityValue : f32,";inputShape;reductionFactor;op;size=!0;type;constructor(e,t,n){let o=[t];this.op=n==="min"?"<":">";let[s,a]=C.computeOutAndReduceShapes(e,o);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=ye(this.outputShape),y.sizeFromShape(a)<32||y.sizeFromShape(s)>1e3?(this.type="plain",this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=le(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){let e=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${ma(this.inputShape.length-1)}`,t=()=>{let n="";if(this.outputShape.length===1)this.inputShape.length!==1&&(n+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)n+=`outputCoords.${ma(o)},`;return n};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${this.workgroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workgroupSize[0]}>;
    `}

      ${ce("index")} {
        let outputIndex = index / i32(workgroupSizeX);
        let reduceLength = ${e()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + i32(workgroupSizeX)) {
          let candidate = getX(${t()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), workgroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${ce("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${t()} 0);
          let reduceLength = ${e()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${t()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};function lde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=An({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let p=new Wf(u.shape,a[0],"max"),m=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],c=t.runWebGPUProgram(p,[u],"int32",m);return l.forEach(d=>t.disposeData(d.dataId)),c}var xK={kernelName:fo,backendName:"webgpu",kernelFunc:lde};function pde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,l=[];i!=null&&(u=An({inputs:{x:o},backend:t,attrs:{perm:i}}),l.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let p=new Wf(u.shape,a[0],"min"),m=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],c=t.runWebGPUProgram(p,[u],"int32",m);return l.forEach(d=>t.disposeData(d.dataId)),c}var IK={kernelName:vi,backendName:"webgpu",kernelFunc:pde};var mde=Re({opType:3}),CK={kernelName:Ca,backendName:"webgpu",kernelFunc:mde};var cde=Re({opType:4}),SK={kernelName:Sa,backendName:"webgpu",kernelFunc:cde};var dde=Re({opType:5}),kK={kernelName:ka,backendName:"webgpu",kernelFunc:dde};var fde=ft({opType:1}),vK={kernelName:Aa,backendName:"webgpu",kernelFunc:fde};var hde=Re({opType:6}),AK={kernelName:va,backendName:"webgpu",kernelFunc:hde};var Dg=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,";workgroupSize=[128,1,1];poolType;size=!0;constructor(e,t){this.outputShape=e.outShape,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";this.poolType==="avg"&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return this.poolType==="avg"&&(t="resultValue / count"),`
      ${ce("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutputAtIndex(index, ${t});
        }
      }
    `}};var KC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="stride : vec2<i32>,";workgroupSize=[256,1,1];size=!0;constructor(e){this.outputShape=e.outShape,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}};function _g(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:a}=n;return oo(o,s,a,"max",t)}var wK={kernelName:Eo,backendName:"webgpu",kernelFunc:_g};function a0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:a}=n;return oo(o,a,s,"mean",t)}var NK={kernelName:$o,backendName:"webgpu",kernelFunc:a0};function VC(r,e,t,n){if(e.filterWidth===1&&e.filterHeight===1&&y.arraysEqual(e.inShape,e.outShape))return pr({inputs:{x:r},backend:n});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){let a=r.shape.length,i=Se({inputs:{x:r},backend:n,attrs:{shape:[r.shape[a-3]*r.shape[a-2],r.shape[a-1]]}}),u;t==="avg"?u=a0({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}}):(y.assert(t==="max",()=>`Invalid pool type ${t}`),u=_g({inputs:{x:i},backend:n,attrs:{reductionIndices:0,keepDims:!1}}));let l=Se({inputs:{x:u},backend:n,attrs:{shape:e.outShape}});return n.disposeData(i.dataId),n.disposeData(u.dataId),l}let o,s=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?o=new KC(e):(t==="avg"?o=new Dg(e,"avg"):(y.assert(t==="max",()=>`Invalid pool type ${t}`),o=new Dg(e,"max")),s.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),n.runWebGPUProgram(o,[r],r.dtype,s)}function gde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1,p=C.computePool2DInfo(o.shape,s,a,l,i,u);return VC(o,p,"avg",t)}var DK={kernelName:ho,backendName:"webgpu",kernelFunc:gde};function bde(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;return lm({a:o,b:s,transposeA:a,transposeB:i,backend:t})}var _K={kernelName:go,backendName:"webgpu",kernelFunc:bde};var HC=class{variableNames=["source"];uniforms;outputShape;shaderKey;rank;dispatchLayout;dispatch;workPerThread=1;workgroupSize=[64,1,1];start;size=!0;constructor(e,t){this.outputShape=t,this.rank=t.length,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${lr(e.length)}, `,this.shaderKey="slice"}getUserCode(){let e=lr(this.rank),t=yde(this.rank),n;return this.start.length===1?n=this.outputShape.map((s,a)=>"sourceLoc = uniforms.start + coords;"):n=this.outputShape.map((s,a)=>`sourceLoc.${i0[a]} = uniforms.start.${ma(a)} + coords.${i0[a]};`),`
      ${ce("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${n.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}},i0=["x","y","z","w","u","v"];function yde(r){if(r===1)return"sourceLoc";if(r<=6)return i0.slice(0,r).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}function Ii(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:a}=n,[i,u]=It.parseSliceParams(o,s,a);if(It.assertParamsValid(o,i,u),t.shouldExecuteOnCPU([o])||o.dtype==="string"){let m=t.tensorMap.get(o.dataId),c=sK(m.values,i,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,c)}if(y.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);let l=new HC(i,u),p=[{type:"int32",data:i}];return t.runWebGPUProgram(l,[o],o.dtype,p)}var MK={kernelName:_s,backendName:"webgpu",kernelFunc:Ii};var Tde=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((T,x)=>T*x),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=[],f=Se({inputs:{x:o},backend:t,attrs:{shape:u}}),h=An({inputs:{x:f},backend:t,attrs:{perm:l}}),g=Se({inputs:{x:h},backend:t,attrs:{shape:p}}),b=Ii({inputs:{x:g},backend:t,attrs:{begin:m,size:c}});return d.push(f),d.push(h),d.push(g),d.forEach(T=>t.disposeData(T.dataId)),b},RK={kernelName:Is,backendName:"webgpu",kernelFunc:Tde};var xde=`
  fn bincount_write(index: i32, value: f32) {
    var oldValue = atomicLoad(& (result[index]));
    var exchanged = false;
    for (; !exchanged;) {
      let newValueF32 = bitcast<f32>(oldValue) + value;
      let newValue = bitcast<i32>(newValueF32);
      let res = atomicCompareExchangeWeak(
          &(result[index]), oldValue, newValue);
      oldValue = res.old_value;
      exchanged = res.exchanged;
    }
  }
`,Ide=`
  fn bincount_write(index: i32, value: f32) {
    result[index] = value;
  }
`,Uf=class{outputShape=[];shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="binCountSize : i32,";workgroupSize=[64,1,1];atomic=!0;hasWeights=!0;binaryOutput=!1;rank;constructor(e,t,n=!1){this.outputShape=e,this.rank=e.length,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?Ide:xde}
  ${ce("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"f32(getW(index))":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"f32(getW(coord[0], coord[1]))":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}};function Cde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a}=n,i=y.sizeFromShape(o.shape),l=y.sizeFromShape(s.shape)>0,p=[a],m=s.dtype,c=mn({backend:t,attrs:{shape:p,value:0,dtype:m}}),d=new Uf([i],l),f=[{type:"int32",data:[a]}],h=l?[o,s]:[o];return t.runWebGPUProgram(d,h,m,f,c)}var PK={kernelName:Ou,backendName:"webgpu",kernelFunc:Cde};var u0=ft({opType:16,dtype:"bool",cpuKernelImpl:JU}),EK={kernelName:Ka,backendName:"webgpu",kernelFunc:u0};function Pu(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return pr({inputs:{x:o.complexTensorInfos.real},backend:t})}var FK={kernelName:Zu,backendName:"webgpu",kernelFunc:Pu};function LK(r,e){let t=new ca(r.shape,35),n=e.runWebGPUProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function l0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return pr({inputs:{x:o},backend:t});let a=Ct(o.shape),i=l0({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=ys({inputs:{real:i,imag:a},backend:t});return a.dispose(),t.disposeData(i.dataId),u}if(o.dtype==="complex64"){let a=Pu({inputs:{input:o},backend:t}),i=l0({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeData(a.dataId),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=pr({inputs:{x:o},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(t.shouldExecuteOnCPU([o])){let a=t.tensorMap.get(o.dataId).values,[i,u,l]=EU(a,o.shape,o.dtype,s);return t.makeTensorInfo(i,u,l)}if(s==="int32")return LK(o,t);if(s==="bool"){let a=t.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),u=u0({inputs:{a:o,b:a},backend:t});return t.disposeData(a.dataId),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var $K={kernelName:Un,backendName:"webgpu",kernelFunc:l0};var Sde=Re({opType:7,cpuKernelImpl:FU}),BK={kernelName:bo,backendName:"webgpu",kernelFunc:Sde};var qC=class{outputShape;shaderKey;variableNames=["A"];uniforms="minVal : f32, maxVal : f32,";dispatchLayout;dispatch;workPerThread=4;workgroupSize=[64,1,1];isVec4=!0;size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${ce("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isnan(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputAtIndex(index, clampedValue);
        }
      }
    `}};var jC=class{outputShape;shaderKey;variableNames=["A"];uniforms="minVal : f32, maxVal : f32,";dispatchLayout;dispatch;workgroupSize=[64,1,1];minVal;maxVal;size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${ce("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function kde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i,u=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return y.sizeFromShape(o.shape)%4===0?i=new qC(o.shape):i=new jC(o.shape),t.runWebGPUProgram(i,[o],o.dtype,u)}var OK={kernelName:Kn,backendName:"webgpu",kernelFunc:kde};var XC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames;uniforms="";workPerThread=1;workgroupSize=[64,1,1];size=!0;offsetLength;constructor(e){this.outputShape=C.computeOutShape(e,1),this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){let e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)e.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);let n=this.offsetLength,o=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${o})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${ce("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};function mm(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return pr({inputs:{x:o.complexTensorInfos.imag},backend:t})}var zK={kernelName:ju,backendName:"webgpu",kernelFunc:mm};function Kf(r,e,t){let n=r[0].dtype;if(n==="complex64"){let f=r.map(x=>Pu({inputs:{input:x},backend:t})),h=r.map(x=>mm({inputs:{input:x},backend:t})),g=Kf(f,e,t),b=Kf(h,e,t),T=ys({inputs:{real:g,imag:b},backend:t});return f.forEach(x=>t.disposeData(x.dataId)),h.forEach(x=>t.disposeData(x.dataId)),t.disposeData(g.dataId),t.disposeData(b.dataId),T}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let f=r.map(S=>{let _=[-1,y.sizeFromShape(S.shape.slice(e))];return Se({inputs:{x:S},backend:t,attrs:{shape:_}})}),h=f.map(S=>({vals:t.readSync(S.dataId),shape:S.shape})),g=C.computeOutShape(f.map(S=>S.shape),1),b=f[0].shape[0]===1,T=LU(h,g,n,b),x=C.computeOutShape(r.map(S=>S.shape),e),I=t.makeTensorInfo(x,n,T);return f.forEach(S=>t.disposeData(S.dataId)),I}let s=t.device.limits.maxStorageBuffersPerShaderStage-1;if(r.length>s){let f=[];for(let g=0;g<r.length;g+=s){let b=r.slice(g,g+s);f.push(Kf(b,e,t))}let h=Kf(f,e,t);for(let g of f)t.disposeData(g.dataId);return h}let{tensors2D:a,outShape:i}=vde(r,e,t),u=a.map(f=>f.shape),l=new XC(u),p=[],m=new Array(u.length-1);if(m.length>0){m[0]=u[0][1],p.push({type:"int32",data:[m[0]]});for(let f=1;f<m.length;f++)m[f]=m[f-1]+u[f][1],p.push({type:"int32",data:[m[f]]})}let c=t.runWebGPUProgram(l,a,a[0].dtype,p);a.forEach(f=>t.disposeData(f.dataId));let d=Se({inputs:{x:c},backend:t,attrs:{shape:i}});return t.disposeData(c.dataId),d}function vde(r,e,t){let n=C.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>Se({inputs:{x:s},backend:t,attrs:{shape:[y.sizeFromShape(s.shape.slice(0,e)),y.sizeFromShape(s.shape.slice(e))]}})),outShape:n}}function p0(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,e[0].shape)[0],a=e.map(l=>l.shape);C.assertParamsConsistent(a,s);let i=C.computeOutShape(e.map(l=>l.shape),s);if(y.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let u=e.filter(l=>y.sizeFromShape(l.shape)>0);return u.length===1?pr({inputs:{x:u[0]},backend:t}):Kf(u,s,t)}var GK={kernelName:Cs,backendName:"webgpu",kernelFunc:p0};function Ade(r,e,t,n,o=!1,s=null,a=!1,i=4,u=4,l=4){let p=R=>{switch(R){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},m=R=>{switch(R){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${R} is not supported.`)}},c=r?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,d=r?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,f=r?"uniforms.xShape[1]":"uniforms.xShape[2]",h=r?"uniforms.xShape[2]":"uniforms.xShape[3]",g=r?"row":"col",b=r?"col":"row",T=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${b} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${b} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
      let xCh = ${b} % inChannels;
      var resData = ${tr(i)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {
        ${c}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${p(i)}
      }
      return resData;`,x=r?e&&n?`
      let col = colIn * ${i};
      ${T}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${T}
      }
      return ${tr(i)}(0.0);`:n&&t?`
      let col = colIn * ${i};
      ${T}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${T}
      }
      return ${tr(i)}(0.0);`,I=`${m(u)}`,S=tr(l),w=r?tr(i):tr(u),_=r?tr(u):tr(i);return`
      ${en(s,a,l===4,4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${w} {
        ${r?x:I}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${_} {
        ${r?I:x}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${S}) {
        let col = colIn * ${l};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${d}
        ${no(o,s)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}var YC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];variableTypes;uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize;elementsPerThread;addBias;activation;hasPreluActivationWeights;isChannelsLast;fitAOuter;fitBOuter;fitInner;tileAOuter;tileBOuter;tileInner;innerElementSize;isVec4;sequentialAccessByThreads;constructor(e,t,n,o,s=!1,a=null,i=!1,u=!1){this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=kg(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=vg(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),s&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),i&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=s,this.activation=a,this.hasPreluActivationWeights=i,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=n%this.tileBOuter===0,this.fitInner=o%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){let e=this.isVec4?im(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):um(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${Ade(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}};var ZC=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,";workgroupSize=[4,4,8];addBias;activation;hasPreluActivationWeights;isChannelsLast;constructor(e,t=!1,n=null,o=!1){this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${en(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${no(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${ce("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}};var QC=class{variableNames=["x"];uniforms=`pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`;outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];isChannelsLast;size=!0;constructor(e,t){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",o=this.isChannelsLast?"coords[2]":"coords[1]",s=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${ce("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${n};
        let col = ${o};
        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];
        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -
              uniforms.pad[1];
          let xCol = offsetX + uniforms.dilation[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${s};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}};function JC(r,e){let t=r.length;return t>=3?e?[...r.slice(0,-3),r[t-3]*r[t-2],r[t-1]]:[...r.slice(0,-3),r[t-3],r[t-2]*r[t-1]]:!e&&t===1&&r[0]>1?[r[0],1]:null}function wde({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=t.dataFormat==="channelsLast",l=!u,p=!1,m=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",c=[],d,f;if(m){let b=t.inHeight*t.inWidth*t.inChannels;d=Se({inputs:{x:r},backend:n,attrs:{shape:[1,t.batchSize,b]}}),f=Se({inputs:{x:e},backend:n,attrs:{shape:[1,b,t.outChannels]}})}else d=Se({inputs:{x:r},backend:n,attrs:{shape:u?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),f=Se({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(c.push(d),c.push(f),s!=null){let b=JC(s.shape,u);b!=null&&(s=Se({inputs:{x:s},backend:n,attrs:{shape:b}}),c.push(s))}if(o!=null){let b=JC(o.shape,u);b!=null&&(o=Se({inputs:{x:o},backend:n,attrs:{shape:b}}),c.push(o))}let h=lm({a:u?d:f,b:u?f:d,transposeA:l,transposeB:p,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),g=Se({inputs:{x:h},backend:n,attrs:{shape:t.outShape}});c.push(h);for(let b of c)n.disposeData(b.dataId);return g}function Nde({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:u,filterHeight:l,inChannels:p,strideWidth:m,strideHeight:c,padInfo:d,outWidth:f,outHeight:h,dilationWidth:g,dilationHeight:b,dataFormat:T}=t,x=T==="channelsLast",I=u*l*p,S=h*f,w=x?[t.batchSize,S,I]:[t.batchSize,I,S],_=new QC(w,x),M=[{type:"int32",data:[d.top,d.left]},{type:"int32",data:[c,m]},{type:"int32",data:[b,g]},{type:"int32",data:[f]},{type:"int32",data:[p*u]},{type:"int32",data:[p]}],R=n.runWebGPUProgram(_,[r],r.dtype,M),E=[];E.push(R);let O=Se({inputs:{x:e},backend:n,attrs:{shape:[1,I,-1]}});if(E.push(O),s!=null){let V=JC(s.shape,x);V!=null&&(s=Se({inputs:{x:s},backend:n,attrs:{shape:V}}),E.push(s))}if(o!=null){let V=JC(o.shape,x);V!=null&&(o=Se({inputs:{x:o},backend:n,attrs:{shape:V}}),E.push(o))}let H=lm({a:x?R:O,b:x?O:R,transposeA:!x,transposeB:!1,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),U=Se({inputs:{x:H},backend:n,attrs:{shape:t.outShape}});E.push(H);for(let V of E)n.disposeData(V.dataId);return U}function eS({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=o!=null,l=s!=null,p=t.dataFormat==="channelsLast",m=p&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",c=$().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!c&&(m||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return wde({x:r,filter:e,convInfo:t,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});let d=$().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),f=d>0?d:n.thresholdToIncreaseWorkgroups,h=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if($().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||h<=f)return Nde({x:r,filter:e,convInfo:t,backend:n,bias:o,preluActivationWeights:s,leakyreluAlpha:a,activation:i});let g,b=[t.padInfo.top,t.padInfo.left],T=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...b]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(c)g=new ZC(t,u,i,l);else{let w=p?t.outHeight*t.outWidth:t.outChannels,_=p?t.outChannels:t.outHeight*t.outWidth,M=t.filterHeight*t.filterWidth*t.inChannels;T.push({type:"int32",data:[w]},{type:"int32",data:[_]},{type:"int32",data:[M]});let R=n.adapterInfo.isIntel();g=new YC(t,w,_,M,u,i,l,R)}let x=[],I=[r,e];u&&(!p&&o.shape.length===1&&(o=Se({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}}),x.push(o)),I.push(o)),l&&(!p&&s.shape.length===1&&(s=Se({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}}),x.push(s)),I.push(s)),i==="leakyrelu"&&(T.push({type:"float32",data:[a]}),g.uniforms+=" alpha : f32,");let S=n.runWebGPUProgram(g,I,r.dtype,T);for(let w of x)n.disposeData(w.dataId);return S}function Dde(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=t,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!1,m);return eS({x:o,filter:s,convInfo:c,backend:n})}var WK={kernelName:yo,backendName:"webgpu",kernelFunc:Dde};function _de(r=4){let e=s=>{switch(s){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${s} is not supported.`)}},n=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${tr(r)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${tr(r)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r}];`}
      }
      return ${tr(r)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${tr(r)} {
    let col = colIn * ${r};
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${tr(r)} {
    let col = colIn * ${r};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(r)}
    }
    return ${tr(r)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${tr(r)}) {
    let col = colIn * ${r};
    if (row < uniforms.dimAOuter && (col + ${r-1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r}] = value;
    }
  }`}var tS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];variableTypes;uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,";workgroupSize;elementsPerThread;isVec4;constructor(e){this.outputShape=e.inShape,y.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=kg(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=vg(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){let e=this.isVec4?im(this.elementsPerThread,this.workgroupSize):um(this.elementsPerThread,this.workgroupSize);return`
    ${_de(this.isVec4?4:1)}
    ${e}
    `}};var rS=class{variableNames=["dy","W"];uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,";outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];isChannelsLast;size=!0;constructor(e){this.outputShape=e.inShape,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`
    ${ce("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};function Mde(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:a,strides:i,pad:u,dataFormat:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(l),c=C.computeConv2DInfo(a,s.shape,i,1,u,p,!1,m),d=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize,c.outHeight,c.outWidth,c.outChannels]}],f;if($().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||c.filterHeight<=2&&c.filterWidth<=2&&c.outChannels<=16&&c.inChannels===1)f=new rS(c);else{f=new tS(c);let h=c.inHeight*c.inWidth,g=c.inChannels,b=c.filterHeight*c.filterWidth*c.outChannels;d.push({type:"uint32",data:[h]},{type:"uint32",data:[g]},{type:"uint32",data:[b]})}return t.runWebGPUProgram(f,[o,s],"float32",d)}var UK={kernelName:To,backendName:"webgpu",kernelFunc:Mde};var Rde=Re({opType:8}),KK={kernelName:xo,backendName:"webgpu",kernelFunc:Rde};var Pde=Re({opType:9}),VK={kernelName:Io,backendName:"webgpu",kernelFunc:Pde};var nS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["Image","Boxes","BoxInd"];uniforms="extrapolationValue : f32,";workgroupSize=[64,1,1];methodId;cropHeightBiggerThan1;cropWidthBiggerThan1;size=!0;constructor(e,t,n,o){let[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=o==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,o,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[a,i,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${ce("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${o};
        let width_scale = ${i};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};var Ede=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:a}=e,{cropSize:i,method:u,extrapolationValue:l}=n,p=new nS(o.shape[3],s.shape,i,u),m=[{type:"float32",data:[l]}];return t.runWebGPUProgram(p,[o,s,a],"float32",m)},HK={kernelName:Na,backendName:"webgpu",kernelFunc:Ede};var Mg=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];workgroupSize;uniforms="index : f32,";size=!0;exclusive;reverse;op;constructor(e,t,n,o){this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=o,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){let e=this.outputShape.length,t=this.op==="*"?"1.0":"0.0",n=this.exclusive?t:`getX(${qK(e,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],s="",a="";return this.exclusive?(s=this.reverse?`end != ${o-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${o}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${ce("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${jK(e,"coords",this.op)};
         var val = ${n};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${a};
           ${jK(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${qK(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function qK(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function jK(r,e,t){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${r} is not yet supported`)}function oS(r,e,t,n,o,s){let a=e.shape.length,i=C.getAxesPermutation([n],a),u=e;i!=null&&(u=An({inputs:{x:e},backend:t,attrs:{perm:i}}));let l=C.getInnerMostAxes(1,a)[0];if(l!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${n}`);let p=u.shape[l],m=pr({inputs:{x:u},backend:t});for(let c=0;c<=Math.ceil(Math.log2(p))-1;c++){let d=new Mg(r,u.shape,!1,s),f=m,h=[{type:"float32",data:[c]}];m=t.runWebGPUProgram(d,[m],m.dtype,h),t.disposeData(f.dataId)}if(o){let c=new Mg(r,u.shape,o,s),d=m,f=[{type:"float32",data:[0]}];m=t.runWebGPUProgram(c,[m],m.dtype,f),t.disposeData(d.dataId)}if(i!=null){let c=C.getUndoAxesPermutation(i),d=An({inputs:{x:m},backend:t,attrs:{perm:c}});return t.disposeData(m.dataId),t.disposeData(u.dataId),d}return m}function Lde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return oS("*",o,t,s,a,i)}var XK={kernelName:wa,backendName:"webgpu",kernelFunc:Lde};function $de(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n;return oS("+",o,t,s,a,i)}var YK={kernelName:Co,backendName:"webgpu",kernelFunc:$de};function Bde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:a,binaryOutput:i}=n,u=o.shape.length===1,p=y.sizeFromShape(s.shape)>0,m=s.dtype,c=u?[o.shape[0]]:[o.shape[0],o.shape[1]],d=u?[a]:[o.shape[0],a],f=mn({backend:t,attrs:{shape:d,value:0,dtype:m}}),h=new Uf(c,p,i),g=[{type:"int32",data:[a]}],b=p?[o,s]:[o];return t.runWebGPUProgram(h,b,m,g,f)}var ZK={kernelName:Uu,backendName:"webgpu",kernelFunc:Bde};var sS=class{variableNames=["x"];outputShape;dataFormat;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];size=!0;uniforms="blockSize : i32,";constructor(e,t){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Ode(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=l*s,d=p/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=[{type:"int32",data:[s]}],g=new sS(f,a);return t.runWebGPUProgram(g,[o],o.dtype,h)}var QK={kernelName:Da,backendName:"webgpu",kernelFunc:Ode};var aS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms="pad : vec2<i32>, inDims : vec2<i32>,";workgroupSize=[16,16,1];addBias;activation;hasPreluActivation;filterHeight;filterWidth;constructor(e,t,n,o=!1,s=null,a=!1){this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=o,this.activation=s,this.hasPreluActivation=a,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){let e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,o=this.workgroupSize[0]+this.filterWidth-1;return`
      ${en(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${o}>, ${n}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${ce()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${o}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${no(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};var Vf=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms="pad : vec2<i32>, inDims : vec2<i32>,";workgroupSize=[4,4,4];workPerThread=4;convInfo;addBias;activation;hasPreluActivation;isVec4=!0;constructor(e,t=!1,n=null,o=!1){this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),y.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){let e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth;return`
      ${en(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      const strideHeight = ${this.convInfo.strideHeight};
      const strideWidth = ${this.convInfo.strideWidth};
      ${ce()} {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * ${this.workPerThread};
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(strideHeight, strideWidth) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * strideWidth + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${no(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}};var Hf=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","W"];uniforms=`pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,`;workgroupSize=[256,1,1];convInfo;addBias;activation;hasPreluActivation;isChannelsLast;size=!0;constructor(e,t=!1,n=null,o=!1){this.outputShape=e.outShape,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${en(this.activation,this.hasPreluActivation,!1,4)}

      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilation[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilation[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilation[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilation[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilation[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilation[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${no(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};function zde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dilations:l,dimRoundingMode:p}=n,m=C.convertConv2DDataFormat(u),c=l;c==null&&(c=[1,1]);let d=C.computeConv2DInfo(o.shape,s.shape,a,c,i,p,!0,m),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],h=d.dataFormat==="channelsLast",g;return!h&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?g=new aS(d.outShape,d.filterHeight,d.filterWidth):h&&d.outHeight>4&&d.outWidth>4&&d.strideWidth<=2&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4===0?g=new Vf(d):(g=new Hf(d),f.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),t.runWebGPUProgram(g,[o,s],o.dtype,f)}var JK={kernelName:So,backendName:"webgpu",kernelFunc:zde};var m0=ft({opType:15,cpuKernelImpl:ZU,supportsComplex:!0}),eV={kernelName:Go,backendName:"webgpu",kernelFunc:m0};function Rg(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return oo(o,s,a,"sum",t)}var tV={kernelName:ns,backendName:"webgpu",kernelFunc:Rg};function Gde(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:l,steps:p}=C.getEinsumComputePath(i,u),m=p.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of p[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=An({inputs:{x:s[g]},backend:t,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let S=0;S<T.length;++S)I.splice(T[S],0,1);y.arraysEqual(x.shape,I)||(x=Se({inputs:{x},backend:t,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=m0({inputs:{a:x,b:c},backend:t}),f.push(c))}h<m-1&&(l[h]>=0&&(c=Rg({inputs:{x:c},backend:t,attrs:{axis:l[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&t.disposeData(h.dataId);return c}var rV={kernelName:Vu,backendName:"webgpu",kernelFunc:Gde};var Wde=Re({opType:10}),nV={kernelName:vo,backendName:"webgpu",kernelFunc:Wde};var Ude=ft({opType:5,dtype:"bool",cpuKernelImpl:$U}),oV={kernelName:Ma,backendName:"webgpu",kernelFunc:Ude};var Kde=Re({opType:11}),sV={kernelName:_a,backendName:"webgpu",kernelFunc:Kde};var c0=Re({opType:12,cpuKernelImpl:BU,dtype:"float32"}),aV={kernelName:Ao,backendName:"webgpu",kernelFunc:c0};function iS(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(y.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),Se({inputs:{x:s},backend:n,attrs:{shape:i}})}var iV={kernelName:Ss,backendName:"webgpu",kernelFunc:iS};var Vde=Re({opType:13,cpuKernelImpl:OU}),uV={kernelName:Ra,backendName:"webgpu",kernelFunc:Vde};var Pg=class{variableNames=["real","imag"];outputShape=[];shaderKey;dispatchLayout;dispatch;uniforms="exponentMultiplier : f32, denominator: f32,";workgroupSize=[64,1,1];size=!0;component;constructor(e,t){this.outputShape=t,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${ce("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}};function uS(r,e,t){let n=t.tensorMap.get(r.dataId),o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=o/s,i=[],u=Se({inputs:{x:r},backend:t,attrs:{shape:[a,s]}});i.push(u);let l=u.shape,p=new Pg("real",l),m=new Pg("imag",l),c=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:l},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:l}],d=e?2*Math.PI:-2*Math.PI,f=e?l[1]:1,h=[{type:"float32",data:[d]},{type:"float32",data:[f]}],g=t.runWebGPUProgram(p,c,"float32",h);i.push(g);let b=t.runWebGPUProgram(m,c,"float32",h);i.push(b);let T=ys({inputs:{real:g,imag:b},backend:t});i.push(T);let x=Se({inputs:{x:T},backend:t,attrs:{shape:r.shape}});return i.forEach(I=>t.disposeData(I.dataId)),x}function Hde(r){let{inputs:e,backend:t}=r,{input:n}=e;return uS(n,!1,t)}var lV={kernelName:Hu,backendName:"webgpu",kernelFunc:Hde};var lS=class{outputShape=[];shaderKey;dispatchLayout;dispatch;variableNames=["x"];workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};var pV={kernelName:Pa,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new lS(t.shape);return n.runWebGPUProgram(o,[t],t.dtype)}};var qde=Re({opType:14,cpuKernelImpl:zU}),mV={kernelName:wo,backendName:"webgpu",kernelFunc:qde};var jde=ft({opType:8,dtype:"int32"}),cV={kernelName:No,backendName:"webgpu",kernelFunc:jde};var pS=class{dispatch;dispatchLayout;isFromPixels=!0;outputShape=[0];shaderKey;importVideo;variableNames=[];workgroupSize=[256,1,1];constructor(e,t,n=!1){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){let e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${ce("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};var dV={kernelName:jl,backendName:"webgpu",kernelFunc:Xde},qf,d0=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),mS=new Map;function Xde(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n;if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&o instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,[p,m]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[m,p,s],d=!1,f=a||i;if(l||u||f){let T;if(d){let E=o;if(!mS.has(E)||mS.get(E).expired){let O={source:E};mS.set(E,t.device.importExternalTexture(O))}T={width:p,height:m,format:null,usage:null,texture:mS.get(E)}}else{if(f){let W=$().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(qf==null||W!==d0)&&(d0=W,qf=document.createElement("canvas").getContext("2d",{willReadFrequently:d0})),qf.canvas.width=p,qf.canvas.height=m,qf.drawImage(o,0,0,p,m),o=qf.canvas}let E=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,O="rgba8unorm",G=t.textureManager.acquireTexture(c[1],c[0],O,E);t.queue.copyExternalImageToTexture({source:o},{texture:G},[c[1],c[0]]),T={width:p,height:m,format:O,usage:E,texture:G}}let x=y.sizeFromShape(c),I=y.computeStrides(c),S=new pS(c,s,d),w=[{type:"uint32",data:[x]},{type:"uint32",data:[s]},{type:"uint32",data:[...I]}],_=t.makeTensorInfo([m,p],"int32"),M=t.tensorMap.get(_.dataId);M.resourceInfo=T;let R=t.runWebGPUProgram(S,[_],"int32",w);return t.disposeData(_.dataId),R}let h=o.data,g=h;if(s!=null&&s!==4){g=new Uint8Array(o.width*o.height*s);let T=h.length,x=0;for(let I=0;I<T;I++)I%4<s&&(g[x++]=h[I])}let b=t.makeTensorInfo(c,"int32",new Int32Array(g));return t.uploadToGPU(b.dataId),b}var cS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames;uniforms="varianceEpsilon : f32,";workgroupSize=[128,1,1];offsetShape;scaleShape;varianceEpsilon;size=!0;constructor(e,t,n,o,s){this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(e,t),C.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),o!=null&&(C.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset")),s!=null&&(C.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale")),this.offsetShape=o,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${ce("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};var fV={kernelName:Do,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n,scale:o,offset:s,mean:a,variance:i}=r,{varianceEpsilon:u}=e,l=t,p=[n,a,i],m=null;s!=null&&(m=s.shape,p.push(s));let c=null;o!=null&&(c=o.shape,p.push(o));let d=new cS(n.shape,a.shape,i.shape,m,c),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(d,p,n.dtype,f)}};function Yde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dataFormat:p,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=C.convertConv2DDataFormat(p),g=C.computeConv2DInfo(o.shape,s.shape,u,m,l,c,!1,h);return eS({x:o,filter:s,convInfo:g,backend:t,bias:a,preluActivationWeights:i,leakyreluAlpha:f,activation:d})}var hV={kernelName:$s,backendName:"webgpu",kernelFunc:Yde};function Zde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:m,activation:c,leakyreluAlpha:d}=n,f=p;f==null&&(f=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(u,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`);let h=C.computeConv2DInfo(o.shape,s.shape,u,f,l,m,!0),g=[o,s],b=a!=null,T=i!=null;b&&g.push(a),T&&g.push(i);let x=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inHeight,h.inWidth]}],I;return h.outHeight>4&&h.outWidth>4&&h.strideWidth<=2&&h.inChannels===h.outChannels&&h.dilationHeight===1&&h.dilationWidth===1&&h.inChannels%4===0?I=new Vf(h,b,c,T):(I=new Hf(h,b,c,T),x.push({type:"int32",data:[h.filterHeight]},{type:"int32",data:[h.filterWidth]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]})),c==="leakyrelu"&&(x.push({type:"float32",data:[d]}),I.uniforms+=" alpha : f32,"),t.runWebGPUProgram(I,g,"float32",x)}var gV={kernelName:Bs,backendName:"webgpu",kernelFunc:Zde};var dS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","indices"];uniforms;workgroupSize=[64,1,1];size=!0;sliceDim;constructor(e,t){this.outputShape=t,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${lr(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};function Qde(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,a=s[s.length-1],i=y.sizeFromShape(n.shape),[u,l,p,m]=C.prepareAndValidate(n,o),c=Se({inputs:{x:o},backend:t,attrs:{shape:[l,a]}}),d=Se({inputs:{x:n},backend:t,attrs:{shape:[y.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let T=t.readSync(o.dataId),x=t.bufferSync(n),I=GU(T,x,n.dtype,l,a,p,m,n.shape,i);return t.makeTensorInfo(u,n.dtype,I.values)}let f=new dS(a,[l,p]),h=[{type:"int32",data:[a]},{type:"int32",data:m}],g=t.runWebGPUProgram(f,[d,c],d.dtype,h),b=Se({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeData(c.dataId),t.disposeData(d.dataId),t.disposeData(g.dataId),b}var bV={kernelName:Ea,backendName:"webgpu",kernelFunc:Qde};var fS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["A","indices"];workgroupSize=[64,1,1];aShape;size=!0;constructor(e,t){this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){let e=Jde(this.aShape);return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}};function Jde(r){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let n=0;n<r.length;n++)n===2?t.push("indexZ"):t.push(`${e[n]}`);return t.join()}function f0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0],l=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),p=y.sizeFromShape(s.shape),m=[],c=Se({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=Se({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,p/l.batchSize]}});m.push(c),m.push(d);let f=[l.batchSize,l.outerSize,p/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])){let x=t.tensorMap.get(d.dataId).values,I=Ie(d.shape,d.dtype,x),w=t.tensorMap.get(c.dataId).values,_=Ie(c.shape,c.dtype,w),M=WU(_,I,f);return m.forEach(R=>t.disposeData(R.dataId)),t.makeTensorInfo(l.outputShape,M.dtype,M.values)}let h=new fS(c.shape,f),g=t.runWebGPUProgram(h,[c,d],c.dtype);m.push(g);let b=Se({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return m.forEach(T=>t.disposeData(T.dataId)),b}var yV={kernelName:ks,backendName:"webgpu",kernelFunc:f0};var efe=ft({opType:6,cpuKernelImpl:KU,dtype:"bool"}),TV={kernelName:Fa,backendName:"webgpu",kernelFunc:efe};var tfe=ft({opType:7,dtype:"bool",cpuKernelImpl:UU}),xV={kernelName:_o,backendName:"webgpu",kernelFunc:tfe};function rfe(r){let{inputs:e,backend:t}=r,{input:n}=e;return uS(n,!0,t)}var IV={kernelName:qu,backendName:"webgpu",kernelFunc:rfe};var nfe=Re({opType:15,dtype:"bool"}),CV={kernelName:La,backendName:"webgpu",kernelFunc:nfe};var ofe=Re({opType:16,dtype:"bool"}),SV={kernelName:$a,backendName:"webgpu",kernelFunc:ofe};var sfe=Re({opType:17,dtype:"bool"}),kV={kernelName:Mo,backendName:"webgpu",kernelFunc:sfe};function afe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,a=[{type:"float32",data:[s]}],i=new ca(o.shape,25);return i.uniforms="alpha : f32,",t.runWebGPUProgram(i,[o],"float32",a)}var vV={kernelName:Ro,backendName:"webgpu",kernelFunc:afe};var ife=ft({opType:9,dtype:"bool",cpuKernelImpl:HU}),AV={kernelName:Ba,backendName:"webgpu",kernelFunc:ife};var ufe=ft({opType:10,dtype:"bool",cpuKernelImpl:VU}),wV={kernelName:Oa,backendName:"webgpu",kernelFunc:ufe};var lfe=Re({opType:19,cpuKernelImpl:qU}),NV={kernelName:Po,backendName:"webgpu",kernelFunc:lfe};var pfe=Re({opType:20}),DV={kernelName:za,backendName:"webgpu",kernelFunc:pfe};var mfe=ft({opType:11,dtype:"bool"}),_V={kernelName:Ga,backendName:"webgpu",kernelFunc:mfe};var cfe=Re({opType:21}),MV={kernelName:Wa,backendName:"webgpu",kernelFunc:cfe};var dfe=ft({opType:12,cpuKernelImpl:XU}),RV={kernelName:Fo,backendName:"webgpu",kernelFunc:dfe};function ffe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,l=1,p=C.computePool2DInfo(o.shape,s,a,l,i,u);return VC(o,p,"max",t)}var PV={kernelName:Lo,backendName:"webgpu",kernelFunc:ffe};function hfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return oo(o,s,a,"min",t)}var EV={kernelName:Bo,backendName:"webgpu",kernelFunc:hfe};var gfe=ft({opType:13,cpuKernelImpl:YU}),FV={kernelName:Oo,backendName:"webgpu",kernelFunc:gfe};var hS=class{outputShape;shaderKey;uniforms="";dispatchLayout;dispatch;variableNames=["x"];workgroupSize=[64,1,1];xShape;offset;size=!0;constructor(e,t,n){this.outputShape=t.map((o,s)=>o[0]+e[s]+o[1]),this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((o,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.offset=n==="reflect"?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){let e=this.xShape.length,t=this.xShape.map((l,p)=>`uniforms.pad${p}[0]`).join(","),n=this.xShape.map((l,p)=>`uniforms.pad${p}[0] + uniforms.xShape${e>1?`[${p}]`:""}`).join(","),o=e===1?"start":"start[i]",s=e===1?"end":"end[i]",a=e===1?"outC":"outC[i]",i=lr(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let start = ${i}(${t});
          let end = ${i}(${n});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${a} < ${o}) {
              ${a} = ${o} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${s}) {
              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}};var LV={kernelName:zo,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{paddings:o,mode:s}=e,a=t,i=o.map(p=>({type:"int32",data:[p[0],p[1]]})),u=new hS(n.shape,o,s);return a.runWebGPUProgram(u,[n],n.dtype,i)}};var bfe=ft({opType:14}),$V={kernelName:Ua,backendName:"webgpu",kernelFunc:bfe};function yfe(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.tensorMap.get(n.dataId),[a,i]=QU(s.values,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,a)}let o=new ca(n.shape,22);return t.runWebGPUProgram(o,[n],n.dtype)}var BV={kernelName:vs,backendName:"webgpu",kernelFunc:yfe};function Tfe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:m}=xr.nonMaxSuppressionV3Impl(l,p,a,i,u);return t.makeTensorInfo([m.length],"int32",new Int32Array(m))}var OV={kernelName:Va,backendName:"webgpu",kernelFunc:Tfe};function xfe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),m=t.readSync(s.dataId),c=a,d=i,f=u,h=l,{selectedIndices:g,selectedScores:b}=xr.nonMaxSuppressionV5Impl(p,m,c,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var zV={kernelName:Ha,backendName:"webgpu",kernelFunc:xfe};var gS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="onValue : f32, offValue : f32,";workgroupSize=[64,1,1];size=!0;constructor(e,t){this.outputShape=[e,t],this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${ce("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}};function Ife(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n,l=y.sizeFromShape(o.shape),p=new gS(l,a),m=Se({inputs:{x:o},backend:t,attrs:{shape:[l]}}),c=[{type:"float32",data:[i]},{type:"float32",data:[u]}],d=t.runWebGPUProgram(p,[m],s,c);t.disposeData(m.dataId);let f=[...o.shape,a],h=Se({inputs:{x:d},backend:t,attrs:{shape:f}});return t.disposeData(d.dataId),h}var GV={kernelName:Wo,backendName:"webgpu",kernelFunc:Ife};function Eg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=Pu({inputs:{input:n},backend:t}),s=Eg({inputs:{x:o},backend:t}),a=mm({inputs:{input:n},backend:t}),i=Eg({inputs:{x:a},backend:t}),u=ys({inputs:{real:s,imag:i},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),u}else return mn({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var WV={kernelName:Es,backendName:"webgpu",kernelFunc:Eg};function UV(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Pu({inputs:{input:n},backend:t}),s=UV({inputs:{x:o},backend:t}),a=mm({inputs:{input:n},backend:t}),i=Eg({inputs:{x:a},backend:t}),u=ys({inputs:{real:s,imag:i},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(a.dataId),t.disposeData(i.dataId),u}else return mn({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var KV={kernelName:As,backendName:"webgpu",kernelFunc:UV};function Cfe(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return iS({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=iS({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=p0({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeData(p.dataId)),l}var VV={kernelName:ws,backendName:"webgpu",kernelFunc:Cfe};var bS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="constantValue : f32,";workgroupSize=[64,1,1];xShape;size=!0;constructor(e,t){this.outputShape=t.map((n,o)=>n[0]+e[o]+n[1]),this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((n,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){let e=this.xShape.length,t=lr(e),n=this.xShape.map((m,c)=>`uniforms.pad${c}[0]`).join(","),o=this.xShape.map((m,c)=>`uniforms.pad${c}[0] + uniforms.xShape${e>1?`[${c}]`:""}`).join(","),s=e>1?`${t}(${n})`:`${n}`,a=e>1?`${t}(${o})`:`${o}`,i=e>1?"any(outC < start)":"outC < start",u=e>1?"any(outC >= end)":"outC >= end",l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let start = ${s};
          let end = ${a};
          let outC = getCoordsFromIndex(index);

          if (${i} || ${u}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${l}));
          }
        }
      }
    `}};var h0=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:a}=n;if(s.every(l=>y.arraysEqual(l,[0,0])))return pr({inputs:{x:o},backend:t});if(y.sizeFromShape(o.shape)===0){let l=s.map((p,m)=>p[0]+o.shape[m]+p[1]);return mn({backend:t,attrs:{shape:l,value:a,dtype:o.dtype}})}let i=[{type:"float32",data:[a]}];s.map(l=>i.push({type:"int32",data:[l[0],l[1]]}));let u=new bS(o.shape,s);return t.runWebGPUProgram(u,[o],o.dtype,i)},HV={kernelName:Uo,backendName:"webgpu",kernelFunc:h0};var Sfe=ft({opType:17}),qV={kernelName:Ko,backendName:"webgpu",kernelFunc:Sfe};function kfe(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=new pm(18,n.shape,o.shape);return t.runWebGPUProgram(s,[n,o],"float32")}var jV={kernelName:Vo,backendName:"webgpu",kernelFunc:kfe};function vfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:a}=n;return oo(o,s,a,"prod",t)}var XV={kernelName:Ho,backendName:"webgpu",kernelFunc:vfe};var Afe=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=tK(n,o,s,a);return e.makeTensorInfo([i.length],a,i)},YV={kernelName:wi,backendName:"webgpu",kernelFunc:Afe};var g0=ft({opType:4}),ZV={kernelName:ko,backendName:"webgpu",kernelFunc:g0};var wfe=Re({opType:26}),QV={kernelName:qo,backendName:"webgpu",kernelFunc:wfe};var Nfe=Re({opType:23}),JV={kernelName:jo,backendName:"webgpu",kernelFunc:Nfe};var Dfe=Re({opType:24}),e4={kernelName:Zo,backendName:"webgpu",kernelFunc:Dfe};var yS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,";workgroupSize=[64,1,1];size=!0;constructor(e,t,n){this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${ce("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function _fe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,size:a,halfPixelCenters:i}=n,[u,l]=a,p=s&&u>1?1:0,m=s&&l>1?1:0,d=[{type:"float32",data:[p,m]},{type:"float32",data:[i?.5:0]}],f=new yS(o.shape,u,l);return t.runWebGPUProgram(f,[o],"float32",d)}var t4={kernelName:Yo,backendName:"webgpu",kernelFunc:_fe};var TS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,";workgroupSize=[64,1,1];halfPixelCenters;size=!0;constructor(e,t,n,o){this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=o,this.shaderKey=`resizeNearest_${o}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function Mfe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,p=s&&u>1?1:0,m=s&&l>1?1:0,d=[{type:"float32",data:[p,m]},{type:"float32",data:[s?.5:0]}],f=new TS(o.shape,u,l,a);return t.runWebGPUProgram(f,[o],o.dtype,d)}var r4={kernelName:Xo,backendName:"webgpu",kernelFunc:Mfe};var xS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}};function Rfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=o.shape.length;if(a===0)return pr({inputs:{x:o},backend:t});let i=o.shape,u=[1,1,1,1];i.forEach((g,b)=>{let T=b+4-a;u[T]=g});let l=y.parseAxisParam(s,o.shape),p=[0,0,0,0];l.forEach(g=>{let b=g+4-a;p[b]=1});let m=[{type:"int32",data:p}],c=Se({inputs:{x:o},backend:t,attrs:{shape:u}}),d=new xS(u),f=t.runWebGPUProgram(d,[c],c.dtype,m);t.disposeData(c.dataId);let h=Se({inputs:{x:f},backend:t,attrs:{shape:i}});return t.disposeData(f.dataId),h}var n4={kernelName:Qo,backendName:"webgpu",kernelFunc:Rfe};var IS=class{outputShape=[];shaderKey;dispatchLayout;dispatch;variableNames=["x"];uniforms;workgroupSize=[64,1,1];fillSnippet;size=!0;constructor(e,t){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${ce("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};var o4={kernelName:Ja,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=e,i=t,u=new IS(n.shape,s),[l,p]=C.getImageCenter(a,n.shape[1],n.shape[2]),m=[{type:"float32",data:[l]},{type:"float32",data:[p]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return typeof s=="number"?m.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):m.push({type:"float32",data:s}),i.runWebGPUProgram(u,[n],n.dtype,m)}};var Pfe=Re({opType:27,cpuKernelImpl:rK}),s4={kernelName:Jo,backendName:"webgpu",kernelFunc:Pfe};var Gl=class{variableNames=["updates","indices"];uniforms;outputShape;sumDupeIndices;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];updatesRank;indicesRank;sliceDimGreaterThanOne;atomic=!0;type;constructor(e,t,n,o,s,a,i,u=!0){this.outputShape=a,this.type=i,this.sumDupeIndices=u,this.dispatchLayout=ye(e),this.dispatch=le(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${o}_${this.sliceDimGreaterThanOne}_${i}_${u}`;let l=lr(s.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=o,this.indicesRank=n}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");let t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",o="",s="";this.dispatchLayout.x.length===1?(o="flattenedIndex",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(o="vec2<i32>(flattenedIndex, coords[1])",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);let i=`getUpdates(${Array.from({length:this.updatesRank},(p,m)=>`coords[${m}]`).join(", ")})`,u=(p,m)=>{let c=`atomicAdd(${p}, bitcast<i32>(${m}))`;this.type==="float32"&&(c=`
          {
            var oldBits = 0;
            var newBits = bitcast<i32>(${m});
            loop {
              let info = atomicCompareExchangeWeak(${p}, oldBits, newBits);
              if (info.exchanged) {
                break;
              }
              oldBits = info.old_value;
              let oldValue = bitcast<f32>(oldBits);
              let newValue = oldValue + (${m});
              newBits = bitcast<i32>(newValue);
            }
          }
        `);let d=`atomicStore(${p}, bitcast<i32>(${m}));`;return this.sumDupeIndices?c:d};return`
    ${s}

      ${ce("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue =
              ${Of(this.type,!1)}(${i});
          let flatIndex = getOutputIndexFromCoords(${o});

          ${u("&result[flatIndex]","updateValue")};
        }
      }`}};function Efe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:l,strides:p,outputSize:m}=C.calculateShapes(s,o,a),c=[m/l,l];if(m===0)return t.makeTensorInfo(a,o.dtype);let d=Se({inputs:{x:o},backend:t,attrs:{shape:[u,i]}}),f=Se({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=f.dtype,g=mn({backend:t,attrs:{shape:c,value:0,dtype:h}}),b=y.sizeFromShape(f.shape),T=[{type:"int32",data:[i]},{type:"int32",data:p},{type:"int32",data:[b]}],x=new Gl(f.shape,i,d.shape.length,f.shape.length,p,c,h),I=t.runWebGPUProgram(x,[f,d],h,T,g),S=Se({inputs:{x:I},backend:t,attrs:{shape:a}});return t.disposeData(d.dataId),t.disposeData(f.dataId),t.disposeData(I.dataId),S}var a4={kernelName:ja,backendName:"webgpu",kernelFunc:Efe};var CS=class{outputShape=[];shaderKey;dispatchLayout;dispatch;variableNames=["sortedSequence","values"];uniforms="numInputs : i32,";workgroupSize=[64,1,1];size=!0;side;constructor(e,t){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${ce("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}};function Ffe(r){let{inputs:e,backend:t,attrs:n}=r,{sortedSequence:o,values:s}=e,{side:a}=n,i=new CS([s.shape[0],s.shape[1]],a),u=[{type:"int32",data:[o.shape[1]]}];return t.runWebGPUProgram(i,[o,s],"int32",u)}var i4={kernelName:Qu,backendName:"webgpu",kernelFunc:Ffe};var SS=class{variableNames=["c","a","b"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];cRank;rank;size=!0;constructor(e,t,n){this.outputShape=t,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let i=0;i<this.outputShape.length;i++)a.push(`${o[i]}`),i<this.cRank&&s.push(`${o[i]}`);e=s.join(),t=a.join()}return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}};function Lfe(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=new SS(n.shape.length,o.shape,o.shape.length);return t.runWebGPUProgram(a,[n,o,s],Pt(o.dtype,s.dtype))}var u4={kernelName:Ds,backendName:"webgpu",kernelFunc:Lfe};var $fe=Re({opType:30}),l4={kernelName:ts,backendName:"webgpu",kernelFunc:$fe};var Bfe=Re({opType:28}),p4={kernelName:es,backendName:"webgpu",kernelFunc:Bfe};var Ofe=Re({opType:29}),m4={kernelName:Xa,backendName:"webgpu",kernelFunc:Ofe};var b0=ft({opType:20,cpuKernelImpl:uK,supportsComplex:!0}),c4={kernelName:as,backendName:"webgpu",kernelFunc:b0};function zfe(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,a=y.parseAxisParam([s],o.shape),i=_g({inputs:{x:o},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),u=C.expandShapeToKeepDim(i.shape,a),l=Se({inputs:{x:i},backend:t,attrs:{shape:u}}),p=b0({inputs:{a:o,b:l},backend:t}),m=c0({inputs:{x:p},backend:t}),c=Rg({inputs:{x:m},backend:t,attrs:{axis:a,keepDims:!1}}),d=Se({inputs:{x:c},backend:t,attrs:{shape:u}}),f=g0({inputs:{a:m,b:d},backend:t});return t.disposeData(i.dataId),t.disposeData(l.dataId),t.disposeData(p.dataId),t.disposeData(m.dataId),t.disposeData(c.dataId),t.disposeData(d.dataId),f}var d4={kernelName:os,backendName:"webgpu",kernelFunc:zfe};var Gfe=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((b,T)=>b*T),u=[[0,0]];u.push(...a);for(let b=1+s.length;b<o.shape.length;++b)u.push([0,0]);let l=[],p=h0({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),m=C.getReshaped(p.shape,s,i,!1),c=C.getPermuted(m.length,s.length,!1),d=C.getReshapedPermuted(p.shape,s,i,!1),f=Se({inputs:{x:p},backend:t,attrs:{shape:m}}),h=An({inputs:{x:f},backend:t,attrs:{perm:c}}),g=Se({inputs:{x:h},backend:t,attrs:{shape:d}});return l.push(p),l.push(f),l.push(h),l.forEach(b=>t.disposeData(b.dataId)),g},f4={kernelName:Ms,backendName:"webgpu",kernelFunc:Gfe};var kS=class{variableNames=["A"];outputShape;shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];size=!0;rank;constructor(e,t){let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let e=Wfe(this.rank,"uniforms.");return`
      ${ce("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}};function Wfe(r,e=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${e}aShape)`;let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r;o++)n.push(`(${t[o]} % ${e}aShape[${o}])`);return n.join()}function y0(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(t.shouldExecuteOnCPU([o])||o.dtype==="string"||o.shape.length>=5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(c=>y.decodeString(c)):u,p=Ie(o.shape,o.dtype,l),m=lK(p,s);return t.makeTensorInfo(m.shape,m.dtype,m.values)}let a=new kS(o.shape,s);return t.runWebGPUProgram(a,[o],o.dtype)}var h4={kernelName:Dn,backendName:"webgpu",kernelFunc:y0};function Ufe(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=e,{outputShape:i}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1;if(s.dtype==="string"){let M=t.bufferSync(o),R=t.bufferSync(s),E=y.decodeString(t.readSync(a.dataId)[0]),O=nK(M,R,i,c,p,l,u,m,E,d);return t.makeTensorInfo(i,O.dtype,O.values)}let f=[c/p,p],h=Se({inputs:{x:o},backend:t,attrs:{shape:[l,u]}}),g=s.shape.length?Se({inputs:{x:s},backend:t,attrs:{shape:[l,p]}}):pr({inputs:{x:s},backend:t}),b=g.dtype,T=t.makeTensorInfo([],b,y.makeZerosTypedArray(1,b)),x=Se({inputs:{x:a},backend:t,attrs:{shape:Array(f.length).fill(1)}}),I=y0({inputs:{x},backend:t,attrs:{reps:f}}),S=y.sizeFromShape([l,p]),w=[{type:"int32",data:[u]},{type:"int32",data:m},{type:"int32",data:[S]}];switch(l){case 0:break;case 1:{let M=new Gl([l,p],u,h.shape.length,g.shape.length,m,f,b,d);t.runWebGPUProgram(M,[g,h],b,w,I)}break;default:{let M=new Gl([l,p],u,h.shape.length,T.shape.length,m,f,b,d);t.runWebGPUProgram(M,[T,h],b,w,I)}{let M=new Gl([l,p],u,h.shape.length,g.shape.length,m,f,b);t.runWebGPUProgram(M,[g,h],b,w,I)}}let _=Se({inputs:{x:I},backend:t,attrs:{shape:i}});return t.disposeData(h.dataId),t.disposeData(g.dataId),t.disposeData(x.dataId),t.disposeData(T.dataId),t.disposeData(I.dataId),_}var g4={kernelName:rl,backendName:"webgpu",kernelFunc:Ufe};function Kfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=o.shape.length,p=new Array(l).fill(0),m=o.shape.slice();return u.map(c=>{let d=[...m];d[i]=c;let f=Ii({inputs:{x:o},backend:t,attrs:{begin:p,size:d}});return p[i]+=c,f})}var b4={kernelName:Rs,backendName:"webgpu",kernelFunc:Kfe};var Vfe=Re({opType:31}),y4={kernelName:rs,backendName:"webgpu",kernelFunc:Vfe};var T4={kernelName:Ni,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e,o=new ca(t.shape,32);return n.runWebGPUProgram(o,[t],t.dtype)}};var Hfe=ft({opType:19}),x4={kernelName:ss,backendName:"webgpu",kernelFunc:Hfe};var vS=class{variableNames=["x"];uniforms;outputShape;shaderKey;dispatchLayout;dispatch;workPerThread=1;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);let t=lr(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e=this.outputShape.length,t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let o=0;t=this.outputShape.map((s,a)=>(o++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${o-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${ce("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}};function qfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),S;if(h)S=Se({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),_=Ii({inputs:{x:o},backend:t,attrs:{begin:T,size:w}});S=Se({inputs:{x:_},backend:t,attrs:{shape:f}}),t.disposeData(_.dataId)}else if(t.shouldExecuteOnCPU([o])){let _=t.readSync(o.dataId),M=Ie(o.shape,o.dtype,_),R=aK(d,M,I,T);S=t.makeTensorInfo(f,o.dtype,R.values)}else{let _=new vS(d),M=[{type:"int32",data:T},{type:"int32",data:I}],R=t.runWebGPUProgram(_,[o],o.dtype,M);S=Se({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeData(R.dataId)}return S}var I4={kernelName:Ya,backendName:"webgpu",kernelFunc:qfe};function jfe(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:m}=e,c=t.readSync(p.dataId),d=t.readSync(m.dataId),[f,h]=iK(c,d,o,s,a,i,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(m.shape,"int32",h)]}var C4={kernelName:Di,backendName:"webgpu",kernelFunc:jfe};var Xfe=Re({opType:33}),S4={kernelName:is,backendName:"webgpu",kernelFunc:Xfe};var Yfe=Re({opType:34}),k4={kernelName:us,backendName:"webgpu",kernelFunc:Yfe};var AS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","indices"];uniforms;workgroupSize=[256,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${ce("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},wS=class{outputShape;shaderKey;dispatchLayout;dispatch;variableNames=["x","indices"];uniforms;workgroupSize=[256,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${ce("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};function jf(r,e){e!==null&&r.disposeData(e.dataId)}function v4(r){let e=1;for(;e<r;)e*=2;return e}function Zfe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:a}=n,i=o.shape,u=i[i.length-1];if(t.shouldExecuteOnCPU([o])){let S=t.readSync(o.dataId),[w,_]=pK(S,i,o.dtype,s,a);return[t.makeTensorInfo(w.shape,w.dtype,w.values),t.makeTensorInfo(_.shape,_.dtype,_.values)]}if(s===0)return i[i.length-1]=0,[t.makeTensorInfo(i,o.dtype,[]),t.makeTensorInfo(i,"int32",[])];if(u===1)return[o,mn({attrs:{shape:i,dtype:"int32",value:0},backend:t})];let p=y.sizeFromShape(i)/u,m=Se({inputs:{x:o},attrs:{shape:[p,u]},backend:t}),c=v4(s),d=v4(u),f=null,h=()=>f===null?[m,m]:[m,f],g=(S,w,_)=>{let M=h(),R=new AS(_),O=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[S]},{type:"int32",data:[w]}],G=f;f=t.runWebGPUProgram(R,M,"int32",O),jf(t,G)};for(let S=1;S<c;S*=2){let w=S*2;for(let _=S;_>=1;_/=2)g(w,_,[p,d])}for(let S=d;S>c;S/=2){let w=h(),_=new wS([p,S/2]),R=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[c]}],E=f;f=t.runWebGPUProgram(_,w,"int32",R),jf(t,E);let O=c/2,G=O*2;for(let W=O;W>=1;W/=2)g(G,W,f.shape)}let b=f;f=Ii({inputs:{x:f},backend:t,attrs:{begin:0,size:[p,s]}}),jf(t,b);let T=f0({inputs:{x:m,indices:f},backend:t,attrs:{axis:1,batchDims:1}});jf(t,m);let x=i.slice(0,-1);x.push(s),b=f,f=Se({inputs:{x:f},attrs:{shape:x},backend:t}),jf(t,b);let I=T;return T=Se({inputs:{x:T},attrs:{shape:x},backend:t}),jf(t,I),[T,f]}var A4={kernelName:Za,backendName:"webgpu",kernelFunc:Zfe};var NS=class{variableNames=["Image","Transforms"];outputShape;uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,";shaderKey;dispatchLayout;dispatch;workgroupSize=[64,1,1];size=!0;constructor(e){this.outputShape=e,this.dispatchLayout=ye(this.outputShape),this.dispatch=le(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${ce("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};function Qfe(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=new NS(g),T=a==="nearest"?1:2,x;switch(i){case"constant":x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4;break;default:x=1;break}let I=[{type:"int32",data:[T]},{type:"int32",data:[x]},{type:"float32",data:[u]}];return t.runWebGPUProgram(b,[o,s],"float32",I)}var w4={kernelName:Qa,backendName:"webgpu",kernelFunc:Qfe};function Jfe(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],l=new Array(i-1),p=0;for(let h=0;h<i;h++)h!==s&&(l[p++]=a.shape[h]);let m=[],c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){c[s]=h;let g=Ii({inputs:{x:a},backend:t,attrs:{begin:c,size:d}}),b=Se({inputs:{x:g},backend:t,attrs:{shape:l}});f[h]=b,m.push(g)}return m.forEach(h=>t.disposeData(h.dataId)),f}var N4={kernelName:Ps,backendName:"webgpu",kernelFunc:Jfe};var ehe=[_U,cK,dK,fK,hK,gK,yK,TK,xK,IK,CK,SK,kK,vK,AK,DK,_K,RK,PK,$K,BK,OK,RU,GK,WK,UK,KK,VK,HK,XK,YK,ZK,QK,JK,rV,nV,oV,sV,aV,iV,uV,lV,NU,pV,dV,mV,cV,fV,hV,gV,bV,yV,TV,xV,MU,IV,zK,CV,SV,kV,vV,AV,wV,DV,NV,_V,MV,wK,RV,PV,NK,EV,FV,LV,$V,eV,BV,OV,zV,EK,GV,KV,VV,HV,qV,jV,XV,YV,FK,ZV,QV,JV,e4,DU,t4,r4,n4,o4,s4,a4,i4,u4,l4,p4,m4,MK,I4,C4,d4,f4,g4,b4,y4,T4,x4,c4,tV,S4,k4,h4,A4,w4,bK,N4,WV];for(let r of ehe)su(r);var Qe=(s=>(s[s.float32=0]="float32",s[s.int32=1]="int32",s[s.bool=2]="bool",s[s.string=3]="string",s[s.complex64=4]="complex64",s))(Qe||{}),cm=(i=>(i[i.linear=0]="linear",i[i.relu=1]="relu",i[i.relu6=2]="relu6",i[i.prelu=3]="prelu",i[i.leakyrelu=4]="leakyrelu",i[i.sigmoid=5]="sigmoid",i[i.elu=6]="elu",i))(cm||{});var D4;function the(r){D4=r.wasm.cwrap(Ls,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function rhe(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=e;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:m}=n,c=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(s.dataId).id,f=0;if(a!=null){let M=t.dataIdMap.get(a.dataId);if(M.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${M.shape.length}.`);f=M.id}let h=i==null?0:t.dataIdMap.get(i.dataId).id,g=cm[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let b=u?o.shape[2]:o.shape[1],T=l?s.shape[1]:s.shape[2],x=Dr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),I=t.makeOutput([...x,b,T],o.dtype),S=t.dataIdMap.get(I.dataId).id,w=new Uint8Array(new Int32Array(o.shape).buffer),_=new Uint8Array(new Int32Array(s.shape).buffer);return D4(c,w,o.shape.length,d,_,s.shape.length,u,l,g,f,h,m||0,S),I}var _4={kernelName:Ls,backendName:"wasm",setupFunc:the,kernelFunc:rhe};function st(r,e){let t;function n(s){t=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:a,inputs:{x:i}}=s,u=a.dataIdMap.get(i.dataId).id,l=a.makeOutput(i.shape,e||i.dtype),p=a.dataIdMap.get(l.dataId).id;return y.sizeFromShape(l.shape)===0||t(u,Qe[i.dtype],p),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var M4=st(xs);function ht(r,e,t){let n;function o(a){n=a.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(a){let{backend:i,inputs:u}=a,{a:l,b:p}=u,m=i.dataIdMap.get(l.dataId).id,c=i.dataIdMap.get(p.dataId).id,d=t??l.dtype,f=C.assertAndGetBroadcastShape(l.shape,p.shape),h=i.makeOutput(f,d);if(y.sizeFromShape(f)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),b=new Uint8Array(new Int32Array(p.shape).buffer),T=i.dataIdMap.get(h.dataId).id;return(()=>n(m,g,l.shape.length,c,b,p.shape.length,Qe[l.dtype],T))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var nhe=!0,R4=ht(Nn,nhe);var P4;function ohe(r){P4=r.wasm.cwrap(co,null,["array","number","number","number"])}function she(r){let{inputs:e,backend:t}=r,n=t.makeOutput(e[0].shape,e[0].dtype);if(y.sizeFromShape(n.shape)===0)return n;let o=e.map(i=>t.dataIdMap.get(i.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),a=t.dataIdMap.get(n.dataId).id;return P4(s,o.length,Qe[n.dtype],a),n}var E4={kernelName:co,backendName:"wasm",setupFunc:ohe,kernelFunc:she};function dm(r){let{inputs:{x:e},backend:t}=r;if(e.dtype==="string")return mr(t.readSync(e.dataId),e.shape,e.dtype);let n=t.makeOutput(e.shape,e.dtype),o=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(n).set(o),n}var F4={kernelName:Vn,backendName:"wasm",kernelFunc:dm};var L4;function ahe(r){L4=r.wasm.cwrap(_n,null,["number","array","number","number","number","array","number"])}function Ts(r){let{inputs:e,backend:t,attrs:n}=r,[o,s]=uhe(e.x.shape,n.perm),a=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(a=!1);let i=ihe(e.x.shape,n.perm),u={dataId:e.x.dataId,shape:o,dtype:e.x.dtype};if(a){let f=dm({inputs:e,backend:t});return f.shape=i,f}let l=t.makeOutput(i,u.dtype),p=t.dataIdMap.get(u.dataId).id,m=t.dataIdMap.get(l.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),d=new Uint8Array(new Int32Array(u.shape).buffer);return L4(p,d,u.shape.length,Qe[u.dtype],m,c,s.length),l}function ihe(r,e){let t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=r[e[n]];return t}function uhe(r,e){let t=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&t.push(r[o]),r[e[o]]!==1&&n.push(e[o]);for(let o=0;o<n.length;++o){let s=-1;for(let a=0;a<n.length;++a)n[a]>=o&&(s===-1||n[s]>n[a])&&(s=a);n[s]=o}return[t,n]}var $4={kernelName:_n,backendName:"wasm",kernelFunc:Ts,setupFunc:ahe};function wn(r,e,t){let n=r.shape,o=r.shape.length,s=y.parseAxisParam(e,n),a=s,i=C.getAxesPermutation(a,o),u=null,l=!1;if(i!=null){let p=new Array(o);for(let d=0;d<p.length;d++)p[d]=n[i[d]];a=C.getInnerMostAxes(a.length,o),u=Ts({inputs:{x:r},attrs:{perm:i},backend:t});let m=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(u.dataId).id!==m&&(l=!0)}return{transposed:u,originalAxes:s,axes:a,inputWasTransposed:l}}var B4;function lhe(r){B4=r.wasm.cwrap(xa,null,["number, number, number"])}function phe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;l=p,u=x}let f=l.shape.length;C.assertAxesAreInnerMostDims("all",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,a.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;B4(u,b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var O4={kernelName:xa,backendName:"wasm",setupFunc:lhe,kernelFunc:phe};var z4;function mhe(r){z4=r.wasm.cwrap(Ia,null,["number, number, number"])}function che(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;l=p,u=x}let f=l.shape.length;C.assertAxesAreInnerMostDims("any",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,a.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;z4(u,b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var G4={kernelName:Ia,backendName:"wasm",setupFunc:mhe,kernelFunc:che};var W4;function dhe(r){W4=r.wasm.cwrap(fo,null,["number","number","number","number","number"])}function fhe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=a,u=s,{transposed:l,axes:p,inputWasTransposed:m}=wn(s,o,e);if(m){let b=e.dataIdMap.get(l.dataId).id;b!==a&&(u=l,i=b)}let c=u.shape.slice(0,-1),d=e.makeOutput(c,"int32"),f=e.dataIdMap.get(d.dataId).id,h=y.sizeFromShape(d.shape),g=u.shape[p[0]];return W4(i,Qe[u.dtype],h,g,f),m&&e.disposeData(l.dataId),d}var U4={kernelName:fo,backendName:"wasm",kernelFunc:fhe,setupFunc:dhe};var K4;function hhe(r){K4=r.wasm.cwrap(ho,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ghe(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=t,p=C.computePool2DInfo(o.shape,a,i,1,u,l),m=p.filterHeight,c=p.filterWidth,d=p.padInfo.top,f=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,b=p.strideHeight,T=p.strideWidth,x=p.inChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(p.dilationWidth!==1||p.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let I=n.makeOutput(p.outShape,"float32"),S=n.dataIdMap.get(I.dataId).id;return K4(s,o.shape[0],o.shape[1],o.shape[2],m,c,d,f,h,g,b,T,x,S),I}var V4={kernelName:ho,backendName:"wasm",setupFunc:hhe,kernelFunc:ghe};function hr(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(o,s);return y.assert(s===y.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var H4={kernelName:Ns,backendName:"wasm",kernelFunc:hr};var q4;function bhe(r){q4=r.wasm.cwrap(go,null,["number","array","number","number","array","number","number","number","number"])}function yhe(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:a,transposeB:i}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,p=a?o.shape[u-2]:o.shape[u-1],m=i?s.shape[l-1]:s.shape[l-2],c=a?o.shape[u-1]:o.shape[u-2],d=i?s.shape[l-2]:s.shape[l-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(f),b=y.sizeFromShape(h),x=Dr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,d]);y.assert(p===m,()=>`Error in matMul: inner shapes (${p}) and (${m}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,p,c]:[g,c,p],S=i?[b,d,m]:[b,m,d],w=hr({inputs:{x:o},backend:t,attrs:{shape:I}}),_=hr({inputs:{x:s},backend:t,attrs:{shape:S}}),M=t.dataIdMap.get(w.dataId).id,R=t.dataIdMap.get(_.dataId).id,E=a?w.shape[2]:w.shape[1],O=i?_.shape[1]:_.shape[2],G=Math.max(g,b),W=t.makeOutput([G,E,O],w.dtype),H=t.dataIdMap.get(W.dataId).id,U=new Uint8Array(new Int32Array(w.shape).buffer),V=new Uint8Array(new Int32Array(_.shape).buffer);return q4(M,U,w.shape.length,R,V,_.shape.length,a,i,H),t.disposeData(w.dataId),t.disposeData(_.dataId),W.shape=x,W}var j4={kernelName:go,backendName:"wasm",setupFunc:bhe,kernelFunc:yhe};function da(r){let{inputs:{x:e},attrs:{begin:t,size:n},backend:o}=r,[s,a]=It.parseSliceParams(e,t,n),i=It.isSliceContinous(e.shape,s,a),u=o.readSync(e.dataId),l=o.makeOutput(a,e.dtype),p=y.computeStrides(e.shape),m=o.dataIdMap.get(l.dataId);if(i){let f=It.computeFlatOffset(s,p);return e.dtype==="string"?m.stringBytes=u.slice(f,f+y.sizeFromShape(a)):o.typedArrayFromHeap(l).set(u.subarray(f,f+y.sizeFromShape(a))),l}if(e.dtype==="string"){let f=Vp(u,s,a,e.shape,e.dtype);return m.stringBytes=f,l}let c=o.typedArrayFromHeap(l),d=e.shape.length;if(d===2)The(u,p[0],c,s,a);else if(d===3)xhe(u,p[0],p[1],c,s,a);else if(d===4)Ihe(u,p[0],p[1],p[2],c,s,a);else{let f=Vp(u,s,a,e.shape,e.dtype);c.set(f)}return l}function The(r,e,t,n,o){let s=0,a=n[0],i=n[1],u=a+o[0];for(let l=a;l<u;l++){let p=l*e+i;t.set(r.subarray(p,p+o[1]),s),s+=o[1]}}function xhe(r,e,t,n,o,s){let a=0,i=o[0],u=o[1],l=o[2],p=i+s[0],m=u+s[1];for(let c=i;c<p;c++)for(let d=u;d<m;d++){let f=c*e+d*t+l;n.set(r.subarray(f,f+s[2]),a),a+=s[2]}}function Ihe(r,e,t,n,o,s,a){let i=0,u=s[0],l=s[1],p=s[2],m=u+a[0],c=l+a[1],d=p+a[2],f=s[3];for(let h=u;h<m;h++)for(let g=l;g<c;g++)for(let b=p;b<d;b++){let T=h*e+g*t+b*n+f;o.set(r.subarray(T,T+a[3]),i),i+=a[3]}}var X4={kernelName:_s,backendName:"wasm",kernelFunc:da};function Che(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:a}=n,i=s.reduce((b,T)=>b*T),u=C.getReshaped(o.shape,s,i),l=C.getPermuted(u.length,s.length),p=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(p,a,s.length),d=hr({inputs:{x:o},backend:t,attrs:{shape:u}}),f=Ts({inputs:{x:d},backend:t,attrs:{perm:l}}),h=hr({inputs:{x:f},backend:t,attrs:{shape:p}}),g=da({inputs:{x:h},backend:t,attrs:{begin:m,size:c}});return t.disposeData(d.dataId),t.disposeData(f.dataId),t.disposeData(d.dataId),g}var Y4={kernelName:Is,backendName:"wasm",kernelFunc:Che};function Ci(r){let{inputs:{x:e},attrs:{dtype:t},backend:n}=r,o=n.makeOutput(e.shape,t),s=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(o).set(s),o}var Z4={kernelName:Un,backendName:"wasm",kernelFunc:Ci};var Q4=st(bo);var J4;function She(r){J4=r.wasm.cwrap(Kn,null,["number","number","number","number"])}function khe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:a}=n,i=t.dataIdMap.get(o.dataId).id,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(u.dataId).id;return J4(i,s,a,l),u}var eH={kernelName:Kn,backendName:"wasm",setupFunc:She,kernelFunc:khe};function T0(r){let{inputs:e,backend:t}=r,n=y.parseAxisParam(r.attrs.axis,e[0].shape)[0],o=e.map(d=>d.shape);C.assertParamsConsistent(o,n);let s=C.computeOutShape(e.map(d=>d.shape),n),a=e.filter(d=>y.sizeFromShape(d.shape)>0);if(a.length===1)return dm({inputs:{x:a[0]},backend:t});let i=t.makeOutput(s,e[0].dtype);if(y.sizeFromShape(s)===0)return i;if(a[0].dtype==="string"){let d=a.map(x=>{let S=[-1,y.sizeFromShape(x.shape.slice(n))];return hr({inputs:{x},backend:t,attrs:{shape:S}})}),f=d.map(x=>({vals:t.readSync(x.dataId),shape:x.shape}));s=C.computeOutShape(d.map(x=>x.shape),1);let h=d[0].shape[0]===1,g=Wp(f,s,e[0].dtype,h),b=C.computeOutShape(a.map(x=>x.shape),n);i.shape=b;let T=t.dataIdMap.get(i.dataId);return T.stringBytes=C.fromStringArrayToUint8(g),d.forEach(x=>t.disposeData(x.dataId)),i}let u=y.sizeFromShape(a[0].shape.slice(0,n)),l=0,p=a.map(d=>{let f=y.sizeFromShape(d.shape.slice(n));return l+=f,f}),m=a.map(d=>t.typedArrayFromHeap(d)),c=t.typedArrayFromHeap(i);for(let d=0;d<u;d++){let f=d*l;for(let h=0;h<m.length;h++){let g=p[h],b=d*g,T=m[h].subarray(b,b+g);c.set(T,f),f+=g}}return i}var tH={kernelName:Cs,backendName:"wasm",kernelFunc:T0};var rH;function vhe(r){rH=r.wasm.cwrap(yo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ahe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:m,dataFormat:c}=t,d=C.convertConv2DDataFormat(c),f=C.computeConv2DInfo(o.shape,s.shape,u,l,p,m,!1,d),h=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,T=f.padInfo.right,x=f.padInfo.bottom,I=f.padInfo.left,S=f.dilationHeight,w=f.dilationWidth,_=f.strideHeight,M=f.strideWidth,R=f.inChannels,E=f.outChannels,O=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let G=n.makeOutput(f.outShape,"float32"),W=n.dataIdMap.get(G.dataId).id;return rH(a,o.shape[0],o.shape[1],o.shape[2],i,h,g,b,T,x,I,O,S,w,_,M,R,E,W),G}var nH={kernelName:yo,backendName:"wasm",setupFunc:vhe,kernelFunc:Ahe};var oH;function whe(r){oH=r.wasm.cwrap(To,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Nhe(r){let{backend:e,inputs:t,attrs:n}=r,{dy:o,filter:s}=t,{strides:a,pad:i,dataFormat:u,dimRoundingMode:l,inputShape:p}=n,m=1,c=C.convertConv2DDataFormat(u),d=C.computeConv2DInfo(p,s.shape,a,m,i,l,!1,c),{batchSize:f,filterHeight:h,filterWidth:g,inChannels:b,inHeight:T,inWidth:x,outChannels:I,outHeight:S,outWidth:w,strideHeight:_,strideWidth:M}=d,R=h-1-d.padInfo.top,E=g-1-d.padInfo.left,O=d.dataFormat==="channelsLast",G=y.computeStrides(d.inShape),W=y.computeStrides(o.shape),[H,U,V]=y.computeStrides(s.shape),Y=G[0],j=O?G[1]:G[2],te=O?G[2]:1,ne=O?1:G[1],oe=W[0],ae=O?W[1]:W[2],se=O?W[2]:1,ie=O?1:W[1],he=e.makeOutput(d.inShape,"float32"),Te=e.dataIdMap.get(he.dataId).id,ve=e.dataIdMap.get(o.dataId).id,Pe=e.dataIdMap.get(s.dataId).id;return oH(ve,Pe,f,h,g,T,x,b,S,w,I,_,M,R,E,H,U,V,Y,j,te,ne,oe,ae,se,ie,Te),he}var sH={kernelName:To,backendName:"wasm",setupFunc:whe,kernelFunc:Nhe};var aH=st(xo);var iH=st(Io);var uH=(t=>(t[t.bilinear=0]="bilinear",t[t.nearest=1]="nearest",t))(uH||{}),lH;function Dhe(r){lH=r.wasm.cwrap(Na,null,["number","number","number","number","array","number","number","number","number","number"])}function _he(r){let{backend:e,inputs:t,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:a}=n,{image:i,boxes:u,boxInd:l}=t,p=u.shape[0],[m,c]=a,d=[p,m,c,i.shape[3]],f=e.dataIdMap.get(i.dataId),h;i.dtype!=="float32"&&(h=Ci({backend:e,inputs:{x:i},attrs:{dtype:"float32"}}),f=e.dataIdMap.get(h.dataId));let g=f.id,b=e.dataIdMap.get(u.dataId).id,T=e.dataIdMap.get(l.dataId).id,x=e.makeOutput(d,"float32"),I=e.dataIdMap.get(x.dataId).id,S=new Uint8Array(new Int32Array(i.shape).buffer);return lH(g,b,T,p,S,m,c,uH[o],s,I),h!=null&&e.disposeData(h.dataId),x}var pH={kernelName:Na,backendName:"wasm",setupFunc:Dhe,kernelFunc:_he};var mH;function Mhe(r){mH=r.wasm.cwrap(wa,null,["number","number","number","number","number","number"])}function Rhe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumprod does not support ${o.dtype} tensors in the WASM backend`);let l=C.getAxesPermutation([s],u),p=o;l!==null&&(p=Ts({inputs:{x:o},attrs:{perm:l},backend:t}));let m=C.getInnerMostAxes(1,u)[0];C.assertAxesAreInnerMostDims("cumprod",[m],u);let c=t.makeOutput(p.shape,p.dtype),d=p.shape[m],f=t.dataIdMap.get(p.dataId).id,h=t.dataIdMap.get(c.dataId).id;mH(f,a?1:0,i?1:0,d,h,Qe[o.dtype]);let g=c;if(l!==null){let b=C.getUndoAxesPermutation(l);g=Ts({inputs:{x:c},attrs:{perm:b},backend:t}),t.disposeData(p.dataId),t.disposeData(c.dataId)}return g}var cH={kernelName:wa,backendName:"wasm",setupFunc:Mhe,kernelFunc:Rhe};var dH;function Phe(r){dH=r.wasm.cwrap(Co,null,["number","number","number","number","number","number"])}function Ehe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=C.getAxesPermutation([s],u),p=o;l!==null&&(p=Ts({inputs:{x:o},attrs:{perm:l},backend:t}));let m=C.getInnerMostAxes(1,u)[0];C.assertAxesAreInnerMostDims("cumsum",[m],u);let c=t.makeOutput(p.shape,p.dtype),d=p.shape[m],f=t.dataIdMap.get(p.dataId).id,h=t.dataIdMap.get(c.dataId).id;dH(f,a?1:0,i?1:0,d,h,Qe[o.dtype]);let g=c;if(l!==null){let b=C.getUndoAxesPermutation(l);g=Ts({inputs:{x:c},attrs:{perm:b},backend:t}),t.disposeData(p.dataId),t.disposeData(c.dataId)}return g}var fH={kernelName:Co,backendName:"wasm",setupFunc:Phe,kernelFunc:Ehe};var hH;function Fhe(r){hH=r.wasm.cwrap(Da,null,["number","number","number","array","number","array","array","number","number"])}function Lhe(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],l=a==="NHWC"?o.shape[2]:o.shape[3],p=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=l*s,d=p/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=e.makeOutput(f,"float32"),b=e.dataIdMap.get(o.dataId).id,T=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),x=new Uint8Array(new Int32Array(f).buffer),I=new Uint8Array(new Int32Array(y.computeStrides(f)).buffer),S=e.dataIdMap.get(h.dataId).id;return hH(b,s,a==="NHWC"?1:0,T,o.shape.length-1,x,I,f.length,S),h}var gH={kernelName:Da,backendName:"wasm",setupFunc:Fhe,kernelFunc:Lhe};var bH;function $he(r){bH=r.wasm.cwrap(So,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Bhe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:m}=t,c=l??[1,1],d=C.computeConv2DInfo(o.shape,s.shape,u,c,p,m,!0),f=d.filterHeight,h=d.filterWidth,g=d.padInfo.top,b=d.padInfo.right,T=d.padInfo.bottom,x=d.padInfo.left,I=d.dilationHeight,S=d.dilationWidth,w=d.strideHeight,_=d.strideWidth,M=d.inChannels,R=d.outChannels,E=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let O=n.makeOutput(d.outShape,"float32"),G=n.dataIdMap.get(O.dataId).id;return bH(a,o.shape[0],o.shape[1],o.shape[2],i,f,h,g,b,T,x,E,I,S,w,_,M,R,G),O}var yH={kernelName:So,backendName:"wasm",setupFunc:$he,kernelFunc:Bhe};var TH=st(vo);var Ohe=!1,xH=ht(Ma,Ohe,"bool");var IH=st(Ao,"float32");function DS(r){let{inputs:e,attrs:t,backend:n}=r,{input:o}=e,{dim:s}=t,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),hr({inputs:{x:o},backend:n,attrs:{shape:i}})}var CH={kernelName:Ss,backendName:"wasm",kernelFunc:DS};function x0(r){let{attrs:{shape:e,value:t,dtype:n},backend:o}=r,s=o.makeOutput(e,n);return o.typedArrayFromHeap(s).fill(t),s}var SH={kernelName:Ai,backendName:"wasm",kernelFunc:x0};var kH;function zhe(r){kH=r.wasm.cwrap(Pa,null,["number","number","number","number","number","number"])}function Ghe(r){let{inputs:e,backend:t}=r,{image:n}=e,o=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,[i,u,l,p]=n.shape;return kH(s,i,u,l,p,a),o}var vH={kernelName:Pa,backendName:"wasm",kernelFunc:Ghe,setupFunc:zhe};var AH=st(wo);var Whe=!1,wH=ht(No,Whe);var NH;function Uhe(r){NH=r.wasm.cwrap(Do,null,["number","number","number","number","number","number","number"])}function Khe(r){let{backend:e,inputs:t,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:a,variance:i,offset:u,scale:l}=t,p=e.dataIdMap.get(s.dataId).id,m=e.dataIdMap.get(a.dataId).id,c=e.dataIdMap.get(i.dataId).id,d=u!=null?e.dataIdMap.get(u.dataId).id:0,f=l!=null?e.dataIdMap.get(l.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(y.sizeFromShape(s.shape)===0)return h;let g=e.dataIdMap.get(h.dataId).id;return NH(p,m,c,d,f,o,g),h}var DH={kernelName:Do,backendName:"wasm",setupFunc:Uhe,kernelFunc:Khe};var _H;function Vhe(r){_H=r.wasm.cwrap($s,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Hhe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dataFormat:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=t,h=C.computeConv2DInfo(o.shape,s.shape,u,p,l,c),g=cm[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);let b=n.dataIdMap.get(o.dataId).id,T=n.dataIdMap.get(s.dataId).id,x=h.outChannels,I=0;if(a!=null){let se=n.dataIdMap.get(a.dataId);if(se.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${se.shape.length}.`);if(se.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${se.shape}) does not match the number of output channels (${x})`);I=se.id}let S=h.filterHeight,w=h.filterWidth,_=h.padInfo.top,M=h.padInfo.right,R=h.padInfo.bottom,E=h.padInfo.left,O=h.dilationHeight,G=h.dilationWidth,W=h.strideHeight,H=h.strideWidth,U=h.inChannels,V=h.padInfo.type==="SAME"?1:0,Y=h.batchSize,j=h.inHeight,te=h.inWidth;if(m!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);let ne=n.makeOutput(h.outShape,"float32"),oe=n.dataIdMap.get(ne.dataId).id,ae=i==null?0:n.dataIdMap.get(i.dataId).id;return _H(b,Y,j,te,T,S,w,I,_,M,R,E,V,O,G,W,H,U,x,g,ae,f||0,oe),ne}var MH={kernelName:$s,backendName:"wasm",setupFunc:Vhe,kernelFunc:Hhe};var RH;function qhe(r){RH=r.wasm.cwrap(Bs,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jhe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=e,{strides:u,pad:l,dilations:p,dataFormat:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=t,h=C.computeConv2DInfo(o.shape,s.shape,u,p,l,c,!0),g=cm[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=n.dataIdMap.get(o.dataId).id,T=n.dataIdMap.get(s.dataId).id,x=h.outChannels,I=0;if(a!=null){let se=n.dataIdMap.get(a.dataId);if(se.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${se.shape.length}.`);if(se.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${se.shape}) does not match the number of output channels (${x})`);I=se.id}let S=h.filterHeight,w=h.filterWidth,_=h.padInfo.top,M=h.padInfo.right,R=h.padInfo.bottom,E=h.padInfo.left,O=h.dilationHeight,G=h.dilationWidth,W=h.strideHeight,H=h.strideWidth,U=h.inChannels,V=h.padInfo.type==="SAME"?1:0,Y=h.batchSize,j=h.inHeight,te=h.inWidth;if(m!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);let ne=n.makeOutput(h.outShape,"float32"),oe=n.dataIdMap.get(ne.dataId).id,ae=i==null?0:n.dataIdMap.get(i.dataId).id;return RH(b,Y,j,te,T,S,w,I,_,M,R,E,V,O,G,W,H,U,x,g,ae,f||0,oe),ne}var PH={kernelName:Bs,backendName:"wasm",setupFunc:qhe,kernelFunc:jhe};var EH;function Xhe(r){EH=r.wasm.cwrap(Ea,null,["number","number","number","number","number","number","array","number"])}function Yhe(r){let{backend:e,inputs:t}=r,{params:n,indices:o}=t,[s,a,i,u]=Ob.prepareAndValidate(n,o),l=e.makeOutput(s,n.dtype);if(a===0)return l;let p=o.shape,m=p[p.length-1],d=e.dataIdMap.get(n.dataId).id,h=e.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),b=e.dataIdMap.get(l.dataId).id;return EH(d,Qe[n.dtype],h,a,m,i,g,b),l}var FH={kernelName:Ea,backendName:"wasm",setupFunc:Xhe,kernelFunc:Yhe};var LH;function Zhe(r){LH=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Qhe(r){let{backend:e,inputs:t,attrs:n}=r,{x:o,indices:s}=t,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0],l=e.readSync(s.dataId),p=o.shape[u];for(let R=0;R<l.length;++R){let E=l[R];y.assert(E<=p-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${p-1}]`)}let m=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),c=hr({inputs:{x:o},attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]},backend:e}),d=y.sizeFromShape(s.shape),f=hr({inputs:{x:s},attrs:{shape:[m.batchSize,d/m.batchSize]},backend:e}),h=[m.batchSize,m.outerSize,d/m.batchSize,m.sliceSize],g=e.makeOutput(h,o.dtype);if(y.sizeFromShape(o.shape)===0)return g;let b=c.shape.length-1,x=e.dataIdMap.get(c.dataId).id,S=e.dataIdMap.get(f.dataId).id,w=e.dataIdMap.get(g.dataId).id,_=new Uint8Array(new Int32Array(y.computeStrides(c.shape)).buffer),M=new Uint8Array(new Int32Array(y.computeStrides(h)).buffer);return LH(x,Qe[o.dtype],_,b,S,m.batchSize,M,w),e.disposeData(c.dataId),e.disposeData(f.dataId),g.shape=m.outputShape,g}var $H={kernelName:ks,backendName:"wasm",setupFunc:Zhe,kernelFunc:Qhe};var Jhe=!1,BH=ht(Fa,Jhe,"bool");var ege=!1,OH=ht(_o,ege,"bool");var zH=st(Mo,"bool");var GH;function tge(r){GH=r.wasm.cwrap(Ro,null,["number","number","number","number"])}function rge(r){let{inputs:{x:e},attrs:{alpha:t},backend:n}=r,o=n.dataIdMap.get(e.dataId).id,s=n.makeOutput(e.shape,"float32");if(y.sizeFromShape(e.shape)!==0){let a=n.dataIdMap.get(s.dataId).id;GH(o,Qe[e.dtype],t,a)}return s}var WH={kernelName:Ro,backendName:"wasm",setupFunc:tge,kernelFunc:rge};var nge=!1,UH=ht(Ba,nge,"bool");var oge=!1,KH=ht(Oa,oge,"bool");var VH=st(Po);var sge=!1,HH=ht(Ga,sge,"bool");var qH=st(Wa);var age=!1,jH=ht(Ji,age,"bool");var ige=!1,XH=ht(e_,ige,"bool");var YH;function uge(r){YH=r.wasm.cwrap(Eo,null,["number","number","number","number"])}function lge(r){let{backend:e,inputs:t,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:a}=t,u=e.dataIdMap.get(a.dataId).id,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;l=p,u=x}let f=l.shape.length;C.assertAxesAreInnerMostDims("max",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,a.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;YH(u,Qe[a.dtype],b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var ZH={kernelName:Eo,backendName:"wasm",setupFunc:uge,kernelFunc:lge};var pge=!1,QH=ht(Fo,pge);var JH;function mge(r){JH=r.wasm.cwrap(Lo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function cge(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id;y.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:a,strides:i,pad:u,dimRoundingMode:l}=t,p=C.computePool2DInfo(o.shape,a,i,1,u,l),m=p.filterHeight,c=p.filterWidth,d=p.padInfo.top,f=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,b=p.dilationHeight,T=p.dilationWidth,x=p.strideHeight,I=p.strideWidth,S=p.inChannels,w=p.outChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let _=n.makeOutput(p.outShape,"float32"),M=n.dataIdMap.get(_.dataId).id;return JH(s,o.shape[0],o.shape[1],o.shape[2],m,c,d,f,h,g,b,T,x,I,S,w,M),_}var eq={kernelName:Lo,backendName:"wasm",setupFunc:mge,kernelFunc:cge};var tq;function dge(r){tq=r.wasm.cwrap($o,null,["number, number, number"])}function fge(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e),f=m;if(d){let I=e.dataIdMap.get(p.dataId).id;I!==i&&(l=p,u=I,f=C.getInnerMostAxes(f.length,l.shape.length))}C.assertAxesAreInnerMostDims("mean",f,l.shape.length);let[h,g]=C.computeOutAndReduceShapes(l.shape,f),b=y.sizeFromShape(g),T=l;l.dtype!=="float32"&&(T=Ci({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),u=e.dataIdMap.get(T.dataId).id);let x=e.makeOutput(h,"float32");if(y.sizeFromShape(l.shape)!==0){let I=e.dataIdMap.get(x.dataId).id;tq(u,b,I)}if(d&&e.disposeData(p.dataId),s){let I=C.expandShapeToKeepDim(x.shape,c);x.shape=I}return l.dtype!=="float32"&&e.disposeData(T.dataId),x}var rq={kernelName:$o,backendName:"wasm",setupFunc:dge,kernelFunc:fge};var nq;function hge(r){nq=r.wasm.cwrap(Bo,null,["number","number","number","number"])}function gge(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e);if(d){let x=e.dataIdMap.get(p.dataId).id;x!==i&&(l=p,u=x)}let f=l.shape.length;C.assertAxesAreInnerMostDims("min",m,f);let[h,g]=C.computeOutAndReduceShapes(l.shape,m),b=y.sizeFromShape(g),T=e.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;nq(u,Qe[a.dtype],b,x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var oq={kernelName:Bo,backendName:"wasm",setupFunc:hge,kernelFunc:gge};var bge=!1,sq=ht(Oo,bge);var aq=(t=>(t[t.reflect=0]="reflect",t[t.symmetric=1]="symmetric",t))(aq||{}),iq;function yge(r){iq=r.wasm.cwrap(zo,null,["number","array","number","number","array","array","number","number"])}function Tge(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,mode:o}}=r,s=n.map((f,h)=>f[0]+e.shape[h]+f[1]),a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),u=t.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),p=n.map(f=>f[0]),m=n.map(f=>f[1]),c=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(m).buffer);return iq(a,l,e.shape.length,Qe[e.dtype],c,d,aq[o],u),i}var uq={kernelName:zo,backendName:"wasm",kernelFunc:Tge,setupFunc:yge};var xge=!0,lq=ht(Go,xge);var pq=st(vs);function Xf(r,e){let t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),n=t[0],o=t[1],s=t[2],a=t[3];return r.wasm._free(e),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:a}}var mq;function Ige(r){mq=r.wasm.cwrap(Va,"number",["number","number","number","number","number"])}function Cge(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a}=n,{boxes:i,scores:u}=t,l=e.dataIdMap.get(i.dataId).id,p=e.dataIdMap.get(u.dataId).id,m=mq(l,p,s,o,a),{pSelectedIndices:c,selectedSize:d,pSelectedScores:f,pValidOutputs:h}=Xf(e,m);return e.wasm._free(f),e.wasm._free(h),e.makeOutput([d],"int32",c)}var cq={kernelName:Va,backendName:"wasm",setupFunc:Ige,kernelFunc:Cge};var dq;function Sge(r){dq=r.wasm.cwrap(eu,"number",["number","number","number","number","number","bool"])}function kge(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,padToMaxOutputSize:i}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,m=e.dataIdMap.get(l.dataId).id,c=dq(p,m,s,o,a,i),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Xf(e,c);e.wasm._free(h);let b=e.makeOutput([f],"int32",d),T=e.makeOutput([],"int32",g);return[b,T]}var fq={kernelName:eu,backendName:"wasm",setupFunc:Sge,kernelFunc:kge};var hq;function vge(r){hq=r.wasm.cwrap(Ha,"number",["number","number","number","number","number","number"])}function Age(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,softNmsSigma:i}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,m=e.dataIdMap.get(l.dataId).id,c=hq(p,m,s,o,a,i),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Xf(e,c);e.wasm._free(g);let b=e.makeOutput([f],"int32",d),T=e.makeOutput([f],"float32",h);return[b,T]}var gq={kernelName:Ha,backendName:"wasm",setupFunc:vge,kernelFunc:Age};var wge=!1,bq=ht(Ka,wge,"bool");var yq;function Nge(r){yq=r.wasm.cwrap(Wo,null,["number","number","number","number","number"])}function Dge(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{dtype:s,depth:a,onValue:i,offValue:u}=n,l=t.makeOutput([...o.shape,a],s),p=t.dataIdMap.get(l.dataId).id,c=t.dataIdMap.get(o.dataId).id;return yq(c,a,i,u,p),l}var Tq={kernelName:Wo,backendName:"wasm",setupFunc:Nge,kernelFunc:Dge};function _ge(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(1),n}var xq={kernelName:As,backendName:"wasm",kernelFunc:_ge};function Mge(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return DS({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,a=e[0].dtype;e.forEach(p=>{y.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=e.map(p=>{let m=DS({inputs:{input:p},backend:t,attrs:{dim:o}});return i.push(m),m}),l=T0({inputs:u,backend:t,attrs:{axis:o}});return i.forEach(p=>t.disposeData(p.dataId)),l}var Iq={kernelName:ws,backendName:"wasm",kernelFunc:Mge};var Cq;function Rge(r){Cq=r.wasm.cwrap(Uo,null,["number","array","number","number","array","array","number","number"])}function Pge(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+e.shape[g]+h[1]);if(y.sizeFromShape(e.shape)===0)return x0({backend:t,attrs:{shape:s,value:o,dtype:e.dtype}});let a=t.dataIdMap.get(e.dataId).id,i=t.makeOutput(s,e.dtype),l=t.dataIdMap.get(i.dataId).id,p=new Uint8Array(new Int32Array(e.shape).buffer),m=n.map(h=>h[0]),c=n.map(h=>h[1]),d=new Uint8Array(new Int32Array(m).buffer),f=new Uint8Array(new Int32Array(c).buffer);return Cq(a,p,e.shape.length,Qe[e.dtype],d,f,o,l),i}var _S={kernelName:Uo,backendName:"wasm",kernelFunc:Pge,setupFunc:Rge};var Ege=!1,Sq=ht(Ko,Ege);var kq;function Fge(r){kq=r.wasm.cwrap(Vo,null,["number","number","number"])}function Lge(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,i=s,u=n,l=u;u.dtype!=="float32"&&(l=Ci({backend:t,inputs:{x:n},attrs:{dtype:"float32"}}),i=t.dataIdMap.get(l.dataId).id);let p=t.makeOutput(n.shape,"float32"),m=t.dataIdMap.get(p.dataId).id;return kq(i,a,m),u.dtype!=="float32"&&t.disposeData(l.dataId),p}var vq={kernelName:Vo,backendName:"wasm",setupFunc:Fge,kernelFunc:Lge};var Aq;function $ge(r){Aq=r.wasm.cwrap(Ho,null,["number","number","number","number"])}function Bge(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e),f=m;if(d){let x=e.dataIdMap.get(p.dataId).id;x!==i&&(l=p,u=x,f=C.getInnerMostAxes(f.length,l.shape.length))}C.assertAxesAreInnerMostDims("prod",f,l.shape.length);let[h,g]=C.computeOutAndReduceShapes(l.shape,f),b=y.sizeFromShape(g),T=e.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;Aq(u,b,Qe[T.dtype],x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var wq={kernelName:Ho,backendName:"wasm",setupFunc:$ge,kernelFunc:Bge};var Oge=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:a}=t,i=Kp(n,o,s,a),u=e.makeOutput([i.length],a);return e.typedArrayFromHeap(u).set(i),u},Nq={kernelName:wi,backendName:"wasm",kernelFunc:Oge};var zge=!0,Dq=ht(ko,zge);var _q=st(qo);var Mq=st(jo);var Rq=st(Zo);var Pq;function Gge(r){Pq=r.wasm.cwrap(Yo,null,["number","number","number","number","number","number","number","number","number","number"])}function Wge(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,[p,m,c,d]=o.shape,f=[p,u,l,d],h=e.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=Ci({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(g.dataId));let b=h.id,T=e.makeOutput(f,"float32");if(y.sizeFromShape(o.shape)===0)return T;let x=e.dataIdMap.get(T.dataId).id;return Pq(b,p,m,c,d,u,l,s?1:0,a?1:0,x),g!=null&&e.disposeData(g.dataId),T}var Eq={kernelName:Yo,backendName:"wasm",setupFunc:Gge,kernelFunc:Wge};var Fq;function Uge(r){Fq=r.wasm.cwrap(Xo,null,["number","number","number","number","number","number","number","number","number","number"])}function Kge(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,l]=i,[p,m,c,d]=o.shape,f=[p,u,l,d],h=e.makeOutput(f,"float32");if(y.sizeFromShape(o.shape)===0)return h;let g=e.dataIdMap.get(o.dataId),b;g.dtype!=="float32"&&(b=Ci({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),g=e.dataIdMap.get(b.dataId));let T=g.id,x=e.dataIdMap.get(h.dataId).id;return Fq(T,p,m,c,d,u,l,s?1:0,a?1:0,x),b!=null&&e.disposeData(b.dataId),h}var Lq={kernelName:Xo,backendName:"wasm",setupFunc:Uge,kernelFunc:Kge};var $q;function Vge(r){$q=r.wasm.cwrap(Qo,null,["number","array","number","array","number","number"])}function Hge(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,a=y.parseAxisParam(s,o.shape);if(o.shape.length===0)return dm({inputs:{x:o},backend:t});let i=t.makeOutput(o.shape,o.dtype),u=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(i.dataId).id,p=new Uint8Array(new Int32Array(a).buffer),m=new Uint8Array(new Int32Array(o.shape).buffer);$q(u,p,a.length,m,o.shape.length,l);let c=hr({inputs:{x:i},attrs:{shape:o.shape},backend:t});return t.disposeData(i.dataId),c}var Bq={kernelName:Qo,backendName:"wasm",kernelFunc:Hge,setupFunc:Vge};var Oq;function qge(r){Oq=r.wasm.cwrap(Ja,null,["number","number","number","number","number","number","number","number","array","number","number"])}function jge(r){let{inputs:e,backend:t,attrs:n}=r,{image:o}=e,{radians:s,fillValue:a,center:i}=n,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(u.dataId).id,[m,c,d,f]=o.shape,[h,g]=C.getImageCenter(i,c,d),b=a===0,T=255,x=typeof a=="number"?[a,a,a,b?0:T]:[...a,T],I=new Uint8Array(new Int32Array(x).buffer);return Oq(l,m,c,d,f,s,h,g,I,x.length,p),u}var zq={kernelName:Ja,backendName:"wasm",kernelFunc:jge,setupFunc:qge};var Gq=st(qa);var Wq=st(Jo);var Uq;function Xge(r){Uq=r.wasm.cwrap(ja,null,["number","number","number","number","number","number","array","number","number"])}function Yge(r){let{backend:e,inputs:t,attrs:n}=r,{indices:o,updates:s}=t,{shape:a}=n,i=e.makeOutput(a,s.dtype);if(y.sizeFromShape(a)===0)return i;let{sliceRank:u,numUpdates:l,sliceSize:p,strides:m,outputSize:c}=Ch.calculateShapes(s,o,a),f=e.dataIdMap.get(o.dataId).id,g=e.dataIdMap.get(s.dataId).id,b=new Uint8Array(new Int32Array(m).buffer),T=e.dataIdMap.get(i.dataId).id;return Uq(f,g,Qe[s.dtype],u,l,p,b,c,T),i}var Kq={kernelName:ja,backendName:"wasm",setupFunc:Xge,kernelFunc:Yge};var Vq;function Zge(r){Vq=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Qge(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,a=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=t.makeOutput(o.shape,o.dtype),p=t.dataIdMap.get(l.dataId).id,m=n.shape.length,c=o.shape.length,d=m===0||m>1||c===1?1:y.sizeFromShape(o.shape.slice(1));return Vq(a,i,u,d,p),l}var Hq={kernelName:Ds,backendName:"wasm",kernelFunc:Qge,setupFunc:Zge};var qq;function Jge(r){qq=r.wasm.cwrap(ts,null,["number","number"])}function ebe(r){let{backend:e,inputs:{x:t}}=r,n=e.dataIdMap.get(t.dataId).id,o=e.makeOutput(t.shape,t.dtype),s=e.dataIdMap.get(o.dataId).id;return y.sizeFromShape(o.shape)===0||qq(n,s),o}var jq={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Jge,kernelFunc:ebe};var Xq=st(es);var Yq;function tbe(r){Yq=r.wasm.cwrap(os,null,["number","number","number","number"])}function rbe(r){let{backend:e,inputs:{logits:t},attrs:{dim:n}}=r,o=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),a=e.dataIdMap.get(s.dataId).id,i=t.shape[n],u=y.sizeFromShape(t.shape)/i;return y.sizeFromShape(s.shape)===0||Yq(o,a,i,u),s}var Zq={kernelName:os,backendName:"wasm",setupFunc:tbe,kernelFunc:rbe};function nbe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:a}=n,i=y.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let w=1+s.length;w<o.shape.length;++w)u.push([0,0]);let l=_S.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=C.getReshaped(l.shape,s,i,!1),m=C.getPermuted(p.length,s.length,!1),c=C.getReshapedPermuted(l.shape,s,i,!1),h=hr({inputs:{x:l},backend:t,attrs:{shape:p}}),T=Ts({inputs:{x:h},backend:t,attrs:{perm:m}}),S=hr({inputs:{x:T},backend:t,attrs:{shape:c}});return t.disposeData(l.dataId),t.disposeData(h.dataId),t.disposeData(T.dataId),S}var Qq={kernelName:Ms,backendName:"wasm",kernelFunc:nbe};var Jq;function obe(r){Jq=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function sbe(r){let{backend:e,inputs:t}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=t,i=n.shape[0],u=n.shape[1],l=e.readSync(s.dataId)[0],p=[i+l,u],m=e.dataIdMap.get(n.dataId).id,c=e.dataIdMap.get(o.dataId).id,d=e.dataIdMap.get(a.dataId).id,f=e.makeOutput(p,n.dtype),h=e.dataIdMap.get(f.dataId).id,g=e.makeOutput(p.slice(0,1),o.dtype),b=e.dataIdMap.get(g.dataId).id,T=e.makeOutput([l],"bool"),x=e.dataIdMap.get(T.dataId).id,I=e.makeOutput([i],n.dtype),S=e.dataIdMap.get(I.dataId).id,w=e.makeOutput([4],"int32"),_=e.dataIdMap.get(w.dataId).id,M=Jq(m,c,Qe[o.dtype],i,l,u,d,h,b,x,S,_),R=e.readSync(w.dataId),E;switch(R[0]){case 1:{E=C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(R[1]);break}case 2:{E=C.getSparseFillEmptyRowsNegativeIndexErrorMessage(R[1],R[2]);break}case 3:E=C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(R[1],R[2],R[3]);break;default:E=""}if(e.disposeData(w.dataId),E)throw e.disposeData(f.dataId),e.disposeData(g.dataId),e.disposeData(T.dataId),e.disposeData(I.dataId),new Error(E);let O=f,G=g;return M!==p[0]&&(O=da({inputs:{x:f},attrs:{begin:0,size:[M,u]},backend:e}),G=da({inputs:{x:g},attrs:{begin:0,size:M},backend:e}),e.disposeData(f.dataId),e.disposeData(g.dataId)),[O,G,T,I]}var ej={kernelName:Ju,backendName:"wasm",setupFunc:obe,kernelFunc:sbe};var tj;function abe(r){tj=r.wasm.cwrap(ou,null,["number","number","number","number","number","number","number"])}function ibe(r){let{backend:e,inputs:t}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=n.shape[0],p=y.sizeFromShape(s.shape),m=e.makeOutput([l,p],n.dtype),c=e.dataIdMap.get(m.dataId).id,d=e.makeOutput([p],s.dtype),f=e.dataIdMap.get(d.dataId).id,h=e.makeOutput([3],"int32"),g=e.dataIdMap.get(h.dataId).id;tj(a,i,u,l,c,f,g);let b=e.readSync(h.dataId),T;switch(b[0]){case 0:{T=C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{T=C.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:T=C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(e.readSync(o.dataId)),I=Array.from(e.readSync(d.dataId));T=C.getSparseReshapeInputOutputMultipleErrorMessage(x,I);break}case 4:{let x=Array.from(e.readSync(o.dataId)),I=Array.from(e.readSync(d.dataId));T=C.getSparseReshapeInputOutputMismatchErrorMessage(x,I);break}default:T=""}if(e.disposeData(h.dataId),T)throw e.disposeData(m.dataId),e.disposeData(d.dataId),new Error(T);return[m,d]}var rj={kernelName:ou,backendName:"wasm",setupFunc:abe,kernelFunc:ibe};var nj;function MS(r){nj=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function RS(r,e){let{backend:t,inputs:n}=r,{data:o,indices:s,segmentIds:a}=n,i=s.shape[0],u=t.readSync(a.dataId,i-1,i)[0],p=i>0?u+1:0;if(p<0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=o.shape.slice();m[0]=p;let c=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(a.dataId).id,h=t.makeOutput(m,o.dtype),g=t.dataIdMap.get(h.dataId).id,b=t.makeOutput([4],"int32"),T=t.dataIdMap.get(b.dataId).id;nj(c,Qe[o.dtype],o.shape[0],d,f,g,T,e,0);let x=t.readSync(b.dataId),I;switch(x[0]){case 0:{I=C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{I=C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:I=C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1],x[2]);break;case 3:I=C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1],x[2],x[3]);break;default:I=""}if(t.disposeData(b.dataId),I)throw t.disposeData(h.dataId),new Error(I);return h}function ube(r){return RS(r,!0)}var oj={kernelName:el,backendName:"wasm",setupFunc:MS,kernelFunc:ube};function lbe(r){return RS(r,!1)}var sj={kernelName:tl,backendName:"wasm",setupFunc:MS,kernelFunc:lbe};function pbe(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:a}=t,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(m=>{let c=[...p];c[i]=m;let d=da({inputs:{x:o},attrs:{begin:l,size:c},backend:n});return l[i]+=m,d})}var aj={kernelName:Rs,backendName:"wasm",kernelFunc:pbe};var ij=st(rs);var uj=st(Ni);var mbe=!0,lj=ht(ss,mbe);var pj;function cbe(r){pj=r.wasm.cwrap(Fs,null,["number","number","number","number"])}function dbe(r){let{backend:e,inputs:t,attrs:n}=r,{alpha:o}=n,{x:s}=t,a=e.dataIdMap.get(s.dataId).id,i=e.makeOutput(s.shape,s.dtype),u=e.dataIdMap.get(i.dataId).id;return pj(a,o,Qe[s.dtype],u),i}var mj={kernelName:Fs,backendName:"wasm",setupFunc:cbe,kernelFunc:dbe};var cj;function fbe(r){cj=r.wasm.cwrap(Ya,null,["number","array","number","array","array","array","array","array","number","number"])}function hbe(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{begin:s,end:a,strides:i,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,l,p,m,c),S;if(h)S=hr({inputs:{x:o},backend:e,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),_=da({inputs:{x:o},backend:e,attrs:{begin:T,size:w}});S=hr({inputs:{x:_},backend:e,attrs:{shape:f}}),e.disposeData(_.dataId)}else{let w=e.makeOutput(d,"float32"),_=e.dataIdMap.get(o.dataId).id,M=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),R=new Uint8Array(new Int32Array(T).buffer),E=new Uint8Array(new Int32Array(x).buffer),O=new Uint8Array(new Int32Array(I).buffer),G=new Uint8Array(new Int32Array(d).buffer),W=new Uint8Array(new Int32Array(y.computeStrides(d)).buffer),H=e.dataIdMap.get(w.dataId).id;cj(_,M,o.shape.length,R,E,O,G,W,d.length,H),S=hr({inputs:{x:w},backend:e,attrs:{shape:f}}),e.disposeData(w.dataId)}return S}var dj={kernelName:Ya,backendName:"wasm",setupFunc:fbe,kernelFunc:hbe};function gbe(r){let{backend:e,inputs:t,attrs:n}=r,{data:o,dataSplits:s}=t,{separator:a,nGramWidths:i,leftPad:u,rightPad:l,padWidth:p,preserveShortSequences:m}=n,c=e.readSync(o.dataId),d=e.readSync(s.dataId),[f,h]=Hp(c,d,a,i,u,l,p,m),g=e.makeOutput([f.length],"string"),b=e.dataIdMap.get(g.dataId);b.stringBytes=f;let T=e.makeOutput(s.shape,"int32");return e.typedArrayFromHeap(T).set(h),[g,T]}var fj={kernelName:Di,backendName:"wasm",kernelFunc:gbe};function bbe(r){let{backend:e,inputs:t,attrs:n}=r,{input:o,delimiter:s}=t,{skipEmpty:a}=n,i=e.readSync(o.dataId),u=e.readSync(s.dataId),[l,p,m]=qp(i,u[0],a),c=p.length,d=e.makeOutput([c,2],"int32");e.typedArrayFromHeap(d).set(l);let h=e.makeOutput([c],"string"),g=e.dataIdMap.get(h.dataId);g.stringBytes=p;let b=e.makeOutput([2],"int32");return e.typedArrayFromHeap(b).set(m),[d,h,b]}var hj={kernelName:nl,backendName:"wasm",kernelFunc:bbe};function ybe(r){let{backend:e,inputs:t,attrs:n}=r,{input:o}=t,{numBuckets:s}=n,a=e.readSync(o.dataId),i=jp(a,s),u=e.makeOutput(o.shape,"int32");return e.typedArrayFromHeap(u).set(i),u}var gj={kernelName:ol,backendName:"wasm",kernelFunc:ybe};var Tbe=!0,bj=ht(as,Tbe);var yj;function xbe(r){yj=r.wasm.cwrap(ns,null,["number","number","number","number"])}function Ibe(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=t,i=e.dataIdMap.get(a.dataId).id,u=i,l=a,{transposed:p,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,e),f=m;if(d){let x=e.dataIdMap.get(p.dataId).id;x!==i&&(l=p,u=x,f=C.getInnerMostAxes(f.length,l.shape.length))}C.assertAxesAreInnerMostDims("sum",f,l.shape.length);let[h,g]=C.computeOutAndReduceShapes(l.shape,f),b=y.sizeFromShape(g),T=e.makeOutput(h,l.dtype);if(y.sizeFromShape(l.shape)!==0){let x=e.dataIdMap.get(T.dataId).id;yj(u,b,Qe[T.dtype],x)}if(d&&e.disposeData(p.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var Tj={kernelName:ns,backendName:"wasm",setupFunc:xbe,kernelFunc:Ibe};var xj=st(is);var Ij=st(us);var Cj;function Cbe(r){Cj=r.wasm.cwrap(Dn,null,["number","array","number","array","number","number"])}function Sbe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,s=t.dataIdMap.get(o.dataId).id,{reps:a}=n,i=new Array(o.shape.length);for(let c=0;c<i.length;c++)i[c]=o.shape[c]*a[c];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(i).buffer),p=t.makeOutput(i,o.dtype),m=t.dataIdMap.get(p.dataId).id;return Cj(s,u,o.shape.length,l,i.length,Qe[p.dtype],m),p}var Sj={kernelName:Dn,backendName:"wasm",setupFunc:Cbe,kernelFunc:Sbe};var kj;function kbe(r){kj=r.wasm.cwrap(Za,null,["number","array","number","number","number","bool","number","number"])}var vbe=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{k:o,sorted:s}=t,a=e.dataIdMap.get(n.dataId).id,i=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=e.makeOutput(u,n.dtype),p=e.dataIdMap.get(l.dataId).id,m=e.makeOutput(u,"int32"),c=e.dataIdMap.get(m.dataId).id;return kj(a,i,n.shape.length,Qe[n.dtype],o,s,p,c),[l,m]},vj={kernelName:Za,backendName:"wasm",setupFunc:kbe,kernelFunc:vbe};var Aj;function Abe(r){Aj=r.wasm.cwrap(Qa,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function wbe(r){let{backend:e,inputs:t,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:a,fillMode:i,fillValue:u,outputShape:l}=n,[p,m,c,d]=o.shape,[f,h]=l??[m,c],g=[p,f,h,d],b=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),T=new Uint8Array(new Int32Array(y.computeStrides(g)).buffer),x=e.makeOutput(g,o.dtype),I=e.dataIdMap.get(x.dataId).id,w=e.dataIdMap.get(o.dataId).id,M=e.dataIdMap.get(s.dataId).id,R=a==="nearest"?1:2,E;switch(i){case"constant":E=1;break;case"reflect":E=2;break;case"wrap":E=3;break;case"nearest":E=4;break;default:E=1;break}return Aj(w,M,s.shape[0]>1,p,f,h,d,c,m,b,o.shape.length-1,T,g.length-1,R,E,u,I),x}var wj={kernelName:Qa,backendName:"wasm",setupFunc:Abe,kernelFunc:wbe};function Nbe(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape[s],i=o.shape.length,u=new Array(i-1),l=0;for(let d=0;d<i;d++)d!==s&&(u[l++]=o.shape[d]);let p=new Array(a),m=new Array(i).fill(0),c=o.shape.slice();c[s]=1;for(let d=0;d<p.length;d++)m[s]=d,p[d]=da({inputs:{x:o},attrs:{begin:m,size:c},backend:t});return p.map(({dataId:d,dtype:f})=>({dataId:d,dtype:f,shape:u}))}var Nj={kernelName:Ps,backendName:"wasm",kernelFunc:Nbe};function Dbe(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(0),n}var Dj={kernelName:Es,backendName:"wasm",kernelFunc:Dbe};var _be=[_4,M4,R4,E4,O4,G4,U4,V4,j4,Y4,Z4,Q4,eH,tH,nH,sH,aH,iH,pH,cH,fH,gH,yH,TH,xH,IH,CH,SH,vH,AH,wH,DH,MH,PH,FH,$H,BH,OH,F4,zH,WH,UH,KH,VH,HH,qH,jH,XH,ZH,QH,eq,rq,oq,sq,uq,lq,pq,cq,fq,gq,bq,Tq,xq,Iq,_S,Sq,vq,wq,Nq,Dq,_q,Mq,Rq,H4,Eq,Lq,Bq,zq,Gq,Wq,Kq,Hq,jq,Xq,X4,Zq,Qq,ej,rj,oj,sj,aj,ij,uj,lj,mj,dj,fj,hj,gj,bj,Tj,xj,Ij,Sj,vj,wj,$4,Nj,Dj];for(let r of _be)su(r);var I0=$();I0.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]))}catch{return!1}});I0.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(I0.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var w0=Vl(Pj());var Ej=`var WasmBackendModuleThreadedSimd = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(WasmBackendModuleThreadedSimd) {
  WasmBackendModuleThreadedSimd = WasmBackendModuleThreadedSimd || {};

function GROWABLE_HEAP_I8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP8}function GROWABLE_HEAP_U8(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU8}function GROWABLE_HEAP_I16(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP16}function GROWABLE_HEAP_I32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAP32}function GROWABLE_HEAP_U32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPU32}function GROWABLE_HEAP_F32(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF32}function GROWABLE_HEAP_F64(){if(wasmMemory.buffer!=buffer){updateGlobalBufferAndViews(wasmMemory.buffer)}return HEAPF64}var Module=typeof WasmBackendModuleThreadedSimd!="undefined"?WasmBackendModuleThreadedSimd:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});var beforeListeners;if(typeof process!=="undefined"&&process.listeners){beforeListeners={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")}}var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var ENVIRONMENT_IS_PTHREAD=Module["ENVIRONMENT_IS_PTHREAD"]||false;var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err("exiting due to exception: "+toLog)}if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require("path").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}var fs,nodePath;if(typeof require==="function"){fs=require("fs");nodePath=require("path")}read_=(filename,binary)=>{filename=nodePath["normalize"](filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret};readAsync=(filename,onload,onerror)=>{filename=nodePath["normalize"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer)})};if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",function(reason){throw reason});quit_=(status,toThrow)=>{if(keepRuntimeAlive()){process["exitCode"]=status;throw toThrow}logExceptionOnExit(toThrow);process["exit"](status)};Module["inspect"]=function(){return"[Emscripten Module object]"};let nodeWorkerThreads;try{nodeWorkerThreads=require("worker_threads")}catch(e){console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?');throw e}global.Worker=nodeWorkerThreads.Worker}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}if(!ENVIRONMENT_IS_NODE){read_=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(ENVIRONMENT_IS_WORKER){readBinary=url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)}}readAsync=(url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()};xhr.onerror=onerror;xhr.send(null)}}setWindowTitle=title=>document.title=title}else{}if(ENVIRONMENT_IS_NODE){if(typeof performance=="undefined"){global.performance=require("perf_hooks").performance}}var defaultPrint=console.log.bind(console);var defaultPrintErr=console.warn.bind(console);if(ENVIRONMENT_IS_NODE){defaultPrint=str=>fs.writeSync(1,str+"
");defaultPrintErr=str=>fs.writeSync(2,str+"
")}var out=Module["print"]||defaultPrint;var err=Module["printErr"]||defaultPrintErr;Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var POINTER_SIZE=4;var Atomics_load=Atomics.load;var Atomics_store=Atomics.store;var Atomics_compareExchange=Atomics.compareExchange;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var wasmModule;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort(text)}}var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.buffer instanceof SharedArrayBuffer?heapOrArray.slice(idx,endPtr):heapOrArray.subarray(idx,endPtr))}var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(GROWABLE_HEAP_U8(),ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,GROWABLE_HEAP_U8(),outPtr,maxBytesToWrite)}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;if(ENVIRONMENT_IS_PTHREAD){buffer=Module["buffer"]}function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||16777216;if(ENVIRONMENT_IS_PTHREAD){wasmMemory=Module["wasmMemory"];buffer=Module["buffer"]}else{if(Module["wasmMemory"]){wasmMemory=Module["wasmMemory"]}else{wasmMemory=new WebAssembly.Memory({"initial":INITIAL_MEMORY/65536,"maximum":2147483648/65536,"shared":true});if(!(wasmMemory.buffer instanceof SharedArrayBuffer)){err("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag");if(ENVIRONMENT_IS_NODE){console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)")}throw Error("bad memory")}}}if(wasmMemory){buffer=wasmMemory.buffer}INITIAL_MEMORY=buffer.byteLength;updateGlobalBufferAndViews(buffer);var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(ENVIRONMENT_IS_PTHREAD)return;callRuntimeCallbacks(__ATINIT__)}function postRun(){if(ENVIRONMENT_IS_PTHREAD)return;if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}function abort(what){if(ENVIRONMENT_IS_PTHREAD){postMessage({"cmd":"onAbort","arg":what})}else{if(Module["onAbort"]){Module["onAbort"](what)}}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -sASSERTIONS for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="tfjs-backend-wasm-threaded-simd.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}throw"both async and sync fetching of the wasm failed"}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"env":asmLibraryArg,"wasi_snapshot_preview1":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;registerTLSInit(Module["asm"]["_emscripten_tls_init"]);wasmTable=Module["asm"]["__indirect_function_table"];addOnInit(Module["asm"]["__wasm_call_ctors"]);wasmModule=module;if(!ENVIRONMENT_IS_PTHREAD){var numWorkersToLoad=PThread.unusedWorkers.length;PThread.unusedWorkers.forEach(function(w){PThread.loadWasmModuleToWorker(w,function(){if(!--numWorkersToLoad)removeRunDependency("wasm-instantiate")})})}}if(!ENVIRONMENT_IS_PTHREAD){addRunDependency("wasm-instantiate")}function receiveInstantiationResult(result){receiveInstance(result["instance"],result["module"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&!ENVIRONMENT_IS_NODE&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);readyPromiseReject(e)}}instantiateAsync().catch(readyPromiseReject);return{}}var tempDouble;var tempI64;var ASM_CONSTS={};function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}function killThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];delete PThread.pthreads[pthread_ptr];worker.terminate();__emscripten_thread_free_data(pthread_ptr);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0}function cancelThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];worker.postMessage({"cmd":"cancel"})}function cleanupThread(pthread_ptr){var worker=PThread.pthreads[pthread_ptr];assert(worker);PThread.returnWorkerToPool(worker)}function spawnThread(threadParams){var worker=PThread.getNewWorker();if(!worker){return 6}PThread.runningWorkers.push(worker);PThread.pthreads[threadParams.pthread_ptr]=worker;worker.pthread_ptr=threadParams.pthread_ptr;var msg={"cmd":"run","start_routine":threadParams.startRoutine,"arg":threadParams.arg,"pthread_ptr":threadParams.pthread_ptr};worker.runPthread=()=>{msg.time=performance.now();worker.postMessage(msg,threadParams.transferList)};if(worker.loaded){worker.runPthread();delete worker.runPthread}return 0}var SYSCALLS={varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=GROWABLE_HEAP_I32()[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret}};function _proc_exit(code){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(1,1,code);EXITSTATUS=code;if(!keepRuntimeAlive()){PThread.terminateAllThreads();if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))}function exitJS(status,implicit){EXITSTATUS=status;if(!implicit){if(ENVIRONMENT_IS_PTHREAD){exitOnMainThread(status);throw"unwind"}else{}}_proc_exit(status)}var _exit=exitJS;function handleException(e){if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)}var PThread={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],pthreads:{},init:function(){if(ENVIRONMENT_IS_PTHREAD){PThread.initWorker()}else{PThread.initMainThread()}},initMainThread:function(){var pthreadPoolSize=8;while(pthreadPoolSize--){PThread.allocateUnusedWorker()}},initWorker:function(){noExitRuntime=false},setExitStatus:function(status){EXITSTATUS=status},terminateAllThreads:function(){for(var worker of Object.values(PThread.pthreads)){PThread.returnWorkerToPool(worker)}for(var worker of PThread.unusedWorkers){worker.terminate()}PThread.unusedWorkers=[]},returnWorkerToPool:function(worker){var pthread_ptr=worker.pthread_ptr;delete PThread.pthreads[pthread_ptr];PThread.unusedWorkers.push(worker);PThread.runningWorkers.splice(PThread.runningWorkers.indexOf(worker),1);worker.pthread_ptr=0;__emscripten_thread_free_data(pthread_ptr)},receiveObjectTransfer:function(data){},threadInitTLS:function(){PThread.tlsInitFunctions.forEach(f=>f())},loadWasmModuleToWorker:function(worker,onFinishedLoading){worker.onmessage=e=>{var d=e["data"];var cmd=d["cmd"];if(worker.pthread_ptr)PThread.currentProxiedOperationCallerThread=worker.pthread_ptr;if(d["targetThread"]&&d["targetThread"]!=_pthread_self()){var targetWorker=PThread.pthreads[d.targetThread];if(targetWorker){targetWorker.postMessage(d,d["transferList"])}else{err('Internal error! Worker sent a message "'+cmd+'" to target pthread '+d["targetThread"]+", but that thread no longer exists!")}PThread.currentProxiedOperationCallerThread=undefined;return}if(cmd==="processProxyingQueue"){executeNotifiedProxyingQueue(d["queue"])}else if(cmd==="spawnThread"){spawnThread(d)}else if(cmd==="cleanupThread"){cleanupThread(d["thread"])}else if(cmd==="killThread"){killThread(d["thread"])}else if(cmd==="cancelThread"){cancelThread(d["thread"])}else if(cmd==="loaded"){worker.loaded=true;if(onFinishedLoading)onFinishedLoading(worker);if(worker.runPthread){worker.runPthread();delete worker.runPthread}}else if(cmd==="print"){out("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="printErr"){err("Thread "+d["threadId"]+": "+d["text"])}else if(cmd==="alert"){alert("Thread "+d["threadId"]+": "+d["text"])}else if(d.target==="setimmediate"){worker.postMessage(d)}else if(cmd==="onAbort"){if(Module["onAbort"]){Module["onAbort"](d["arg"])}}else if(cmd){err("worker sent an unknown command "+cmd)}PThread.currentProxiedOperationCallerThread=undefined};worker.onerror=e=>{var message="worker sent an error!";err(message+" "+e.filename+":"+e.lineno+": "+e.message);throw e};if(ENVIRONMENT_IS_NODE){worker.on("message",function(data){worker.onmessage({data:data})});worker.on("error",function(e){worker.onerror(e)});worker.on("detachedExit",function(){})}worker.postMessage({"cmd":"load","urlOrBlob":Module["mainScriptUrlOrBlob"]||_scriptDir,"wasmMemory":wasmMemory,"wasmModule":wasmModule})},allocateUnusedWorker:function(){var pthreadMainJs=locateFile("tfjs-backend-wasm-threaded-simd.worker.js");PThread.unusedWorkers.push(new Worker(pthreadMainJs))},getNewWorker:function(){if(PThread.unusedWorkers.length==0){PThread.allocateUnusedWorker();PThread.loadWasmModuleToWorker(PThread.unusedWorkers[0])}return PThread.unusedWorkers.pop()}};Module["PThread"]=PThread;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){callbacks.shift()(Module)}}function withStackSave(f){var stack=stackSave();var ret=f();stackRestore(stack);return ret}function demangle(func){return func}function demangleAll(text){var regex=/\b_Z[wd_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function establishStackSpace(){var pthread_ptr=_pthread_self();var stackTop=GROWABLE_HEAP_I32()[pthread_ptr+44>>2];var stackSize=GROWABLE_HEAP_I32()[pthread_ptr+48>>2];var stackMax=stackTop-stackSize;_emscripten_stack_set_limits(stackTop,stackMax);stackRestore(stackTop)}Module["establishStackSpace"]=establishStackSpace;function exitOnMainThread(returnCode){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(2,0,returnCode);try{_exit(returnCode)}catch(e){handleException(e)}}var wasmTableMirror=[];function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func}function invokeEntryPoint(ptr,arg){var result=getWasmTableEntry(ptr)(arg);if(keepRuntimeAlive()){PThread.setExitStatus(result)}else{__emscripten_thread_exit(result)}}Module["invokeEntryPoint"]=invokeEntryPoint;function jsStackTrace(){var error=new Error;if(!error.stack){try{throw new Error}catch(e){error=e}if(!error.stack){return"(no stack trace available)"}}return error.stack.toString()}function registerTLSInit(tlsInitFunc){PThread.tlsInitFunctions.push(tlsInitFunc)}function writeArrayToMemory(array,buffer){GROWABLE_HEAP_I8().set(array,buffer)}function ___emscripten_init_main_thread_js(tb){__emscripten_thread_init(tb,!ENVIRONMENT_IS_WORKER,1,!ENVIRONMENT_IS_WEB);PThread.threadInitTLS()}function ___emscripten_thread_cleanup(thread){if(!ENVIRONMENT_IS_PTHREAD)cleanupThread(thread);else postMessage({"cmd":"cleanupThread","thread":thread})}function pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(3,1,pthread_ptr,attr,startRoutine,arg);return ___pthread_create_js(pthread_ptr,attr,startRoutine,arg)}function ___pthread_create_js(pthread_ptr,attr,startRoutine,arg){if(typeof SharedArrayBuffer=="undefined"){err("Current environment does not support SharedArrayBuffer, pthreads are not available!");return 6}var transferList=[];var error=0;if(ENVIRONMENT_IS_PTHREAD&&(transferList.length===0||error)){return pthreadCreateProxied(pthread_ptr,attr,startRoutine,arg)}if(error)return error;var threadParams={startRoutine:startRoutine,pthread_ptr:pthread_ptr,arg:arg,transferList:transferList};if(ENVIRONMENT_IS_PTHREAD){threadParams.cmd="spawnThread";postMessage(threadParams,transferList);return 0}return spawnThread(threadParams)}function __emscripten_default_pthread_stack_size(){return 2097152}var nowIsMonotonic=true;function __emscripten_get_now_is_monotonic(){return nowIsMonotonic}function executeNotifiedProxyingQueue(queue){Atomics.store(GROWABLE_HEAP_I32(),queue>>2,1);if(_pthread_self()){__emscripten_proxy_execute_task_queue(queue)}Atomics.compareExchange(GROWABLE_HEAP_I32(),queue>>2,1,0)}Module["executeNotifiedProxyingQueue"]=executeNotifiedProxyingQueue;function __emscripten_notify_task_queue(targetThreadId,currThreadId,mainThreadId,queue){if(targetThreadId==currThreadId){setTimeout(()=>executeNotifiedProxyingQueue(queue))}else if(ENVIRONMENT_IS_PTHREAD){postMessage({"targetThread":targetThreadId,"cmd":"processProxyingQueue","queue":queue})}else{var worker=PThread.pthreads[targetThreadId];if(!worker){return}worker.postMessage({"cmd":"processProxyingQueue","queue":queue})}return 1}function __emscripten_set_offscreencanvas_size(target,width,height){return-1}function _abort(){abort("")}function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;if(ENVIRONMENT_IS_NODE)text="warning: "+text;err(text)}}function _emscripten_check_blocking_allowed(){if(ENVIRONMENT_IS_NODE)return;if(ENVIRONMENT_IS_WORKER)return;warnOnce("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function _emscripten_date_now(){return Date.now()}function getHeapMax(){return 2147483648}function _emscripten_get_heap_max(){return getHeapMax()}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=()=>{var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6}}else if(ENVIRONMENT_IS_PTHREAD){_emscripten_get_now=()=>performance.now()-Module["__performance_now_clock_drift"]}else _emscripten_get_now=()=>performance.now();function _emscripten_memcpy_big(dest,src,num){GROWABLE_HEAP_U8().copyWithin(dest,src,src+num)}function _emscripten_num_logical_cores(){if(ENVIRONMENT_IS_NODE)return require("os").cpus().length;return navigator["hardwareConcurrency"]}function _emscripten_proxy_to_main_thread_js(index,sync){var numCallArgs=arguments.length-2;var outerArgs=arguments;return withStackSave(()=>{var serializedNumCallArgs=numCallArgs;var args=stackAlloc(serializedNumCallArgs*8);var b=args>>3;for(var i=0;i<numCallArgs;i++){var arg=outerArgs[2+i];GROWABLE_HEAP_F64()[b+i]=arg}return _emscripten_run_in_main_runtime_thread_js(index,serializedNumCallArgs,args,sync)})}var _emscripten_receive_on_main_thread_js_callArgs=[];function _emscripten_receive_on_main_thread_js(index,numCallArgs,args){_emscripten_receive_on_main_thread_js_callArgs.length=numCallArgs;var b=args>>3;for(var i=0;i<numCallArgs;i++){_emscripten_receive_on_main_thread_js_callArgs[i]=GROWABLE_HEAP_F64()[b+i]}var isEmAsmConst=index<0;var func=!isEmAsmConst?proxiedFunctionTable[index]:ASM_CONSTS[-index-1];return func.apply(null,_emscripten_receive_on_main_thread_js_callArgs)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=GROWABLE_HEAP_U8().length;requestedSize=requestedSize>>>0;if(requestedSize<=oldSize){return false}var maxHeapSize=getHeapMax();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _emscripten_unwind_to_js_event_loop(){throw"unwind"}function _fd_close(fd){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(4,1,fd);return 52}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(5,1,fd,offset_low,offset_high,whence,newOffset);return 70}var printCharBuffers=[null,[],[]];function printChar(stream,curr){var buffer=printCharBuffers[stream];if(curr===0||curr===10){(stream===1?out:err)(UTF8ArrayToString(buffer,0));buffer.length=0}else{buffer.push(curr)}}function _fd_write(fd,iov,iovcnt,pnum){if(ENVIRONMENT_IS_PTHREAD)return _emscripten_proxy_to_main_thread_js(6,1,fd,iov,iovcnt,pnum);var num=0;for(var i=0;i<iovcnt;i++){var ptr=GROWABLE_HEAP_U32()[iov>>2];var len=GROWABLE_HEAP_U32()[iov+4>>2];iov+=8;for(var j=0;j<len;j++){printChar(fd,GROWABLE_HEAP_U8()[ptr+j])}num+=len}GROWABLE_HEAP_U32()[pnum>>2]=num;return 0}function getCFunc(ident){var func=Module["_"+ident];return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":str=>{var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},"array":arr=>{var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string"){return UTF8ToString(ret)}if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret}function cwrap(ident,returnType,argTypes,opts){argTypes=argTypes||[];var numericArgs=argTypes.every(type=>type==="number"||type==="boolean");var numericRet=returnType!=="string";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return function(){return ccall(ident,returnType,argTypes,arguments,opts)}}PThread.init();var proxiedFunctionTable=[null,_proc_exit,exitOnMainThread,pthreadCreateProxied,_fd_close,_fd_seek,_fd_write];var asmLibraryArg={"__emscripten_init_main_thread_js":___emscripten_init_main_thread_js,"__emscripten_thread_cleanup":___emscripten_thread_cleanup,"__pthread_create_js":___pthread_create_js,"_emscripten_default_pthread_stack_size":__emscripten_default_pthread_stack_size,"_emscripten_get_now_is_monotonic":__emscripten_get_now_is_monotonic,"_emscripten_notify_task_queue":__emscripten_notify_task_queue,"_emscripten_set_offscreencanvas_size":__emscripten_set_offscreencanvas_size,"abort":_abort,"emscripten_check_blocking_allowed":_emscripten_check_blocking_allowed,"emscripten_date_now":_emscripten_date_now,"emscripten_get_heap_max":_emscripten_get_heap_max,"emscripten_get_now":_emscripten_get_now,"emscripten_memcpy_big":_emscripten_memcpy_big,"emscripten_num_logical_cores":_emscripten_num_logical_cores,"emscripten_receive_on_main_thread_js":_emscripten_receive_on_main_thread_js,"emscripten_resize_heap":_emscripten_resize_heap,"emscripten_unwind_to_js_event_loop":_emscripten_unwind_to_js_event_loop,"exit":_exit,"fd_close":_fd_close,"fd_seek":_fd_seek,"fd_write":_fd_write,"memory":wasmMemory||Module["wasmMemory"]};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["__wasm_call_ctors"]).apply(null,arguments)};var _init=Module["_init"]=function(){return(_init=Module["_init"]=Module["asm"]["init"]).apply(null,arguments)};var _init_with_threads_count=Module["_init_with_threads_count"]=function(){return(_init_with_threads_count=Module["_init_with_threads_count"]=Module["asm"]["init_with_threads_count"]).apply(null,arguments)};var _get_threads_count=Module["_get_threads_count"]=function(){return(_get_threads_count=Module["_get_threads_count"]=Module["asm"]["get_threads_count"]).apply(null,arguments)};var _register_tensor=Module["_register_tensor"]=function(){return(_register_tensor=Module["_register_tensor"]=Module["asm"]["register_tensor"]).apply(null,arguments)};var _dispose_data=Module["_dispose_data"]=function(){return(_dispose_data=Module["_dispose_data"]=Module["asm"]["dispose_data"]).apply(null,arguments)};var _dispose=Module["_dispose"]=function(){return(_dispose=Module["_dispose"]=Module["asm"]["dispose"]).apply(null,arguments)};var _Abs=Module["_Abs"]=function(){return(_Abs=Module["_Abs"]=Module["asm"]["Abs"]).apply(null,arguments)};var _Add=Module["_Add"]=function(){return(_Add=Module["_Add"]=Module["asm"]["Add"]).apply(null,arguments)};var _AddN=Module["_AddN"]=function(){return(_AddN=Module["_AddN"]=Module["asm"]["AddN"]).apply(null,arguments)};var _All=Module["_All"]=function(){return(_All=Module["_All"]=Module["asm"]["All"]).apply(null,arguments)};var _Any=Module["_Any"]=function(){return(_Any=Module["_Any"]=Module["asm"]["Any"]).apply(null,arguments)};var _ArgMax=Module["_ArgMax"]=function(){return(_ArgMax=Module["_ArgMax"]=Module["asm"]["ArgMax"]).apply(null,arguments)};var _AvgPool=Module["_AvgPool"]=function(){return(_AvgPool=Module["_AvgPool"]=Module["asm"]["AvgPool"]).apply(null,arguments)};var _BatchMatMul=Module["_BatchMatMul"]=function(){return(_BatchMatMul=Module["_BatchMatMul"]=Module["asm"]["BatchMatMul"]).apply(null,arguments)};var _Ceil=Module["_Ceil"]=function(){return(_Ceil=Module["_Ceil"]=Module["asm"]["Ceil"]).apply(null,arguments)};var _ClipByValue=Module["_ClipByValue"]=function(){return(_ClipByValue=Module["_ClipByValue"]=Module["asm"]["ClipByValue"]).apply(null,arguments)};var _Conv2D=Module["_Conv2D"]=function(){return(_Conv2D=Module["_Conv2D"]=Module["asm"]["Conv2D"]).apply(null,arguments)};var _Conv2DBackpropInput=Module["_Conv2DBackpropInput"]=function(){return(_Conv2DBackpropInput=Module["_Conv2DBackpropInput"]=Module["asm"]["Conv2DBackpropInput"]).apply(null,arguments)};var _Cos=Module["_Cos"]=function(){return(_Cos=Module["_Cos"]=Module["asm"]["Cos"]).apply(null,arguments)};var _Cosh=Module["_Cosh"]=function(){return(_Cosh=Module["_Cosh"]=Module["asm"]["Cosh"]).apply(null,arguments)};var _CropAndResize=Module["_CropAndResize"]=function(){return(_CropAndResize=Module["_CropAndResize"]=Module["asm"]["CropAndResize"]).apply(null,arguments)};var _Cumprod=Module["_Cumprod"]=function(){return(_Cumprod=Module["_Cumprod"]=Module["asm"]["Cumprod"]).apply(null,arguments)};var _Cumsum=Module["_Cumsum"]=function(){return(_Cumsum=Module["_Cumsum"]=Module["asm"]["Cumsum"]).apply(null,arguments)};var _DepthToSpace=Module["_DepthToSpace"]=function(){return(_DepthToSpace=Module["_DepthToSpace"]=Module["asm"]["DepthToSpace"]).apply(null,arguments)};var _DepthwiseConv2dNative=Module["_DepthwiseConv2dNative"]=function(){return(_DepthwiseConv2dNative=Module["_DepthwiseConv2dNative"]=Module["asm"]["DepthwiseConv2dNative"]).apply(null,arguments)};var _Elu=Module["_Elu"]=function(){return(_Elu=Module["_Elu"]=Module["asm"]["Elu"]).apply(null,arguments)};var _Equal=Module["_Equal"]=function(){return(_Equal=Module["_Equal"]=Module["asm"]["Equal"]).apply(null,arguments)};var _Exp=Module["_Exp"]=function(){return(_Exp=Module["_Exp"]=Module["asm"]["Exp"]).apply(null,arguments)};var _FlipLeftRight=Module["_FlipLeftRight"]=function(){return(_FlipLeftRight=Module["_FlipLeftRight"]=Module["asm"]["FlipLeftRight"]).apply(null,arguments)};var _Floor=Module["_Floor"]=function(){return(_Floor=Module["_Floor"]=Module["asm"]["Floor"]).apply(null,arguments)};var _FloorDiv=Module["_FloorDiv"]=function(){return(_FloorDiv=Module["_FloorDiv"]=Module["asm"]["FloorDiv"]).apply(null,arguments)};var _FusedBatchNorm=Module["_FusedBatchNorm"]=function(){return(_FusedBatchNorm=Module["_FusedBatchNorm"]=Module["asm"]["FusedBatchNorm"]).apply(null,arguments)};var _FusedConv2D=Module["_FusedConv2D"]=function(){return(_FusedConv2D=Module["_FusedConv2D"]=Module["asm"]["FusedConv2D"]).apply(null,arguments)};var _FusedDepthwiseConv2D=Module["_FusedDepthwiseConv2D"]=function(){return(_FusedDepthwiseConv2D=Module["_FusedDepthwiseConv2D"]=Module["asm"]["FusedDepthwiseConv2D"]).apply(null,arguments)};var _Gather=Module["_Gather"]=function(){return(_Gather=Module["_Gather"]=Module["asm"]["Gather"]).apply(null,arguments)};var _GatherNd=Module["_GatherNd"]=function(){return(_GatherNd=Module["_GatherNd"]=Module["asm"]["GatherNd"]).apply(null,arguments)};var _Greater=Module["_Greater"]=function(){return(_Greater=Module["_Greater"]=Module["asm"]["Greater"]).apply(null,arguments)};var _GreaterEqual=Module["_GreaterEqual"]=function(){return(_GreaterEqual=Module["_GreaterEqual"]=Module["asm"]["GreaterEqual"]).apply(null,arguments)};var _IsNan=Module["_IsNan"]=function(){return(_IsNan=Module["_IsNan"]=Module["asm"]["IsNan"]).apply(null,arguments)};var _LeakyRelu=Module["_LeakyRelu"]=function(){return(_LeakyRelu=Module["_LeakyRelu"]=Module["asm"]["LeakyRelu"]).apply(null,arguments)};var _Less=Module["_Less"]=function(){return(_Less=Module["_Less"]=Module["asm"]["Less"]).apply(null,arguments)};var _LessEqual=Module["_LessEqual"]=function(){return(_LessEqual=Module["_LessEqual"]=Module["asm"]["LessEqual"]).apply(null,arguments)};var _Log=Module["_Log"]=function(){return(_Log=Module["_Log"]=Module["asm"]["Log"]).apply(null,arguments)};var _LogicalAnd=Module["_LogicalAnd"]=function(){return(_LogicalAnd=Module["_LogicalAnd"]=Module["asm"]["LogicalAnd"]).apply(null,arguments)};var _LogicalNot=Module["_LogicalNot"]=function(){return(_LogicalNot=Module["_LogicalNot"]=Module["asm"]["LogicalNot"]).apply(null,arguments)};var _LogicalOr=Module["_LogicalOr"]=function(){return(_LogicalOr=Module["_LogicalOr"]=Module["asm"]["LogicalOr"]).apply(null,arguments)};var _LogicalXor=Module["_LogicalXor"]=function(){return(_LogicalXor=Module["_LogicalXor"]=Module["asm"]["LogicalXor"]).apply(null,arguments)};var _Max=Module["_Max"]=function(){return(_Max=Module["_Max"]=Module["asm"]["Max"]).apply(null,arguments)};var _MaxPool=Module["_MaxPool"]=function(){return(_MaxPool=Module["_MaxPool"]=Module["asm"]["MaxPool"]).apply(null,arguments)};var _Maximum=Module["_Maximum"]=function(){return(_Maximum=Module["_Maximum"]=Module["asm"]["Maximum"]).apply(null,arguments)};var _Mean=Module["_Mean"]=function(){return(_Mean=Module["_Mean"]=Module["asm"]["Mean"]).apply(null,arguments)};var _Min=Module["_Min"]=function(){return(_Min=Module["_Min"]=Module["asm"]["Min"]).apply(null,arguments)};var _Minimum=Module["_Minimum"]=function(){return(_Minimum=Module["_Minimum"]=Module["asm"]["Minimum"]).apply(null,arguments)};var _MirrorPad=Module["_MirrorPad"]=function(){return(_MirrorPad=Module["_MirrorPad"]=Module["asm"]["MirrorPad"]).apply(null,arguments)};var _Multiply=Module["_Multiply"]=function(){return(_Multiply=Module["_Multiply"]=Module["asm"]["Multiply"]).apply(null,arguments)};var _Neg=Module["_Neg"]=function(){return(_Neg=Module["_Neg"]=Module["asm"]["Neg"]).apply(null,arguments)};var _NonMaxSuppressionV3=Module["_NonMaxSuppressionV3"]=function(){return(_NonMaxSuppressionV3=Module["_NonMaxSuppressionV3"]=Module["asm"]["NonMaxSuppressionV3"]).apply(null,arguments)};var _NonMaxSuppressionV4=Module["_NonMaxSuppressionV4"]=function(){return(_NonMaxSuppressionV4=Module["_NonMaxSuppressionV4"]=Module["asm"]["NonMaxSuppressionV4"]).apply(null,arguments)};var _NonMaxSuppressionV5=Module["_NonMaxSuppressionV5"]=function(){return(_NonMaxSuppressionV5=Module["_NonMaxSuppressionV5"]=Module["asm"]["NonMaxSuppressionV5"]).apply(null,arguments)};var _NotEqual=Module["_NotEqual"]=function(){return(_NotEqual=Module["_NotEqual"]=Module["asm"]["NotEqual"]).apply(null,arguments)};var _OneHot=Module["_OneHot"]=function(){return(_OneHot=Module["_OneHot"]=Module["asm"]["OneHot"]).apply(null,arguments)};var _PadV2=Module["_PadV2"]=function(){return(_PadV2=Module["_PadV2"]=Module["asm"]["PadV2"]).apply(null,arguments)};var _Pow=Module["_Pow"]=function(){return(_Pow=Module["_Pow"]=Module["asm"]["Pow"]).apply(null,arguments)};var _Prelu=Module["_Prelu"]=function(){return(_Prelu=Module["_Prelu"]=Module["asm"]["Prelu"]).apply(null,arguments)};var _Prod=Module["_Prod"]=function(){return(_Prod=Module["_Prod"]=Module["asm"]["Prod"]).apply(null,arguments)};var _RealDiv=Module["_RealDiv"]=function(){return(_RealDiv=Module["_RealDiv"]=Module["asm"]["RealDiv"]).apply(null,arguments)};var _Reciprocal=Module["_Reciprocal"]=function(){return(_Reciprocal=Module["_Reciprocal"]=Module["asm"]["Reciprocal"]).apply(null,arguments)};var _Relu=Module["_Relu"]=function(){return(_Relu=Module["_Relu"]=Module["asm"]["Relu"]).apply(null,arguments)};var _Relu6=Module["_Relu6"]=function(){return(_Relu6=Module["_Relu6"]=Module["asm"]["Relu6"]).apply(null,arguments)};var _ResizeBilinear=Module["_ResizeBilinear"]=function(){return(_ResizeBilinear=Module["_ResizeBilinear"]=Module["asm"]["ResizeBilinear"]).apply(null,arguments)};var _ResizeNearestNeighbor=Module["_ResizeNearestNeighbor"]=function(){return(_ResizeNearestNeighbor=Module["_ResizeNearestNeighbor"]=Module["asm"]["ResizeNearestNeighbor"]).apply(null,arguments)};var _Reverse=Module["_Reverse"]=function(){return(_Reverse=Module["_Reverse"]=Module["asm"]["Reverse"]).apply(null,arguments)};var _RotateWithOffset=Module["_RotateWithOffset"]=function(){return(_RotateWithOffset=Module["_RotateWithOffset"]=Module["asm"]["RotateWithOffset"]).apply(null,arguments)};var _Round=Module["_Round"]=function(){return(_Round=Module["_Round"]=Module["asm"]["Round"]).apply(null,arguments)};var _Rsqrt=Module["_Rsqrt"]=function(){return(_Rsqrt=Module["_Rsqrt"]=Module["asm"]["Rsqrt"]).apply(null,arguments)};var _ScatterNd=Module["_ScatterNd"]=function(){return(_ScatterNd=Module["_ScatterNd"]=Module["asm"]["ScatterNd"]).apply(null,arguments)};var _SelectV2=Module["_SelectV2"]=function(){return(_SelectV2=Module["_SelectV2"]=Module["asm"]["SelectV2"]).apply(null,arguments)};var _Sigmoid=Module["_Sigmoid"]=function(){return(_Sigmoid=Module["_Sigmoid"]=Module["asm"]["Sigmoid"]).apply(null,arguments)};var _Sin=Module["_Sin"]=function(){return(_Sin=Module["_Sin"]=Module["asm"]["Sin"]).apply(null,arguments)};var _Softmax=Module["_Softmax"]=function(){return(_Softmax=Module["_Softmax"]=Module["asm"]["Softmax"]).apply(null,arguments)};var _SparseFillEmptyRows=Module["_SparseFillEmptyRows"]=function(){return(_SparseFillEmptyRows=Module["_SparseFillEmptyRows"]=Module["asm"]["SparseFillEmptyRows"]).apply(null,arguments)};var _SparseReshape=Module["_SparseReshape"]=function(){return(_SparseReshape=Module["_SparseReshape"]=Module["asm"]["SparseReshape"]).apply(null,arguments)};var _SparseSegmentReduction=Module["_SparseSegmentReduction"]=function(){return(_SparseSegmentReduction=Module["_SparseSegmentReduction"]=Module["asm"]["SparseSegmentReduction"]).apply(null,arguments)};var _Sqrt=Module["_Sqrt"]=function(){return(_Sqrt=Module["_Sqrt"]=Module["asm"]["Sqrt"]).apply(null,arguments)};var _Square=Module["_Square"]=function(){return(_Square=Module["_Square"]=Module["asm"]["Square"]).apply(null,arguments)};var _SquaredDifference=Module["_SquaredDifference"]=function(){return(_SquaredDifference=Module["_SquaredDifference"]=Module["asm"]["SquaredDifference"]).apply(null,arguments)};var _Step=Module["_Step"]=function(){return(_Step=Module["_Step"]=Module["asm"]["Step"]).apply(null,arguments)};var _StridedSlice=Module["_StridedSlice"]=function(){return(_StridedSlice=Module["_StridedSlice"]=Module["asm"]["StridedSlice"]).apply(null,arguments)};var _Sub=Module["_Sub"]=function(){return(_Sub=Module["_Sub"]=Module["asm"]["Sub"]).apply(null,arguments)};var _Sum=Module["_Sum"]=function(){return(_Sum=Module["_Sum"]=Module["asm"]["Sum"]).apply(null,arguments)};var _Tan=Module["_Tan"]=function(){return(_Tan=Module["_Tan"]=Module["asm"]["Tan"]).apply(null,arguments)};var _Tanh=Module["_Tanh"]=function(){return(_Tanh=Module["_Tanh"]=Module["asm"]["Tanh"]).apply(null,arguments)};var _Tile=Module["_Tile"]=function(){return(_Tile=Module["_Tile"]=Module["asm"]["Tile"]).apply(null,arguments)};var _TopK=Module["_TopK"]=function(){return(_TopK=Module["_TopK"]=Module["asm"]["TopK"]).apply(null,arguments)};var _Transform=Module["_Transform"]=function(){return(_Transform=Module["_Transform"]=Module["asm"]["Transform"]).apply(null,arguments)};var _Transpose=Module["_Transpose"]=function(){return(_Transpose=Module["_Transpose"]=Module["asm"]["Transpose"]).apply(null,arguments)};var __FusedMatMul=Module["__FusedMatMul"]=function(){return(__FusedMatMul=Module["__FusedMatMul"]=Module["asm"]["_FusedMatMul"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["malloc"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["free"]).apply(null,arguments)};var __emscripten_tls_init=Module["__emscripten_tls_init"]=function(){return(__emscripten_tls_init=Module["__emscripten_tls_init"]=Module["asm"]["_emscripten_tls_init"]).apply(null,arguments)};var _pthread_self=Module["_pthread_self"]=function(){return(_pthread_self=Module["_pthread_self"]=Module["asm"]["pthread_self"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["__errno_location"]).apply(null,arguments)};var __emscripten_thread_init=Module["__emscripten_thread_init"]=function(){return(__emscripten_thread_init=Module["__emscripten_thread_init"]=Module["asm"]["_emscripten_thread_init"]).apply(null,arguments)};var __emscripten_thread_crashed=Module["__emscripten_thread_crashed"]=function(){return(__emscripten_thread_crashed=Module["__emscripten_thread_crashed"]=Module["asm"]["_emscripten_thread_crashed"]).apply(null,arguments)};var _emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=function(){return(_emscripten_main_thread_process_queued_calls=Module["_emscripten_main_thread_process_queued_calls"]=Module["asm"]["emscripten_main_thread_process_queued_calls"]).apply(null,arguments)};var _emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=function(){return(_emscripten_main_browser_thread_id=Module["_emscripten_main_browser_thread_id"]=Module["asm"]["emscripten_main_browser_thread_id"]).apply(null,arguments)};var _emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=function(){return(_emscripten_run_in_main_runtime_thread_js=Module["_emscripten_run_in_main_runtime_thread_js"]=Module["asm"]["emscripten_run_in_main_runtime_thread_js"]).apply(null,arguments)};var _emscripten_dispatch_to_thread_=Module["_emscripten_dispatch_to_thread_"]=function(){return(_emscripten_dispatch_to_thread_=Module["_emscripten_dispatch_to_thread_"]=Module["asm"]["emscripten_dispatch_to_thread_"]).apply(null,arguments)};var __emscripten_proxy_execute_task_queue=Module["__emscripten_proxy_execute_task_queue"]=function(){return(__emscripten_proxy_execute_task_queue=Module["__emscripten_proxy_execute_task_queue"]=Module["asm"]["_emscripten_proxy_execute_task_queue"]).apply(null,arguments)};var __emscripten_thread_free_data=Module["__emscripten_thread_free_data"]=function(){return(__emscripten_thread_free_data=Module["__emscripten_thread_free_data"]=Module["asm"]["_emscripten_thread_free_data"]).apply(null,arguments)};var __emscripten_thread_exit=Module["__emscripten_thread_exit"]=function(){return(__emscripten_thread_exit=Module["__emscripten_thread_exit"]=Module["asm"]["_emscripten_thread_exit"]).apply(null,arguments)};var _emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=function(){return(_emscripten_stack_set_limits=Module["_emscripten_stack_set_limits"]=Module["asm"]["emscripten_stack_set_limits"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["stackSave"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["stackRestore"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["stackAlloc"]).apply(null,arguments)};var dynCall_iijjiiii=Module["dynCall_iijjiiii"]=function(){return(dynCall_iijjiiii=Module["dynCall_iijjiiii"]=Module["asm"]["dynCall_iijjiiii"]).apply(null,arguments)};var dynCall_jiji=Module["dynCall_jiji"]=function(){return(dynCall_jiji=Module["dynCall_jiji"]=Module["asm"]["dynCall_jiji"]).apply(null,arguments)};Module["keepRuntimeAlive"]=keepRuntimeAlive;Module["wasmMemory"]=wasmMemory;Module["cwrap"]=cwrap;Module["ExitStatus"]=ExitStatus;Module["PThread"]=PThread;var calledRun;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function run(args){args=args||arguments_;if(runDependencies>0){return}if(ENVIRONMENT_IS_PTHREAD){readyPromiseResolve(Module);initRuntime();postMessage({"cmd":"loaded"});return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}run();var listenersAdded;if(beforeListeners){listenersAdded={uncaughtException:process.listeners("uncaughtException").filter(function(listener){return!beforeListeners.uncaughtException.indexOf(listener)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(listener){return!beforeListeners.unhandledRejection.indexOf(listener)>-1})}}var actualModule;if(typeof WasmBackendModule!=="undefined"){actualModule=WasmBackendModule}else if(typeof WasmBackendModuleThreadedSimd!=="undefined"){actualModule=WasmBackendModuleThreadedSimd}else{throw new Error("Could not find wasm module in post.js")}if(listenersAdded){var tmpDispose=actualModule["_dispose"];actualModule["_dispose"]=function(){tmpDispose();listenersAdded.uncaughtException.forEach(function(listener){process.removeListener("uncaughtException",listener)});listenersAdded.unhandledRejection.forEach(function(listener){process.removeListener("unhandledRejection",listener)})}}


  return WasmBackendModuleThreadedSimd.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = WasmBackendModuleThreadedSimd;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return WasmBackendModuleThreadedSimd; });
else if (typeof exports === 'object')
  exports["WasmBackendModuleThreadedSimd"] = WasmBackendModuleThreadedSimd;`;var N0=Vl(Fj());var Lj=w0.default||w0,Mbe=N0.default||N0,Og=class extends po{constructor(t){super();this.wasm=t;this.wasm.tfjs.initWithThreadsCount(Oj),A0=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new ha(this,rn())}dataIdNextNumber=1;dataIdMap;write(t,n,o){let s={id:this.dataIdNextNumber++};return this.move(s,t,n,o,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(t){let n=y.now();return t(),{kernelMs:y.now()-n}}move(t,n,o,s,a){let i=this.dataIdNextNumber++;if(s==="string"){let m=n;this.dataIdMap.set(t,{id:i,stringBytes:m,shape:o,dtype:s,memoryOffset:null,refCount:a});return}let u=y.sizeFromShape(o),l=u*y.bytesPerElement(s),p=this.wasm._malloc(l);this.dataIdMap.set(t,{id:i,memoryOffset:p,shape:o,dtype:s,refCount:a}),this.wasm.tfjs.registerTensor(i,u,p),n!=null&&this.wasm.HEAPU8.set(new Uint8Array(n.buffer,n.byteOffset,l),p)}async read(t){return this.readSync(t)}readSync(t,n,o){let{memoryOffset:s,dtype:a,shape:i,stringBytes:u}=this.dataIdMap.get(t);if(a==="string")return(n==null||n===0)&&(o==null||o>=u.length)?u:u.slice(n,o);n=n||0,o=o||y.sizeFromShape(i);let l=y.bytesPerElement(a),p=this.wasm.HEAPU8.slice(s+n*l,s+o*l);return Pbe(p.buffer,a)}disposeData(t,n=!1){if(this.dataIdMap.has(t)){let o=this.dataIdMap.get(t);if(o.refCount--,!n&&o.refCount>0)return!1;this.wasm._free(o.memoryOffset),this.wasm.tfjs.disposeData(o.id),this.dataIdMap.delete(t)}return!0}refCount(t){return this.dataIdMap.has(t)?this.dataIdMap.get(t).refCount:0}incRef(t){let n=this.dataIdMap.get(t);n!=null&&n.refCount++}floatPrecision(){return 32}getMemoryOffset(t){return this.dataIdMap.get(t).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(t,n,o){let s;if(o==null)s=this.write(null,t,n);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:o,shape:t,dtype:n,refCount:1});let i=y.sizeFromShape(t);this.wasm.tfjs.registerTensor(a,i,o)}return{dataId:s,shape:t,dtype:n}}typedArrayFromHeap({shape:t,dtype:n,dataId:o}){let s=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(o),i=y.sizeFromShape(t);switch(n){case"float32":return new Float32Array(s,a,i);case"int32":return new Int32Array(s,a,i);case"bool":return new Uint8Array(s,a,i);default:throw new Error(`Unknown dtype ${n}`)}}};function Rbe(r){return(e,t)=>(y.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||e.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,e).then(s=>{t(s.instance,s.module)})})}),{})}function $j(r,e,t){if(FS!=null)return FS;let n="tfjs-backend-wasm.wasm";return r&&e?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),$g!=null&&$g[n]!=null?$g[n]:t+n}async function Bj(){let[r,e]=await Promise.all([$().getAsync("WASM_HAS_SIMD_SUPPORT"),$().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,n)=>{let o={};o.locateFile=(i,u)=>{if(i.endsWith(".worker.js")){let l=Ej.replace(/\n/g,"\\n"),p=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(p)}return i.endsWith(".wasm")?$j(r,e,Lg??u):u+i},D0&&(o.instantiateWasm=Rbe($j(r,e,Lg??"")));let s=!1;o.onAbort=()=>{if(s||Bg)return;Bg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;e&&r&&FS==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+Lj.toString()],{type:"text/javascript"}),a=Lj(o)):a=Mbe(o),a.then(i=>{s=!0,Bg=!1;let u=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",u,["number"]),dispose:i.cwrap("dispose",u,[])},t({wasm:i})}).catch(n)})}function Pbe(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}var Ebe=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],FS=null,Lg=null,$g={},Bg=!1,D0=!1;function Fbe(r,e=!1){if(nA("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Bg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");FS=r,D0=e}function Lbe(r,e=!1){if(Bg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")Lg=r;else{$g=r;let t=Ebe.filter(n=>$g[n]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}D0=e}var Oj=-1,A0=-1;function $be(r){Oj=r}function Bbe(){if(A0===-1)throw new Error("WASM backend not initialized.");return A0}var Obe="0.0.0";var zbe=2;ml("wasm",async()=>{let{wasm:r}=await Bj();return new Og(r)},zbe);var Wl="4.1.0-20221120",Dan={tfjs:Wl,"tfjs-core":Wl,"tfjs-data":Wl,"tfjs-layers":Wl,"tfjs-converter":Wl,"tfjs-backend-cpu":Wl,"tfjs-backend-webgl":Wl,"tfjs-backend-wasm":Wl};export{xs as Abs,ya as Acos,Ta as Acosh,Sl as AdadeltaOptimizer,kl as AdagradOptimizer,vl as AdamOptimizer,Al as AdamaxOptimizer,Nn as Add,co as AddN,xa as All,Ia as Any,fo as ArgMax,vi as ArgMin,Ca as Asin,Sa as Asinh,ka as Atan,Aa as Atan2,va as Atanh,ho as AvgPool,Bu as AvgPool3D,wm as AvgPool3DGrad,Am as AvgPoolGrad,Og as BackendWasm,go as BatchMatMul,Is as BatchToSpaceND,Ou as Bincount,Nm as BroadcastArgs,J0 as BroadcastTo,VT as Callback,nT as CallbackList,Un as Cast,bo as Ceil,Kn as ClipByValue,zu as Complex,Gu as ComplexAbs,Cs as Concat,yo as Conv2D,Dm as Conv2DBackpropFilter,To as Conv2DBackpropInput,Wu as Conv3D,_m as Conv3DBackpropFilterV2,Mm as Conv3DBackpropInputV2,xo as Cos,Io as Cosh,Na as CropAndResize,wa as Cumprod,Co as Cumsum,sT as CustomCallback,ha as DataStorage,Uu as DenseBincount,Da as DepthToSpace,So as DepthwiseConv2dNative,Rm as DepthwiseConv2dNativeBackpropFilter,Pm as DepthwiseConv2dNativeBackpropInput,Em as Diag,Ku as Dilation2D,lh as Dilation2DBackpropFilter,uh as Dilation2DBackpropInput,vv as ENV,HT as EarlyStopping,Vu as Einsum,vo as Elu,Fm as EluGrad,ah as Environment,Ma as Equal,_a as Erf,Ao as Exp,Ss as ExpandDims,Ra as Expm1,Hu as FFT,Ai as Fill,Pa as FlipLeftRight,wo as Floor,No as FloorDiv,jl as FromPixels,Do as FusedBatchNorm,$s as FusedConv2D,Bs as FusedDepthwiseConv2D,em as GPGPUContext,Ea as GatherNd,ks as GatherV2,Jh as GraphModel,Fa as Greater,_o as GreaterEqual,oT as History,qu as IFFT,Vn as Identity,ju as Imag,wt as InputSpec,La as IsFinite,$a as IsInf,Mo as IsNan,po as KernelBackend,Xu as LRN,$m as LRNGrad,Bh as LayerVariable,Qn as LayersModel,Ro as LeakyRelu,Ba as Less,Oa as LessEqual,Lm as LinSpace,Po as Log,za as Log1p,t_ as LogSoftmax,Ga as LogicalAnd,Wa as LogicalNot,Ji as LogicalOr,e_ as LogicalXor,Hbe as LowerBound,af as MathBackendCPU,Df as MathBackendWebGL,Eo as Max,Lo as MaxPool,Yu as MaxPool3D,Om as MaxPool3DGrad,Bm as MaxPoolGrad,zm as MaxPoolWithArgmax,Fo as Maximum,$o as Mean,Bo as Min,Oo as Minimum,zo as MirrorPad,Ua as Mod,wl as MomentumOptimizer,Gm as Multinomial,Go as Multiply,vs as Neg,Va as NonMaxSuppressionV3,eu as NonMaxSuppressionV4,Ha as NonMaxSuppressionV5,Ka as NotEqual,Gv as OP_SCOPE_SUFFIX,Wo as OneHot,As as OnesLike,Yr as Optimizer,oi as OptimizerConstructors,ws as Pack,Uo as PadV2,qbe as Pool,Ko as Pow,Vo as Prelu,Ho as Prod,Nl as RMSPropOptimizer,gs as RNN,Wm as RaggedGather,Um as RaggedRange,Km as RaggedTensorToTensor,wi as Range,A_ as Rank,Zu as Real,ko as RealDiv,qo as Reciprocal,ni as Reduction,jo as Relu,Zo as Relu6,Ns as Reshape,Yo as ResizeBilinear,Hm as ResizeBilinearGrad,Xo as ResizeNearestNeighbor,Vm as ResizeNearestNeighborGrad,Qo as Reverse,Ja as RotateWithOffset,qa as Round,Jo as Rsqrt,$i as SGDOptimizer,ja as ScatterNd,Qu as SearchSorted,Ds as Select,tu as Selu,Mp as Sequential,ts as Sigmoid,ru as Sign,es as Sin,Xa as Sinh,_s as Slice,os as Softmax,nu as Softplus,Ms as SpaceToBatchND,Ju as SparseFillEmptyRows,ou as SparseReshape,el as SparseSegmentMean,tl as SparseSegmentSum,rl as SparseToDense,Rs as SplitV,rs as Sqrt,Ni as Square,ss as SquaredDifference,Fs as Step,Ya as StridedSlice,Di as StringNGrams,nl as StringSplit,ol as StringToHashBucketFast,as as Sub,ns as Sum,ln as SymbolicTensor,is as Tan,us as Tanh,We as Tensor,bt as TensorBuffer,Dn as Tile,Za as TopK,Qa as Transform,_n as Transpose,qm as Unique,Ps as Unpack,sl as UnsortedSegmentSum,jbe as UpperBound,au as Variable,zf as WebGPUBackend,Es as ZerosLike,Ls as _FusedMatMul,Ot as abs,D1 as acos,_1 as acosh,Z as add,M1 as addN,Ub as all,vh as any,dl as argMax,R1 as argMin,P1 as asin,E1 as asinh,F1 as atan,L1 as atan2,$1 as atanh,ac as avgPool,Vb as avgPool3d,l1 as backend,C as backend_util,z1 as basicLSTMCell,hl as batchNorm,Hb as batchNorm2d,qb as batchNorm3d,jb as batchNorm4d,ic as batchToSpaceND,Xb as bincount,YZ as booleanMaskAsync,W1 as broadcastArgs,gl as broadcastTo,Dr as broadcast_util,Bb as browser,Ie as buffer,Fte as callbacks,re as cast,U1 as ceil,Hr as clipByValue,gn as clone,Mn as complex,ct as concat,Yb as concat1d,Zb as concat2d,Qb as concat3d,Jb as concat4d,xE as constraints,ey as conv1d,cs as conv2d,ty as conv2dTranspose,ry as conv3d,oy as conv3dTranspose,tye as copyRegisteredKernels,lc as cos,sy as cosh,Rh as cosineWindow,Ah as cumprod,ay as cumsum,bn as customGrad,tL as data,wh as denseBincount,nA as deprecationWarn,K1 as depthToSpace,bl as depthwiseConv2d,zte as deregisterOp,ul as device_util,V1 as diag,H1 as dilation2d,JIe as disableDeprecationWarnings,_e as dispose,eCe as disposeVariables,fe as div,q1 as divNoNan,j1 as dot,CA as dropout,X1 as einsum,yl as elu,QIe as enableDebugMode,ZIe as enableProdMode,SA as enclosingPowerOfTwo,rn as engine,$ as env,nn as equal,Y1 as erf,J1 as euclideanNorm,br as exp,yr as expandDims,e2 as expm1,ip as eye,Tc as fft,Vs as fill,aCe as findBackend,iCe as findBackendFactory,Tl as floor,Wb as floorDiv,zz as forceHalfFloat,Cl as fused,xl as gather,sQ as gatherND,Ob as gather_util,oCe as getBackend,Nv as getGradient,mh as getKernel,yb as getKernelsForBackend,Bbe as getThreadsCount,wD as gpgpu_util,cY as grad,dY as grads,Qt as greater,Xn as greaterEqual,dp as ifft,cl as imag,fs as image,uQ as inTopKAsync,IE as initializers,YA as input,Br as io,Ay as irfft,t2 as isFinite,r2 as isInf,n2 as isNaN,Et as keep,xr as kernel_impls,JE as layers,pc as leakyRelu,iy as less,qs as lessEqual,vA as linalg,o2 as linspace,Ere as loadGraphModel,Fre as loadGraphModelSync,zE as loadLayersModel,s2 as localResponseNormalization,jr as log,mc as log1p,a2 as logSigmoid,py as logSoftmax,my as logSumExp,sn as logicalAnd,cc as logicalNot,cy as logicalOr,i2 as logicalXor,u7 as losses,u2 as lowerBound,Ue as matMul,m1 as math,qr as max,dc as maxPool,fy as maxPool3d,l2 as maxPoolWithArgmax,ds as maximum,Lt as mean,Ih as memory,p2 as meshgrid,eF as metrics,sp as min,Il as minimum,m2 as mirrorPad,c2 as mod,B9 as model,tF as models,up as moments,QZ as movingAverage,P as mul,d2 as multiRNNCell,f2 as multinomial,tt as neg,Ph as nextFrame,ap as norm,du as notEqual,pl as oneHot,Tr as ones,zr as onesLike,A as op,h2 as outerProduct,Yn as pad,g2 as pad1d,b2 as pad2d,y2 as pad3d,T2 as pad4d,x2 as pool,jn as pow,hc as prelu,Rb as print,I2 as prod,tCe as profile,C2 as raggedGather,S2 as raggedRange,k2 as raggedTensorToTensor,v2 as rand,W2 as randomGamma,mp as randomNormal,U2 as randomStandardNormal,Ei as randomUniform,Fi as range,nCe as ready,mu as real,K2 as reciprocal,ml as registerBackend,z9 as registerCallbackConstructor,n_ as registerGradient,su as registerKernel,Ote as registerOp,rF as regularizers,an as relu,Ty as relu6,sCe as removeBackend,F as reshape,_r as reverse,V2 as reverse1d,H2 as reverse2d,q2 as reverse3d,j2 as reverse4d,xc as rfft,xy as round,Iy as rsqrt,ge as scalar,eQ as scatterND,Ch as scatter_util,Dh as searchSorted,Cy as selu,Sy as separableConv2d,O9 as sequential,Q as serialization,H8 as setBackend,uCe as setPlatform,$be as setThreadsCount,Fbe as setWasmPath,Lbe as setWasmPaths,GN as setWebGLContext,X2 as setdiff1dAsync,ff as shared,Pn as sigmoid,Y2 as sign,i7 as signal,ky as sin,vy as sinh,ze as slice,gc as slice1d,Mh as slice2d,bc as slice3d,cp as slice4d,It as slice_util,yc as softmax,cu as softplus,fc as spaceToBatchND,l7 as sparse,nQ as sparseToDense,a7 as spectral,Mr as split,Ft as sqrt,He as square,wy as squaredDifference,js as squeeze,cr as stack,Li as step,Z2 as stridedSlice,p7 as string,de as sub,be as sum,iu as sumOutType,Q2 as tan,fl as tanh,mr as tensor,Jt as tensor1d,ri as tensor2d,$b as tensor3d,J2 as tensor4d,eM as tensor5d,tM as tensor6d,Ws as tensor_util,N1 as test_util,z as tidy,on as tile,rCe as time,rM as topk,yp as train,Ge as transpose,Ic as truncatedNormal,nM as unique,eye as unregisterGradient,Jbe as unregisterKernel,Ny as unsortedSegmentSum,Rr as unstack,Pt as upcastType,oM as upperBound,y as util,fY as valueAndGrad,hY as valueAndGrads,Dy as variable,uy as variableGrads,Dan as version,$re as version_converter,C5 as version_core,bne as version_cpu,qh as version_layers,Obe as version_wasm,cie as version_webgl,n7t as webgl,xf as webgl_util,t0 as webgpu_util,zt as where,My as whereAsync,Ct as zeros,we as zerosLike};
//# sourceMappingURL=tfjs.min.esm.js.map
