var a6=Object.create;var vb=Object.defineProperty;var i6=Object.getOwnPropertyDescriptor;var u6=Object.getOwnPropertyNames;var p6=Object.getPrototypeOf,l6=Object.prototype.hasOwnProperty;var J0=(r=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(r,{get:(t,e)=>(typeof require!="undefined"?require:t)[e]}):r)(function(r){if(typeof require!="undefined")return require.apply(this,arguments);throw new Error('Dynamic require of "'+r+'" is not supported')});var m6=(r,t)=>()=>(r&&(t=r(r=0)),t);var Or=(r,t)=>()=>(t||r((t={exports:{}}).exports,t),t.exports),Xe=(r,t)=>{for(var e in t)vb(r,e,{get:t[e],enumerable:!0})},e1=(r,t,e,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of u6(t))!l6.call(r,o)&&o!==e&&vb(r,o,{get:()=>t[o],enumerable:!(n=i6(t,o))||n.enumerable});return r};var wm=(r,t,e)=>(e=r!=null?a6(p6(r)):{},e1(t||!r||!r.__esModule?vb(e,"default",{value:r,enumerable:!0}):e,r)),c6=r=>e1(vb({},"__esModule",{value:!0}),r);var y5={};var a2=m6(()=>{});var i2=Or(()=>{});var MF=Or((PF,hA)=>{(function(r,t,e){function n(i){var u=this,p=a();u.next=function(){var l=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=l-(u.c=l|0)},u.c=1,u.s0=p(" "),u.s1=p(" "),u.s2=p(" "),u.s0-=p(i),u.s0<0&&(u.s0+=1),u.s1-=p(i),u.s1<0&&(u.s1+=1),u.s2-=p(i),u.s2<0&&(u.s2+=1),p=null}function o(i,u){return u.c=i.c,u.s0=i.s0,u.s1=i.s1,u.s2=i.s2,u}function s(i,u){var p=new n(i),l=u&&u.state,m=p.next;return m.int32=function(){return p.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,l&&(typeof l=="object"&&o(l,p),m.state=function(){return o(p,{})}),m}function a(){var i=4022871197,u=function(p){p=String(p);for(var l=0;l<p.length;l++){i+=p.charCodeAt(l);var m=.02519603282416938*i;i=m>>>0,m-=i,m*=i,i=m>>>0,m-=i,i+=m*4294967296}return(i>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.alea=s})(PF,typeof hA=="object"&&hA,typeof define=="function"&&define)});var _F=Or((EF,gA)=>{(function(r,t,e){function n(a){var i=this,u="";i.x=0,i.y=0,i.z=0,i.w=0,i.next=function(){var l=i.x^i.x<<11;return i.x=i.y,i.y=i.z,i.z=i.w,i.w^=i.w>>>19^l^l>>>8},a===(a|0)?i.x=a:u+=a;for(var p=0;p<u.length+64;p++)i.x^=u.charCodeAt(p)|0,i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i}function s(a,i){var u=new n(a),p=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},l.int32=u.next,l.quick=l,p&&(typeof p=="object"&&o(p,u),l.state=function(){return o(u,{})}),l}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor128=s})(EF,typeof gA=="object"&&gA,typeof define=="function"&&define)});var $F=Or((LF,bA)=>{(function(r,t,e){function n(a){var i=this,u="";i.next=function(){var l=i.x^i.x>>>2;return i.x=i.y,i.y=i.z,i.z=i.w,i.w=i.v,(i.d=i.d+362437|0)+(i.v=i.v^i.v<<4^(l^l<<1))|0},i.x=0,i.y=0,i.z=0,i.w=0,i.v=0,a===(a|0)?i.x=a:u+=a;for(var p=0;p<u.length+64;p++)i.x^=u.charCodeAt(p)|0,p==u.length&&(i.d=i.x<<10^i.x>>>4),i.next()}function o(a,i){return i.x=a.x,i.y=a.y,i.z=a.z,i.w=a.w,i.v=a.v,i.d=a.d,i}function s(a,i){var u=new n(a),p=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},l.int32=u.next,l.quick=l,p&&(typeof p=="object"&&o(p,u),l.state=function(){return o(u,{})}),l}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorwow=s})(LF,typeof bA=="object"&&bA,typeof define=="function"&&define)});var OF=Or((BF,yA)=>{(function(r,t,e){function n(a){var i=this;i.next=function(){var p=i.x,l=i.i,m,c,d;return m=p[l],m^=m>>>7,c=m^m<<24,m=p[l+1&7],c^=m^m>>>10,m=p[l+3&7],c^=m^m>>>3,m=p[l+4&7],c^=m^m<<7,m=p[l+7&7],m=m^m<<13,c^=m^m<<9,p[l]=c,i.i=l+1&7,c};function u(p,l){var m,c,d=[];if(l===(l|0))c=d[0]=l;else for(l=""+l,m=0;m<l.length;++m)d[m&7]=d[m&7]<<15^l.charCodeAt(m)+d[m+1&7]<<13;for(;d.length<8;)d.push(0);for(m=0;m<8&&d[m]===0;++m);for(m==8?c=d[7]=-1:c=d[m],p.x=d,p.i=0,m=256;m>0;--m)p.next()}u(i,a)}function o(a,i){return i.x=a.x.slice(),i.i=a.i,i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),p=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},l.int32=u.next,l.quick=l,p&&(p.x&&o(p,u),l.state=function(){return o(u,{})}),l}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xorshift7=s})(BF,typeof yA=="object"&&yA,typeof define=="function"&&define)});var GF=Or((zF,TA)=>{(function(r,t,e){function n(a){var i=this;i.next=function(){var p=i.w,l=i.X,m=i.i,c,d;return i.w=p=p+1640531527|0,d=l[m+34&127],c=l[m=m+1&127],d^=d<<13,c^=c<<17,d^=d>>>15,c^=c>>>12,d=l[m]=d^c,i.i=m,d+(p^p>>>16)|0};function u(p,l){var m,c,d,f,h,g=[],b=128;for(l===(l|0)?(c=l,l=null):(l=l+"\0",c=0,b=Math.max(b,l.length)),d=0,f=-32;f<b;++f)l&&(c^=l.charCodeAt((f+32)%l.length)),f===0&&(h=c),c^=c<<10,c^=c>>>15,c^=c<<4,c^=c>>>13,f>=0&&(h=h+1640531527|0,m=g[f&127]^=c+h,d=m==0?d+1:0);for(d>=128&&(g[(l&&l.length||0)&127]=-1),d=127,f=4*128;f>0;--f)c=g[d+34&127],m=g[d=d+1&127],c^=c<<13,m^=m<<17,c^=c>>>15,m^=m>>>12,g[d]=c^m;p.w=h,p.X=g,p.i=d}u(i,a)}function o(a,i){return i.i=a.i,i.w=a.w,i.X=a.X.slice(),i}function s(a,i){a==null&&(a=+new Date);var u=new n(a),p=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},l.int32=u.next,l.quick=l,p&&(p.X&&o(p,u),l.state=function(){return o(u,{})}),l}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.xor4096=s})(zF,typeof TA=="object"&&TA,typeof define=="function"&&define)});var WF=Or((UF,xA)=>{(function(r,t,e){function n(a){var i=this,u="";i.next=function(){var l=i.b,m=i.c,c=i.d,d=i.a;return l=l<<25^l>>>7^m,m=m-c|0,c=c<<24^c>>>8^d,d=d-l|0,i.b=l=l<<20^l>>>12^m,i.c=m=m-c|0,i.d=c<<16^m>>>16^d,i.a=d-l|0},i.a=0,i.b=0,i.c=-1640531527,i.d=1367130551,a===Math.floor(a)?(i.a=a/4294967296|0,i.b=a|0):u+=a;for(var p=0;p<u.length+20;p++)i.b^=u.charCodeAt(p)|0,i.next()}function o(a,i){return i.a=a.a,i.b=a.b,i.c=a.c,i.d=a.d,i}function s(a,i){var u=new n(a),p=i&&i.state,l=function(){return(u.next()>>>0)/4294967296};return l.double=function(){do var m=u.next()>>>11,c=(u.next()>>>0)/4294967296,d=(m+c)/(1<<21);while(d===0);return d},l.int32=u.next,l.quick=l,p&&(typeof p=="object"&&o(p,u),l.state=function(){return o(u,{})}),l}t&&t.exports?t.exports=s:e&&e.amd?e(function(){return s}):this.tychei=s})(UF,typeof xA=="object"&&xA,typeof define=="function"&&define)});var KF=Or(()=>{});var HF=Or((VF,Sy)=>{(function(r,t,e){var n=256,o=6,s=52,a="random",i=e.pow(n,o),u=e.pow(2,s),p=u*2,l=n-1,m;function c(x,I,k){var w=[];I=I==!0?{entropy:!0}:I||{};var R=g(h(I.entropy?[x,T(t)]:x??b(),3),w),P=new d(w),M=function(){for(var L=P.g(o),z=i,W=0;L<u;)L=(L+W)*n,z*=n,W=P.g(1);for(;L>=p;)L/=2,z/=2,W>>>=1;return(L+W)/z};return M.int32=function(){return P.g(4)|0},M.quick=function(){return P.g(4)/4294967296},M.double=M,g(T(P.S),t),(I.pass||k||function(L,z,W,V){return V&&(V.S&&f(V,P),L.state=function(){return f(P,{})}),W?(e[a]=L,z):L})(M,R,"global"in I?I.global:this==e,I.state)}function d(x){var I,k=x.length,w=this,R=0,P=w.i=w.j=0,M=w.S=[];for(k||(x=[k++]);R<n;)M[R]=R++;for(R=0;R<n;R++)M[R]=M[P=l&P+x[R%k]+(I=M[R])],M[P]=I;(w.g=function(L){for(var z,W=0,V=w.i,j=w.j,H=w.S;L--;)z=H[V=l&V+1],W=W*n+H[l&(H[V]=H[j=l&j+z])+(H[j]=z)];return w.i=V,w.j=j,W})(n)}function f(x,I){return I.i=x.i,I.j=x.j,I.S=x.S.slice(),I}function h(x,I){var k=[],w=typeof x,R;if(I&&w=="object")for(R in x)try{k.push(h(x[R],I-1))}catch{}return k.length?k:w=="string"?x:x+"\0"}function g(x,I){for(var k=x+"",w,R=0;R<k.length;)I[l&R]=l&(w^=I[l&R]*19)+k.charCodeAt(R++);return T(I)}function b(){try{var x;return m&&(x=m.randomBytes)?x=x(n):(x=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(x)),T(x)}catch{var I=r.navigator,k=I&&I.plugins;return[+new Date,r,k,r.screen,T(t)]}}function T(x){return String.fromCharCode.apply(0,x)}if(g(e.random(),t),typeof Sy=="object"&&Sy.exports){Sy.exports=c;try{m=KF()}catch{}}else typeof define=="function"&&define.amd?define(function(){return c}):e["seed"+a]=c})(typeof self<"u"?self:VF,[],Math)});var _h=Or((i_e,qF)=>{var zY=MF(),GY=_F(),UY=$F(),WY=OF(),KY=GF(),VY=WF(),al=HF();al.alea=zY;al.xor128=GY;al.xorwow=UY;al.xorshift7=WY;al.xor4096=KY;al.tychei=VY;qF.exports=al});var Ew=Or(()=>{});var lg=Or(()=>{});var Gg=Or(()=>{});var x0=Or(()=>{});var nj=Or(()=>{});var oj=Or(()=>{});var sj=Or((Mk,C0)=>{"use strict";var I0=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(t){t=t||{};function e(){return Be.buffer!=Cr&&sa(Be.buffer),dm}function n(){return Be.buffer!=Cr&&sa(Be.buffer),fm}function o(){return Be.buffer!=Cr&&sa(Be.buffer),Qf}function s(){return Be.buffer!=Cr&&sa(Be.buffer),Hg}function a(){return Be.buffer!=Cr&&sa(Be.buffer),qg}function i(){return Be.buffer!=Cr&&sa(Be.buffer),jg}function u(){return Be.buffer!=Cr&&sa(Be.buffer),Xg}var p=typeof t<"u"?t:{},l,m;p.ready=new Promise(function(N,E){l=N,m=E});var c;typeof process<"u"&&process.listeners&&(c={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var d=Object.assign({},p),f=[],h="./this.program",g=(N,E)=>{throw E},b=typeof window=="object",T=typeof importScripts=="function",x=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",I=p.ENVIRONMENT_IS_PTHREAD||!1,k="";function w(N){return p.locateFile?p.locateFile(N,k):k+N}var R,P,M,L;function z(N){if(N instanceof ih)return;q("exiting due to exception: "+N)}var W,V,j;if(x){T?k=Gg().dirname(k)+"/":k=__dirname+"/",j=()=>{V||(W=lg(),V=Gg())},R=function(G,Y){return j(),G=V.normalize(G),W.readFileSync(G,Y?void 0:"utf8")},M=E=>{var G=R(E,!0);return G.buffer||(G=new Uint8Array(G)),G},P=(E,G,Y)=>{j(),E=V.normalize(E),W.readFile(E,function(be,ke){be?Y(be):G(ke.buffer)})},process.argv.length>1&&(h=process.argv[1].replace(/\\/g,"/")),f=process.argv.slice(2),process.on("uncaughtException",function(E){if(!(E instanceof ih))throw E}),process.on("unhandledRejection",function(E){throw E}),g=(E,G)=>{if(Gp())throw process.exitCode=E,G;z(G),process.exit(E)},p.inspect=function(){return"[Emscripten Module object]"};let N;try{N=x0()}catch(E){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),E}global.Worker=N.Worker}else(b||T)&&(T?k=self.location.href:typeof document<"u"&&document.currentScript&&(k=document.currentScript.src),r&&(k=r),k.indexOf("blob:")!==0?k=k.substr(0,k.replace(/[?#].*/,"").lastIndexOf("/")+1):k="",x||(R=N=>{var E=new XMLHttpRequest;return E.open("GET",N,!1),E.send(null),E.responseText},T&&(M=N=>{var E=new XMLHttpRequest;return E.open("GET",N,!1),E.responseType="arraybuffer",E.send(null),new Uint8Array(E.response)}),P=(N,E,G)=>{var Y=new XMLHttpRequest;Y.open("GET",N,!0),Y.responseType="arraybuffer",Y.onload=()=>{if(Y.status==200||Y.status==0&&Y.response){E(Y.response);return}G()},Y.onerror=G,Y.send(null)}),L=N=>document.title=N);x&&typeof performance>"u"&&(global.performance=nj().performance);var H=console.log.bind(console),X=console.warn.bind(console);x&&(j(),H=N=>W.writeSync(1,N+`
`),X=N=>W.writeSync(2,N+`
`));var ee=p.print||H,q=p.printErr||X;Object.assign(p,d),d=null,p.arguments&&(f=p.arguments),p.thisProgram&&(h=p.thisProgram),p.quit&&(g=p.quit);var ne=4;function se(N){se.shown||(se.shown={}),se.shown[N]||(se.shown[N]=1,q(N))}function ie(N,E){if(typeof WebAssembly.Function=="function"){for(var G={i:"i32",j:"i64",f:"f32",d:"f64"},Y={parameters:[],results:E[0]=="v"?[]:[G[E[0]]]},be=1;be<E.length;++be)Y.parameters.push(G[E[be]]);return new WebAssembly.Function(Y,N)}var ke=[1,0,1,96],De=E.slice(0,1),We=E.slice(1),lr={i:127,j:126,f:125,d:124};ke.push(We.length);for(var be=0;be<We.length;++be)ke.push(lr[We[be]]);De=="v"?ke.push(0):ke=ke.concat([1,lr[De]]),ke[1]=ke.length-2;var pa=new Uint8Array([0,97,115,109,1,0,0,0].concat(ke,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),la=new WebAssembly.Module(pa),Sb=new WebAssembly.Instance(la,{e:{f:N}}),uh=Sb.exports.f;return uh}var pe=[],ae;function ye(){if(pe.length)return pe.pop();try{to.grow(1)}catch(N){throw N instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":N}return to.length-1}function fe(N,E){for(var G=N;G<N+E;G++){var Y=Tm(G);Y&&ae.set(Y,G)}}var Ce=0,we=N=>{Ce=N},Ee=Atomics.load,$e=Atomics.store,Ze=Atomics.compareExchange,J;p.wasmBinary&&(J=p.wasmBinary);var gt=p.noExitRuntime||!0;typeof WebAssembly!="object"&&gm("no native wasm support detected");var Be,Lt,Pt=!1,mt;function er(N,E){N||gm(E)}function zt(N){var E=p["_"+N];return E}function on(N,E,G,Y,be){var ke={string:function(Gn){var Am=0;if(Gn!=null&&Gn!==0){var Q0=(Gn.length<<2)+1;Am=vm(Q0),zn(Gn,Am,Q0)}return Am},array:function(Gn){var Am=vm(Gn.length);return Fu(Gn,Am),Am}};function De(Gn){return E==="string"?Xr(Gn):E==="boolean"?Boolean(Gn):Gn}var We=zt(N),lr=[],pa=0;if(Y)for(var la=0;la<Y.length;la++){var Sb=ke[G[la]];Sb?(pa===0&&(pa=gv()),lr[la]=Sb(Y[la])):lr[la]=Y[la]}var uh=We.apply(null,lr);function s6(Gn){return pa!==0&&xb(pa),De(Gn)}return uh=s6(uh),uh}function qt(N,E,G,Y){G=G||[];var be=G.every(function(De){return De==="number"}),ke=E!=="string";return ke&&be&&!Y?zt(N):function(){return on(N,E,G,arguments,Y)}}var na=1;function Br(N){var E=new TextDecoder(N);this.decode=G=>(G.buffer instanceof SharedArrayBuffer&&(G=new Uint8Array(G)),E.decode.call(E,G))}var sn=typeof TextDecoder<"u"?new Br("utf8"):void 0;function an(N,E,G){for(var Y=E+G,be=E;N[be]&&!(be>=Y);)++be;if(be-E>16&&N.subarray&&sn)return sn.decode(N.subarray(E,be));for(var ke="";E<be;){var De=N[E++];if(!(De&128)){ke+=String.fromCharCode(De);continue}var We=N[E++]&63;if((De&224)==192){ke+=String.fromCharCode((De&31)<<6|We);continue}var lr=N[E++]&63;if((De&240)==224?De=(De&15)<<12|We<<6|lr:De=(De&7)<<18|We<<12|lr<<6|N[E++]&63,De<65536)ke+=String.fromCharCode(De);else{var pa=De-65536;ke+=String.fromCharCode(55296|pa>>10,56320|pa&1023)}}return ke}function Xr(N,E){return N?an(n(),N,E):""}function us(N,E,G,Y){if(!(Y>0))return 0;for(var be=G,ke=G+Y-1,De=0;De<N.length;++De){var We=N.charCodeAt(De);if(We>=55296&&We<=57343){var lr=N.charCodeAt(++De);We=65536+((We&1023)<<10)|lr&1023}if(We<=127){if(G>=ke)break;E[G++]=We}else if(We<=2047){if(G+1>=ke)break;E[G++]=192|We>>6,E[G++]=128|We&63}else if(We<=65535){if(G+2>=ke)break;E[G++]=224|We>>12,E[G++]=128|We>>6&63,E[G++]=128|We&63}else{if(G+3>=ke)break;E[G++]=240|We>>18,E[G++]=128|We>>12&63,E[G++]=128|We>>6&63,E[G++]=128|We&63}}return E[G]=0,G-be}function zn(N,E,G){return us(N,n(),E,G)}function oa(N){for(var E=0,G=0;G<N.length;++G){var Y=N.charCodeAt(G);Y>=55296&&Y<=57343&&(Y=65536+((Y&1023)<<10)|N.charCodeAt(++G)&1023),Y<=127?++E:Y<=2047?E+=2:Y<=65535?E+=3:E+=4}return E}var ps=typeof TextDecoder<"u"?new Br("utf-16le"):void 0;function Fu(N,E){e().set(N,E)}function Op(N,E,G){for(var Y=0;Y<N.length;++Y)e()[E++>>0]=N.charCodeAt(Y);G||(e()[E>>0]=0)}function cm(N,E){return N%E>0&&(N+=E-N%E),N}var Cr,dm,fm,Qf,Hg,qg,P0,jg,Xg;I&&(Cr=p.buffer);function sa(N){Cr=N,p.HEAP8=dm=new Int8Array(N),p.HEAP16=Qf=new Int16Array(N),p.HEAP32=qg=new Int32Array(N),p.HEAPU8=fm=new Uint8Array(N),p.HEAPU16=Hg=new Uint16Array(N),p.HEAPU32=P0=new Uint32Array(N),p.HEAPF32=jg=new Float32Array(N),p.HEAPF64=Xg=new Float64Array(N)}var Yg=p.INITIAL_MEMORY||16777216;if(I)Be=p.wasmMemory,Cr=p.buffer;else if(p.wasmMemory)Be=p.wasmMemory;else if(Be=new WebAssembly.Memory({initial:Yg/65536,maximum:32768,shared:!0}),!(Be.buffer instanceof SharedArrayBuffer))throw q("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),x&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");Be&&(Cr=Be.buffer),Yg=Cr.byteLength,sa(Cr);var to,hm=[],Ru=[],$k=[],Zg=[],zp=!1,Bk=!1,Qg=0;function Gp(){return gt||Qg>0}function un(){if(p.preRun)for(typeof p.preRun=="function"&&(p.preRun=[p.preRun]);p.preRun.length;)M0(p.preRun.shift());nb(hm)}function Jf(){zp=!0,!I&&nb(Ru)}function Ok(){I||(He.terminateAllThreads(),Bk=!0)}function zk(){if(!I){if(p.postRun)for(typeof p.postRun=="function"&&(p.postRun=[p.postRun]);p.postRun.length;)eh(p.postRun.shift());nb(Zg)}}function M0(N){hm.unshift(N)}function E0(N){Ru.unshift(N)}function eh(N){Zg.unshift(N)}var Pu=0,Jg=null,aa=null;function th(N){Pu++,p.monitorRunDependencies&&p.monitorRunDependencies(Pu)}function _0(N){if(Pu--,p.monitorRunDependencies&&p.monitorRunDependencies(Pu),Pu==0&&(Jg!==null&&(clearInterval(Jg),Jg=null),aa)){var E=aa;aa=null,E()}}p.preloadedImages={},p.preloadedAudios={};function gm(N){I?postMessage({cmd:"onAbort",arg:N}):p.onAbort&&p.onAbort(N),N="Aborted("+N+")",q(N),Pt=!0,mt=1,N+=". Build with -s ASSERTIONS=1 for more info.";var E=new WebAssembly.RuntimeError(N);throw m(E),E}var Gk="data:application/octet-stream;base64,";function eb(N){return N.startsWith(Gk)}function tb(N){return N.startsWith("file://")}var pn;pn="tfjs-backend-wasm-threaded-simd.wasm",eb(pn)||(pn=w(pn));function rb(N){try{if(N==pn&&J)return new Uint8Array(J);if(M)return M(N);throw"both async and sync fetching of the wasm failed"}catch(E){gm(E)}}function bm(){if(!J&&(b||T)){if(typeof fetch=="function"&&!tb(pn))return fetch(pn,{credentials:"same-origin"}).then(function(N){if(!N.ok)throw"failed to load wasm binary file at '"+pn+"'";return N.arrayBuffer()}).catch(function(){return rb(pn)});if(P)return new Promise(function(N,E){P(pn,function(G){N(new Uint8Array(G))},E)})}return Promise.resolve().then(function(){return rb(pn)})}function Uk(){var N={env:hb,wasi_snapshot_preview1:hb};function E(De,We){var lr=De.exports;if(p.asm=lr,Xk(p.asm.emscripten_tls_init),to=p.asm.__indirect_function_table,E0(p.asm.__wasm_call_ctors),Lt=We,!I){var pa=He.unusedWorkers.length;He.unusedWorkers.forEach(function(la){He.loadWasmModuleToWorker(la,function(){--pa||_0("wasm-instantiate")})})}}I||th("wasm-instantiate");function G(De){E(De.instance,De.module)}function Y(De){return bm().then(function(We){return WebAssembly.instantiate(We,N)}).then(function(We){return We}).then(De,function(We){q("failed to asynchronously prepare wasm: "+We),gm(We)})}function be(){return!J&&typeof WebAssembly.instantiateStreaming=="function"&&!eb(pn)&&!tb(pn)&&typeof fetch=="function"?fetch(pn,{credentials:"same-origin"}).then(function(De){var We=WebAssembly.instantiateStreaming(De,N);return We.then(G,function(lr){return q("wasm streaming compile failed: "+lr),q("falling back to ArrayBuffer instantiation"),Y(G)})}):Y(G)}if(p.instantiateWasm)try{var ke=p.instantiateWasm(N,E);return ke}catch(De){return q("Module.instantiateWasm callback failed with error: "+De),!1}return be().catch(m),{}}var L0,$0,Wk={};function nb(N){for(;N.length>0;){var E=N.shift();if(typeof E=="function"){E(p);continue}var G=E.func;typeof G=="number"?E.arg===void 0?Tm(G)():Tm(G)(E.arg):G(E.arg===void 0?null:E.arg)}}function ym(N){var E=gv(),G=N();return xb(E),G}function dj(N){return N}function B0(N){var E=/\b_Z[\w\d_]+/g;return N.replace(E,function(G){var Y=G;return G===Y?G:Y+" ["+G+"]"})}function Kk(N){a()[N>>2]=0;var E=He.pthreads[N];delete He.pthreads[N],E.worker.terminate(),hv(N),He.runningWorkers.splice(He.runningWorkers.indexOf(E.worker),1),E.worker.pthread=void 0}function Vk(N){var E=He.pthreads[N];E.worker.postMessage({cmd:"cancel"})}function ob(N){var E=He.pthreads[N];if(E){a()[N>>2]=0;var G=E.worker;He.returnWorkerToPool(G)}}function sb(N){r6(N)}function Hk(N){if(N instanceof ih||N=="unwind")return mt;g(1,N)}var He={unusedWorkers:[],runningWorkers:[],tlsInitFunctions:[],init:function(){I?He.initWorker():He.initMainThread()},initMainThread:function(){for(var N=8,E=0;E<N;++E)He.allocateUnusedWorker()},initWorker:function(){gt=!1},pthreads:{},setExitStatus:function(N){mt=N},terminateAllThreads:function(){for(var N in He.pthreads){var E=He.pthreads[N];E&&E.worker&&He.returnWorkerToPool(E.worker)}for(var G=0;G<He.unusedWorkers.length;++G){var Y=He.unusedWorkers[G];Y.terminate()}He.unusedWorkers=[]},returnWorkerToPool:function(N){He.runWithoutMainThreadQueuedCalls(function(){delete He.pthreads[N.pthread.threadInfoStruct],He.unusedWorkers.push(N),He.runningWorkers.splice(He.runningWorkers.indexOf(N),1),hv(N.pthread.threadInfoStruct),N.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(N){a()[Z0>>2]=0;try{N()}finally{a()[Z0>>2]=1}},receiveObjectTransfer:function(N){},threadInit:function(){for(var N in He.tlsInitFunctions)He.tlsInitFunctions[N]()},loadWasmModuleToWorker:function(N,E){N.onmessage=G=>{var Y=G.data,be=Y.cmd;if(N.pthread&&(He.currentProxiedOperationCallerThread=N.pthread.threadInfoStruct),Y.targetThread&&Y.targetThread!=Tb()){var ke=He.pthreads[Y.targetThread];ke?ke.worker.postMessage(Y,Y.transferList):q('Internal error! Worker sent a message "'+be+'" to target pthread '+Y.targetThread+", but that thread no longer exists!"),He.currentProxiedOperationCallerThread=void 0;return}be==="processQueuedMainThreadWork"?H0():be==="spawnThread"?ib(Y):be==="cleanupThread"?ob(Y.thread):be==="killThread"?Kk(Y.thread):be==="cancelThread"?Vk(Y.thread):be==="loaded"?(N.loaded=!0,E&&E(N),N.runPthread&&(N.runPthread(),delete N.runPthread)):be==="print"?ee("Thread "+Y.threadId+": "+Y.text):be==="printErr"?q("Thread "+Y.threadId+": "+Y.text):be==="alert"?alert("Thread "+Y.threadId+": "+Y.text):Y.target==="setimmediate"?N.postMessage(Y):be==="onAbort"?p.onAbort&&p.onAbort(Y.arg):q("worker sent an unknown command "+be),He.currentProxiedOperationCallerThread=void 0},N.onerror=G=>{var Y="worker sent an error!";throw q(Y+" "+G.filename+":"+G.lineno+": "+G.message),G},x&&(N.on("message",function(G){N.onmessage({data:G})}),N.on("error",function(G){N.onerror(G)}),N.on("detachedExit",function(){})),N.postMessage({cmd:"load",urlOrBlob:p.mainScriptUrlOrBlob||r,wasmMemory:Be,wasmModule:Lt})},allocateUnusedWorker:function(){var N=w("tfjs-backend-wasm-threaded-simd.worker.js");He.unusedWorkers.push(new Worker(N))},getNewWorker:function(){return He.unusedWorkers.length==0&&(He.allocateUnusedWorker(),He.loadWasmModuleToWorker(He.unusedWorkers[0])),He.unusedWorkers.pop()}};function qk(){var N=Tb(),E=a()[N+44>>2],G=a()[N+48>>2],Y=E-G;Y0(E,Y),xb(E)}p.establishStackSpace=qk;function ab(N){if(I)return Kp(1,0,N);try{sb(N)}catch(E){Hk(E)}}var Up=[];function Tm(N){var E=Up[N];return E||(N>=Up.length&&(Up.length=N+1),Up[N]=E=to.get(N)),E}function jk(N,E){return Tm(N)(E)}p.invokeEntryPoint=jk;function O0(){var N=new Error;if(!N.stack){try{throw new Error}catch(E){N=E}if(!N.stack)return"(no stack trace available)"}return N.stack.toString()}function Xk(N,E,G){He.tlsInitFunctions.push(N)}function z0(N,E){to.set(N,E),Up[N]=E}var Wp;x?Wp=()=>{var N=process.hrtime();return N[0]*1e3+N[1]/1e6}:I?Wp=()=>performance.now()-p.__performance_now_clock_drift:Wp=()=>performance.now();var Yk=!0;function Zk(N){return a()[V0()>>2]=N,N}function Qk(N,E){var G;if(N===0)G=Date.now();else if((N===1||N===4)&&Yk)G=Wp();else return Zk(28),-1;return a()[E>>2]=G/1e3|0,a()[E+4>>2]=G%1e3*1e3*1e3|0,0}function Jk(N,E){return Qk(N,E)}function eS(N){q0(N,!T,1,!b),He.threadInit()}function tS(N){I?postMessage({cmd:"cleanupThread",thread:N}):ob(N)}function ib(N){var E=He.getNewWorker();if(!E)return 6;He.runningWorkers.push(E);var G=He.pthreads[N.pthread_ptr]={worker:E,threadInfoStruct:N.pthread_ptr};E.pthread=G;var Y={cmd:"run",start_routine:N.startRoutine,arg:N.arg,threadInfoStruct:N.pthread_ptr};return E.runPthread=()=>{Y.time=performance.now(),E.postMessage(Y,N.transferList)},E.loaded&&(E.runPthread(),delete E.runPthread),0}function rS(N,E,G,Y){if(typeof SharedArrayBuffer>"u")return q("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var be=[],ke=0;if(I&&(be.length===0||ke))return j0(687865856,N,E,G,Y);if(ke)return ke;var De={startRoutine:G,pthread_ptr:N,arg:Y,transferList:be};return I?(De.cmd="spawnThread",postMessage(De,be),0):ib(De)}function nS(){return 2097152}function oS(N,E){if(N==E)postMessage({cmd:"processQueuedMainThreadWork"});else if(I)postMessage({targetThread:N,cmd:"processThreadQueue"});else{var G=He.pthreads[N],Y=G&&G.worker;if(!Y)return;Y.postMessage({cmd:"processThreadQueue"})}return 1}function sS(){gm("")}function aS(){x||T||se("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function ub(){return 2147483648}function iS(N,E,G){n().copyWithin(N,E,E+G)}function uS(){return x?oj().cpus().length:navigator.hardwareConcurrency}function Kp(N,E){var G=arguments.length-2,Y=arguments;return ym(function(){for(var be=G,ke=vm(be*8),De=ke>>3,We=0;We<G;We++){var lr=Y[2+We];u()[De+We]=lr}return X0(N,be,ke,E)})}var rh=[];function pS(N,E,G){rh.length=E;for(var Y=G>>3,be=0;be<E;be++)rh[be]=u()[Y+be];var ke=N<0,De=ke?Wk[-N-1]:NS[N];return De.apply(null,rh)}function lS(N){try{return Be.grow(N-Cr.byteLength+65535>>>16),sa(Be.buffer),1}catch{}}function mS(N){var E=n().length;if(N=N>>>0,N<=E)return!1;var G=ub();if(N>G)return!1;for(var Y=1;Y<=4;Y*=2){var be=E*(1+.2/Y);be=Math.min(be,N+100663296);var ke=Math.min(G,cm(Math.max(N,be),65536)),De=lS(ke);if(De)return!0}return!1}var at={inEventHandler:0,removeAllEventListeners:function(){for(var N=at.eventHandlers.length-1;N>=0;--N)at._removeHandler(N);at.eventHandlers=[],at.deferredCalls=[]},registerRemoveEventListeners:function(){at.removeEventListenersRegistered||($k.push(at.removeAllEventListeners),at.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(N,E,G){function Y(De,We){if(De.length!=We.length)return!1;for(var lr in De)if(De[lr]!=We[lr])return!1;return!0}for(var be in at.deferredCalls){var ke=at.deferredCalls[be];if(ke.targetFunction==N&&Y(ke.argsList,G))return}at.deferredCalls.push({targetFunction:N,precedence:E,argsList:G}),at.deferredCalls.sort(function(De,We){return De.precedence<We.precedence})},removeDeferredCalls:function(N){for(var E=0;E<at.deferredCalls.length;++E)at.deferredCalls[E].targetFunction==N&&(at.deferredCalls.splice(E,1),--E)},canPerformEventHandlerRequests:function(){return at.inEventHandler&&at.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!at.canPerformEventHandlerRequests())for(var N=0;N<at.deferredCalls.length;++N){var E=at.deferredCalls[N];at.deferredCalls.splice(N,1),--N,E.targetFunction.apply(null,E.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(N,E){for(var G=0;G<at.eventHandlers.length;++G)at.eventHandlers[G].target==N&&(!E||E==at.eventHandlers[G].eventTypeString)&&at._removeHandler(G--)},_removeHandler:function(N){var E=at.eventHandlers[N];E.target.removeEventListener(E.eventTypeString,E.eventListenerFunc,E.useCapture),at.eventHandlers.splice(N,1)},registerOrRemoveHandler:function(N){var E=function(be){++at.inEventHandler,at.currentEventHandler=N,at.runDeferredCalls(),N.handlerFunc(be),at.runDeferredCalls(),--at.inEventHandler};if(N.callbackfunc)N.eventListenerFunc=E,N.target.addEventListener(N.eventTypeString,E,N.useCapture),at.eventHandlers.push(N),at.registerRemoveEventListeners();else for(var G=0;G<at.eventHandlers.length;++G)at.eventHandlers[G].target==N.target&&at.eventHandlers[G].eventTypeString==N.eventTypeString&&at._removeHandler(G--)},queueEventHandlerOnThread_iiii:function(N,E,G,Y,be){ym(function(){var ke=vm(12);a()[ke>>2]=G,a()[ke+4>>2]=Y,a()[ke+8>>2]=be,fv(N,637534208,E,Y,ke)})},getTargetThreadForEventCallback:function(N){switch(N){case 1:return 0;case 2:return He.currentProxiedOperationCallerThread;default:return N}},getNodeNameForTarget:function(N){return N?N==window?"#window":N==screen?"#screen":N&&N.nodeName?N.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function cS(N){var E=oa(N)+1,G=dv(E);return zn(N,G,E),G}function dS(N,E,G,Y){ym(function(){var be=vm(12),ke=0;E&&(ke=cS(E)),a()[be>>2]=ke,a()[be+4>>2]=G,a()[be+8>>2]=Y,fv(N,657457152,0,ke,be)})}function fS(N,E,G,Y){E=E?Xr(E):"",dS(N,E,G,Y)}function hS(N){return N>2?Xr(N):N}var gS=[0,typeof document<"u"?document:0,typeof window<"u"?window:0];function bS(N){N=hS(N);var E=gS[N]||(typeof document<"u"?document.querySelector(N):void 0);return E}function nh(N){return bS(N)}function pb(N,E,G){var Y=nh(N);if(!Y)return-4;if(Y.canvasSharedPtr&&(a()[Y.canvasSharedPtr>>2]=E,a()[Y.canvasSharedPtr+4>>2]=G),Y.offscreenCanvas||!Y.controlTransferredOffscreen){Y.offscreenCanvas&&(Y=Y.offscreenCanvas);var be=!1;if(Y.GLctxObject&&Y.GLctxObject.GLctx){var ke=Y.GLctxObject.GLctx.getParameter(2978);be=ke[0]===0&&ke[1]===0&&ke[2]===Y.width&&ke[3]===Y.height}Y.width=E,Y.height=G,be&&Y.GLctxObject.GLctx.viewport(0,0,E,G)}else if(Y.canvasSharedPtr){var De=a()[Y.canvasSharedPtr+8>>2];return fS(De,N,E,G),1}else return-4;return 0}function lb(N,E,G){return I?Kp(2,1,N,E,G):pb(N,E,G)}function yS(N,E,G){var Y=nh(N);return Y?pb(N,E,G):lb(N,E,G)}function TS(){throw"unwind"}function xS(N){var E=N.getExtension("ANGLE_instanced_arrays");if(E)return N.vertexAttribDivisor=function(G,Y){E.vertexAttribDivisorANGLE(G,Y)},N.drawArraysInstanced=function(G,Y,be,ke){E.drawArraysInstancedANGLE(G,Y,be,ke)},N.drawElementsInstanced=function(G,Y,be,ke,De){E.drawElementsInstancedANGLE(G,Y,be,ke,De)},1}function IS(N){var E=N.getExtension("OES_vertex_array_object");if(E)return N.createVertexArray=function(){return E.createVertexArrayOES()},N.deleteVertexArray=function(G){E.deleteVertexArrayOES(G)},N.bindVertexArray=function(G){E.bindVertexArrayOES(G)},N.isVertexArray=function(G){return E.isVertexArrayOES(G)},1}function CS(N){var E=N.getExtension("WEBGL_draw_buffers");if(E)return N.drawBuffers=function(G,Y){E.drawBuffersWEBGL(G,Y)},1}function kS(N){return!!(N.multiDrawWebgl=N.getExtension("WEBGL_multi_draw"))}var pr={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},queries:[],stringCache:{},unpackAlignment:4,recordError:function(E){pr.lastError||(pr.lastError=E)},getNewId:function(N){for(var E=pr.counter++,G=N.length;G<E;G++)N[G]=null;return E},getSource:function(N,E,G,Y){for(var be="",ke=0;ke<E;++ke){var De=Y?a()[Y+ke*4>>2]:-1;be+=Xr(a()[G+ke*4>>2],De<0?void 0:De)}return be},createContext:function(N,E){N.getContextSafariWebGL2Fixed||(N.getContextSafariWebGL2Fixed=N.getContext,N.getContext=function(be,ke){var De=N.getContextSafariWebGL2Fixed(be,ke);return be=="webgl"==De instanceof WebGLRenderingContext?De:null});var G=N.getContext("webgl",E);if(!G)return 0;var Y=pr.registerContext(G,E);return Y},registerContext:function(N,E){var G=dv(8);a()[G+4>>2]=Tb();var Y={handle:G,attributes:E,version:E.majorVersion,GLctx:N};return N.canvas&&(N.canvas.GLctxObject=Y),pr.contexts[G]=Y,(typeof E.enableExtensionsByDefault>"u"||E.enableExtensionsByDefault)&&pr.initExtensions(Y),G},makeContextCurrent:function(N){return pr.currentContext=pr.contexts[N],p.ctx=fb=pr.currentContext&&pr.currentContext.GLctx,!(N&&!fb)},getContext:function(N){return pr.contexts[N]},deleteContext:function(N){pr.currentContext===pr.contexts[N]&&(pr.currentContext=null),typeof at=="object"&&at.removeAllHandlersOnTarget(pr.contexts[N].GLctx.canvas),pr.contexts[N]&&pr.contexts[N].GLctx.canvas&&(pr.contexts[N].GLctx.canvas.GLctxObject=void 0),K0(pr.contexts[N].handle),pr.contexts[N]=null},initExtensions:function(N){if(N||(N=pr.currentContext),!N.initExtensionsDone){N.initExtensionsDone=!0;var E=N.GLctx;xS(E),IS(E),CS(E),E.disjointTimerQueryExt=E.getExtension("EXT_disjoint_timer_query"),kS(E);var G=E.getSupportedExtensions()||[];G.forEach(function(Y){!Y.includes("lose_context")&&!Y.includes("debug")&&E.getExtension(Y)})}}},SS=["default","low-power","high-performance"];function vS(N,E){var G=E>>2,Y=a()[G+6],be={alpha:!!a()[G+0],depth:!!a()[G+1],stencil:!!a()[G+2],antialias:!!a()[G+3],premultipliedAlpha:!!a()[G+4],preserveDrawingBuffer:!!a()[G+5],powerPreference:SS[Y],failIfMajorPerformanceCaveat:!!a()[G+7],majorVersion:a()[G+8],minorVersion:a()[G+9],enableExtensionsByDefault:a()[G+10],explicitSwapControl:a()[G+11],proxyContextToMainThread:a()[G+12],renderViaOffscreenBackBuffer:a()[G+13]},ke=nh(N);if(!ke||be.explicitSwapControl)return 0;var De=pr.createContext(ke,be);return De}function AS(N,E){return vS(N,E)}var xm={mappings:{},buffers:[null,[],[]],printChar:function(N,E){var G=xm.buffers[N];E===0||E===10?((N===1?ee:q)(an(G,0)),G.length=0):G.push(E)},varargs:void 0,get:function(){xm.varargs+=4;var N=a()[xm.varargs-4>>2];return N},getStr:function(N){var E=Xr(N);return E},get64:function(N,E){return N}};function mb(N){return I?Kp(3,1,N):0}function cb(N,E,G,Y,be){if(I)return Kp(4,1,N,E,G,Y,be)}function db(N,E,G,Y){if(I)return Kp(5,1,N,E,G,Y);for(var be=0,ke=0;ke<G;ke++){var De=a()[E>>2],We=a()[E+4>>2];E+=8;for(var lr=0;lr<We;lr++)xm.printChar(N,n()[De+lr]);be+=We}return a()[Y>>2]=be,0}function wS(N){we(N)}He.init();var fb,NS=[null,ab,lb,mb,cb,db],G0=!1,hb={__clock_gettime:Jk,__emscripten_init_main_thread_js:eS,__emscripten_thread_cleanup:tS,__pthread_create_js:rS,_emscripten_default_pthread_stack_size:nS,_emscripten_notify_thread_queue:oS,abort:sS,emscripten_check_blocking_allowed:aS,emscripten_get_heap_max:ub,emscripten_get_now:Wp,emscripten_memcpy_big:iS,emscripten_num_logical_cores:uS,emscripten_receive_on_main_thread_js:pS,emscripten_resize_heap:mS,emscripten_set_canvas_element_size:yS,emscripten_unwind_to_js_event_loop:TS,emscripten_webgl_create_context:AS,exit:sb,fd_close:mb,fd_seek:cb,fd_write:db,memory:Be||p.wasmMemory,setTempRet0:wS},U0=Uk(),DS=p.___wasm_call_ctors=function(){return(DS=p.___wasm_call_ctors=p.asm.__wasm_call_ctors).apply(null,arguments)},FS=p._init=function(){return(FS=p._init=p.asm.init).apply(null,arguments)},RS=p._init_with_threads_count=function(){return(RS=p._init_with_threads_count=p.asm.init_with_threads_count).apply(null,arguments)},PS=p._get_threads_count=function(){return(PS=p._get_threads_count=p.asm.get_threads_count).apply(null,arguments)},MS=p._register_tensor=function(){return(MS=p._register_tensor=p.asm.register_tensor).apply(null,arguments)},ES=p._dispose_data=function(){return(ES=p._dispose_data=p.asm.dispose_data).apply(null,arguments)},_S=p._dispose=function(){return(_S=p._dispose=p.asm.dispose).apply(null,arguments)},LS=p._Abs=function(){return(LS=p._Abs=p.asm.Abs).apply(null,arguments)},$S=p._Add=function(){return($S=p._Add=p.asm.Add).apply(null,arguments)},BS=p._AddN=function(){return(BS=p._AddN=p.asm.AddN).apply(null,arguments)},OS=p._All=function(){return(OS=p._All=p.asm.All).apply(null,arguments)},zS=p._Any=function(){return(zS=p._Any=p.asm.Any).apply(null,arguments)},GS=p._ArgMax=function(){return(GS=p._ArgMax=p.asm.ArgMax).apply(null,arguments)},US=p._AvgPool=function(){return(US=p._AvgPool=p.asm.AvgPool).apply(null,arguments)},WS=p._BatchMatMul=function(){return(WS=p._BatchMatMul=p.asm.BatchMatMul).apply(null,arguments)},KS=p._Ceil=function(){return(KS=p._Ceil=p.asm.Ceil).apply(null,arguments)},VS=p._ClipByValue=function(){return(VS=p._ClipByValue=p.asm.ClipByValue).apply(null,arguments)},HS=p._Conv2D=function(){return(HS=p._Conv2D=p.asm.Conv2D).apply(null,arguments)},qS=p._Conv2DBackpropInput=function(){return(qS=p._Conv2DBackpropInput=p.asm.Conv2DBackpropInput).apply(null,arguments)},jS=p._Cos=function(){return(jS=p._Cos=p.asm.Cos).apply(null,arguments)},XS=p._Cosh=function(){return(XS=p._Cosh=p.asm.Cosh).apply(null,arguments)},YS=p._CropAndResize=function(){return(YS=p._CropAndResize=p.asm.CropAndResize).apply(null,arguments)},ZS=p._Cumprod=function(){return(ZS=p._Cumprod=p.asm.Cumprod).apply(null,arguments)},QS=p._Cumsum=function(){return(QS=p._Cumsum=p.asm.Cumsum).apply(null,arguments)},JS=p._DepthToSpace=function(){return(JS=p._DepthToSpace=p.asm.DepthToSpace).apply(null,arguments)},ev=p._DepthwiseConv2dNative=function(){return(ev=p._DepthwiseConv2dNative=p.asm.DepthwiseConv2dNative).apply(null,arguments)},tv=p._Elu=function(){return(tv=p._Elu=p.asm.Elu).apply(null,arguments)},rv=p._Equal=function(){return(rv=p._Equal=p.asm.Equal).apply(null,arguments)},nv=p._Exp=function(){return(nv=p._Exp=p.asm.Exp).apply(null,arguments)},ov=p._FlipLeftRight=function(){return(ov=p._FlipLeftRight=p.asm.FlipLeftRight).apply(null,arguments)},sv=p._Floor=function(){return(sv=p._Floor=p.asm.Floor).apply(null,arguments)},av=p._FloorDiv=function(){return(av=p._FloorDiv=p.asm.FloorDiv).apply(null,arguments)},iv=p._FusedBatchNorm=function(){return(iv=p._FusedBatchNorm=p.asm.FusedBatchNorm).apply(null,arguments)},uv=p._FusedConv2D=function(){return(uv=p._FusedConv2D=p.asm.FusedConv2D).apply(null,arguments)},gb=p._FusedDepthwiseConv2D=function(){return(gb=p._FusedDepthwiseConv2D=p.asm.FusedDepthwiseConv2D).apply(null,arguments)},bb=p._Gather=function(){return(bb=p._Gather=p.asm.Gather).apply(null,arguments)},oh=p._GatherNd=function(){return(oh=p._GatherNd=p.asm.GatherNd).apply(null,arguments)},pv=p._Greater=function(){return(pv=p._Greater=p.asm.Greater).apply(null,arguments)},lv=p._GreaterEqual=function(){return(lv=p._GreaterEqual=p.asm.GreaterEqual).apply(null,arguments)},Im=p._LeakyRelu=function(){return(Im=p._LeakyRelu=p.asm.LeakyRelu).apply(null,arguments)},sh=p._Less=function(){return(sh=p._Less=p.asm.Less).apply(null,arguments)},ah=p._LessEqual=function(){return(ah=p._LessEqual=p.asm.LessEqual).apply(null,arguments)},W0=p._Log=function(){return(W0=p._Log=p.asm.Log).apply(null,arguments)},Cm=p._LogicalAnd=function(){return(Cm=p._LogicalAnd=p.asm.LogicalAnd).apply(null,arguments)},km=p._LogicalNot=function(){return(km=p._LogicalNot=p.asm.LogicalNot).apply(null,arguments)},mv=p._LogicalOr=function(){return(mv=p._LogicalOr=p.asm.LogicalOr).apply(null,arguments)},K=p._LogicalXor=function(){return(K=p._LogicalXor=p.asm.LogicalXor).apply(null,arguments)},Q=p._Max=function(){return(Q=p._Max=p.asm.Max).apply(null,arguments)},Te=p._MaxPool=function(){return(Te=p._MaxPool=p.asm.MaxPool).apply(null,arguments)},_e=p._Maximum=function(){return(_e=p._Maximum=p.asm.Maximum).apply(null,arguments)},xt=p._Mean=function(){return(xt=p._Mean=p.asm.Mean).apply(null,arguments)},St=p._Min=function(){return(St=p._Min=p.asm.Min).apply(null,arguments)},it=p._Minimum=function(){return(it=p._Minimum=p.asm.Minimum).apply(null,arguments)},ot=p._MirrorPad=function(){return(ot=p._MirrorPad=p.asm.MirrorPad).apply(null,arguments)},kr=p._Multiply=function(){return(kr=p._Multiply=p.asm.Multiply).apply(null,arguments)},ia=p._Neg=function(){return(ia=p._Neg=p.asm.Neg).apply(null,arguments)},ua=p._NonMaxSuppressionV3=function(){return(ua=p._NonMaxSuppressionV3=p.asm.NonMaxSuppressionV3).apply(null,arguments)},Sm=p._NonMaxSuppressionV4=function(){return(Sm=p._NonMaxSuppressionV4=p.asm.NonMaxSuppressionV4).apply(null,arguments)},Vp=p._NonMaxSuppressionV5=function(){return(Vp=p._NonMaxSuppressionV5=p.asm.NonMaxSuppressionV5).apply(null,arguments)},cv=p._NotEqual=function(){return(cv=p._NotEqual=p.asm.NotEqual).apply(null,arguments)},ln=p._OneHot=function(){return(ln=p._OneHot=p.asm.OneHot).apply(null,arguments)},Mu=p._PadV2=function(){return(Mu=p._PadV2=p.asm.PadV2).apply(null,arguments)},yb=p._Pow=function(){return(yb=p._Pow=p.asm.Pow).apply(null,arguments)},fj=p._Prelu=function(){return(fj=p._Prelu=p.asm.Prelu).apply(null,arguments)},hj=p._Prod=function(){return(hj=p._Prod=p.asm.Prod).apply(null,arguments)},gj=p._RealDiv=function(){return(gj=p._RealDiv=p.asm.RealDiv).apply(null,arguments)},bj=p._Relu=function(){return(bj=p._Relu=p.asm.Relu).apply(null,arguments)},yj=p._Relu6=function(){return(yj=p._Relu6=p.asm.Relu6).apply(null,arguments)},Tj=p._ResizeBilinear=function(){return(Tj=p._ResizeBilinear=p.asm.ResizeBilinear).apply(null,arguments)},xj=p._ResizeNearestNeighbor=function(){return(xj=p._ResizeNearestNeighbor=p.asm.ResizeNearestNeighbor).apply(null,arguments)},Ij=p._Reverse=function(){return(Ij=p._Reverse=p.asm.Reverse).apply(null,arguments)},Cj=p._RotateWithOffset=function(){return(Cj=p._RotateWithOffset=p.asm.RotateWithOffset).apply(null,arguments)},kj=p._Round=function(){return(kj=p._Round=p.asm.Round).apply(null,arguments)},Sj=p._Rsqrt=function(){return(Sj=p._Rsqrt=p.asm.Rsqrt).apply(null,arguments)},vj=p._ScatterNd=function(){return(vj=p._ScatterNd=p.asm.ScatterNd).apply(null,arguments)},Aj=p._SelectV2=function(){return(Aj=p._SelectV2=p.asm.SelectV2).apply(null,arguments)},wj=p._Sigmoid=function(){return(wj=p._Sigmoid=p.asm.Sigmoid).apply(null,arguments)},Nj=p._Sin=function(){return(Nj=p._Sin=p.asm.Sin).apply(null,arguments)},Dj=p._Softmax=function(){return(Dj=p._Softmax=p.asm.Softmax).apply(null,arguments)},Fj=p._SparseFillEmptyRows=function(){return(Fj=p._SparseFillEmptyRows=p.asm.SparseFillEmptyRows).apply(null,arguments)},Rj=p._SparseReshape=function(){return(Rj=p._SparseReshape=p.asm.SparseReshape).apply(null,arguments)},Pj=p._SparseSegmentReduction=function(){return(Pj=p._SparseSegmentReduction=p.asm.SparseSegmentReduction).apply(null,arguments)},Mj=p._Sqrt=function(){return(Mj=p._Sqrt=p.asm.Sqrt).apply(null,arguments)},Ej=p._Square=function(){return(Ej=p._Square=p.asm.Square).apply(null,arguments)},_j=p._SquaredDifference=function(){return(_j=p._SquaredDifference=p.asm.SquaredDifference).apply(null,arguments)},Lj=p._Step=function(){return(Lj=p._Step=p.asm.Step).apply(null,arguments)},$j=p._StridedSlice=function(){return($j=p._StridedSlice=p.asm.StridedSlice).apply(null,arguments)},Bj=p._Sub=function(){return(Bj=p._Sub=p.asm.Sub).apply(null,arguments)},Oj=p._Sum=function(){return(Oj=p._Sum=p.asm.Sum).apply(null,arguments)},zj=p._Tan=function(){return(zj=p._Tan=p.asm.Tan).apply(null,arguments)},Gj=p._Tanh=function(){return(Gj=p._Tanh=p.asm.Tanh).apply(null,arguments)},Uj=p._Tile=function(){return(Uj=p._Tile=p.asm.Tile).apply(null,arguments)},Wj=p._TopK=function(){return(Wj=p._TopK=p.asm.TopK).apply(null,arguments)},Kj=p._Transform=function(){return(Kj=p._Transform=p.asm.Transform).apply(null,arguments)},Vj=p._Transpose=function(){return(Vj=p._Transpose=p.asm.Transpose).apply(null,arguments)},Hj=p.__FusedMatMul=function(){return(Hj=p.__FusedMatMul=p.asm._FusedMatMul).apply(null,arguments)},dv=p._malloc=function(){return(dv=p._malloc=p.asm.malloc).apply(null,arguments)},K0=p._free=function(){return(K0=p._free=p.asm.free).apply(null,arguments)},qj=p._emscripten_tls_init=function(){return(qj=p._emscripten_tls_init=p.asm.emscripten_tls_init).apply(null,arguments)},V0=p.___errno_location=function(){return(V0=p.___errno_location=p.asm.__errno_location).apply(null,arguments)},Tb=p._pthread_self=function(){return(Tb=p._pthread_self=p.asm.pthread_self).apply(null,arguments)},H0=p._emscripten_main_thread_process_queued_calls=function(){return(H0=p._emscripten_main_thread_process_queued_calls=p.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},jj=p.__emscripten_thread_crashed=function(){return(jj=p.__emscripten_thread_crashed=p.asm._emscripten_thread_crashed).apply(null,arguments)},q0=p.__emscripten_thread_init=function(){return(q0=p.__emscripten_thread_init=p.asm._emscripten_thread_init).apply(null,arguments)},Xj=p._emscripten_current_thread_process_queued_calls=function(){return(Xj=p._emscripten_current_thread_process_queued_calls=p.asm.emscripten_current_thread_process_queued_calls).apply(null,arguments)},Yj=p._emscripten_main_browser_thread_id=function(){return(Yj=p._emscripten_main_browser_thread_id=p.asm.emscripten_main_browser_thread_id).apply(null,arguments)},Zj=p._emscripten_sync_run_in_main_thread_2=function(){return(Zj=p._emscripten_sync_run_in_main_thread_2=p.asm.emscripten_sync_run_in_main_thread_2).apply(null,arguments)},j0=p._emscripten_sync_run_in_main_thread_4=function(){return(j0=p._emscripten_sync_run_in_main_thread_4=p.asm.emscripten_sync_run_in_main_thread_4).apply(null,arguments)},X0=p._emscripten_run_in_main_runtime_thread_js=function(){return(X0=p._emscripten_run_in_main_runtime_thread_js=p.asm.emscripten_run_in_main_runtime_thread_js).apply(null,arguments)},fv=p._emscripten_dispatch_to_thread_=function(){return(fv=p._emscripten_dispatch_to_thread_=p.asm.emscripten_dispatch_to_thread_).apply(null,arguments)},hv=p.__emscripten_thread_free_data=function(){return(hv=p.__emscripten_thread_free_data=p.asm._emscripten_thread_free_data).apply(null,arguments)},Qj=p.__emscripten_thread_exit=function(){return(Qj=p.__emscripten_thread_exit=p.asm._emscripten_thread_exit).apply(null,arguments)},Jj=p._memalign=function(){return(Jj=p._memalign=p.asm.memalign).apply(null,arguments)},Y0=p._emscripten_stack_set_limits=function(){return(Y0=p._emscripten_stack_set_limits=p.asm.emscripten_stack_set_limits).apply(null,arguments)},gv=p.stackSave=function(){return(gv=p.stackSave=p.asm.stackSave).apply(null,arguments)},xb=p.stackRestore=function(){return(xb=p.stackRestore=p.asm.stackRestore).apply(null,arguments)},vm=p.stackAlloc=function(){return(vm=p.stackAlloc=p.asm.stackAlloc).apply(null,arguments)},e6=p.dynCall_iijjiiii=function(){return(e6=p.dynCall_iijjiiii=p.asm.dynCall_iijjiiii).apply(null,arguments)},t6=p.dynCall_jiji=function(){return(t6=p.dynCall_jiji=p.asm.dynCall_jiji).apply(null,arguments)},Z0=p.__emscripten_allow_main_runtime_queued_calls=21664;p.cwrap=qt,p.keepRuntimeAlive=Gp,p.PThread=He,p.PThread=He,p.wasmMemory=Be,p.ExitStatus=ih;var Ib;function ih(N){this.name="ExitStatus",this.message="Program terminated with exit("+N+")",this.status=N}aa=function N(){Ib||bv(),Ib||(aa=N)};function bv(N){if(N=N||f,Pu>0)return;if(I){l(p),Jf(),postMessage({cmd:"loaded"});return}if(un(),Pu>0)return;function E(){Ib||(Ib=!0,p.calledRun=!0,!Pt&&(Jf(),l(p),p.onRuntimeInitialized&&p.onRuntimeInitialized(),zk()))}p.setStatus?(p.setStatus("Running..."),setTimeout(function(){setTimeout(function(){p.setStatus("")},1),E()},1)):E()}p.run=bv;function r6(N,E){if(mt=N,!E&&I)throw ab(N),"unwind";Gp()||Ok(),n6(N)}function n6(N){mt=N,Gp()||(He.terminateAllThreads(),p.onExit&&p.onExit(N),Pt=!0),g(N,new ih(N))}if(p.preInit)for(typeof p.preInit=="function"&&(p.preInit=[p.preInit]);p.preInit.length>0;)p.preInit.pop()();bv();var Cb;c&&(Cb={uncaughtException:process.listeners("uncaughtException").filter(function(N){return!c.uncaughtException.indexOf(N)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(N){return!c.unhandledRejection.indexOf(N)>-1})});var kb;if(typeof WasmBackendModule<"u")kb=WasmBackendModule;else if(typeof t<"u")kb=t;else throw new Error("Could not find wasm module in post.js");if(Cb){var o6=kb._dispose;kb._dispose=function(){o6(),Cb.uncaughtException.forEach(function(N){process.removeListener("uncaughtException",N)}),Cb.unhandledRejection.forEach(function(N){process.removeListener("unhandledRejection",N)})}}return t.ready}})();typeof Mk=="object"&&typeof C0=="object"?C0.exports=I0:typeof define=="function"&&define.amd?define([],function(){return I0}):typeof Mk=="object"&&(Mk.WasmBackendModuleThreadedSimd=I0)});var ij=Or((_k,w0)=>{"use strict";var A0=(()=>{var r=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename<"u"&&(r=r||__filename),function(t){t=t||{};var e=typeof t<"u"?t:{},n,o;e.ready=new Promise(function(K,Q){n=K,o=Q});var s;typeof process<"u"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var a=Object.assign({},e),i=[],u="./this.program",p=(K,Q)=>{throw Q},l=typeof window=="object",m=typeof importScripts=="function",c=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",d="";function f(K){return e.locateFile?e.locateFile(K,d):d+K}var h,g,b,T;function x(K){if(K instanceof sh)return;P("exiting due to exception: "+K)}var I,k,w;c?(m?d=Gg().dirname(d)+"/":d=__dirname+"/",w=()=>{k||(I=lg(),k=Gg())},h=function(Q,Te){return w(),Q=k.normalize(Q),I.readFileSync(Q,Te?void 0:"utf8")},b=K=>{var Q=h(K,!0);return Q.buffer||(Q=new Uint8Array(Q)),Q},g=(K,Q,Te)=>{w(),K=k.normalize(K),I.readFile(K,function(_e,xt){_e?Te(_e):Q(xt.buffer)})},process.argv.length>1&&(u=process.argv[1].replace(/\\/g,"/")),i=process.argv.slice(2),process.on("uncaughtException",function(K){if(!(K instanceof sh))throw K}),process.on("unhandledRejection",function(K){throw K}),p=(K,Q)=>{if(Qf())throw process.exitCode=K,Q;x(Q),process.exit(K)},e.inspect=function(){return"[Emscripten Module object]"}):(l||m)&&(m?d=self.location.href:typeof document<"u"&&document.currentScript&&(d=document.currentScript.src),r&&(d=r),d.indexOf("blob:")!==0?d=d.substr(0,d.replace(/[?#].*/,"").lastIndexOf("/")+1):d="",h=K=>{var Q=new XMLHttpRequest;return Q.open("GET",K,!1),Q.send(null),Q.responseText},m&&(b=K=>{var Q=new XMLHttpRequest;return Q.open("GET",K,!1),Q.responseType="arraybuffer",Q.send(null),new Uint8Array(Q.response)}),g=(K,Q,Te)=>{var _e=new XMLHttpRequest;_e.open("GET",K,!0),_e.responseType="arraybuffer",_e.onload=()=>{if(_e.status==200||_e.status==0&&_e.response){Q(_e.response);return}Te()},_e.onerror=Te,_e.send(null)},T=K=>document.title=K);var R=e.print||console.log.bind(console),P=e.printErr||console.warn.bind(console);Object.assign(e,a),a=null,e.arguments&&(i=e.arguments),e.thisProgram&&(u=e.thisProgram),e.quit&&(p=e.quit);var M=4;function L(K){L.shown||(L.shown={}),L.shown[K]||(L.shown[K]=1,P(K))}function z(K,Q){if(typeof WebAssembly.Function=="function"){for(var Te={i:"i32",j:"i64",f:"f32",d:"f64"},_e={parameters:[],results:Q[0]=="v"?[]:[Te[Q[0]]]},xt=1;xt<Q.length;++xt)_e.parameters.push(Te[Q[xt]]);return new WebAssembly.Function(_e,K)}var St=[1,0,1,96],it=Q.slice(0,1),ot=Q.slice(1),kr={i:127,j:126,f:125,d:124};St.push(ot.length);for(var xt=0;xt<ot.length;++xt)St.push(kr[ot[xt]]);it=="v"?St.push(0):St=St.concat([1,kr[it]]),St[1]=St.length-2;var ia=new Uint8Array([0,97,115,109,1,0,0,0].concat(St,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0])),ua=new WebAssembly.Module(ia),Sm=new WebAssembly.Instance(ua,{e:{f:K}}),Vp=Sm.exports.f;return Vp}var W=[],V;function j(){if(W.length)return W.pop();try{ps.grow(1)}catch(K){throw K instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":K}return ps.length-1}function H(K,Q){for(var Te=K;Te<K+Q;Te++){var _e=th(Te);_e&&V.set(_e,Te)}}var X=0,ee=K=>{X=K},q;e.wasmBinary&&(q=e.wasmBinary);var ne=e.noExitRuntime||!0;typeof WebAssembly!="object"&&zp("no native wasm support detected");var se,ie=!1,pe;function ae(K,Q){K||zp(Q)}function ye(K){var Q=e["_"+K];return Q}function fe(K,Q,Te,_e,xt){var St={string:function(ln){var Mu=0;if(ln!=null&&ln!==0){var yb=(ln.length<<2)+1;Mu=oh(yb),gt(ln,Mu,yb)}return Mu},array:function(ln){var Mu=oh(ln.length);return Pt(ln,Mu),Mu}};function it(ln){return Q==="string"?Ze(ln):Q==="boolean"?Boolean(ln):ln}var ot=ye(K),kr=[],ia=0;if(_e)for(var ua=0;ua<_e.length;ua++){var Sm=St[Te[ua]];Sm?(ia===0&&(ia=gb()),kr[ua]=Sm(_e[ua])):kr[ua]=_e[ua]}var Vp=ot.apply(null,kr);function cv(ln){return ia!==0&&bb(ia),it(ln)}return Vp=cv(Vp),Vp}function Ce(K,Q,Te,_e){Te=Te||[];var xt=Te.every(function(it){return it==="number"}),St=Q!=="string";return St&&xt&&!_e?ye(K):function(){return fe(K,Q,Te,arguments,_e)}}var we=1,Ee=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0;function $e(K,Q,Te){for(var _e=Q+Te,xt=Q;K[xt]&&!(xt>=_e);)++xt;if(xt-Q>16&&K.subarray&&Ee)return Ee.decode(K.subarray(Q,xt));for(var St="";Q<xt;){var it=K[Q++];if(!(it&128)){St+=String.fromCharCode(it);continue}var ot=K[Q++]&63;if((it&224)==192){St+=String.fromCharCode((it&31)<<6|ot);continue}var kr=K[Q++]&63;if((it&240)==224?it=(it&15)<<12|ot<<6|kr:it=(it&7)<<18|ot<<12|kr<<6|K[Q++]&63,it<65536)St+=String.fromCharCode(it);else{var ia=it-65536;St+=String.fromCharCode(55296|ia>>10,56320|ia&1023)}}return St}function Ze(K,Q){return K?$e(qt,K,Q):""}function J(K,Q,Te,_e){if(!(_e>0))return 0;for(var xt=Te,St=Te+_e-1,it=0;it<K.length;++it){var ot=K.charCodeAt(it);if(ot>=55296&&ot<=57343){var kr=K.charCodeAt(++it);ot=65536+((ot&1023)<<10)|kr&1023}if(ot<=127){if(Te>=St)break;Q[Te++]=ot}else if(ot<=2047){if(Te+1>=St)break;Q[Te++]=192|ot>>6,Q[Te++]=128|ot&63}else if(ot<=65535){if(Te+2>=St)break;Q[Te++]=224|ot>>12,Q[Te++]=128|ot>>6&63,Q[Te++]=128|ot&63}else{if(Te+3>=St)break;Q[Te++]=240|ot>>18,Q[Te++]=128|ot>>12&63,Q[Te++]=128|ot>>6&63,Q[Te++]=128|ot&63}}return Q[Te]=0,Te-xt}function gt(K,Q,Te){return J(K,qt,Q,Te)}function Be(K){for(var Q=0,Te=0;Te<K.length;++Te){var _e=K.charCodeAt(Te);_e>=55296&&_e<=57343&&(_e=65536+((_e&1023)<<10)|K.charCodeAt(++Te)&1023),_e<=127?++Q:_e<=2047?Q+=2:_e<=65535?Q+=3:Q+=4}return Q}var Lt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0;function Pt(K,Q){on.set(K,Q)}function mt(K,Q,Te){for(var _e=0;_e<K.length;++_e)on[Q++>>0]=K.charCodeAt(_e);Te||(on[Q>>0]=0)}function er(K,Q){return K%Q>0&&(K+=Q-K%Q),K}var zt,on,qt,na,Br,sn,an,Xr,us;function zn(K){zt=K,e.HEAP8=on=new Int8Array(K),e.HEAP16=na=new Int16Array(K),e.HEAP32=sn=new Int32Array(K),e.HEAPU8=qt=new Uint8Array(K),e.HEAPU16=Br=new Uint16Array(K),e.HEAPU32=an=new Uint32Array(K),e.HEAPF32=Xr=new Float32Array(K),e.HEAPF64=us=new Float64Array(K)}var oa=e.INITIAL_MEMORY||16777216,ps,Fu=[],Op=[],cm=[],Cr=!1,dm=!1,fm=0;function Qf(){return ne||fm>0}function Hg(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)Xg(e.preRun.shift());eh(Fu)}function qg(){Cr=!0,eh(Op)}function P0(){dm=!0}function jg(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)Yg(e.postRun.shift());eh(cm)}function Xg(K){Fu.unshift(K)}function sa(K){Op.unshift(K)}function Yg(K){cm.unshift(K)}var to=0,hm=null,Ru=null;function $k(K){to++,e.monitorRunDependencies&&e.monitorRunDependencies(to)}function Zg(K){if(to--,e.monitorRunDependencies&&e.monitorRunDependencies(to),to==0&&(hm!==null&&(clearInterval(hm),hm=null),Ru)){var Q=Ru;Ru=null,Q()}}e.preloadedImages={},e.preloadedAudios={};function zp(K){e.onAbort&&e.onAbort(K),K="Aborted("+K+")",P(K),ie=!0,pe=1,K+=". Build with -s ASSERTIONS=1 for more info.";var Q=new WebAssembly.RuntimeError(K);throw o(Q),Q}var Bk="data:application/octet-stream;base64,";function Qg(K){return K.startsWith(Bk)}function Gp(K){return K.startsWith("file://")}var un;un="tfjs-backend-wasm.wasm",Qg(un)||(un=f(un));function Jf(K){try{if(K==un&&q)return new Uint8Array(q);if(b)return b(K);throw"both async and sync fetching of the wasm failed"}catch(Q){zp(Q)}}function Ok(){if(!q&&(l||m)){if(typeof fetch=="function"&&!Gp(un))return fetch(un,{credentials:"same-origin"}).then(function(K){if(!K.ok)throw"failed to load wasm binary file at '"+un+"'";return K.arrayBuffer()}).catch(function(){return Jf(un)});if(g)return new Promise(function(K,Q){g(un,function(Te){K(new Uint8Array(Te))},Q)})}return Promise.resolve().then(function(){return Jf(un)})}function zk(){var K={env:ym,wasi_snapshot_preview1:ym};function Q(it,ot){var kr=it.exports;e.asm=kr,se=e.asm.memory,zn(se.buffer),ps=e.asm.__indirect_function_table,sa(e.asm.__wasm_call_ctors),Zg("wasm-instantiate")}$k("wasm-instantiate");function Te(it){Q(it.instance)}function _e(it){return Ok().then(function(ot){return WebAssembly.instantiate(ot,K)}).then(function(ot){return ot}).then(it,function(ot){P("failed to asynchronously prepare wasm: "+ot),zp(ot)})}function xt(){return!q&&typeof WebAssembly.instantiateStreaming=="function"&&!Qg(un)&&!Gp(un)&&typeof fetch=="function"?fetch(un,{credentials:"same-origin"}).then(function(it){var ot=WebAssembly.instantiateStreaming(it,K);return ot.then(Te,function(kr){return P("wasm streaming compile failed: "+kr),P("falling back to ArrayBuffer instantiation"),_e(Te)})}):_e(Te)}if(e.instantiateWasm)try{var St=e.instantiateWasm(K,Q);return St}catch(it){return P("Module.instantiateWasm callback failed with error: "+it),!1}return xt().catch(o),{}}var M0,E0;function eh(K){for(;K.length>0;){var Q=K.shift();if(typeof Q=="function"){Q(e);continue}var Te=Q.func;typeof Te=="number"?Q.arg===void 0?th(Te)():th(Te)(Q.arg):Te(Q.arg===void 0?null:Q.arg)}}function Pu(K){return K}function Jg(K){var Q=/\b_Z[\w\d_]+/g;return K.replace(Q,function(Te){var _e=Te;return Te===_e?Te:_e+" ["+Te+"]"})}var aa=[];function th(K){var Q=aa[K];return Q||(K>=aa.length&&(aa.length=K+1),aa[K]=Q=ps.get(K)),Q}function _0(){var K=new Error;if(!K.stack){try{throw new Error}catch(Q){K=Q}if(!K.stack)return"(no stack trace available)"}return K.stack.toString()}function gm(K,Q){ps.set(K,Q),aa[K]=Q}function Gk(){zp("")}function eb(K,Q,Te){qt.copyWithin(K,Q,Q+Te)}function tb(){return 2147483648}function pn(K){try{return se.grow(K-zt.byteLength+65535>>>16),zn(se.buffer),1}catch{}}function rb(K){var Q=qt.length;K=K>>>0;var Te=tb();if(K>Te)return!1;for(var _e=1;_e<=4;_e*=2){var xt=Q*(1+.2/_e);xt=Math.min(xt,K+100663296);var St=Math.min(Te,er(Math.max(K,xt),65536)),it=pn(St);if(it)return!0}return!1}var bm={mappings:{},buffers:[null,[],[]],printChar:function(K,Q){var Te=bm.buffers[K];Q===0||Q===10?((K===1?R:P)($e(Te,0)),Te.length=0):Te.push(Q)},varargs:void 0,get:function(){bm.varargs+=4;var K=sn[bm.varargs-4>>2];return K},getStr:function(K){var Q=Ze(K);return Q},get64:function(K,Q){return K}};function Uk(K){return 0}function L0(K,Q,Te,_e,xt){}function $0(K,Q,Te,_e){for(var xt=0,St=0;St<Te;St++){var it=sn[Q>>2],ot=sn[Q+4>>2];Q+=8;for(var kr=0;kr<ot;kr++)bm.printChar(K,qt[it+kr]);xt+=ot}return sn[_e>>2]=xt,0}function Wk(K){ee(K)}var nb=!1,ym={abort:Gk,emscripten_memcpy_big:eb,emscripten_resize_heap:rb,fd_close:Uk,fd_seek:L0,fd_write:$0,setTempRet0:Wk},dj=zk(),B0=e.___wasm_call_ctors=function(){return(B0=e.___wasm_call_ctors=e.asm.__wasm_call_ctors).apply(null,arguments)},Kk=e._init=function(){return(Kk=e._init=e.asm.init).apply(null,arguments)},Vk=e._init_with_threads_count=function(){return(Vk=e._init_with_threads_count=e.asm.init_with_threads_count).apply(null,arguments)},ob=e._get_threads_count=function(){return(ob=e._get_threads_count=e.asm.get_threads_count).apply(null,arguments)},sb=e._register_tensor=function(){return(sb=e._register_tensor=e.asm.register_tensor).apply(null,arguments)},Hk=e._dispose_data=function(){return(Hk=e._dispose_data=e.asm.dispose_data).apply(null,arguments)},He=e._dispose=function(){return(He=e._dispose=e.asm.dispose).apply(null,arguments)},qk=e._Abs=function(){return(qk=e._Abs=e.asm.Abs).apply(null,arguments)},ab=e._Add=function(){return(ab=e._Add=e.asm.Add).apply(null,arguments)},Up=e._AddN=function(){return(Up=e._AddN=e.asm.AddN).apply(null,arguments)},Tm=e._All=function(){return(Tm=e._All=e.asm.All).apply(null,arguments)},jk=e._Any=function(){return(jk=e._Any=e.asm.Any).apply(null,arguments)},O0=e._ArgMax=function(){return(O0=e._ArgMax=e.asm.ArgMax).apply(null,arguments)},Xk=e._AvgPool=function(){return(Xk=e._AvgPool=e.asm.AvgPool).apply(null,arguments)},z0=e._BatchMatMul=function(){return(z0=e._BatchMatMul=e.asm.BatchMatMul).apply(null,arguments)},Wp=e._Ceil=function(){return(Wp=e._Ceil=e.asm.Ceil).apply(null,arguments)},Yk=e._ClipByValue=function(){return(Yk=e._ClipByValue=e.asm.ClipByValue).apply(null,arguments)},Zk=e._Conv2D=function(){return(Zk=e._Conv2D=e.asm.Conv2D).apply(null,arguments)},Qk=e._Conv2DBackpropInput=function(){return(Qk=e._Conv2DBackpropInput=e.asm.Conv2DBackpropInput).apply(null,arguments)},Jk=e._Cos=function(){return(Jk=e._Cos=e.asm.Cos).apply(null,arguments)},eS=e._Cosh=function(){return(eS=e._Cosh=e.asm.Cosh).apply(null,arguments)},tS=e._CropAndResize=function(){return(tS=e._CropAndResize=e.asm.CropAndResize).apply(null,arguments)},ib=e._Cumprod=function(){return(ib=e._Cumprod=e.asm.Cumprod).apply(null,arguments)},rS=e._Cumsum=function(){return(rS=e._Cumsum=e.asm.Cumsum).apply(null,arguments)},nS=e._DepthToSpace=function(){return(nS=e._DepthToSpace=e.asm.DepthToSpace).apply(null,arguments)},oS=e._DepthwiseConv2dNative=function(){return(oS=e._DepthwiseConv2dNative=e.asm.DepthwiseConv2dNative).apply(null,arguments)},sS=e._Elu=function(){return(sS=e._Elu=e.asm.Elu).apply(null,arguments)},aS=e._Equal=function(){return(aS=e._Equal=e.asm.Equal).apply(null,arguments)},ub=e._Exp=function(){return(ub=e._Exp=e.asm.Exp).apply(null,arguments)},iS=e._FlipLeftRight=function(){return(iS=e._FlipLeftRight=e.asm.FlipLeftRight).apply(null,arguments)},uS=e._Floor=function(){return(uS=e._Floor=e.asm.Floor).apply(null,arguments)},Kp=e._FloorDiv=function(){return(Kp=e._FloorDiv=e.asm.FloorDiv).apply(null,arguments)},rh=e._FusedBatchNorm=function(){return(rh=e._FusedBatchNorm=e.asm.FusedBatchNorm).apply(null,arguments)},pS=e._FusedConv2D=function(){return(pS=e._FusedConv2D=e.asm.FusedConv2D).apply(null,arguments)},lS=e._FusedDepthwiseConv2D=function(){return(lS=e._FusedDepthwiseConv2D=e.asm.FusedDepthwiseConv2D).apply(null,arguments)},mS=e._Gather=function(){return(mS=e._Gather=e.asm.Gather).apply(null,arguments)},at=e._GatherNd=function(){return(at=e._GatherNd=e.asm.GatherNd).apply(null,arguments)},cS=e._Greater=function(){return(cS=e._Greater=e.asm.Greater).apply(null,arguments)},dS=e._GreaterEqual=function(){return(dS=e._GreaterEqual=e.asm.GreaterEqual).apply(null,arguments)},fS=e._LeakyRelu=function(){return(fS=e._LeakyRelu=e.asm.LeakyRelu).apply(null,arguments)},hS=e._Less=function(){return(hS=e._Less=e.asm.Less).apply(null,arguments)},gS=e._LessEqual=function(){return(gS=e._LessEqual=e.asm.LessEqual).apply(null,arguments)},bS=e._Log=function(){return(bS=e._Log=e.asm.Log).apply(null,arguments)},nh=e._LogicalAnd=function(){return(nh=e._LogicalAnd=e.asm.LogicalAnd).apply(null,arguments)},pb=e._LogicalNot=function(){return(pb=e._LogicalNot=e.asm.LogicalNot).apply(null,arguments)},lb=e._LogicalOr=function(){return(lb=e._LogicalOr=e.asm.LogicalOr).apply(null,arguments)},yS=e._LogicalXor=function(){return(yS=e._LogicalXor=e.asm.LogicalXor).apply(null,arguments)},TS=e._Max=function(){return(TS=e._Max=e.asm.Max).apply(null,arguments)},xS=e._MaxPool=function(){return(xS=e._MaxPool=e.asm.MaxPool).apply(null,arguments)},IS=e._Maximum=function(){return(IS=e._Maximum=e.asm.Maximum).apply(null,arguments)},CS=e._Mean=function(){return(CS=e._Mean=e.asm.Mean).apply(null,arguments)},kS=e._Min=function(){return(kS=e._Min=e.asm.Min).apply(null,arguments)},pr=e._Minimum=function(){return(pr=e._Minimum=e.asm.Minimum).apply(null,arguments)},SS=e._MirrorPad=function(){return(SS=e._MirrorPad=e.asm.MirrorPad).apply(null,arguments)},vS=e._Multiply=function(){return(vS=e._Multiply=e.asm.Multiply).apply(null,arguments)},AS=e._Neg=function(){return(AS=e._Neg=e.asm.Neg).apply(null,arguments)},xm=e._NonMaxSuppressionV3=function(){return(xm=e._NonMaxSuppressionV3=e.asm.NonMaxSuppressionV3).apply(null,arguments)},mb=e._NonMaxSuppressionV4=function(){return(mb=e._NonMaxSuppressionV4=e.asm.NonMaxSuppressionV4).apply(null,arguments)},cb=e._NonMaxSuppressionV5=function(){return(cb=e._NonMaxSuppressionV5=e.asm.NonMaxSuppressionV5).apply(null,arguments)},db=e._NotEqual=function(){return(db=e._NotEqual=e.asm.NotEqual).apply(null,arguments)},wS=e._OneHot=function(){return(wS=e._OneHot=e.asm.OneHot).apply(null,arguments)},fb=e._PadV2=function(){return(fb=e._PadV2=e.asm.PadV2).apply(null,arguments)},NS=e._Pow=function(){return(NS=e._Pow=e.asm.Pow).apply(null,arguments)},G0=e._Prelu=function(){return(G0=e._Prelu=e.asm.Prelu).apply(null,arguments)},hb=e._Prod=function(){return(hb=e._Prod=e.asm.Prod).apply(null,arguments)},U0=e._RealDiv=function(){return(U0=e._RealDiv=e.asm.RealDiv).apply(null,arguments)},DS=e._Relu=function(){return(DS=e._Relu=e.asm.Relu).apply(null,arguments)},FS=e._Relu6=function(){return(FS=e._Relu6=e.asm.Relu6).apply(null,arguments)},RS=e._ResizeBilinear=function(){return(RS=e._ResizeBilinear=e.asm.ResizeBilinear).apply(null,arguments)},PS=e._ResizeNearestNeighbor=function(){return(PS=e._ResizeNearestNeighbor=e.asm.ResizeNearestNeighbor).apply(null,arguments)},MS=e._Reverse=function(){return(MS=e._Reverse=e.asm.Reverse).apply(null,arguments)},ES=e._RotateWithOffset=function(){return(ES=e._RotateWithOffset=e.asm.RotateWithOffset).apply(null,arguments)},_S=e._Round=function(){return(_S=e._Round=e.asm.Round).apply(null,arguments)},LS=e._Rsqrt=function(){return(LS=e._Rsqrt=e.asm.Rsqrt).apply(null,arguments)},$S=e._ScatterNd=function(){return($S=e._ScatterNd=e.asm.ScatterNd).apply(null,arguments)},BS=e._SelectV2=function(){return(BS=e._SelectV2=e.asm.SelectV2).apply(null,arguments)},OS=e._Sigmoid=function(){return(OS=e._Sigmoid=e.asm.Sigmoid).apply(null,arguments)},zS=e._Sin=function(){return(zS=e._Sin=e.asm.Sin).apply(null,arguments)},GS=e._Softmax=function(){return(GS=e._Softmax=e.asm.Softmax).apply(null,arguments)},US=e._SparseFillEmptyRows=function(){return(US=e._SparseFillEmptyRows=e.asm.SparseFillEmptyRows).apply(null,arguments)},WS=e._SparseReshape=function(){return(WS=e._SparseReshape=e.asm.SparseReshape).apply(null,arguments)},KS=e._SparseSegmentReduction=function(){return(KS=e._SparseSegmentReduction=e.asm.SparseSegmentReduction).apply(null,arguments)},VS=e._Sqrt=function(){return(VS=e._Sqrt=e.asm.Sqrt).apply(null,arguments)},HS=e._Square=function(){return(HS=e._Square=e.asm.Square).apply(null,arguments)},qS=e._SquaredDifference=function(){return(qS=e._SquaredDifference=e.asm.SquaredDifference).apply(null,arguments)},jS=e._Step=function(){return(jS=e._Step=e.asm.Step).apply(null,arguments)},XS=e._StridedSlice=function(){return(XS=e._StridedSlice=e.asm.StridedSlice).apply(null,arguments)},YS=e._Sub=function(){return(YS=e._Sub=e.asm.Sub).apply(null,arguments)},ZS=e._Sum=function(){return(ZS=e._Sum=e.asm.Sum).apply(null,arguments)},QS=e._Tan=function(){return(QS=e._Tan=e.asm.Tan).apply(null,arguments)},JS=e._Tanh=function(){return(JS=e._Tanh=e.asm.Tanh).apply(null,arguments)},ev=e._Tile=function(){return(ev=e._Tile=e.asm.Tile).apply(null,arguments)},tv=e._TopK=function(){return(tv=e._TopK=e.asm.TopK).apply(null,arguments)},rv=e._Transform=function(){return(rv=e._Transform=e.asm.Transform).apply(null,arguments)},nv=e._Transpose=function(){return(nv=e._Transpose=e.asm.Transpose).apply(null,arguments)},ov=e.__FusedMatMul=function(){return(ov=e.__FusedMatMul=e.asm._FusedMatMul).apply(null,arguments)},sv=e._malloc=function(){return(sv=e._malloc=e.asm.malloc).apply(null,arguments)},av=e._free=function(){return(av=e._free=e.asm.free).apply(null,arguments)},iv=e.___errno_location=function(){return(iv=e.___errno_location=e.asm.__errno_location).apply(null,arguments)},uv=e._emscripten_main_thread_process_queued_calls=function(){return(uv=e._emscripten_main_thread_process_queued_calls=e.asm.emscripten_main_thread_process_queued_calls).apply(null,arguments)},gb=e.stackSave=function(){return(gb=e.stackSave=e.asm.stackSave).apply(null,arguments)},bb=e.stackRestore=function(){return(bb=e.stackRestore=e.asm.stackRestore).apply(null,arguments)},oh=e.stackAlloc=function(){return(oh=e.stackAlloc=e.asm.stackAlloc).apply(null,arguments)},pv=e.dynCall_iijjiiii=function(){return(pv=e.dynCall_iijjiiii=e.asm.dynCall_iijjiiii).apply(null,arguments)},lv=e.dynCall_jiji=function(){return(lv=e.dynCall_jiji=e.asm.dynCall_jiji).apply(null,arguments)};e.cwrap=Ce;var Im;function sh(K){this.name="ExitStatus",this.message="Program terminated with exit("+K+")",this.status=K}Ru=function K(){Im||ah(),Im||(Ru=K)};function ah(K){if(K=K||i,to>0||(Hg(),to>0))return;function Q(){Im||(Im=!0,e.calledRun=!0,!ie&&(qg(),n(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),jg()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),Q()},1)):Q()}e.run=ah;function W0(K){pe=K,Qf()||(e.onExit&&e.onExit(K),ie=!0),p(K,new sh(K))}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();ah();var Cm;s&&(Cm={uncaughtException:process.listeners("uncaughtException").filter(function(K){return!s.uncaughtException.indexOf(K)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(K){return!s.unhandledRejection.indexOf(K)>-1})});var km;if(typeof t<"u")km=t;else if(typeof WasmBackendModuleThreadedSimd<"u")km=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(Cm){var mv=km._dispose;km._dispose=function(){mv(),Cm.uncaughtException.forEach(function(K){process.removeListener("uncaughtException",K)}),Cm.unhandledRejection.forEach(function(K){process.removeListener("unhandledRejection",K)})}}return t.ready}})();typeof _k=="object"&&typeof w0=="object"?w0.exports=A0:typeof define=="function"&&define.amd?define([],function(){return A0}):typeof _k=="object"&&(_k.WasmBackendModule=A0)});var d6=1e-7,f6=1e-4,ma=class{constructor(t,e){this.backend=t;this.dataMover=e;this.data=new WeakMap;this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},no=class{refCount(t){return ro("refCount")}incRef(t){return ro("incRef")}timerAvailable(){return!0}time(t){return ro("time")}read(t){return ro("read")}readSync(t){return ro("readSync")}readToGPU(t,e){return ro("readToGPU")}numDataIds(){return ro("numDataIds")}disposeData(t,e){return ro("disposeData")}write(t,e,n){return ro("write")}move(t,e,n,o,s){return ro("move")}memory(){return ro("memory")}floatPrecision(){return ro("floatPrecision")}epsilon(){return this.floatPrecision()===32?d6:f6}dispose(){return ro("dispose")}};function ro(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function t1(r){let t=r.length,e=0;for(;t>0;)e=Math.random()*t|0,t--,Ab(r,t,e)}function h6(r,t){if(r.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,n=0;for(;e>0;)n=Math.random()*e|0,e--,Ab(r,e,n),Ab(t,e,n)}function Nm(r,t,e){return Math.max(r,Math.min(t,e))}function g6(r){return r%2===0?r:r+1}function Ab(r,t,e){let n=r[t];r[t]=r[e],r[e]=n}function b6(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function y6(r,t){let e=Math.random();return t*e+(1-e)*r}function T6(r,t){let e=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(t[n]);e+=o*o}return e}function F(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function Gt(r,t,e=""){F(Un(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function oo(r){F(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ca(r,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(r)||Sr(r)&&!e)for(let n=0;n<r.length;++n)ca(r[n],t,e);else t.push(r);return t}function rt(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function x6(r){return r.length===0}function Un(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function _i(r){return r%1===0}function I6(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function C6(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function k6(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return t1(t),t}function qp(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function S6(r,t=n=>0,e){return new Promise((n,o)=>{let s=0,a=()=>{if(r()){n();return}s++;let i=t(s);if(e!=null&&s>=e){o();return}setTimeout(a,i)};a()})}function v6(r,t){let e=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)e*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let o=r.slice();return o[n]=t/e,o}function gr(r,t){let e=t.length;return r=r==null?t.map((n,o)=>o):[].concat(r),F(r.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),F(r.every(n=>_i(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?e+n:n)}function yv(r,t){let e=[],n=[],o=t!=null&&Array.isArray(t)&&t.length===0,s=t==null||o?null:gr(t,r).sort(),a=0;for(let i=0;i<r.length;++i){if(s!=null){if(s[a]===i&&r[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${r[i]}' is not 1`);(s[a]==null||s[a]>i)&&r[i]===1&&(e.push(r[i]),n.push(i)),s[a]<=i&&a++}r[i]!==1&&(e.push(r[i]),n.push(i))}return{newShape:e,keptDims:n}}function Tv(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${r}`);return e}function xv(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function Iv(r,t){for(let e=0;e<r.length;e++){let n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function Cv(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function A6(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function Sr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function wb(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function kv(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function da(r){return typeof r=="string"||r instanceof String}function r1(r){return typeof r=="boolean"}function n1(r){return typeof r=="number"}function Dm(r){return Array.isArray(r)?Dm(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":n1(r)?"float32":da(r)?"string":r1(r)?"bool":"float32"}function mi(r){return!!(r&&r.constructor&&r.call&&r.apply)}function Fm(r,t){for(let e=t;e<r;++e)if(r%e===0)return e;return r}function ci(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function o1(r,t,e,n=!1){let o=new Array;if(t.length===1){let s=t[0]*(n?2:1);for(let a=0;a<s;a++)o[a]=e[r+a]}else{let s=t[0],a=t.slice(1),i=a.reduce((u,p)=>u*p)*(n?2:1);for(let u=0;u<s;u++)o[u]=o1(r+u*i,a,e,n)}return o}function Hp(r,t,e=!1){if(r.length===0)return t[0];let n=r.reduce((o,s)=>o*s)*(e?2:1);if(n===0)return[];if(n!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}${e?" for a complex tensor":""}.`);return o1(0,r,t,e)}function ph(r,t){let e=Rm(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function Rm(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function w6(r,t){let e=r.reduce((n,o)=>n*o,1);if(t==null||t==="float32")return Hp(r,new Float32Array(e));if(t==="int32")return Hp(r,new Int32Array(e));if(t==="bool")return Hp(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function lh(r){r.forEach(t=>{F(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function N6(r,t,e){if(t===0)return 0;if(t===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=e[o]*r[o];return n}function D6(r,t,e){if(t===0)return[];if(t===1)return[r];let n=new Array(t);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/e[o]),r-=n[o]*e[o];return n[n.length-1]=r,n}function mh(r){return r&&r.then&&typeof r.then=="function"}var s1="tfjsflags",ch=class{constructor(t){this.global=t;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=R6;this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&(B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let o=this.urlFlags[t];B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${o}.`),this.set(t,o)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(mh(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;let t=this.getQueryParams(this.global.location.search);s1 in t&&t[s1].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=M6(o,s)})}};function R6(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(P6(t,n[0],n[1]),n.join("="))),t}function P6(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function M6(r,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${r}.`)}function B(){return Sv}var Sv=null;function a1(r){Sv=r}var vv;function Av(){if(vv==null){let r;if(typeof window<"u")r=window;else if(typeof global<"u")r=global;else if(typeof process<"u")r=process;else if(typeof self<"u")r=self;else throw new Error("Could not find a global object");vv=r}return vv}function E6(){let r=Av();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function dh(r,t){let e=E6();if(e.has(r))return e.get(r);{let n=t();return e.set(r,n),e.get(r)}}var ls="Abs",Li="Acos",$i="Acosh",Nn="Add",so="AddN",Bi="All",Oi="Any",ao="ArgMax",di="ArgMin",zi="Asin",Gi="Asinh",Ui="Atan",Wi="Atanh",fa="Atan2",io="AvgPool",Pm="AvgPoolGrad",Eu="AvgPool3D",Mm="AvgPool3DGrad",uo="BatchMatMul",ms="BatchToSpaceND",Em="Bincount",i1="BroadcastTo",_m="BroadcastArgs",Wn="Cast",po="Ceil",Kn="ClipByValue",_u="Complex",Lu="ComplexAbs",cs="Concat",lo="Conv2D",Lm="Conv2DBackpropFilter",mo="Conv2DBackpropInput",$u="Conv3D",$m="Conv3DBackpropFilterV2",Bm="Conv3DBackpropInputV2",co="Cos",fo="Cosh",ha="Cumprod",ho="Cumsum",ga="CropAndResize",Om="DenseBincount",ba="DepthToSpace",go="DepthwiseConv2dNative",zm="DepthwiseConv2dNativeBackpropFilter",Gm="DepthwiseConv2dNativeBackpropInput",Um="Diag",Bu="Dilation2D",fh="Dilation2DBackpropInput",hh="Dilation2DBackpropFilter",bo="RealDiv",Ou="Einsum",yo="Elu",Wm="EluGrad",Ki="Erf",ya="Equal",To="Exp",ds="ExpandDims",Ta="Expm1",Km="FFT",fi="Fill",xa="FlipLeftRight",xo="Floor",Io="FloorDiv",Co="FusedBatchNorm",fs="GatherV2",Ia="GatherNd",Ca="Greater",ko="GreaterEqual",Vn="Identity",Vm="IFFT",zu="Imag",Vi="IsFinite",Hi="IsInf",ka="IsNan",So="LeakyRelu",Sa="Less",va="LessEqual",Hm="LinSpace",vo="Log",qi="Log1p",Aa="LogicalAnd",wa="LogicalNot",ji="LogicalOr",u1="LogicalXor",p1="LogSoftmax",Pge="LowerBound",Gu="LRN",qm="LRNGrad",Ao="Max",wo="Maximum",No="MaxPool",jm="MaxPoolGrad",Uu="MaxPool3D",Xm="MaxPool3DGrad",Ym="MaxPoolWithArgmax",Do="Mean",Fo="Min",Ro="Minimum",Po="MirrorPad",Xi="Mod",Zm="Multinomial",Mo="Multiply",hs="Neg",Na="NotEqual",Da="NonMaxSuppressionV3",Yi="NonMaxSuppressionV4",Fa="NonMaxSuppressionV5",gs="OnesLike",Ra="OneHot",bs="Pack",Eo="PadV2",Mge="Pool",_o="Pow",Lo="Prelu",$o="Prod",Qm="RaggedTensorToTensor",hi="Range",Wu="Real",Pa="Reciprocal",Bo="Relu",ys="Reshape",Oo="ResizeNearestNeighbor",Jm="ResizeNearestNeighborGrad",zo="ResizeBilinear",ec="ResizeBilinearGrad",Go="Relu6",Ma="Reverse",Ea="Round",Uo="Rsqrt",_a="ScatterNd",tc="SearchSorted",Ts="Select",Zi="Selu",xs="Slice",Wo="Sin",La="Sinh",Qi="Sign",Ko="Sigmoid",Ji="Softplus",Vo="Sqrt",Ho="Sum",Is="SpaceToBatchND",Cs="SplitV",qo="Softmax",Ku="SparseFillEmptyRows",eu="SparseReshape",Vu="SparseSegmentMean",Hu="SparseSegmentSum",qu="SparseToDense",jo="SquaredDifference",gi="Square",$a="StridedSlice",bi="StringNGrams",ju="StringSplit",Xu="StringToHashBucketFast",Xo="Sub",Ba="Tan",Yo="Tanh",Dn="Tile",Oa="TopK",za="Transform",Fn="Transpose",rc="Unique",ks="Unpack",Yu="UnsortedSegmentSum",Ege="UpperBound",Ss="ZerosLike",vs="Step",jp="FromPixels",Ga="RotateWithOffset",As="_FusedMatMul",ws="FusedConv2D",Ns="FusedDepthwiseConv2D";function yi(...r){B().getBool("IS_TEST")||B().getBool("PROD")||console.warn(...r)}function _6(...r){B().getBool("IS_TEST")||B().getBool("PROD")||console.log(...r)}var nc=dh("kernelRegistry",()=>new Map),gh=dh("gradRegistry",()=>new Map);function bh(r,t){let e=Nv(r,t);return nc.get(e)}function wv(r){return gh.get(r)}function Nb(r){let t=nc.entries(),e=[];for(;;){let{done:n,value:o}=t.next();if(n)break;let[s,a]=o,[i]=s.split("_");i===r&&e.push(a)}return e}function tu(r){let{kernelName:t,backendName:e}=r,n=Nv(t,e);nc.has(n)&&yi(`The kernel '${t}' for backend '${e}' is already registered`),nc.set(n,r)}function m1(r){let{kernelName:t}=r;gh.has(t)&&B().getBool("DEBUG")&&yi(`Overriding the gradient for '${t}'`),gh.set(t,r)}function Oge(r,t){let e=Nv(r,t);if(!nc.has(e))throw new Error(`The kernel '${r}' for backend '${t}' is not registered`);nc.delete(e)}function zge(r){if(!gh.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);gh.delete(r)}function Gge(r,t){Nb(r).forEach(n=>{let o=Object.assign({},n,{backendName:t});tu(o)})}function Nv(r,t){return`${t}_${r}`}var y={};Xe(y,{arraysEqual:()=>Un,assert:()=>F,assertNonNegativeIntegerDimensions:()=>lh,assertNonNull:()=>oo,assertShapesMatch:()=>Gt,bytesFromStringArray:()=>kv,bytesPerElement:()=>wb,checkConversionForErrors:()=>Iv,clamp:()=>Nm,computeStrides:()=>ci,createScalarValue:()=>U6,createShuffledIndices:()=>k6,decodeString:()=>ic,distSquared:()=>T6,encodeString:()=>Qu,fetch:()=>K6,fingerPrint64:()=>G6,flatten:()=>ca,getArrayFromDType:()=>xv,getTypedArrayFromDType:()=>Tv,hasEncodingLoss:()=>A6,hexToLong:()=>yh,indexToLoc:()=>D6,inferDtype:()=>Dm,inferFromImplicitShape:()=>v6,isBoolean:()=>r1,isFunction:()=>mi,isInt:()=>_i,isNumber:()=>n1,isPromise:()=>mh,isScalarShape:()=>x6,isString:()=>da,isTypedArray:()=>Sr,isValidDtype:()=>Cv,locToIndex:()=>N6,makeOnesTypedArray:()=>ph,makeZerosNestedTypedArray:()=>w6,makeZerosTypedArray:()=>Rm,nearestDivisor:()=>Fm,nearestLargerEven:()=>g6,now:()=>Qp,parseAxisParam:()=>gr,randUniform:()=>y6,repeatedTry:()=>S6,rightPad:()=>qp,shuffle:()=>t1,shuffleCombo:()=>h6,sizeFromShape:()=>rt,sizeToSquarishShape:()=>C6,squeezeShape:()=>yv,sum:()=>b6,swap:()=>Ab,tanh:()=>I6,toNestedArray:()=>Hp,toTypedArray:()=>ac});var Pv={};Xe(Pv,{default:()=>Rv});var Ds=null;try{Ds=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function tr(r,t,e){this.low=r|0,this.high=t|0,this.unsigned=!!e}tr.prototype.__isLong__;Object.defineProperty(tr.prototype,"__isLong__",{value:!0});function mn(r){return(r&&r.__isLong__)===!0}function c1(r){var t=Math.clz32(r&-r);return r?31-t:t}tr.isLong=mn;var d1={},f1={};function Xp(r,t){var e,n,o;return t?(r>>>=0,(o=0<=r&&r<256)&&(n=f1[r],n)?n:(e=vt(r,0,!0),o&&(f1[r]=e),e)):(r|=0,(o=-128<=r&&r<128)&&(n=d1[r],n)?n:(e=vt(r,r<0?-1:0,!1),o&&(d1[r]=e),e))}tr.fromInt=Xp;function Fs(r,t){if(isNaN(r))return t?ru:Ua;if(t){if(r<0)return ru;if(r>=y1)return I1}else{if(r<=-g1)return Hn;if(r+1>=g1)return x1}return r<0?Fs(-r,t).neg():vt(r%sc|0,r/sc|0,t)}tr.fromNumber=Fs;function vt(r,t,e){return new tr(r,t,e)}tr.fromBits=vt;var Db=Math.pow;function Fv(r,t,e){if(r.length===0)throw Error("empty string");if(typeof t=="number"?(e=t,t=!1):t=!!t,r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return t?ru:Ua;if(e=e||10,e<2||36<e)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return Fv(r.substring(1),t,e).neg();for(var o=Fs(Db(e,8)),s=Ua,a=0;a<r.length;a+=8){var i=Math.min(8,r.length-a),u=parseInt(r.substring(a,a+i),e);if(i<8){var p=Fs(Db(e,i));s=s.mul(p).add(Fs(u))}else s=s.mul(o),s=s.add(Fs(u))}return s.unsigned=t,s}tr.fromString=Fv;function Wa(r,t){return typeof r=="number"?Fs(r,t):typeof r=="string"?Fv(r,t):vt(r.low,r.high,typeof t=="boolean"?t:r.unsigned)}tr.fromValue=Wa;var h1=1<<16,L6=1<<24,sc=h1*h1,y1=sc*sc,g1=y1/2,b1=Xp(L6),Ua=Xp(0);tr.ZERO=Ua;var ru=Xp(0,!0);tr.UZERO=ru;var oc=Xp(1);tr.ONE=oc;var T1=Xp(1,!0);tr.UONE=T1;var Dv=Xp(-1);tr.NEG_ONE=Dv;var x1=vt(-1,2147483647,!1);tr.MAX_VALUE=x1;var I1=vt(-1,-1,!0);tr.MAX_UNSIGNED_VALUE=I1;var Hn=vt(0,-2147483648,!1);tr.MIN_VALUE=Hn;var he=tr.prototype;he.toInt=function(){return this.unsigned?this.low>>>0:this.low};he.toNumber=function(){return this.unsigned?(this.high>>>0)*sc+(this.low>>>0):this.high*sc+(this.low>>>0)};he.toString=function(t){if(t=t||10,t<2||36<t)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Hn)){var e=Fs(t),n=this.div(e),o=n.mul(e).sub(this);return n.toString(t)+o.toInt().toString(t)}else return"-"+this.neg().toString(t);for(var s=Fs(Db(t,6),this.unsigned),a=this,i="";;){var u=a.div(s),p=a.sub(u.mul(s)).toInt()>>>0,l=p.toString(t);if(a=u,a.isZero())return l+i;for(;l.length<6;)l="0"+l;i=""+l+i}};he.getHighBits=function(){return this.high};he.getHighBitsUnsigned=function(){return this.high>>>0};he.getLowBits=function(){return this.low};he.getLowBitsUnsigned=function(){return this.low>>>0};he.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Hn)?64:this.neg().getNumBitsAbs();for(var t=this.high!=0?this.high:this.low,e=31;e>0&&(t&1<<e)==0;e--);return this.high!=0?e+33:e+1};he.isZero=function(){return this.high===0&&this.low===0};he.eqz=he.isZero;he.isNegative=function(){return!this.unsigned&&this.high<0};he.isPositive=function(){return this.unsigned||this.high>=0};he.isOdd=function(){return(this.low&1)===1};he.isEven=function(){return(this.low&1)===0};he.equals=function(t){return mn(t)||(t=Wa(t)),this.unsigned!==t.unsigned&&this.high>>>31===1&&t.high>>>31===1?!1:this.high===t.high&&this.low===t.low};he.eq=he.equals;he.notEquals=function(t){return!this.eq(t)};he.neq=he.notEquals;he.ne=he.notEquals;he.lessThan=function(t){return this.comp(t)<0};he.lt=he.lessThan;he.lessThanOrEqual=function(t){return this.comp(t)<=0};he.lte=he.lessThanOrEqual;he.le=he.lessThanOrEqual;he.greaterThan=function(t){return this.comp(t)>0};he.gt=he.greaterThan;he.greaterThanOrEqual=function(t){return this.comp(t)>=0};he.gte=he.greaterThanOrEqual;he.ge=he.greaterThanOrEqual;he.compare=function(t){if(mn(t)||(t=Wa(t)),this.eq(t))return 0;var e=this.isNegative(),n=t.isNegative();return e&&!n?-1:!e&&n?1:this.unsigned?t.high>>>0>this.high>>>0||t.high===this.high&&t.low>>>0>this.low>>>0?-1:1:this.sub(t).isNegative()?-1:1};he.comp=he.compare;he.negate=function(){return!this.unsigned&&this.eq(Hn)?Hn:this.not().add(oc)};he.neg=he.negate;he.add=function(t){mn(t)||(t=Wa(t));var e=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,a=t.high>>>16,i=t.high&65535,u=t.low>>>16,p=t.low&65535,l=0,m=0,c=0,d=0;return d+=s+p,c+=d>>>16,d&=65535,c+=o+u,m+=c>>>16,c&=65535,m+=n+i,l+=m>>>16,m&=65535,l+=e+a,l&=65535,vt(c<<16|d,l<<16|m,this.unsigned)};he.subtract=function(t){return mn(t)||(t=Wa(t)),this.add(t.neg())};he.sub=he.subtract;he.multiply=function(t){if(this.isZero())return this;if(mn(t)||(t=Wa(t)),Ds){var e=Ds.mul(this.low,this.high,t.low,t.high);return vt(e,Ds.get_high(),this.unsigned)}if(t.isZero())return this.unsigned?ru:Ua;if(this.eq(Hn))return t.isOdd()?Hn:Ua;if(t.eq(Hn))return this.isOdd()?Hn:Ua;if(this.isNegative())return t.isNegative()?this.neg().mul(t.neg()):this.neg().mul(t).neg();if(t.isNegative())return this.mul(t.neg()).neg();if(this.lt(b1)&&t.lt(b1))return Fs(this.toNumber()*t.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,a=this.low&65535,i=t.high>>>16,u=t.high&65535,p=t.low>>>16,l=t.low&65535,m=0,c=0,d=0,f=0;return f+=a*l,d+=f>>>16,f&=65535,d+=s*l,c+=d>>>16,d&=65535,d+=a*p,c+=d>>>16,d&=65535,c+=o*l,m+=c>>>16,c&=65535,c+=s*p,m+=c>>>16,c&=65535,c+=a*u,m+=c>>>16,c&=65535,m+=n*l+o*p+s*u+a*i,m&=65535,vt(d<<16|f,m<<16|c,this.unsigned)};he.mul=he.multiply;he.divide=function(t){if(mn(t)||(t=Wa(t)),t.isZero())throw Error("division by zero");if(Ds){if(!this.unsigned&&this.high===-2147483648&&t.low===-1&&t.high===-1)return this;var e=(this.unsigned?Ds.div_u:Ds.div_s)(this.low,this.high,t.low,t.high);return vt(e,Ds.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ru:Ua;var n,o,s;if(this.unsigned){if(t.unsigned||(t=t.toUnsigned()),t.gt(this))return ru;if(t.gt(this.shru(1)))return T1;s=ru}else{if(this.eq(Hn)){if(t.eq(oc)||t.eq(Dv))return Hn;if(t.eq(Hn))return oc;var a=this.shr(1);return n=a.div(t).shl(1),n.eq(Ua)?t.isNegative()?oc:Dv:(o=this.sub(t.mul(n)),s=n.add(o.div(t)),s)}else if(t.eq(Hn))return this.unsigned?ru:Ua;if(this.isNegative())return t.isNegative()?this.neg().div(t.neg()):this.neg().div(t).neg();if(t.isNegative())return this.div(t.neg()).neg();s=Ua}for(o=this;o.gte(t);){n=Math.max(1,Math.floor(o.toNumber()/t.toNumber()));for(var i=Math.ceil(Math.log(n)/Math.LN2),u=i<=48?1:Db(2,i-48),p=Fs(n),l=p.mul(t);l.isNegative()||l.gt(o);)n-=u,p=Fs(n,this.unsigned),l=p.mul(t);p.isZero()&&(p=oc),s=s.add(p),o=o.sub(l)}return s};he.div=he.divide;he.modulo=function(t){if(mn(t)||(t=Wa(t)),Ds){var e=(this.unsigned?Ds.rem_u:Ds.rem_s)(this.low,this.high,t.low,t.high);return vt(e,Ds.get_high(),this.unsigned)}return this.sub(this.div(t).mul(t))};he.mod=he.modulo;he.rem=he.modulo;he.not=function(){return vt(~this.low,~this.high,this.unsigned)};he.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32};he.clz=he.countLeadingZeros;he.countTrailingZeros=function(){return this.low?c1(this.low):c1(this.high)+32};he.ctz=he.countTrailingZeros;he.and=function(t){return mn(t)||(t=Wa(t)),vt(this.low&t.low,this.high&t.high,this.unsigned)};he.or=function(t){return mn(t)||(t=Wa(t)),vt(this.low|t.low,this.high|t.high,this.unsigned)};he.xor=function(t){return mn(t)||(t=Wa(t)),vt(this.low^t.low,this.high^t.high,this.unsigned)};he.shiftLeft=function(t){return mn(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?vt(this.low<<t,this.high<<t|this.low>>>32-t,this.unsigned):vt(0,this.low<<t-32,this.unsigned)};he.shl=he.shiftLeft;he.shiftRight=function(t){return mn(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?vt(this.low>>>t|this.high<<32-t,this.high>>t,this.unsigned):vt(this.high>>t-32,this.high>=0?0:-1,this.unsigned)};he.shr=he.shiftRight;he.shiftRightUnsigned=function(t){return mn(t)&&(t=t.toInt()),(t&=63)===0?this:t<32?vt(this.low>>>t|this.high<<32-t,this.high>>>t,this.unsigned):t===32?vt(this.high,0,this.unsigned):vt(this.high>>>t-32,0,this.unsigned)};he.shru=he.shiftRightUnsigned;he.shr_u=he.shiftRightUnsigned;he.rotateLeft=function(t){var e;return mn(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?vt(this.high,this.low,this.unsigned):t<32?(e=32-t,vt(this.low<<t|this.high>>>e,this.high<<t|this.low>>>e,this.unsigned)):(t-=32,e=32-t,vt(this.high<<t|this.low>>>e,this.low<<t|this.high>>>e,this.unsigned))};he.rotl=he.rotateLeft;he.rotateRight=function(t){var e;return mn(t)&&(t=t.toInt()),(t&=63)===0?this:t===32?vt(this.high,this.low,this.unsigned):t<32?(e=32-t,vt(this.high<<e|this.low>>>t,this.low<<e|this.high>>>t,this.unsigned)):(t-=32,e=32-t,vt(this.low<<e|this.high>>>t,this.high<<e|this.low>>>t,this.unsigned))};he.rotr=he.rotateRight;he.toSigned=function(){return this.unsigned?vt(this.low,this.high,!1):this};he.toUnsigned=function(){return this.unsigned?this:vt(this.low,this.high,!0)};he.toBytes=function(t){return t?this.toBytesLE():this.toBytesBE()};he.toBytesLE=function(){var t=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,t&255,t>>>8&255,t>>>16&255,t>>>24]};he.toBytesBE=function(){var t=this.high,e=this.low;return[t>>>24,t>>>16&255,t>>>8&255,t&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};tr.fromBytes=function(t,e,n){return n?tr.fromBytesLE(t,e):tr.fromBytesBE(t,e)};tr.fromBytesLE=function(t,e){return new tr(t[0]|t[1]<<8|t[2]<<16|t[3]<<24,t[4]|t[5]<<8|t[6]<<16|t[7]<<24,e)};tr.fromBytesBE=function(t,e){return new tr(t[4]<<24|t[5]<<16|t[6]<<8|t[7],t[0]<<24|t[1]<<16|t[2]<<8|t[3],e)};var Rv=tr;var Zp=Rv||Pv;function yh(r){return Zp.fromString(r,!0,16)}var k1=yh("c3a5c85c97cb3127"),Yp=yh("b492b66fbe98f273"),cn=yh("9ae16a3b2f90404f");function Mv(r){return r.xor(r.shru(47))}function S1(r,t,e){let n=r.slice(t,t+e);return Zp.fromBytes(Array.from(n),!0,!0)}function jt(r,t){return S1(r,t,8)}function C1(r,t){return S1(r,t,4)}function Pr(r,t){return t===0?r:r.shru(t).or(r.shl(64-t))}function Zu(r,t,e=yh("9ddfea08eb382d69")){let n=r.xor(t).mul(e);n=n.xor(n.shru(47));let o=t.xor(n).mul(e);return o=o.xor(o.shru(47)),o=o.mul(e),o}function $6(r,t,e,n,o,s){o=o.add(r),s=Pr(s.add(o).add(n),21);let a=o;return o=o.add(t),o=o.add(e),s=s.add(Pr(o,44)),[o.add(n),s.add(a)]}function Fb(r,t,e,n){return $6(jt(r,t),jt(r,t+8),jt(r,t+16),jt(r,t+24),e,n)}function B6(r,t=r.length){if(t>=8){let e=cn.add(t*2),n=jt(r,0).add(cn),o=jt(r,t-8),s=Pr(o,37).mul(e).add(n),a=Pr(n,25).add(o).mul(e);return Zu(s,a,e)}if(t>=4){let e=cn.add(t*2),n=C1(r,0);return Zu(n.shl(3).add(t),C1(r,t-4),e)}if(t>0){let e=r[0],n=r[t>>1],o=r[t-1],s=e+(n<<8),a=t+(o<<2);return Mv(cn.mul(s).xor(k1.mul(a))).mul(cn)}return cn}function O6(r,t=r.length){let e=cn.add(t*2),n=jt(r,0).mul(Yp),o=jt(r,8),s=jt(r,t-8).mul(e),a=jt(r,t-16).mul(cn);return Zu(Pr(n.add(o),43).add(Pr(s,30)).add(a),n.add(Pr(o.add(cn),18)).add(s),e)}function z6(r,t=r.length){let e=cn.add(t*2),n=jt(r,0).mul(cn),o=jt(r,8),s=jt(r,t-8).mul(e),a=jt(r,t-16).mul(cn),i=Pr(n.add(o),43).add(Pr(s,30)).add(a),u=Zu(i,n.add(Pr(o.add(cn),18)).add(s),e),p=jt(r,16).mul(e),l=jt(r,24),m=i.add(jt(r,t-32)).mul(e),c=u.add(jt(r,t-24)).mul(e);return Zu(Pr(p.add(l),43).add(Pr(m,30)).add(c),p.add(Pr(l.add(n),18)).add(m),e)}function G6(r,t=r.length){let e=Zp.fromNumber(81,!0);if(t<=32)return t<=16?B6(r,t):O6(r,t);if(t<=64)return z6(r,t);let n=e,o=e.mul(Yp).add(113),s=Mv(o.mul(cn).add(113)).mul(cn),a=[Zp.UZERO,Zp.UZERO],i=[Zp.UZERO,Zp.UZERO];n=n.mul(cn).add(jt(r,0));let u=0,p=(t-1>>6)*64,l=p+(t-1&63)-63;do n=Pr(n.add(o).add(a[0]).add(jt(r,u+8)),37).mul(Yp),o=Pr(o.add(a[1]).add(jt(r,u+48)),42).mul(Yp),n=n.xor(i[1]),o=o.add(a[0]).add(jt(r,u+40)),s=Pr(s.add(i[0]),33).mul(Yp),a=Fb(r,u,a[1].mul(Yp),n.add(i[0])),i=Fb(r,u+32,s.add(i[1]),o.add(jt(r,u+16))),[s,n]=[n,s],u+=64;while(u!==p);let m=Yp.add(s.and(255).shl(1));return u=l,i[0]=i[0].add(t-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),n=Pr(n.add(o).add(a[0]).add(jt(r,u+8)),37).mul(m),o=Pr(o.add(a[1]).add(jt(r,u+48)),42).mul(m),n=n.xor(i[1].mul(9)),o=o.add(a[0].mul(9).add(jt(r,u+40))),s=Pr(s.add(i[0]),33).mul(m),a=Fb(r,u,a[1].mul(m),n.add(i[0])),i=Fb(r,u+32,s.add(i[1]),o.add(jt(r,u+16))),[s,n]=[n,s],Zu(Zu(a[0],i[0],m).add(Mv(o).mul(k1)).add(s),Zu(a[1],i[1],m).add(n),m)}function U6(r,t){return t==="string"?Qu(r):ac([r],t)}function W6(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function ac(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=ca(r)),B().getBool("DEBUG")&&Iv(r,t),W6(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let n=0;n<e.length;++n)Math.round(r[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function Qp(){return B().platform.now()}function K6(r,t){return B().platform.fetch(r,t)}function Qu(r,t="utf-8"){return t=t||"utf-8",B().platform.encode(r,t)}function ic(r,t="utf-8"){return t=t||"utf-8",B().platform.decode(r,t)}var Rb=class{constructor(t,e){this.backendTimer=t;this.logger=e;e==null&&(this.logger=new Ev)}profileKernel(t,e,n){let o,s=()=>{o=n()},a,i=Qp();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(let p of o)p.dataSync();a=Promise.resolve({kernelMs:Qp()-i})}if(B().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let p=0;p<o.length;p++){let l=o[p];l.data().then(m=>{V6(m,l.dtype,t)})}return{kernelName:t,outputs:o,inputs:e,timeMs:a.then(p=>p.kernelMs),extraInfo:a.then(p=>p.getExtraProfileInfo!=null?p.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:o,inputs:s,extraInfo:a}=t;n.forEach(i=>{Promise.all([i.data(),o,a]).then(u=>{this.logger.logKernelProfile(e,i,u[0],u[1],s,u[2])})})}};function V6(r,t,e){if(t!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${e}'`),!0}return!1}var Ev=class{logKernelProfile(t,e,n,o,s,a){let i=typeof o=="number"?qp(`${o}ms`,9):o.error,u=qp(t,25),p=e.rank,l=e.size,m=qp(e.shape.toString(),14),c="";for(let d in s){let f=s[d];if(f!=null){let h=f.shape||e.shape,g=h.length;c+=`${d}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${i}	%c${p}D ${m}	%c${l}	%c${c}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function v1(r,t,e){let n={},o={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<r.length;u++){let p=r[u],l=p.inputs;for(let m in l){let c=l[m],d=!1;for(let f=0;f<t.length;f++)if(n[c.id]){p.outputs.forEach(h=>n[h.id]=!0),d=!0,o[p.id]=!0;break}if(d)break}}let s={};s[e.id]=!0;let a={};for(let u=r.length-1;u>=0;u--){let p=r[u],l=p.inputs;for(let m=0;m<p.outputs.length;m++)if(s[p.outputs[m].id]){for(let c in l)s[l[c].id]=!0,a[p.id]=!0;break}}let i=[];for(let u=0;u<r.length;u++){let p=r[u];if(o[p.id]&&a[p.id]){let l={};for(let c in p.inputs){let d=p.inputs[c];n[d.id]&&(l[c]=d)}let m=Object.assign({},p);m.inputs=l,m.outputs=p.outputs,i.push(m)}}return i}function A1(r,t,e,n){for(let o=t.length-1;o>=0;o--){let s=t[o],a=[];if(s.outputs.forEach(u=>{let p=r[u.id];p!=null?a.push(p):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let i=s.gradient(a);for(let u in s.inputs){if(!(u in i))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(i)}.`);let p=e(()=>i[u]());if(p.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${p.dtype}'`);let l=s.inputs[u];if(!Un(p.shape,l.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${p.shape}', which does not match the shape of the input '${l.shape}'`);if(r[l.id]==null)r[l.id]=p;else{let m=r[l.id];r[l.id]=n(m,p),m.dispose()}}}}var w1=20,Th=3,_v=7;function N1(r,t,e,n){let o=ci(t),s=H6(r,t,e,o),a=t.length,i=Pb(r,t,e,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${a}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(i.map(p=>"    "+p).join(`
`)),u.join(`
`)}function H6(r,t,e,n){let o=rt(t),s=n[n.length-1],a=new Array(s).fill(0),i=t.length,u=e==="complex64"?Ih(r):r;if(i>1)for(let p=0;p<o/s;p++){let l=p*s;for(let m=0;m<s;m++)a[m]=Math.max(a[m],xh(u[l+m],0,e).length)}return a}function xh(r,t,e){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(_v))} + ${parseFloat(r[1].toFixed(_v))}j`:da(r)?n=`'${r}'`:e==="bool"?n=D1(r):n=parseFloat(r.toFixed(_v)).toString(),qp(n,t)}function D1(r){return r===0?"false":"true"}function Pb(r,t,e,n,o,s=!0){let a=e==="complex64"?2:1,i=t[0],u=t.length;if(u===0){if(e==="complex64"){let h=Ih(r);return[xh(h[0],0,e)]}return e==="bool"?[D1(r[0])]:[r[0].toString()]}if(u===1){if(i>w1){let g=Th*a,b=Array.from(r.slice(0,g)),T=Array.from(r.slice((i-Th)*a,i*a));return e==="complex64"&&(b=Ih(b),T=Ih(T)),["["+b.map((x,I)=>xh(x,o[I],e)).join(", ")+", ..., "+T.map((x,I)=>xh(x,o[i-Th+I],e)).join(", ")+"]"]}let h=e==="complex64"?Ih(r):Array.from(r);return["["+h.map((g,b)=>xh(g,o[b],e)).join(", ")+"]"]}let p=t.slice(1),l=n.slice(1),m=n[0]*a,c=[];if(i>w1){for(let h=0;h<Th;h++){let g=h*m,b=g+m;c.push(...Pb(r.slice(g,b),p,e,l,o,!1))}c.push("...");for(let h=i-Th;h<i;h++){let g=h*m,b=g+m;c.push(...Pb(r.slice(g,b),p,e,l,o,h===i-1))}}else for(let h=0;h<i;h++){let g=h*m,b=g+m;c.push(...Pb(r.slice(g,b),p,e,l,o,h===i-1))}let d=u===2?",":"";c[0]="["+c[0]+d;for(let h=1;h<c.length-1;h++)c[h]=" "+c[h]+d;let f=`,
`;for(let h=2;h<u;h++)f+=`
`;return c[c.length-1]=" "+c[c.length-1]+"]"+(s?"":f),c}function Ih(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var bt=class{constructor(t,e,n){this.dtype=e;if(this.shape=t.slice(),this.size=rt(t),n!=null){let o=n.length;F(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||xv(e,this.size),this.strides=ci(t)}set(t,...e){e.length===0&&(e=[0]),F(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let o of t){if(o<0||o>=this.shape[e]){let s=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(s)}e++}let n=t[t.length-1];for(let o=0;o<t.length-1;++o)n+=this.strides[o]*t[o];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return Ka().makeTensor(this.values,this.shape,this.dtype)}},Ka=null,uc=null,q6=null;function F1(r){Ka=r}function R1(r){uc=r}function P1(r){q6=r}var qe=class{constructor(t,e,n,o){this.kept=!1;this.isDisposedInternal=!1;this.shape=t.slice(),this.dtype=e||"float32",this.size=rt(t),this.strides=ci(t),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return uc.buffer(this.shape,this.dtype,t)}bufferSync(){return uc.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Hp(this.shape,t,this.dtype==="complex64")}arraySync(){return Hp(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let t=Ka().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(n=>ic(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),Ka().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();let t=Ka().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>ic(e))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await Ka().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(Ka().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return uc.print(this,t)}clone(){return this.throwIfDisposed(),uc.clone(this)}toString(t=!1){let e=this.dataSync();return N1(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),uc.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),Ka().makeVariable(this,t,e,n)}};Object.defineProperty(qe,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function j6(){return dh("Tensor",()=>qe)}j6();var nu=class extends qe{constructor(e,n,o,s){super(e.shape,e.dtype,e.dataId,s);this.trainable=n;this.name=o}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Un(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ka().disposeTensor(this),this.dataId=e.dataId,Ka().incRef(this,null)}dispose(){Ka().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(nu,Symbol.hasInstance,{value:r=>r instanceof qe&&r.assign!=null&&r.assign instanceof Function});var Rs={};Xe(Rs,{assertTypesMatch:()=>Lv,getTensorsInContainer:()=>Ch,isTensorInList:()=>Y6,makeTypesMatch:()=>Qe});var M1=(i=>(i.R0="R0",i.R1="R1",i.R2="R2",i.R3="R3",i.R4="R4",i.R5="R5",i.R6="R6",i))(M1||{}),E1=(o=>(o.float32="float32",o.int32="int32",o.bool="int32",o.complex64="complex64",o))(E1||{}),_1=(o=>(o.float32="float32",o.int32="int32",o.bool="bool",o.complex64="complex64",o))(_1||{}),L1=(o=>(o.float32="float32",o.int32="float32",o.bool="float32",o.complex64="complex64",o))(L1||{}),$1=(o=>(o.float32="complex64",o.int32="complex64",o.bool="complex64",o.complex64="complex64",o))($1||{}),X6={float32:L1,int32:E1,bool:_1,complex64:$1};function $t(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return X6[r][t]}function ou(r){return $t(r,"int32")}function Qe(r,t){if(r.dtype===t.dtype)return[r,t];let e=$t(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function Lv(r,t){F(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function Y6(r,t){return t.some(e=>e.id===r.id)}function Ch(r){let t=[];return B1(r,t,new Set),t}function B1(r,t,e){if(r==null)return;if(r instanceof qe){t.push(r);return}if(!Z6(r))return;let n=r;for(let o in n){let s=n[o];e.has(s)||(e.add(s),B1(s,t,e))}}function Z6(r){return Array.isArray(r)||typeof r=="object"}function $v(r){return r.kernelName!=null}var Mb=class{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=!1;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},Eb=class{constructor(t){this.ENV=t;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new Mb}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(yi(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Rb(this.backendInstance),!0}setupRegisteredKernels(){Nb(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Nb(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=e.factory();if(n&&!(n instanceof no)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(a=>o<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,yi(`Initialization of backend ${t} failed`),yi(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return yi(`Initialization of backend ${t} failed`),yi(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let n=this.state.tensorInfo.get(e),o=n.backend,s=this.readSync(e),a=o.refCount(e);o.disposeData(e,!0),n.backend=t,t.move(e,s,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=e(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(t,e,n){t();try{let o=n();return e(),o}catch(o){throw e(),o}}nextTensorId(){return Eb.nextTensorId++}nextVariableId(){return Eb.nextVariableId++}clone(t){let e=D.runKernel(Vn,{x:t}),n={x:t},o=a=>({x:()=>{let i="float32",u={x:a},p={dtype:i};return D.runKernel(Wn,u,p)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[e],o,s,{}),e}runKernel(t,e,n){if(this.backendName==null&&this.backend,!(bh(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=o-e-s-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[],o=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let u,p=$v(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if($v(t)){let{kernelName:f,inputs:h,attrs:g}=t;this.backendName==null&&this.backend;let b=bh(f,this.backendName);F(b!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),i=()=>{let T=this.backend.numDataIds();u=b.kernelFunc({inputs:h,attrs:g,backend:this.backend});let x=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,T,x);let I=x.map(k=>k.rank!=null?k:this.makeTensorFromTensorInfo(k));if(o){let k=this.getTensorsForGradient(f,h,I);n=this.saveTensorsForBackwardMode(k)}return I}}else{let{forwardFunc:f}=t,h=g=>{!o||(n=g.map(b=>this.keep(this.clone(b))))};i=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,h));let b=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,g,b),b}}let{inputs:l,attrs:m}=t,c=$v(t)?null:t.backwardsFunc,d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=i():(d=this.profiler.profileKernel(p,l,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),e=d.outputs)}),o&&this.addTapeNode(p,l,e,c,n,m),this.state.profiling&&this.state.activeProfile.kernels.push({name:p,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map(f=>l[f]!=null?l[f].shape:null),outputShapes:e.map(f=>f.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,e,n){let o=wv(t);if(o!=null){let s=o.inputsToSave||[],a=o.outputsToSave||[],i;o.saveAllInputs?(F(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(e).map(p=>e[p])):i=s.map(p=>e[p]);let u=n.filter((p,l)=>a[l]);return i.concat(u)}return[]}makeTensor(t,e,n,o){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=t;n==="string"&&da(t[0])&&(s=t.map(u=>Qu(u)));let a=o.write(s,e,n),i=new qe(e,n,a,this.nextTensorId());if(this.trackTensor(i,o),n==="string"){let u=this.state.tensorInfo.get(a),p=kv(s);this.state.numBytes+=p-u.bytes,u.bytes=p}return i}makeTensorFromDataId(t,e,n,o){n=n||"float32";let s={dataId:t,shape:e,dtype:n};return this.makeTensorFromTensorInfo(s,o)}makeTensorFromTensorInfo(t,e){let{dataId:n,shape:o,dtype:s}=t,a=new qe(o,s,n,this.nextTensorId());return this.trackTensor(a,e),a}makeVariable(t,e=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==t.dtype&&(t=t.cast(o));let s=new nu(t,e,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(t,e){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let n=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(n=t.size*wb(t.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:n})),t instanceof nu||this.track(t)}incRef(t,e){this.trackTensor(t,e),this.backend.incRef(t.dataId)}removeDataId(t,e){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===e&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;let e=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=e.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){let n=t.size*wb(t.dtype);this.state.numBytes-=n}e.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,e.backend)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,n,o,s,a){let i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:s},u=wv(t);u!=null&&(o=u.gradFunc),o!=null&&(i.gradient=p=>(p=p.map((l,m)=>{if(l==null){let c=n[m],d=Rm(c.size,c.dtype);return this.makeTensor(d,c.shape,c.dtype)}return l}),o(p.length>1?p:p[0],s,a))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=Ch(t),n=new Set(e.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let a=this.state.activeScope.track[s];!a.kept&&!n.has(a.id)&&a.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(t,e,n,o=!1){if(F(e.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));F(s instanceof qe,()=>"The result y returned by f() must be a tensor.");let a=v1(this.state.activeTape,e,s);if(!o&&a.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let i={};i[s.id]=n??Q6(s.shape),A1(i,a,p=>this.tidy(p),J6);let u=e.map(p=>i[p.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(p=>{for(let l of p.saved)l.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(t){return F(mi(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{F(e.every(i=>i instanceof qe),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};e.forEach((i,u)=>{o[u]=i});let s=(i,u)=>(n=t(...e,u),F(n.value instanceof qe,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),F(mi(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(i,u)=>{let p=n.gradFunc(i,u),l=Array.isArray(p)?p:[p];F(l.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),F(l.every(c=>c instanceof qe),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let m={};return l.forEach((c,d)=>{m[d]=()=>c}),m};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:o})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,e){return this.state.tensorInfo.get(t).backend.readToGPU(t,e)}async time(t){let e=Qp(),n=await this.backend.time(t);return n.wallMs=Qp()-e,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Mb;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},kh=Eb;kh.nextTensorId=0,kh.nextVariableId=0;function Q6(r){let t=ph(rt(r),"float32");return D.makeTensor(t,r,"float32")}function Bv(){let r=Av();if(r._tfengine==null){let t=new ch(r);r._tfengine=new kh(t)}return a1(r._tfengine.ENV),F1(()=>r._tfengine),r._tfengine}var D=Bv();function J6(r,t){let e={a:r,b:t};return D.runKernel(Nn,e)}var Ju={};Xe(Ju,{isBrowser:()=>zv,isMobile:()=>r5,mockIsMobile:()=>t5});function e5(){return typeof navigator<"u"&&navigator!=null}var Ov;function t5(r){Ov=r}function r5(r){if(Ov!==void 0)return Ov;if(r||e5()){if(r||(r=navigator),r.product==="ReactNative")return!0;let t=r.userAgent||r.vendor||(typeof window<"u"?window.opera:"");if(!t){let e=r;return e.userAgentData&&e.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function zv(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}var Zo=B();Zo.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Zo.registerFlag("IS_BROWSER",()=>zv());Zo.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Zo.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Zo.registerFlag("PROD",()=>!1);Zo.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Zo.getBool("DEBUG"));Zo.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Zo.registerFlag("IS_TEST",()=>!1);Zo.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Zo.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Zo.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);Zo.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);function zr(r,t){let e=r;if(Sr(r))return t==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||Sr(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&B().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&z1(r,n,[]),n}function z1(r,t,e){if(e=e||[],!Array.isArray(r)&&!Sr(r)){F(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}F(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),F(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let n=t.slice(1);for(let o=0;o<r.length;++o)z1(r[o],n,e.concat(o))}function O1(r,t,e,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${r} tensor, but got ${t} tensor`)}}function S(r,t,e,n="numeric"){if(r instanceof qe)return O1(n,r.dtype,t,e),r;let o=Dm(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),O1(n,o,t,e),r==null||!Sr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}let s=zr(r,o);!Sr(r)&&!Array.isArray(r)&&(r=[r]);let i=o!=="string"?ac(r,o):ca(r,[],!0);return D.makeTensor(i,s,o)}function su(r,t,e,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,a)=>S(s,`${t}[${a}]`,e,n))}var Gv="__op";function A(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],n=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+Gv;let o=(...s)=>{D.startScope(e);try{let a=n(...s);return mh(a)&&console.error("Cannot return a Promise inside of tidy."),D.endScope(a),a}catch(a){throw D.endScope(null),a}};return Object.defineProperty(o,"name",{value:e,configurable:!0}),o}function n5(r,t){let e=S(r,"real","complex"),n=S(t,"imag","complex");Gt(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:e,imag:n};return D.runKernel(_u,o)}var Rn=A({complex_:n5});function dn(r,t,e,n){if(n==null&&(n=Dm(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Sr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){lh(t);let o=rt(t),s=rt(e);F(o===s,()=>`Based on the provided shape, [${t}], the tensor should have ${o} values but has ${s}`);for(let a=0;a<e.length;++a){let i=e[a],u=a===e.length-1?i!==rt(t.slice(a)):!0;F(e[a]===t[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Sr(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=n!=="string"?ac(r,n):ca(r,[],!0),D.makeTensor(r,t,n)}function wr(r,t,e){let n=zr(r,e);return dn(r,t,n,e)}var Sh={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var _b=4;async function U1(r,t){let e=[],n=[],o=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<o.length;++a){let i=o[a],u=Array.isArray(r)?r[a].tensor:r[i];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${u.dtype}`);let p={name:i,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let l=new Promise(async m=>{let c=await u.bytes(),d=c.reduce((g,b)=>g+b.length,0)+_b*c.length,f=new Uint8Array(d),h=0;for(let g=0;g<c.length;g++){let b=c[g],T=new Uint8Array(new Uint32Array([b.length]).buffer);f.set(T,h),h+=_b,f.set(b,h),h+=b.length}m(f)});n.push(l)}else n.push(u.data());t!=null&&(p.group=t),e.push(p)}let s=await Promise.all(n);return{data:o5(s),specs:e}}function Lb(r,t){let e={},n,o=0;for(let s of t){let a=s.name,i=s.dtype,u=s.shape,p=rt(u),l;if("quantization"in s){let m=s.quantization;if(m.dtype==="uint8"||m.dtype==="uint16"){if(!("min"in m&&"scale"in m))throw new Error(`Weight ${s.name} with quantization ${m.dtype} doesn't have corresponding metadata min and scale.`)}else if(m.dtype==="float16"){if(i!=="float32")throw new Error(`Weight ${s.name} is quantized with ${m.dtype} which only supports weights of type float32 not ${i}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${m.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let c=Sh[m.dtype],d=r.slice(o,o+p*c),f=m.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(i==="float32")if(m.dtype==="uint8"||m.dtype==="uint16"){l=new Float32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];l[h]=g*m.scale+m.min}}else if(m.dtype==="float16")n===void 0&&(n=u5()),l=n(f);else throw new Error(`Unsupported quantization type ${m.dtype} for weight type float32.`);else if(i==="int32"){if(m.dtype!=="uint8"&&m.dtype!=="uint16")throw new Error(`Unsupported quantization type ${m.dtype} for weight type int32.`);l=new Int32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];l[h]=Math.round(g*m.scale+m.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=p*c}else if(i==="string"){let m=rt(s.shape);l=[];for(let c=0;c<m;c++){let d=new Uint32Array(r.slice(o,o+_b))[0];o+=_b;let f=new Uint8Array(r.slice(o,o+d));l.push(f),o+=d}}else{let m=Sh[i],c=r.slice(o,o+p*m);if(i==="float32")l=new Float32Array(c);else if(i==="int32")l=new Int32Array(c);else if(i==="bool")l=new Uint8Array(c);else if(i==="complex64"){l=new Float32Array(c);let d=new Float32Array(l.length/2),f=new Float32Array(l.length/2);for(let b=0;b<d.length;b++)d[b]=l[b*2],f[b]=l[b*2+1];let h=wr(d,u,"float32"),g=wr(f,u,"float32");e[a]=Rn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${i}`);o+=p*m}i!=="complex64"&&(e[a]=wr(l,u,i))}return e}function o5(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(s=>{if(t+=s.byteLength,e.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(t),o=0;return e.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var Uv=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function G1(r){return Uv?Buffer.byteLength(r):new Blob([r]).size}function W1(r){if(Uv)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let n=0,o=t.length;n<o;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function K1(r){if(Uv){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function pc(r){if(r.length===1)return r[0];let t=0;r.forEach(o=>{t+=o.byteLength});let e=new Uint8Array(t),n=0;return r.forEach(o=>{e.set(new Uint8Array(o),n),n+=o.byteLength}),e.buffer}function Wv(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function $b(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:t};return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),e}async function lc(r,t){let e={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(e.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await t(r.weightsManifest);e.weightSpecs=n,e.weightData=o}return r.signature!=null&&(e.signature=r.signature),r.userDefinedMetadata!=null&&(e.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(e.modelInitializer=r.modelInitializer),e}function Ti(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:G1(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:G1(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function s5(){let r=e=>{let n=e<<13,o=0;for(;(n&8388608)===0;)o-=8388608,n<<=1;return n&=-8388609,o+=947912704,n|o},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function a5(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function i5(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function u5(){let r=s5(),t=a5(),e=i5();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let a=0;a<n.length;a++){let i=n[a],u=r[e[i>>10]+(i&1023)]+t[i>>10];s[a]=u}return new Float32Array(o)}}var Mt=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Mt.instance==null&&(Mt.instance=new Mt),Mt.instance}static registerSaveRouter(t){Mt.getInstance().saveRouters.push(t)}static registerLoadRouter(t){Mt.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return Mt.getHandlers(t,"save")}static getLoadHandlers(t,e){return Mt.getHandlers(t,"load",e)}static getHandlers(t,e,n){let o=[];return(e==="load"?Mt.getInstance().loadRouters:Mt.getInstance().saveRouters).forEach(a=>{let i=a(t,n);i!==null&&o.push(i)}),o}},V1=r=>Mt.registerSaveRouter(r),H1=r=>Mt.registerLoadRouter(r),q1=r=>Mt.getSaveHandlers(r),j1=(r,t)=>Mt.getLoadHandlers(r,t);var Kv="tensorflowjs",Vv=1,Jp="models_store",ep="model_info_store";function X1(){if(!B().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window>"u"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Hv(r){let t=r.result;t.createObjectStore(Jp,{keyPath:"modelPath"}),t.createObjectStore(ep,{keyPath:"modelPath"})}var xi=class{constructor(t){if(this.indexedDB=X1(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,o)=>{let s=this.indexedDB.open(Kv,Vv);s.onupgradeneeded=()=>Hv(s),s.onsuccess=()=>{let a=s.result;if(e==null){let i=a.transaction(Jp,"readonly"),p=i.objectStore(Jp).get(this.modelPath);p.onsuccess=()=>{if(p.result==null)return a.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(p.result.modelArtifacts)},p.onerror=l=>(a.close(),o(p.error)),i.oncomplete=()=>a.close()}else{let i=Ti(e),u=a.transaction(ep,"readwrite"),p=u.objectStore(ep),l=p.put({modelPath:this.modelPath,modelArtifactsInfo:i}),m;l.onsuccess=()=>{m=a.transaction(Jp,"readwrite");let d=m.objectStore(Jp).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:i});d.onsuccess=()=>n({modelArtifactsInfo:i}),d.onerror=f=>{p=u.objectStore(ep);let h=p.delete(this.modelPath);h.onsuccess=()=>(a.close(),o(d.error)),h.onerror=g=>(a.close(),o(d.error))}},l.onerror=c=>(a.close(),o(l.error)),u.oncomplete=()=>{m==null?a.close():m.oncomplete=()=>a.close()}}},s.onerror=a=>o(s.error)})}};xi.URL_SCHEME="indexeddb://";var Y1=r=>B().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(xi.URL_SCHEME)?p5(r.slice(xi.URL_SCHEME.length)):null;Mt.registerSaveRouter(Y1);Mt.registerLoadRouter(Y1);function p5(r){return new xi(r)}function l5(r){return r.startsWith(xi.URL_SCHEME)?r.slice(xi.URL_SCHEME.length):r}var Bb=class{constructor(){this.indexedDB=X1()}async listModels(){return new Promise((t,e)=>{let n=this.indexedDB.open(Kv,Vv);n.onupgradeneeded=()=>Hv(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(ep,"readonly"),i=s.objectStore(ep).getAll();i.onsuccess=()=>{let u={};for(let p of i.result)u[p.modelPath]=p.modelArtifactsInfo;t(u)},i.onerror=u=>(o.close(),e(i.error)),s.oncomplete=()=>o.close()},n.onerror=o=>e(n.error)})}async removeModel(t){return t=l5(t),new Promise((e,n)=>{let o=this.indexedDB.open(Kv,Vv);o.onupgradeneeded=()=>Hv(o),o.onsuccess=()=>{let s=o.result,a=s.transaction(ep,"readwrite"),i=a.objectStore(ep),u=i.get(t),p;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let l=i.delete(t),m=()=>{p=s.transaction(Jp,"readwrite");let d=p.objectStore(Jp).delete(t);d.onsuccess=()=>e(u.result.modelArtifactsInfo),d.onerror=f=>n(u.error)};l.onsuccess=m,l.onerror=c=>(m(),s.close(),n(u.error))}},u.onerror=l=>(s.close(),n(u.error)),a.oncomplete=()=>{p==null?s.close():p.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var au="/",mc="tensorflowjs_models",Z1="info",m5="model_topology",c5="weight_specs",d5="weight_data",f5="model_metadata";function Q1(r){return{info:[mc,r,Z1].join(au),topology:[mc,r,m5].join(au),weightSpecs:[mc,r,c5].join(au),weightData:[mc,r,d5].join(au),modelMetadata:[mc,r,f5].join(au)}}function J1(r){for(let t of Object.values(r))window.localStorage.removeItem(t)}function h5(r){let t=r.split(au);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(au)}function g5(r){return r.startsWith(Ii.URL_SCHEME)?r.slice(Ii.URL_SCHEME.length):r}var Ii=class{constructor(t){if(!B().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=Q1(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),o=Ti(t);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,W1(t.weightData));let s={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch{throw J1(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let i=JSON.parse(s);e.format=i.format,e.generatedBy=i.generatedBy,e.convertedBy=i.convertedBy,i.signature!=null&&(e.signature=i.signature),i.userDefinedMetadata!=null&&(e.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(e.modelInitializer=i.modelInitializer),i.trainingConfig!=null&&(e.trainingConfig=i.trainingConfig)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=K1(a),e}};Ii.URL_SCHEME="localstorage://";var e2=r=>B().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Ii.URL_SCHEME)?b5(r.slice(Ii.URL_SCHEME.length)):null;Mt.registerSaveRouter(e2);Mt.registerLoadRouter(e2);function b5(r){return new Ii(r)}var Ob=class{constructor(){F(B().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),F(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=mc+au,n=au+Z1;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(e)&&s.endsWith(n)){let a=h5(s);t[a]=JSON.parse(this.LS.getItem(s))}}return t}async removeModel(t){t=g5(t);let e=Q1(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return J1(e),n}};var cc="://",Mr=class{constructor(){this.managers={}}static getInstance(){return Mr.instance==null&&(Mr.instance=new Mr),Mr.instance}static registerManager(t,e){F(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(cc)&&(t=t.slice(0,t.indexOf(cc))),F(t.length>0,()=>"scheme must not be an empty string.");let n=Mr.getInstance();F(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){let e=Mr.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(Mr.getInstance().managers)}};function zb(r){if(r.indexOf(cc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Mr.getSchemes().join(",")}`);return{scheme:r.split(cc)[0],path:r.split(cc)[1]}}async function t2(r,t,e=!1){F(r!==t,()=>`Old path and new path are the same: '${r}'`);let n=Mt.getLoadHandlers(r);F(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),F(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=Mt.getSaveHandlers(t);F(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),F(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let a=s[0],i=zb(r).scheme,u=zb(r).path,p=i===zb(r).scheme,l=await o.load();e&&p&&await Mr.getManager(i).removeModel(u);let m=await a.save(l);return e&&!p&&await Mr.getManager(i).removeModel(u),m.modelArtifactsInfo}async function r2(){let r=Mr.getSchemes(),t={};for(let e of r){let n=await Mr.getManager(e).listModels();for(let o in n){let s=e+cc+o;t[s]=n[o]}}return t}async function n2(r){let t=zb(r);return Mr.getManager(t.scheme).removeModel(t.path)}async function o2(r,t){return t2(r,t,!1)}async function s2(r,t){return t2(r,t,!0)}var qv=class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}};if(B().get("IS_BROWSER")){B().setPlatform("browser",new qv);try{Mr.registerManager(Ii.URL_SCHEME,new Ob)}catch{}try{Mr.registerManager(xi.URL_SCHEME,new Bb)}catch{}}var T5={importFetch:()=>(a2(),c6(y5))},jv;var Xv=class{constructor(){this.util=i2(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return B().global.fetch!=null?B().global.fetch(t,e):(jv==null&&(jv=T5.importFetch()),jv(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}};B().get("IS_NODE")&&!B().get("IS_BROWSER")&&B().setPlatform("node",new Xv);function xe(r,t="float32",e){return t=t||"float32",lh(r),new bt(r,t,e)}function x5(r,t){let e=S(r,"x","cast");if(!Cv(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:e},o={dtype:t};return D.runKernel(Wn,n,o)}var oe=A({cast_:x5});function I5(r){let e={x:S(r,"x","clone","string_or_numeric")};return D.runKernel(Vn,e)}var fn=A({clone_:I5});function Gb(r,t=!1){console.log(r.toString(t))}Bv();var C5={buffer:xe,cast:oe,clone:fn,print:Gb};R1(C5);var Pn={};Xe(Pn,{browserFiles:()=>p2,browserHTTPRequest:()=>c2,concatenateArrayBuffers:()=>pc,copyModel:()=>o2,decodeWeights:()=>Lb,encodeWeights:()=>U1,fromMemory:()=>d2,fromMemorySync:()=>tA,getLoadHandlers:()=>j1,getModelArtifactsForJSON:()=>lc,getModelArtifactsInfoForJSON:()=>Ti,getSaveHandlers:()=>q1,http:()=>Kb,isHTTPScheme:()=>Wb,listModels:()=>r2,loadWeights:()=>l2,moveModel:()=>s2,registerLoadRouter:()=>H1,registerSaveRouter:()=>V1,removeModel:()=>n2,weightsLoaderFactory:()=>Jv,withSaveHandler:()=>f2,withSaveHandlerSync:()=>h2});var k5="model",S5=".json",v5=".weights.bin";function u2(r){return new Promise(t=>setTimeout(t)).then(r)}var Ub=class{constructor(t){if(!B().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(Ub.URL_SCHEME)&&(t=t.slice(Ub.URL_SCHEME.length)),(t==null||t.length===0)&&(t=k5),this.modelJsonFileName=t+S5,this.weightDataFileName=t+v5}async save(t){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],o=$b(t,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=s,await u2(()=>a.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let i=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;i.download=this.weightDataFileName,i.href=e,await u2(()=>i.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ti(t)}}}},dc=Ub;dc.URL_SCHEME="downloads://";var Yv=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.jsonFile=t[0],this.weightsFiles=t.slice(1)}async load(){return new Promise((t,e)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),a=s.modelTopology;if(a==null){e(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){e(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){t({modelTopology:a});return}let u=lc(s,p=>this.loadWeights(p));t(u)},n.onerror=o=>e(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(t){let e=[],n=[];for(let a of t)e.push(...a.weights),n.push(...a.paths);let o=this.checkManifestAndWeightFiles(t),s=n.map(a=>this.loadWeightsFile(a,o[a]));return Promise.all(s).then(a=>[e,pc(a)])}loadWeightsFile(t,e){return new Promise((n,o)=>{let s=new FileReader;s.onload=a=>{let i=a.target.result;n(i)},s.onerror=a=>o(`Failed to weights data from file of path '${t}'.`),s.readAsArrayBuffer(e)})}checkManifestAndWeightFiles(t){let e=[],n=this.weightsFiles.map(s=>Wv(s.name)),o={};for(let s of t)s.paths.forEach(a=>{let i=Wv(a);if(e.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(e.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);o[a]=this.weightsFiles[n.indexOf(i)]});if(e.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${e.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},A5=r=>B().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(dc.URL_SCHEME)?w5(r.slice(dc.URL_SCHEME.length)):null;Mt.registerSaveRouter(A5);function w5(r="model"){return new dc(r)}function p2(r){return new Yv(r)}function Zv(r,t,e,n){a(r),e=e??0,n=n??1,i(e,n);let o=0,s=u=>(u.then(p=>{let l=e+ ++o/r.length*(n-e);return t(l),p}),u);function a(u){F(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function i(u,p){F(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),F(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),F(p>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${p}`)}return Promise.all(r.map(s))}async function Qv(r,t){t==null&&(t={});let e=t.fetchFunc==null?B().platform.fetch:t.fetchFunc,n=r.map(m=>e(m,t.requestInit,{isBinary:!0})),o=0,s=.5,i=(t.onProgress==null?await Promise.all(n):await Zv(n,t.onProgress,o,s)).map(m=>m.arrayBuffer()),u=.5,p=1;return t.onProgress==null?await Promise.all(i):await Zv(i,t.onProgress,u,p)}async function l2(r,t="",e,n){return Jv(a=>Qv(a,{requestInit:n}))(r,t,e)}function Jv(r){return async(t,e="",n)=>{let o=t.map(()=>!1),s={},a=n!=null?n.map(()=>!1):[],i=[];if(t.forEach((d,f)=>{let h=0;d.weights.forEach(g=>{let b="quantization"in g?g.quantization.dtype:g.dtype,T=Sh[b]*rt(g.shape),x=()=>{o[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:h,sizeBytes:T})};n!=null?n.forEach((I,k)=>{I===g.name&&(x(),a[k]=!0)}):x(),i.push(g.name),h+=T})}),!a.every(d=>d)){let d=n.filter((f,h)=>!a[h]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}let u=o.reduce((d,f,h)=>(f&&d.push(h),d),[]),p=[];u.forEach(d=>{t[d].paths.forEach(f=>{let h=e+(e.endsWith("/")?"":"/")+f;p.push(h)})});let l=await r(p),m={},c=0;return u.forEach(d=>{let f=t[d].paths.length,h=0;for(let I=0;I<f;I++)h+=l[c+I].byteLength;let g=new ArrayBuffer(h),b=new Uint8Array(g),T=0;for(let I=0;I<f;I++){let k=new Uint8Array(l[c+I]);b.set(k,T),T+=k.byteLength}s[d].forEach(I=>{let k=g.slice(I.groupOffset,I.groupOffset+I.sizeBytes),w=Lb(k,[I.manifestEntry]);for(let R in w)m[R]=w[R]}),c+=f}),m}}var N5="application/octet-stream",D5="application/json",vh=class{constructor(t,e){this.DEFAULT_METHOD="POST";if(e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(F(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=B().platform.fetch,F(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&F(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],o=$b(t,n);e.body.append("model.json",new Blob([JSON.stringify(o)],{type:D5}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:N5}),"model.weights.bin");let s=await this.fetch(this.path,e);if(s.ok)return{modelArtifactsInfo:Ti(t),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch{let a=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}let n=e.modelTopology,o=e.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return lc(e,s=>this.loadWeights(s))}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=F5(e),s=this.weightPathPrefix||n,a=[];for(let l of t)a.push(...l.weights);let i=[],u=[];for(let l of t)for(let m of l.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(m)):i.push(s+m+o);this.weightUrlConverter&&i.push(...await Promise.all(u));let p=await Qv(i,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,pc(p)]}};vh.URL_SCHEME_REGEX=/^https?:\/\//;function F5(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),n=r.substring(0,t),o=e>t?r.substring(e):"";return[n+"/",o]}function Wb(r){return r.match(vh.URL_SCHEME_REGEX)!=null}var m2=(r,t)=>{if(typeof fetch>"u"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(n=>Wb(n)):e=Wb(r),e)return Kb(r,t)}return null};Mt.registerSaveRouter(m2);Mt.registerLoadRouter(m2);function Kb(r,t){return new vh(r,t)}function c2(r,t){return Kb(r,t)}var Ah=class{constructor(t){this.modelArtifacts=t}load(){return this.modelArtifacts}},Vb=class{constructor(t){this.saveHandler=t}save(t){return this.saveHandler(t)}},eA=class{constructor(t){t.load&&(this.load=()=>Promise.resolve(t.load())),t.save&&(this.save=e=>Promise.resolve(t.save(e)))}};function d2(r,t,e,n){let o=arguments;return new eA(tA(...o))}function tA(r,t,e,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new Ah(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ah({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Ah({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:n}))}function f2(r){return new Vb(r)}function h2(r){return new Vb(r)}var y2={};Xe(y2,{confusionMatrix:()=>b2});function R5(r,t,e=!1,n=!1){let o=S(r,"a","matMul"),s=S(t,"b","matMul");[o,s]=Qe(o,s);let a={a:o,b:s},i={transposeA:e,transposeB:n};return D.runKernel(uo,a,i)}var je=A({matMul_:R5});function P5(r,t,e=1,n=0,o="int32"){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let a={indices:S(r,"indices","oneHot","int32")},i={dtype:o,depth:t,onValue:e,offValue:n};return D.runKernel(Ra,a,i)}var tp=A({oneHot_:P5});function Dxe(){B().set("PROD",!0)}function Fxe(){B().set("DEBUG",!0)}function Rxe(){B().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function rA(r){B().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}P1(rA);function Pxe(){D.disposeVariables()}function Mn(){return D}function wh(){return D.memory()}function Mxe(r){return D.profile(r)}function U(r,t){return D.tidy(r,t)}function Pe(r){Ch(r).forEach(e=>e.dispose())}function Ut(r){return D.keep(r)}function Exe(r){return D.time(r)}function M5(r){return D.setBackend(r)}function _xe(){return D.ready()}function Lxe(){return D.backendName}function $xe(r){D.removeBackend(r)}function Bxe(r){return D.findBackend(r)}function Oxe(r){return D.findBackendFactory(r)}function rp(r,t,e=1){return D.registerBackend(r,t,e)}function g2(){return D.backend}function zxe(r,t){B().setPlatform(r,t)}function E5(r){let e={input:S(r,"input","imag")};return D.runKernel(zu,e)}var np=A({imag_:E5});function _5(r){let e={x:S(r,"x","neg")};return D.runKernel(hs,e)}var et=A({neg_:_5});function L5(r){let e={input:S(r,"input","real")};return D.runKernel(Wu,e)}var iu=A({real_:L5});function $5(r,t,e){let n=S(r,"x","transpose");if(t==null&&(t=n.shape.map((a,i)=>i).reverse()),F(n.rank===t.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${t}.`),t.forEach(a=>{F(a>=0&&a<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${t}`)}),n.rank<=1)return n.clone();let o={x:n},s={perm:t};return n.dtype==="complex64"?U(()=>{let a=iu(n),i=np(n);return a=D.runKernel(Fn,{x:a},s),i=D.runKernel(Fn,{x:i},s),e&&(i=et(i)),Rn(a,i)}):D.runKernel(Fn,o,s)}var Ke=A({transpose_:$5});function B5(r,t,e){let n=S(r,"labels","confusionMatrix"),o=S(t,"predictions","confusionMatrix");F(e==null||e>0&&Number.isInteger(e),()=>`If provided, numClasses must be a positive integer, but got ${e}`),F(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),F(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),F(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),F(e>0&&Number.isInteger(e),()=>`numClasses is required to be a positive integer, but got ${e}`);let s=tp(oe(n,"int32"),e),a=tp(oe(o,"int32"),e),i=Ke(s),u=je(i,a);return oe(u,"int32")}var b2=A({confusionMatrix_:B5});var Nr={};Xe(Nr,{assertAndGetBroadcastShape:()=>ze,getBroadcastDims:()=>T2,getReductionAxes:()=>At});function T2(r,t){let e=r.length,n=[];for(let o=0;o<e;o++){let s=e-1-o,a=r[s]||1;(t[t.length-1-o]||1)>1&&a===1&&n.unshift(s)}return n}function At(r,t){let e=[];for(let n=0;n<t.length;n++){let o=r[r.length-n-1],s=t.length-n-1,a=t[s];(o==null||o===1&&a>1)&&e.unshift(s)}return e}function ze(r,t){let e=[],n=Math.max(r.length,t.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let a=t[t.length-o-1];if(a==null&&(a=1),s===1)e.unshift(a);else if(a===1)e.unshift(s);else if(s!==a){let i=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(i)}else e.unshift(s)}return e}var qb={};Xe(qb,{fromPixels:()=>V5,fromPixelsAsync:()=>W5,toPixels:()=>K5});function Hb(r,t,e){if(oo(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=zr(r,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return dn(r,t,n,e)}var el;function x2(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,o=!1,s=!1,a=!1,i=!1;if(r.data instanceof Uint8Array)e=!0;else if(typeof ImageData<"u"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement<"u"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&r instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(bh(jp,D.backendName)!=null){let f={pixels:r},h={numChannels:t};return D.runKernel(jp,f,h)}let[p,l]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],m;if(a)m=r.getContext("2d").getImageData(0,0,p,l).data;else if(n||e)m=r.data;else if(s||o||i){if(el==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")el=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else el=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});el.canvas.width=p,el.canvas.height=l,el.drawImage(r,0,0,p,l),m=el.getImageData(0,0,p,l).data}let c;if(t===4)c=new Int32Array(m);else{let f=p*l;c=new Int32Array(f*t);for(let h=0;h<f;h++)for(let g=0;g<t;++g)c[h*t+g]=m[h*4+g]}return Hb(c,[l,p,t],"int32")}function O5(r){return r!=null&&r.data instanceof Uint8Array}function z5(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function G5(r){return r!=null&&r.width!==0&&r.height!==0}function U5(r){return z5()&&!(r instanceof ImageBitmap)&&G5(r)&&!O5(r)}async function W5(r,t=3){let e=null;if(B().getBool("WRAP_TO_IMAGEBITMAP")&&U5(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===r.width&&n.height===r.height?e=n:e=r}else e=r;return x2(e,t)}async function K5(r,t){let e=S(r,"img","toPixels");if(!(r instanceof qe)){let p=e;e=oe(p,"int32"),p.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[n,o]=e.shape.slice(0,2),s=e.rank===2?1:e.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let a=await e.data(),i=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let p=0;p<n*o;++p){let l=[0,0,0,255];for(let c=0;c<s;c++){let d=a[p*s+c];if(e.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(e.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(l[0]=d*i,l[1]=d*i,l[2]=d*i):l[c]=d*i}let m=p*4;u[m+0]=Math.round(l[0]),u[m+1]=Math.round(l[1]),u[m+2]=Math.round(l[2]),u[m+3]=Math.round(l[3])}if(t!=null){t.width=o,t.height=n;let p=t.getContext("2d"),l=new ImageData(u,o,n);p.putImageData(l,0,0)}return e!==r&&e.dispose(),u}var V5=A({fromPixels_:x2});var jb={};Xe(jb,{prepareAndValidate:()=>I2});function I2(r,t){let e=r.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(rt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=t.shape,s=o[o.length-1],a=1;for(let m=0;m<o.length-1;++m)a*=o[m];let i=r.shape,u=o.slice();u.pop();let p=1;for(let m=s;m<e;++m)p*=i[m],u.push(i[m]);let l=[...ci(r.shape).map(m=>m/p),1].slice(0,s);return[u,a,p,l]}var Nh={};Xe(Nh,{calculateShapes:()=>C2,validateInput:()=>Xb,validateUpdateShape:()=>nA});function nA(r,t,e){let n=t.rank>1?t.shape[t.rank-1]:1,o=t.rank>1?t.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(e.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(e.rank-o))throw new Error(s+` Output shape length < ${n+(e.rank-o)}`);if(e.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let a=0;a<o;++a)if(e.shape[a]!==t.shape[a])throw new Error(s+` updates.shape[${a}] (${e.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<e.rank-o;++a)if(e.shape[a+o]!==r[a+n])throw new Error(s+` updates.shape[${a+o}] (${e.shape[a+o]}) != shape[${a+o}] (${r[a+o]})`)}function Xb(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}nA(e,t,r)}function C2(r,t,e){let n=t.shape.length,o=n>1?t.shape[n-1]:1,s=e.length,a=1;for(let m=o;m<s;++m)a*=e[m];let i=o<1?1:o,u=rt(t.shape)/i,p=[...ci(e.slice(0,o)),1],l=rt(e);return{sliceRank:o,numUpdates:u,sliceSize:a,strides:p,outputSize:l}}var It={};Xe(It,{assertParamsValid:()=>q5,computeFlatOffset:()=>Q5,computeOutShape:()=>X5,getNormalizedAxes:()=>Y5,isSliceContinous:()=>Z5,maskToAxes:()=>j5,parseSliceParams:()=>sA,sliceInfo:()=>J5,startForAxis:()=>F2,startIndicesWithElidedDims:()=>w2,stopForAxis:()=>R2,stopIndicesWithElidedDims:()=>N2,stridesForAxis:()=>D2,stridesWithElidedDims:()=>S2});var oA=-2,H5=-1;function q5(r,t,e){let n=r.shape.length;F(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),F(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)F(t[o]+e[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${t[o]+e[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function j5(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function X5(r,t,e){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((t[o]-r[o])/e[o]);return n}function S2(r,t,e,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<e;s++)s===0?o[t]=1:(o.splice(t,0,1),o.pop());return o}function v2(r,t,e){return e<=r?e:e-(t-1)}function A2(r,t){let e=[];for(let n=0;n<r;n++)e.push(t+n);return e}function Y5(r,t,e,n,o,s,a,i,u){let p=r.length,l=new Array(p),m=new Array(p),c=new Array(p);if(t.length&&e>0){let d=t[0],f=e+1;l=w2(a,d,f,n,r),m=N2(i,d,f,o,r),c=S2(s,d,f,r)}else for(let d=0;d<p;d++)l[d]=F2(a,n,s,r,d,u),m[d]=R2(i,o,s,r,d,u),c[d]=D2(s,d,u);return{begin:l,end:m,strides:c}}function w2(r,t,e,n,o){let s=[...o],a=A2(e,t);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=0;else{let u=v2(t,e,i),p=n[u];r&1<<u&&(p=0),s[i]=p}return s}function N2(r,t,e,n,o){let s=[...o],a=A2(e,t);for(let i=0;i<s.length;i++)if(a.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{let u=v2(t,e,i),p=n[u];r&1<<u&&(p=Number.MAX_SAFE_INTEGER),s[i]=p}for(let i=0;i<s.length;i++){let u=o[i];s[i]<0&&(s[i]+=u),s[i]=Nm(0,s[i],o[i])}return s}function D2(r,t,e){let n=r[t];return(e&1<<t||n==null)&&(n=1),n}function F2(r,t,e,n,o,s){let a=t[o],i=e[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),a=Nm(0,a,u-1),a}function R2(r,t,e,n,o,s){let a=t[o],i=e[o]||1;(r&1<<o||s&1<<o||a==null)&&(i>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let u=n[o];return a<0&&(a+=u),i>0?a=Nm(0,a,u):a=Nm(-1,a,u-1),a}function Z5(r,t,e){let n=e.length;for(let o=0;o<e.length;o++)if(e[o]>1){n=o;break}for(let o=n+1;o<e.length;o++)if(t[o]>0||e[o]!==r[o])return!1;return!0}function Q5(r,t){let e=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)e+=r[n]*t[n];return e}function sA(r,t,e){let n,o=r.shape.length;typeof t=="number"?n=[t,...new Array(o-1).fill(0)]:t.length<o?n=t.concat(new Array(o-t.length).fill(0)):n=t.slice(),n.forEach(a=>{F(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return e==null?s=new Array(o).fill(-1):typeof e=="number"?s=[e,...new Array(o-1).fill(-1)]:e.length<o?s=e.concat(new Array(o-e.length).fill(-1)):s=e,s=s.map((a,i)=>a>=0?a:(F(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${i}.`),r.shape[i]-n[i])),[n,s]}function J5(r,t,e,n,o,s,a,i,u){let p;if(n==null?(p=new Array(t.length),p.fill(1)):p=n,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let l=!1,m={dims:p.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:e.slice(),strides:p.slice(),beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};for(let x=0;x<m.dims;x++)l&&(1<<x&i)!==0&&m.numAddAxisAfterEllipsis++,1<<x&a&&(l=!0);l||(m.ellipsisMask|=1<<m.dims,m.dims++);let c={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};e8(m,c);let d=!0,f=!0,h=!0,g=[],b=[];for(let x=0;x<r.length;++x){if(c.strides[x]===0)throw Error(`strides[${x}] must be non-zero`);let I=!!(c.shrinkAxisMask&1<<x),k=r[x];if(k===-1){g.push(I?1:-1);continue}let w=[c.beginMask&1<<x,c.endMask&1<<x],R=[c.strides[x]>0?0:-1,c.strides[x]>0?k:k-1];if(I&&c.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&c.strides[x]===1;let P=!!(c.beginMask&1<<x&&c.endMask&1<<x);if(c.beginValid&&c.endValid){if(I){let W=c.begin[x]<0?k+c.begin[x]:c.begin[x];if(c.begin[x]=W,c.end[x]=c.begin[x]+1,W<0||W>=k)throw Error(`slice index ${c.begin[x]} of dimension ${x} out of bounds.`)}else c.begin[x]=k2(c.begin[x],0,c.strides[x],k,w,R),c.end[x]=k2(c.end[x],1,c.strides[x],k,w,R);let z=c.strides[x]===1&&c.begin[x]===0&&c.end[x]===k;d=d&&z,f=f&&(x===0&&c.strides[x]===1||z)}else d=d&&c.strides[x]===1&&P,f=f&&(x===0&&c.strides[x]===1||P);let M,L=!1;if(c.beginValid&&c.endValid?(M=c.end[x]-c.begin[x],L=!0):I?(M=1,L=!0):P&&k>=0&&(c.strides[x]<0?M=-k:M=k,L=!0),L){let z;M===0||M<0!=c.strides[x]<0?z=0:z=Math.trunc(M/c.strides[x])+(M%c.strides[x]!==0?1:0),g.push(z)}else g.push(-1)}for(let x=0;x<c.finalShapeGatherIndices.length;++x){let I=c.finalShapeGatherIndices[x];I>=0?b.push(g[I]):I===oA&&b.push(1)}return{finalShapeSparse:b.filter((x,I)=>c.finalShapeGatherIndices[I]!==oA),finalShape:b,isIdentity:d,sliceDim0:f,isSimpleSlice:h,begin:c.begin,end:c.end,strides:c.strides}}function e8(r,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let e=0;t.beginValid=r.begin!=null,t.endValid=r.end!=null,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(t.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,t.dims);for(;e<o;e++)t.begin[e]=0,t.end[e]=0,t.strides[e]=1,t.beginMask|=1<<e,t.endMask|=1<<e,t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[e]=n}else if(1<<n&r.newAxisMask)t.finalShapeGatherIndices.push(oA),t.finalShapeGatherIndicesSparse.push(-1);else{if(e===t.begin.length)throw Error(`Index out of range using input dim ${e}; input has only ${t.dims} dims, ${t.begin.length}.`);r.begin!=null&&(t.begin[e]=r.begin[n]),r.end!=null&&(t.end[e]=r.end[n]),t.strides[e]=r.strides[n],r.beginMask&1<<n&&(t.beginMask|=1<<e),r.endMask&1<<n&&(t.endMask|=1<<e),r.shrinkAxisMask&1<<n?(t.finalShapeGatherIndices.push(H5),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<e):(t.finalShapeGatherIndices.push(e),t.finalShapeGatherIndicesSparse.push(n)),t.inputShapeGatherIndicesSparse[e]=n,e++}}function k2(r,t,e,n,o,s){if(o[t])return e>0?s[t]:s[t+1&1];{let a=r<0?n+r:r;return a<s[0]?s[0]:a>s[1]?s[1]:a}}var te={};Xe(te,{Serializable:()=>Dh,SerializationMap:()=>Ci,registerClass:()=>En});var Dh=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},Ci=class{constructor(){this.classNameMap={}}static getMap(){return Ci.instance==null&&(Ci.instance=new Ci),Ci.instance}static register(t){Ci.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function En(r){F(r.className!=null,()=>"Class being registered does not have the static className property defined."),F(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),F(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Ci.register(r)}var _2={};Xe(_2,{TEST_EPSILON_FLOAT16:()=>P2,createVideoElement:()=>i8,encodeStrings:()=>E2,expectArrayBuffersEqual:()=>a8,expectArraysClose:()=>r8,expectArraysEqual:()=>o8,expectNumbersClose:()=>M2,expectPromiseToFail:()=>n8,expectValuesInRange:()=>s8,play:()=>u8,testEpsilon:()=>Yb});var t8=.001,P2=.1;function r8(r,t,e){return e==null&&(e=Yb()),aA(r,t,(n,o)=>iA(n,o,e))}function Yb(){return D.backend.floatPrecision()===32?t8:P2}function aA(r,t,e){let n=!0;if((Sr(r)||Sr(t))&&(n=!1),Sr(r)&&Sr(t)&&(n=!0),n){let a=r.constructor.name,i=t.constructor.name;if(a!==i)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${i}`)}if(Array.isArray(r)&&Array.isArray(t)){let a=zr(r),i=zr(t);if(!Un(a,i))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${i}]`)}let o=Sr(r)?r:ca(r),s=Sr(t)?t:ca(t);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let a=0;a<s.length;++a){let i=o[a],u=s[a];if(!e(i,u))throw new Error(`Arrays differ: actual[${a}] = ${i}, expected[${a}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}typeof expect<"u"&&expect().nothing()}function n8(r,t){r().then(()=>t.fail(),()=>t()),typeof expect<"u"&&expect().nothing()}function o8(r,t){let e=typeof t=="string"||typeof t=="number"||typeof t=="boolean"?[t]:t;return da(r)||da(r[0])||da(t)||da(t[0])?aA(r,e,(n,o)=>n==o):aA(r,t,(n,o)=>iA(n,o,0))}function M2(r,t,e){if(e==null&&(e=Yb()),!iA(r,t,e))throw new Error(`Numbers differ: actual === ${r}, expected === ${t}`);typeof expect<"u"&&expect().nothing()}function iA(r,t,e){return!isFinite(r)&&!isFinite(t)?!0:!(isNaN(r)||isNaN(t)||Math.abs(r-t)>e)}function s8(r,t,e){for(let n=0;n<r.length;n++)if(r[n]<t||r[n]>e)throw new Error(`Value out of range:${r[n]} low: ${t}, high: ${e}`)}function a8(r,t){let e=new Float32Array(r),n=new Float32Array(t);if(e.length!==n.length)throw new Error(`Expected ArrayBuffer to be of length ${n.length}, but it was ${e.length}`);for(let o=0;o<n.length;o++)if(e[o]!==n[o])throw new Error(`Expected ArrayBuffer value at ${o} to be ${n[o]} but got ${e[o]} instead`)}function E2(r){for(let t=0;t<r.length;t++){let e=r[t];Array.isArray(e)?E2(e):r[t]=Qu(e)}return r}function i8(r){let t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(r),new Promise(e=>{t.addEventListener("loadeddata",n=>e(t)),t.load()})}async function u8(r){await r.play(),"requestVideoFrameCallback"in r&&await new Promise(t=>{r.requestVideoFrameCallback(t)})}var p8="0.0.0";function l8(r,t){let e=S(r,"a","add"),n=S(t,"b","add");[e,n]=Qe(e,n);let o={a:e,b:n};return D.runKernel(Nn,o)}var Z=A({add_:l8});function m8(r,t){let e=S(r,"a","floorDiv"),n=S(t,"b","floorDiv");[e,n]=Qe(e,n);let o={a:e,b:n};return D.runKernel(Io,o)}var Zb=A({floorDiv_:m8});function c8(r,t){let e=S(r,"a","div"),n=S(t,"b","div");if([e,n]=Qe(e,n),e.dtype==="int32"&&n.dtype==="int32")return Zb(e,n);let o={a:e,b:n},s={};return D.runKernel(bo,o,s)}var me=A({div_:c8});function d8(r,t){let e=S(r,"a","mul"),n=S(t,"b","mul");[e,n]=Qe(e,n);let o={a:e,b:n};return D.runKernel(Mo,o)}var _=A({mul_:d8});function f8(r){let t=S(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return D.runKernel(Lu,e)}else{let e={x:t};return D.runKernel(ls,e)}}var Wt=A({abs_:f8});function h8(r){let e={x:S(r,"x","acos")};return D.runKernel(Li,e)}var L2=A({acos_:h8});function g8(r){let e={x:S(r,"x","acosh")};return D.runKernel($i,e)}var $2=A({acosh_:g8});function b8(r){F(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),F(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let t=r.map((o,s)=>S(o,`tensors${s}`,"addN")),e=t[0];t.forEach(o=>{if(o.dtype!==e.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),t.forEach(o=>{if(!Un(o.shape,e.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=t;return D.runKernel(so,n)}var B2=A({addN_:b8});function y8(r,t=null,e=!1){let o={x:S(r,"x","all","bool")},s={axis:t,keepDims:e};return D.runKernel(Bi,o,s)}var Qb=A({all_:y8});function T8(r,t=null,e=!1){let o={x:S(r,"x","any","bool")},s={axis:t,keepDims:e};return D.runKernel(Oi,o,s)}var Fh=A({any_:T8});function x8(r,t=0){let n={x:S(r,"x","argMax")},o={axis:t};return D.runKernel(ao,n,o)}var op=A({argMax_:x8});function I8(r,t=0){let n={x:S(r,"x","argMin")},o={axis:t};return D.runKernel(di,n,o)}var O2=A({argMin_:I8});function C8(r){let e={x:S(r,"x","asin")};return D.runKernel(zi,e)}var z2=A({asin_:C8});function k8(r){let e={x:S(r,"x","asinh")};return D.runKernel(Gi,e)}var G2=A({asinh_:k8});function S8(r){let e={x:S(r,"x","atan")};return D.runKernel(Ui,e)}var U2=A({atan_:S8});function v8(r,t){let e=S(r,"a","atan2"),n=S(t,"b","atan2");[e,n]=Qe(e,n);let o={a:e,b:n};return D.runKernel(fa,o)}var W2=A({atan2_:v8});function A8(r){let e={x:S(r,"x","atanh")};return D.runKernel(Wi,e)}var K2=A({atanh_:A8});function w8(r,t,e,n,o="NHWC",s){let a=r[3],i=[...t,a],u=H2(o);return rl(r,i,e,s,n,null,null,u)}function pA(r,t,e,n,o,s,a="channelsLast"){let[i,u]=Jb(t),p;if(a==="channelsLast")p=[i,u,r[3],r[3]];else if(a==="channelsFirst")p=[i,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return rl(r,p,e,n,o,s,!1,a)}function N8(r,t,e,n,o,s,a="NDHWC"){let[i,u,p]=uA(t),l,m;if(a==="NDHWC")m="channelsLast",l=[i,u,p,r[4],r[4]];else if(a==="NCDHW")m="channelsFirst",l=[i,u,p,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return V2(r,l,e,n,o,!1,m,s)}function rl(r,t,e,n,o,s,a=!1,i="channelsLast"){let[u,p,l,m]=[-1,-1,-1,-1];if(i==="channelsLast")[u,p,l,m]=r;else if(i==="channelsFirst")[u,m,p,l]=r;else throw new Error(`Unknown dataFormat ${i}`);let[c,d,,f]=t,[h,g]=Jb(e),[b,T]=Jb(n),x=fc(c,b),I=fc(d,T),{padInfo:k,outHeight:w,outWidth:R}=R8(o,p,l,h,g,x,I,s,i),P=a?f*m:f,M;return i==="channelsFirst"?M=[u,P,w,R]:i==="channelsLast"&&(M=[u,w,R,P]),{batchSize:u,dataFormat:i,inHeight:p,inWidth:l,inChannels:m,outHeight:w,outWidth:R,outChannels:P,padInfo:k,strideHeight:h,strideWidth:g,filterHeight:c,filterWidth:d,effectiveFilterHeight:x,effectiveFilterWidth:I,dilationHeight:b,dilationWidth:T,inShape:r,outShape:M,filterShape:t}}function V2(r,t,e,n,o,s=!1,a="channelsLast",i){let[u,p,l,m,c]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,p,l,m,c]=r;else if(a==="channelsFirst")[u,c,p,l,m]=r;else throw new Error(`Unknown dataFormat ${a}`);let[d,f,h,,g]=t,[b,T,x]=uA(e),[I,k,w]=uA(n),R=fc(d,I),P=fc(f,k),M=fc(h,w),{padInfo:L,outDepth:z,outHeight:W,outWidth:V}=P8(o,p,l,m,b,T,x,R,P,M,i),j=s?g*c:g,H;return a==="channelsFirst"?H=[u,j,z,W,V]:a==="channelsLast"&&(H=[u,z,W,V,j]),{batchSize:u,dataFormat:a,inDepth:p,inHeight:l,inWidth:m,inChannels:c,outDepth:z,outHeight:W,outWidth:V,outChannels:j,padInfo:L,strideDepth:b,strideHeight:T,strideWidth:x,filterDepth:d,filterHeight:f,filterWidth:h,effectiveFilterDepth:R,effectiveFilterHeight:P,effectiveFilterWidth:M,dilationDepth:I,dilationHeight:k,dilationWidth:w,inShape:r,outShape:H,filterShape:t}}function D8(r,t,e,n,o){n==null&&(n=lA(r,t,e));let s=r[0],a=r[1],i=tl((s-t+2*n)/e+1,o),u=tl((a-t+2*n)/e+1,o);return[i,u]}function F8(r,t,e,n,o,s){o==null&&(o=lA(r,t,n));let a=r[0],i=r[1],u=r[2],p=tl((a-t+2*o)/n+1,s),l=tl((i-t+2*o)/n+1,s),m=tl((u-t+2*o)/n+1,s);return[p,l,m,e]}function lA(r,t,e,n=1){let o=fc(t,n);return Math.floor((r[0]*(e-1)-e+o)/2)}function Jb(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function uA(r){return typeof r=="number"?[r,r,r]:r}function fc(r,t){return t<=1?r:r+(r-1)*(t-1)}function R8(r,t,e,n,o,s,a,i,u){let p,l,m;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let d=D8([t,e],s,n,r,i);l=d[0],m=d[1]}else if(r==="same"){l=Math.ceil(t/n),m=Math.ceil(e/o);let c=Math.max(0,(l-1)*n+s-t),d=Math.max(0,(m-1)*o+a-e),f=Math.floor(c/2),h=c-f,g=Math.floor(d/2),b=d-g;p={top:f,bottom:h,left:g,right:b,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,type:"VALID"},l=Math.ceil((t-s+1)/n),m=Math.ceil((e-a+1)/o);else if(typeof r=="object"){let c=u==="channelsLast"?r[1][0]:r[2][0],d=u==="channelsLast"?r[1][1]:r[2][1],f=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];p={top:c,bottom:d,left:f,right:h,type:c===0&&d===0&&f===0&&h===0?"VALID":"EXPLICIT"},l=tl((t-s+c+d)/n+1,i),m=tl((e-a+f+h)/o+1,i)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outHeight:l,outWidth:m}}function P8(r,t,e,n,o,s,a,i,u,p,l){let m,c,d,f;if(typeof r=="number"){m={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=F8([t,e,n,1],i,1,o,r,l);c=g[0],d=g[1],f=g[2]}else if(r==="same"){c=Math.ceil(t/o),d=Math.ceil(e/s),f=Math.ceil(n/a);let h=(c-1)*o+i-t,g=(d-1)*s+u-e,b=(f-1)*a+p-n,T=Math.floor(h/2),x=h-T,I=Math.floor(g/2),k=g-I,w=Math.floor(b/2),R=b-w;m={top:I,bottom:k,left:w,right:R,front:T,back:x,type:"SAME"}}else if(r==="valid")m={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},c=Math.ceil((t-i+1)/o),d=Math.ceil((e-u+1)/s),f=Math.ceil((n-p+1)/a);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:m,outDepth:c,outHeight:d,outWidth:f}}function tl(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Qo(r){let[t,e,n]=Jb(r);return t===1&&e===1&&n===1}function Er(r,t){return Qo(r)||Qo(t)}function H2(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Et(r,t,e){if(e!=null){if(typeof t=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);if(typeof t=="number")F(_i(t),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${t}.`);else if(typeof t=="object")t.forEach(n=>{n.forEach(o=>{F(_i(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${e} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${t}`)}}function M8(r,t){let n={x:S(r,"x","reshape","string_or_numeric")},o={shape:t};return D.runKernel(ys,n,o)}var $=A({reshape_:M8});function E8(r,t,e,n,o){let s=S(r,"x","avgPool","float32"),a=1;F(Er(e,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);let i=s,u=!1;s.rank===3&&(u=!0,i=$(s,[1,s.shape[0],s.shape[1],s.shape[2]])),F(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),Et("avgPool",n,o);let p={x:i},l={filterSize:t,strides:e,pad:n,dimRoundingMode:o},m=D.runKernel(io,p,l);return m=oe(m,s.dtype),u?$(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var hc=A({avgPool_:E8});function _8(r,t,e,n,o,s="NDHWC"){let a=S(r,"x","avgPool3d","float32"),i=a,u=!1;a.rank===4&&(u=!0,i=$(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),F(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),F(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Et("avgPool3d",n,o);let p={x:i},l={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},m=D.runKernel(Eu,p,l);return m=oe(m,i.dtype),u?$(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var ey=A({avgPool3d_:_8});function L8(r,t=0){F(r.length>=1,()=>"Pass at least one tensor to concat");let e=su(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),e.length===1)return fn(e[0]);let n=e,o={axis:t};return D.runKernel(cs,n,o)}var ct=A({concat_:L8});function $8(r){let e={x:S(r,"x","sigmoid","float32")};return D.runKernel(Ko,e)}var _n=A({sigmoid_:$8});function B8(r,t,e){let n=S(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:t,size:e};return D.runKernel(xs,o,s)}var Ge=A({slice_:B8});function O8(r){let e={x:S(r,"x","tanh","float32")};return D.runKernel(Yo,e)}var sp=A({tanh_:O8});function z8(r,t,e,n,o,s){let a=S(r,"forgetBias","basicLSTMCell"),i=S(t,"lstmKernel","basicLSTMCell"),u=S(e,"lstmBias","basicLSTMCell"),p=S(n,"data","basicLSTMCell"),l=S(o,"c","basicLSTMCell"),m=S(s,"h","basicLSTMCell"),c=ct([p,m],1),d=je(c,i),f=Z(d,u),h=f.shape[0],g=f.shape[1]/4,b=[h,g],T=Ge(f,[0,0],b),x=Ge(f,[0,g],b),I=Ge(f,[0,g*2],b),k=Ge(f,[0,g*3],b),w=Z(_(_n(T),sp(x)),_(l,_n(Z(a,I)))),R=_(sp(w),_n(k));return[w,R]}var q2=A({basicLSTMCell_:z8});function G8(r,t,e){let n=S(r,"x","batchToSpaceND"),o=t.reduce((i,u)=>i*u);F(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),F(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),F(n.shape[0]%o===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${o}`);let s={x:n},a={blockShape:t,crops:e};return D.runKernel(ms,s,a)}var gc=A({batchToSpaceND_:G8});function j2(r){let t;return r.rank===0||r.rank===1?t=$(r,[1,1,1,r.size]):r.rank===2?t=$(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=$(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function U8(r,t,e,n,o,s){s==null&&(s=.001);let a=S(r,"x","batchNorm"),i=S(t,"mean","batchNorm"),u=S(e,"variance","batchNorm"),p;o!=null&&(p=S(o,"scale","batchNorm"));let l;n!=null&&(l=S(n,"offset","batchNorm")),F(i.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),F(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),F(p==null||i.rank===p.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let c={x:j2(a),scale:p,offset:l,mean:i,variance:u},d={varianceEpsilon:s},f=D.runKernel(Co,c,d);return $(f,a.shape)}var ap=A({batchNorm_:U8});function W8(r,t,e,n,o,s){let a=S(r,"x","batchNorm"),i=S(t,"mean","batchNorm"),u=S(e,"variance","batchNorm"),p;o!=null&&(p=S(o,"scale","batchNorm"));let l;return n!=null&&(l=S(n,"offset","batchNorm")),F(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),F(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),F(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),p!=null&&F(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${p.rank}.`),l!=null&&F(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${l.rank}.`),ap(a,i,u,l,p,s)}var ty=A({batchNorm2d_:W8});function K8(r,t,e,n,o,s){let a=S(r,"x","batchNorm"),i=S(t,"mean","batchNorm"),u=S(e,"variance","batchNorm"),p;o!=null&&(p=S(o,"scale","batchNorm"));let l;return n!=null&&(l=S(n,"offset","batchNorm")),F(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),F(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),F(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),p!=null&&F(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${p.rank}.`),l!=null&&F(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${l.rank}.`),ap(a,i,u,l,p,s)}var ry=A({batchNorm3d_:K8});function V8(r,t,e,n,o,s){let a=S(r,"x","batchNorm"),i=S(t,"mean","batchNorm"),u=S(e,"variance","batchNorm"),p;o!=null&&(p=S(o,"scale","batchNorm"));let l;return n!=null&&(l=S(n,"offset","batchNorm")),F(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),F(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),F(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),p!=null&&F(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${p.rank}.`),l!=null&&F(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${l.rank}.`),ap(a,i,u,l,p,s)}var ny=A({batchNorm4d_:V8});function H8(r,t,e){let n=S(r,"x","bincount"),o=S(t,"weights","bincount");F(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),F(e>=0,()=>`size must be non-negative, but got ${e}.`),F(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},a={size:e};return D.runKernel(Em,s,a)}var oy=A({bincount_:H8});function q8(r,t){let e=S(r,"s0","broadcastArgs","int32"),n=S(t,"s1","broadcastArgs","int32");if(e.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${e.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:e,s1:n};return D.runKernel(_m,o)}var X2=A({broadcastArgs_:q8});function j8(r,t){let e=S(r,"broadcastTo","x"),n=e.shape;if(t.some(p=>!(p>0)||p%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let p=e.shape.slice();for(;p.length<t.length;)p.unshift(1);e=$(e,p)}let o=e.shape,s=Array.from(t);for(let p=t.length-1;p>=0;p--)if(o[p]===t[p])s[p]=1;else if(e.shape[p]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(s.map((p,l)=>p>1?l:-1).filter(p=>p>=0).length===0)return fn(e);let i={x:e},u={reps:s};return D.runKernel(Dn,i,u)}var ip=A({broadcastTo_:j8});function X8(r){let e={x:S(r,"x","ceil","float32")};return D.runKernel(po,e)}var Y2=A({ceil_:X8});function Y8(r,t,e){let n=S(r,"x","clipByValue");F(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let o={x:n},s={clipValueMin:t,clipValueMax:e};return D.runKernel(Kn,o,s)}var Gr=A({clipByValue_:Y8});function Z8(r){return ct(r,0)}var sy=A({concat1d_:Z8});function Q8(r,t){return ct(r,t)}var ay=A({concat2d_:Q8});function J8(r,t){return ct(r,t)}var iy=A({concat3d_:J8});function eX(r,t){return ct(r,t)}var uy=A({concat4d_:eX});function tX(r,t,e,n,o="NHWC",s=[1,1],a){let i=S(r,"x","conv2d","float32"),u=S(t,"filter","conv2d","float32"),p=i,l=!1;i.rank===3&&(l=!0,p=$(i,[1,i.shape[0],i.shape[1],i.shape[2]])),F(p.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${p.rank}.`),F(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Et("conv2d",n,a);let m=o==="NHWC"?p.shape[3]:p.shape[1];F(m===u.shape[2],()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${u.shape[2]}.`),F(Er(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let c={x:p,filter:u},d={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=D.runKernel(lo,c,d);return l?$(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var es=A({conv2d_:tX});function rX(r,t,e,n,o="NWC",s=1,a){let i=S(r,"x","conv1d"),u=S(t,"filter","conv1d"),p=i,l=!1;i.rank===2&&(l=!0,p=$(i,[1,i.shape[0],i.shape[1]])),F(p.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${p.rank}.`),F(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Et("conv1d",n,a),F(p.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${p.shape[2]}) must match input depth for filter ${u.shape[1]}.`),F(Er(e,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${s}'`),F(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let m=$(u,[1,u.shape[0],u.shape[1],u.shape[2]]),c=$(p,[p.shape[0],1,p.shape[1],p.shape[2]]),g=es(c,m,[1,e],n,"NHWC",[1,s],a);return l?$(g,[g.shape[2],g.shape[3]]):$(g,[g.shape[0],g.shape[2],g.shape[3]])}var py=A({conv1d_:rX});function nX(r,t,e,n,o,s="NHWC",a){F(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let i=r,u=t,p=!1;t.rank===3&&(p=!0,u=$(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,r[0],r[1],r[2]]),F(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),F(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),F(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let l=s==="NHWC"?i[3]:i[1],m=s==="NHWC"?u.shape[3]:u.shape[1];F(l===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${l}) must match input depth for filter ${e.shape[2]}.`),F(m===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${e.shape[3]}.`),Et("conv2dDerInput",o,a);let c={dy:u,filter:e},d={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,inputShape:i},f=D.runKernel(mo,c,d);return p?$(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var bc=A({conv2DBackpropInput_:nX});function oX(r,t,e,n,o,s){let a=S(r,"x","conv2dTranspose"),i=S(t,"filter","conv2dTranspose");return bc(e,a,i,n,o,"NHWC",s)}var ly=A({conv2dTranspose_:oX});function sX(r,t,e,n,o="NDHWC",s=[1,1,1]){let a=S(r,"x","conv3d"),i=S(t,"filter","conv3d"),u=a,p=!1;a.rank===4&&(p=!0,u=$(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),F(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),F(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),F(u.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${i.shape[3]}.`),F(Er(e,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),F(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let l={x:u,filter:i},m={strides:e,pad:n,dataFormat:o,dilations:s},c=D.runKernel($u,l,m);return p?$(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var my=A({conv3d_:sX});function aX(r,t,e,n,o){F(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let s=r,a=t,i=!1;t.rank===4&&(i=!0,a=$(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],p=a.shape[4];F(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),F(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),F(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),F(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),F(p===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[4]}.`);let l={dy:a,filter:e},m={pad:o,strides:n,inputShape:s},c=D.runKernel(Bm,l,m);return i?$(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var cy=A({conv3DBackpropInput_:aX});function iX(r,t,e,n,o){let s=S(r,"x","conv3dTranspose"),a=S(t,"filter","conv3dTranspose");return cy(e,s,a,n,o)}var dy=A({conv3dTranspose_:iX});function uX(r){let e={x:S(r,"x","cos","float32")};return D.runKernel(co,e)}var yc=A({cos_:uX});function pX(r){let e={x:S(r,"x","cosh","float32")};return D.runKernel(fo,e)}var fy=A({cosh_:pX});function lX(r,t=0,e=!1,n=!1){let s={x:S(r,"x","cumprod")},a={axis:t,exclusive:e,reverse:n};return D.runKernel(ha,s,a)}var Rh=A({cumprod_:lX});function mX(r,t=0,e=!1,n=!1){let s={x:S(r,"x","cumsum")},a={axis:t,exclusive:e,reverse:n};return D.runKernel(ho,s,a)}var hy=A({cumsum_:mX});function cX(r,t,e,n=!1){let o=S(r,"x","denseBincount"),s=S(t,"weights","denseBincount");F(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),F(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),F(e>=0,()=>`size must be non-negative, but got ${e}.`),F(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let a={x:o,weights:s},i={size:e,binaryOutput:n};return D.runKernel(Om,a,i)}var Z2=A({denseBincount_:cX});function dX(r,t,e="NHWC"){let n=S(r,"x","depthToSpace","float32"),o=e==="NHWC"?n.shape[1]:n.shape[2],s=e==="NHWC"?n.shape[2]:n.shape[3],a=e==="NHWC"?n.shape[3]:n.shape[1];F(t>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`),F(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t}  for depthToSpace with input shape
    ${n.shape}`),F(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t} for depthToSpace with input shape
        ${n.shape}`),F(a%(t*t)===0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${n.shape}`);let i={x:n},u={blockSize:t,dataFormat:e};return D.runKernel(ba,i,u)}var Q2=A({depthToSpace_:dX});function fX(r,t,e,n,o="NHWC",s=[1,1],a){let i=S(r,"x","depthwiseConv2d","float32"),u=S(t,"filter","depthwiseConv2d","float32"),p=i,l=!1;i.rank===3&&(l=!0,p=$(i,[1,i.shape[0],i.shape[1],i.shape[2]])),F(p.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),F(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);let m=o==="NHWC"?p.shape[3]:p.shape[1];F(m===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${m}) must match the inChannels dimension in filter ${u.shape[2]}.`),Et("depthwiseConv2d",n,a);let c={x:p,filter:u},d={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a},f=D.runKernel(go,c,d);return l?$(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var up=A({depthwiseConv2d_:fX});function hX(r){let e={x:S(r,"x","diag")};return D.runKernel(Um,e)}var J2=A({diag_:hX});function gX(r,t,e,n,o=[1,1],s="NHWC"){let a=S(r,"x","dilation2d"),i=S(t,"filter","dilation2d");F(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),F(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),F(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=a,p=!1;a.rank===3&&(u=$(a,[1,a.shape[0],a.shape[1],a.shape[2]]),p=!0);let l={x:u,filter:i},m={strides:e,pad:n,dilations:o},c=D.runKernel(Bu,l,m);return p?$(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var eF=A({dilation2d_:gX});function bX(r,t){let e=S(r,"a","equal","string_or_numeric"),n=S(t,"b","equal","string_or_numeric");[e,n]=Qe(e,n),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(ya,o)}var Yr=A({equal_:bX});function yX(r,t,e){let n=S(t,"a","where"),o=S(e,"b","where"),s=S(r,"condition","where","bool"),a=ze(ze(s.shape,n.shape),o.shape),i=ip(s,a),u=ip(n,a),p=ip(o,a),l={condition:i,t:u,e:p};return D.runKernel(Ts,l)}var Kt=A({where_:yX});function TX(r){let e={x:S(r,"x","zerosLike")};return D.runKernel(Ss,e)}var Fe=A({zerosLike_:TX});function xX(r,t){let e=S(r,"a","div"),n=S(t,"b","div");[e,n]=Qe(e,n);let o=me(e,n),s=Fe(o),a=Yr(n,s);return Kt(a,s,o)}var tF=A({divNoNan_:xX});function IX(r,t){let e=S(r,"t1","dot"),n=S(t,"t2","dot");F((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);let o=e.rank===1?e.size:e.shape[1],s=n.rank===1?n.size:n.shape[0];if(F(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),e.rank===1&&n.rank===1){let a=$(e,[1,-1]),i=$(n,[-1,1]),u=je(a,i);return $(u,[])}else if(e.rank===1&&n.rank===2){let a=$(e,[1,-1]),i=$(n,[n.shape[0],n.shape[1]]),u=je(a,i);return $(u,[u.size])}else if(e.rank===2&&n.rank===1){let a=$(n,[-1,1]),i=je(e,a);return $(i,[i.size])}else{let a=$(n,[n.shape[0],n.shape[1]]);return je(e,a)}}var rF=A({dot_:IX});function CX(r,...t){let e=t.map((o,s)=>S(o,`tensors${s}`,"einsum")),n={equation:r};return D.runKernel(Ou,e,n)}var nF=A({einsum_:CX});function kX(r){let e={x:S(r,"x","elu","float32")};return D.runKernel(yo,e)}var pp=A({elu_:kX});function SX(r){let t=S(r,"x","erf");F(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=oe(t,"float32"));let e={x:t};return D.runKernel(Ki,e)}var oF=A({erf_:SX});function mA(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function sF(r,t,e){let n=r.length+t.length,o=[],s=0,a=0;for(let i=0;i<n;i++)e.indexOf(i)===-1?o.push(r[s++]):o.push(t[a++]);return o}function cA(r,t){let e=[],n=r.length;for(let s=0;s<n;s++)t.indexOf(s)===-1&&e.push(r[s]);let o=t.map(s=>r[s]);return[e,o]}function Ps(r,t){let e=t.map(n=>1);return sF(r,e,t)}function vX(r,t,e){F(mA(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function dA(r,t){if(mA(r,t))return null;let e=[];for(let n=0;n<t;++n)r.indexOf(n)===-1&&e.push(n);return r.forEach(n=>e.push(n)),e}function Ph(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function AX(r,t){let e=[];for(let n=t-r;n<t;++n)e.push(n);return e}function wX(r,t=null,e=!1){let o={x:S(r,"x","max")},s={reductionIndices:t,keepDims:e};return D.runKernel(Ao,o,s)}var hn=A({max_:wX});function NX(r,t=null,e=!1){let o={x:S(r,"x","min")},s={axis:t,keepDims:e};return D.runKernel(Fo,o,s)}var Mh=A({min_:NX});function DX(r,t){let e=S(r,"base","pow"),n=S(t,"exp","pow");[e,n]=Qe(e,n);let o={a:e,b:n};return D.runKernel(_o,o)}var qn=A({pow_:DX});function ce(r,t){if((Sr(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Sr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return dn(r,[],[],t)}function FX(r){let e={x:S(r,"x","sqrt","float32")};return D.runKernel(Vo,e)}var Bt=A({sqrt_:FX});function RX(r){let t=S(r,"x","square"),e={};return D.runKernel("Square",{x:t},e)}var Ye=A({square_:RX});function PX(r,t=null,e=!1){let n=S(r,"x","sum");n.dtype==="bool"&&(n=oe(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return D.runKernel(Ho,o,s)}var de=A({sum_:PX});function MX(r,t="euclidean",e=null,n=!1){r=S(r,"x","norm");let o=aF(r,t,e),s=o.shape;if(n){let a=gr(e,r.shape);s=Ps(o.shape,a)}return $(o,s)}function aF(r,t,e=null){if(r.rank===0)return Wt(r);if(r.rank!==1&&e===null)return aF($(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return de(Wt(r),e);if(t===1/0)return hn(Wt(r),e);if(t===-1/0)return Mh(Wt(r),e);if(t==="euclidean"||t===2)return Bt(de(qn(Wt(r),ce(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return hn(de(Wt(r),e[0]),e[1]-1);if(t===1/0)return hn(de(Wt(r),e[1]),e[0]);if(t===-1/0)return Mh(de(Wt(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return Bt(de(Ye(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var nl=A({norm_:MX});function EX(r,t=null,e=!1){return nl(r,"euclidean",t,e)}var iF=A({euclideanNorm_:EX});function _X(r){let e={x:S(r,"x","exp")};return D.runKernel(To,e)}var br=A({exp_:_X});function LX(r,t=0){let e=S(r,"x","expandDims","string_or_numeric");F(t<=e.rank,()=>"Axis must be <= rank of the tensor");let n={input:e},o={dim:t};return D.runKernel(ds,n,o)}var _r=A({expandDims_:LX});function $X(r){let e={x:S(r,"x","expm1")};return D.runKernel(Ta,e)}var uF=A({expm1_:$X});function BX(r,t){let e=S(r,"x","tile","string_or_numeric");F(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let n={x:e},o={reps:t};return D.runKernel(Dn,n,o)}var Zr=A({tile_:BX});function OX(r,t,e,n="float32"){t==null&&(t=r);let o=xe([r,t],n),s=r<=t?r:t;for(let i=0;i<s;++i)o.set(1,i,i);let a=$(o.toTensor(),[r,t]);if(e==null)return a;if(e.length===1)return Zr(_r(a,0),[e[0],1,1]);if(e.length===2)return Zr(_r(_r(a,0),0),[e[0],e[1],1,1]);if(e.length===3)return Zr(_r(_r(_r(a,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var ol=A({eye_:OX});function ki(r,t,e){let n={shape:r,value:t,dtype:e};return D.runKernel(fi,{},n)}function zX(r){let e={x:S(r,"x","floor","float32")};return D.runKernel(xo,e)}var lp=A({floor_:zX});function GX(r,t,e=0,n=0){let o=S(r,"x","gather"),s=S(t,"indices","gather","int32"),a={x:o,indices:s},i={axis:e,batchDims:n};return D.runKernel(fs,a,i)}var mp=A({gather_:GX});function UX(r,t){let e=S(r,"a","greater","string_or_numeric"),n=S(t,"b","greater","string_or_numeric");[e,n]=Qe(e,n),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(Ca,o)}var mr=A({greater_:UX});function WX(r,t){let e=S(r,"a","greaterEqual","string_or_numeric"),n=S(t,"b","greaterEqual","string_or_numeric");[e,n]=Qe(e,n),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(ko,o)}var Ms=A({greaterEqual_:WX});function KX(r){let e={x:S(r,"x","isFinite")};return D.runKernel(Vi,e)}var pF=A({isFinite_:KX});function VX(r){let e={x:S(r,"x","isInf")};return D.runKernel(Hi,e)}var lF=A({isInf_:VX});function HX(r){let e={x:S(r,"x","isNaN")};return D.runKernel(ka,e)}var mF=A({isNaN_:HX});function qX(r,t=.2){let n={x:S(r,"x","leakyRelu")},o={alpha:t};return D.runKernel(So,n,o)}var Tc=A({leakyRelu_:qX});function jX(r,t){let e=S(r,"a","less","string_or_numeric"),n=S(t,"b","less","string_or_numeric");[e,n]=Qe(e,n),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(Sa,o)}var gy=A({less_:jX});function XX(r,t){let e=S(r,"a","lessEqual","string_or_numeric"),n=S(t,"b","lessEqual","string_or_numeric");[e,n]=Qe(e,n),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(va,o)}var Es=A({lessEqual_:XX});function cF(r,t,e){if(e<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:t,num:e};return D.runKernel(Hm,{},n)}function YX(r,t=5,e=1,n=1,o=.5){let s=S(r,"x","localResponseNormalization");F(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),F(_i(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=s,i=!1;s.rank===3&&(i=!0,a=$(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:a},p={depthRadius:t,bias:e,alpha:n,beta:o},l=D.runKernel(Gu,u,p);return i?$(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var dF=A({localResponseNormalization_:YX});function ZX(r){let e={x:S(r,"x","log","float32")};return D.runKernel(vo,e)}var Ur=A({log_:ZX});function QX(r){let e={x:S(r,"x","log1p")};return D.runKernel(qi,e)}var xc=A({log1p_:QX});function JX(r){return F(mi(r),()=>"The f passed in grad(f) must be a function"),(t,e)=>{let n=S(t,"x","tf.grad","string_or_numeric"),o=e!=null?S(e,"dy","tf.grad"):null;return D.tidy(()=>{let{value:s,grads:a}=D.gradients(()=>r(n),[n],o);return o!=null&&Gt(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),yy(a),a[0]})}}function eY(r){return F(mi(r),()=>"The f passed in grads(f) must be a function"),(t,e)=>{F(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=su(t,"args","tf.grads","string_or_numeric"),o=e!=null?S(e,"dy","tf.grads"):null;return D.tidy(()=>{let{value:s,grads:a}=D.gradients(()=>r(...n),n,o);return o!=null&&Gt(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),yy(a),a})}}function tY(r){return F(mi(r),()=>"The f passed in valueAndGrad(f) must be a function"),(t,e)=>{F(t instanceof qe,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),F(e==null||e instanceof qe,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=D.gradients(()=>r(t),[t],e);return yy(n),{grad:n[0],value:o}}}function rY(r){return F(mi(r),()=>"The f passed in valueAndGrads(f) must be a function"),(t,e)=>{F(Array.isArray(t)&&t.every(o=>o instanceof qe),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),F(e==null||e instanceof qe,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=D.gradients(()=>r(...t),t,e);return e!=null&&Gt(n.value.shape,e.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),yy(n.grads),n}}function by(r,t){F(mi(r),()=>"The f passed in variableGrads(f) must be a function"),F(t==null||Array.isArray(t)&&t.every(p=>p instanceof nu),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let p in D.registeredVariables)t.push(D.registeredVariables[p])}let n=e?t.filter(p=>!p.trainable):null,o=t.length;t=t.filter(p=>p.trainable),F(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:a,grads:i}=D.gradients(r,t,null,s);F(i.some(p=>p!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),F(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let u={};return t.forEach((p,l)=>{i[l]!=null&&(u[p.name]=i[l])}),n?.forEach(p=>u[p.name]=null),{value:a,grads:u}}function gn(r){return D.customGrad(r)}function yy(r){if(r.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function nY(r){let e={x:S(r,"x","softplus")};return D.runKernel(Ji,e)}var uu=A({softplus_:nY});function oY(r){let t=S(r,"x","logSigmoid");return gn(n=>({value:et(uu(et(n))),gradFunc:a=>_(a,_n(et(n)))}))(t)}var fF=A({logSigmoid_:oY});function sY(r,t){let e=S(r,"a","sub"),n=S(t,"b","sub");[e,n]=Qe(e,n);let o={a:e,b:n};return D.runKernel(Xo,o)}var le=A({sub_:sY});function aY(r,t=-1){let e=S(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return gn((o,s)=>{let i=hn(o,t,!0),u=le(o,i),p=le(oe(u,"float32"),Ur(de(br(u),t,!0)));return s([p]),{value:p,gradFunc:(m,c)=>{let[d]=c,f=!0,h=br(d);return le(m,_(de(m,t,f),h))}}})(e)}var Ty=A({logSoftmax_:aY});function iY(r,t=null,e=!1){let n=S(r,"x","logSumExp"),o=gr(t,n.shape),s=hn(n,o,!0),a=le(n,s),i=br(a),u=de(i,o),p=Ur(u),l=Z($(s,p.shape),p);if(e){let m=Ps(l.shape,o);return $(l,m)}return l}var xy=A({logSumExp_:iY});function uY(r,t){let e=S(r,"a","logicalAnd","bool"),n=S(t,"b","logicalAnd","bool");ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(Aa,o)}var Qr=A({logicalAnd_:uY});function pY(r){let e={x:S(r,"x","logicalNot","bool")};return D.runKernel(wa,e)}var Ic=A({logicalNot_:pY});function lY(r,t){let e=S(r,"a","logicalOr","bool"),n=S(t,"b","logicalOr","bool");ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(ji,o)}var Iy=A({logicalOr_:lY});function mY(r,t){let e=S(r,"a","logicalXor","bool"),n=S(t,"b","logicalXor","bool");return ze(e.shape,n.shape),Qr(Iy(r,t),Ic(Qr(r,t)))}var hF=A({logicalXor_:mY});var Cy=2147483648;function cY(r,t,e="left"){let n=S(r,"sortedSequence","searchSorted"),o=S(t,"values","searchSorted"),s=n.shape[n.shape.length-1],a=o.shape[o.shape.length-1],i=$(n,[-1,s]),u=$(o,[-1,a]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(rt(u.shape)>=Cy)throw new Error(`values tensor size must less than ${Cy}`);if(i.shape[1]>=Cy)throw new Error(`trailing dim_size must less than ${Cy} for int32 output type, was ${i.shape[1]}`);let p={sortedSequence:i,values:u},l={side:e};return D.runKernel(tc,p,l)}var Eh=A({searchSorted_:cY});function gF(r,t){return Eh(r,t,"left")}function dY(r,t,e,n,o){let s=S(r,"x","maxPool"),a=1,i=s,u=!1;s.rank===3&&(u=!0,i=$(s,[1,s.shape[0],s.shape[1],s.shape[2]])),F(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),F(Er(e,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),Et("maxPool",n,o);let p={x:i},l={filterSize:t,strides:e,pad:n,dimRoundingMode:o},m=D.runKernel(No,p,l);return u?$(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Cc=A({maxPool_:dY});function fY(r,t=[1,1,1],e,n,o,s="NDHWC"){let a=S(r,"x","maxPool3d"),i=a,u=!1;a.rank===4&&(u=!0,i=$(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),F(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),F(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Et("maxPool3d",n,o);let p={x:i},l={filterSize:t,strides:e,pad:n,dimRoundingMode:o,dataFormat:s},m=D.runKernel(Uu,p,l);return u?$(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var ky=A({maxPool3d_:fY});function hY(r,t,e,n,o=!1){let a={x:S(r,"x","maxPoolWithArgmax")},i={filterSize:t,strides:e,pad:n,includeBatchInIndex:o},u=D.runKernel(Ym,a,i);return{result:u[0],indexes:u[1]}}var bF=A({maxPoolWithArgmax_:hY});function gY(r,t){let e=S(r,"a","maximum"),n=S(t,"b","maximum");[e,n]=Qe(e,n),e.dtype==="bool"&&(e=oe(e,"int32"),n=oe(n,"int32")),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(wo,o)}var ts=A({maximum_:gY});function bY(r,t=null,e=!1){let o={x:S(r,"x","mean")},s={axis:t,keepDims:e};return D.runKernel(Do,o,s)}var Ot=A({mean_:bY});function Ct(r,t="float32"){if(t==="complex64"){let n=Ct(r,"float32"),o=Ct(r,"float32");return Rn(n,o)}let e=Rm(rt(r),t);return D.makeTensor(e,r,t)}function yr(r,t="float32"){if(t==="complex64"){let n=yr(r,"float32"),o=Ct(r,"float32");return Rn(n,o)}let e=ph(rt(r),t);return D.makeTensor(e,r,t)}function yF(r,t,{indexing:e="xy"}={}){if(e!=="xy"&&e!=="ij")throw new TypeError(`${e} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=S(r,"x","meshgrid",r instanceof qe?r.dtype:"float32");if(t===void 0)return[n];let o=S(t,"y","meshgrid",t instanceof qe?t.dtype:"float32"),s=rt(n.shape),a=rt(o.shape);return e==="xy"?(n=$(n,[1,-1]),o=$(o,[-1,1]),[je(yr([a,1],n.dtype),n),je(o,yr([1,s],o.dtype))]):(n=$(n,[-1,1]),o=$(o,[1,-1]),[je(n,yr([1,a],n.dtype)),je(yr([s,1],o.dtype),o)])}function yY(r,t){let e=S(r,"a","minimum"),n=S(t,"b","minimum");[e,n]=Qe(e,n),e.dtype==="bool"&&(e=oe(e,"int32"),n=oe(n,"int32")),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(Ro,o)}var cp=A({minimum_:yY});function TY(r,t,e){F(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let n=S(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");F(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let o=e==="reflect"?1:0;for(let i=0;i<n.rank;i++)F(t[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),F(t[i][0]>=0&&t[i][0]<=n.shape[i]-o&&t[i][1]>=0&&t[i][1]<=n.shape[i]-o,()=>`Padding in dimension ${i} cannot be greater than or equal to ${n.shape[i]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:t,mode:e},a={x:n};return D.runKernel(Po,a,s)}var TF=A({mirrorPad_:TY});function xY(r,t){let e=S(r,"a","mod"),n=S(t,"b","mod");[e,n]=Qe(e,n);let o={a:e,b:n};return D.runKernel(Xi,o)}var xF=A({mod_:xY});function IY(r,t=null,e=!1){r=S(r,"x","moments");let n=gr(t,r.shape),o=Ot(r,n,e),s=o.shape;e||(s=Ps(o.shape,n));let a=Ye(le(oe(r,"float32"),$(o,s))),i=Ot(a,n,e);return{mean:o,variance:i}}var sl=A({moments_:IY});function CY(r,t,e,n){let o=S(t,"data","multiRNNCell"),s=su(e,"c","multiRNNCell"),a=su(n,"h","multiRNNCell"),i=o,u=[];for(let m=0;m<r.length;m++){let c=r[m](i,s[m],a[m]);u.push(c[0]),u.push(c[1]),i=c[1]}let p=[],l=[];for(let m=0;m<u.length;m+=2)p.push(u[m]),l.push(u[m+1]);return[p,l]}var IF=A({multiRNNCell_:CY});function kY(r,t,e,n=!1){let o=S(r,"logits","multinomial"),s=o.size,a=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);e=e||Math.random();let u={logits:a===1?$(o,[1,-1]):o},p={numSamples:t,seed:e,normalized:n},l=D.runKernel(Zm,u,p);return a===1?$(l,[l.size]):l}var CF=A({multinomial_:kY});function SY(r,t){let e=S(r,"a","notEqual","string_or_numeric"),n=S(t,"b","notEqual","string_or_numeric");[e,n]=Qe(e,n),ze(e.shape,n.shape);let o={a:e,b:n};return D.runKernel(Na,o)}var pu=A({notEqual_:SY});function vY(r){let e={x:S(r,"x","onesLike")};return D.runKernel(gs,e)}var Lr=A({onesLike_:vY});function AY(r,t){let e=S(r,"v1","outerProduct"),n=S(t,"v2","outerProduct");F(e.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${e.rank} and ${n.rank}.`);let o=$(e,[-1,1]),s=$(n,[1,-1]);return je(o,s)}var kF=A({outerProduct_:AY});function wY(r,t,e=0){let n=S(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:t,constantValue:e},s={x:n};return D.runKernel(Eo,s,o)}var jn=A({pad_:wY});function NY(r,t,e=0){return F(t.length===2,()=>"Invalid number of paddings. Must be length of 2."),jn(r,[t],e)}var SF=A({pad1d_:NY});function DY(r,t,e=0){return F(t.length===2&&t[0].length===2&&t[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),jn(r,t,e)}var vF=A({pad2d_:DY});function FY(r,t,e=0){return F(t.length===3&&t[0].length===2&&t[1].length===2&&t[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),jn(r,t,e)}var AF=A({pad3d_:FY});function RY(r,t,e=0){return F(t.length===4&&t[0].length===2&&t[1].length===2&&t[2].length===2&&t[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),jn(r,t,e)}var wF=A({pad4d_:RY});function PY(r,t,e){let n=S(r,"x","spaceToBatchND");F(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),F(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),F(n.shape.reduce((a,i,u)=>u>0&&u<=t.length?a&&(i+e[u-1][0]+e[u-1][1])%t[u-1]===0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let o={x:n},s={blockShape:t,paddings:e};return D.runKernel(Is,o,s)}var kc=A({spaceToBatchND_:PY});function MY(r,t,e,n,o,s,a){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let i=S(r,"x","maxPool"),u=i,p=!1;i.rank===3&&(p=!0,u=$(i,[1,i.shape[0],i.shape[1],i.shape[2]])),F(Er(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let l=pA(u.shape,t,s,o,n),m=[l.dilationHeight,l.dilationWidth],c;n==="same"?c=_Y([l.filterHeight,l.filterWidth],m):c=[[0,0],[0,0]];let d=m[0]===1&&m[1]===1,[f,h]=EY([l.inHeight,l.inWidth],m,c),g=d?n:"valid",b=d?u:kc(u,m,f),x=(e==="avg"?()=>hc(b,t,s,g,a):()=>Cc(b,t,s,g,a))(),I=d?x:gc(x,m,h);return p?$(I,[I.shape[1],I.shape[2],I.shape[3]]):I}function EY(r,t,e){let n=e.map(l=>l[0]),o=e.map(l=>l[1]),s=r.concat(n,o),a=t.map((l,m)=>(l-s[m]%l)%l),i=o.map((l,m)=>l+a[m]),u=t.map((l,m)=>[n[m],i[m]]),p=t.map((l,m)=>[0,a[m]]);return[u,p]}function _Y(r,t){let n=r.map((a,i)=>a+(a-1)*(t[i]-1)).map(a=>a-1),o=n.map(a=>Math.floor(a/2)),s=n.map((a,i)=>a-o[i]);return n.map((a,i)=>[o[i],s[i]])}var NF=A({pool_:MY});function LY(r,t){let e=S(r,"x","prelu"),n=S(t,"alpha","prelu"),o={x:e,alpha:n};return D.runKernel(Lo,o)}var Sc=A({prelu_:LY});function $Y(r,t=null,e=!1){let n=S(r,"x","prod");n.dtype==="bool"&&(n=oe(n,"int32"));let o={x:n},s={axis:t,keepDims:e};return D.runKernel($o,o,s)}var DF=A({prod_:$Y});function BY(r,t,e,n,o){let s=S(r,"shape","raggedTensorToTensor","int32"),a=S(t,"values","raggedTensorToTensor"),i=S(e,"defaultValue","raggedTensorToTensor",a.dtype),u=n.map((m,c)=>S(m,`tensors${c}`,"raggedTensorToTensor","int32")),p={shape:s,values:a,defaultValue:i,rowPartitionTensors:u},l={rowPartitionTypes:o};return D.runKernel(Qm,p,l)}var FF=A({raggedTensorToTensor_:BY});function OY(r,t,e){let n=rt(r),o=null;if(e==null||e==="float32")o=new Float32Array(n);else if(e==="int32")o=new Int32Array(n);else if(e==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${e}`);for(let s=0;s<n;s++)o[s]=t();return D.makeTensor(o,r,e)}var RF=A({rand_:OY});var wy=wm(_h());var il=class{constructor(t,e,n,o,s){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=s||Math.random();this.random=wy.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let t,e,n=!1;for(;!n;){let o,s,a;do o=2*this.random()-1,s=2*this.random()-1,a=o*o+s*s;while(a>=1||a===0);let i=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*o*i,e=this.mean+this.stdDev*s*i,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}},vy=class{constructor(t,e,n,o){this.alpha=t,this.beta=1/e,this.dtype=n;let s=o||Math.random();this.randu=wy.alea(s.toString()),this.randn=new il(0,1,n,!1,this.randu()),t<1?this.d=t+2/3:this.d=t-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let t,e,n,o,s,a;for(;;){do o=this.randn.nextValue(),a=1+this.c*o;while(a<=0);if(a*=a*a,t=o*o,e=1-.331*t*t,n=.5*t+this.d*(1-a+Math.log(a)),s=this.randu(),s<e||Math.log(s)<n)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(t){return this.dtype==="float32"?t:Math.round(t)}},Ay=class{constructor(t=0,e=1,n,o){this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32";if(this.min=t,this.range=e-t,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=wy.alea(o)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function HY(r,t,e=1,n="float32",o){if(e==null&&(e=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new vy(t,e,n,o),a=xe(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var jF=A({randomGamma_:HY});function qY(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new il(t,e,n,!1,o),a=xe(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var ul=A({randomNormal_:qY});function jY(r,t,e){if(t!=null&&t==="bool")throw new Error(`Unsupported data type ${t}`);return ul(r,0,1,t,e)}var XF=A({randomStandardNormal_:jY});function XY(r,t=0,e=1,n="float32",o){let s=xe(r,n),a=new Ay(t,e,null,o);for(let i=0;i<s.values.length;i++)s.values[i]=a.nextValue();return s.toTensor()}var Si=A({randomUniform_:XY});function dp(r,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:t,step:e,dtype:n};return D.runKernel(hi,{},o)}function YY(r){let e={x:S(r,"x","reciprocal")};return D.runKernel(Pa,e)}var YF=A({reciprocal_:YY});function ZY(r){let e={x:S(r,"x","relu")};return D.runKernel(Bo,e)}var Jr=A({relu_:ZY});function QY(r){let e={x:S(r,"x","relu6")};return D.runKernel(Go,e)}var Ny=A({relu6_:QY});function JY(r,t){let n={x:S(r,"x","reverse")},o={dims:t};return D.runKernel(Ma,n,o)}var Dr=A({reverse_:JY});function eZ(r){let t=S(r,"x","reverse");return F(t.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${t.rank}.`),Dr(t,0)}var ZF=A({reverse1d_:eZ});function tZ(r,t){let e=S(r,"x","reverse");return F(e.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${e.rank}.`),Dr(e,t)}var QF=A({reverse2d_:tZ});function rZ(r,t){let e=S(r,"x","reverse");return F(e.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${e.rank}.`),Dr(e,t)}var JF=A({reverse3d_:rZ});function nZ(r,t){let e=S(r,"x","reverse");return F(e.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${e.rank}.`),Dr(e,t)}var eR=A({reverse4d_:nZ});function oZ(r){let e={x:S(r,"x","round")};return D.runKernel(Ea,e)}var Dy=A({round_:oZ});function sZ(r){let e={x:S(r,"x","rsqrt","float32")};return D.runKernel(Uo,e)}var Fy=A({rsqrt_:sZ});function aZ(r){let e={x:S(r,"x","selu")};return D.runKernel(Zi,e)}var Ry=A({selu_:aZ});function iZ(r,t,e,n,o,s=[1,1],a="NHWC"){let i=S(r,"x","separableConv2d"),u=S(t,"depthwiseFilter","separableConv2d"),p=S(e,"pointwiseFilter","separableConv2d"),l=i,m=!1;if(i.rank===3&&(m=!0,l=$(i,[1,i.shape[0],i.shape[1],i.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");F(l.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${l.rank}.`),F(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),F(p.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),F(p.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`),F(p.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`);let c=u.shape[2],d=u.shape[3];F(p.shape[2]===c*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${c*d}, but got ${p.shape[2]}.`);let f=up(l,u,n,o,a,s),g=es(f,p,1,"valid",a);return m?$(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var Py=A({separableConv2d_:iZ});async function uZ(r,t){let e=S(r,"x","setdiff1d"),n=S(t,"y","setdiff1d");F(e.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${e.dtype}) and y (${n.dtype}).`),F(e.rank===1,()=>`x should be 1D tensor, but got x (${e.shape}).`),F(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await e.data(),s=await n.data(),a=new Set(s),i=0;for(let l=0;l<o.length;l++)a.has(o[l])||i++;let u=new bt([i],e.dtype),p=new bt([i],"int32");for(let l=0,m=0;l<o.length;l++)a.has(o[l])||(u.values[m]=o[l],p.values[m]=l,m++);return[u.toTensor(),p.toTensor()]}var tR=uZ;function pZ(r){let e={x:S(r,"x","sign")};return D.runKernel(Qi,e)}var rR=A({sign_:pZ});function lZ(r){let e={x:S(r,"x","sin","float32")};return D.runKernel(Wo,e)}var My=A({sin_:lZ});function mZ(r){let e={x:S(r,"x","sinh")};return D.runKernel(La,e)}var Ey=A({sinh_:mZ});function cZ(r,t,e){let n=S(r,"x","slice1d");return F(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),Ge(n,[t],[e])}var vc=A({slice1d_:cZ});function dZ(r,t,e){let n=S(r,"x","slice2d");return F(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),Ge(n,t,e)}var Lh=A({slice2d_:dZ});function fZ(r,t,e){let n=S(r,"x","slice3d");return F(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),Ge(n,t,e)}var Ac=A({slice3d_:fZ});function hZ(r,t,e){let n=S(r,"x","slice4d");return F(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),Ge(n,t,e)}var pl=A({slice4d_:hZ});function gZ(r,t=-1){let e=S(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let n={logits:e},o={dim:t};return D.runKernel(qo,n,o)}var wc=A({softmax_:gZ});function bZ(r){F(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return D.runKernel(Km,t)}var Nc=A({fft_:bZ});function yZ(r){F(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return D.runKernel(Vm,t)}var ll=A({ifft_:yZ});function TZ(r){let t=r.shape[r.shape.length-1],e=r.size/t,n;if(t<=2){let o=$(r,[e,t]);n=ll(o)}else{let o=[e,2*(t-1)],s=$(iu(r),[e,t]),a=$(np(r),[e,t]),i=Dr(Ge(s,[0,1],[e,t-2]),1),u=_(Dr(Ge(a,[0,1],[e,t-2]),1),ce(-1)),p=ct([s,i],1),l=ct([a,u],1),m=$(Rn(p,l),[o[0],o[1]]);n=ll(m)}if(n=iu(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=$(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var _y=A({irfft_:TZ});function xZ(r,t,e=0){let o={x:S(r,"x","split")},s={numOrSizeSplits:t,axis:e};return D.runKernel(Cs,o,s)}var Fr=A({split_:xZ});function IZ(r,t){F(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],n=r.size/e,o;if(t!=null&&t<e){let f=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=t,o=Ge(r,f,h),e=t}else if(t!=null&&t>e){let f=r.shape.map(h=>h);f[r.shape.length-1]=t-e,o=ct([r,Ct(f)],r.shape.length-1),e=t}else o=r;let s=Fe(o),a=$(Rn(o,s),[n,e]),i=Nc(a),u=Math.floor(e/2)+1,p=iu(i),l=np(i),m=Fr(p,[u,e-u],p.shape.length-1),c=Fr(l,[u,e-u],l.shape.length-1),d=o.shape.slice();return d[o.shape.length-1]=u,$(Rn(m[0],c[0]),d)}var Dc=A({rfft_:IZ});function CZ(r,t){let e=S(r,"a","squaredDifference"),n=S(t,"b","squaredDifference");[e,n]=Qe(e,n),ze(e.shape,n.shape);let o={a:e,b:n},s={};return D.runKernel(jo,o,s)}var Ly=A({squaredDifference_:CZ});function kZ(r,t){let e=S(r,"x","squeeze","string_or_numeric");return $(e,yv(e.shape,t).newShape)}var _s=A({squeeze_:kZ});function SZ(r,t=0){let e=su(r,"tensors","stack","string_or_numeric");F(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&F(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let n=e,o={axis:t};return D.runKernel(bs,n,o)}var Tr=A({stack_:SZ});function vZ(r,t=0){let n={x:S(r,"x","step")},o={alpha:t};return D.runKernel(vs,n,o)}var vi=A({step_:vZ});function AZ(r,t,e,n,o=0,s=0,a=0,i=0,u=0){let l={x:S(r,"x","stridedSlice","string_or_numeric")},m={begin:t,end:e,strides:n,beginMask:o,endMask:s,ellipsisMask:a,newAxisMask:i,shrinkAxisMask:u};return D.runKernel($a,l,m)}var nR=A({stridedSlice_:AZ});function wZ(r){let e={x:S(r,"x","tan","float32")};return D.runKernel(Ba,e)}var oR=A({tan_:wZ});function Xt(r,t){oo(r);let e=zr(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return dn(r,null,e,t)}function Va(r,t,e){if(oo(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=zr(r,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return dn(r,t,n,e)}function sR(r,t,e){if(oo(r),t!=null&&t.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=zr(r,e);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return dn(r,t,n,e)}function aR(r,t,e){if(oo(r),t!=null&&t.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=zr(r,e);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return dn(r,t,n,e)}function iR(r,t,e){if(oo(r),t!=null&&t.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=zr(r,e);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return t=t||n,dn(r,t,n,e)}function NZ(r,t=1,e=!0){let n=S(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${t}`);let s={x:n},a={k:t,sorted:e},[i,u]=D.runKernel(Oa,s,a);return{values:i,indices:u}}var uR=A({topk_:NZ});function DZ(r,t=0,e=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new il(t,e,n,!0,o),a=xe(r,n);for(let i=0;i<a.values.length;i++)a.values[i]=s.nextValue();return a.toTensor()}var Fc=A({truncatedNormal_:DZ});function FZ(r,t=0){let e=S(r,"x","unique","string_or_numeric");F(e.rank>0,()=>"The input tensor must be at least 1D");let n={x:e},o={axis:t},[s,a]=D.runKernel(rc,n,o);return{values:s,indices:a}}var pR=A({unique_:FZ});function RZ(r,t,e){let n=S(r,"x","unsortedSegmentSum"),o=S(t,"segmentIds","unsortedSegmentSum","int32");F(_i(e),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},a={numSegments:e};return D.runKernel(Yu,s,a)}var $y=A({unsortedSegmentSum_:RZ});function PZ(r,t=0){let e=S(r,"x","unstack","string_or_numeric");F(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let n={value:e},o={axis:t};return D.runKernel(ks,n,o)}var Wr=A({unstack_:PZ});function lR(r,t){return Eh(r,t,"right")}function By(r,t=!0,e,n){return D.makeVariable(r,t,e,n)}function Oy(r,t){let e=[];for(let s=0;s<t.length;s++)t[s]&&e.push(s);let n=xe(r,"int32"),o=xe([e.length,r.length],"int32");for(let s=0;s<e.length;s++){let a=n.indexToLoc(e[s]),i=s*r.length;o.values.set(a,i)}return o.toTensor()}async function MZ(r){let t=S(r,"condition","whereAsync","bool"),e=await t.data(),n=Oy(t.shape,e);return r!==t&&t.dispose(),n}var zy=MZ;async function EZ(r,t,e){let n=S(r,"tensor","boolMask"),o=S(t,"mask","boolMask","bool"),s=e??0,a=o.rank,i=n.shape;F(a>0,()=>"mask cannot be scalar"),Gt(i.slice(s,s+a),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+a;h++)u*=i[h];let p=i.slice(0,s).concat([u],i.slice(s+a)),l=$(n,p),m=$(o,[-1]),c=await zy(m),d=_s(c,[1]),f=mp(l,d,s);return r!==n&&n.dispose(),t!==o&&o.dispose(),d.dispose(),l.dispose(),m.dispose(),c.dispose(),f}var _Z=EZ;function LZ(r,t,e,n,o=!0){let s=S(r,"v","movingAverage"),a=S(t,"x","movingAverage"),i=S(e,"decay","movingAverage");Lv(s,a),F(Un(s.shape,a.shape),()=>"Shape mismatch in v and x");let u=ce(1),p=le(u,i),l=_(le(a,s),p);if(o){F(n!=null,()=>"When using zeroDebias: true, step is required.");let m=S(n,"step","movingAverage");l=me(l,le(u,qn(i,m)))}return Z(s,l)}var $Z=A({movingAverage_:LZ});function BZ(r,t,e){let n=S(r,"indices","scatterND","int32"),o=S(t,"updates","scatterND");Xb(o,n,e);let s={indices:n,updates:o},a={shape:e};return D.runKernel(_a,s,a)}var OZ=A({scatterND_:BZ});function mR(r,t,e,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(e.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${e.length}, should be: ${s}.`);let a=t.size;if(!(t.rank===0||t.rank===1&&a===o))throw new Error(`sparseValues has incorrect shape ${t.shape}, should be [] or [${o}]`);if(t.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function GZ(r,t,e,n=0){let o=S(r,"sparseIndices","sparseToDense","int32"),s=S(t,"sparseValues","sparseToDense","string_or_numeric"),a=S(n,"defaultValue","sparseToDense",s.dtype);mR(o,s,e,a);let i={sparseIndices:o,sparseValues:s,defaultValue:a},u={outputShape:e};return D.runKernel(qu,i,u)}var UZ=A({sparseToDense_:GZ});function WZ(r,t){let e=S(t,"indices","gatherND","int32"),o={params:S(r,"x","gatherND","string_or_numeric"),indices:e};return D.runKernel(Ia,o)}var KZ=A({gatherND_:WZ});function cR(r,t){if(t==null)return r.shape.slice();if(Un(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let n=0;n<r.shape.length;n++)t[n]==null&&r.shape[n]!=null?e.push(r.shape[n]):e.push(t[n]);return e}return t}function VZ(r,t,e,n){let o=S(r,"x","dropout");if(F(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),F(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof qe?o.clone():o;let s=cR(o,e),a=1-t,i=me(lp(Z(Si(s,0,1,"float32",n),a)),a);return _(o,i)}var IA=A({dropout_:VZ});function CA(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function $h(r,t,e){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let a=2*Math.PI*s/(r+n-1);o[s]=t-e*Math.cos(a)}return Xt(o,"float32")}async function HZ(r,t,e=1){let n=S(r,"predictions","inTopK"),o=S(t,"targets","inTopK");F(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),F(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Gt(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];F(e>0&&e<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${e}`);let a=await n.data(),i=await o.data(),[u,p]=[a.length/s,s],l=Tv("bool",u);for(let m=0;m<u;m++){let c=m*p,d=a.subarray(c,c+p),f=[];for(let h=0;h<d.length;h++)f.push({value:d[h],index:h});f.sort((h,g)=>g.value-h.value),l[m]=0;for(let h=0;h<e;h++)if(f[h].index===i[m]){l[m]=1;break}}return r!==n&&n.dispose(),t!==o&&o.dispose(),wr(l,o.shape,"bool")}var qZ=HZ;var fp={};Xe(fp,{conv2d:()=>dR,depthwiseConv2d:()=>fR,matMul:()=>hR});function jZ(r,t,e,n,o,s="NHWC",a){let i=r;r.rank===3&&(i=$(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=$(t,[1,t.shape[0],t.shape[1],t.shape[2]])),F(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),F(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),F(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let p=s==="NHWC"?i.shape[3]:i.shape[1],l=s==="NHWC"?u.shape[3]:u.shape[1];F(p===e[2],()=>`Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${e[2]}.`),F(l===e[3],()=>`Error in conv2dDerFilter: depth of dy (${l}) must match output depth for filter (${e[3]}).`),Et("conv2dDerFilter",o,a);let m={x:i,dy:u},c={strides:n,pad:o,dataFormat:s,dimRoundingMode:a,filterShape:e};return D.runKernel(Lm,m,c)}var Rc=A({conv2DBackpropFilter_:jZ});function ml(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return _(r,vi(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function cl(r,t){let e=t,n=At(r.shape,t.shape);return n.length>0&&(e=de(e,n)),$(e,r.shape)}function dl(r,t,e,n){if(t==="linear")return r;if(t==="relu")return Jr(r);if(t==="elu")return pp(r);if(t==="relu6")return Ny(r);if(t==="prelu")return Sc(r,e);if(t==="leakyrelu")return Tc(r,n);if(t==="sigmoid")return _n(r);throw new Error(`Unknown fused activation ${t}.`)}var fl=(r,t)=>!(r>0)||t==="linear";function XZ({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:p,leakyreluAlpha:l}){if(u=u||"linear",fl(D.state.gradientDepth,u)===!1){F(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let w=es(r,t,e,n,o,s,a);return i!=null&&(w=Z(w,i)),dl(w,u,p,l)}let m=S(r,"x","conv2d","float32"),c=S(t,"filter","conv2d","float32"),d=m,f=!1;m.rank===3&&(f=!0,d=$(m,[1,m.shape[0],m.shape[1],m.shape[2]])),F(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),F(c.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${c.rank}.`),Et("fused conv2d",n,a);let h=o==="NHWC"?d.shape[3]:d.shape[1];F(c.shape[2]===h,()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${c.shape[2]}.`),F(Er(e,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`);let g=rl(d.shape,c.shape,e,s,n,a),b;i!=null&&(b=S(i,"bias","fused conv2d"),[b]=Qe(b,m),o==="NHWC"?ze(g.outShape,b.shape):(F(b.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${b.shape.length}.`),F(b.shape.length===0||b.shape[0]===g.outChannels||b.shape[0]===1,()=>`Error in fused conv2d: bias shape (${b.shape}) is not compatible with the number of output channels (${g.outChannels})`)));let T;if(p!=null){let w=p.shape;if(F(w.length<=1||w.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${w.length}.`),w.length===1)F(w[0]===1||w[0]===g.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the number of output channels (${g.outChannels}).`);else if(w.length===3)try{ze(w,g.outShape)}catch{let P=`Error in fused conv2d: PReLU activation weights (${w}) is not compatible with the output shape of the conv2d (${g.outShape}).`;throw Error(P)}T=S(p,"prelu weights","fused conv2d")}let x=(w,R)=>{F(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);let[P,M,L,z]=R,W=ml(w,L,u);F(Qo(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let V=bc(M.shape,W,P,e,n),j=Rc(M,W,P.shape,e,n),H=[V,j];if(z!=null){let X=cl(z,W);H.push(X)}return H},I={x:d,filter:c,bias:b,preluActivationWeights:T},k={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:l};return i==null?gn((R,P,M)=>{let L=D.runKernel(ws,I,k);return M([P,R,L]),f&&(L=$(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:x}})(d,c):gn((R,P,M,L)=>{let z=D.runKernel(ws,I,k);return L([P,R,z,M]),f&&(z=$(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:x}})(d,c,b)}var dR=A({fusedConv2d_:XZ});function YZ(r,t,e,n,o,s=[1,1],a){let i=r;r.rank===3&&(i=$(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=$(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={x:i,dy:u},l={strides:n,pad:o,dimRoundingMode:a,dilations:s,filterShape:e};return D.runKernel(zm,p,l)}var Gy=A({depthwiseConv2dNativeBackpropFilter_:YZ});function ZZ(r,t,e,n,o,s=[1,1],a){let i=t,u=!1;t.rank===3&&(u=!0,i=$(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={dy:i,filter:e},l={strides:n,pad:o,dimRoundingMode:a,dilations:s,inputShape:r},m=D.runKernel(Gm,p,l);return u?$(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Uy=A({depthwiseConv2dNativeBackpropInput_:ZZ});function QZ({x:r,filter:t,strides:e,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:i,activation:u="linear",preluActivationWeights:p,leakyreluAlpha:l}){if(fl(D.state.gradientDepth,u)===!1){let k=up(r,t,e,n,o,s,a);return i!=null&&(k=Z(k,i)),dl(k,u,p,l)}let m=S(r,"x","depthwiseConv2d","float32"),c=S(t,"filter","depthwiseConv2d","float32"),d=m,f=!1;m.rank===3&&(f=!0,d=$(m,[1,m.shape[0],m.shape[1],m.shape[2]])),F(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),F(c.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`),F(d.shape[3]===c.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),s==null&&(s=[1,1]),F(Er(e,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${s}'`),Et("fused depthwiseConv2d",n,a);let h=rl(d.shape,c.shape,e,s,n,a,!0),g;i!=null&&(g=S(i,"bias","fused conv2d"),[g]=Qe(g,m),ze(h.outShape,g.shape));let b;p!=null&&(b=S(p,"prelu weights","fused depthwiseConv2d"));let T=(k,w)=>{F(Qo(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[R,P,M,L]=w,z=ml(k,M,u),W=Uy(P.shape,z,R,e,n,s,a),V=Gy(P,z,R.shape,e,n,s,a);if(L!=null){let j=cl(g,z);return[W,V,j]}return[W,V]},x={x:d,filter:c,bias:g,preluActivationWeights:b},I={strides:e,pad:n,dataFormat:o,dilations:s,dimRoundingMode:a,activation:u,leakyreluAlpha:l};return i==null?gn((w,R,P)=>{let M=D.runKernel(Ns,x,I);return P([R,w,M]),f&&(M=$(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:T}})(d,c):gn((w,R,P,M)=>{let L=D.runKernel(Ns,x,I);return M([R,w,L,P]),f&&(L=$(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:T}})(d,c,g)}var fR=A({fusedDepthwiseConv2d_:QZ});function JZ({a:r,b:t,transposeA:e=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:i=.2}){if(fl(D.state.gradientDepth,s)===!1){let z=je(r,t,e,n);return o!=null&&(z=Z(z,o)),dl(z,s,a,i)}let u=S(r,"a","fused matMul"),p=S(t,"b","fused matMul");[u,p]=Qe(u,p);let l=e?u.shape[u.rank-2]:u.shape[u.rank-1],m=n?p.shape[p.rank-1]:p.shape[p.rank-2],c=e?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?p.shape[p.rank-2]:p.shape[p.rank-1],f=u.shape.slice(0,-2),h=p.shape.slice(0,-2),g=rt(f),b=rt(h);F(l===m,()=>`Error in fused matMul: inner shapes (${l}) and (${m}) of Tensors with shapes ${u.shape} and ${p.shape} and transposeA=${e} and transposeB=${n} must match.`);let x=ze(u.shape.slice(0,-2),p.shape.slice(0,-2)).concat([c,d]),I=e?$(u,[g,l,c]):$(u,[g,c,l]),k=n?$(p,[b,d,m]):$(p,[b,m,d]),w;o!=null&&(w=S(o,"bias","fused matMul"),[w]=Qe(w,u),ze(x,w.shape));let R;a!=null&&(R=S(a,"prelu weights","fused matMul"));let P=(z,W)=>{let[V,j,H,X]=W,ee=ml($(z,H.shape),H,s),q,ne;if(!e&&!n?(q=je(ee,j,!1,!0),ne=je(V,ee,!0,!1)):!e&&n?(q=je(ee,j,!1,!1),ne=je(ee,V,!0,!1)):e&&!n?(q=je(j,ee,!1,!0),ne=je(V,ee,!1,!1)):(q=je(j,ee,!0,!0),ne=je(ee,V,!0,!0)),o!=null){let se=cl(X,ee);return[q,ne,se]}else return[q,ne]},M={a:I,b:k,bias:w,preluActivationWeights:R},L={transposeA:e,transposeB:n,activation:s,leakyreluAlpha:i};return o==null?gn((W,V,j)=>{let H=D.runKernel(As,M,L);return j([W,V,H]),{value:$(H,x),gradFunc:P}})(I,k):gn((W,V,j,H)=>{let X=D.runKernel(As,M,L);return H([W,V,X,j]),{value:$(X,x),gradFunc:P}})(I,k,w)}var hR=A({fusedMatMul_:JZ});function eQ(r){return $h(r,.54,.46)}var gR=A({hammingWindow_:eQ});function tQ(r){return $h(r,.5,.5)}var Wy=A({hannWindow_:tQ});function rQ(r,t,e,n=!1,o=0){let s=0,a=[];for(;s+t<=r.size;)a.push(Ge(r,s,t)),s+=e;if(n)for(;s<r.size;){let i=s+t-r.size,u=ct([Ge(r,s,t-i),ki([i],o)]);a.push(u),s+=e}return a.length===0?Va([],[0,t]):$(ct(a),[a.length,t])}var Ky=A({frame_:rQ});function nQ(r,t,e,n,o=Wy){n==null&&(n=CA(t));let s=Ky(r,t,e),a=_(s,o(t));return Dc(a,n)}var bR=A({stft_:nQ});function oQ(r,t,e,n,o="bilinear",s=0){let a=S(r,"image","cropAndResize"),i=S(t,"boxes","cropAndResize","float32"),u=S(e,"boxInd","cropAndResize","int32"),p=i.shape[0];F(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),F(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${p},4] but had shape ${i.shape}.`),F(u.rank===1&&u.shape[0]===p,()=>`Error in cropAndResize: boxInd must be have size [${p}] but had shape ${i.shape}.`),F(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),F(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),F(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let l={image:a,boxes:i,boxInd:u},m={method:o,extrapolationValue:s,cropSize:n};return D.runKernel(ga,l,m)}var yR=A({cropAndResize_:oQ});function sQ(r){let t=S(r,"image","flipLeftRight","float32");F(t.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`);let e={image:t};return D.runKernel(xa,e,{})}var TR=A({flipLeftRight_:sQ});function aQ(r){let t=S(r,"image","grayscaleToRGB"),e=t.rank-1,n=t.shape[e];F(t.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`),F(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(t.rank);return o.fill(1,0,e),o[e]=3,Zr(t,o)}var xR=A({grayscaleToRGB_:aQ});function iQ(r,t,e=0,n=.5){let o=S(r,"image","rotateWithOffset","float32");F(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},a={radians:t,fillValue:e,center:n};return D.runKernel(Ga,s,a)}var IR=A({rotateWithOffset_:iQ});function Ls(r,t,e,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let a=r.shape[0];return e=Math.min(e,a),F(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),F(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),F(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),F(t.rank===1,()=>"scores must be a 1D tensor"),F(t.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`),F(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function uQ(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=S(r,"boxes","nonMaxSuppression","float32"),a=S(t,"scores","nonMaxSuppression","float32"),i=Ls(s,a,e,n,o);e=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u={maxOutputSize:e,iouThreshold:n,scoreThreshold:o};return D.runKernel(Da,{boxes:s,scores:a},u)}var CR=A({nonMaxSuppression_:uQ});function kR(r,t,e){let n=pQ(r,t,e),o=n<0?-(n+1):n;r.splice(o,0,t)}function pQ(r,t,e){return mQ(r,t,e||lQ)}function lQ(r,t){return r>t?1:r<t?-1:0}function mQ(r,t,e){let n=0,o=r.length,s=0,a=!1;for(;n<o;){s=n+(o-n>>>1);let i=e(t,r[s]);i>0?n=s+1:(o=s,a=!i)}return a?n:-n-1}function Vy(r,t,e,n,o){return kA(r,t,e,n,o,0)}function Hy(r,t,e,n,o,s){return kA(r,t,e,n,o,0,!1,s,!0)}function qy(r,t,e,n,o,s){return kA(r,t,e,n,o,s,!0)}function kA(r,t,e,n,o,s,a=!1,i=!1,u=!1){let p=[];for(let g=0;g<t.length;g++)t[g]>o&&p.push({score:t[g],boxIndex:g,suppressBeginIndex:0});p.sort(SR);let l=s>0?-.5/s:0,m=[],c=[];for(;m.length<e&&p.length>0;){let g=p.pop(),{score:b,boxIndex:T,suppressBeginIndex:x}=g;if(b<o)break;let I=!1;for(let k=m.length-1;k>=x;--k){let w=cQ(r,T,m[k]);if(w>=n){I=!0;break}if(g.score=g.score*dQ(n,l,w),g.score<=o)break}g.suppressBeginIndex=m.length,I||(g.score===b?(m.push(T),c.push(g.score)):g.score>o&&kR(p,g,SR))}let d=m.length,f=e-d;i&&f>0&&(m.push(...new Array(f).fill(0)),c.push(...new Array(f).fill(0)));let h={selectedIndices:m};return a&&(h.selectedScores=c),u&&(h.validOutputs=d),h}function cQ(r,t,e){let n=r.subarray(t*4,t*4+4),o=r.subarray(e*4,e*4+4),s=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),i=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),p=Math.min(o[0],o[2]),l=Math.min(o[1],o[3]),m=Math.max(o[0],o[2]),c=Math.max(o[1],o[3]),d=(i-s)*(u-a),f=(m-p)*(c-l);if(d<=0||f<=0)return 0;let h=Math.max(s,p),g=Math.max(a,l),b=Math.min(i,m),T=Math.min(u,c),x=Math.max(b-h,0)*Math.max(T-g,0);return x/(d+f-x)}function dQ(r,t,e){let n=Math.exp(t*e*e);return e<=r?n:0}function SR(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}async function fQ(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY){let s=S(r,"boxes","nonMaxSuppressionAsync"),a=S(t,"scores","nonMaxSuppressionAsync"),i=Ls(s,a,e,n,o);e=i.maxOutputSize,n=i.iouThreshold,o=i.scoreThreshold;let u=await Promise.all([s.data(),a.data()]),p=u[0],l=u[1],{selectedIndices:m}=Vy(p,l,e,n,o);return s!==r&&s.dispose(),a!==t&&a.dispose(),Xt(m,"int32")}var vR=fQ;function hQ(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=S(r,"boxes","nonMaxSuppression"),i=S(t,"scores","nonMaxSuppression"),u=Ls(a,i,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let p={boxes:a,scores:i},l={maxOutputSize:e,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},m=D.runKernel(Fa,p,l);return{selectedIndices:m[0],selectedScores:m[1]}}var AR=A({nonMaxSuppressionWithScore_:hQ});async function gQ(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let a=S(r,"boxes","nonMaxSuppressionAsync"),i=S(t,"scores","nonMaxSuppressionAsync"),u=Ls(a,i,e,n,o,s);e=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let p=await Promise.all([a.data(),i.data()]),l=p[0],m=p[1],{selectedIndices:c,selectedScores:d}=qy(l,m,e,n,o,s);return a!==r&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Xt(c,"int32"),selectedScores:Xt(d)}}var wR=gQ;function bQ(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=S(r,"boxes","nonMaxSuppression"),i=S(t,"scores","nonMaxSuppression"),u=Ls(a,i,e,n,o,null),p=u.maxOutputSize,l=u.iouThreshold,m=u.scoreThreshold,c={boxes:a,scores:i},d={maxOutputSize:p,iouThreshold:l,scoreThreshold:m,padToMaxOutputSize:s},f=D.runKernel(Yi,c,d);return{selectedIndices:f[0],validOutputs:f[1]}}var NR=A({nonMaxSuppressionPadded_:bQ});async function yQ(r,t,e,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let a=S(r,"boxes","nonMaxSuppressionAsync"),i=S(t,"scores","nonMaxSuppressionAsync"),u=Ls(a,i,e,n,o,null),p=u.maxOutputSize,l=u.iouThreshold,m=u.scoreThreshold,[c,d]=await Promise.all([a.data(),i.data()]),{selectedIndices:f,validOutputs:h}=Hy(c,d,p,l,m,s);return a!==r&&a.dispose(),i!==t&&i.dispose(),{selectedIndices:Xt(f,"int32"),validOutputs:ce(h,"int32")}}var DR=yQ;function TQ(r,t,e=!1,n=!1){let o=S(r,"images","resizeBilinear");F(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),F(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),F(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=$(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,i={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},p=D.runKernel(zo,i,u);return a?$(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var FR=A({resizeBilinear_:TQ});function xQ(r,t,e=!1,n=!1){let o=S(r,"images","resizeNearestNeighbor");F(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),F(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),F(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),F(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,a=!1;o.rank===3&&(a=!0,s=$(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=t,i={images:s},u={alignCorners:e,halfPixelCenters:n,size:t},p=D.runKernel(Oo,i,u);return a?$(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var RR=A({resizeNearestNeighbor_:xQ});function IQ(r,t="binary",e=!1,n=.5){let o=S(r,"image","threshold"),s=.2989,a=.587,i=.114,u=o.shape[0]*o.shape[1],p=_(Xt([n]),255),l,m,c,d;if(F(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),F(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),F(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),F(t==="otsu"||t==="binary",()=>`Method must be binary or otsu, but was ${t}`),o.shape[2]===3){[l,m,c]=Fr(o,[1,1,1],-1);let g=_(l,s),b=_(m,a),T=_(c,i);d=Z(Z(g,b),T)}else d=r;if(t==="otsu"){let g=oy(oe(Dy(d),"int32"),wr([]),256);p=CQ(g,u)}let f=e?Es(d,p):mr(d,p);return oe(_(f,255),"int32")}function CQ(r,t){let e=Xt([-1]),n=Xt([0]),o=Xt([0]),s,a,i,u,p,l;for(let m=0;m<r.size-1;m++){s=Ge(r,0,m+1),a=Ge(r,m+1),p=me(de(s),t),l=me(de(a),t);let c=de(_(s,dp(0,s.size)));i=me(c,de(s));let d=ki(a.shape,s.size),f=Z(dp(0,a.size),d),h=_(a,f);u=me(de(h),de(a));let g=le(i,u),b=le(i,u),T=_(p,l);o=_(_(T,g),b);let x=mr(o,n);n=Kt(x,o,n),e=Kt(x,Xt([m]),e)}return e}var PR=A({threshold_:IQ});function kQ(r,t,e="nearest",n="constant",o=0,s){let a=S(r,"image","transform","float32"),i=S(t,"transforms","transform","float32");F(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),F(i.rank===2&&(i.shape[0]===a.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),F(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:a,transforms:i},p={interpolation:e,fillMode:n,fillValue:o,outputShape:s};return D.runKernel(za,u,p)}var MR=A({transform_:kQ});function SQ(r,t,e){F(t%1===0,()=>`bandPart(): numLower must be an integer, got ${t}.`),F(e%1===0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let n=S(r,"a","bandPart");F(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,a]=n.shape.slice(-2);if(!(t<=s))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${s}).`);if(!(e<=a))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${a}).`);t<0&&(t=s),e<0&&(e=a);let i=$(dp(0,s,1,"int32"),[-1,1]),u=dp(0,a,1,"int32"),p=le(i,u),l=Qr(Es(p,ce(+t,"int32")),Ms(p,ce(-e,"int32"))),m=Ct([s,a],n.dtype);return $(Tr(Wr($(n,[-1,s,a])).map(c=>Kt(l,c,m))),o)}var ER=A({bandPart_:SQ});function vQ(r){let t;if(Array.isArray(r)){t=!1,F(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)F(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else t=!0,r=Fr(r,r.shape[0],0).map(o=>_s(o,[0]));F(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],n=r;for(let o=0;o<r.length;++o)e.push(D.tidy(()=>{let s=n[o];if(o>0)for(let a=0;a<o;++a){let i=_(de(_(e[a],s)),e[a]);s=le(s,i)}return me(s,nl(s,"euclidean"))}));return t?Tr(e,0):e}var _R=A({gramSchmidt_:vQ});function AQ(r,t=!1){if(F(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return LR(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((u,p)=>u*p),n=Wr($(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[p,l]=LR(u,t);o.push(p),s.push(l)});let a=$(Tr(o,0),r.shape),i=$(Tr(s,0),r.shape);return[a,i]}}function LR(r,t=!1){return D.tidy(()=>{F(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],n=r.shape[1],o=ol(e),s=fn(r),a=Va([[1]],[1,1]),i=fn(a),u=e>=n?n:e;for(let p=0;p<u;++p){let l=s,m=i,c=o;[i,s,o]=D.tidy(()=>{let d=Ge(s,[p,p],[e-p,1]),f=nl(d),h=Ge(s,[p,p],[1,1]),g=Kt(mr(h,0),Va([[-1]]),Va([[1]])),b=le(h,_(g,f)),T=me(d,b);T.shape[0]===1?i=fn(a):i=ct([a,Ge(T,[1,0],[T.shape[0]-1,T.shape[1]])],0);let x=et(me(je(g,b),f)),I=Ge(s,[p,0],[e-p,n]),k=_(x,i),w=Ke(i);if(p===0)s=le(I,je(k,je(w,I)));else{let M=le(I,je(k,je(w,I)));s=ct([Ge(s,[0,0],[p,n]),M],0)}let R=Ke(k),P=Ge(o,[0,p],[e,o.shape[1]-p]);if(p===0)o=le(P,je(je(P,i),R));else{let M=le(P,je(je(P,i),R));o=ct([Ge(o,[0,0],[e,p]),M],1)}return[i,s,o]}),Pe([l,m,c])}return!t&&e>n&&(o=Ge(o,[0,0],[e,n]),s=Ge(s,[0,0],[n,n])),[o,s]})}var $R=A({qr_:AQ});var Ha=(o=>(o[o.NONE=0]="NONE",o[o.MEAN=1]="MEAN",o[o.SUM=2]="SUM",o[o.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",o))(Ha||{});function wQ(r,t,e=3){let n=S(r,"losses","computeWeightedLoss"),o=null;t!=null&&(o=S(t,"weights","computeWeightedLoss"));let s=o==null?n:_(n,o);if(e===0)return s;if(e===2)return de(s);if(e===1){if(o==null)return Ot(s);{let a=n.size/o.size,i=me(de(s),de(o));return a>1?me(i,ce(a)):i}}if(e===3){if(o==null)return me(de(s),ce(n.size));{let a=_(o,yr(n.shape)),i=oe(de(pu(a,ce(0))),"float32");return me(de(s),i)}}throw Error(`Unknown reduction: ${e}`)}var Kr=A({computeWeightedLoss_:wQ});function NQ(r,t,e,n=3){let o=S(r,"labels","absoluteDifference"),s=S(t,"predictions","absoluteDifference"),a=null;e!=null&&(a=S(e,"weights","absoluteDifference")),Gt(o.shape,s.shape,"Error in absoluteDifference: ");let i=Wt(le(o,s));return Kr(i,a,n)}var BR=A({absoluteDifference_:NQ});function DQ(r,t,e,n,o=3){let s=S(r,"labels","cosineDistance"),a=S(t,"predictions","cosineDistance"),i=null;n!=null&&(i=S(n,"weights","cosineDistance")),Gt(s.shape,a.shape,"Error in cosineDistance: ");let u=ce(1),p=le(u,de(_(s,a),e,!0));return Kr(p,i,o)}var OR=A({cosineDistance_:DQ});function FQ(r,t,e,n=3){let o=S(r,"labels","hingeLoss"),s=S(t,"predictions","hingeLoss"),a=null;e!=null&&(a=S(e,"weights","hingeLoss")),Gt(o.shape,s.shape,"Error in hingeLoss: ");let i=ce(1);o=le(_(ce(2),o),i);let u=Jr(le(i,_(o,s)));return Kr(u,a,n)}var zR=A({hingeLoss_:FQ});function RQ(r,t,e,n=1,o=3){let s=S(r,"labels","huberLoss"),a=S(t,"predictions","huberLoss"),i=null;e!=null&&(i=S(e,"weights","huberLoss")),Gt(s.shape,a.shape,"Error in huberLoss: ");let u=ce(n),p=Wt(le(a,s)),l=cp(p,u),m=le(p,l),c=Z(_(ce(.5),Ye(l)),_(u,m));return Kr(c,i,o)}var GR=A({huberLoss_:RQ});function PQ(r,t,e,n=1e-7,o=3){let s=S(r,"labels","logLoss"),a=S(t,"predictions","logLoss"),i=null;e!=null&&(i=S(e,"weights","logLoss")),Gt(s.shape,a.shape,"Error in logLoss: ");let u=ce(1),p=ce(n),l=et(_(s,Ur(Z(a,p)))),m=_(le(u,s),Ur(Z(le(u,a),p))),c=le(l,m);return Kr(c,i,o)}var UR=A({logLoss_:PQ});function MQ(r,t,e,n=3){let o=S(r,"labels","meanSquaredError"),s=S(t,"predictions","meanSquaredError"),a=null;e!=null&&(a=S(e,"weights","meanSquaredError")),Gt(o.shape,s.shape,"Error in meanSquaredError: ");let i=Ly(o,s);return Kr(i,a,n)}var WR=A({meanSquaredError_:MQ});function EQ(r,t){let e=S(r,"labels","sigmoidCrossEntropyWithLogits"),n=S(t,"logits","sigmoidCrossEntropyWithLogits");Gt(e.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=Jr(n),s=_(n,e),a=xc(br(et(Wt(n))));return Z(le(o,s),a)}function _Q(r,t,e,n=0,o=3){let s=S(r,"multiClassLabels","sigmoidCrossEntropy"),a=S(t,"logits","sigmoidCrossEntropy"),i=null;if(e!=null&&(i=S(e,"weights","sigmoidCrossEntropy")),Gt(s.shape,a.shape,"Error in sigmoidCrossEntropy: "),n>0){let p=ce(n),l=ce(1),m=ce(.5);s=Z(_(s,le(l,p)),_(m,p))}let u=EQ(s,a);return Kr(u,i,o)}var KR=A({sigmoidCrossEntropy_:_Q});function LQ(r,t,e=-1){if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${t.rank} and dim was ${e}`);return gn((o,s,a)=>{let u=xy(s,[e],!0),p=le(oe(s,"float32"),u);a([o,p]);let l=et(_(p,o));return{value:de(l,[e]),gradFunc:(d,f)=>{let[h,g]=f,b=Ps(d.shape,[e]);return[_($(d,b),le(oe(h,"float32"),br(g))),_($(d,b),le(br(g),oe(h,"float32")))]}}})(r,t)}function $Q(r,t,e,n=0,o=3){let s=S(r,"onehotLabels","softmaxCrossEntropy"),a=S(t,"logits","softmaxCrossEntropy"),i=null;if(e!=null&&(i=S(e,"weights","softmaxCrossEntropy")),Gt(s.shape,a.shape,"Error in softmaxCrossEntropy: "),n>0){let p=ce(n),l=ce(1),m=ce(s.shape[1]);s=Z(_(s,le(l,p)),me(p,m))}let u=LQ(s,a);return Kr(u,i,o)}var VR=A({softmaxCrossEntropy_:$Q});function BQ(r,t,e,n){let o=S(r,"indices","sparseFillEmptyRows","int32"),s=S(t,"values","sparseFillEmptyRows"),a=S(e,"denseShape","sparseFillEmptyRows","int32"),i=S(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);let u={indices:o,values:s,denseShape:a,defaultValue:i},p=D.runKernel(Ku,u);return{outputIndices:p[0],outputValues:p[1],emptyRowIndicator:p[2],reverseIndexMap:p[3]}}var HR=A({sparseFillEmptyRows_:BQ});function OQ(r,t,e){let n=S(r,"inputIndices","sparseReshape","int32"),o=S(t,"inputShape","sparseReshape","int32"),s=S(e,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let a={inputIndices:n,inputShape:o,newShape:s},i=D.runKernel(eu,a);return{outputIndices:i[0],outputShape:i[1]}}var qR=A({sparseReshape_:OQ});function zQ(r,t,e){let n=S(r,"data","sparseSegmentMean"),o=S(t,"indices","sparseSegmentMean","int32"),s=S(e,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return D.runKernel(Vu,a)}var jR=A({sparseSegmentMean_:zQ});function GQ(r,t,e){let n=S(r,"data","sparseSegmentSum"),o=S(t,"indices","sparseSegmentSum","int32"),s=S(e,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let a={data:n,indices:o,segmentIds:s};return D.runKernel(Hu,a)}var XR=A({sparseSegmentSum_:GQ});function UQ(r,t,e,n,o,s,a,i){let u=S(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let p=S(t,"dataSplits","stringNGrams");if(p.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let l={separator:e,nGramWidths:n,leftPad:o,rightPad:s,padWidth:a,preserveShortSequences:i},m={data:u,dataSplits:p},c=D.runKernel(bi,m,l);return{nGrams:c[0],nGramsSplits:c[1]}}var YR=A({stringNGrams_:UQ});function WQ(r,t,e=!0){let n=S(r,"input","stringSplit","string"),o=S(t,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:e},a={input:n,delimiter:o},i=D.runKernel(ju,a,s);return{indices:i[0],values:i[1],shape:i[2]}}var ZR=A({stringSplit_:WQ});function KQ(r,t){let e=S(r,"input","stringToHashBucketFast","string"),n={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");let o={input:e};return D.runKernel(Xu,o,n)}var QR=A({stringToHashBucketFast_:KQ});var VQ={fft:Nc,ifft:ll,rfft:Dc,irfft:_y},HQ={hammingWindow:gR,hannWindow:Wy,frame:Ky,stft:bR},hp={flipLeftRight:TR,grayscaleToRGB:xR,resizeNearestNeighbor:RR,resizeBilinear:FR,rotateWithOffset:IR,cropAndResize:yR,nonMaxSuppression:CR,nonMaxSuppressionAsync:vR,nonMaxSuppressionWithScore:AR,nonMaxSuppressionWithScoreAsync:wR,nonMaxSuppressionPadded:NR,nonMaxSuppressionPaddedAsync:DR,threshold:PR,transform:MR},SA={bandPart:ER,gramSchmidt:_R,qr:$R},qQ={absoluteDifference:BR,computeWeightedLoss:Kr,cosineDistance:OR,hingeLoss:zR,huberLoss:GR,logLoss:UR,meanSquaredError:WR,sigmoidCrossEntropy:KR,softmaxCrossEntropy:VR},jQ={sparseFillEmptyRows:HR,sparseReshape:qR,sparseSegmentMean:jR,sparseSegmentSum:XR},XQ={stringNGrams:YR,stringSplit:ZR,stringToHashBucketFast:QR};var Vr=class extends Dh{minimize(e,n=!1,o){let{value:s,grads:a}=this.computeGradients(e,o);if(o!=null){let i=o.map(u=>({name:u.name,tensor:a[u.name]}));this.applyGradients(i)}else this.applyGradients(a);return Pe(a),n?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,n){return by(e,n)}dispose(){this.iterations_!=null&&Pe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:ce(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(Vr,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var gp=class extends Vr{constructor(e,n,o=null){super();this.learningRate=e;this.rho=n;this.epsilon=o;this.accumulatedGrads=[];this.accumulatedUpdates=[];o==null&&(this.epsilon=D.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,s)=>{let a=D.registeredVariables[o],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${o}/accum_grad`,variable:U(()=>Fe(a).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${o}/accum_var`,variable:U(()=>Fe(a).variable(i))});let u=Array.isArray(e)?e[s].tensor:e[o];if(u==null)return;let p=this.accumulatedGrads[s].variable,l=this.accumulatedUpdates[s].variable;U(()=>{let m=Z(_(p,this.rho),_(Ye(u),1-this.rho)),c=_(me(Bt(Z(l,this.epsilon)),Bt(Z(p,this.epsilon))),u),d=Z(_(l,this.rho),_(Ye(c),1-this.rho));p.assign(m),l.assign(d);let f=Z(_(c,-this.learningRate),a);a.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Pe(this.accumulatedGrads.map(e=>e.variable)),Pe(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);let n=e.length/2,o=!1;this.accumulatedGrads=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedUpdates=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.rho,n.epsilon)}};gp.className="Adadelta";En(gp);var bp=class extends Vr{constructor(e,n=.1){super();this.learningRate=e;this.initialAccumulatorValue=n;this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,s)=>{let a=D.registeredVariables[o];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${o}/accumulator`,variable:U(()=>ki(a.shape,this.initialAccumulatorValue).variable(!1))});let i=Array.isArray(e)?e[s].tensor:e[o];if(i==null)return;let u=this.accumulatedGrads[s].variable;U(()=>{let p=Z(u,Ye(i));u.assign(p);let l=Z(_(me(i,Bt(Z(p,D.backend.epsilon()))),-this.learningRate),a);a.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Pe(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let n=!1;this.accumulatedGrads=e.map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,n){return new e(n.learningRate,n.initialAccumulatorValue)}};bp.className="Adagrad";En(bp);var yp=class extends Vr{constructor(e,n,o,s=null){super();this.learningRate=e;this.beta1=n;this.beta2=o;this.epsilon=s;this.accumulatedFirstMoment=[];this.accumulatedSecondMoment=[];U(()=>{this.accBeta1=ce(n).variable(),this.accBeta2=ce(o).variable()}),s==null&&(this.epsilon=D.backend.epsilon())}applyGradients(e){let n=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);U(()=>{let o=le(1,this.accBeta1),s=le(1,this.accBeta2);n.forEach((a,i)=>{let u=D.registeredVariables[a],p=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:U(()=>Fe(u).variable(p))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${a}/v`,variable:U(()=>Fe(u).variable(p))});let l=Array.isArray(e)?e[i].tensor:e[a];if(l==null)return;let m=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,d=Z(_(m,this.beta1),_(l,1-this.beta1)),f=Z(_(c,this.beta2),_(Ye(l),1-this.beta2)),h=me(d,o),g=me(f,s);m.assign(d),c.assign(f);let b=Z(_(me(h,Z(Bt(g),this.epsilon)),-this.learningRate),u);u.assign(b)}),this.accBeta1.assign(_(this.accBeta1,this.beta1)),this.accBeta2.assign(_(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Pe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Pe(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e),U(()=>{this.accBeta1.assign(qn(this.beta1,this.iterations_+1)),this.accBeta2.assign(qn(this.beta2,this.iterations_+1))});let n=e.length/2,o=!1;this.accumulatedFirstMoment=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedSecondMoment=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon)}};yp.className="Adam";En(yp);var Tp=class extends Vr{constructor(e,n,o,s=null,a=0){super();this.learningRate=e;this.beta1=n;this.beta2=o;this.epsilon=s;this.decay=a;this.accumulatedFirstMoment=[];this.accumulatedWeightedInfNorm=[];U(()=>{this.iteration=ce(0).variable(),this.accBeta1=ce(n).variable()}),s==null&&(this.epsilon=D.backend.epsilon())}applyGradients(e){let n=Array.isArray(e)?e.map(o=>o.name):Object.keys(e);U(()=>{let o=le(1,this.accBeta1),s=me(-this.learningRate,Z(_(this.iteration,this.decay),1));n.forEach((a,i)=>{let u=D.registeredVariables[a],p=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${a}/m`,variable:Fe(u).variable(p)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${a}/v`,variable:Fe(u).variable(p)});let l=Array.isArray(e)?e[i].tensor:e[a];if(l==null)return;let m=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,d=Z(_(m,this.beta1),_(l,1-this.beta1)),f=_(c,this.beta2),h=Wt(l),g=ts(f,h);m.assign(d),c.assign(g);let b=Z(_(me(s,o),me(d,Z(g,this.epsilon))),u);u.assign(b)}),this.iteration.assign(Z(this.iteration,1)),this.accBeta1.assign(_(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Pe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Pe(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,n){return new e(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}};Tp.className="Adamax";En(Tp);var Ai=class extends Vr{constructor(e){super();this.learningRate=e;this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,s)=>{let a=Array.isArray(e)?e[s].tensor:e[o];if(a==null)return;let i=D.registeredVariables[o];U(()=>{let u=Z(_(this.c,a),i);i.assign(u)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Ut(ce(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,n){return new e(n.learningRate)}};Ai.className="SGD";En(Ai);var xp=class extends Ai{constructor(e,n,o=!1){super(e);this.learningRate=e;this.momentum=n;this.useNesterov=o;this.accumulations=[];this.m=ce(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,s)=>{let a=D.registeredVariables[o];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${o}/momentum`,variable:U(()=>Fe(a).variable(!1))});let i=this.accumulations[s].variable,u=Array.isArray(e)?e[s].tensor:e[o];u!=null&&U(()=>{let p,l=Z(_(this.m,i),u);this.useNesterov?p=Z(_(this.c,Z(u,_(l,this.m))),a):p=Z(_(this.c,l),a),i.assign(l),a.assign(p)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Pe(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let n=!1;this.accumulations=e.map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,n){return new e(n.learningRate,n.momentum,n.useNesterov)}};xp.className="Momentum";En(xp);var Ip=class extends Vr{constructor(e,n=.9,o=0,s=null,a=!1){super();this.learningRate=e;this.decay=n;this.momentum=o;this.epsilon=s;this.accumulatedMeanSquares=[];this.accumulatedMoments=[];this.accumulatedMeanGrads=[];if(this.centered=a,s==null&&(this.epsilon=D.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(o=>o.name):Object.keys(e)).forEach((o,s)=>{let a=D.registeredVariables[o],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${o}/rms`,variable:U(()=>Fe(a).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${o}/momentum`,variable:U(()=>Fe(a).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${o}/mg`,variable:U(()=>Fe(a).variable(i))});let u=Array.isArray(e)?e[s].tensor:e[o];if(u==null)return;let p=this.accumulatedMeanSquares[s].variable,l=this.accumulatedMoments[s].variable;U(()=>{let m=Z(_(p,this.decay),_(Ye(u),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[s].variable,d=Z(_(c,this.decay),_(u,1-this.decay)),f=me(_(u,this.learningRate),Bt(le(m,Z(Ye(d),this.epsilon)))),h=Z(_(l,this.momentum),f);p.assign(m),c.assign(d),l.assign(h);let g=le(a,h);a.assign(g)}else{let c=Z(_(p,this.decay),_(Ye(u),1-this.decay)),d=Z(_(l,this.momentum),me(_(u,this.learningRate),Bt(Z(c,this.epsilon))));p.assign(c),l.assign(d);let f=le(a,d);a.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Pe(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Pe(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Pe(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(e){e=await this.extractIterations(e);let n=this.centered?e.length/3:e.length/2,o=!1;this.accumulatedMeanSquares=e.slice(0,n).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.accumulatedMoments=e.slice(n,n*2).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})),this.centered&&(this.accumulatedMeanGrads=e.slice(n*2,n*3).map(s=>({originalName:s.name,variable:s.tensor.variable(o)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,n){return new e(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}};Ip.className="RMSProp";En(Ip);var qa=class{static sgd(t){return new Ai(t)}static momentum(t,e,n=!1){return new xp(t,e,n)}static rmsprop(t,e=.9,n=0,o=null,s=!1){return new Ip(t,e,n,o,s)}static adam(t=.001,e=.9,n=.999,o=null){return new yp(t,e,n,o)}static adadelta(t=.001,e=.95,n=null){return new gp(t,e,n)}static adamax(t=.002,e=.9,n=.999,o=null,s=0){return new Tp(t,e,n,o,s)}static adagrad(t,e=.1){return new bp(t,e)}};var hl={sgd:qa.sgd,momentum:qa.momentum,adadelta:qa.adadelta,adagrad:qa.adagrad,rmsprop:qa.rmsprop,adamax:qa.adamax,adam:qa.adam};var YQ=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:r=>r())();function Bh(){return new Promise(r=>YQ(()=>r()))}var C={};Xe(C,{ERF_A1:()=>m7,ERF_A2:()=>c7,ERF_A3:()=>d7,ERF_A4:()=>f7,ERF_A5:()=>h7,ERF_P:()=>l7,PARALLELIZE_THRESHOLD:()=>jy,RowPartitionType:()=>JR,SELU_SCALE:()=>AA,SELU_SCALEALPHA:()=>vA,applyActivation:()=>dl,assertAndGetBroadcastShape:()=>ze,assertAxesAreInnerMostDims:()=>vX,assertParamsConsistent:()=>ZQ,assignToTypedArray:()=>I7,axesAreInnerMostDims:()=>mA,calculateShapes:()=>C2,checkEinsumDimSizes:()=>w7,checkPadOnDimRoundingMode:()=>Et,combineLocations:()=>sF,combineRaggedTensorToTensorShapes:()=>JQ,complexWithEvenIndex:()=>y7,complexWithOddIndex:()=>T7,computeConv2DInfo:()=>rl,computeConv3DInfo:()=>V2,computeDefaultPad:()=>lA,computeDilation2DInfo:()=>w8,computeOptimalWindowSize:()=>n7,computeOutAndReduceShapes:()=>cA,computeOutShape:()=>QQ,computePool2DInfo:()=>pA,computePool3DInfo:()=>N8,convertConv2DDataFormat:()=>H2,decodeEinsumEquation:()=>v7,eitherStridesOrDilationsAreOne:()=>Er,expandShapeToKeepDim:()=>Ps,exponent:()=>k7,exponents:()=>C7,fromStringArrayToUint8:()=>j7,fromUint8ToStringArray:()=>q7,getAxesPermutation:()=>dA,getBroadcastDims:()=>T2,getComplexWithIndex:()=>x7,getEinsumComputePath:()=>N7,getEinsumPermutation:()=>A7,getFusedBiasGradient:()=>cl,getFusedDyActivation:()=>ml,getImageCenter:()=>o7,getInnerMostAxes:()=>AX,getPermuted:()=>a7,getRaggedRank:()=>t7,getReductionAxes:()=>At,getReshaped:()=>s7,getReshapedPermuted:()=>i7,getRowPartitionTypesHelper:()=>e7,getSliceBeginCoords:()=>u7,getSliceSize:()=>p7,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>P7,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>M7,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>E7,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>$7,getSparseReshapeInputOutputMismatchErrorMessage:()=>O7,getSparseReshapeInputOutputMultipleErrorMessage:()=>B7,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>_7,getSparseReshapeNegativeOutputDimErrorMessage:()=>L7,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>W7,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>z7,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>G7,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>U7,getUndoAxesPermutation:()=>Ph,isIdentityPermutation:()=>D7,log:()=>_6,mergeRealAndImagArrays:()=>g7,prepareAndValidate:()=>I2,prepareSplitSize:()=>R7,segment_util:()=>NA,shouldFuse:()=>fl,slice_util:()=>It,splitRealAndImagArrays:()=>b7,tupleValuesAreOne:()=>Qo,upcastType:()=>$t,validateDefaultValueShape:()=>r7,validateInput:()=>Xb,validateUpdateShape:()=>nA,warn:()=>yi});function ZQ(r,t){let e=r[0].length;r.forEach((o,s)=>{F(o.length===e,()=>`Error in concat${e}D: rank of tensors[${s}] must be the same as the rank of the rest (${e})`)}),F(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let n=r[0];r.forEach((o,s)=>{for(let a=0;a<e;a++)F(a===t||o[a]===n[a],()=>`Error in concat${e}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function QQ(r,t){let e=r[0].slice();for(let n=1;n<r.length;n++)e[t]+=r[n][t];return e}var JR=(a=>(a[a.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",a[a.VALUE_ROWIDS=1]="VALUE_ROWIDS",a[a.ROW_LENGTHS=2]="ROW_LENGTHS",a[a.ROW_SPLITS=3]="ROW_SPLITS",a[a.ROW_LIMITS=4]="ROW_LIMITS",a[a.ROW_STARTS=5]="ROW_STARTS",a))(JR||{});function JQ(r,t,e){let n=new Array;if(e==null&&t==null)return n;if(t==null)for(;n.length<r+e.length;)n.push(-1);else n=t.slice();if(e==null)return n;if(r+e.length!==n.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${r+e.length}, but shape.rank = ${n.length}`);for(let o=1;o<e.length;++o){let s=e[o],a=n[n.length-e.length+o],i=n[a];if(s>=0)if(i>=0){if(i!==s)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${o+r}] = ${s} but shape[${o+r}] = ${i}`)}else n[a]=s}return n}function e7(r){let t={FIRST_DIM_SIZE:0,VALUE_ROWIDS:1,ROW_LENGTHS:2,ROW_SPLITS:3,ROW_LIMITS:4,ROW_STARTS:5},e=[];for(let n of r)if(n in t)e.push(t[n]);else break;return e}function t7(r){return r.length===0?0:r[0]===0?r.length-1:r.length}function r7(r,t){if(r==null||t==null)return;let e=r.length,n=t.length;if(e>=n)throw new Error(`defaultValue.shape=${r} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${e} must be less than ragged tensor input flatValues.rank = ${n})`);for(let o=0;o<Math.min(e,n-1);++o){let s=r[o],a=t[o+1];if(s>=0&&a>=0&&s!==1&&s!==a)throw new Error(`defaultValue.shape=${r}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${o-r.length}] = ${s} but ragged tensor input.flatValues.shape[${o-r.length}] = ${a}`)}}var jy=30;function n7(r){return r<=jy?r:Fm(r,Math.floor(Math.sqrt(r)))}function o7(r,t,e){let n=e*(typeof r=="number"?r:r[0]),o=t*(typeof r=="number"?r:r[1]);return[n,o]}function s7(r,t,e,n=!0){let o=[];if(n)o=o.concat(t.slice(0)),o.push(r[0]/e),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=t.length;for(let a=0;a<s;++a)o=o.concat([r[a+1]/t[a],t[a]]);o=o.concat(r.slice(s+1))}return o}function a7(r,t,e=!0){let n=[];if(e){n.push(t);for(let o=t+1;o<r;++o)o<=2*t?(n.push(o),n.push(o-(t+1))):n.push(o)}else{let o=[],s=[];for(let a=1;a<r;++a)a>=t*2+1||a%2===1?s.push(a):o.push(a);n.push(...o),n.push(0),n.push(...s)}return n}function i7(r,t,e,n=!0){let o=[];n?o.push(r[0]/e):o.push(r[0]*e);for(let s=1;s<r.length;++s)s<=t.length?n?o.push(t[s-1]*r[s]):o.push(r[s]/t[s-1]):o.push(r[s]);return o}function u7(r,t){let e=[0];for(let n=0;n<t;++n)e.push(r[n][0]);return e}function p7(r,t,e){let n=r.slice(0,1);for(let o=0;o<e;++o)n.push(r[o+1]-t[o][0]-t[o][1]);return n}var vA=1.7580993408473768,AA=1.0507009873554805;var l7=.3275911,m7=.254829592,c7=-.284496736,d7=1.421413741,f7=-1.453152027,h7=1.061405429;function g7(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let n=0;n<e.length;n+=2)e[n]=r[n/2],e[n+1]=t[n/2];return e}function b7(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)t[n/2]=r[n],e[n/2]=r[n+1];return{real:t,imag:e}}function y7(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=0;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function T7(r){let t=Math.floor(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let o=2;o<r.length;o+=4)e[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:e,imag:n}}function x7(r,t){let e=r[t*2],n=r[t*2+1];return{real:e,imag:n}}function I7(r,t,e,n){r[n*2]=t,r[n*2+1]=e}function C7(r,t){let e=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(t?2:-2)*Math.PI*(o/r);e[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:e,imag:n}}function k7(r,t,e){let n=(e?2:-2)*Math.PI*(r/t),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var wA="->",S7=/->/g,eP=",",tP="...";function v7(r,t){r=r.replace(/\s/g,"");let e=(r.length-r.replace(S7,"").length)/wA.length;if(e<1)throw new Error("Equations without an arrow are not supported.");if(e>1)throw new Error(`Equation must contain exactly one arrow ("${wA}").`);let[n,o]=r.split(wA);F(n.indexOf(tP)===-1,()=>`The ellipsis notation ("${tP}") is not supported yet.`);let s=n.split(eP),a=s.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let i=[];for(let c=0;c<o.length;++c){let d=o[c];if(!s.some(f=>f.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);i.indexOf(d)===-1&&i.push(d)}for(let c=0;c<n.length;++c){let d=n[c];i.indexOf(d)===-1&&d!==eP&&i.push(d)}let u=new Array(s.length);for(let c=0;c<a;++c){if(new Set(s[c].split("")).size!==s[c].length)throw new Error(`Found duplicate axes in input component ${s[c]}. Support for duplicate axes in input is not implemented yet.`);u[c]=[];for(let d=0;d<s[c].length;++d)u[c].push(i.indexOf(s[c][d]))}let p=i.length,l=o.length,m=[];for(let c=l;c<p;++c)m.push(c);return{allDims:i,summedDims:m,idDims:u}}function A7(r,t){let e=new Array(r);e.fill(-1);for(let o=0;o<t.length;++o)e[t[o]]=o;let n=[];for(let o=0;o<r;++o)e[o]===-1&&n.push(o);return e=e.filter(o=>o!==-1),{permutationIndices:e,expandDims:n}}function w7(r,t,e){let n=new Array(r);for(let o=0;o<e.length;++o){let s=e[o].shape;for(let a=0;a<t[o].length;++a)n[t[o][a]]===void 0?n[t[o][a]]=s[a]:F(n[t[o][a]]===s[a],()=>`Expected dimension ${n[t[o][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function N7(r,t){let e=r,n=[],o=0;r.length===0&&e.push(-1),o=r.length+1;for(let a=0;a<o;++a)n.push([]);let s=[];for(let a=0;a<e.length;++a){let i=e[a],u=F7(t,i);for(let p of u)s.indexOf(p)===-1&&(n[a].push(p),s.push(p))}return{path:e,steps:n}}function D7(r){return r.every((t,e)=>t===e)}function F7(r,t){let e=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(t)!==-1||t===-1)&&e.push(n);return e}function R7(r,t,e=0){let n=[];if(typeof t=="number")F(r.shape[e]%t===0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(r.shape[e]/t);else{let o=t.reduce((a,i)=>(i===-1&&(a+=1),a),0);F(o<=1,()=>"There should be only one negative value in split array.");let s=t.indexOf(-1);if(s!==-1){let a=t.reduce((i,u)=>u>0?i+u:i);t[s]=r.shape[e]-a}F(r.shape[e]===t.reduce((a,i)=>a+i),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}function P7(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function M7(r,t){return`indices(${r}, 0) is invalid: ${t} < 0`}function E7(r,t,e){return`indices(${r}, 0) is invalid: ${t} >= ${e}`}function _7(r,t){return`only one output dimension may be -1, not both ${r} and ${t}`}function L7(r,t){return`size ${r} must be non-negative, not ${t}`}function $7(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function B7(r,t){let e=rt(r),n=rt(t);return`Input to reshape is a SparseTensor with ${e}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${t}`}function O7(r,t){let e=rt(r),n=rt(t);return`Input to reshape is a tensor with ${e} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${t}`}function z7(){return"segment ids must be >= 0"}function G7(){return"segment ids are not increasing"}function U7(r,t){return`Segment id ${r} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function W7(r,t,e){return`Bad: indices[${r}] == ${t} out of range [0, ${e})`}var NA={};Xe(NA,{collectGatherOpShapeInfo:()=>H7,computeOutShape:()=>V7,segOpComputeOptimalWindowSize:()=>K7});function K7(r,t){let e=!1,n;for(r<=jy?(n=r,e=!0):n=Fm(r,Math.floor(Math.sqrt(r)));!e;)n>t||n===r?e=!0:n=Fm(r,n+1);return n}function V7(r,t,e){let n=[],o=r.length;for(let s=0;s<o;s++)s!==t?n.push(r[s]):n.push(e);return n}function H7(r,t,e,n){let o=t.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let m=0;m<n;++m)if(r.shape[m]!==t.shape[m])throw new Error(`x.shape[${m}]: ${r.shape[m]} should be equal to indices.shape[${m}]: ${t.shape[m]}.`);let a=r.shape[e],i=[],u=1,p=1,l=1;for(let m=0;m<n;++m)i.push(r.shape[m]),u*=r.shape[m];for(let m=n;m<e;m++)i.push(r.shape[m]),p*=r.shape[m];for(let m=n;m<o;m++)i.push(t.shape[m]);for(let m=e+1;m<s;m++)i.push(r.shape[m]),l*=r.shape[m];return{batchSize:u,sliceSize:l,outerSize:p,dimSize:a,outputShape:i}}function q7(r){try{return r.map(t=>ic(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function j7(r){return r.map(t=>Qu(t))}var xr={};Xe(xr,{nonMaxSuppressionV3Impl:()=>Vy,nonMaxSuppressionV4Impl:()=>Hy,nonMaxSuppressionV5Impl:()=>qy,whereImpl:()=>Oy});var Ln=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ln.prototype)}},Hr=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Hr.prototype)}},O=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,O.prototype)}},Ne=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Ne.prototype)}},Pc=class extends Error{constructor(t){super(t),Object.setPrototypeOf(this,Pc.prototype)}};var Oh=class{constructor(t){this.maxEntries=t||100,this.cache=new Map}get(t){let e;return this.cache.has(t)&&(e=this.cache.get(t),this.cache.delete(t),this.cache.set(t,e)),e}put(t,e){if(this.cache.has(t))this.cache.delete(t);else if(this.cache.size>=this.maxEntries){let n=this.cache.keys().next().value;this.cache.delete(n)}this.cache.set(t,e)}getMaxEntries(){return this.maxEntries}setMaxEntries(t){if(t<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${t}.`);if(this.maxEntries>t)for(let e=0;e<this.maxEntries-t;e++){let n=this.cache.keys().next().value;this.cache.delete(n)}this.maxEntries=t}};function Bs(r,t){if(Array.isArray(r)){let e=[];for(let n=0;n<t;n++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function rs(r,t){if(!r)throw new Pc(t)}function FA(r,t){let e=0;for(let n of r)n===t&&e++;return e}function Rr(r){return r.length===1?r[0]:r}function wt(r){return Array.isArray(r)?r:[r]}function Os(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function lu(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var $s={};function Mc(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function DA(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>DA(t));else{let t=Object.keys(r);for(let e of t){let n=r[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[e]=n.value:DA(n))}}}function wi(r,t={},e={},n="object",o=!1){if(typeof r=="string"){let s=r,a;if(s in e)a=e[s];else if(s in $s)a=$s[s];else if(a=t[s],a==null)throw new O(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let s=r;if(s.className==null||s.config==null)throw new O(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let a=s.className,i,u;if(a in e?[i,u]=e[a]:a in $s?[i,u]=$s.className:a in t&&([i,u]=t[a]),i==null)throw new O(`Unknown ${n}: ${a}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let p={};for(let d of Object.keys($s))p[d]=$s[d];for(let d of Object.keys(e))p[d]=e[d];let l=s.config;l.customObjects=p;let m={...$s};for(let d of Object.keys(e))$s[d]=e[d];DA(s.config);let c=u(i,s.config,e,o);return $s={...m},c}else{let p={...$s};for(let m of Object.keys(e))$s[m]=e[m];let l=new i(s.config);return $s={...p},l}}}function X7(r,t){return r<t?-1:r>t?1:0}function zh(r,t){return-1*X7(r,t)}function zs(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function rP(r){if(r==null)throw new O(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function Ni(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new O(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function Xy(r,t,e=0,n=1/0){return rs(e>=0),rs(n>=e),Array.isArray(r)&&r.length>=e&&r.length<=n&&r.every(o=>typeof o===t)}function or(r,t){Array.isArray(r)?(y.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,n)=>or(e,`element ${n+1} of ${t}`))):y.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${nP(r)}.`)}function nP(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>nP(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function oP(r,t,e){let n=e!=null?e():y.now(),o;return(...a)=>{let i=e!=null?e():y.now();return i-n<t||(n=i,o=r(...a)),o}}function Yy(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}var Y7=0;function Qy(){return Y7++}var Zy={};function Cp(r=""){return r in Zy||(Zy[r]=0),Zy[r]+=1,r+Zy[r].toString()}var sP=["channelsFirst","channelsLast"],aP=["nearest","bilinear"],iP=["valid","same","causal"],uP=["max","avg"],pP=["sum","mul","concat","ave"];var Ec=new Map;function Vt(r){Ni(sP,"DataFormat",r)}function mP(r){Ni(aP,"InterpolationFormat",r)}function bn(r){Ni(iP,"PaddingMode",r)}function RA(r){Ni(uP,"PoolMode",r)}var Gh=[],lP="/";function Xa(r,t){Gh.push(r);try{let e=t();return Gh.pop(),e}catch(e){throw Gh.pop(),e}}function Z7(){return Gh.length===0?"":Gh.join(lP)+lP}function Jy(r){if(!cP(r))throw new Error("Not a valid tensor name: '"+r+"'");return Z7()+r}function eT(r){if(!cP(r))throw new Error("Not a valid tensor name: '"+r+"'");Ec.has(r)||Ec.set(r,0);let t=Ec.get(r);if(Ec.set(r,Ec.get(r)+1),t>0){let e=`${r}_${t}`;return Ec.set(e,1),e}else return r}var Q7=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function cP(r){return!!r.match(Q7)}function dP(r){return r===parseInt(r.toString(),10)}function Gs(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let n=1;for(let o=t;o<e;++o)n*=r[o];return n}function gl(r){if(r.length===0)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n<t&&(t=n)}return t}function Ya(r){if(r.length===0)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let e=0;e<r.length;e++){let n=r[e];n>t&&(t=n)}return t}function en(r,t){if(t<r)throw new O(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let n=r;n<t;++n)e.push(n);return e}var PA;function dr(){return PA==null&&(PA=g2().epsilon()),PA}function yn(){return"channelsLast"}function bl(r,t){return oe(r,t)}function cu(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),$(r,e)}function fP(r,t){return U(()=>{if(r.shape.length!==2)throw new O(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=cu(r,1);return rT(e,[1,t,1])})}function hP(r){let t=[Gs(r.shape)];return $(r,t)}function gP(r){if(r.rank<=1)throw new O(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],Gs(r.shape,1)];return $(r,t)}function mu(r,t,e){return U(()=>{switch(r.rank){case 1:return vc(r,t,e);case 2:return Lh(r,[t,0],[e,r.shape[1]]);case 3:return Ac(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return pl(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return Ge(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return Ge(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new O(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function MA(r,t,e){return U(()=>{switch(r.rank){case 1:return vc(r,t,e);case 2:return Lh(r,[0,t],[r.shape[0],e]);case 3:return Ac(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return pl(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Uh(r,t,e,n){return U(()=>{switch(r.rank){case 1:return vc(r,t,e);case 2:switch(n){case 1:return mu(r,t,e);case 2:return MA(r,t,e);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return mu(r,t,e);case 2:return Ac(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return MA(r,t,e);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return mu(r,t,e);case 2:return pl(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return pl(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return MA(r,t,e);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function _c(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),ct(r,t)}function _A(r,t){switch(r.rank){case 1:return sy([r,t]);case 2:return ay([r,t],0);case 3:return iy([r,t],0);case 4:return uy([r,t],0);default:throw new O(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function rT(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new O(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return Zr(r,t)}function Lc(r,t=0,e=1,n,o){return ul(r,t,e,n,o)}function Us(r,t,e,n){if(r.rank<2||t.rank<2)throw new Ne(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let o=r.shape.slice(-1)[0],s=t.shape.slice(-2)[0];if(o!==s)throw new Ne(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2)return fp.matMul({a:r,b:t,transposeA:!1,transposeB:!1,bias:n?EA(r.rank,n,yn()):null,activation:e});{let o=r.shape.slice(),s=o.pop();r=$(r,[-1,s]);let a=t.shape.slice(),i=a.pop(),u=a.pop(),p=[...a,i],l=Array.from({length:t.rank},(f,h)=>h===0?t.rank-2:h<=t.rank-2?h-1:h);t=$(Ke(t,l),[u,-1]);let m=[...o,...p],c=!1,d=!1;return $(fp.matMul({a:r,b:t,transposeA:c,transposeB:d,bias:n?EA(r.rank,n,yn()):null,activation:e}),m)}}function nT(r,t,e){return U(()=>(Array.isArray(t)?t=Xt(t,"int32"):t=oe(t,"int32"),mp(r,t,e)))}function yl(r){return _(r,r)}function EA(r,t,e){let n=t.shape;if(t.rank!==1&&t.rank!==r)throw new O(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return n.length===1?$(t,[1,n[0],1,1,1]):$(t,[1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?$(t,[1,1,1,1,n[0]]):$(t,[1].concat(n))}else if(r===4){if(e==="channelsFirst")return n.length===1?$(t,[1,n[0],1,1]):$(t,[1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?$(t,[1,1,1,n[0]]):$(t,[1].concat(n))}else if(r===3){if(e==="channelsFirst")return n.length===1?$(t,[1,n[0],1]):$(t,[1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?$(t,[1,1,n[0]]):$(t,[1].concat(n))}else if(r<3)return t;throw new O(`Unsupported input rank by biasAdd: ${t.rank}`)}function Tn(r,t,e){return U(()=>(e==null&&(e=yn()),Vt(e),Z(r,EA(r.rank,t,e))))}function bP(r,t=1){if(t!==1)throw new Ne(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return pp(r)}function yP(r){return U(()=>me(r,Z(Wt(r),1)))}function oT(r,t,e,n){return U(()=>IA(r,t,e,n))}function TP(r){return U(()=>{let t=Z(.5,_(.2,r));return Gr(t,0,1)})}function kp(r,t,e=!1){return e?r():t()}var xP=["fanIn","fanOut","fanAvg"],IP=["normal","uniform","truncatedNormal"];function J7(r){Ni(xP,"FanMode",r)}function eJ(r){Ni(IP,"Distribution",r)}var In=class extends te.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},$c=class extends In{apply(t,e){return Ct(t,e)}};$c.className="Zeros";te.registerClass($c);var Sp=class extends In{apply(t,e){return yr(t,e)}};Sp.className="Ones";te.registerClass(Sp);var Bc=class extends In{constructor(e){super();if(typeof e!="object")throw new O(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new O(`config must have value set but got ${e}`);this.value=e.value}apply(e,n){return U(()=>_(ce(this.value),yr(e,n)))}getConfig(){return{value:this.value}}};Bc.className="Constant";te.registerClass(Bc);var Oc=class extends In{constructor(e){super();this.DEFAULT_MINVAL=-.05;this.DEFAULT_MAXVAL=.05;this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,n){return Si(e,this.minval,this.maxval,n)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};Oc.className="RandomUniform";te.registerClass(Oc);var zc=class extends In{constructor(e){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Ne(`randomNormal does not support dType ${n}.`);return Lc(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};zc.className="RandomNormal";te.registerClass(zc);var Gc=class extends In{constructor(e){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,n){if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Ne(`truncatedNormal does not support dType ${n}.`);return Fc(e,this.mean,this.stddev,n,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};Gc.className="TruncatedNormal";te.registerClass(Gc);var Uc=class extends In{constructor(e){super();this.gain=e.gain!=null?e.gain:1}apply(e,n){return U(()=>{if(e.length!==2||e[0]!==e[1])throw new O("Identity matrix initializer can only be used for 2D square matrices.");return _(this.gain,ol(e[0]))})}getConfig(){return{gain:this.gain}}};Uc.className="Identity";te.registerClass(Uc);function tJ(r,t="channelsLast"){let e,n;if(Vt(t),r.length===2)e=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let o=Gs(r,2);e=r[1]*o,n=r[0]*o}else if(t==="channelsLast"){let o=Gs(r,0,r.length-2);e=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=Gs(r);e=Math.sqrt(o),n=Math.sqrt(o)}return[e,n]}var qr=class extends In{constructor(e){super();if(e.scale<0)throw new O(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,J7(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,eJ(this.distribution),this.seed=e.seed}apply(e,n){let o=tJ(e),s=o[0],a=o[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,s):this.mode==="fanOut"?i/=Math.max(1,a):i/=Math.max(1,(s+a)/2),this.distribution==="normal"){let u=Math.sqrt(i);if(n=n||"float32",n!=="float32"&&n!=="int32")throw new Ne(`${this.getClassName()} does not support dType ${n}.`);return Fc(e,0,u,n,this.seed)}else{let u=Math.sqrt(3*i);return Si(e,-u,u,n)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};qr.className="VarianceScaling";te.registerClass(qr);var Tl=class extends qr{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return qr.className}};Tl.className="GlorotUniform";te.registerClass(Tl);var xl=class extends qr{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return qr.className}};xl.className="GlorotNormal";te.registerClass(xl);var Il=class extends qr{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return qr.className}};Il.className="HeNormal";te.registerClass(Il);var Cl=class extends qr{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return qr.className}};Cl.className="HeUniform";te.registerClass(Cl);var kl=class extends qr{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return qr.className}};kl.className="LeCunNormal";te.registerClass(kl);var Sl=class extends qr{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return qr.className}};Sl.className="LeCunNormal";te.registerClass(Sl);var Wc=class extends In{constructor(e){super();this.DEFAULT_GAIN=1;if(this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Ne("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,n){return U(()=>{if(e.length<2)throw new Ne("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let o=e[0]>e[1]?[e[1],e[0]]:e,s=Lc(o,0,1,"float32"),a=SA.gramSchmidt(s);return e[0]>e[1]&&(a=Ke(a)),_(this.gain,a)})}getConfig(){return{gain:this.gain,seed:this.seed}}};Wc.className="Orthogonal";te.registerClass(Wc);var CP={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function kP(r,t={}){return wi(r,te.SerializationMap.getMap().classNameMap,t,"initializer")}function _t(r){return Mc(r)}function kt(r){if(typeof r=="string"){let t=r in CP?CP[r]:r;if(t==="GlorotNormal")return new xl;if(t==="GlorotUniform")return new Tl;if(t==="HeNormal")return new Il;if(t==="HeUniform")return new Cl;if(t==="LeCunNormal")return new kl;if(t==="LeCunUniform")return new Sl;{let e={};return e.className=t,e.config={},kP(e)}}else return r instanceof In?r:kP(r)}function sT(r){return Array.isArray(r)&&Array.isArray(r[0])}function Kc(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Oe(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new O(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function nt(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new O(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function Vc(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((n,o)=>n*o);return t}var vP="Variable",Wh=class{constructor(t,e="float32",n=vP,o=!0,s=null){this.dtype=e??"float32",this.shape=t.shape,this.id=Qy(),n=n??vP,this.originalName=Jy(n),this.name=eT(this.originalName),this.trainable_=o,this.constraint=s,this.val=By(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),nJ(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function nJ(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function Kh(r){return r.map(t=>t.read())}function Hc(r){r.forEach(t=>{t[0].write(t[1])})}var Nt=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},tn=class{constructor(t,e,n,o,s,a,i){this.dtype=t;this.shape=e;this.sourceLayer=n;this.inputs=o;this.callArgs=s;this.outputTensorIndex=i;this.id=Qy(),a!=null&&(this.originalName=Jy(a),this.name=eT(this.originalName)),this.rank=e.length}},oJ=0,du=class{constructor(t,e){this.callArgs=e;this.id=oJ++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n?.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},sJ=0,Ue=class extends te.Serializable{constructor(e={}){super();this._callHook=null;this._addedWeightNames=[];this._stateful=!1;this.id=sJ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let n=e.name;if(!n){let o=this.getClassName();n=Os(o)+"_"+Cp(o)}if(this.name=n,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let o;if(e.batchInputShape!=null)o=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),o=[a].concat(e.inputShape)}this.batchInputShape=o;let s=e.dtype;s==null&&(s=e.inputDType),s==null&&(s="float32"),this.dtype=s}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,n){return e.name+"_ib-"+n.toString()}getNodeAtIndex(e,n){if(this.inboundNodes.length===0)throw new Hr(`The layer has never been called and thus has no defined ${n}.`);if(this.inboundNodes.length<=e)throw new O(`Asked to get ${n} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Rr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Rr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Ln(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Ln(`Layer ${this.name} is not connected, no input to return.`);return Rr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Ln(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Ln(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Rr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(n=>n.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=wt(e),this.inputSpec==null||this.inputSpec.length===0)return;let n=wt(this.inputSpec);if(e.length!==n.length)throw new O(`Layer ${this.name} expects ${n.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let o=0;o<e.length;o++){let s=e[o],a=n[o];if(a==null)continue;let i=s.rank;if(a.ndim!=null&&i!==a.ndim)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${i}`);if(a.maxNDim!=null&&i>a.maxNDim)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${i}`);if(a.minNDim!=null&&i<a.minNDim)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${i}.`);if(a.dtype!=null&&s.dtype!==a.dtype)throw new O(`Input ${o} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${s.dtype}.`);if(a.axes){let u=s.shape;for(let p in a.axes){let l=Number(p),m=a.axes[p],c=l>=0?u[l]:u[u.length+l];if(m!=null&&[m,null].indexOf(c)===-1)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${m} but got shape ${u}.`)}}if(a.shape!=null)for(let u=0;u<a.shape.length;++u){let p=a.shape[u],l=s.shape[u];if(p!=null&&l!=null&&p!==l)throw new O(`Input ${o} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${s.shape}.`)}}}call(e,n){return e}invokeCallHook(e,n){this._callHook!=null&&this._callHook(e,n)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,n){n=n||{},this.assertNotDisposed();let o=wt(e),s=!0;for(let i of o)if(!(i instanceof tn)){s=!1;break}let a=!0;for(let i of o)if(i instanceof tn){a=!1;break}if(s===a)throw new O("Arguments to apply() must be all SymbolicTensors or all Tensors");return Xa(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let i=[];for(let u of wt(e))i.push(u.shape);this.build(Rr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let i=this.call(e,n),u=wt(i),p=[];for(let l of u)o.indexOf(l)!==-1&&(l=l.clone()),p.push(l);if(i=Rr(p),this.activityRegularizer!=null)throw new Ne("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=aJ(e),u=this.computeOutputShape(i),p,l=iJ(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),u!=null&&u.length>0&&Array.isArray(u[0])?p=u.map((m,c)=>new tn(l,m,this,wt(e),n,this.name,c)):p=new tn(l,u,this,wt(e),n,this.name),this.addInboundNode(e,p,null,null,i,u,n),this._refCount++,this.activityRegularizer!=null)throw new Ne("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return p}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let n=!1;this.batchInputShape.forEach((o,s)=>{o!=null&&e[s]!=null&&e[s]!==o&&(n=!0)}),n&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Ln(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let n of this.inboundNodes){let o=JSON.stringify(n.outputShapes);e.indexOf(o)===-1&&e.push(o)}if(e.length===1){let n=this.inboundNodes[0].outputShapes;return Array.isArray(n)&&Array.isArray(n[0])&&n.length===1?n[0]:n}else throw new Ln(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Hr(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Vc(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Kh(e?this.trainableWeights:this.weights)}setWeights(e){U(()=>{let n=this.weights;if(n.length!==e.length)throw new O(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${n.length} weights. Provided weights: ${e}...`);if(n.length===0)return;let o=[],s=Kh(n);for(let a=0;a<s.length;++a){let i=s[a],u=n[a],p=e[a];if(!y.arraysEqual(i.shape,p.shape))throw new O(`Layer weight shape ${i.shape} not compatible with provided weight shape ${p.shape}`);o.push([u,p])}Hc(o)})}addWeight(e,n,o,s,a,i,u,p){if(this._addedWeightNames.indexOf(e)!==-1)throw new O(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),o==null&&(o="float32"),this.fastWeightInitDuringBuild&&(s=p!=null?p():kt("zeros"));let l=s.apply(n,o),m=new Wh(l,o,e,i,u);return l.dispose(),a!=null&&this.addLoss(()=>a.apply(m.read())),i==null&&(i=!0),i?this._trainableWeights.push(m):this._nonTrainableWeights.push(m),m}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=wt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,n){if(!this.supportsMasking){if(n!=null)if(Array.isArray(n))n.forEach(o=>{if(o!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return n}addInboundNode(e,n,o,s,a,i,u=null){let p=wt(e);n=wt(n),o=wt(o),s=wt(s),a=Kc(a),i=Kc(i);let l=[],m=[],c=[];for(let d of p)l.push(d.sourceLayer),m.push(d.nodeIndex),c.push(d.tensorIndex);new du({outboundLayer:this,inboundLayers:l,nodeIndices:m,tensorIndices:c,inputTensors:p,outputTensors:n,inputMasks:o,outputMasks:s,inputShapes:a,outputShapes:i},u);for(let d=0;d<n.length;d++)n[d].sourceLayer=this,n[d].nodeIndex=this.inboundNodes.length-1,n[d].tensorIndex=d}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function aJ(r){r=wt(r);let t=[];for(let e of r)t.push(e.shape);return Rr(t)}function iJ(r){return"float32"}function LA(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let a=n.inputTensors[s],i=n.inboundLayers[s],u=n.nodeIndices[s],p=LA(a,i,u);for(let l of p)o.indexOf(l)===-1&&o.push(l)}return o}}}var Za=class extends Ue{constructor(e){super({dtype:e.dtype,name:e.name!=null?e.name:Cp("input").toString()});if(e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new O("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let n=e.batchInputShape;if(n==null){if(e.inputShape==null)throw new O("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");n=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new O("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let o=e.dtype||"float32";this.batchInputShape=n,this.dtype=o,this.inputSpec=[{shape:n}];let s=new tn(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new du({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[n],outputShapes:[n]})}apply(e,n){throw new O(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};Za.className="InputLayer";te.registerClass(Za);function aT(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new O("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new Za({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}function uJ(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return oe(t,r.dtype)}catch{throw new O(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Ws=class{constructor(t){this.id2Value={};this.id2Mask={};this.name2Id={};if(t instanceof Ws)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=uJ(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new O(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof tn){if(this.id2Value[t.id]==null)throw new O(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof tn){if(this.id2Value[t.id]==null)throw new O(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new O(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&Pe(this.id2Mask)}},iT=new Oh,uT=new Oh;function wP(r){iT?.setMaxEntries(r),uT?.setMaxEntries(r)}function vl(r,t,e,n){let o=e==null?!1:e.training,s=Array.isArray(r),a=s?r:[r],i=a.map(f=>f.name),u=[],p=t.names();for(let f of i)p.indexOf(f)!==-1?u.push(t.getValue(f)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let l=i.join(",")+"|"+t.names().sort().join(","),m=iT.get(l),c;if(m==null){let f=pJ(a,t);m=f.sorted,c=f.recipientCounts,iT.put(l,m),uT.put(l,c)}c={},o||Object.assign(c,uT.get(l));let d=new Ws(t);for(let f=0;f<m.length;++f){if(n!=null){let M=wh().numTensors;M>n.maxNumTensors&&(n.maxNumTensors=M),M<n.minNumTensors&&(n.minNumTensors=M)}let h=m[f],g=h.sourceLayer;if(g instanceof Za)continue;let b=[],T=[],x=[],I=!1;for(let M of h.inputs){let L=d.getValue(M),z=d.getMask(M);b.push(L),T.push(z),z!=null&&(I=!0),o||(c[M.name]--,c[M.name]===0&&!t.hasKey(M)&&i.indexOf(M.name)===-1&&!L.isDisposed&&M.sourceLayer.stateful!==!0&&x.push(L))}I&&(e=e||{},e.mask=T[0]);let k=wt(g.apply(b,e)),w=null;g.supportsMasking&&(w=g.computeMask(b,T));let R=mJ(h),P=Array.isArray(R)?R:[R];for(let M=0;M<P.length;++M){d.hasKey(P[M])||d.add(P[M],k[M],Array.isArray(w)?w[0]:w);let L=i.indexOf(P[M].name);L!==-1&&(u[L]=k[M])}o||Pe(x)}return d.disposeMasks(),s?u:u[0]}function pJ(r,t){y.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(r.length===1){let o=AP(r[0],t);e=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:a,recipientMap:i}=AP(s,t);for(let u of a)o.has(u.name)||(e.push(u),o.add(u.name));for(let u in i)n[u]==null&&(n[u]=new Set),i[u].forEach(p=>n[u].add(p))}}return{sorted:e,recipientCounts:lJ(n)}}function lJ(r){let t={};for(let e in r)t[e]=r[e].size;return t}function AP(r,t){let e=new Set,n=[],o={};for(let i of t.names())e.add(i);let s=[],a=[];for(s.push(r);s.length>0;){let i=s[s.length-1];if(e.has(i.name)){s.pop();continue}let u=a[a.length-1]===s.length-1;if(i.inputs.length===0||u)s.pop(),n.push(i),e.add(i.name),u&&a.pop();else{a.push(s.length-1);for(let p of i.inputs)o[p.name]==null&&(o[p.name]=new Set),o[p.name].add(i.name),!e.has(p.name)&&s.push(p)}}return{sorted:n,recipientMap:o}}function mJ(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){e=n;break}t=r.sourceLayer.getOutputAt(e)}return t}var cJ=B();cJ.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,wP);var pT={kernelName:ls,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(r,vi(oe(e,"float32"),-1))}}};var NP={kernelName:Li,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Ye(oe(e,"float32")),o=Bt(le(ce(1),n));return et(me(r,o))}}}};var DP={kernelName:$i,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Bt(le(Ye(oe(e,"float32")),1));return me(r,n)}}}};var FP={kernelName:Nn,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ze(e.shape,n.shape);return{a:()=>{let i=r,u=At(e.shape,o);return u.length>0&&(i=de(i,u)),$(i,e.shape)},b:()=>{let i=r,u=At(n.shape,o);return u.length>0&&(i=de(i,u)),$(i,n.shape)}}}};var RP={kernelName:so,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((n,o)=>{e[o]=()=>r.clone()}),e}};var PP={kernelName:ao,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Fe(e)}}};var MP={kernelName:di,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Fe(e)}}};var EP={kernelName:zi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,Bt(le(ce(1),Ye(oe(e,"float32")))))}}};var _P={kernelName:Gi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Bt(Z(ce(1),Ye(oe(e,"float32"))));return me(r,n)}}}};var LP={kernelName:fa,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ze(e.shape,n.shape);return{a:()=>{let i=Z(Ye(e),Ye(n)),u=_(r,me(n,i)),p=At(e.shape,o);return p.length>0&&(u=de(u,p)),$(u,e.shape)},b:()=>{let i=Z(Ye(e),Ye(n)),u=et(_(r,me(e,i))),p=At(n.shape,o);return p.length>0&&(u=de(u,p)),$(u,n.shape)}}}};var $P={kernelName:Ui,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,Z(Ye(oe(e,"float32")),1))}}};var BP={kernelName:Wi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,le(ce(1),Ye(oe(e,"float32"))))}}};function dJ(r,t,e,n,o,s){let a=S(r,"dy","avgPool3dGrad"),i=S(t,"input","avgPool3dGrad"),u=a,p=i,l=!1;i.rank===4&&(l=!0,u=$(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=$(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),F(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),F(p.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),Et("avgPool3dGrad",o,s);let m={dy:u,input:p},c={filterSize:e,strides:n,pad:o,dimRoundingMode:s},d=D.runKernel(Mm,m,c);return l?$(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var OP=A({avgPool3dGrad_:dJ});var zP={kernelName:Eu,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:a,dimRoundingMode:i}=e;return{x:()=>OP(r,n,o,s,a,i)}}};function fJ(r,t,e,n,o){let s=S(r,"dy","avgPoolGrad"),a=S(t,"input","avgPoolGrad");F(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let i=a,u=s,p=!1;a.rank===3&&(p=!0,i=$(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=$(s,[1,s.shape[0],s.shape[1],s.shape[2]])),F(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),F(i.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${i.rank}.`);let l={dy:u,input:i},m={filterSize:e,strides:n,pad:o},c=D.runKernel(Pm,l,m);return p?$(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var GP=A({avgPoolGrad_:fJ});var UP={kernelName:io,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:o,strides:s,pad:a}=e;return{x:()=>GP(r,n,o,s,a)}}};var WP={kernelName:uo,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[n,o]=t,{transposeA:s,transposeB:a}=e;return!s&&!a?{a:()=>je(r,o,!1,!0),b:()=>je(n,r,!0,!1)}:!s&&a?{a:()=>je(r,o,!1,!1),b:()=>je(r,n,!0,!1)}:s&&!a?{a:()=>je(o,r,!1,!0),b:()=>je(n,r,!1,!1)}:{a:()=>je(o,r,!0,!0),b:()=>je(r,n,!0,!0)}}};var KP={kernelName:ms,gradFunc:(r,t,e)=>{let{blockShape:n,crops:o}=e;return{x:()=>kc(r,n,o)}}};var VP={kernelName:i1,gradFunc:(r,t,e)=>{let n=e,o=n.inputShape,s=n.shape,a=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])a[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let i=[];for(let u=0;u<a.length;u++)a[u]>1&&i.push(u);return{x:()=>de(r,i,!0)}}};var HP={kernelName:Wn,gradFunc:r=>({x:()=>r.clone()})};var qP={kernelName:po,gradFunc:r=>({x:()=>Fe(r)})};var jP={kernelName:Kn,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{clipValueMin:o,clipValueMax:s}=e;return{x:()=>Kt(Qr(Ms(n,o),Es(n,s)),r,Fe(r))}}};var XP={kernelName:Lu,inputsToSave:["x"],gradFunc:pT.gradFunc};var YP={kernelName:cs,saveAllInputs:!0,gradFunc:(r,t,e)=>{let n=t.map(u=>u.shape),{axis:o}=e,s=gr(o,t[0].shape)[0],a=n.map(u=>u[s]);return Fr(r,a,s).map(u=>()=>u)}};var ZP={kernelName:lo,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{dilations:s,strides:a,pad:i,dataFormat:u}=e;return F(Qo(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>bc(n.shape,r,o,a,i,u),filter:()=>Rc(n,r,o.shape,a,i,u)}}};var QP={kernelName:mo,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,{strides:s,pad:a,dataFormat:i,dimRoundingMode:u}=e;return{dy:()=>es(r,o,s,a,i,1,u),filter:()=>Rc(r,n,o.shape,s,a,i,u)}}};function hJ(r,t,e,n,o){let s=r;r.rank===4&&(s=$(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let a=t;a.rank===4&&(a=$(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),F(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),F(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),F(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),F(s.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${e[3]}.`),F(a.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${e[4]}).`);let i={x:s,dy:a},u={strides:n,pad:o,filterShape:e};return D.runKernel($m,i,u)}var JP=A({conv3DBackpropFilter_:hJ});var eM={kernelName:$u,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s}=e;F(Qo(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[a,i]=t;return{x:()=>cy(a.shape,r,i,o,s),filter:()=>JP(a,r,i.shape,o,s)}}};var tM={kernelName:co,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(et(My(oe(e,"float32"))),r)}}};var rM={kernelName:fo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(Ey(oe(e,"float32")),r)}}};var nM={kernelName:ho,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o,exclusive:s,reverse:a}=e;return{x:()=>{let i=dA([o],n.rank),u=hy(r,o,s,!a);return i!=null&&(u=Ke(u,i)),u}}}};var oM={kernelName:go,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:a}=e,i=n??[1,1];F(Qo(i),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);let[u,p]=t;return F(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),F(p.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${p.rank}.`),F(u.shape[3]===p.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),F(Er(o,i),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${i}'.`),Et("depthwiseConv2d",s,a),{x:()=>Uy(u.shape,r,p,o,s,i,a),filter:()=>Gy(u,r,p.shape,o,s,i,a)}}};var sM={kernelName:Bu,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,o]=t,s={x:n,filter:o,dy:r},a={x:n,filter:o,dy:r};return{x:()=>D.runKernel(fh,s,e),filter:()=>D.runKernel(hh,a,e)}}};var aM={kernelName:yo,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,n={dy:r,y:e};return{x:()=>D.runKernel(Wm,n)}}};var iM={kernelName:Ki,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=_(br(et(Ye(e))),2/Math.sqrt(Math.PI));return{x:()=>_(r,n)}}};var uM={kernelName:To,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(r,e)}}};var pM={kernelName:ds,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>$(r,e.shape)}}};var lM={kernelName:Ta,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(r,br(e))}}};var mM={kernelName:xo,gradFunc:r=>({x:()=>Fe(r)})};var cM={kernelName:Io,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ze(e.shape,n.shape);return{a:()=>{let i=me(r,oe(n,"float32")),u=At(e.shape,o);return u.length>0?$(de(i,u),e.shape):i},b:()=>{let i=_(r,oe(e,"float32")),u=At(n.shape,o);u.length>0&&(i=$(de(i,u),n.shape));let p=Ye(n);return et(me(i,oe(p,"float32")))}}}};var dM={kernelName:Co,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:n}=e,[o,s,a,i]=t,u=i??ce(1),p=At(s.shape,o.shape),l=[];if(s.rank===1){for(let I=0;I<o.shape.length-1;++I)l.push(o.shape[I]);l.push(1)}let m=le(o,s),c=_(r,u),d=Fy(Z(a,ce(n))),f=_(_(_(d,d),d),ce(-.5));return{x:()=>s.rank===1?$(_(_(r,Zr($(d,[1,1,1,s.shape[0]]),l)),u),o.shape):$(_(_(r,d),u),o.shape),mean:()=>{let I=_(_(d,ce(-1)),c);return s.rank===1&&(I=de(I,p)),$(I,s.shape)},variance:()=>{let I=_(_(f,m),c);return s.rank===1&&(I=de(I,p)),$(I,s.shape)},scale:()=>{let I=_(m,d),k=_(r,I);return s.rank===1&&(k=de(k,p)),$(k,s.shape)},offset:()=>{let I=r;return s.rank===1&&(I=de(I,p)),$(I,s.shape)}}}};var gM={kernelName:fs,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[n,o]=t,{axis:s}=e,a=gr(s,n.shape)[0];return{x:()=>{let u=n.shape,p=o.size,l=u.slice(0,a),m=l.length,c=u.slice(s,u.length).slice(1),d=c.length,f=fM(0,m),h=fM(m+1,m+1+d),g=hM([l,[p],c]),b=$(r,g),T=$(o,[p]),x=hM([[m],f,h]),I=Ke(b,x),k=$y(I,T,n.shape[a]),w=Ph(x);return k=Ke(k,w),k},indices:()=>o}}};function fM(r,t){let e=[];for(let n=r;n<t;++n)e.push(n);return e}function hM(r){let t=[];for(let e=0;e<r.length;++e)for(let n=0;n<r[e].length;++n)t.push(r[e][n]);return t}var bM={kernelName:ko,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>Fe(e),b:()=>Fe(n)}}};var yM={kernelName:Vn,gradFunc:r=>({x:()=>oe(r,"float32")})};var TM={kernelName:Vi,gradFunc:r=>({x:()=>Fe(r)})};var xM={kernelName:Hi,gradFunc:r=>({x:()=>Fe(r)})};var IM={kernelName:ka,gradFunc:r=>({x:()=>Fe(r)})};var CM={kernelName:So,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{alpha:o}=e,s=mr(n,0);return{x:()=>Kt(s,r,_(r,o))}}};var kM={kernelName:qi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,Z(e,1))}}};var SM={kernelName:vo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,oe(e,"float32"))}}};var vM={kernelName:p1,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e;return{logits:()=>{let a=br(n);return le(r,_(de(r,o,!0),a))}}}};function gJ(r,t,e,n=5,o=1,s=1,a=.5){let i={x:r,y:t,dy:e},u={depthRadius:n,bias:o,alpha:s,beta:a};return D.runKernel(qm,i,u)}var AM=A({localResponseNormalizationBackprop_:gJ});var wM={kernelName:Gu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{depthRadius:s,bias:a,alpha:i,beta:u}=e;return{x:()=>AM(n,o,r,s,a,i,u)}}};function lT(r,t,e,n){return t.rank<e.rank&&(t=$(t,Ps(t.shape,n))),r.rank<e.rank&&(r=$(r,Ps(r.shape,n))),{x:()=>_(r,oe(Yr(e,t),r.dtype))}}var $A={kernelName:Ao,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{reductionIndices:o}=n,s=t[0],a=t[1],i=gr(o,s.shape),u=lT(r,a,s,i);return{x:()=>u.x()}}};var NM={kernelName:wo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>_(r,oe(Ms(e,n),"float32")),b:()=>_(r,oe(gy(e,n),"float32"))}}};function bJ(r,t,e,n,o,s,a){let i=S(r,"dy","maxPool3dGrad"),u=S(t,"input","maxPool3dGrad"),p=S(e,"output","maxPool3dGrad"),l=i,m=u,c=p,d=!1;u.rank===4&&(d=!0,l=$(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),m=$(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),c=$(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),F(l.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),F(m.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${m.rank}.`),F(c.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${c.rank}.`),Et("maxPool3dGrad",s,a);let f={dy:l,input:m,output:c},h={filterSize:n,strides:o,pad:s,dimRoundingMode:a},g=D.runKernel(Xm,f,h);return d?$(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var DM=A({maxPool3dGrad_:bJ});var FM={kernelName:Uu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=e;return{x:()=>DM(r,n,o,s,a,i,u)}}};function yJ(r,t,e,n,o,s,a){let i=S(r,"dy","maxPoolGrad"),u=S(t,"input","maxPoolGrad"),p=S(e,"output","maxPoolGrad");F(u.rank===i.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${i.rank})`),F(i.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${i.rank}.`),F(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Et("maxPoolGrad",s,a);let l={dy:i,input:u,output:p},m={filterSize:n,strides:o,pad:s,dimRoundingMode:a};return D.runKernel(jm,l,m)}var RM=A({maxPoolGrad_:yJ});var PM={kernelName:No,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,o]=t,{filterSize:s,strides:a,pad:i}=e;return{x:()=>RM(r,n,o,s,a,i)}}};var MM={kernelName:Do,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=gr(o,n.shape),i=cA(n.shape,s)[1],u=rt(i);return{x:()=>{let l=n.shape.slice();s.forEach(d=>{l[d]=1});let m=$(r,l);return me(_(m,yr(n.shape,"float32")),u)}}}};var EM={kernelName:Fo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{axis:o}=n,[s,a]=t,i=gr(o,s.shape),u=lT(r,a,s,i);return{x:()=>u.x()}}};var _M={kernelName:Ro,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>_(r,oe(Es(e,n),"float32")),b:()=>_(r,oe(mr(e,n),"float32"))}}};var LM={kernelName:Po,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(a=>a[0]);return{x:()=>Ge(r,s,n.shape)}}};var $M={kernelName:Xi,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ze(e.shape,n.shape);return{a:()=>{let i=At(e.shape,o);return i.length>0?$(de(r,i),e.shape):r},b:()=>{let i=_(r,et(lp(me(e,n)))),u=At(n.shape,o);return u.length>0?$(de(i,u),n.shape):i}}}};var BM={kernelName:Mo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ze(e.shape,n.shape);return{a:()=>{let i=_(r,oe(n,"float32")),u=At(e.shape,o);return u.length>0?$(de(i,u),e.shape):i},b:()=>{let i=_(r,oe(e,"float32")),u=At(n.shape,o);return u.length>0?$(de(i,u),n.shape):i}}}};var OM={kernelName:hs,gradFunc:r=>({x:()=>et(r)})};var zM={kernelName:Ra,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>Ct(e.shape,"float32")}}};var GM={kernelName:gs,gradFunc:r=>({x:()=>Fe(r)})};var UM={kernelName:bs,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:n}=e;return Wr(r,n).map(s=>()=>s)}};var BA={kernelName:Eo,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:o}=e,s=o.map(a=>a[0]);return{x:()=>Ge(r,s,n.shape)}}};var WM={kernelName:_o,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,n,o]=t,s=e,a=n,i=ze(s.shape,a.shape);return{a:()=>{let l=oe(a,"float32"),m=_(r,_(l,qn(s,le(l,ce(1))))),c=At(s.shape,i);return c.length>0&&(m=de(m,c)),$(m,s.shape)},b:()=>{let l=mr(s,0),m=Kt(l,Ur(s),Fe(s)),c=_(r,_(o,m)),d=At(a.shape,i);return d.length>0&&(c=de(c,d)),$(c,a.shape)}}}};var KM={kernelName:Lo,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,n]=t,o=mr(e,0);return{x:()=>Kt(o,r,_(r,n)),alpha:()=>{let s=Kt(o,Fe(r),_(r,e)),a=At(n.shape,r.shape);return a.length>0&&(s=de(s,a)),$(s,n.shape)}}}};function TJ(r,t,e){let n=r.shape.slice();n[e]=1;let o=$(t,n),s=Rh(r,e,!0,!1),a=Rh(r,e,!0,!0),i=_(s,a);return _(o,i)}function xJ(r,t,e){let n=r.shape.length,o=n-e.length,s=C.getAxesPermutation(e,n),a=r;s!=null&&(a=Ke(r,s));let i=a.shape.slice(),p=i.splice(n-e.length,e.length).reduce((c,d)=>c*d,1);i.push(p);let l=a.reshape(i),m=TJ(l,t,o);if(m=m.reshape(a.shape),s!=null){let c=C.getUndoAxesPermutation(s);m=Ke(m,c)}return m}var VM={kernelName:$o,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:o}=e,s=[];return o==null?s=n.shape.map((a,i)=>i):typeof o=="number"?s=[o]:s=o,{x:()=>xJ(n,r,s)}}};var HM={kernelName:bo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ze(e.shape,n.shape);return{a:()=>{let i=me(r,oe(n,"float32")),u=At(e.shape,o);return u.length>0?$(de(i,u),e.shape):i},b:()=>{let i=_(r,oe(e,"float32")),u=At(n.shape,o);u.length>0&&(i=$(de(i,u),n.shape));let p=Ye(n);return et(me(i,oe(p,"float32")))}}}};var qM={kernelName:Pa,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,et(Ye(e)))}}};var jM={kernelName:Go,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=_(Es(e,6),vi(e));return{x:()=>_(r,oe(n,"float32"))}}};var XM={kernelName:Bo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(r,oe(vi(e),"float32"))}}};var YM={kernelName:ys,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>$(r,e.shape)}}};var ZM={kernelName:zo,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>D.runKernel(ec,o,e)}}};var QM={kernelName:Oo,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,o={dy:r,images:n};return{images:()=>D.runKernel(Jm,o,e)}}};var JM={kernelName:Ma,gradFunc:(r,t,e)=>{let{dims:n}=e,o=gr(n,r.shape);return{x:()=>Dr(r,o)}}};var eE={kernelName:Ea,gradFunc:r=>({x:()=>Fe(r)})};var tE={kernelName:Uo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>et(me(r,_(qn(e,1.5),2)))}}};var rE={kernelName:Ts,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>oe(Fe(e),"float32"),t:()=>_(r,oe(e,r.dtype)),e:()=>_(r,oe(Ic(e),r.dtype))}}};var nE={kernelName:Zi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=mr(e,ce(0)),o=ce(vA),s=ce(AA),a=_(r,s),i=_(_(r,o),br(oe(e,"float32")));return Kt(n,a,i)}}}};var oE={kernelName:Ko,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(r,_(e,le(ce(1),e)))}}};var sE={kernelName:Qi,gradFunc:r=>({x:()=>Fe(r)})};var aE={kernelName:Wo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(yc(oe(e,"float32")),r)}}};var iE={kernelName:La,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(fy(oe(e,"float32")),r)}}};var uE={kernelName:xs,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{begin:o,size:s}=e,a=n.shape,[i,u]=sA(n,o,s),p=[];for(let l=0;l<r.rank;l++)p.push([i[l],a[l]-i[l]-u[l]]);return{x:()=>jn(r,p)}}};var pE={kernelName:qo,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{dim:o}=e,s=!0,a=_(r,n);return{logits:()=>le(a,_(de(a,[o],s),n))}}};var lE={kernelName:Ji,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(r,_n(e))}}};var OA={kernelName:Is,gradFunc:(r,t,e)=>{let{blockShape:n,paddings:o}=e;return{x:()=>gc(r,n,o)}}};var zA={kernelName:Cs,gradFunc:(r,t,e)=>{let{axis:n}=e;return{x:()=>ct(r,n)}}};var mE={kernelName:Vo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,_(Bt(oe(e,"float32")),2))}}};var cE={kernelName:gi,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(r,_(oe(e,"float32"),2))}}};var dE={kernelName:jo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ce(2);return{a:()=>_(r,_(o,le(e,n))),b:()=>_(r,_(o,le(n,e)))}}};var fE={kernelName:vs,gradFunc:r=>({x:()=>Fe(r)})};var hE={kernelName:Xo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,o=ze(e.shape,n.shape);return{a:()=>{let i=r,u=At(e.shape,o);return u.length>0&&(i=de(i,u)),$(i,e.shape)},b:()=>{let i=r,u=At(n.shape,o);return u.length>0&&(i=de(i,u)),$(et(i),n.shape)}}}};var gE={kernelName:Ho,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,o=n.shape.slice(),{axis:s}=e;gr(s,n.shape).forEach(p=>{o[p]=1});let i=$(r,o),u=_(i,yr(n.shape,"float32"));return{x:()=>u}}};var bE={kernelName:Ba,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>me(r,Ye(yc(e)))}}};var yE={kernelName:Yo,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>_(le(ce(1),Ye(e)),r)}}};var TE={kernelName:Dn,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{reps:o}=e;return{x:()=>{let a=Fe(n);if(n.rank===1)for(let i=0;i<o[0];++i)a=Z(a,Ge(r,[i*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)a=Z(a,Ge(r,[i*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let p=0;p<o[2];++p)a=Z(a,Ge(r,[i*n.shape[0],u*n.shape[1],p*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let i=0;i<o[0];++i)for(let u=0;u<o[1];++u)for(let p=0;p<o[2];++p)for(let l=0;l<o[3];++l)a=Z(a,Ge(r,[i*n.shape[0],u*n.shape[1],p*n.shape[2],l*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return a}}}};var xE={kernelName:Fn,gradFunc:(r,t,e)=>{let n=e,{perm:o}=n,s=Ph(o);return{x:()=>Ke(r,s)}}};var IE={kernelName:ks,gradFunc:(r,t,e)=>{let n=e,{axis:o}=n;return{value:()=>Tr(r,o)}}};var CE={kernelName:Yu,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>IJ(r,e)}}};function IJ(r,t){let e=ts(t,Fe(t)),n=mp(r,e),o=Ms(t,ce(0,"int32")),s=n.rank-o.rank;for(let i=0;i<s;++i)o=_r(o,i+1);o=Qr(o,yr(n.shape,"bool"));let a=Fe(n);return Kt(o,n,a)}var kE={kernelName:Ss,gradFunc:r=>({x:()=>Fe(r)})};var CJ=[pT,NP,DP,FP,RP,PP,MP,EP,_P,LP,$P,BP,zP,UP,WP,KP,VP,HP,qP,jP,XP,YP,QP,ZP,eM,tM,rM,nM,oM,sM,HM,aM,iM,uM,pM,lM,cM,mM,dM,gM,bM,yM,TM,xM,IM,CM,kM,SM,vM,wM,$A,$A,NM,FM,PM,MM,EM,_M,LM,$M,BM,OM,zM,GM,UM,BA,BA,WM,KM,VM,qM,jM,XM,YM,ZM,QM,JM,eE,tE,rE,nE,oE,sE,aE,iE,uE,pE,lE,OA,OA,zA,zA,mE,dE,cE,fE,hE,gE,bE,yE,TE,xE,IE,CE,kE];for(let r of CJ)m1(r);var AE={};Xe(AE,{maxNorm:()=>kJ,minMaxNorm:()=>AJ,nonNeg:()=>vJ,unitNorm:()=>SJ});function GA(r,t){return U(()=>Bt(de(_(r,r),t,!0)))}var Al=class extends te.Serializable{getConfig(){return{}}},qc=class extends Al{constructor(e){super();this.defaultMaxValue=2;this.defaultAxis=0;this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return U(()=>{let n=GA(e,this.axis),o=Gr(n,0,this.maxValue);return _(e,me(o,Z(dr(),n)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};qc.className="MaxNorm";te.registerClass(qc);var jc=class extends Al{constructor(e){super();this.defaultAxis=0;this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return U(()=>me(e,Z(dr(),GA(e,this.axis))))}getConfig(){return{axis:this.axis}}};jc.className="UnitNorm";te.registerClass(jc);var Xc=class extends Al{apply(t){return Jr(t)}};Xc.className="NonNeg";te.registerClass(Xc);var Yc=class extends Al{constructor(e){super();this.defaultMinValue=0;this.defaultMaxValue=1;this.defaultRate=1;this.defaultAxis=0;this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return U(()=>{let n=GA(e,this.axis),o=Z(_(this.rate,Gr(n,this.minValue,this.maxValue)),_(1-this.rate,n));return _(e,me(o,Z(dr(),n)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};Yc.className="MinMaxNorm";te.registerClass(Yc);var SE={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Yt(r){return Mc(r)}function vE(r,t={}){return wi(r,te.SerializationMap.getMap().classNameMap,t,"constraint")}function Zt(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in SE?SE[r]:r,config:{}};return vE(e)}else return r instanceof Al?r:vE(r)}function kJ(r){return new qc(r)}function SJ(r){return new jc(r)}function vJ(){return new Xc}function AJ(r){return new Yc(r)}var wE={};Xe(wE,{constant:()=>DJ,glorotNormal:()=>LJ,glorotUniform:()=>_J,heNormal:()=>$J,heUniform:()=>BJ,identity:()=>MJ,leCunNormal:()=>OJ,leCunUniform:()=>zJ,ones:()=>NJ,orthogonal:()=>GJ,randomNormal:()=>RJ,randomUniform:()=>FJ,truncatedNormal:()=>PJ,varianceScaling:()=>EJ,zeros:()=>wJ});function wJ(){return new $c}function NJ(){return new Sp}function DJ(r){return new Bc(r)}function FJ(r){return new Oc(r)}function RJ(r){return new zc(r)}function PJ(r){return new Gc(r)}function MJ(r){return new Uc(r)}function EJ(r){return new qr(r)}function _J(r){return new Tl(r)}function LJ(r){return new xl(r)}function $J(r){return new Il(r)}function BJ(r){return new Cl(r)}function OJ(r){return new kl(r)}function zJ(r){return new Sl(r)}function GJ(r){return new Wc(r)}var o_={};Xe(o_,{Layer:()=>Ue,RNN:()=>ns,RNNCell:()=>gu,activation:()=>tee,add:()=>lee,alphaDropout:()=>qee,average:()=>mee,averagePooling1d:()=>sw,averagePooling2d:()=>aw,averagePooling3d:()=>iw,avgPool1d:()=>xee,avgPool2d:()=>Cee,avgPool3d:()=>See,avgPooling1d:()=>Iee,avgPooling2d:()=>kee,avgPooling3d:()=>vee,batchNormalization:()=>bee,bidirectional:()=>Oee,concatenate:()=>cee,conv1d:()=>H9,conv2d:()=>q9,conv2dTranspose:()=>j9,conv3d:()=>X9,conv3dTranspose:()=>Y9,convLstm2d:()=>_ee,convLstm2dCell:()=>Lee,cropping2D:()=>Q9,dense:()=>ree,depthwiseConv2d:()=>eee,dot:()=>gee,dropout:()=>nee,elu:()=>z9,embedding:()=>pee,flatten:()=>see,gaussianDropout:()=>Hee,gaussianNoise:()=>Vee,globalAveragePooling1d:()=>Aee,globalAveragePooling2d:()=>wee,globalMaxPool1d:()=>Gee,globalMaxPool2d:()=>Uee,globalMaxPooling1d:()=>e_,globalMaxPooling2d:()=>t_,gru:()=>Dee,gruCell:()=>Fee,input:()=>XA,inputLayer:()=>O9,layerNormalization:()=>yee,leakyReLU:()=>U9,lstm:()=>Ree,lstmCell:()=>Pee,masking:()=>jee,maxPool1d:()=>Wee,maxPool2d:()=>Kee,maxPooling1d:()=>r_,maxPooling2d:()=>n_,maxPooling3d:()=>Nee,maximum:()=>dee,minimum:()=>fee,multiply:()=>hee,permute:()=>uee,prelu:()=>W9,reLU:()=>G9,repeatVector:()=>aee,reshape:()=>iee,rnn:()=>$ee,separableConv2d:()=>Z9,simpleRNN:()=>Mee,simpleRNNCell:()=>Eee,softmax:()=>K9,spatialDropout1d:()=>oee,stackedRNNCells:()=>Bee,thresholdedReLU:()=>V9,timeDistributed:()=>zee,upSampling2d:()=>J9,zeroPadding2d:()=>Tee});async function Di(r){if(r==null)return;let t=[],e=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let a=s;t.push(a.data()),e.push(o),n.push(a)}}if(t.length>0){let o=await Promise.all(t);for(let s=0;s<o.length;++s)r[e[s]]=o[s][0];Pe(n)}}function mT(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var UJ=125,fu=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},cT=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}},UA=class extends fu{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,n){n==null&&(n={});let o=n.size==null?0:n.size;this.seen+=o;for(let s in n){let a=n[s];if(typeof a=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+a*o;else{let i;s in this.totals?i=this.totals[s]:this.totals[s]=0;let u=U(()=>Z(this.totals[s],_(a,o)));this.totals[s]=u,i?.dispose()}}}async onEpochEnd(e,n){if(n!=null)for(let o of this.params.metrics)this.totals[o]!=null&&(typeof this.totals[o]=="number"?n[o]=this.totals[o]/this.seen:U(()=>{let s=_(me(1,this.seen),this.totals[o]);n[o]=s,this.totals[o].dispose(),Ut(n[o])}))}},dT=class extends fu{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,n){n==null&&(n={}),this.epoch.push(e);for(let o in n)this.history[o]==null&&(this.history[o]=[]),this.history[o].push(n[o])}async syncData(){let e=[],n=[],o=[];for(let a in this.history){let i=this.history[a];for(let u=0;u<i.length;++u)if(typeof i[u]!="number"){let p=i[u];e.push(p.data()),n.push(a),o.push(u)}}let s=await Promise.all(e);for(let a=0;a<s.length;++a)this.history[n[a]][o[a]].dispose(),this.history[n[a]][o[a]]=s[a][0]}},fT=class extends fu{constructor(e,n){super();this.currentEpoch=0;if(this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Bh,this.yieldEvery=n||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=UJ),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");y.isNumber(this.yieldEvery)&&(this.maybeWait=oP(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,n,o){let s=[];this.yield!=null&&(await Di(o),s.push(this.yield(e,n,o))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,n){this.currentEpoch=e,this.epochBegin!=null&&(await Di(n),await this.epochBegin(e,n))}async onEpochEnd(e,n){let o=[];this.epochEnd!=null&&(await Di(n),o.push(this.epochEnd(e,n))),this.yieldEvery==="epoch"&&o.push(this.nextFrameFunc()),await Promise.all(o)}async onBatchBegin(e,n){this.batchBegin!=null&&(await Di(n),await this.batchBegin(e,n))}async onBatchEnd(e,n){let o=[];this.batchEnd!=null&&(await Di(n),o.push(this.batchEnd(e,n))),this.yieldEvery==="batch"?o.push(this.nextFrameFunc()):y.isNumber(this.yieldEvery)&&o.push(this.maybeWait(this.currentEpoch,e,n)),await Promise.all(o)}async onTrainBegin(e){this.trainBegin!=null&&(await Di(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Di(e),await this.trainEnd(e))}};function hT(r,t){return r==null&&(r={}),r instanceof fu?[r]:Array.isArray(r)&&r[0]instanceof fu?r:wt(r).map(n=>new fT(n,t))}var Qa=class{constructor(){}static registerCallbackConstructor(t,e){y.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),Qa.checkForDuplicate(e),Qa.constructors[t]==null&&(Qa.constructors[t]=[]),Qa.constructors[t].push(e)}static checkForDuplicate(t){for(let e in Qa.constructors)Qa.constructors[+e].forEach(o=>{if(o===t)throw new O("Duplicate callback constructor.")})}static clear(){Qa.constructors={}}static createCallbacks(t){let e=[];for(let n in Qa.constructors){let o=+n;t>=o&&e.push(...Qa.constructors[o])}return e.map(n=>new n)}},Zc=Qa;Zc.constructors={};function gT(r,t,e,n,o,s,a,i,u){let p=new dT,l=[new UA,...Zc.createCallbacks(t)];r!=null&&l.push(...r),l.push(p);let m=new cT(l);return m.setParams({epochs:e,initialEpoch:n,samples:o,steps:s,batchSize:a,verbose:t,doValidation:i,metrics:u}),{callbackList:m,history:p}}function Cn(r,t={},e=!1){return wi(r,te.SerializationMap.getMap().classNameMap,t,"layer",e)}function Vh(r,t){return U(()=>{r.dtype!=="float32"&&(r=oe(r,"float32"));let e=de(yl(r),t,!0),n=ki(e.shape,dr()),o=Bt(ts(e,n));return me(r,o)})}function Fi(r,t){return U(()=>Ot(yl(le(t,r)),-1))}function Qc(r,t){return U(()=>Ot(Wt(le(t,r)),-1))}function vp(r,t){return U(()=>{let e=le(r,t),n=Gr(Wt(r),dr(),Number.MAX_VALUE),o=Wt(me(e,n));return _(100,Ot(o,-1))})}function WJ(r,t){return U(()=>{let e=Gr(t,dr(),Number.MAX_VALUE),n=Ur(Z(1,e)),o=Gr(r,dr(),Number.MAX_VALUE),s=Ur(Z(1,o));return Ot(yl(le(n,s)),-1)})}function KJ(r,t){return U(()=>{let e=ts(0,le(1,_(r,t)));return Ot(yl(e),-1)})}function VJ(r,t){return U(()=>{let e=ts(0,le(1,_(r,t)));return Ot(e,-1)})}function HJ(r,t){return U(()=>{let e=de(_(r,t),-1),n=hn(_(le(1,r),t),-1);return ts(0,Z(1,le(n,e)))})}function qJ(r,t){return U(()=>{let e=Math.log(2),n=le(t,r),o=le(Z(n,uu(_(-2,n))),e);return Ot(o,-1)})}function wl(r,t,e=!1){return U(()=>{if(e)t=wc(t);else{let n=de(t,t.shape.length-1,!0);t=me(t,n)}return t=Gr(t,dr(),1-dr()),et(de(_(oe(r,"float32"),Ur(t)),t.shape.length-1))})}function Jc(r,t,e=!1){return U(()=>{let n=oe(lp(hP(r)),"int32");t=Gr(t,dr(),1-dr());let o=t.shape,s=$(tp(n,o[o.length-1]),o);return wl(s,t,e)})}function jJ(r,t){if(!y.arraysEqual(r.shape,t.shape))throw new O(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return U(()=>{let e=Jr(t),n=et(Wt(t));return Z(le(e,_(t,r)),xc(br(n)))})}function ed(r,t){return U(()=>{let e;return e=Gr(t,dr(),1-dr()),e=Ur(me(e,le(1,e))),Ot(jJ(r,e),-1)})}function XJ(r,t){return U(()=>{let e=Gr(r,dr(),1),n=Gr(t,dr(),1);return de(_(r,Ur(me(e,n))),-1)})}function YJ(r,t){return U(()=>{let e=Ur(Z(dr(),t));return Ot(le(t,_(r,e)),-1)})}function qh(r,t){return U(()=>{let e=Vh(r,-1),n=Vh(t,-1),o=_(e,n);return et(de(o,-1))})}var Hh={meanSquaredError:Fi,meanAbsoluteError:Qc,meanAbsolutePercentageError:vp,meanSquaredLogarithmicError:WJ,squaredHinge:KJ,hinge:VJ,categoricalHinge:HJ,logcosh:qJ,categoricalCrossentropy:wl,sparseCategoricalCrossentropy:Jc,binaryCrossentropy:ed,kullbackLeiblerDivergence:XJ,poisson:YJ,cosineProximity:qh};function bT(r){if(typeof r=="string"){if(r in Hh)return Hh[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new O(t)}else return r}function jh(r,t){return U(()=>{let e=_(.5,Lr(t)),n=bl(mr(t,e),r.dtype);return Ot(Yr(r,n),-1)})}function Xh(r,t){return U(()=>bl(Yr(op(r,-1),op(t,-1)),"float32"))}function DE(r,t){return U(()=>oe(de(Qr(Yr(r,1),Yr(t,1))),"float32"))}function ZJ(r,t){return U(()=>oe(de(Qr(Yr(r,1),Yr(t,0))),"float32"))}function QJ(r,t){return U(()=>oe(de(Qr(Yr(r,0),Yr(t,1))),"float32"))}function WA(r,t){return U(()=>{let e=DE(r,t),n=QJ(r,t),o=Z(e,n);return oe(Kt(mr(o,0),me(e,o),0),"float32")})}function FE(r,t){return U(()=>{let e=DE(r,t),n=ZJ(r,t),o=Z(e,n);return oe(Kt(mr(o,0),me(e,o),0),"float32")})}function TT(r,t){return ed(r,t)}function xT(r,t){return r.rank===t.rank&&(r=_s(r,[r.rank-1])),t=op(t,-1),t.dtype!==r.dtype&&(t=oe(t,r.dtype)),oe(Yr(r,t),"float32")}var JJ=Fi,e9=Fi,t9=Qc,r9=Qc,n9=vp,o9=vp,Yh=wl,s9=qh,KA=Jc,yT={binaryAccuracy:jh,categoricalAccuracy:Xh,precision:WA,categoricalCrossentropy:Yh,sparseCategoricalCrossentropy:KA,mse:JJ,MSE:e9,mae:t9,MAE:r9,mape:n9,MAPE:o9,cosine:s9};function RE(r){if(typeof r=="string"&&r in yT)return yT[r];if(typeof r!="string"&&r!=null)return r;throw new O(`Unknown metric ${r}`)}function Zh(r){if(rs(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(Hh))if(Hh[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(yT))if(yT[e]===r){t=e;break}return t!==void 0?t:r.name}}function ME(r){let t={Adagrad:()=>hl.adagrad(.01),Adadelta:()=>hl.adadelta(1,.95,dr()),Adam:()=>hl.adam(.001,.9,.999,dr()),Adamax:()=>hl.adamax(.002,.9,.999,dr(),0),RMSProp:()=>hl.rmsprop(.001,.9,0,dr()),SGD:()=>hl.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new O(`Unknown Optimizer ${r}`)}function HA(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!VA(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let n=JSON.stringify(r);n.length>1048576&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${1048576}.`)}}function VA(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!VA(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!VA(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function EE(r,t,e,n=console.log){let o=u9(r),s=["Layer (type)","Input Shape","Output shape","Param #"];o?(t=t||90,e=e||[.32,.61,.89,1]):(t=t||115,e=e||[.24,.48,.7,.8,1]),e[e.length-1]<=1&&(e=e.map(l=>Math.floor(t*l)));let a;if(!o){s.push("Receives inputs"),a=[];for(let l in r.nodesByDepth)a.push(...r.nodesByDepth[l])}n("_".repeat(t)),IT(s,e,n),n("=".repeat(t));let i=r.layers;for(let l=0;l<i.length;++l)o?p9(i[l],e,n):l9(i[l],e,a,n),n((l===i.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let u=i9(r),p=Vc(r.nonTrainableWeights);n(`Total params: ${u+p}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${p}`),n("_".repeat(t))}function i9(r){let t;return r.collectedTrainableWeights!=null?t=Vc(r.collectedTrainableWeights):t=Vc(r.trainableWeights),t}function u9(r){let t=!0,e=[],n=[];for(let o in r.nodesByDepth)e.push(r.nodesByDepth[o]);for(let o of e){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){t=!1;break}n.push(...o)}if(t)for(let o of r.layers){let s=!1;for(let a of o.inboundNodes)if(n.indexOf(a)!==-1)if(s){t=!1;break}else s=!0;if(!t)break}return t}function IT(r,t,e=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,t[o]),n+=" ".repeat(t[o]-n.length);e(n)}function p9(r,t,e){let n,o;try{o=r.inboundNodes.map(u=>JSON.stringify(u.inputShapes)).join(",")}catch{o="multiple"}try{n=JSON.stringify(r.outputShape)}catch{n="multiple"}let s=r.name,a=r.getClassName(),i=[`${s} (${a})`,o,n,r.countParams().toString()];IT(i,t,e)}function l9(r,t,e,n){let o,s;try{s=r.inboundNodes.map(m=>JSON.stringify(m.inputShapes)).join(",")}catch{s="multiple"}try{o=JSON.stringify(r.outputShape)}catch{o="multiple"}let a=[];for(let m of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(m)===-1))for(let c=0;c<m.inboundLayers.length;++c){let d=m.inboundLayers[c].name,f=m.nodeIndices[c],h=m.tensorIndices[c];a.push(`${d}[${f}][${h}]`)}let i=r.name,u=r.getClassName(),p=a.length===0?"":a[0],l=[`${i} (${u})`,s,o,r.countParams().toString(),p];IT(l,t,n);for(let m=1;m<a.length;++m)IT(["","","","",a[m]],t,n)}function _E(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function Nl(r,t){if(r===null)return null;if(typeof r=="string")return lu(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];_E(t,o,s)?e.push(s):e.push(Nl(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")e[n]=o;else{let s=lu(n);e[s]=Nl(o,s)}}return e}}function CT(r,t){if(r==null)return null;if(typeof r=="string")return Os(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];_E(t,o,s)?e.push(s):e.push(CT(s,t))}return e}else{let e={};for(let n of Object.keys(r)){let o=r[n],s=Os(n);(n==="name"||n==="className")&&typeof o=="string"?e[s]=o:e[s]=CT(o,n)}return e}}var Qh="0.0.0";var Xn=class extends Ue{constructor(e){super({});this.containerNodes=new Set;if(this.name=e.name,this.name==null){let x=this.getClassName().toLowerCase();this.name=Cp(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],zs(this.inputs).length!==this.inputs.length)throw new O(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);zs(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let x of this.outputs){let I=x.sourceLayer,k=x.nodeIndex,w=x.tensorIndex;this.outputLayers.push(I),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(w)}for(let x of this.inputs){let I=x.sourceLayer,k=x.nodeIndex,w=x.tensorIndex;rs(k===0,"input layer has >1 nodes"),rs(w===0,"input layer has >1 tensors"),this.inputLayers.push(I),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){let I=this.inputLayers[x];if(!(I instanceof Za))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${I.getClassName()}.`);this.inputNames.push(I.name),this.feedInputShapes.push(I.batchInputShape),this.feedInputNames.push(I.name)}for(let x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);let n={},o={},s={},a={},i={},u=[],p=(x,I,k,w,R,P)=>{(w==null||R==null||P==null)&&(w=x.sourceLayer,R=x.nodeIndex,P=x.tensorIndex);let M=w.inboundNodes[R];if(k.indexOf(M)!==-1)throw new Hr(`The tensor ${x.name} at layer "${w.name}" is part of a cycle.`);if(I.indexOf(M)!==-1)return;this.containerNodes.add(Xn.nodeKey(w,R)),w.id in i||(i[w.id]=Object.keys(i).length),k.indexOf(M)===-1&&k.push(M);let L=M.inboundLayers.length;for(let z=0;z<L;z++){let W=M.inputTensors[z],V=M.inboundLayers[z],j=M.nodeIndices[z],H=M.tensorIndices[z];p(W,I,k,V,j,H)}for(I.push(M);k.indexOf(M)>=0;)k.splice(k.indexOf(M),1);u.push(M)},l=[],m=[];for(let x of this.outputs)p(x,l,m);let c=u.slice().reverse();for(let x of c){o[x.id]=x,x.id in n||(n[x.id]=0);let I=n[x.id],k=s[x.outboundLayer.id]==null?0:s[x.outboundLayer.id];I=Math.max(I,k),s[x.outboundLayer.id]=I,a[x.outboundLayer.id]=x.outboundLayer,n[x.id]=I;for(let w=0;w<x.inboundLayers.length;w++){let R=x.inboundLayers[w],P=x.nodeIndices[w],M=R.inboundNodes[P],L=n[M.id]==null?0:n[M.id];n[M.id]=Math.max(I+1,L),o[M.id]=M}}let d={};for(let x in n){let I=n[x];I in d||(d[I]=[]),d[I].push(o[x])}let f={};for(let x in s){let I=s[x];I in f||(f[I]=[]),f[I].push(a[x])}let h=Object.keys(f).map(x=>parseInt(x,10)).sort(zh);this.layers=[];for(let x of h){let I=f[x];I.sort((k,w)=>{let R=i[k.id],P=i[w.id];return R<P?-1:R>P?1:0});for(let k of I)k instanceof Xn&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=f,h=Object.keys(d).map(x=>parseInt(x,10)).sort(zh);let g=this.inputs.slice(),b=[];for(let x of h)for(let I of d[x]){let k=I.outboundLayer;if(k!=null){for(let w of I.inputTensors)if(g.indexOf(w)===-1)throw new Hr(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${k.name}". The following previous layers were accessed without issue: ${b}`);for(let w of I.outputTensors)g.push(w);b.push(k.name)}}this.nodesByDepth=d;let T=this.layers.map(x=>x.name);for(let x of T){let I=T.filter(k=>k===x).length;if(I!==1)throw new Hr(`The name "${x}" is used ${I} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(T))}this.outboundNodes=[],this.inboundNodes=[],new du({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(let n of this.layers)e.numDisposedVariables+=n.dispose().numDisposedVariables;for(let n of this.internalContainerRefs)e.numDisposedVariables+=n.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(n=>{n._trainableWeights.forEach(o=>o.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new O("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let n of this.layers)e=e.concat(n.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let n of this.layers)e.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let o of this.layers)n.push(...o.trainableWeights);return n.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,n=!0){let o={},s=0;for(let i of this.layers)for(let u of i.weights){if(o[u.originalName]!=null)throw new O(`Duplicate weight name: ${u.originalName}`);o[u.originalName]=u,s++}let a=[];for(let i in e){let u=i;if(o[i]==null){let p=i.split("/");u=p.slice(0,-2).concat([p[p.length-1]]).join("/")}if(o[u]!=null)a.push([o[u],e[i]]);else if(n)throw new O(`Provided weight data has no target variable: ${i}`);delete o[u]}if(n){let i=[];for(let u in o)i.push(u);if(i.length>0)throw new O(`${i.length} of ${s} weights are not set: ${i}`)}Hc(a)}updatedConfig(){let e=this.getConfig(),n={};return n.className=this.getClassName(),n.config=e,n.kerasVersion=`tfjs-layers ${Qh}`,n.backend="TensorFlow.js",n}toJSON(e,n=!0){let o=CT(this.updatedConfig());return n?JSON.stringify(o):o}call(e,n){return U(()=>{e=wt(e);let o=new Ws;for(let s=0;s<this.inputs.length;++s)o.add(this.inputs[s],e[s]);return vl(this.outputs,o,n)})}computeMask(e,n){return U(()=>{e=wt(e);let o;return n==null?o=Bs(null,e.length):o=wt(n),this.runInternalGraph(e,o)[1]})}computeOutputShape(e){let n=Kc(e);if(n.length!==this.inputLayers.length)throw new O(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let o={};for(let u=0;u<n.length;u++){let p=this.inputLayers[u],l=n[u],m=p.name+"_0_0";o[m]=l}let s=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(zh);if(s.length>1)for(let u of s){let p=this.nodesByDepth[u];for(let l of p){let m=l.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(m.id)!==-1)continue;let c=[];for(let g=0;g<l.inboundLayers.length;g++){let b=l.inboundLayers[g],T=l.nodeIndices[g],x=l.tensorIndices[g],I=`${b.name}_${T}_${x}`,k=o[I];c.push(k)}let d=m.computeOutputShape(Rr(c)),f=Kc(d),h=m.inboundNodes.indexOf(l);for(let g=0;g<f.length;g++){let b=`${m.name}_${h}_${g}`;o[b]=f[g]}}}let a=[],i=[];for(let u=0;u<this.outputLayers.length;u++){let p=this.outputLayers[u],l=this.outputLayersNodeIndices[u],m=this.outputLayersTensorIndices[u],c=`${p.name}_${l}_${m}`;i.push(c)}for(let u=0;u<i.length;u++){let p=i[u];rs(p in o),a.push(o[p])}return Rr(a)}runInternalGraph(e,n){n==null&&(n=Bs(null,e.length));let o={};for(let p=0;p<this.inputs.length;++p){let l=this.inputs[p],m=e[p],c=n[p];o[l.id]=[m,c]}let s=Object.keys(this.nodesByDepth).map(p=>parseInt(p,10)).sort(zh);for(let p of s){let l=this.nodesByDepth[p];for(let m of l){let c=m.outboundLayer,d=m.inputTensors,f=m.outputTensors,h=new Array;for(let g of d)g.id in o&&h.push(o[g.id]);if(h.length===d.length){let g={},b,T,x,I;if(m.callArgs!=null&&(g=m.callArgs),h.length===1){let[k,w]=h[0];g.mask==null&&(g.mask=w),x=wt(c.call(k,g)),I=wt(c.computeMask(k,w)),b=[k],T=[w]}else b=h.map(k=>k[0]),T=h.map(k=>k[1]),g.mask==null&&(g.mask=T),x=wt(c.call(b,g)),I=wt(c.computeMask(b,T));if(c.activityRegularizer)throw new Ne("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<f.length;++k){let w=f[k],R=x[k],P=I[k];o[w.id]=[R,P]}}}}let a=[],i=[],u=[];for(let p of this.outputs){rs(p.id in o,`Could not compute output ${p.name} : ${p.id}`);let[l,m]=o[p.id];u.push(l.shape),a.push(l),i.push(m)}return[a,i,u]}buildNodeConversionMap(e){let n={},o;for(let s of this.layers){o=s instanceof Xn?1:0;for(let a=0;a<s.inboundNodes.length;a++){let i=Xn.nodeKey(s,a);this.containerNodes.has(i)&&(n[i]=o,o+=1)}}return n}getLayer(e,n){if(n!=null){if(this.layers.length<=n)throw new O(`Was asked to retrieve layer at index ${n}, but model only has ${this.layers.length} layer(s).`);return this.layers[n]}else if(e==null)throw new O("Provide either a layer name or layer index");for(let o of this.layers)if(o.name===e)return o;throw new O(`No such layer: ${e}`)}calculateLosses(){return U(()=>{let e=[];for(let n of this.layers)for(let o=0;o<n.inboundNodes.length;++o){let s=Xn.nodeKey(n,o);this.containerNodes.has(s)&&e.push(...n.calculateLosses())}return e})}getConfig(){let e={name:this.name},n=this.buildNodeConversionMap(this.layers),o=[];for(let i of this.layers){let u=i.getClassName(),p=i.getConfig(),l=[];for(let c=0;c<i.inboundNodes.length;c++){let d=i.inboundNodes[c],f=Xn.nodeKey(i,c),h={};if(this.containerNodes.has(f)){if(d.callArgs)try{JSON.stringify(d.callArgs),h=d.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),h={}}if(d.inboundLayers.length>0){let g=[];for(let b=0;b<d.inboundLayers.length;b++){let T=d.inboundLayers[b],x=d.nodeIndices[b],I=d.tensorIndices[b],k=Xn.nodeKey(T,x),w=n[k];w==null&&(w=0),g.push([T.name,w,I,h])}l.push(g)}}}let m={};m.name=i.name,m.className=u,m.config=p,m.inboundNodes=l,o.push(m)}e.layers=o;let s=[];for(let i=0;i<this.inputLayers.length;i++){let u=this.inputLayers[i],p=this.inputLayersNodeIndices[i],l=Xn.nodeKey(u,p);if(!this.containerNodes.has(l))continue;let m=n[l];m==null&&(m=0);let c=this.inputLayersTensorIndices[i];s.push([u.name,m,c])}e.inputLayers=s;let a=[];for(let i=0;i<this.outputLayers.length;i++){let u=this.outputLayers[i],p=this.outputLayersNodeIndices[i],l=Xn.nodeKey(u,p);if(!this.containerNodes.has(l))continue;let m=n[l];m==null&&(m=0);let c=this.outputLayersTensorIndices[i];a.push([u.name,m,c])}return e.outputLayers=a,e}static fromConfig(e,n,o={},s=!1){let a={},i={};function u(b,T){b.name in i?i[b.name].push(T):i[b.name]=[T]}function p(b,T){let x=[],I;for(let k of T){let w=k[0],R=k[1],P=k[2];if(I=k[3]==null?{}:k[3],!(w in a)){u(b,T);return}let M=a[w];if(M.inboundNodes.length<=R){u(b,T);return}let L=M.inboundNodes[R];x.push(L.outputTensors[P])}x.length>0&&b.apply(Rr(x),I)}function l(b){let T=b.name,x=Cn(b,n.customObjects!=null?n.customObjects:{});x.setFastWeightInitDuringBuild(s),a[T]=x,b.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new O(`Corrupted configuration, expected array for nodeData: ${k}`);u(x,k)})}let m=n.name,c=n.layers;for(let b of c)l(b);for(;!rP(i);)for(let b of c){let T=a[b.name];if(T.name in i){let x=i[T.name];delete i[T.name];for(let I of x)p(T,I)}}let d=[],f=[],h=n.inputLayers;for(let b of h){let T=b[0],x=b[1],I=b[2];rs(T in a);let w=a[T].inboundNodes[x].outputTensors;d.push(w[I])}let g=n.outputLayers;for(let b of g){let T=b[0],x=b[1],I=b[2];rs(T in a);let w=a[T].inboundNodes[x].outputTensors;f.push(w[I])}return new e({inputs:d,outputs:f,name:m})}get stateful(){if(this._stateful)throw new O("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){U(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function m9(r,t,e){let n=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return t.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function kT(r,t){return m9(r,t,"classWeight")}async function ST(r,t,e,n){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let o=U(()=>{if(r.shape.length===1)return fn(r);if(r.shape.length===2){if(r.shape[1]>1)return op(r,1);if(r.shape[1]===1)return $(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());Pe(o);let a=[];return s.forEach(i=>{if(e[i]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${i} exists in the data but not in classWeight`);a.push(e[i])}),Xt(a,"float32")}else return null}function LE(r,t){return _(r,t)}var c9=32;function OE(r,t){let e,n,o=t;e=o.xs,n=o.ys,y.assert(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let s=$E("input",r.inputNames,e),a=$E("output",r.outputNames,n),i=s[0].shape[0];y.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),y.assert(a.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)y.assert(s[u].shape[0]===i,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);for(let u=0;u<a.length;u++)y.assert(a[u].shape[0]===i,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${a[u].shape[0]}; expected  ${i} based on input ${r.inputNames[0]}.`);return{xs:s,ys:a}}function $E(r,t,e){if(e instanceof qe)return[e];if(Array.isArray(e))return y.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let n=[];for(let o of t){if(e[o]==null)throw new O(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(e[o])}return n}}function d9(r){if(r.length===3)throw new Ne("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function zE(r,t,e){let n=e.batchesPerEpoch!=null;if(y.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),y.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),y.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),y.assert(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),y.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=e.validationData!=null,s,a;if(o)if(BE(e.validationData))y.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let g=d9(e.validationData);s=g.xs,a=g.ys}let i=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),p;o?p=u.slice().concat(u.map(g=>"val_"+g)):p=u.slice();let l=hT(e.callbacks,e.yieldEvery),m=e.verbose==null?1:e.verbose,{callbackList:c,history:d}=gT(l,m,e.epochs,null,null,f9(t,e),null,o,p);c.setModel(r),r.history=d,await c.onTrainBegin(),r.stopTraining_=!1;let f=e.initialEpoch==null?0:e.initialEpoch,h=await t.iterator();for(;f<e.epochs;){let g={};await c.onEpochBegin(f);let b=0,T=0;for(n||(h=await t.iterator());!n||b<e.batchesPerEpoch;){let x=await h.next();if(n&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${b} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){let{xs:I,ys:k}=OE(r,x.value),w={};w.batch=T,w.size=I[0].shape[0],await c.onBatchBegin(T,w);let R=[];if(e.classWeight!=null){let L=kT(e.classWeight,r.outputNames);for(let z=0;z<L.length;++z)R.push(await ST(k[z],null,L[z]))}let P=I.concat(k).concat(R),M=i(P);Pe(P);for(let L=0;L<u.length;++L){let z=u[L],W=M[L];w[z]=W,Ut(W)}await c.onBatchEnd(T,w),mT(w),T++,b++}if(n?b>=e.batchesPerEpoch:x.done){if(o){let I;BE(e.validationData)?I=wt(await r.evaluateDataset(e.validationData,{batches:e.validationBatches})):I=wt(r.evaluate(s,a,{batchSize:e.validationBatchSize==null?c9:e.validationBatchSize,verbose:0}));for(let k=0;k<r.metricsNames.length;++k)g[`val_${r.metricsNames[k]}`]=I[k]}break}if(r.stopTraining_)break}if(await c.onEpochEnd(f,g),f++,r.stopTraining_)break}return await c.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function f9(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function BE(r){return typeof r.iterator=="function"}function h9(r){return typeof r.next=="function"}async function GE(r,t,e){e=e||{};let n=e.batches!=null,o=r.testFunction,s=[];if(e.verbose>0)throw new Ne("Verbose mode is not implemented yet.");y.assert(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let a=h9(t)?t:await t.iterator(),i=0,u=0;for(;!n||u<e.batches;){let p=await a.next();if(s=U(()=>{if(p.value){let{xs:l,ys:m}=OE(r,p.value),c=l.concat(m),d=U(()=>o(c));if(Pe(c),u===0)for(let h=0;h<d.length;++h)s.push(ce(0));let f=c[0].shape[0];for(let h=0;h<d.length;++h){let g=d[h],b=s[h];s[h]=U(()=>Z(s[h],_(f,g))),u>0&&Pe(b)}Pe(d),i+=f,++u}return s}),p.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let p=0;p<s.length;++p){let l=s[p];s[p]=me(s[p],i),Pe(l)}return Rr(s)}function vT(r){y.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function td(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(n=>mu(n,t,e-t)):mu(r,t,e-t)}function AT(r,t){return U(()=>r==null?null:Array.isArray(r)?r.map(e=>AT(e,t)):nT(r,t.dtype==="int32"?t:oe(t,"int32")))}function wT(r,t){let e=[],n=0,o=null;for(;n<r;)o=n+t,o>=r&&(o=r),e.push([n,o]),n=o;return e}async function g9(r,t,e,n,o,s,a,i,u,p,l,m,c,d,f){o==null&&(o=32),s==null&&(s=1),l==null&&(l=!0),c==null&&(c=0);let h=!1;if(u!=null&&p!=null&&(h=!0),f!=null&&(h=!0,d==null))throw new O("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(e,o,d,"steps_per_epoch"),b;g!=null&&(b=en(0,g)),a==null&&(a=1);let{callbackList:T,history:x}=gT(i,a,s,c,g,d,o,h,m);T.setModel(r),r.history=x,await T.onTrainBegin(),r.stopTraining_=!1;for(let I=c;I<s;++I){await T.onEpochBegin(I);let k={};if(d!=null)throw new Ne("stepsPerEpoch mode is not implemented yet.");{if(l==="batch")throw new Ne("batch shuffling is not implemneted yet");l&&y.shuffle(b);let w=Xt(b),R=wT(g,o);for(let P=0;P<R.length;++P){let M={};if(await T.onBatchBegin(P,M),U(()=>{let L=R[P][0],z=R[P][1],W=mu(w,L,z-L);M.batch=P,M.size=z-L;let V=AT(e,W),j=t(V);for(let H=0;H<n.length;++H){let X=n[H],ee=j[H];M[X]=ee,Ut(ee)}if(P===R.length-1&&h){let H=r.testLoop(u,p,o);for(let X=0;X<n.length;++X){let ee=n[X],q=H[X];Ut(q),k["val_"+ee]=q}}}),await T.onBatchEnd(P,M),mT(M),r.stopTraining_)break}w.dispose()}if(await T.onEpochEnd(I,k),r.stopTraining_)break}return await T.onTrainEnd(),await r.history.syncData(),r.history}async function UE(r,t,e,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,a,i,u,p,l,m,c;try{let d=n.batchSize==null?32:n.batchSize;vT(d);let f=!1,h=await r.standardizeUserData(t,e,n.sampleWeight,n.classWeight,f,d);o=h[0],s=h[1],c=h[2];let g=!1,b;if(n.validationData!=null&&n.validationData.length>0){if(g=!0,n.validationData.length===2)u=n.validationData[0],p=n.validationData[1];else throw n.validationData.length===3?new Ne("validationData including sample weights is not supported yet."):new O(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let M=!0,L=await r.standardizeUserData(u,p,null,null,M,d);l=L[0],m=L[1],b=l.concat(m)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){g=!0;let M=Math.floor(o[0].shape[0]*(1-n.validationSplit)),L=o[0].shape[0];l=td(o,M,L),a=o,o=td(o,0,M),m=td(s,M,L),i=s,s=td(s,0,M),b=l.concat(m)}else n.validationSteps!=null&&(g=!0);let T=o.concat(s).concat(c);r.checkTrainableWeightsConsistency();let x=r.makeTrainFunction(),I=r.getDedupedMetricsNames(),k,w;g?(r.makeTestFunction(),k=r.testFunction,w=I.slice().concat(I.map(M=>"val_"+M))):(k=null,b=[],w=I.slice());let R=hT(n.callbacks,n.yieldEvery);return await g9(r,x,T,I,d,n.epochs,n.verbose,R,k,b,n.shuffle,w,n.initialEpoch,null,null)}finally{r.isTraining=!1,Ks(o,t),Ks(s,e),Ks(a,t),Ks(i,e),Ks(l,u),Ks(m,p),c!=null&&Pe(c)}}function qA(r){let t=[];r instanceof qe&&(r=[r]);for(let e=0;e<r.length;++e){let n=r[e];if(n.rank===1)t.push(cu(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function Ks(r,t){if(r==null)return;let e=[];if(t instanceof qe)e.push(t.id);else if(Array.isArray(t))t.forEach(o=>e.push(o.id));else if(t!=null)for(let o in t){let s=t[o];e.push(s.id)}let n=[];if(r instanceof qe)e.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{e.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];e.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function b9(r){return r instanceof qe}function jA(r){return Array.isArray(r)}function WE(r){return!b9(r)&&!jA(r)}function KE(r,t,e,n=!0,o=""){if(t==null||t.length===0){if(r!=null){let a=!1;if(jA(r)&&r.length>0)a=!0;else if(WE(r)){for(let i in r)if(r.hasOwnProperty(i)){a=!0;break}}else a=!0;if(a)throw new O(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(a=>null);let s;if(WE(r)){r=r,s=[];for(let a of t){if(r[a]==null)throw new O(`No data provided for "${a}". Need data for each key in: ${t}`);s.push(r[a])}}else if(jA(r)){if(r=r,r.length!==t.length)throw new O(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,t.length>1)throw new O(`The model ${o} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=qA(s),e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;let i=s[a];if(i.shape.length!==e[a].length)throw new O(`Error when checking ${o}: expected ${t[a]} to have ${e[a].length} dimension(s). but got array with shape ${i.shape}`);for(let u=0;u<e[a].length;++u){if(u===0&&!n)continue;let p=i.shape[u],l=e[a][u];if(l!=null&&l>=0&&p!==l)throw new O(`${o} expected a batch of elements where each example has shape [${e[a].slice(1,e[a].length)}] (i.e.,tensor shape [*,${e[a].slice(1,e[a].length)}]) but the ${o} received an input with ${i.shape[0]} examples, each with shape [${i.shape.slice(1,i.shape.length)}] (tensor shape [${i.shape}])`)}}return s}function y9(r,t,e){let n=zs(r.map(s=>s.shape[0]));n.sort();let o=zs(t.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new O(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new O(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!y.arraysEqual(n,o))throw new O(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function T9(r,t,e){let n=[Fi,ed,wl];for(let o=0;o<r.length;++o){let s=r[o],a=t[o],i=e[o];if(a!=null){if(a===wl&&s.shape[s.shape.length-1]===1)throw new O(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(a)!==-1){let u=s.shape.slice(1),p=i.slice(1);for(let l=0;l<u.length;++l){let m=u[l],c=p[l];if(c!=null&&m!==c)throw new O(`A target Tensor with shape ${s.shape} was passed for an output of shape ${i}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function VE(r,t,e,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==t.length)throw new O(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(t.length>1)throw new O(`The model expects ${t.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;let i=s[a];if(i.shape.length!==e[a].length)throw new O(`Error when checking ${o}: expected ${t[a]} to have ${e[a].length} dimension(s), but got array with shape ${JSON.stringify(i.shape)}`);for(let u=0;u<e[a].length;++u){if(u===0&&!n)continue;let p=i.shape[u],l=e[a][u];if(l!=null&&l!==p)throw new O(`Error when checking ${o}: expected ${t[a]} to have shape ${JSON.stringify(e[a])} but got array with shape ${JSON.stringify(i.shape)}.`)}}}function x9(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(n=>e);{let n=[];for(let o of t){let s=e.hasOwnProperty(o)?e[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var I9="layers-model",Yn=class extends Xn{constructor(e){super(e);this.isTraining=!1}summary(e,n,o=console.log){if(!this.built)throw new O("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");EE(this,e,n,o)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=ME(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Vr))throw new O("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let n=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new O(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),n.push(bT(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new O(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);n=e.loss.map(u=>bT(u))}else{let i=bT(e.loss);this.outputs.forEach(u=>{n.push(i)})}this.lossFunctions=n,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let u=this.internalOutputShapes[i],p=this.outputNames[i];this.feedOutputNames.push(p),this.feedOutputShapes.push(u),this.feedLossFns.push(this.lossFunctions[i])}let o=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Xa("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(o.indexOf(i)!==-1)continue;let u=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([u,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let s=x9(e.metrics,this.outputNames),a=(i,u,p)=>{this.outputNames.length>1&&(u=this.outputNames[i]+"_"+u),this.metricsNames.push(u),this.metricsTensors.push([p,i])};Xa("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(o.indexOf(i)!==-1)continue;let u=s[i];(l=>{let m="",c,d,f;for(let h of l){if(typeof h=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(h)!==-1){let b=this.internalOutputShapes[i];b[b.length-1]===1||this.lossFunctions[i]===ed?["accuracy","acc"].indexOf(h)!==-1?d=jh:["crossentropy","ce"].indexOf(h)!==-1&&(d=TT):this.lossFunctions[i]===Jc?["accuracy","acc"].indexOf(h)!==-1?d=xT:["crossentropy","ce"].indexOf(h)!==-1&&(d=KA):["accuracy","acc"].indexOf(h)!==-1?d=Xh:["crossentropy","ce"].indexOf(h)!==-1&&(d=Yh);let T;["accuracy","acc"].indexOf(h)!==-1?T="acc":["crossentropy","ce"].indexOf(h)!==-1&&(T="ce"),f=d,c=m+T}else f=RE(h),c=m+Zh(h);let g;Xa(c,()=>{g=f}),a(i,c,g)}})(u)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,n,o={}){let s=o.batchSize==null?32:o.batchSize;vT(s);let a=!0,i=this.standardizeUserDataXY(e,n,a,s);try{let u=i[0].concat(i[1]);this.makeTestFunction();let p=this.testFunction,l=this.testLoop(p,u,s,o.verbose,o.steps);return Rr(l)}finally{Ks(i[0],e),Ks(i[1],n)}}async evaluateDataset(e,n){return this.makeTestFunction(),GE(this,e,n)}checkNumSamples(e,n,o,s="steps"){let a;if(o!=null){if(a=null,n!=null)throw new O(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${n}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new O(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return a}execute(e,n){if(Array.isArray(n)&&n.length===0)throw new O("`outputs` is an empty Array, which is not allowed.");let o=Array.isArray(n),s=o?n:[n],a=this.retrieveSymbolicTensors(s),i=new Ws;if(e instanceof qe&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new O(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let p=0;p<this.inputs.length;++p)i.add(this.inputs[p],e[p])}else for(let p of this.inputs){let l=e[p.name];if(l==null)throw new O(`No value is provided for the model's input ${p.name}`);i.add(p,l)}let u=vl(a,i);return o?u:u[0]}retrieveSymbolicTensors(e){let n=Bs(null,e.length),o=e.length;for(let s of this.layers){let a=Array.isArray(s.output)?s.output:[s.output],i=a.map(u=>u.name);for(let u=0;u<e.length;++u){let p=i.indexOf(e[u]);if(p!==-1&&(n[u]=a[p],o--),o===0)break}if(o===0)break}if(o>0){let s=[];throw n.forEach((a,i)=>{a==null&&s.push(e[i])}),new O(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return n}predictLoop(e,n=32,o=!1){return U(()=>{let s=this.checkNumSamples(e);if(o)throw new Ne("Verbose predictLoop() is not implemented yet.");let a=wT(s,n),i=this.outputs.map(u=>[]);for(let u=0;u<a.length;++u)U(()=>{let l=a[u][0],m=a[u][1],c=td(e,l,m),d=[];if(Array.isArray(c))for(let h=0;h<c.length;++h)d.push({key:this.inputs[h],value:c[h]});else d.push({key:this.inputs[0],value:c});let f=new Ws(d);return vl(this.outputs,f)}).forEach((l,m)=>i[m].push(l));return Rr(i.map(u=>ct(u,0)))})}predict(e,n={}){let o=qA(e);VE(o,this.inputNames,this.feedInputShapes,!1);try{let s=n.batchSize==null?32:n.batchSize;return vT(s),this.predictLoop(o,s)}finally{Ks(o,e)}}predictOnBatch(e){VE(e,this.inputNames,this.feedInputShapes,!0);let n=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,n)}standardizeUserDataXY(e,n,o=!0,s){if(this.optimizer_==null)throw new Hr("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let a=[];for(let i=0;i<this.feedOutputShapes.length;++i){let u=this.feedOutputShapes[i];this.feedLossFns[i]===Jc?a.push(u.slice(0,u.length-1).concat([1])):a.push(u)}if(e=KE(e,this.feedInputNames,this.feedInputShapes,!1,"input"),n=KE(n,this.feedOutputNames,a,!1,"target"),y9(e,n,null),T9(n,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&e[0].shape[0]%s!==0)throw new O(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${e[0].shape[0]} sample(s).`);return[e,n]}async standardizeUserData(e,n,o,s,a=!0,i){let[u,p]=this.standardizeUserDataXY(e,n,a,i);if(o!=null)throw new Error("sample weight is not supported yet.");let l=null;if(s!=null){let m=kT(s,this.outputNames);l=[];for(let c=0;c<m.length;++c)l.push(await ST(p[c],null,m[c]))}return[u,p,l]}testLoop(e,n,o,s=0,a){return U(()=>{let i=this.checkNumSamples(n,o,a,"steps"),u=[];if(s>0)throw new Ne("Verbose mode is not implemented yet.");if(a!=null)throw new Ne("steps mode in testLoop() is not implemented yet");{let p=wT(i,o),l=Xt(en(0,i));for(let m=0;m<p.length;++m){let c=p[m][0],d=p[m][1],f=mu(l,c,d-c),h=AT(n,f),g=e(h);if(m===0)for(let b=0;b<g.length;++b)u.push(ce(0));for(let b=0;b<g.length;++b){let T=g[b];u[b]=Z(u[b],_(d-c,T))}}for(let m=0;m<u.length;++m)u[m]=me(u[m],i)}return u})}getDedupedMetricsNames(){let e=this.metricsNames,n=[];for(let o=0;o<e.length;++o){let s=e[o],a=s;FA(e,s)>1&&(a+=`_${FA(e.slice(0,o),s)}`),n.push(a)}return n}makeTrainFunction(){return e=>{let n=[],o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],u=()=>{let c=[];for(let g=0;g<this.inputs.length;++g)c.push({key:this.inputs[g],value:o[g]});let d=new Ws(c),f=vl(this.outputs,d,{training:!0}),h;for(let g=0;g<this.lossFunctions.length;++g){let b=this.lossFunctions[g],T=b(s[g],f[g]);a[g]!=null&&(T=LE(T,a[g]));let x=Ot(T);n.push(x),g===0?h=T:h=Z(h,T)}for(let g=0;g<this.metricsTensors.length;++g){let b;if(this.outputs.length>1&&g<this.outputs.length)b=n[g];else{let T=this.metricsTensors[g][0],x=this.metricsTensors[g][1];b=Ot(T(s[x],f[x]))}Ut(b),i.push(b)}return h=Ot(h),this.calculateLosses().forEach(g=>{h=Z(h,g)}),h},p=this.collectedTrainableWeights.map(c=>c.read()),l=!0;return[this.optimizer_.minimize(u,l,p)].concat(i)}}makeTestFunction(){this.testFunction=e=>U(()=>{let n=[],o,s=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:s[l]});let u=new Ws(i),p=vl(this.outputs,u);for(let l=0;l<this.lossFunctions.length;++l){let m=this.lossFunctions[l],c=Ot(m(a[l],p[l]));l===0?o=c:o=Z(o,c),n.push(o)}for(let l=0;l<this.metricsTensors.length;++l){let m=this.metricsTensors[l][0],c=this.metricsTensors[l][1],d=Ot(m(a[c],p[c]));n.push(d)}return n})}async fit(e,n,o={}){return UE(this,e,n,o)}async fitDataset(e,n){return zE(this,e,n)}async trainOnBatch(e,n){let o=await this.standardizeUserData(e,n),s=o[0],a=o[1],u=this.makeTrainFunction()(s.concat(a)),p=[];for(let l of u){let m=await l.data();p.push(m[0])}return Pe(u),Ks(o[0],e),Ks(o[1],n),Rr(p)}getNamedWeights(e){let n=[],o=e!=null&&e.trainableOnly,s=o?this.trainableWeights:this.weights,a=this.getWeights(o);for(let i=0;i<s.length;++i)o&&!s[i].trainable||n.push({name:s[i].originalName,tensor:a[i]});return n}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let n=wh().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=n-wh().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Os(this.loss);else if(Array.isArray(this.loss)){for(let n of this.loss)if(typeof n!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(n=>Os(n))}else{let n=Object.keys(this.loss);e={};let o=this.loss;for(let s of n)if(typeof o[s]=="string")e[s]=Os(o[s]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Os(Zh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Os(Zh(e)));{let e={};for(let n in this.metrics)e[n]=Os(Zh(this.metrics[n]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let n=Nl(e.optimizer_config),o=Cn(n),s;if(typeof e.loss=="string")s=lu(e.loss);else if(Array.isArray(e.loss))s=e.loss.map(i=>lu(i));else if(e.loss!=null){s={};for(let i in e.loss)s[i]=lu(e.loss[i])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(i=>lu(i));else if(e.metrics!=null){a={};for(let i in e.metrics)a[i]=lu(e.metrics[i])}this.compile({loss:s,metrics:a,optimizer:o})}async save(e,n){if(typeof e=="string"){let l=Pn.getSaveHandlers(e);if(l.length===0)throw new O(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new O(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new O("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let o=await Pn.encodeWeights(this.getNamedWeights(n)),s=!1,a=null,u={modelTopology:this.toJSON(a,s),format:I9,generatedBy:`TensorFlow.js tfjs-layers v${Qh}`,convertedBy:null};if((n==null?!1:n.includeOptimizer)&&this.optimizer!=null){u.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:m,specs:c}=await Pn.encodeWeights(await this.optimizer.getWeights(),l);o.specs.push(...c),o.data=Pn.concatenateArrayBuffers([o.data,m])}return this.userDefinedMetadata!=null&&(HA(this.userDefinedMetadata,this.name,!0),u.userDefinedMetadata=this.userDefinedMetadata),u.weightData=o.data,u.weightSpecs=o.specs,e.save(u)}setUserDefinedMetadata(e){HA(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};Yn.className="Model";te.registerClass(Yn);var NT=class extends Yn{};NT.className="Functional";te.registerClass(NT);async function HE(r,t){"modelTopology"in r||(r={modelTopology:r}),r=r;let e=r.modelTopology;e.model_config!=null&&(e=e.model_config);let n=Nl(e),o=Cn(n,t);if(r.weightsManifest!=null){let s=await Pn.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(i=>i.originalName)),a={};for(let i of o.weights)a[i.originalName]=s[i.originalName];o.loadWeights(a),Pe(s)}return o}async function qE(r,t){if(t==null&&(t={}),typeof r=="string"){let e=Pn.getLoadHandlers(r,t);if(e.length===0)e.push(Pn.browserHTTPRequest(r,t));else if(e.length>1)throw new O(`Found more than one (${e.length}) load handlers for URL '${r}'`);r=e[0]}return C9(r,void 0,t)}async function C9(r,t,e){if(e==null&&(e={}),r.load==null)throw new O("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=e.strict==null?!0:e.strict,a=n.weightData!=null&&n.weightSpecs!=null&&s,i=Cn(Nl(o),t,a),u=n.trainingConfig;if(u!=null&&i.loadTrainingConfig(u),n.userDefinedMetadata!=null&&i.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new O("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:p,optimizerWeights:l}=k9(n.weightData,n.weightSpecs);i.loadWeights(p,s),i.optimizer!=null&&l.length>0&&await i.optimizer.setWeights(l),Pe(p),Pe(l.map(m=>m.tensor))}return i}function k9(r,t){let e=Pn.decodeWeights(r,t),n={},o=[];return t.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:e[s.name]}):n[s.name]=e[s.name]}),{modelWeights:n,optimizerWeights:o}}var DT=class extends Yn{constructor(e){super({inputs:[],outputs:[]});if(e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Cp("sequential_"),e.layers!=null)for(let n of e.layers)this.add(n)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(o=>o<0))throw new O(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let n=e instanceof DT||e instanceof Yn,o;if(n){if(o=e,o.outputs.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(o.inputs.length!==1)throw new O("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new O("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=aT({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(s)}if(n)this.outputs=o.outputs,this.inputs=o.inputs;else{if(e.inboundNodes.length!==1)throw new O(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=LA(this.outputs[0])}this.inboundNodes=[],new du({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Bs(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=e.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,n){return this.model==null&&this.build(),this.model.call(e,n)}build(e){if(nt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Yn({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,n,o=console.log){this.built||this.build(),super.summary(e,n,o)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,n,o={}){if(!this.built)throw new Hr("The model needs to be compiled before being used.");return this.model.evaluate(e,n,o)}async evaluateDataset(e,n){if(!this.built)throw new Hr("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,n)}predict(e,n={}){return this.model==null&&this.build(),this.model.predict(e,n)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,n,o={}){if(!this.built)throw new Hr("The model needs to be compiled before being used.");return this.model.fit(e,n,o)}async fitDataset(e,n){if(!this.built)throw new Hr("The model needs to be compiled before being used.");return this.model.fitDataset(e,n)}async trainOnBatch(e,n){return this.model.trainOnBatch(e,n)}static fromConfig(e,n,o={},s=!1){let a,i={};if(n instanceof Array){if(n[0].className==null||n[0].className==="Merge")throw new O("Legacy serialization format not supported yet.");a=n}else y.assert(n.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=n.layers,delete n.layers,i=n;let u=new e(i);if(!(u instanceof DT))throw new Ne(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(let p of a){let m=Cn(p,void 0,s);s&&m.setFastWeightInitDuringBuild(!0),u.add(m)}return u}set stopTraining(e){if(this.model==null)throw new O("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new O("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let n of this.layers){let o={};o.className=n.getClassName(),o.config=n.getConfig(),e.push(o)}return{name:this.name,layers:e}}},Dl=DT;Dl.className="Sequential";te.registerClass(Dl);function S9(r){return new Yn(r)}function v9(r){return new Dl(r)}function A9(r,t){return t==null&&(t={}),qE(r,t)}function XA(r){return aT(r)}function w9(r,t){Zc.registerCallbackConstructor(r,t)}var rn=class extends te.Serializable{getConfig(){return{}}},FT=class extends rn{apply(t,e=1){return bP(t,e)}};FT.className="elu";te.registerClass(FT);var RT=class extends rn{apply(t){return Ry(t)}};RT.className="selu";te.registerClass(RT);var PT=class extends rn{apply(t){return Jr(t)}};PT.className="relu";te.registerClass(PT);var MT=class extends rn{apply(t){return U(()=>cp(6,Jr(t)))}};MT.className="relu6";te.registerClass(MT);var ET=class extends rn{apply(t){return t}};ET.className="linear";te.registerClass(ET);var _T=class extends rn{apply(t){return _n(t)}};_T.className="sigmoid";te.registerClass(_T);var LT=class extends rn{apply(t){return TP(t)}};LT.className="hardSigmoid";te.registerClass(LT);var $T=class extends rn{apply(t){return uu(t)}};$T.className="softplus";te.registerClass($T);var BT=class extends rn{apply(t){return yP(t)}};BT.className="softsign";te.registerClass(BT);var OT=class extends rn{apply(t){return sp(t)}};OT.className="tanh";te.registerClass(OT);var rd=class extends rn{apply(t,e=-1){return wc(t,e)}};rd.className="softmax";te.registerClass(rd);var zT=class extends rn{apply(t,e=-1){return Ty(t,e)}};zT.className="logSoftmax";te.registerClass(zT);var GT=class extends rn{apply(t,e=1){return U(()=>_(_n(_(t,e)),t))}};GT.className="swish";te.registerClass(GT);var UT=class extends rn{apply(t){return U(()=>_(t,sp(uu(t))))}};UT.className="mish";te.registerClass(UT);function Ja(r){return r.getClassName()}function YA(r,t={}){return wi(r,te.SerializationMap.getMap().classNameMap,t,"activation")}function ei(r){if(r==null){let t={};return t.className="linear",t.config={},YA(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},YA(t)}else return r instanceof rn?r:YA(r)}function ZA(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var WT=class extends te.Serializable{},Ap=class extends WT{constructor(e){super();ZA(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return U(()=>{let n=Ct([1]);return this.hasL1&&(n=Z(n,de(_(this.l1,Wt(e))))),this.hasL2&&(n=Z(n,de(_(this.l2,yl(e))))),$(n,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,n){return new e({l1:n.l1,l2:n.l2})}};Ap.className="L1L2";te.registerClass(Ap);function YE(r){return ZA(r),new Ap({l1:r!=null?r.l1:null,l2:0})}function ZE(r){return ZA(r),new Ap({l2:r!=null?r.l2:null,l1:0})}var jE={l1l2:"L1L2"};function yt(r){return Mc(r)}function XE(r,t={}){return wi(r,te.SerializationMap.getMap().classNameMap,t,"regularizer")}function Dt(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in jE?jE[r]:r,config:{}};return XE(e)}else return r instanceof WT?r:XE(r)}var nd=class extends Ue{constructor(e){super(e??{});this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,n){e=Oe(e);let o=Jr(e);return this.maxValue!=null&&(o=Gr(o,0,this.maxValue)),o}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},n=super.getConfig();return Object.assign(e,n),e}};nd.className="ReLU";te.registerClass(nd);var od=class extends Ue{constructor(e){super(e??{});this.DEFAULT_ALPHA=.3;e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){let o=Oe(e);return Tc(o,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};od.className="LeakyReLU";te.registerClass(od);var sd=class extends Ue{constructor(e){super(e??{});this.DEFAULT_ALPHA_INITIALIZER="zeros";if(e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=kt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Dt(e.alphaRegularizer),this.alphaConstraint=Zt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new O(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=nt(e);let n=e.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)n[s-1]=1;this.alpha=this.addWeight("alpha",n,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let o={};if(this.sharedAxes!=null)for(let s=1;s<e.length;++s)o[s]=e[s];this.inputSpec=[new Nt({ndim:e.length,axes:o})],this.built=!0}call(e,n){return e=Oe(e),Sc(e,this.alpha.read())}getConfig(){let e={alphaInitializer:_t(this.alphaInitializer),alphaRegularizer:yt(this.alphaRegularizer),alphaConstraint:Yt(this.alphaConstraint),sharedAxes:this.sharedAxes},n=super.getConfig();return Object.assign(e,n),e}};sd.className="PReLU";te.registerClass(sd);var ad=class extends Ue{constructor(e){super(e??{});this.DEFAULT_ALPHA=1;if(e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Ne(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,n){let o=Oe(e);return pp(o)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},n=super.getConfig();return Object.assign(e,n),e}};ad.className="ELU";te.registerClass(ad);var id=class extends Ue{constructor(e){super(e??{});this.DEFAULT_THETA=1;e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,n){let o=Oe(e);return _(o,oe(mr(o,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},n=super.getConfig();return Object.assign(e,n),e}};id.className="ThresholdedReLU";te.registerClass(id);var ud=class extends Ue{constructor(e){super(e??{});this.DEFAULT_AXIS=1;e==null&&(e={}),this.softmax=new rd().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,n){let o=Oe(e);return this.softmax(o,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}};ud.className="Softmax";te.registerClass(ud);function wp(r,t,e){if(typeof r=="number")return Bs(r,t);if(r.length!==t)throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let n=0;n<t;++n){let o=r[n];if(!dP(o))throw new O(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function $n(r,t,e,n,o=1){if(r==null)return r;let s=t+(t-1)*(o-1),a;return e==="same"?a=r:a=r-s+1,Math.floor((a+n-1)/n)}function ti(r,t,e,n){if(r==null)return null;if(n==="valid")r=r*t+Ya([e-t,0]);else if(n==="same")r=r*t;else throw new O(`Unsupport padding mode: ${n}.`);return r}function Jh(r,t){return U(()=>(Vt(t),t==="channelsFirst"?Ke(r,[0,2,3,1]):r))}function QA(r,t){return U(()=>(Vt(t),t==="channelsFirst"?Ke(r,[0,2,3,4,1]):r))}function D9(r,t,e,n=1,o="valid",s,a=1){return U(()=>{if(s==null&&(s=yn()),Vt(s),r.shape.length!==3)throw new O(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new O(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new O(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(r=Ke(r,[0,2,1])),o==="causal")throw new Ne("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=py(r,t,n,o==="same"?"same":"valid","NWC",a);return e!=null&&(i=Tn(i,e)),i})}function QE(r,t,e,n=[1,1],o="valid",s,a,i=null){return U(()=>{if(s==null&&(s=yn()),Vt(s),r.rank!==3&&r.rank!==4)throw new O(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new O(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=Jh(r,s);if(o==="causal")throw new Ne("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=fp.conv2d({x:u,filter:t,strides:n,pad:o==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:e,activation:i}),s==="channelsFirst"&&(u=Ke(u,[0,3,1,2])),u})}function F9(r,t,e,n=[1,1,1],o="valid",s,a){return U(()=>{if(s==null&&(s=yn()),Vt(s),r.rank!==4&&r.rank!==5)throw new O(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new O(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let i=QA(r,s);if(o==="causal")throw new Ne("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=my(i,t,n,o==="same"?"same":"valid","NDHWC",a),e!=null&&(i=Tn(i,e)),s==="channelsFirst"&&(i=Ke(i,[0,4,1,2,3])),i})}var Pl=class extends Ue{constructor(e,n){super(n);this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(Pl.verifyArgs(n),this.rank=e,or(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Ne(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=wp(n.kernelSize,e,"kernelSize"),this.strides=wp(n.strides==null?1:n.strides,e,"strides"),this.padding=n.padding==null?"valid":n.padding,bn(this.padding),this.dataFormat=n.dataFormat==null?"channelsLast":n.dataFormat,Vt(this.dataFormat),this.activation=ei(n.activation),this.useBias=n.useBias==null?!0:n.useBias,this.biasInitializer=kt(n.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Zt(n.biasConstraint),this.biasRegularizer=Dt(n.biasRegularizer),this.activityRegularizer=Dt(n.activityRegularizer),this.dilationRate=wp(n.dilationRate==null?1:n.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new O(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new O(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new O(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(rs("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Xy(e.kernelSize,"number",1,3))throw new O(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ja(this.activation),useBias:this.useBias,biasInitializer:_t(this.biasInitializer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),biasConstraint:Yt(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}},Np=class extends Pl{constructor(e,n){super(e,n);this.kernel=null;Np.verifyArgs(n),this.filters=n.filters,or(this.filters,"filters"),this.kernelInitializer=kt(n.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Zt(n.kernelConstraint),this.kernelRegularizer=Dt(n.kernelRegularizer)}build(e){e=nt(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new O(`The channel dimension of the input should be defined. Found ${e[n]}`);let o=e[n],s=this.kernelSize.concat([o,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[n]:o}}],this.built=!0}call(e,n){return U(()=>{e=Oe(e);let o,s=this.bias==null?null:this.bias.read(),a=Yy(this.activation.getClassName());if(a!=null&&this.rank===2)o=QE(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)o=D9(e,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)o=QE(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)o=F9(e,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Ne("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(o=this.activation.apply(o))}return o})}computeOutputShape(e){e=nt(e);let n=[],o=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<o.length;++a){let i=$n(o[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);n.push(i)}let s=[e[0]];return this.dataFormat==="channelsLast"?(s=s.concat(n),s.push(this.filters)):(s.push(this.filters),s=s.concat(n)),s}getConfig(){let e={filters:this.filters,kernelInitializer:_t(this.kernelInitializer),kernelRegularizer:yt(this.kernelRegularizer),kernelConstraint:Yt(this.kernelConstraint)},n=super.getConfig();return Object.assign(e,n),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new O(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},JA=class extends Np{constructor(t){super(2,t),JA.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Xy(t.kernelSize,"number",1,2))throw new O(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}},Fl=JA;Fl.className="Conv2D";te.registerClass(Fl);var ew=class extends Np{constructor(t){super(3,t),ew.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new O(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}},Rl=ew;Rl.className="Conv3D";te.registerClass(Rl);var pd=class extends Fl{constructor(e){super(e);if(this.inputSpec=[new Nt({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=nt(e),e.length!==4)throw new O("Input should have rank 4; Received input shape: "+JSON.stringify(e));let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let o=e[n],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Nt({ndim:4,axes:{[n]:o}})],this.built=!0}call(e,n){return U(()=>{let o=Oe(e);if(o.shape.length!==4)throw new O(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,a=s[0],i,u;this.dataFormat==="channelsFirst"?(i=2,u=3):(i=1,u=2);let p=s[i],l=s[u],m=this.kernelSize[0],c=this.kernelSize[1],d=this.strides[0],f=this.strides[1],h=ti(p,d,m,this.padding),g=ti(l,f,c,this.padding),b=[a,h,g,this.filters];this.dataFormat!=="channelsLast"&&(o=Ke(o,[0,2,3,1]));let T=ly(o,this.kernel.read(),b,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(T=Ke(T,[0,3,1,2])),this.bias!=null&&(T=Tn(T,this.bias.read(),this.dataFormat)),this.activation!=null&&(T=this.activation.apply(T)),T})}computeOutputShape(e){e=nt(e);let n=e.slice(),o,s,a;this.dataFormat==="channelsFirst"?(o=1,s=2,a=3):(o=3,s=1,a=2);let i=this.kernelSize[0],u=this.kernelSize[1],p=this.strides[0],l=this.strides[1];return n[o]=this.filters,n[s]=ti(n[s],p,i,this.padding),n[a]=ti(n[a],l,u,this.padding),n}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};pd.className="Conv2DTranspose";te.registerClass(pd);var ld=class extends Rl{constructor(e){super(e);if(this.inputSpec=[new Nt({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=nt(e),e.length!==5)throw new O("Input should have rank 5; Received input shape: "+JSON.stringify(e));let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let o=e[n],s=this.kernelSize.concat([this.filters,o]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Nt({ndim:5,axes:{[n]:o}})],this.built=!0}call(e,n){return U(()=>{let o=Oe(e);if(o.shape.length!==5)throw new O(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${o.shape.length}`);let s=o.shape,a=s[0],i,u,p;this.dataFormat==="channelsFirst"?(p=2,i=3,u=4):(p=1,i=2,u=3);let l=s[p],m=s[i],c=s[u],d=this.kernelSize[0],f=this.kernelSize[1],h=this.kernelSize[2],g=this.strides[0],b=this.strides[1],T=this.strides[2],x=ti(l,g,d,this.padding),I=ti(m,b,f,this.padding),k=ti(c,T,h,this.padding),w=[a,x,I,k,this.filters];this.dataFormat!=="channelsLast"&&(o=Ke(o,[0,2,3,4,1]));let R=dy(o,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(R=Ke(R,[0,4,1,2,3])),this.bias!==null&&(R=Tn(R,this.bias.read(),this.dataFormat)),this.activation!==null&&(R=this.activation.apply(R)),R})}computeOutputShape(e){e=nt(e);let n=e.slice(),o,s,a,i;this.dataFormat==="channelsFirst"?(o=1,s=2,a=3,i=4):(o=4,s=1,a=2,i=3);let u=this.kernelSize[0],p=this.kernelSize[1],l=this.kernelSize[2],m=this.strides[0],c=this.strides[1],d=this.strides[2];return n[o]=this.filters,n[s]=ti(n[s],m,u,this.padding),n[a]=ti(n[a],c,p,this.padding),n[i]=ti(n[i],d,l,this.padding),n}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};ld.className="Conv3DTranspose";te.registerClass(ld);var KT=class extends Np{constructor(e,n){super(e,n);this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform";this.depthwiseKernel=null;this.pointwiseKernel=null;if(n.filters==null)throw new O("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(n.kernelInitializer!=null||n.kernelRegularizer!=null||n.kernelConstraint!=null)throw new O("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(n.padding!=null&&n.padding!=="same"&&n.padding!=="valid")throw new O(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(n.padding)}`);this.depthMultiplier=n.depthMultiplier==null?1:n.depthMultiplier,this.depthwiseInitializer=kt(n.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Dt(n.depthwiseRegularizer),this.depthwiseConstraint=Zt(n.depthwiseConstraint),this.pointwiseInitializer=kt(n.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Dt(n.pointwiseRegularizer),this.pointwiseConstraint=Zt(n.pointwiseConstraint)}build(e){if(e=nt(e),e.length<this.rank+2)throw new O(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null||e[n]<0)throw new O(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[n])}`);let o=e[n],s=this.kernelSize.concat([o,this.depthMultiplier]),a=[];for(let u=0;u<this.rank;++u)a.push(1);a.push(o*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Nt({ndim:this.rank+2,axes:{[n]:o}})],this.built=!0}call(e,n){return U(()=>{e=Oe(e);let o;if(this.rank===1)throw new Ne("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Ke(e,[0,2,3,1])),o=Py(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(o=Tn(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),this.dataFormat==="channelsFirst"&&(o=Ke(o,[0,3,1,2])),o})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=_t(this.depthwiseInitializer),e.pointwiseInitializer=_t(this.pointwiseInitializer),e.depthwiseRegularizer=yt(this.depthwiseRegularizer),e.pointwiseRegularizer=yt(this.pointwiseRegularizer),e.depthwiseConstraint=Yt(this.depthwiseConstraint),e.pointwiseConstraint=Yt(this.pointwiseConstraint),e}};KT.className="SeparableConv";var md=class extends KT{constructor(t){super(2,t)}};md.className="SeparableConv2D";te.registerClass(md);var tw=class extends Np{constructor(t){super(1,t),tw.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!Xy(t.kernelSize,"number",1,1))throw new O(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}},cd=tw;cd.className="Conv1D";te.registerClass(cd);var dd=class extends Ue{constructor(e){super(e);typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,n){return U(()=>{if(e=Oe(e),this.dataFormat==="channelsLast"){let o=Uh(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Uh(o,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let o=Uh(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Uh(o,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}};dd.className="Cropping2D";te.registerClass(dd);var fd=class extends Ue{constructor(e){super(e);this.DEFAULT_SIZE=[2,2];this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,mP(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let n=e[2]==null?null:this.size[0]*e[2],o=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],n,o]}else{let n=e[1]==null?null:this.size[0]*e[1],o=e[2]==null?null:this.size[1]*e[2];return[e[0],n,o,e[3]]}}call(e,n){return U(()=>{let o=Oe(e),s=o.shape;if(this.dataFormat==="channelsFirst"){o=Ke(o,[0,2,3,1]);let a=this.size[0]*s[2],i=this.size[1]*s[3],u=this.interpolation==="nearest"?hp.resizeNearestNeighbor(o,[a,i]):hp.resizeBilinear(o,[a,i]);return Ke(u,[0,3,1,2])}else{let a=this.size[0]*s[1],i=this.size[1]*s[2];return this.interpolation==="nearest"?hp.resizeNearestNeighbor(o,[a,i]):hp.resizeBilinear(o,[a,i])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},n=super.getConfig();return Object.assign(e,n),e}};fd.className="UpSampling2D";te.registerClass(fd);function R9(r,t,e=[1,1],n="valid",o,s){return U(()=>{o==null&&(o=yn()),Vt(o);let a=Jh(r,o);if(r.rank!==4)throw new O(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new O(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=up(a,t,e,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(a=Ke(a,[0,3,1,2])),a})}var hd=class extends Pl{constructor(e){super(2,e);this.depthwiseKernel=null;this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=kt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Zt(e.depthwiseConstraint),this.depthwiseRegularizer=Dt(e.depthwiseRegularizer)}build(e){if(e=nt(e),e.length<4)throw new O(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let n=this.dataFormat==="channelsFirst"?1:3;if(e[n]==null||e[n]<0)throw new O(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[n]}).`);let o=e[n],s=[this.kernelSize[0],this.kernelSize[1],o,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[o*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return U(()=>{e=Oe(e);let o=R9(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(o=Tn(o,this.bias.read(),this.dataFormat)),this.activation!=null&&(o=this.activation.apply(o)),o})}computeOutputShape(e){e=nt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],o=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=$n(n,this.kernelSize[0],this.padding,this.strides[0]),i=$n(o,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],s,a,i]:[e[0],a,i,s]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=_t(this.depthwiseInitializer),e.depthwiseRegularizer=yt(this.depthwiseRegularizer),e.depthwiseConstraint=Yt(this.depthwiseRegularizer),e}};hd.className="DepthwiseConv2D";te.registerClass(hd);function rw(r,t,e,n){if(Array.isArray(r)){if(t!=null||e!=null)throw new O("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return t=o(t),e=o(e),{inputs:r,initialState:t,constants:e}}function nw(r,t,e,n=!1,o,s,a=!1,i=!1){return U(()=>{let u=t.shape.length;if(u<3)throw new O(`Input should be at least 3D, but is ${u}D.`);let p=[1,0].concat(en(2,u));if(t=Ke(t,p),s!=null)throw new Ne("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=oe(oe(o,"bool"),"float32"),o.rank===u-1&&(o=_r(o,-1)),o=Ke(o,p)),n&&(t=Dr(t,0),o!=null&&(o=Dr(o,0)));let l=[],m,c=e,d=t.shape[0],f=Wr(t),h;o!=null&&(h=Wr(o));for(let b=0;b<d;++b){let T=f[b],x=U(()=>r(T,c));if(o==null)m=x[0],c=x[1];else{let I=U(()=>{let k=h[b],w=le(Lr(k),k),R=Z(_(x[0],k),_(c[0],w)),P=c.map((M,L)=>Z(_(x[1][L],k),_(M,w)));return{output:R,newStates:P}});m=I.output,c=I.newStates}i&&l.push(m)}let g;return i&&(g=Tr(l,1)),[m,g,c]})}var ow=class extends Ue{constructor(e){super(e);let n;if(e.cell==null)throw new O("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?n=new _l({cells:e.cell}):n=e.cell,n.stateSize==null)throw new O("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=n,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Nt({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return en(0,e).map(n=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){sT(e)&&(e=e[0]),e=e;let n=this.cell.stateSize;Array.isArray(n)||(n=[n]);let o=n[0],s;if(this.returnSequences?s=[e[0],e[1],o]:s=[e[0],o],this.returnState){let a=[];for(let i of n)a.push([e[0],i]);return[s].concat(a)}else return s}computeMask(e,n){return U(()=>{Array.isArray(n)&&(n=n[0]);let o=this.returnSequences?n:null;if(this.returnState){let s=this.states.map(a=>null);return[o].concat(s)}else return o})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,n=[];for(let o=0;o<e;++o)n.push(null);return n}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Ne("Constants support is not implemented in RNN yet.");sT(e)&&(e=e[0]),e=e;let o=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new Nt({shape:[o,null,...s]});let a=[e[0]].concat(e.slice(2));this.cell.build(a);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!y.arraysEqual(this.stateSpec.map(u=>u.shape[u.shape.length-1]),i))throw new O(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(u=>new Nt({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(e,n=!1){U(()=>{if(!this.stateful)throw new Ln("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape[0];if(o==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Ct([o,s])):this.states_=[Ct([o,this.cell.stateSize])];else if(e==null)Pe(this.states_),this.keptStates!=null&&(Pe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>Ct([o,s])):this.states_[0]=Ct([o,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n===!0?this.keptStates.push(this.states_.slice()):Pe(this.states_);for(let s=0;s<this.states_.length;++s){let a=e[s],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,u=[o,i];if(!y.arraysEqual(a.shape,u))throw new O(`State ${s} is incompatible with layer ${this.name}: expected shape=${u}, received shape=${a.shape}`);this.states_[s]=a}}this.states_=this.states_.map(s=>Ut(s.clone()))})}apply(e,n){let o=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let a=rw(e,o,s,this.numConstants);e=a.inputs,o=a.initialState,s=a.constants;let i=[],u=[];if(o!=null){n.initialState=o,i=i.concat(o),this.stateSpec=[];for(let l of o)this.stateSpec.push(new Nt({shape:l.shape}));u=u.concat(this.stateSpec)}if(s!=null&&(n.constants=s,i=i.concat(s),this.numConstants=s.length),i[0]instanceof tn){let l=[e].concat(i),m=this.inputSpec.concat(u),c=this.inputSpec;this.inputSpec=m;let d=super.apply(l,n);return this.inputSpec=c,d}else return super.apply(e,n)}call(e,n){return U(()=>{let o=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;e=Oe(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==i)throw new O(`RNN Layer has ${i} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let u={training:s},l=nw((h,g)=>{let b=this.cell.call([h].concat(g),u);return[b[0],b.slice(1)]},e,a,this.goBackwards,o,null,this.unroll,this.returnSequences),m=l[0],c=l[1],d=l[2];this.stateful&&this.resetStates(d,s);let f=this.returnSequences?c:m;return this.returnState?[f].concat(d):f})}getInitialState(e){return U(()=>{let n=Ct(e.shape);return n=de(n,[1,2]),n=cu(n),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(o=>o>1?rT(n,[1,o]):n):this.cell.stateSize>1?[rT(n,[1,this.cell.stateSize])]:[n]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),n={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(n.numConstants=this.numConstants);let o=this.cell.getConfig();return this.getClassName()===ow.className&&(n.cell={className:this.cell.getClassName(),config:o}),{...o,...e,...n}}static fromConfig(e,n,o={}){let s=n.cell,a=Cn(s,o);return new e(Object.assign(n,{cell:a}))}},ns=ow;ns.className="RNN";te.registerClass(ns);var gu=class extends Ue{},Ml=class extends gu{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=e.units,or(this.units,"units"),this.activation=ei(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Dt(e.kernelRegularizer),this.recurrentRegularizer=Dt(e.recurrentRegularizer),this.biasRegularizer=Dt(e.biasRegularizer),this.kernelConstraint=Zt(e.kernelConstraint),this.recurrentConstraint=Zt(e.recurrentConstraint),this.biasConstraint=Zt(e.biasConstraint),this.dropout=gl([1,Ya([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gl([1,Ya([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=nt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return U(()=>{if(e=e,e.length!==2)throw new O(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let o=e[1];e=e[0];let s=n.training==null?!1:n.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bu({ones:()=>Lr(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bu({ones:()=>Lr(o),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));let a,i=this.dropoutMask,u=this.recurrentDropoutMask;i!=null?a=Us(_(e,i),this.kernel.read()):a=Us(e,this.kernel.read()),this.bias!=null&&(a=Tn(a,this.bias.read())),u!=null&&(o=_(o,u));let p=Z(a,Us(o,this.recurrentKernel.read()));return this.activation!=null&&(p=this.activation.apply(p)),[p,p]})}getConfig(){let e=super.getConfig(),n={units:this.units,activation:Ja(this.activation),useBias:this.useBias,kernelInitializer:_t(this.kernelInitializer),recurrentInitializer:_t(this.recurrentInitializer),biasInitializer:_t(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),recurrentConstraint:Yt(this.recurrentConstraint),biasConstraint:Yt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return{...e,...n}}};Ml.className="SimpleRNNCell";te.registerClass(Ml);var gd=class extends ns{constructor(t){t.cell=new Ml(t),super(t)}call(t,e){return U(()=>{this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return new t(e)}};gd.className="SimpleRNN";te.registerClass(gd);var El=class extends gu{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(e.resetAfter)throw new O("GRUCell does not support reset_after parameter set to true.");this.units=e.units,or(this.units,"units"),this.activation=ei(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ei(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Dt(e.kernelRegularizer),this.recurrentRegularizer=Dt(e.recurrentRegularizer),this.biasRegularizer=Dt(e.biasRegularizer),this.kernelConstraint=Zt(e.kernelConstraint),this.recurrentConstraint=Zt(e.recurrentConstraint),this.biasConstraint=Zt(e.biasConstraint),this.dropout=gl([1,Ya([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gl([1,Ya([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=nt(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,n){return U(()=>{if(e=e,e.length!==2)throw new O(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let o=n.training==null?!1:n.training,s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bu({ones:()=>Lr(e),rate:this.dropout,training:o,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bu({ones:()=>Lr(s),rate:this.recurrentDropout,training:o,count:3,dropoutFunc:this.dropoutFunc}));let a=this.dropoutMask,i=this.recurrentDropoutMask,u,p,l;0<this.dropout&&this.dropout<1&&(e=_(e,a[0]));let m=Us(e,this.kernel.read());this.useBias&&(m=Tn(m,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=_(s,i[0]));let c=this.recurrentKernel.read(),[d,f]=Fr(c,[2*this.units,this.units],c.rank-1),h=Us(s,d),[g,b,T]=Fr(m,3,m.rank-1),[x,I]=Fr(h,2,h.rank-1);u=this.recurrentActivation.apply(Z(g,x)),p=this.recurrentActivation.apply(Z(b,I));let k=Us(_(p,s),f);l=this.activation.apply(Z(T,k));let w=Z(_(u,s),_(Z(1,et(u)),l));return[w,w]})}getConfig(){let e=super.getConfig(),n={units:this.units,activation:Ja(this.activation),recurrentActivation:Ja(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_t(this.kernelInitializer),recurrentInitializer:_t(this.recurrentInitializer),biasInitializer:_t(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),recurrentConstraint:Yt(this.recurrentConstraint),biasConstraint:Yt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return{...e,...n}}};El.className="GRUCell";te.registerClass(El);var bd=class extends ns{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new El(t),super(t)}call(t,e){return U(()=>{this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};bd.className="GRU";te.registerClass(bd);var hu=class extends gu{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=e.units,or(this.units,"units"),this.activation=ei(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=ei(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Dt(e.kernelRegularizer),this.recurrentRegularizer=Dt(e.recurrentRegularizer),this.biasRegularizer=Dt(e.biasRegularizer),this.kernelConstraint=Zt(e.kernelConstraint),this.recurrentConstraint=Zt(e.recurrentConstraint),this.biasConstraint=Zt(e.biasConstraint),this.dropout=gl([1,Ya([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=gl([1,Ya([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var s;e=nt(e);let n=e[e.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){let a=this.biasInitializer,i=this.units;o=new(s=class extends In{apply(p,l){let m=a.apply([i]),c=new Sp().apply([i]),d=a.apply([i*2]);return _A(_A(m,c),d)}},s.className="CustomInit",s)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,n){return U(()=>{let o=n.training==null?!1:n.training;if(e=e,e.length!==3)throw new O(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1],a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bu({ones:()=>Lr(e),rate:this.dropout,training:o,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bu({ones:()=>Lr(s),rate:this.recurrentDropout,training:o,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,u=this.recurrentDropoutMask,p,l,m,c;0<this.dropout&&this.dropout<1&&(e=_(e,i[0]));let d=Us(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=_(s,u[0])),d=Z(d,Us(s,this.recurrentKernel.read())),this.useBias&&(d=Tn(d,this.bias.read()));let[f,h,g,b]=Fr(d,4,d.rank-1);p=this.recurrentActivation.apply(f),l=this.recurrentActivation.apply(h),m=Z(_(l,a),_(p,this.activation.apply(g))),c=this.recurrentActivation.apply(b);let T=_(c,this.activation.apply(m));return[T,T,m]})}getConfig(){let e=super.getConfig(),n={units:this.units,activation:Ja(this.activation),recurrentActivation:Ja(this.recurrentActivation),useBias:this.useBias,kernelInitializer:_t(this.kernelInitializer),recurrentInitializer:_t(this.recurrentInitializer),biasInitializer:_t(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:yt(this.kernelRegularizer),recurrentRegularizer:yt(this.recurrentRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),recurrentConstraint:Yt(this.recurrentConstraint),biasConstraint:Yt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return{...e,...n}}};hu.className="LSTMCell";te.registerClass(hu);var yd=class extends ns{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new hu(t),super(t)}call(t,e){return U(()=>{this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,o=e==null?null:e.training,s=e==null?null:e.initialState;return super.call(t,{mask:n,training:o,initialState:s})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};yd.className="LSTM";te.registerClass(yd);var _l=class extends gu{constructor(e){super(e);this.cells=e.cells}get stateSize(){let e=[];for(let n of this.cells.slice().reverse())Array.isArray(n.stateSize)?e.push(...n.stateSize):e.push(n.stateSize);return e}call(e,n){return U(()=>{e=e;let o=e.slice(1),s=[];for(let u of this.cells.slice().reverse())Array.isArray(u.stateSize)?s.push(o.splice(0,u.stateSize.length)):s.push(o.splice(0,1));s.reverse();let a=[],i;for(let u=0;u<this.cells.length;++u){let p=this.cells[u];o=s[u],u===0?i=[e[0]].concat(o):i=[i[0]].concat(o),i=p.call(i,n),a.push(i.slice(1))}o=[];for(let u of a.slice().reverse())o.push(...u);return[i[0]].concat(o)})}build(e){sT(e)&&(e=e[0]),e=e;let n;this.cells.forEach((o,s)=>{Xa(`RNNCell_${s}`,()=>{o.build(e),Array.isArray(o.stateSize)?n=o.stateSize[0]:n=o.stateSize,e=[e[0],n]})}),this.built=!0}getConfig(){let e=super.getConfig(),n=a=>({className:a.getClassName(),config:a.getConfig()}),s={cells:this.cells.map(n)};return{...e,...s}}static fromConfig(e,n,o={}){let s=[];for(let a of n.cells)s.push(Cn(a,o));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let n of this.cells)e.push(...n.nonTrainableWeights);if(!this.trainable){let n=[];for(let o of this.cells)n.push(...o.trainableWeights);return n.concat(e)}return e}getWeights(){let e=[];for(let n of this.cells)e.push(...n.weights);return Kh(e)}setWeights(e){let n=[];for(let o of this.cells){let s=o.weights.length,a=e.splice(s);for(let i=0;i<o.weights.length;++i)n.push([o.weights[i],a[i]])}Hc(n)}};_l.className="StackedRNNCells";te.registerClass(_l);function bu(r){let{ones:t,rate:e,training:n=!1,count:o=1,dropoutFunc:s}=r,a=()=>s!=null?s(t(),e):oT(t(),e),i=()=>kp(a,t,n);return!o||o<=1?Ut(i().clone()):Array(o).fill(void 0).map(i).map(p=>Ut(p.clone()))}var VT=class extends ns{constructor(e){if(e.unroll)throw new Ne("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ne("It is not possible at the moment to stack convolutional cells.");super(e);this.inputSpec=[new Nt({ndim:5})]}call(e,n){return U(()=>{if(this.cell.dropoutMask!=null&&(Pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),n&&n.constants)throw new O("ConvRNN2D cell does not support constants");let o=n==null?null:n.mask,s=n==null?null:n.training,a=n==null?null:n.initialState;return super.call(e,{mask:o,training:s,initialState:a})})}computeOutputShape(e){let n=this.computeSingleOutputShape(e);return this.returnSequences||(n=[n[0],...n.slice(2)]),this.returnState&&(n=[n,...Array(2).fill([e[0],...n.slice(-3)])]),n}getInitialState(e){return U(()=>{let{stateSize:n}=this.cell,o=e.shape,s=this.computeSingleOutputShape(o),a=[s[0],...s.slice(2)],i=Ct(a);return Array.isArray(n)?Array(n.length).fill(i):[i]})}resetStates(e,n=!1){U(()=>{if(!this.stateful)throw new Ln("Cannot call resetStates() on an RNN Layer that is not stateful.");let o=this.inputSpec[0].shape,s=this.computeSingleOutputShape(o),a=[s[0],...s.slice(2)];if(o[0]==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(a)):this.states_=[Ct(a)];else if(e==null)Pe(this.states_),this.keptStates!=null&&(Pe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ct(a)):this.states_[0]=Ct(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);n?this.keptStates.push(this.states_.slice()):Pe(this.states_);for(let u=0;u<this.states_.length;++u){let p=e[u],l=a;if(!y.arraysEqual(p.shape,l))throw new O(`State ${u} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${p.shape}`);this.states_[u]=p}}this.states_=this.states_.map(u=>Ut(u.clone()))})}computeSingleOutputShape(e){let{dataFormat:n,filters:o,kernelSize:s,padding:a,strides:i,dilationRate:u}=this.cell,p=n==="channelsFirst",l=e[p?3:2],m=e[p?4:3],c=$n(l,s[0],a,i[0],u[0]),d=$n(m,s[1],a,i[1],u[1]);return[...e.slice(0,2),...p?[o,c,d]:[c,d,o]]}};VT.className="ConvRNN2D";var Ll=class extends hu{constructor(e){let{filters:n,kernelSize:o,strides:s,padding:a,dataFormat:i,dilationRate:u}=e;super({...e,units:n});this.filters=n,or(this.filters,"filters"),this.kernelSize=wp(o,2,"kernelSize"),this.kernelSize.forEach(p=>or(p,"kernelSize")),this.strides=wp(s||1,2,"strides"),this.strides.forEach(p=>or(p,"strides")),this.padding=a||"valid",bn(this.padding),this.dataFormat=i||"channelsLast",Vt(this.dataFormat),this.dilationRate=wp(u||1,2,"dilationRate"),this.dilationRate.forEach(p=>or(p,"dilationRate"))}build(e){var u;e=nt(e);let n=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[n]==null)throw new O(`The channel dimension of the input should be defined. Found ${e[n]}`);let o=e[n],s=4,a=this.kernelSize.concat([o,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let p;if(this.unitForgetBias){let l=this.biasInitializer,m=this.filters;p=new(u=class extends In{apply(d,f){let h=l.apply([m]),g=yr([m]),b=l.apply([m*2]);return _c([h,g,b])}},u.className="CustomInit",u)}else p=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,p,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,n){return U(()=>{if(e.length!==3)throw new O(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=n.training||!1,s=e[0],a=e[1],i=e[2],u=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=bu({ones:()=>Lr(s),rate:this.dropout,training:o,count:u,dropoutFunc:this.dropoutFunc}));let p=this.dropoutMask,l=(ie,pe,ae)=>!pe||!pe[ae]?ie:_(pe[ae],ie),m=l(s,p,0),c=l(s,p,1),d=l(s,p,2),f=l(s,p,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=bu({ones:()=>Lr(a),rate:this.recurrentDropout,training:o,count:u,dropoutFunc:this.dropoutFunc}));let h=this.recurrentDropoutMask,g=l(a,h,0),b=l(a,h,1),T=l(a,h,2),x=l(a,h,3),I=3,[k,w,R,P]=Fr(this.kernel.read(),u,I),[M,L,z,W]=this.useBias?Fr(this.bias.read(),u):[null,null,null,null];m=this.inputConv(m,k,M,this.padding),c=this.inputConv(c,w,L,this.padding),d=this.inputConv(d,R,z,this.padding),f=this.inputConv(f,P,W,this.padding);let[V,j,H,X]=Fr(this.recurrentKernel.read(),u,I);g=this.recurrentConv(g,V),b=this.recurrentConv(b,j),T=this.recurrentConv(T,H),x=this.recurrentConv(x,X);let ee=this.recurrentActivation.apply(Z(m,g)),q=this.recurrentActivation.apply(Z(c,b)),ne=Z(_(q,i),_(ee,this.activation.apply(Z(d,T)))),se=_(this.recurrentActivation.apply(Z(f,x)),this.activation.apply(ne));return[se,se,ne]})}getConfig(){let{units:e,...n}=super.getConfig(),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return{...n,...o}}inputConv(e,n,o,s){let a=es(e,n,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return o?Tn(a,o,this.dataFormat):a}recurrentConv(e,n){return es(e,n,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Ll.className="ConvLSTM2DCell";te.registerClass(Ll);var Td=class extends VT{constructor(t){let e=new Ll(t);super({...t,cell:e})}static fromConfig(t,e){return new t(e)}};Td.className="ConvLSTM2D";te.registerClass(Td);var $l=class extends Ue{constructor(e){super(e);this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let n=e.shape,o=[];for(let s=0;s<this.noiseShape.length;++s)o.push(this.noiseShape[s]==null?n[s]:this.noiseShape[s]);return o}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e);if(0<this.rate&&this.rate<1){let s=n.training==null?!1:n.training,a=this.getNoiseShape(o);return kp(()=>oT(o,this.rate,a,this.seed),()=>o,s)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},n=super.getConfig();return Object.assign(e,n),e}dispose(){return super.dispose()}};$l.className="Dropout";te.registerClass($l);var xd=class extends $l{constructor(t){super(t),this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};xd.className="SpatialDropout1D";te.registerClass(xd);var Id=class extends Ue{constructor(e){super(e);this.activation=null;this.useBias=!0;this.kernel=null;this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let n=null;e.batchSize!=null&&(n=e.batchSize),this.batchInputShape=[n,e.inputDim]}this.units=e.units,or(this.units,"units"),this.activation=ei(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Zt(e.kernelConstraint),this.biasConstraint=Zt(e.biasConstraint),this.kernelRegularizer=Dt(e.kernelRegularizer),this.biasRegularizer=Dt(e.biasRegularizer),this.activityRegularizer=Dt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=nt(e);let n=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[n,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:n}}],this.built=!0}computeOutputShape(e){e=nt(e);let n=e.slice();return n[n.length-1]=this.units,n}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e),s=Yy(this.activation.getClassName()),a;return s!=null?a=Us(o,this.kernel.read(),s,this.bias?this.bias.read():null):(a=Us(o,this.kernel.read()),this.bias!=null&&(a=Tn(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){let e={units:this.units,activation:Ja(this.activation),useBias:this.useBias,kernelInitializer:_t(this.kernelInitializer),biasInitializer:_t(this.biasInitializer),kernelRegularizer:yt(this.kernelRegularizer),biasRegularizer:yt(this.biasRegularizer),activityRegularizer:yt(this.activityRegularizer),kernelConstraint:Yt(this.kernelConstraint),biasConstraint:Yt(this.biasConstraint)},n=super.getConfig();return Object.assign(e,n),e}};Id.className="Dense";te.registerClass(Id);var Cd=class extends Ue{constructor(e){e=e||{};super(e);this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=nt(e);for(let n of e.slice(1))if(n==null)throw new O(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Gs(e,1)]}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e);if(this.dataFormat==="channelsFirst"&&o.rank>1){let s=[0];for(let a=2;a<o.rank;++a)s.push(a);s.push(1),o=Ke(o,s)}return gP(o)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let n=super.getConfig();return Object.assign(e,n),e}};Cd.className="Flatten";te.registerClass(Cd);var kd=class extends Ue{constructor(e){super(e);this.supportsMasking=!0,this.activation=ei(e.activation)}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e);return this.activation.apply(o)})}getConfig(){let e={activation:Ja(this.activation)},n=super.getConfig();return Object.assign(e,n),e}};kd.className="Activation";te.registerClass(kd);var Sd=class extends Ue{constructor(e){super(e);this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,n){return U(()=>(e=Oe(e),fP(e,this.n)))}getConfig(){let e={n:this.n},n=super.getConfig();return Object.assign(e,n),e}};Sd.className="RepeatVector";te.registerClass(Sd);var vd=class extends Ue{constructor(e){super(e);this.targetShape=e.targetShape;for(let n=0;n<this.targetShape.length;++n)this.isUnknown(this.targetShape[n])&&(this.targetShape[n]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,n){let o="Total size of new array must be unchanged.",s=n.slice(),a=1,i=null;for(let p=0;p<s.length;++p){let l=s[p];if(this.isUnknown(l))if(i===null)i=p;else throw new O("Can only specifiy one unknown dimension.");else a*=l}let u=Gs(e);if(i!==null){if(a===0||u%a!==0)throw new O(o);s[i]=u/a}else if(u!==a)throw new O(o);return s}computeOutputShape(e){let n=!1;for(let o=0;o<e.length;++o)if(this.isUnknown(e[o])){n=!0;break}return n?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e),s=o.shape,a=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return $(o,a)})}getConfig(){let e={targetShape:this.targetShape},n=super.getConfig();return Object.assign(e,n),e}};vd.className="Reshape";te.registerClass(vd);var Ad=class extends Ue{constructor(e){super(e);if(e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let n=en(1,e.dims.length+1);if(!y.arraysEqual(e.dims.slice().sort(),n))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Nt({ndim:this.dims.length+1})]}computeOutputShape(e){e=nt(e);let n=e.slice();return this.dims.forEach((o,s)=>{n[s+1]=e[o]}),n}call(e,n){return Ke(Oe(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},n=super.getConfig();return Object.assign(e,n),e}};Ad.className="Permute";te.registerClass(Ad);var wd=class extends Ue{constructor(e){super(e??{});this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={maskValue:this.maskValue};return Object.assign(n,e),n}computeMask(e,n){let o=Oe(e),s=-1;return Fh(pu(o,this.maskValue),s)}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e),s=-1,a=!0,i=Fh(pu(o,this.maskValue),s,a);return _(o,oe(i,o.dtype))})}};wd.className="Masking";te.registerClass(wd);var Nd=class extends Ue{constructor(e){super(e);this.embeddings=null;this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform";if(e.batchInputShape==null&&e.inputShape==null){let n=null;e.batchSize!=null&&(n=e.batchSize),e.inputLength==null?this.batchInputShape=[n,null]:this.batchInputShape=[n].concat(wt(e.inputLength))}this.inputDim=e.inputDim,or(this.inputDim,"inputDim"),this.outputDim=e.outputDim,or(this.outputDim,"outputDim"),this.embeddingsInitializer=kt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Dt(e.embeddingsRegularizer),this.activityRegularizer=Dt(e.activityRegularizer),this.embeddingsConstraint=Zt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,n){return U(()=>this.maskZero?(e=Oe(e),pu(e,Fe(e))):null)}computeOutputShape(e){if(e=nt(e),this.inputLength==null)return[...e,this.outputDim];let n=wt(this.inputLength);if(n.length!==e.length-1)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let o=0;for(let s=0;s<n.length;++s){let a=n[s],i=e[s+1];if(a!=null&&i!=null&&a!==i)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(n[o]=i),o++}}return[e[0],...n,this.outputDim]}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e);o.dtype!=="int32"&&(o=bl(o,"int32"));let s=nT(this.embeddings.read(),$(o,[o.size]));return $(s,nt(this.computeOutputShape(o.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:_t(this.embeddingsInitializer),embeddingsRegularizer:yt(this.embeddingsRegularizer),activityRegularizer:yt(this.activityRegularizer),embeddingsConstraint:Yt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},n=super.getConfig();return Object.assign(e,n),e}};Nd.className="Embedding";te.registerClass(Nd);var yu=class extends Ue{constructor(e){super(e||{});this.supportsMasking=!0}mergeFunction(e){throw new Ne}computeElementwiseOpOutputShape(e,n){if(e==null||n==null)return null;if(e.length<n.length)return this.computeElementwiseOpOutputShape(n,e);if(n.length===0)return e;let o=e.slice(0,e.length-n.length);for(let s=0;s<n.length;++s){let a=e[e.length-n.length+s],i=n[s];if(a==null||i==null||a<0||i<0)o.push(null);else if(a===1)o.push(i);else if(i===1)o.push(a);else{if(a!==i)throw new O("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(n));o.push(a)}}return o}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[nt(e)]),e=e,e.length<2)throw new O(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let n=[];for(let a of e)a!=null&&a[0]!==null&&n.push(a[0]);if(n=zs(n),n.length>1)throw new O(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let o=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){let i=e[a]==null?null:e[a].slice(1);o=this.computeElementwiseOpOutputShape(o,i)}let s=e.map(a=>a.length);e.indexOf(null)===-1&&zs(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,n){return U(()=>{if(e=e,this.reshapeRequired){let o=[],s=e.map(a=>a.rank);if(s.indexOf(null)===-1){let a=Ya(s);for(let i of e){let u=i.rank;for(let p=0;p<a-u;++p)i=cu(i,1);o.push(i)}return this.mergeFunction(o)}else{let a=!1;for(let p of e){let l=p.rank;if(l==null){let m=p.shape,c=m[0],d=m.slice(1).concat([c]),f=$(p,[c].concat(Gs(m.slice(1))));f=Ke(f,[1,0]),f=$(f,d),o.push(f),a=!0}else if(l>1){let m=en(1,l).concat([0]);o.push(Ke(p,m)),a=!0}else o.push(p)}let i=this.mergeFunction(o),u=i.rank;if(a){if(u==null){let p=i.shape,l=p.length,m=p[l-1],c=[m].concat(p.slice(0,p.length-1));i=$(Ke($(i,[-1,m]),[1,0]),c)}else if(u>1){let p=[u-1].concat(en(0,u-1));i=Ke(i,p)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let n;e[0]==null?n=null:n=e[0].slice(1);for(let s=1;s<e.length;++s){let a=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let o=[];for(let s of e)s!=null&&s[0]!==null&&o.push(s[0]);return o=zs(o),o.length===1?n=o.concat(n):n=[null].concat(n),n}computeMask(e,n){return U(()=>{if(n==null)return null;if(!Array.isArray(n))throw new O("`mask` should be an Array");if(!Array.isArray(e))throw new O("`inputs` should be an Array");if(n.length!==e.length)throw new O(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${n.length})`);if(n.every(s=>s==null))return null;n=n.map(s=>s==null?s:_r(s,0));let o=n[0];for(let s=1;s<n.length-1;++s)o=Qr(o,n[s]);return o})}},Dd=class extends yu{constructor(t){super(t)}mergeFunction(t){return U(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Z(e,t[n]);return e})}};Dd.className="Add";te.registerClass(Dd);var Fd=class extends yu{constructor(t){super(t)}mergeFunction(t){return U(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=_(e,t[n]);return e})}};Fd.className="Multiply";te.registerClass(Fd);var Rd=class extends yu{constructor(t){super(t)}mergeFunction(t){return U(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Z(e,t[n]);return _(1/t.length,e)})}};Rd.className="Average";te.registerClass(Rd);var Pd=class extends yu{constructor(t){super(t)}mergeFunction(t){return U(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=ts(e,t[n]);return e})}};Pd.className="Maximum";te.registerClass(Pd);var Md=class extends yu{constructor(t){super(t)}mergeFunction(t){return U(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=cp(e,t[n]);return e})}};Md.className="Minimum";te.registerClass(Md);var Ed=class extends yu{constructor(e){super(e);this.DEFAULT_AXIS=-1;e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new O("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let n=!0;for(let s of e)if(s!=null){n=!1;break}if(n)return;let o=[];for(let s=0;s<e.length;++s){let a=e[s].slice();a.splice(this.axis,1);let i=!1;for(let u of o)if(y.arraysEqual(u,a)){i=!0;break}i||o.push(a)}if(o.length>1)throw new O("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return U(()=>_c(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new O("A `Concatenate` layer should be called on a list of inputs.");let n=e,o=n[0].slice(),s=this.axis<0?o.length+this.axis:this.axis;for(let a of n.slice(1)){if(o[s]==null||a[s]==null){o[s]=null;break}o[s]+=a[s]}return o}computeMask(e,n){if(n==null)return null;if(!Array.isArray(n))throw new O("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new O("`inputs` should be an array for Concatenate");if(n.length!==e.length)throw new O(`Mismatch in the length of mask (${n.length}) and the legnth of inputs (${e.length})`);return U(()=>{let o=!0;if(n.forEach(i=>{if(i!=null){o=!1;return}}),o)return null;let s=[];for(let i=0;i<e.length;++i)n[i]==null?s.push(oe(Lr(e[i]),"bool")):n[i].rank<e[i].rank?s.push(_r(n[i],-1)):s.push(n[i]);let a=ct(s,this.axis);return Qb(a,-1,!1)})}getConfig(){let e={axis:this.axis},n=super.getConfig();return Object.assign(e,n),e}};Ed.className="Concatenate";te.registerClass(Ed);function eg(r,t){for(;r<0;)r+=t;return r}function P9(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new Ne("batchDot is not implemented for tensors of 4D or higher rank yet");if(y.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),y.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new Ne("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=t.shape.length;e==null&&(e=[n-1,o-2]);let s=e;return U(()=>{let a;if(n>o){a=n-o;let u=[];for(let p=0;p<a;++p)u.push(1);t=$(t,t.shape.concat(u))}else if(o>n){a=o-n;let u=[];for(let p=0;p<a;++p)u.push(1);r=$(r,r.shape.concat(u))}else a=0;let i;if(r.shape.length===2&&t.shape.length===2)s[0]===s[1]?i=de(_(r,t),s[0]):i=de(_(Ke(r,[1,0]),t),s[1]);else{let u=s[0]!==r.shape.length-1,p=s[1]===t.shape.length-1;i=je(r,t,u,p)}if(a>0){let u;n>o?u=n+o-3:u=n-1;let p=[];for(let l=u;l<u+a;++l)p.push(l);i=_s(i,p)}return i.shape.length===1&&(i=_r(i,1)),i})}var _d=class extends yu{constructor(e){super(e);this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=e[0],o=e[1];if(n.length>3||o.length>3)throw new Ne("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(n,o);if(n[s[0]]!==o[s[1]])throw new O(`Dimension incompatibility: ${n[s[0]]} !== ${o[s[1]]}`)}mergeFunction(e){if(e.length!==2)throw new O(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let n=e[0],o=e[1],s;return Array.isArray(this.axes)?s=this.axes.map((a,i)=>eg(a,e[i].shape.length)):s=[eg(this.axes,n.shape.length),eg(this.axes,o.shape.length)],this.normalize&&(n=Vh(n,s[0]),o=Vh(o,s[1])),P9(n,o,s)}interpretAxes(e,n){let o;return Array.isArray(this.axes)?o=this.axes:o=[eg(this.axes,e.length),eg(this.axes,n.length)],o}computeOutputShape(e){y.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let n=e[0].slice(),o=e[1].slice();if(n.length>3||o.length>3)throw new Ne("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(n,o);n.splice(s[0],1),o.splice(s[1],1),o.splice(0,1);let a=n.concat(o);return a.length===1&&a.push(1),a}computeMask(e,n){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},n=super.getConfig();return Object.assign(e,n),e}};_d.className="Dot";te.registerClass(_d);var Ld=class extends Ue{constructor(e){super(e);this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={stddev:this.stddev};return Object.assign(n,e),n}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e);return kp(()=>Z(Lc(o.shape,0,this.stddev),o),()=>o,n.training||!1)})}};Ld.className="GaussianNoise";te.registerClass(Ld);var $d=class extends Ue{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return U(()=>{this.invokeCallHook(e,n);let o=Oe(e);return this.rate>0&&this.rate<1?kp(()=>{let a=Math.sqrt(this.rate/(1-this.rate));return _(o,Lc(o.shape,1,a))},()=>o,n.training||!1):o})}};$d.className="GaussianDropout";te.registerClass($d);var Bd=class extends Ue{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Oe(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),n={rate:this.rate};return Object.assign(n,e),n}call(e,n){return U(()=>{if(this.rate<1&&this.rate>0){let o=this._getNoiseShape(e);return kp(()=>{let a=Oe(e),i=1.6732632423543772,u=1.0507009873554805,p=-i*u,l=Ms(Si(o),this.rate);l=bl(l,"float32");let m=((1-this.rate)*(1+this.rate*p**2))**-.5,c=-m*p*this.rate,d=Z(_(a,l),_(Z(l,-1),p));return Z(_(d,m),c)},()=>Oe(e),n.training||!1)}return e})}};Bd.className="AlphaDropout";te.registerClass(Bd);function tg(r,t,e,n,o,s=.001){let a;if(r.rank===2)a=ty(r,t,e,n,o,s);else if(r.rank===3)a=ry(r,t,e,n,o,s);else if(r.rank===4)a=ny(r,t,e,n,o,s);else throw new Ne(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return a}function M9(r,t,e,n,o=.001){return U(()=>{let s=sl(r,n),a=s.mean,i=s.variance;return[tg(r,a,i,e,t,o),a,i]})}function E9(r,t,e,n,o=.001){return U(()=>{let s=sl(r,n),a=s.mean,i=s.variance,u=[];for(let f of en(0,r.rank))n.indexOf(f)!==-1?u.push(1):u.push(r.shape[f]);let p=$(a,u),l=$(i,u),m=t==null?null:$(t,u),c=e==null?null:$(e,u);return[tg(r,p,l,c,m,o),a,i]})}function _9(r,t,e,n,o=.001){return y.arraysEqual(n.slice().sort(),en(0,r.rank-1))?M9(r,t,e,n,o):E9(r,t,e,n,o)}var Od=class extends Ue{constructor(e){e==null&&(e={});super(e);this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.movingMeanInitializer=kt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=kt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Zt(e.betaConstraint),this.gammaConstraint=Zt(e.gammaConstraint),this.betaRegularizer=Dt(e.betaRegularizer),this.gammaRegularizer=Dt(e.gammaRegularizer)}build(e){e=nt(e);let n=this.axis>=0?this.axis:this.axis+e.length,o=e[n];if(o==null)throw new O(`Axis ${n} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Nt({ndim:e.length,axes:{[n]:o}})];let s=[o];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,n){return U(()=>{let o=n.training==null?!1:n.training,s=Oe(e),a=s.shape,i=a.length,u=en(0,i),p=this.axis>=0?this.axis:this.axis+i;u.splice(p,1);let l=Bs(1,i);l[p]=a[p];let m=u.slice();m.sort();let c=!y.arraysEqual(m,en(0,i).slice(0,i-1)),d=()=>{if(c){let x=$(this.movingMean.read(),l),I=$(this.movingVariance.read(),l),k=this.center?$(this.beta.read(),l):null,w=this.scale?$(this.gamma.read(),l):null;return tg(s,x,I,k,w,this.epsilon)}else return tg(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!o)return d();let[f,h,g]=_9(s,this.gamma.read(),this.beta.read(),u,this.epsilon),b=(x,I,k)=>{U(()=>{let w=1-k,R=x.read(),P=_(le(R,I),w);x.write(le(R,P))})};return(()=>{b(this.movingMean,h,this.momentum),b(this.movingVariance,g,this.momentum)})(),f})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_t(this.betaInitializer),gammaInitializer:_t(this.gammaInitializer),movingMeanInitializer:_t(this.movingMeanInitializer),movingVarianceInitializer:_t(this.movingVarianceInitializer),betaRegularizer:yt(this.betaRegularizer),gammaRegularizer:yt(this.gammaRegularizer),betaConstraint:Yt(this.betaConstraint),gammaConstraint:Yt(this.gammaConstraint)},n=super.getConfig();return Object.assign(e,n),e}};Od.className="BatchNormalization";te.registerClass(Od);var zd=class extends Ue{constructor(e){e==null&&(e={});super(e);if(this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let n of this.axis)if(!Number.isInteger(n))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.betaRegularizer=Dt(e.betaRegularizer),this.gammaRegularizer=Dt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=nt(e);let n=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=n);for(let a of this.axis)if(a<0||a>=n)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==zs(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let o=this.axis.map(a=>e[a]),s=!0;this.scale?this.gamma=this.addWeight("gamma",o,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",o,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,n){let o=Oe(e),s=o.shape,a=s.length;return U(()=>{let{mean:u,variance:p}=sl(o,this.axis,!0),l=Bs(1,a);for(let g of this.axis)l[g]=s[g];let m=g=>g!=null&&g.shape.length!==a?$(g,l):g,c=this.scale?m(this.gamma.read()):null,d=this.center?m(this.beta.read()):null,f=[],h=[];for(let g=0;g<a;++g)this.axis.indexOf(g)!==-1?(f.push(s[g]),h.push(1)):(f.push(1),h.push(s[g]));return u=Zr(u,f),p=Zr(p,f),c!=null&&(c=Zr(c,h)),d!=null&&(d=Zr(d,h)),tg(o,u,p,d,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:_t(this.betaInitializer),gammaInitializer:_t(this.gammaInitializer),betaRegularizer:yt(this.betaRegularizer),gammaRegularizer:yt(this.gammaRegularizer)},n=super.getConfig();return Object.assign(e,n),e}};zd.className="LayerNormalization";te.registerClass(zd);function L9(r,t,e){return U(()=>{if(r.rank!==4)throw new O(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new O("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=yn()),e!=="channelsLast"&&e!=="channelsFirst")throw new O(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],jn(r,n)})}var Gd=class extends Ue{constructor(e){e==null&&(e={});super(e);if(this.dataFormat=e.dataFormat==null?yn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new O(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let n,o;if(typeof e.padding[0]=="number")n=[e.padding[0],e.padding[0]],o=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new O(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(n=e.padding[0],e.padding[1].length!==2)throw new O(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);o=e.padding[1]}this.padding=[n,o]}this.inputSpec=[new Nt({ndim:4})]}computeOutputShape(e){e=nt(e);let n,o;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?n=e[2]+this.padding[0][0]+this.padding[0][1]:n=null,e[3]!=null&&e[3]>=0?o=e[3]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],e[1],n,o]):(e[1]!=null&&e[1]>=0?n=e[1]+this.padding[0][0]+this.padding[0][1]:n=null,e[2]!=null&&e[2]>=0?o=e[2]+this.padding[1][0]+this.padding[1][1]:o=null,[e[0],n,o,e[3]])}call(e,n){return U(()=>L9(Oe(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}};Gd.className="ZeroPadding2D";te.registerClass(Gd);function ZT(r,t,e,n,o,s){return U(()=>{Vt(o),RA(s),bn(n),e==null&&(e=[1,1]),n==null&&(n="valid"),o==null&&(o=yn()),s==null&&(s="max"),r=Jh(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=Cc(r,t,e,i):a=hc(r,t,e,i),o==="channelsFirst"&&(a=Ke(a,[0,3,1,2])),a})}function JE(r,t,e,n,o,s){return U(()=>{Vt(o),RA(s),bn(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),o==null&&(o=yn()),s==null&&(s="max"),r=QA(r,o);let a,i=n==="same"?"same":"valid";return s==="max"?a=ky(r,t,e,i):a=ey(r,t,e,i),o==="channelsFirst"&&(a=Ke(a,[0,4,1,2,3])),a})}var HT=class extends Ue{constructor(e){e.poolSize==null&&(e.poolSize=2);super(e);if(typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new O(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(or(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new O(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,bn(this.padding),this.inputSpec=[new Nt({ndim:3})]}computeOutputShape(e){e=nt(e);let n=$n(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],n,e[2]]}call(e,n){return U(()=>{this.invokeCallHook(e,n),e=cu(Oe(e),2);let o=this.poolingFunction(Oe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return _s(o,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},n=super.getConfig();return Object.assign(e,n),e}},Ud=class extends HT{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Vt(s),bn(o),ZT(t,e,n,o,s,"max")}};Ud.className="MaxPooling1D";te.registerClass(Ud);var Wd=class extends HT{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Vt(s),bn(o),ZT(t,e,n,o,s,"avg")}};Wd.className="AveragePooling1D";te.registerClass(Wd);var qT=class extends Ue{constructor(e){e.poolSize==null&&(e.poolSize=[2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new O(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];or(this.poolSize,"poolSize"),or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),bn(this.padding),this.inputSpec=[new Nt({ndim:4})]}computeOutputShape(e){e=nt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],o=this.dataFormat==="channelsFirst"?e[3]:e[2];return n=$n(n,this.poolSize[0],this.padding,this.strides[0]),o=$n(o,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,o]:[e[0],n,o,e[3]]}call(e,n){return U(()=>(this.invokeCallHook(e,n),this.poolingFunction(Oe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}},Kd=class extends qT{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Vt(s),bn(o),ZT(t,e,n,o,s,"max")}};Kd.className="MaxPooling2D";te.registerClass(Kd);var Vd=class extends qT{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Vt(s),bn(o),ZT(t,e,n,o,s,"avg")}};Vd.className="AveragePooling2D";te.registerClass(Vd);var jT=class extends Ue{constructor(e){e.poolSize==null&&(e.poolSize=[2,2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new O(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];or(this.poolSize,"poolSize"),or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),bn(this.padding),this.inputSpec=[new Nt({ndim:5})]}computeOutputShape(e){e=nt(e);let n=this.dataFormat==="channelsFirst"?e[2]:e[1],o=this.dataFormat==="channelsFirst"?e[3]:e[2],s=this.dataFormat==="channelsFirst"?e[4]:e[3];return n=$n(n,this.poolSize[0],this.padding,this.strides[0]),o=$n(o,this.poolSize[1],this.padding,this.strides[1]),s=$n(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],n,o,s]:[e[0],n,o,s,e[4]]}call(e,n){return U(()=>(this.invokeCallHook(e,n),this.poolingFunction(Oe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}},Hd=class extends jT{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Vt(s),bn(o),JE(t,e,n,o,s,"max")}};Hd.className="MaxPooling3D";te.registerClass(Hd);var qd=class extends jT{constructor(t){super(t)}poolingFunction(t,e,n,o,s){return Vt(s),bn(o),JE(t,e,n,o,s,"avg")}};qd.className="AveragePooling3D";te.registerClass(qd);var XT=class extends Ue{constructor(t){super(t),this.inputSpec=[new Nt({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new Ne}},jd=class extends XT{constructor(t){super(t||{})}call(t,e){return U(()=>{let n=Oe(t);return Ot(n,1)})}};jd.className="GlobalAveragePooling1D";te.registerClass(jd);var Xd=class extends XT{constructor(t){super(t||{})}call(t,e){return U(()=>{let n=Oe(t);return hn(n,1)})}};Xd.className="GlobalMaxPooling1D";te.registerClass(Xd);var YT=class extends Ue{constructor(e){super(e);this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,Vt(this.dataFormat),this.inputSpec=[new Nt({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,n){throw new Ne}getConfig(){let e={dataFormat:this.dataFormat},n=super.getConfig();return Object.assign(e,n),e}},Yd=class extends YT{call(t,e){return U(()=>{let n=Oe(t);return this.dataFormat==="channelsLast"?Ot(n,[1,2]):Ot(n,[2,3])})}};Yd.className="GlobalAveragePooling2D";te.registerClass(Yd);var Zd=class extends YT{call(t,e){return U(()=>{let n=Oe(t);return this.dataFormat==="channelsLast"?hn(n,[1,2]):hn(n,[2,3])})}};Zd.className="GlobalMaxPooling2D";te.registerClass(Zd);var QT=class extends Ue{constructor(e){super(e);this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},n=super.getConfig();return Object.assign(e,n),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,n,o={}){let s=n.layer,a=Cn(s,o);delete n.layer;let i={layer:a};return Object.assign(i,n),new e(i)}},Qd=class extends QT{constructor(t){super(t),this.supportsMasking=!0}build(t){if(t=nt(t),t.length<3)throw new O(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=nt(t);let e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),o=t[1];return[n[0],o].concat(n.slice(1))}call(t,e){return U(()=>(t=Oe(t),nw((a,i)=>[Oe(this.layer.call(a,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};Qd.className="TimeDistributed";te.registerClass(Qd);function $9(r){Ni(pP,"BidirectionalMergeMode",r)}var B9="concat",Jd=class extends QT{constructor(e){super(e);let n=e.layer.getConfig(),o={};o.className=e.layer.getClassName(),o.config=n,this.forwardLayer=Cn(o),n.goBackwards=n.goBackwards!==!0;let s={};if(s.className=e.layer.getClassName(),s.config=n,this.backwardLayer=Cn(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?B9:e.mergeMode,$9(this.mergeMode),e.weights)throw new Ne("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let n=e.length,o=Math.floor(n/2);this.forwardLayer.setWeights(e.slice(0,o)),this.backwardLayer.setWeights(e.slice(o))}computeOutputShape(e){let n=this.forwardLayer.computeOutputShape(e);Array.isArray(n)&&Array.isArray(n[0])||(n=[n]),n=n;let o,s,a;return this.returnState&&(a=n.slice(1)),o=n[0],o=o,this.mergeMode==="concat"?(o[o.length-1]*=2,s=[o]):this.mergeMode==null?s=[o,o.slice()]:s=[o],this.returnState?this.mergeMode==null?s.concat(a).concat(a.slice()):[o].concat(a).concat(a.slice()):Rr(s)}apply(e,n){let o=n==null?null:n.initialState,s=n==null?null:n.constants;n==null&&(n={});let a=rw(e,o,s,this.numConstants);if(e=a.inputs,o=a.initialState,s=a.constants,Array.isArray(e)&&(o=e.slice(1),e=e[0]),(o==null||o.length===0)&&s==null)return super.apply(e,n);let i=[],u=[];if(o!=null){let l=o.length;if(l%2>0)throw new O("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");n.initialState=o,i.push(...o);let m=o.map(c=>new Nt({shape:c.shape}));this.forwardLayer.stateSpec=m.slice(0,l/2),this.backwardLayer.stateSpec=m.slice(l/2),u.push(...m)}if(s!=null)throw new Ne("Support for constants in Bidirectional layers is not implemented yet.");let p=i[0]instanceof tn;for(let l of i)if(l instanceof tn!==p)throw new O("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(p){let l=[e].concat(i),m=this.inputSpec.concat(u),c=this.inputSpec;this.inputSpec=m;let d=super.apply(l,n);return this.inputSpec=c,d}else return super.apply(e,n)}call(e,n){return U(()=>{let o=n.initialState,s,a;if(o==null)s=this.forwardLayer.call(e,n),a=this.backwardLayer.call(e,n);else{let p=o.slice(0,o.length/2),l=o.slice(o.length/2);s=this.forwardLayer.call(e,Object.assign(n,{initialState:p})),a=this.backwardLayer.call(e,Object.assign(n,{initialState:l}))}let i;this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(a.slice(1))),s=s[0],a=a[0]),this.returnSequences&&(a=Dr(a,1));let u;return this.mergeMode==="concat"?u=_c([s,a]):this.mergeMode==="sum"?u=Z(s,a):this.mergeMode==="ave"?u=_(.5,Z(s,a)):this.mergeMode==="mul"?u=_(s,a):this.mergeMode==null&&(u=[s,a]),this.returnState?this.mergeMode==null?u.concat(i):[u].concat(i):u})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Xa(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Xa(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,n){Array.isArray(n)&&(n=n[0]);let o;if(this.returnSequences?this.mergeMode==null?o=[n,n]:o=n:this.mergeMode==null?o=[null,null]:o=null,this.returnState){let a=this.forwardLayer.states.map(i=>null);return Array.isArray(o)?o.concat(a).concat(a):[o].concat(a).concat(a)}else return o}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},n=super.getConfig();return Object.assign(e,n),e}static fromConfig(e,n){let o=Cn(n.layer);if(delete n.layer,n.numConstants!=null)throw new Ne("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=n;return s.layer=o,new e(s)}};Jd.className="Bidirectional";te.registerClass(Jd);function O9(r){return new Za(r)}function z9(r){return new ad(r)}function G9(r){return new nd(r)}function U9(r){return new od(r)}function W9(r){return new sd(r)}function K9(r){return new ud(r)}function V9(r){return new id(r)}function H9(r){return new cd(r)}function q9(r){return new Fl(r)}function j9(r){return new pd(r)}function X9(r){return new Rl(r)}function Y9(r){return new ld(r)}function Z9(r){return new md(r)}function Q9(r){return new dd(r)}function J9(r){return new fd(r)}function eee(r){return new hd(r)}function tee(r){return new kd(r)}function ree(r){return new Id(r)}function nee(r){return new $l(r)}function oee(r){return new xd(r)}function see(r){return new Cd(r)}function aee(r){return new Sd(r)}function iee(r){return new vd(r)}function uee(r){return new Ad(r)}function pee(r){return new Nd(r)}function lee(r){return new Dd(r)}function mee(r){return new Rd(r)}function cee(r){return new Ed(r)}function dee(r){return new Pd(r)}function fee(r){return new Md(r)}function hee(r){return new Fd(r)}function gee(r){return new _d(r)}function bee(r){return new Od(r)}function yee(r){return new zd(r)}function Tee(r){return new Gd(r)}function sw(r){return new Wd(r)}function xee(r){return sw(r)}function Iee(r){return sw(r)}function aw(r){return new Vd(r)}function Cee(r){return aw(r)}function kee(r){return aw(r)}function iw(r){return new qd(r)}function See(r){return iw(r)}function vee(r){return iw(r)}function Aee(r){return new jd(r)}function wee(r){return new Yd(r)}function e_(r){return new Xd(r)}function t_(r){return new Zd(r)}function r_(r){return new Ud(r)}function n_(r){return new Kd(r)}function Nee(r){return new Hd(r)}function Dee(r){return new bd(r)}function Fee(r){return new El(r)}function Ree(r){return new yd(r)}function Pee(r){return new hu(r)}function Mee(r){return new gd(r)}function Eee(r){return new Ml(r)}function _ee(r){return new Td(r)}function Lee(r){return new Ll(r)}function $ee(r){return new ns(r)}function Bee(r){return new _l(r)}function Oee(r){return new Jd(r)}function zee(r){return new Qd(r)}var Gee=e_,Uee=t_,Wee=r_,Kee=n_;function Vee(r){return new Ld(r)}function Hee(r){return new $d(r)}function qee(r){return new Bd(r)}function jee(r){return new wd(r)}var s_={};Xe(s_,{MAPE:()=>ste,MSE:()=>ute,binaryAccuracy:()=>Xee,binaryCrossentropy:()=>Yee,categoricalAccuracy:()=>Qee,categoricalCrossentropy:()=>Jee,cosineProximity:()=>rte,mape:()=>ate,meanAbsoluteError:()=>nte,meanAbsolutePercentageError:()=>ote,meanSquaredError:()=>ite,mse:()=>pte,precision:()=>ete,recall:()=>tte,sparseCategoricalAccuracy:()=>Zee});function Xee(r,t){return jh(r,t)}function Yee(r,t){return TT(r,t)}function Zee(r,t){return xT(r,t)}function Qee(r,t){return Xh(r,t)}function Jee(r,t){return Yh(r,t)}function ete(r,t){return WA(r,t)}function tte(r,t){return FE(r,t)}function rte(r,t){return qh(r,t)}function nte(r,t){return Qc(r,t)}function ote(r,t){return vp(r,t)}function ste(r,t){return vp(r,t)}function ate(r,t){return vp(r,t)}function ite(r,t){return Fi(r,t)}function ute(r,t){return Fi(r,t)}function pte(r,t){return Fi(r,t)}var a_={};Xe(a_,{modelFromJSON:()=>HE});var i_={};Xe(i_,{l1:()=>mte,l1l2:()=>lte,l2:()=>cte});function lte(r){return new Ap(r)}function mte(r){return YE(r)}function cte(r){return ZE(r)}var ex=class extends fu{constructor(){super(...arguments);this.model=null}setModel(e){if(!(e instanceof Yn))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function JT(r,t){return r<t}function u_(r,t){return r>t}var tx=class extends ex{constructor(e){super();if(e==null&&(e={}),e.restoreBestWeights)throw new Ne("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=JT:this.mode==="max"?this.monitorFunc=u_:this.monitor.indexOf("acc")!==-1?this.monitorFunc=u_:this.monitorFunc=JT,this.monitorFunc===JT&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===JT?1/0:-1/0}async onEpochEnd(e,n){await Di(n);let o=this.getMonitorValue(n);o!=null&&(this.monitorFunc(o-this.minDelta,this.best)?(this.best=o,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let n=e[this.monitor];return n==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),n}};function dte(r){return new tx(r)}var fte={earlyStopping:dte};var hte=B();hte.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var uw=(J=>(J[J.DT_INVALID=0]="DT_INVALID",J[J.DT_FLOAT=1]="DT_FLOAT",J[J.DT_DOUBLE=2]="DT_DOUBLE",J[J.DT_INT32=3]="DT_INT32",J[J.DT_UINT8=4]="DT_UINT8",J[J.DT_INT16=5]="DT_INT16",J[J.DT_INT8=6]="DT_INT8",J[J.DT_STRING=7]="DT_STRING",J[J.DT_COMPLEX64=8]="DT_COMPLEX64",J[J.DT_INT64=9]="DT_INT64",J[J.DT_BOOL=10]="DT_BOOL",J[J.DT_QINT8=11]="DT_QINT8",J[J.DT_QUINT8=12]="DT_QUINT8",J[J.DT_QINT32=13]="DT_QINT32",J[J.DT_BFLOAT16=14]="DT_BFLOAT16",J[J.DT_QINT16=15]="DT_QINT16",J[J.DT_QUINT16=16]="DT_QUINT16",J[J.DT_UINT16=17]="DT_UINT16",J[J.DT_COMPLEX128=18]="DT_COMPLEX128",J[J.DT_HALF=19]="DT_HALF",J[J.DT_RESOURCE=20]="DT_RESOURCE",J[J.DT_VARIANT=21]="DT_VARIANT",J[J.DT_UINT32=22]="DT_UINT32",J[J.DT_UINT64=23]="DT_UINT64",J[J.DT_FLOAT_REF=101]="DT_FLOAT_REF",J[J.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",J[J.DT_INT32_REF=103]="DT_INT32_REF",J[J.DT_UINT8_REF=104]="DT_UINT8_REF",J[J.DT_INT16_REF=105]="DT_INT16_REF",J[J.DT_INT8_REF=106]="DT_INT8_REF",J[J.DT_STRING_REF=107]="DT_STRING_REF",J[J.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",J[J.DT_INT64_REF=109]="DT_INT64_REF",J[J.DT_BOOL_REF=110]="DT_BOOL_REF",J[J.DT_QINT8_REF=111]="DT_QINT8_REF",J[J.DT_QUINT8_REF=112]="DT_QUINT8_REF",J[J.DT_QINT32_REF=113]="DT_QINT32_REF",J[J.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",J[J.DT_QINT16_REF=115]="DT_QINT16_REF",J[J.DT_QUINT16_REF=116]="DT_QUINT16_REF",J[J.DT_UINT16_REF=117]="DT_UINT16_REF",J[J.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",J[J.DT_HALF_REF=119]="DT_HALF_REF",J[J.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",J[J.DT_VARIANT_REF=121]="DT_VARIANT_REF",J[J.DT_UINT32_REF=122]="DT_UINT32_REF",J[J.DT_UINT64_REF=123]="DT_UINT64_REF",J))(uw||{}),gte;(t=>{let r;(s=>(s[s.LEGACY=0]="LEGACY",s[s.V1=1]="V1",s[s.V2=2]="V2"))(r=t.CheckpointFormatVersion||={})})(gte||={});var pw={};function yte(r,t){let e={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:t};pw[r]=e}function rx(r){return pw[r]}function Tte(r){delete pw[r]}function v(r,t,e,n,o){let s=t.inputParams[r];if(s&&s.inputIndexStart!==void 0){let i=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?i+1:s.inputIndexEnd;if(s.type==="tensor")return vr(t.inputNames[s.inputIndexStart],e,n,o);if(s.type==="tensors")return t.inputNames.slice(i,u).map(c=>vr(c,e,n,o));let p=vr(t.inputNames.slice(i)[0],e,n,o),l=p.dataSync();return s.type==="number"?l[0]:y.toNestedArray(p.shape,l)}let a=t.attrParams[r];return a&&a.value}function vr(r,t,e,n){let[o,s]=kn(r);if(n!=null){let i=n.getHashTableHandleByName(o);if(i!=null)return i}let a=e.currentContextIds.find(i=>!!t[nx(o,i)]);return a!==void 0?t[nx(o,a)][s]:void 0}function p_(r,t,e){return t[nx(r,e.currentContextId)]}function Vs(r,t){let[e,n,o]=kn(r);return[nx(e,t&&t.currentContextId),n,o]}function nx(r,t){return t?`${r}-${t}`:r}function kn(r){let t=r.split(":");if(t.length===1)return[r,0,void 0];let e=t[0],n=t.length===3?t[1]:void 0,o=Number(t[t.length-1]);return[e,o,n]}function rg(r,t,e){let n=v("pad",r,t,e);if(n==="explicit"){n=v("explicitPaddings",r,t,e);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function ri(r){return r.kept?r:fn(r)}var lw={};Xe(lw,{json:()=>xte});var xte=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var mw={};Xe(mw,{json:()=>Ite});var Ite=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var cw={};Xe(cw,{json:()=>Cte});var Cte=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var dw={};Xe(dw,{json:()=>kte});var kte=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var fw={};Xe(fw,{json:()=>Ste});var Ste=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var hw={};Xe(hw,{json:()=>vte});var vte=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var gw={};Xe(gw,{json:()=>Ate});var Ate=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var bw={};Xe(bw,{json:()=>wte});var wte=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var yw={};Xe(yw,{json:()=>Nte});var Nte=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var Tw={};Xe(Tw,{json:()=>Dte});var Dte=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var xw={};Xe(xw,{json:()=>Fte});var Fte=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Iw={};Xe(Iw,{json:()=>Rte});var Rte=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var Cw={};Xe(Cw,{json:()=>Pte});var Pte=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var kw={};Xe(kw,{json:()=>Mte});var Mte=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var Sw={};Xe(Sw,{json:()=>Ete});var Ete=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var vw={};Xe(vw,{json:()=>_te});var _te=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var Aw={};Xe(Aw,{json:()=>Lte});var Lte=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var ww={};Xe(ww,{json:()=>$te});var $te=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var Nw={};Xe(Nw,{json:()=>Bte});var Bte=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var ng=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let t=[lw,mw,cw,dw,fw,hw,gw,bw,yw,Tw,xw,Iw,Cw,kw,Sw,vw,Aw,ww,Nw],e=[].concat(...t.map(n=>n.json));this.opMappers=e.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(t,e={}){let n=t.node,o=[],s=[],a=[],i=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&a.push(h[g.name]),h),{}),u=[],p=[],l={},m={};e!=null&&(l=this.mapSignatureEntries(e.inputs),m=this.mapSignatureEntries(e.outputs));let c=Object.keys(i);c.forEach(h=>{let g=i[h];g.inputNames.forEach((b,T)=>{let[x,,I]=Vs(b),k=i[x];if(k.outputs!=null){let w=k.outputs.indexOf(I);if(w!==-1){let R=`${x}:${w}`;g.inputNames[T]=R}}g.inputs.push(k),k.children.push(g)})}),Object.keys(m).length===0?c.forEach(h=>{let g=i[h];g.children.length===0&&p.push(g)}):Object.keys(m).forEach(h=>{let[g]=Vs(h),b=i[g];b!=null&&(b.signatureKey=m[h],p.push(b))}),Object.keys(l).length>0?Object.keys(l).forEach(h=>{let[g]=Vs(h),b=i[g];b&&(b.signatureKey=l[h],u.push(b))}):u=o;let d={};t.library!=null&&t.library.function!=null&&(d=t.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let f={nodes:i,inputs:u,outputs:p,weights:s,placeholders:o,signature:e,functions:d};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(t){return Object.keys(t||{}).reduce((e,n)=>(e[t[n].name]=n,e),{})}mapNode(t){let e=rx(t.op)||this.opMappers[t.op]||{};t.attr==null&&(t.attr={});let n={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map(o=>o.startsWith("^")?o.slice(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr,outputs:e.outputs};return e.inputs!=null&&(n.inputParams=e.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),e.attrs!=null&&(n.attrParams=e.attrs.reduce((o,s)=>{let a=s.type,i;switch(s.type){case"string":i=ox(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ox(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":i=mx(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=mx(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":i=ax(t.attr,s.tfName,s.defaultValue||0),i===void 0&&!!s.tfDeprecatedName&&(i=ax(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":i=lx(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=lx(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":i=sx(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=sx(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":i=dx(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=dx(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":i=px(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=px(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":i=cx(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=cx(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":i=ix(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ix(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":i=ux(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=ux(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":i=l_(t.attr,s.tfName,s.defaultValue),i===void 0&&!!s.tfDeprecatedName&&(i=l_(t.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${t.op}`)}return o[s.name]={value:i,type:a},o},{})),n}mapFunction(t){let e=t.nodeDef,n=[],o=[],s={};e!=null&&(s=e.reduce((m,c)=>(m[c.name]=this.mapNode(c),c.op==="Const"&&o.push(m[c.name]),m),{}));let a=[],i=[];t.signature.inputArg.forEach(m=>{let[c]=Vs(m.name),d={name:c,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Dw(m.type),type:"dtype"}},children:[]};d.signatureKey=m.name,a.push(d),s[c]=d}),Object.keys(s).forEach(m=>{let c=s[m];c.inputNames.forEach((d,f)=>{let[h,,g]=Vs(d),b=s[h];if(b.outputs!=null){let T=b.outputs.indexOf(g);if(T!==-1){let x=`${h}:${T}`;c.inputNames[f]=x}}c.inputs.push(b),b.children.push(c)})});let p=t.ret;t.signature.outputArg.forEach(m=>{let[c,d]=Vs(p[m.name]),f=s[c];f!=null&&(f.defaultOutput=d,i.push(f))});let l=this.mapArgsToSignature(t);return{nodes:s,inputs:a,outputs:i,weights:o,placeholders:n,signature:l}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n),e),{}),outputs:t.signature.outputArg.reduce((e,n)=>(e[n.name]=this.mapArgToTensorInfo(n,t.ret),e),{})}}mapArgToTensorInfo(t,e){let n=t.name;return e!=null&&(n=e[n]),{name:n,dtype:t.type}}};function Ote(r){let t=B().global;if(typeof t.atob<"u")return t.atob(r);if(typeof Buffer<"u")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function m_(r,t){let e=Array.isArray(r)?String.fromCharCode.apply(null,r):Ote(r);return t?e:e.toLowerCase()}function ox(r,t,e,n=!1){let o=r[t];return o!=null?m_(o.s,n):e}function sx(r,t,e){let n=r[t];return n?n.b:e}function ax(r,t,e){let n=r[t]||{},o=n.i!=null?n.i:n.f!=null?n.f:e;return typeof o=="number"?o:parseInt(o,10)}function Dw(r){switch(typeof r=="string"&&(r=uw[r]),r){case 1:case 19:return"float32";case 3:case 9:case 6:case 4:return"int32";case 10:return"bool";case 2:return"float32";case 7:return"string";default:return null}}function l_(r,t,e){let n=r[t];return n&&n.func?n.func.name:e}function ix(r,t,e){let n=r[t];return n&&n.type?Dw(n.type):e}function ux(r,t,e){let n=r[t];return n&&n.list&&n.list.type?n.list.type.map(o=>Dw(o)):e}function c_(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(t=>typeof t.size=="number"?t.size:parseInt(t.size,10)):[]}function px(r,t,e){let n=r[t];return n&&n.shape?c_(n.shape):e}function lx(r,t,e){let n=r[t];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):e}function mx(r,t,e,n=!1){let o=r[t];return o&&o.list&&o.list.s?o.list.s.map(s=>m_(s,n)):e}function cx(r,t,e){let n=r[t];return n&&n.list&&n.list.shape?n.list.shape.map(o=>c_(o)):e}function dx(r,t,e){let n=r[t];return n&&n.list&&n.list.b?n.list.b:e}var fx=class{constructor(t,e,n){this.node=t;this.tensorMap=e;this.context=n;this.inputs=[];this.attrs={};this.inputs=t.inputNames.map(o=>this.getInput(o)),t.rawAttrs!=null&&(this.attrs=Object.keys(t.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(t){return vr(t,this.tensorMap,this.context)}getAttr(t,e){let n=this.node.rawAttrs[t];if(n.tensor!=null)return vr(t,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return ax(this.node.rawAttrs,t,e);if(n.s!=null)return ox(this.node.rawAttrs,t,e);if(n.b!=null)return sx(this.node.rawAttrs,t,e);if(n.shape!=null)return px(this.node.rawAttrs,t,e);if(n.type!=null)return ix(this.node.rawAttrs,t,e);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return lx(this.node.rawAttrs,t,e);if(n.list.s!=null)return mx(this.node.rawAttrs,t,e);if(n.list.shape!=null)return cx(this.node.rawAttrs,t,e);if(n.list.b!=null)return dx(this.node.rawAttrs,t,e);if(n.list.type!=null)return ux(this.node.rawAttrs,t,e)}return e}};var dt={};Xe(dt,{OP_SCOPE_SUFFIX:()=>Gv,abs:()=>Wt,acos:()=>L2,acosh:()=>$2,add:()=>Z,addN:()=>B2,all:()=>Qb,any:()=>Fh,argMax:()=>op,argMin:()=>O2,asin:()=>z2,asinh:()=>G2,atan:()=>U2,atan2:()=>W2,atanh:()=>K2,avgPool:()=>hc,avgPool3d:()=>ey,basicLSTMCell:()=>q2,batchNorm:()=>ap,batchNorm2d:()=>ty,batchNorm3d:()=>ry,batchNorm4d:()=>ny,batchToSpaceND:()=>gc,bincount:()=>oy,booleanMaskAsync:()=>_Z,broadcastArgs:()=>X2,broadcastTo:()=>ip,buffer:()=>xe,cast:()=>oe,ceil:()=>Y2,clipByValue:()=>Gr,clone:()=>fn,complex:()=>Rn,concat:()=>ct,concat1d:()=>sy,concat2d:()=>ay,concat3d:()=>iy,concat4d:()=>uy,conv1d:()=>py,conv2d:()=>es,conv2dTranspose:()=>ly,conv3d:()=>my,conv3dTranspose:()=>dy,cos:()=>yc,cosh:()=>fy,cosineWindow:()=>$h,cumprod:()=>Rh,cumsum:()=>hy,denseBincount:()=>Z2,depthToSpace:()=>Q2,depthwiseConv2d:()=>up,diag:()=>J2,dilation2d:()=>eF,div:()=>me,divNoNan:()=>tF,dot:()=>rF,dropout:()=>IA,einsum:()=>nF,elu:()=>pp,enclosingPowerOfTwo:()=>CA,equal:()=>Yr,erf:()=>oF,euclideanNorm:()=>iF,exp:()=>br,expandDims:()=>_r,expm1:()=>uF,eye:()=>ol,fft:()=>Nc,fill:()=>ki,floor:()=>lp,floorDiv:()=>Zb,fused:()=>fp,gather:()=>mp,gatherND:()=>KZ,greater:()=>mr,greaterEqual:()=>Ms,ifft:()=>ll,imag:()=>np,image:()=>hp,inTopKAsync:()=>qZ,irfft:()=>_y,isFinite:()=>pF,isInf:()=>lF,isNaN:()=>mF,leakyRelu:()=>Tc,less:()=>gy,lessEqual:()=>Es,linalg:()=>SA,linspace:()=>cF,localResponseNormalization:()=>dF,log:()=>Ur,log1p:()=>xc,logSigmoid:()=>fF,logSoftmax:()=>Ty,logSumExp:()=>xy,logicalAnd:()=>Qr,logicalNot:()=>Ic,logicalOr:()=>Iy,logicalXor:()=>hF,losses:()=>qQ,lowerBound:()=>gF,matMul:()=>je,max:()=>hn,maxPool:()=>Cc,maxPool3d:()=>ky,maxPoolWithArgmax:()=>bF,maximum:()=>ts,mean:()=>Ot,meshgrid:()=>yF,min:()=>Mh,minimum:()=>cp,mirrorPad:()=>TF,mod:()=>xF,moments:()=>sl,movingAverage:()=>$Z,mul:()=>_,multiRNNCell:()=>IF,multinomial:()=>CF,neg:()=>et,norm:()=>nl,notEqual:()=>pu,oneHot:()=>tp,ones:()=>yr,onesLike:()=>Lr,op:()=>A,outerProduct:()=>kF,pad:()=>jn,pad1d:()=>SF,pad2d:()=>vF,pad3d:()=>AF,pad4d:()=>wF,pool:()=>NF,pow:()=>qn,prelu:()=>Sc,print:()=>Gb,prod:()=>DF,raggedTensorToTensor:()=>FF,rand:()=>RF,randomGamma:()=>jF,randomNormal:()=>ul,randomStandardNormal:()=>XF,randomUniform:()=>Si,range:()=>dp,real:()=>iu,reciprocal:()=>YF,relu:()=>Jr,relu6:()=>Ny,reshape:()=>$,reverse:()=>Dr,reverse1d:()=>ZF,reverse2d:()=>QF,reverse3d:()=>JF,reverse4d:()=>eR,rfft:()=>Dc,round:()=>Dy,rsqrt:()=>Fy,scalar:()=>ce,scatterND:()=>OZ,searchSorted:()=>Eh,selu:()=>Ry,separableConv2d:()=>Py,setdiff1dAsync:()=>tR,sigmoid:()=>_n,sign:()=>rR,signal:()=>HQ,sin:()=>My,sinh:()=>Ey,slice:()=>Ge,slice1d:()=>vc,slice2d:()=>Lh,slice3d:()=>Ac,slice4d:()=>pl,softmax:()=>wc,softplus:()=>uu,spaceToBatchND:()=>kc,sparse:()=>jQ,sparseToDense:()=>UZ,spectral:()=>VQ,split:()=>Fr,sqrt:()=>Bt,square:()=>Ye,squaredDifference:()=>Ly,squeeze:()=>_s,stack:()=>Tr,step:()=>vi,stridedSlice:()=>nR,string:()=>XQ,sub:()=>le,sum:()=>de,tan:()=>oR,tanh:()=>sp,tensor:()=>wr,tensor1d:()=>Xt,tensor2d:()=>Va,tensor3d:()=>Hb,tensor4d:()=>sR,tensor5d:()=>aR,tensor6d:()=>iR,tile:()=>Zr,topk:()=>uR,transpose:()=>Ke,truncatedNormal:()=>Fc,unique:()=>pR,unsortedSegmentSum:()=>$y,unstack:()=>Wr,upperBound:()=>lR,variable:()=>By,where:()=>Kt,whereAsync:()=>zy,zeros:()=>Ct,zerosLike:()=>Fe});var d_=(r,t,e,n=dt)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(v("a",r,t,e),v("b",r,t,e))];case"AddN":return[n.addN(v("tensors",r,t,e))];case"FloorMod":case"Mod":return[n.mod(v("a",r,t,e),v("b",r,t,e))];case"Mul":return[n.mul(v("a",r,t,e),v("b",r,t,e))];case"RealDiv":case"Div":return[n.div(v("a",r,t,e),v("b",r,t,e))];case"DivNoNan":return[n.divNoNan(v("a",r,t,e),v("b",r,t,e))];case"FloorDiv":return[n.floorDiv(v("a",r,t,e),v("b",r,t,e))];case"Sub":return[n.sub(v("a",r,t,e),v("b",r,t,e))];case"Minimum":return[n.minimum(v("a",r,t,e),v("b",r,t,e))];case"Maximum":return[n.maximum(v("a",r,t,e),v("b",r,t,e))];case"Pow":return[n.pow(v("a",r,t,e),v("b",r,t,e))];case"SquaredDifference":return[n.squaredDifference(v("a",r,t,e),v("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var f_=(r,t,e,n=dt)=>{switch(r.op){case"Abs":case"ComplexAbs":return[n.abs(v("x",r,t,e))];case"Acos":return[n.acos(v("x",r,t,e))];case"Acosh":return[n.acosh(v("x",r,t,e))];case"Asin":return[n.asin(v("x",r,t,e))];case"Asinh":return[n.asinh(v("x",r,t,e))];case"Atan":return[n.atan(v("x",r,t,e))];case"Atan2":return[n.atan2(v("x",r,t,e),v("y",r,t,e))];case"Atanh":return[n.atanh(v("x",r,t,e))];case"Ceil":return[n.ceil(v("x",r,t,e))];case"Complex":return[n.complex(v("real",r,t,e),v("imag",r,t,e))];case"Cos":return[n.cos(v("x",r,t,e))];case"Cosh":return[n.cosh(v("x",r,t,e))];case"Elu":return[n.elu(v("x",r,t,e))];case"Erf":return[n.erf(v("x",r,t,e))];case"Exp":return[n.exp(v("x",r,t,e))];case"Expm1":return[n.expm1(v("x",r,t,e))];case"Floor":return[n.floor(v("x",r,t,e))];case"Log":return[n.log(v("x",r,t,e))];case"Log1p":return[n.log1p(v("x",r,t,e))];case"Imag":return[n.imag(v("x",r,t,e))];case"Neg":return[n.neg(v("x",r,t,e))];case"Reciprocal":return[n.reciprocal(v("x",r,t,e))];case"Real":return[n.real(v("x",r,t,e))];case"Relu":return[n.relu(v("x",r,t,e))];case"Round":return[n.round(v("x",r,t,e))];case"Selu":return[n.selu(v("x",r,t,e))];case"Sigmoid":return[n.sigmoid(v("x",r,t,e))];case"Sin":return[n.sin(v("x",r,t,e))];case"Sign":return[n.sign(v("x",r,t,e))];case"Sinh":return[n.sinh(v("x",r,t,e))];case"Softplus":return[n.softplus(v("x",r,t,e))];case"Sqrt":return[n.sqrt(v("x",r,t,e))];case"Square":return[n.square(v("x",r,t,e))];case"Tanh":return[n.tanh(v("x",r,t,e))];case"Tan":return[n.tan(v("x",r,t,e))];case"ClipByValue":return[n.clipByValue(v("x",r,t,e),v("clipValueMin",r,t,e),v("clipValueMax",r,t,e))];case"Relu6":return[n.relu6(v("x",r,t,e))];case"Rsqrt":return[n.rsqrt(vr(r.inputNames[0],t,e))];case"Prod":return[n.prod(v("x",r,t,e),v("axes",r,t,e))];case"LeakyRelu":return[n.leakyRelu(v("x",r,t,e),v("alpha",r,t,e))];case"Prelu":return[n.prelu(v("x",r,t,e),v("alpha",r,t,e))];case"IsNan":return[n.isNaN(vr(r.inputNames[0],t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Zn(r,t,e=""){if(!(typeof r=="number"||typeof t=="number")){y.assert(r.length===t.length,()=>e+` Shapes ${r} and ${t} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=t[n];y.assert(o<0||s<0||o===s,()=>e+` Shapes ${r} and ${t} must match`)}}}function h_(r){return!(typeof r=="number"||r.some(t=>t<0))}function ef(r,t,e){let n=hx(r,e),o=!h_(n);if(o&&t.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&t.forEach(s=>{n=hx(s.shape,n)}),!h_(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function hx(r,t){if(typeof r=="number")return t;if(typeof t=="number")return r;if(r.length!==t.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${t}`);let e=[];for(let n=0;n<r.length;++n){let o=r[n],s=t[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${t}`);e[n]=o>=0?o:s}return e}var gx=class{constructor(t,e,n,o,s,a,i){this.name=t;this.dtype=e;this.maxSize=n;this.elementShape=o;this.identicalElementShapes=s;this.dynamicSize=a;this.clearAfterRead=i;this.tensors=[];this.closed_=!1;this.idTensor=ce(0),Ut(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.tensor.id))&&e.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);let e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map(e=>this.read(e))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},
          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=e.shape),Zn(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);n.tensor=e,Ut(e),n.written=!0,this.tensors[t]=n}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach((n,o)=>this.write(n,e[o]))}gather(t,e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let o=0;o<this.size();o++)t.push(o)}if(t.length===0)return wr([],[0].concat(this.elementShape));let n=this.readMany(t);return Zn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Tr(n,0)}concat(t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(this.size()===0)return wr([],[0].concat(this.elementShape));let e=[];for(let o=0;o<this.size();o++)e.push(o);let n=this.readMany(e);return Zn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),ct(n,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);let n=Math.max(...t);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(t,Wr(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let n=0,o=t.map(u=>(n+=u,n));if(n!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:e.size/n,a=[];U(()=>{e=$(e,[1,n,s]);for(let u=0;u<t.length;++u){let p=u===0?0:o[u-1],l=[0,p,0],m=[1,t[u],s];a[u]=$(Ge(e,l,m),this.elementShape)}return a});let i=[];for(let u=0;u<t.length;u++)i[u]=u;this.writeMany(i,a)}};var Tu=class{constructor(t,e,n,o=-1){this.tensors=t;this.elementShape=e;this.elementDtype=n;t?.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Zn(e,s.shape,"TensorList shape mismatch: "),Ut(s)}),this.idTensor=ce(0),this.maxNumElements=o,Ut(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Tu([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach(e=>{(t==null||!t.has(e.id))&&e.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,n=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Zn(t,this.elementShape,"TensorList shape mismatch: ");let o=ef(this.elementShape,this.tensors,t);return U(()=>{let s=this.tensors.map(a=>$(a,o));return Tr(s,0)})}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=ef(this.elementShape,this.tensors,t),o=this.tensors.pop();return o.kept=!1,Zn(o.shape,t,"TensorList shape mismatch: "),$(o,n)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(Zn(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Ut(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(this.maxNumElements!==-1&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);let e=new Tu([],this.elementShape,this.elementDtype,this.maxNumElements);e.tensors.length=t;for(let n=0;n<Math.min(this.tensors.length,t);++n)e.tensors[n]=this.tensors[n];return e}getItem(t,e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(this.tensors[t]==null)throw new Error(`element at index ${t} is null.`);Zn(this.tensors[t].shape,e,"TensorList shape mismatch: ");let o=ef(this.elementShape,this.tensors,e);return $(this.tensors[t],o)}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||this.maxNumElements!==-1&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);Zn(this.elementShape,e.shape,"TensorList shape mismatch: "),Ut(e),this.tensors[t]!=null&&(this.tensors[t].kept=!1),this.tensors[t]=e}gather(t,e,n){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);Zn(this.elementShape,n,"TensorList shape mismatch: "),t=t.slice(0,this.size());let o=ef(this.elementShape,this.tensors,n);return t.length===0?wr([],[0].concat(o)):U(()=>{let s=t.map(a=>$(this.tensors[a],o));return Tr(s,0)})}concat(t,e){if(!!t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);Zn(this.elementShape,e,"TensorList shape mismatch: ");let n=ef(this.elementShape,this.tensors,e);return this.size()===0?wr([],[0].concat(n)):U(()=>{let o=this.tensors.map(s=>$(s,n));return ct(o,0)})}};function g_(r,t,e){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==e)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${e}`);let o=r.shape.slice(1);Zn(o,t,"TensorList shape mismatch: ");let s=Wr(r);return new Tu(s,t,n)}function b_(r,t,e,n){return new Tu([],r,t,n)}function y_(r,t,e,n){if(t.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${r.shape[0]}`);let o=Math.max(...t);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new Tu([],e,r.dtype,n),a=Wr(r,0);return t.forEach((i,u)=>{s.setItem(i,a[u])}),s}function T_(r,t,e){let n=0,o=t.map(l=>(n+=l,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),a=hx(s,e),i=n===0?0:r.size/n,u=U(()=>{let l=[];r=$(r,[1,n,i]);for(let m=0;m<t.length;++m){let c=m===0?0:o[m-1],d=[0,c,0],f=[1,t[m],i];l[m]=$(Ge(r,d,f),a)}return r.dispose(),l}),p=new Tu([],e,r.dtype,t.length);for(let l=0;l<u.length;l++)p.setItem(l,u[l]);return p}var x_=async(r,t,e)=>{switch(r.op){case"If":case"StatelessIf":{let n=v("thenBranch",r,t,e),o=v("elseBranch",r,t,e),s=v("cond",r,t,e),a=v("args",r,t,e);return(await s.data())[0]?e.functionMap[n].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap):e.functionMap[o].executeFunctionAsync(a,e.tensorArrayMap,e.tensorListMap)}case"While":case"StatelessWhile":{let n=v("body",r,t,e),o=v("cond",r,t,e),s=v("args",r,t,e),a=await e.functionMap[o].executeFunctionAsync(s,e.tensorArrayMap,e.tensorListMap),i=s.map(l=>l.id),u=await a[0].data();a.forEach(l=>{!l.kept&&i.indexOf(l.id)===-1&&l.dispose()});let p=s;for(;u[0];){let l=p;p=await e.functionMap[n].executeFunctionAsync(p,e.tensorArrayMap,e.tensorListMap);let m=p.map(d=>d.id);l.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&m.indexOf(d.id)===-1&&d.dispose()});let c=await e.functionMap[o].executeFunctionAsync(p,e.tensorArrayMap,e.tensorListMap);u=await c[0].data(),c.forEach(d=>{!d.kept&&i.indexOf(d.id)===-1&&m.indexOf(d.id)===-1&&d.dispose()})}return p}case"LoopCond":{let n=v("pred",r,t,e);return[ri(n)]}case"Switch":{let n=v("pred",r,t,e),o=v("data",r,t,e);return o.kept||(o=ri(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>vr(o,t,e)!==void 0);if(n){let o=vr(n,t,e);return[ri(o)]}return}case"Enter":{let n=v("frameName",r,t,e),o=v("tensor",r,t,e);return e.enterFrame(n),[ri(o)]}case"Exit":{let n=v("tensor",r,t,e);return e.exitFrame(),[ri(n)]}case"NextIteration":{let n=v("tensor",r,t,e);return e.nextIteration(),[ri(n)]}case"TensorArrayV3":{let n=v("size",r,t,e),o=v("dtype",r,t,e),s=v("elementShape",r,t,e),a=v("dynamicSize",r,t,e),i=v("clearAfterRead",r,t,e),u=v("identicalElementShapes",r,t,e),p=v("name",r,t,e),l=new gx(p,o,n,s,u,a,i);return e.addTensorArray(l),[l.idTensor,ce(1)]}case"TensorArrayWriteV3":{let n=v("tensorArrayId",r,t,e),o=v("index",r,t,e),s=v("tensor",r,t,e),a=e.getTensorArray(n.id);return a.write(o,s),[a.idTensor]}case"TensorArrayReadV3":{let n=v("tensorArrayId",r,t,e),o=v("index",r,t,e);return[e.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=v("tensorArrayId",r,t,e),o=v("indices",r,t,e),s=v("dtype",r,t,e);return[e.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=v("tensorArrayId",r,t,e),o=v("indices",r,t,e),s=v("tensor",r,t,e),a=e.getTensorArray(n.id);return a.scatter(o,s),[a.idTensor]}case"TensorArrayConcatV3":{let n=v("tensorArrayId",r,t,e),o=e.getTensorArray(n.id),s=v("dtype",r,t,e);return[o.concat(s)]}case"TensorArraySplitV3":{let n=v("tensorArrayId",r,t,e),o=v("tensor",r,t,e),s=v("lengths",r,t,e),a=e.getTensorArray(n.id);return a.split(s,o),[a.idTensor]}case"TensorArraySizeV3":{let n=v("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return[ce(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=v("tensorArrayId",r,t,e),o=e.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=v("tensorListId",r,t,e),o=v("index",r,t,e),s=v("tensor",r,t,e),a=e.getTensorList(n.id);return a.setItem(o,s),[a.idTensor]}case"TensorListGetItem":{let n=v("tensorListId",r,t,e),o=v("index",r,t,e),s=v("elementShape",r,t,e),a=v("elementDType",r,t,e);return[e.getTensorList(n.id).getItem(o,s,a)]}case"TensorListScatterV2":case"TensorListScatter":{let n=v("indices",r,t,e),o=v("tensor",r,t,e),s=v("elementShape",r,t,e),a=v("numElements",r,t,e),i=y_(o,n,s,a);return e.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=v("elementShape",r,t,e),o=v("elementDType",r,t,e),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let a=v(s,r,t,e),i=r.op==="TensorListReserve"?-1:a,u=b_(n,o,a,i);return e.addTensorList(u),[u.idTensor]}case"TensorListGather":{let n=v("tensorListId",r,t,e),o=v("indices",r,t,e),s=v("elementShape",r,t,e),a=v("elementDType",r,t,e);return[e.getTensorList(n.id).gather(o,a,s)]}case"TensorListStack":{let n=v("tensorListId",r,t,e),o=v("elementShape",r,t,e),s=v("elementDType",r,t,e),a=v("numElements",r,t,e);return[e.getTensorList(n.id).stack(o,s,a)]}case"TensorListFromTensor":{let n=v("tensor",r,t,e),o=v("elementShape",r,t,e),s=v("elementDType",r,t,e),a=g_(n,o,s);return e.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{let n=v("tensorListId",r,t,e),o=e.getTensorList(n.id),s=v("dtype",r,t,e),a=v("elementShape",r,t,e);return[o.concat(s,a)]}case"TensorListPushBack":{let n=v("tensorListId",r,t,e),o=v("tensor",r,t,e),s=e.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=v("tensorListId",r,t,e),o=v("elementShape",r,t,e),s=v("elementDType",r,t,e);return[e.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=v("tensor",r,t,e),o=v("elementShape",r,t,e),s=v("lengths",r,t,e),a=T_(n,s,o);return e.addTensorList(a),[a.idTensor]}case"TensorListLength":{let n=v("tensorListId",r,t,e),o=e.getTensorList(n.id);return[ce(o.size(),"int32")]}case"TensorListResize":{let n=v("tensorListId",r,t,e),o=v("size",r,t,e),a=e.getTensorList(n.id).resize(o);return e.addTensorList(a),[a.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function I_(r,t,e){let[n,o]=v("fusedOps",r,t,e),s=n==="biasadd",a=!s,i=o==="prelu",u=n==="fusedbatchnorm",p=v("numArgs",r,t,e);if(s){if(i&&p!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&p!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let l=v("strides",r,t,e),m=rg(r,t,e),c=v("dataFormat",r,t,e).toUpperCase(),d=v("dilations",r,t,e),[f,h]=v("args",r,t,e);a&&(h=f,f=void 0);let g=v("leakyreluAlpha",r,t,e);return{stride:l,pad:m,dataFormat:c,dilations:d,biasArg:f,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var C_=(r,t,e,n=dt)=>{switch(r.op){case"Conv1D":{let o=v("stride",r,t,e),s=v("pad",r,t,e),a=v("dataFormat",r,t,e).toUpperCase(),i=v("dilation",r,t,e);return[n.conv1d(v("x",r,t,e),v("filter",r,t,e),o,s,a,i)]}case"Conv2D":{let o=v("strides",r,t,e),s=rg(r,t,e),a=v("dataFormat",r,t,e).toUpperCase(),i=v("dilations",r,t,e);return[n.conv2d(v("x",r,t,e),v("filter",r,t,e),[o[1],o[2]],s,a,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:o,pad:s,dataFormat:a,dilations:i,biasArg:u,preluArg:p,activationFunc:l,leakyreluAlpha:m}=I_(r,t,e);return[n.fused.conv2d({x:v("x",r,t,e),filter:v("filter",r,t,e),strides:[o[1],o[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:p,leakyreluAlpha:m})]}case"FusedDepthwiseConv2dNative":{let{stride:o,pad:s,dataFormat:a,dilations:i,biasArg:u,preluArg:p,activationFunc:l,leakyreluAlpha:m}=I_(r,t,e);return[n.fused.depthwiseConv2d({x:v("x",r,t,e),filter:v("filter",r,t,e),strides:[o[1],o[2]],pad:s,dataFormat:a,dilations:[i[1],i[2]],bias:u,activation:l,preluActivationWeights:p,leakyreluAlpha:m})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let o=v("outputShape",r,t,e),s=v("strides",r,t,e),a=rg(r,t,e);return[n.conv2dTranspose(v("x",r,t,e),v("filter",r,t,e),o,[s[1],s[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let o=v("strides",r,t,e),s=rg(r,t,e),a=v("dilations",r,t,e),i=v("dataFormat",r,t,e).toUpperCase();return[n.depthwiseConv2d(v("input",r,t,e),v("filter",r,t,e),[o[1],o[2]],s,i,[a[1],a[2]])]}case"Conv3D":{let o=v("strides",r,t,e),s=v("pad",r,t,e),a=v("dataFormat",r,t,e).toUpperCase(),i=v("dilations",r,t,e);return[n.conv3d(v("x",r,t,e),v("filter",r,t,e),[o[1],o[2],o[3]],s,a,[i[1],i[2],i[3]])]}case"AvgPool":{let o=v("strides",r,t,e),s=v("pad",r,t,e),a=v("kernelSize",r,t,e);return[n.avgPool(v("x",r,t,e),[a[1],a[2]],[o[1],o[2]],s)]}case"MaxPool":{let o=v("strides",r,t,e),s=v("pad",r,t,e),a=v("kernelSize",r,t,e);return[n.maxPool(v("x",r,t,e),[a[1],a[2]],[o[1],o[2]],s)]}case"MaxPoolWithArgmax":{let o=v("strides",r,t,e),s=v("pad",r,t,e),a=v("kernelSize",r,t,e),i=v("includeBatchInIndex",r,t,e),{result:u,indexes:p}=n.maxPoolWithArgmax(v("x",r,t,e),[a[1],a[2]],[o[1],o[2]],s,i);return[u,p]}case"AvgPool3D":{let o=v("strides",r,t,e),s=v("pad",r,t,e),a=v("kernelSize",r,t,e);return[n.avgPool3d(v("x",r,t,e),[a[1],a[2],a[3]],[o[1],o[2],o[3]],s)]}case"MaxPool3D":{let o=v("strides",r,t,e),s=v("pad",r,t,e),a=v("kernelSize",r,t,e);return[n.maxPool3d(v("x",r,t,e),[a[1],a[2],a[3]],[o[1],o[2],o[3]],s)]}case"Dilation2D":{let o=v("strides",r,t,e),s=v("pad",r,t,e),a=v("dilations",r,t,e),i=o[1],u=o[2],p=a[1],l=a[2];return[n.dilation2d(v("x",r,t,e),v("filter",r,t,e),[i,u],s,[p,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var k_=(r,t,e,n=dt)=>{switch(r.op){case"Fill":{let o=v("shape",r,t,e),s=v("dtype",r,t,e),a=v("value",r,t,e);return[n.fill(o,a,s)]}case"LinSpace":{let o=v("start",r,t,e),s=v("stop",r,t,e),a=v("num",r,t,e);return[n.linspace(o,s,a)]}case"Multinomial":{let o=v("logits",r,t,e),s=v("numSamples",r,t,e),a=v("seed",r,t,e);return[n.multinomial(o,s,a)]}case"OneHot":{let o=v("indices",r,t,e),s=v("depth",r,t,e),a=v("onValue",r,t,e),i=v("offValue",r,t,e),u=v("dtype",r,t,e);return[n.oneHot(o,s,a,i,u)]}case"Ones":return[n.ones(v("shape",r,t,e),v("dtype",r,t,e))];case"OnesLike":return[n.onesLike(v("x",r,t,e))];case"RandomStandardNormal":return[n.randomStandardNormal(v("shape",r,t,e),v("dtype",r,t,e),v("seed",r,t,e))];case"RandomUniform":return[n.randomUniform(v("shape",r,t,e),v("minval",r,t,e),v("maxval",r,t,e),v("dtype",r,t,e))];case"Range":{let o=v("start",r,t,e),s=v("stop",r,t,e),a=v("step",r,t,e);return[n.range(o,s,a,v("dtype",r,t,e))]}case"TruncatedNormal":{let o=v("shape",r,t,e),s=v("mean",r,t,e),a=v("stdDev",r,t,e),i=v("seed",r,t,e);return[n.truncatedNormal(o,s,a,v("dtype",r,t,e),i)]}case"Zeros":return[n.zeros(v("shape",r,t,e),v("dtype",r,t,e))];case"ZerosLike":return[n.zerosLike(v("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Fw(r,t,e){let n=v("boxes",r,t,e),o=v("scores",r,t,e),s=v("maxOutputSize",r,t,e),a=v("iouThreshold",r,t,e),i=v("scoreThreshold",r,t,e),u=v("softNmsSigma",r,t,e);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:a,scoreThreshold:i,softNmsSigma:u}}var S_=async(r,t,e,n,o=dt)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:p,softNmsSigma:l}=Fw(r,t,e),m=await o.image.nonMaxSuppressionWithScoreAsync(s,a,i,u,p,l);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:p}=Fw(r,t,e),l=v("padToMaxOutputSize",r,t,e),m=await o.image.nonMaxSuppressionPaddedAsync(s,a,i,u,p,l);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:s,scores:a,maxOutputSize:i,iouThreshold:u,scoreThreshold:p}=Fw(r,t,e);return[await o.image.nonMaxSuppressionAsync(s,a,i,u,p)]}case"Where":{let s=o.cast(v("condition",r,t,e),"bool"),a=[await o.whereAsync(s)];return s.dispose(),a}case"ListDiff":return o.setdiff1dAsync(v("x",r,t,e),v("y",r,t,e));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var v_=(r,t,e,n=dt)=>{switch(r.op){case"LowerBound":{let o=v("sortedSequence",r,t,e),s=v("values",r,t,e);return[n.lowerBound(o,s)]}case"TopKV2":{let o=v("x",r,t,e),s=v("k",r,t,e),a=v("sorted",r,t,e),i=n.topk(o,s,a);return[i.values,i.indices]}case"UpperBound":{let o=v("sortedSequence",r,t,e),s=v("values",r,t,e);return[n.upperBound(o,s)]}case"Unique":{let o=v("x",r,t,e),s=n.unique(o);return[s.values,s.indices]}case"UniqueV2":{let o=v("x",r,t,e),s=v("axis",r,t,e),a=n.unique(o,s);return[a.values,a.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var A_=(r,t,e,n=dt)=>{switch(r.op){case"Const":return t[r.name];case"PlaceholderWithDefault":let o=v("default",r,t,e);return[vr(r.name,t,e)||o];case"Placeholder":return[vr(r.name,t,e)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=v("x",r,t,e);return[ri(l)]}case"IdentityN":return v("x",r,t,e).map(l=>ri(l));case"Snapshot":let s=v("x",r,t,e);return[ri(s)];case"Shape":return[n.tensor1d(v("x",r,t,e).shape,"int32")];case"ShapeN":return v("x",r,t,e).map(l=>n.tensor1d(l.shape));case"Size":return[n.scalar(v("x",r,t,e).size,"int32")];case"Rank":return[n.scalar(v("x",r,t,e).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":let a=v("x",r,t,e),i=v("data",r,t,e),u=v("message",r,t,e),p=v("summarize",r,t,e);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,p));return[a];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var bx=class{constructor(t,e){this.keyDType=t;this.valueDType=e;this.handle=ce(0),this.tensorMap=new Map,Ut(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(t=>t.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return ce(this.size(),"int32")}async import(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),U(()=>{let o=Wr(e),s=n.length,a=o.length;y.assert(s===a,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${a} elements.`);for(let i=0;i<s;i++){let u=n[i],p=o[i];Ut(p),this.tensorMap.set(u,p)}return this.handle})}async find(t,e){this.checkKeyAndValueTensor(t,e);let n=await t.data();return U(()=>{let o=[];for(let s=0;s<n.length;s++){let a=n[s],i=this.findWithDefault(a,e);o.push(i)}return Tr(o)})}findWithDefault(t,e){let n=this.tensorMap.get(t);return n??e}checkKeyAndValueTensor(t,e){if(t.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${t.dtype}`);if(e.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${e.dtype}`)}};var w_=async(r,t,e,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=v("keyDType",r,t,e),s=v("valueDType",r,t,e),a=new bx(o,s);return n.addHashTable(r.name,a),[a.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=v("tableHandle",r,t,e,n),s=v("keys",r,t,e),a=v("values",r,t,e);return[await n.getHashTableById(o.id).import(s,a)]}case"LookupTableFind":case"LookupTableFindV2":{let o=v("tableHandle",r,t,e,n),s=v("keys",r,t,e),a=v("defaultValue",r,t,e);return[await n.getHashTableById(o.id).find(s,a)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=v("tableHandle",r,t,e,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var N_=(r,t,e,n=dt)=>{switch(r.op){case"ResizeBilinear":{let o=v("images",r,t,e),s=v("size",r,t,e),a=v("alignCorners",r,t,e),i=v("halfPixelCenters",r,t,e);return[n.image.resizeBilinear(o,[s[0],s[1]],a,i)]}case"ResizeNearestNeighbor":{let o=v("images",r,t,e),s=v("size",r,t,e),a=v("alignCorners",r,t,e),i=v("halfPixelCenters",r,t,e);return[n.image.resizeNearestNeighbor(o,[s[0],s[1]],a,i)]}case"CropAndResize":{let o=v("image",r,t,e),s=v("boxes",r,t,e),a=v("boxInd",r,t,e),i=v("cropSize",r,t,e),u=v("method",r,t,e),p=v("extrapolationValue",r,t,e);return[n.image.cropAndResize(o,s,a,i,u,p)]}case"ImageProjectiveTransformV3":{let o=v("images",r,t,e),s=v("transforms",r,t,e),a=v("outputShape",r,t,e),i=v("fillValue",r,t,e),u=v("interpolation",r,t,e),p=v("fillMode",r,t,e);return[n.image.transform(o,s,u.toLowerCase(),p.toLowerCase(),i,a)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var D_=(r,t,e,n=dt)=>{switch(r.op){case"Equal":return[n.equal(v("a",r,t,e),v("b",r,t,e))];case"NotEqual":return[n.notEqual(v("a",r,t,e),v("b",r,t,e))];case"Greater":return[n.greater(v("a",r,t,e),v("b",r,t,e))];case"GreaterEqual":return[n.greaterEqual(v("a",r,t,e),v("b",r,t,e))];case"Less":return[n.less(v("a",r,t,e),v("b",r,t,e))];case"LessEqual":return[n.lessEqual(v("a",r,t,e),v("b",r,t,e))];case"LogicalAnd":return[n.logicalAnd(v("a",r,t,e),v("b",r,t,e))];case"LogicalNot":return[n.logicalNot(v("a",r,t,e))];case"LogicalOr":return[n.logicalOr(v("a",r,t,e),v("b",r,t,e))];case"Select":case"SelectV2":return[n.where(v("condition",r,t,e),v("a",r,t,e),v("b",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var F_=(r,t,e,n=dt)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(v("a",r,t,e),v("b",r,t,e),v("transposeA",r,t,e),v("transposeB",r,t,e))];case"Einsum":return[n.einsum(v("equation",r,t,e),...v("tensors",r,t,e))];case"Transpose":return[n.transpose(v("x",r,t,e),v("perm",r,t,e))];case"_FusedMatMul":let[o,s]=v("fusedOps",r,t,e),a=o==="biasadd",i=s==="prelu",u=v("numArgs",r,t,e),p=v("leakyreluAlpha",r,t,e);if(a){if(i&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,m]=v("args",r,t,e);return[n.fused.matMul({a:v("a",r,t,e),b:v("b",r,t,e),transposeA:v("transposeA",r,t,e),transposeB:v("transposeB",r,t,e),bias:l,activation:s,preluActivationWeights:m,leakyreluAlpha:p})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var R_=(r,t,e,n=dt)=>{switch(r.op){case"EuclideanNorm":return[n.euclideanNorm(v("x",r,t,e),v("axis",r,t,e),v("keepDims",r,t,e))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(v("x",r,t,e),v("mean",r,t,e),v("variance",r,t,e),v("offset",r,t,e),v("scale",r,t,e),v("epsilon",r,t,e))];case"FusedBatchNormV3":return[n.batchNorm(v("x",r,t,e),v("mean",r,t,e),v("variance",r,t,e),v("offset",r,t,e),v("scale",r,t,e),v("epsilon",r,t,e))];case"LRN":return[n.localResponseNormalization(v("x",r,t,e),v("radius",r,t,e),v("bias",r,t,e),v("alpha",r,t,e),v("beta",r,t,e))];case"Softmax":return[n.softmax(v("x",r,t,e))];case"LogSoftmax":return[n.logSoftmax(v("x",r,t,e))];case"SparseToDense":return[n.sparseToDense(v("sparseIndices",r,t,e),v("outputShape",r,t,e),v("sparseValues",r,t,e),v("defaultValue",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var P_=(r,t,e,n=dt)=>{switch(r.op){case"Max":{let i=v("axis",r,t,e),u=v("keepDims",r,t,e);return[n.max(v("x",r,t,e),i,u)]}case"Mean":{let i=v("axis",r,t,e),u=v("keepDims",r,t,e);return[n.mean(v("x",r,t,e),i,u)]}case"Min":{let i=v("axis",r,t,e),u=v("keepDims",r,t,e);return[n.min(v("x",r,t,e),i,u)]}case"Sum":{let i=v("axis",r,t,e),u=v("keepDims",r,t,e);return[n.sum(v("x",r,t,e),i,u)]}case"All":{let i=v("axis",r,t,e),u=v("keepDims",r,t,e);return[n.all(v("x",r,t,e),i,u)]}case"Any":{let i=v("axis",r,t,e),u=v("keepDims",r,t,e);return[n.any(v("x",r,t,e),i,u)]}case"ArgMax":{let i=v("axis",r,t,e);return[n.argMax(v("x",r,t,e),i)]}case"ArgMin":{let i=v("axis",r,t,e);return[n.argMin(v("x",r,t,e),i)]}case"Prod":{let i=v("axis",r,t,e),u=v("keepDims",r,t,e);return[n.prod(v("x",r,t,e),i,u)]}case"Cumprod":{let i=v("axis",r,t,e),u=v("exclusive",r,t,e),p=v("reverse",r,t,e);return[n.cumprod(v("x",r,t,e),i,u,p)]}case"Cumsum":{let i=v("axis",r,t,e),u=v("exclusive",r,t,e),p=v("reverse",r,t,e);return[n.cumsum(v("x",r,t,e),i,u,p)]}case"Bincount":let o=v("x",r,t,e),s=v("weights",r,t,e),a=v("size",r,t,e);return[n.bincount(o,s,a)];case"DenseBincount":{let i=v("x",r,t,e),u=v("weights",r,t,e),p=v("size",r,t,e),l=v("binaryOutput",r,t,e);return[n.denseBincount(i,u,p,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var M_=(r,t,e,n=dt)=>{switch(r.op){case"ConcatV2":case"Concat":{let o=v("n",r,t,e),s=v("axis",r,t,e),a=v("tensors",r,t,e);return a=a.slice(0,o),[n.concat(a,s)]}case"Gather":{let o=v("x",r,t,e),s=v("indices",r,t,e);return[n.gather(o,n.cast(s,"int32"),0)]}case"GatherV2":{let o=v("axis",r,t,e),s=v("batchDims",r,t,e),a=v("x",r,t,e),i=v("indices",r,t,e);return[n.gather(a,n.cast(i,"int32"),o,s)]}case"Reverse":{let o=v("dims",r,t,e),s=[];for(let i=0;i<o.length;i++)o[i]&&s.push(i);let a=v("x",r,t,e);return[n.reverse(a,s)]}case"ReverseV2":{let o=v("axis",r,t,e),s=v("x",r,t,e);return[n.reverse(s,o)]}case"Slice":{let o=v("begin",r,t,e),s=v("size",r,t,e);return[n.slice(v("x",r,t,e),o,s)]}case"StridedSlice":{let o=v("begin",r,t,e),s=v("end",r,t,e),a=v("strides",r,t,e),i=v("beginMask",r,t,e),u=v("endMask",r,t,e),p=v("ellipsisMask",r,t,e),l=v("newAxisMask",r,t,e),m=v("shrinkAxisMask",r,t,e),c=v("x",r,t,e);return[n.stridedSlice(c,o,s,a,i,u,p,l,m)]}case"Pack":return U(()=>{let o=v("axis",r,t,e),s=v("tensors",r,t,e),a=s[0].shape,i=n.squeeze(s[0]).shape,u=s.map(p=>{let l=y.arraysEqual(p.shape,a);if(!l&&!y.arraysEqual(n.squeeze(p).shape,i))throw new Error("the input tensors shape does not match");return l?p:n.reshape(p,a)});return[n.stack(u,o)]});case"Unpack":{let o=v("axis",r,t,e),s=v("tensor",r,t,e);return n.unstack(s,o)}case"Tile":{let o=v("reps",r,t,e);return[n.tile(v("x",r,t,e),o)]}case"Split":case"SplitV":{let o=v("axis",r,t,e),s=v("numOrSizeSplits",r,t,e),a=v("x",r,t,e);return n.split(a,s,o)}case"ScatterNd":{let o=v("indices",r,t,e),s=v("values",r,t,e),a=v("shape",r,t,e);return[n.scatterND(o,s,a)]}case"GatherNd":{let o=v("x",r,t,e),s=v("indices",r,t,e);return[n.gatherND(o,s)]}case"SparseToDense":{let o=v("sparseIndices",r,t,e),s=v("outputShape",r,t,e),a=v("sparseValues",r,t,e),i=v("defaultValue",r,t,e);return[n.sparseToDense(o,a,s,a.dtype===i.dtype?i:n.cast(i,a.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var E_=(r,t,e,n=dt)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:o,outputValues:s,emptyRowIndicator:a,reverseIndexMap:i}=n.sparse.sparseFillEmptyRows(v("indices",r,t,e),v("values",r,t,e),v("denseShape",r,t,e),v("defaultValue",r,t,e));return[o,s,a,i]}case"SparseReshape":{let{outputIndices:o,outputShape:s}=n.sparse.sparseReshape(v("inputIndices",r,t,e),v("inputShape",r,t,e),v("newShape",r,t,e));return[o,s]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(v("data",r,t,e),v("indices",r,t,e),v("segmentIds",r,t,e))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(v("data",r,t,e),v("indices",r,t,e),v("segmentIds",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var __=(r,t,e,n=dt)=>{switch(r.op){case"FFT":return[n.fft(v("x",r,t,e))];case"IFFT":return[n.ifft(v("x",r,t,e))];case"RFFT":return[n.rfft(v("x",r,t,e))];case"IRFFT":return[n.irfft(v("x",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var L_=(r,t,e,n=dt)=>{switch(r.op){case"StringNGrams":{let{nGrams:o,nGramsSplits:s}=n.string.stringNGrams(v("data",r,t,e),v("dataSplits",r,t,e),v("separator",r,t,e),v("nGramWidths",r,t,e),v("leftPad",r,t,e),v("rightPad",r,t,e),v("padWidth",r,t,e),v("preserveShortSequences",r,t,e));return[o,s]}case"StringSplit":{let{indices:o,values:s,shape:a}=n.string.stringSplit(v("input",r,t,e),v("delimiter",r,t,e),v("skipEmpty",r,t,e));return[o,s,a]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(v("input",r,t,e),v("numBuckets",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var $_=(r,t,e,n=dt)=>{switch(r.op){case"Cast":return[n.cast(v("x",r,t,e),v("dtype",r,t,e))];case"ExpandDims":{let o=v("axis",r,t,e);return[n.expandDims(v("x",r,t,e),o)]}case"Squeeze":{let o=v("axis",r,t,e);return[n.squeeze(v("x",r,t,e),o)]}case"Reshape":return[n.reshape(v("x",r,t,e),v("shape",r,t,e))];case"MirrorPad":return[n.mirrorPad(v("x",r,t,e),v("padding",r,t,e),v("mode",r,t,e))];case"PadV2":case"Pad":return[n.pad(v("x",r,t,e),v("padding",r,t,e),v("constantValue",r,t,e))];case"SpaceToBatchND":{let o=v("blockShape",r,t,e),s=v("paddings",r,t,e);return[n.spaceToBatchND(v("x",r,t,e),o,s)]}case"BatchToSpaceND":{let o=v("blockShape",r,t,e),s=v("crops",r,t,e);return[n.batchToSpaceND(v("x",r,t,e),o,s)]}case"DepthToSpace":{let o=v("blockSize",r,t,e),s=v("dataFormat",r,t,e).toUpperCase();return[n.depthToSpace(v("x",r,t,e),o,s)]}case"BroadcastTo":return[n.broadcastTo(v("x",r,t,e),v("shape",r,t,e))];case"BroadcastArgs":return[n.broadcastArgs(v("s0",r,t,e),v("s1",r,t,e))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Rw(r,t,e,n,o=U){let s=((a,i,u)=>{switch(a.category){case"arithmetic":return o(()=>d_(a,i,u));case"basic_math":return o(()=>f_(a,i,u));case"control":return x_(a,i,u);case"convolution":return o(()=>C_(a,i,u));case"creation":return o(()=>k_(a,i,u));case"dynamic":return S_(a,i,u);case"evaluation":return o(()=>v_(a,i,u));case"image":return o(()=>N_(a,i,u));case"graph":return o(()=>A_(a,i,u));case"logical":return o(()=>D_(a,i,u));case"matrices":return o(()=>F_(a,i,u));case"normalization":return o(()=>R_(a,i,u));case"reduction":return o(()=>P_(a,i,u));case"slice_join":return o(()=>M_(a,i,u));case"sparse":return o(()=>E_(a,i,u));case"spectral":return o(()=>__(a,i,u));case"string":return o(()=>L_(a,i,u));case"transformation":return o(()=>$_(a,i,u));case"hash_table":return w_(a,i,u,n);case"custom":let p=rx(a.op);if(p&&p.customExecutor)return p.customExecutor(new fx(a,i,u));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,t,e);return y.isPromise(s)?s.then(a=>[].concat(a)):[].concat(s)}var og=class{constructor(t={},e={},n={},o={}){this.weightMap=t;this.tensorArrayMap=e;this.tensorListMap=n;this.functionMap=o;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let t=[];for(let e=0;e<this.contexts.length-1;e++){let n=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(n))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map(e=>e.id===0&&e.iterationId===0?"":`${e.frameName}-${e.iterationId}`).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(let e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(let e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}};function Pw(r,t,e,n){let o=new Set,s=[],a=null,i=null,u=new Set,p=Object.keys(r).map(c=>kn(c)[0]),l=[];n!=null&&(l=n.map(c=>kn(c.name)[0]));let m=[...t];for(;m.length>0;){let c=m.pop();if((Mw(c)||ure(c)||pre(c))&&a==null&&(a=c,i=a.children.map(d=>d.name).filter(d=>o.has(d))),o.add(c.name),e[c.name]==null&&p.indexOf(c.name)===-1&&l.indexOf(c.name)===-1){if(c.inputs.length===0){s.push(c.name);continue}c.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),m.push(d))})}}return{inputs:r,outputs:t,usedNodes:o,missingInputs:s,dynamicNode:a,syncInputs:i}}function B_(r,t,e){let{usedNodes:n,inputs:o}=e,s=[],a=Object.keys(o).map(l=>kn(l)[0]).map(l=>r.nodes[l]),i=r.initNodes;a.forEach(l=>{n.has(l.name)&&s.push(l)}),r.weights.forEach(l=>{n.has(l.name)&&s.push(l)}),i?.forEach(l=>{n.has(l.name)&&s.push(l)});let u=new Set,p=[];for(;s.length>0;){let l=s.pop();u.add(l.name),t[l.name]||p.push(l),l.children.forEach(m=>{!u.has(m.name)&&n.has(m.name)&&m.inputs.every(c=>u.has(c.name))&&s.push(m)})}return p}var sre=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],are=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],ire=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function Mw(r){return sre.indexOf(r.op)>=0}function ure(r){return are.indexOf(r.op)>=0}function pre(r){return ire.indexOf(r.op)>=0}var Bl=class{constructor(t,e){this.graph=t;this.parent=e;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this._functions={};this._functionExecutorMap={};this.intermediateTensors={};this.keepTensorForDebug=!1;this._outputs=t.outputs,this._inputs=t.inputs,this._initNodes=t.initNodes,this._signature=t.signature,this._functions=t.functions,t.functions!=null&&Object.keys(t.functions).forEach(n=>{this._functionExecutorMap[n]=new Bl(t.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){let e=Object.keys(t).map(n=>t[n].map(o=>o.id));this._weightIds=[].concat(...e),this._weightMap=t}set resourceManager(t){this._resourceManager=t}get inputs(){return this._inputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(t=>t.signatureKey||t.name)}get outputNodes(){return this._outputs.map(t=>{let e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e})}get functions(){return Object.keys(this._functions).reduce((t,e)=>(t[e]=this._functions[e].signature,t),{})}getCompilationKey(t,e){let n=t.map(s=>s.name).sort(),o=e.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(t,e){let n=Pw(t,e,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:a}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(o.length>0){let i=e.map(p=>p.name),u=Object.keys(t);throw new Error(`Cannot compute the outputs [${i}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return B_(this.graph,this.weightMap,n)}execute(t,e){t=this.mapInputs(t);let n=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);let o=n.map(m=>this.graph.nodes[kn(m)[0]]),s=e.map(m=>kn(m)[0]),a=s.map(m=>this.graph.nodes[m]);this.resetIntermediateTensors(),a.length===0&&(a=this._outputs);let i=this.getCompilationKey(o,a),u=this.compiledMap.get(i);u==null&&(u=this.compile(t,a),this.compiledMap.set(i,u));let p={},l={};return U(()=>{let m=new og(this.weightMap,p,l,this.functionExecutorMap),c={...this.weightMap};Object.keys(t).forEach(h=>{let[g,b]=kn(h),T=[];T[b]=t[h],c[g]=T});let d=this.getFrozenTensorIds(c),f={};for(let h=0;h<u.length;h++){let g=u[h];if(!c[g.name]){let b=Rw(g,c,m,this._resourceManager);if(y.isPromise(b))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);c[g.name]=b,this.checkTensorForDisposal(g.name,g,c,m,d,s,f)}}return this.parent==null&&m.dispose(d),e.map(h=>vr(h,c,m))})}getFrozenTensorIds(t){let e=[].concat.apply([],Object.keys(t).map(n=>t[n]).map(n=>n.map(o=>o.id)));return new Set(e)}checkTensorForDisposal(t,e,n,o,s,a,i){e.category==="control"||a.indexOf(t)!==-1||(n[t].forEach(u=>{u!=null&&(i[u.id]=(i[u.id]||0)+e.children.length)}),e.inputs.forEach(u=>{if(u.category!=="control"){let p=p_(u.name,n,o);p?.forEach(l=>{if(l&&!l.kept&&!s.has(l.id)){let m=i[l.id];if(m===1){if(!this.keepTensorForDebug)l.dispose();else{let[c,d]=Vs(e.name,o);this.intermediateTensors[c]?this.intermediateTensors[c][d]=l:(this.intermediateTensors[c]=[],this.intermediateTensors[c][d]=l)}delete i[l.id]}else m!=null&&i[l.id]--}})}}))}async executeAsync(t,e){return this._executeAsync(t,e)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(t=>this.intermediateTensors[t].forEach(e=>e.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(t=>{this.tensorsMap[t].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let t in this.intermediateTensors)this.intermediateTensors[t].forEach(e=>e.dispose()),delete this.intermediateTensors[t]}async _executeAsync(t,e,n=!1,o={},s={}){n||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));try{this.keepTensorForDebug=B().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(l){console.warn(l.message)}this.resetIntermediateTensors();let a=new og(this.weightMap,o,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(t,a,e,n);let i=e.map(l=>vr(l,this.tensorsMap,a)),u=i.map(l=>l.id),p=Object.keys(t).map(l=>t[l].id);return this.keepIds=new Set([...u,...p,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&a.dispose(this.keepIds),i}async executeFunctionAsync(t,e,n){let o=t.reduce((s,a,i)=>(s[this.inputs[i].name]=a,s),{});return this._executeAsync(o,this.outputNodes,!0,e,n)}async executeWithControlFlow(t,e,n,o){let s=Object.keys(t),a=s.map(x=>this.graph.nodes[kn(x)[0]]),i=n.map(x=>kn(x)[0]),u=i.map(x=>this.graph.nodes[x]);u.length===0&&(u=this._outputs);let{usedNodes:p,missingInputs:l,dynamicNode:m,syncInputs:c}=Pw(t,u,this.weightMap,this._initNodes),d=[...a,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:e.currentContext})),f={...this.weightMap};Object.keys(t).forEach(x=>{let[I,k]=kn(x),w=[];w[k]=t[x],f[I]=w});let h={},g=this.getFrozenTensorIds(f),b={};for(;d.length>0;){let x=this.processStack(a,d,e,f,b,g,i,h,p);await Promise.all(x)}m==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let T=u.filter(x=>!Mw(x)&&!vr(x.name,f,e)).map(x=>x.name);if(T.length>0){let x="";throw m!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${c}]`),new Error(`Cannot compute the outputs [${T}] from the provided inputs [${s}]. Consider providing the following inputs: [${l}]. ${x}`)}return f}processStack(t,e,n,o,s,a,i,u,p){let l=[];for(;e.length>0;){let m=e.pop();n.currentContext=m.contexts;let c="";if(m.node.op==="Enter"&&v("isConstant",m.node,o,n)&&([c]=Vs(m.node.name,n)),o[m.node.name]==null){let d=Rw(m.node,o,n,this._resourceManager);c||([c]=Vs(m.node.name,n));let f=n.currentContext;y.isPromise(d)?l.push(d.then(h=>(o[c]=h,n.currentContext=f,this.checkTensorForDisposal(c,m.node,o,n,a,i,u),this.processChildNodes(m.node,e,n,o,s,p),h))):(o[c]=d,this.checkTensorForDisposal(c,m.node,o,n,a,i,u),this.processChildNodes(m.node,e,n,o,s,p))}else this.processChildNodes(m.node,e,n,o,s,p)}return l}processChildNodes(t,e,n,o,s,a){t.children.forEach(i=>{let[u]=Vs(i.name,n);s[u]||!a.has(i.name)||(i.op==="Merge"?i.inputNames.some(p=>!!vr(p,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:i})):i.inputNames.every(p=>!!vr(p,o,n))&&(s[u]=!0,e.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(t=>this.weightMap[t].forEach(e=>e.dispose()))}checkInputShapeAndType(t){Object.keys(t).forEach(e=>{let n=t[e],[o]=kn(e),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let a=s.attrParams.shape.value,i=a.length===n.shape.length&&n.shape.every((u,p)=>a[p]===-1||a[p]===u);y.assert(i,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${a}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&y.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(t){let e={};for(let n in t)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];e[o.name]=t[n]}else e[n]=t[n];return e}checkInputs(t){let e=Object.keys(t).filter(n=>{let[o]=kn(n);return this.graph.nodes[o]==null});if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map(e=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[e]!=null?this._signature.outputs[e].name:e,{})}checkOutputs(t){t.forEach(e=>{let[n]=kn(e);if(!this.graph.nodes[n])throw new Error(`The output '${e}' is not found in the graph`)})}};var yx=class{constructor(t={},e={}){this.hashTableNameToHandle=t;this.hashTableMap=e}addHashTable(t,e){this.hashTableNameToHandle[t]=e.handle,this.hashTableMap[e.id]=e}getHashTableHandleByName(t){return this.hashTableNameToHandle[t]}getHashTableById(t){return this.hashTableMap[t]}dispose(){for(let t in this.hashTableMap)this.hashTableMap[t].clearAndClose(),delete this.hashTableMap[t];for(let t in this.hashTableNameToHandle)this.hashTableNameToHandle[t].dispose(),delete this.hashTableNameToHandle[t]}};var lre="?tfjs-format=file",mre="model.json",sg=class{constructor(t,e={},n=Pn){this.modelUrl=t;this.loadOptions=e;this.version="n/a";this.io=n,e==null&&(this.loadOptions={}),this.resourceManager=new yx}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){let t=this.modelUrl;if(t.load!=null)this.handler=t;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(t,this.loadOptions);else{let e=this.io.getLoadHandlers(t,this.loadOptions);if(e.length===0)e.push(this.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let t=this.handler.load();return y.isPromise(t)?t.then(e=>this.loadSync(e)):this.loadSync(t)}loadSync(t){this.artifacts=t;let e=this.artifacts.modelTopology,n=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){let s=this.artifacts.userDefinedMetadata;s.signature!=null&&(n=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=n,this.version=`${e.versions.producer}.${e.versions.minConsumer}`;let o=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Bl(ng.Instance.transformGraph(e,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,t.modelInitializer!=null&&t.modelInitializer.node!=null){let s=ng.Instance.transformGraph(t.modelInitializer);this.initializer=new Bl(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(t,e){if(typeof t=="string"){let n=this.io.getSaveHandlers(t);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${t}'`);t=n[0]}if(t.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){let n=this.execute(t,this.outputNodes);if(this.structuredOutputKeys){let o=n instanceof qe?[n]:n,s={};return o.forEach((a,i)=>s[this.structuredOutputKeys[i]]=a),s}return n}normalizeInputs(t){if(!(t instanceof qe)&&!Array.isArray(t))return t;if(t=Array.isArray(t)?t:[t],t.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce((e,n,o)=>(e[n]=t[o],e),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=this.executor.execute(t,e);return n.length>1?n:n[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);let n=await this.executor.executeAsync(t,e);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce((e,n)=>(e[n]=[t[n]],e),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function cre(r,t={},e=Pn){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");t==null&&(t={}),t.fromTFHub&&typeof r=="string"&&(r=fre(r));let n=new sg(r,t,e);return await n.load(),n}function dre(r){if(r==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide a url or an IOHandler that loads the model");if(!r.load)throw new Error(`modelUrl IO Handler ${r} has no load function`);let t=new sg(r);return t.load(),t}function fre(r){return r.endsWith("/")||(r=r+"/"),`${r}${mre}${lre}`}var hre="0.0.0";var sL={};Xe(sL,{CSVDataset:()=>nf,Dataset:()=>ni,FileDataSource:()=>pf,TextLineDataset:()=>rf,URLDataSource:()=>lf,array:()=>j_,csv:()=>J_,func:()=>eL,generator:()=>tL,microphone:()=>nL,version_data:()=>oL,webcam:()=>rL,zip:()=>X_});var q_=wm(_h());var K_=wm(_h());function O_(r,t){return Tx(r,t)}function Tx(r,t,e=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(e.has(r))return e.get(r);let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(Dp(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let i=r[a],u=Tx(i,t,e,n);s[a]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return e.set(r,o.value),o.value}function z_(r,t=_w){return G_(r,t)}function G_(r,t,e=new Set){let n=r[0];if(e.has(n))throw new Error("Circular references are not supported.");let o=t(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(Dp(n)){let s=Array.isArray(n)?[]:{};e.add(n);for(let a in n){let i=r.map(p=>p[a]),u=G_(i,t,e);s[a]=u}return e.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function _w(r){return r===null?null:Dp(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function xx(r,t){let e=new Map;Tx(r,t,e);for(let o of Array.from(e.keys())){let s=e.get(o);if(y.isPromise(s)){let a=await s;e.set(o,a)}}return Tx(r,t,e)}function Dp(r){let t=!1;if(B().get("IS_BROWSER"))t=r instanceof TextDecoder;else{let{StringDecoder:e}=Ew();t=r instanceof e}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof qe)&&!(r instanceof Promise)&&!t)}function U_(r){return r==null||gre(r)||Array.isArray(r)||typeof r=="object"&&r instanceof qe||y.isTypedArray(r)}function gre(r){return r===null||typeof r!="object"&&typeof r!="function"}function W_(r){return O_(r,bre)}function bre(r){return r instanceof qe?{value:r.clone(),recurse:!1}:Dp(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var tf=class{constructor(t){this.capacity=t;this.begin=0;this.end=0;if(t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}};var Lw=class extends tf{constructor(){super(Lw.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),n=this.length();for(let o=0;o<n;o++)e[o]=this.get(this.wrap(this.begin+o));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},ag=Lw;ag.INITIAL_CAPACITY=32;function Xw(r){return new $w(r)}function ig(r){return new Bw(r)}function V_(r,t){return new Cx(r,t)}function H_(r,t=Yw.FAIL){return new qw(r,t)}var sr=class{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new Vw(this,t)}filter(t){return new Ww(this,t)}map(t){return new Kw(this,t)}mapAsync(t){return new Ix(this,t)}serialMapAsync(t){return new Ix(this,t).serial()}flatmap(t){return new Hw(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new Uw(this,t,e)}columnMajorBatch(t,e=!0,n=_w){return this.rowMajorBatch(t,e).map(s=>z_(s,n))}concatenate(t,e){return new Cx(Xw([this,t]),e)}take(t){return t<0||t==null?this:new Gw(this,t)}skip(t){return t<0||t==null?this:new zw(this,t)}prefetch(t){return new kx(this,t)}shuffle(t,e){return new jw(this,t,e)}serial(){return new Ow(this)}},$w=class extends sr{constructor(e){super();this.items=e;this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:W_(e),done:!1}}},Bw=class extends sr{constructor(e){super();this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},Ow=class extends sr{constructor(e){super();this.upstream=e;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},zw=class extends sr{constructor(e,n){super();this.upstream=e;this.maxCount=n;this.count=0;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Pe(e.value)}return this.upstream.next()}},Gw=class extends sr{constructor(e,n){super();this.upstream=e;this.maxCount=n;this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},Uw=class extends sr{constructor(e,n,o=!0){super();this.upstream=e;this.batchSize=n;this.enableSmallLastBatch=o;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let n=await this.upstream.next();if(n.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(n.value)}return{value:e,done:!1}}},Ww=class extends sr{constructor(e,n){super();this.upstream=e;this.predicate=n;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Pe(e.value)}}},Kw=class extends sr{constructor(e,n){super();this.upstream=e;this.transform=n}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let n=Rs.getTensorsInContainer(e.value),o=this.transform(e.value),s=Rs.getTensorsInContainer(o);for(let a of n)Rs.isTensorInList(a,s)||a.dispose();return{value:o,done:!1}}},Vw=class extends sr{constructor(e,n){super();this.upstream=e;this.handler=n;this.count=0;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},Ix=class extends sr{constructor(e,n){super();this.upstream=e;this.transform=n}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let n=Rs.getTensorsInContainer(e.value),o=await this.transform(e.value),s=Rs.getTensorsInContainer(o);for(let a of n)Rs.isTensorInList(a,s)||a.dispose();return{value:o,done:!1}}},Ol=class extends sr{constructor(){super();this.outputQueue=new ag,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},Hw=class extends Ol{constructor(e,n){super();this.upstream=e;this.transform=n}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let n=Rs.getTensorsInContainer(e.value),o=this.transform(e.value),s=Rs.getTensorsInContainer(o);this.outputQueue.pushAll(o);for(let a of n)Rs.isTensorInList(a,s)||a.dispose();return!0}},Cx=class extends sr{constructor(e,n){super();this.baseErrorHandler=n;this.lastRead=null;this.iterator=null;this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let o=await this.moreIterators.next();if(o.done)return{value:null,done:!0};this.iterator=o.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let n=await this.iterator.next();return n.done?(this.iterator=null,this.readFromChain(e)):n}},Yw=(n=>(n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST",n))(Yw||{}),qw=class extends sr{constructor(e,n=0){super();this.iterators=e;this.mismatchMode=n;this.count=0;this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let n=0,o=0;function s(i){return i instanceof sr?{value:i.next().then(p=>(n++,p.done&&o++,p.value)),recurse:!1}:{value:null,recurse:!0}}let a=await xx(this.iterators,s);if(n===o)return{value:null,done:!0};if(o>0)switch(this.mismatchMode){case 0:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case 1:return{value:null,done:!0};case 2:default:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},kx=class extends sr{constructor(e,n){super();this.upstream=e;this.bufferSize=n;this.buffer=new tf(n)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},jw=class extends kx{constructor(e,n,o){super(e,n);this.upstream=e;this.windowSize=n;this.upstreamExhausted=!1;this.random=K_.alea(o||y.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),n=await this.buffer.shuffleExcise(e);if(n.done)this.upstreamExhausted=!0;else return this.refill(),n}return{value:null,done:!0}}};var ni=class{constructor(){this.size=null}batch(t,e=!0){let n=this;y.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let o;return this.size===1/0||this.size==null?o=this.size:e?o=Math.ceil(this.size/t):o=Math.floor(this.size/t),Bn(async()=>(await n.iterator()).columnMajorBatch(t,e,yre),o)}concatenate(t){let e=this,n;return this.size===1/0||t.size===1/0?n=1/0:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,Bn(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){let e=this,n;return this.size===1/0?n=1/0:n=null,Bn(async()=>(await e.iterator()).filter(o=>U(()=>t(o))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return Bn(async()=>(await e.iterator()).map(n=>U(()=>t(n))),this.size)}mapAsync(t){let e=this;return Bn(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Bn(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=1/0:n=null,Bn(async()=>{let o=ig(async()=>({value:await e.iterator(),done:!1}));return V_(o.take(t))},n)}skip(t){let e=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,Bn(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=q_.alea(e||y.now().toString());return Bn(async()=>{let a=s.int32();return n&&(a+=s.int32()),(await o.iterator()).shuffle(t,a.toString())},this.size)}take(t){let e=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,Bn(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};ni.MAX_BUFFER_SIZE=1e4;function Bn(r,t=null){return new class extends ni{constructor(){super(...arguments);this.size=t}async iterator(){return r()}}}function j_(r){return Bn(async()=>Xw(r),r.length)}function X_(r){if(!Dp(r))throw new Error("The argument to zip() must be an object or array.");let t;if(Array.isArray(r))for(let e=0;e<r.length;e++)t=t==null?r[e].size:Math.min(t,r[e].size);else if(r instanceof Object)for(let e in r)t=t==null?r[e].size:Math.min(t,r[e].size);return Bn(async()=>{let e=await xx(r,n=>{if(n instanceof ni)return{value:n.iterator(),recurse:!1};if(Dp(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return H_(e,1)},t)}function yre(r){if(r===null)return null;let t=r[0];return U_(t)?{value:Tre(r),recurse:!1}:{value:null,recurse:!0}}function Tre(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof qe?Tr(r):wr(r)}var rf=class extends ni{constructor(e){super();this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(s=>(s.endsWith("\r")&&(s=s.slice(0,-1)),s))}};var Sx='"',ug=Symbol("out"),Y_=Symbol("field"),vx=Symbol("quote"),Zw=Symbol("quoteafterquote"),Z_=Symbol("quoteinquote"),nf=class extends ni{constructor(e,n){super();this.input=e;this.hasHeader=!0;this.fullColumnNames=null;this.columnNamesValidated=!1;this.columnConfigs=null;this.configuredColumnsOnly=!1;this.delimiter=",";this.delimWhitespace=!1;this.base=new rf(e),n||(n={}),this.hasHeader=n.hasHeader!==!1,this.fullColumnNames=n.columnNames,this.columnConfigs=n.columnConfigs,this.configuredColumnsOnly=n.configuredColumnsOnly,n.delimWhitespace?(y.assert(n.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=n.delimiter?n.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&y.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let n=this.fullColumnNames.reduce((s,a)=>(s[a]=s[a]+1||1,s),{}),o=Object.keys(n).filter(s=>n[s]>1);if(y.assert(o.length===0,()=>"Duplicate column names found: "+o.toString()),this.columnConfigs){for(let s of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(s)===-1)throw new Error('The key "'+s+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let n=await(await this.base.iterator()).next();if(n.done)throw new Error("No data was found for CSV parsing.");let o=n.value;return this.parseRow(o,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(n=>this.makeDataElement(n))}makeDataElement(e){let n=this.parseRow(e),o={},s={};for(let a=0;a<this.fullColumnNames.length;a++){let i=this.fullColumnNames[a],u=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!u)){let p=n[a],l=null;if(p==="")if(u&&u.default!==void 0)l=u.default;else{if(u&&(u.required||u.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);l=void 0}else{let m=Number(p);if(isNaN(m))u&&u.dtype==="bool"?l=this.getBoolean(p):l=p;else if(!u||!u.dtype)l=m;else switch(u.dtype){case"float32":l=m;break;case"int32":l=Math.floor(m);break;case"bool":l=this.getBoolean(p);break;default:l=m}}u&&u.isLabel?s[i]=l:o[i]=l}}return Object.keys(s).length===0?o:{xs:o,ys:s}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,n=!0){let o=[],s=0,a=e.length,i=ug;for(let u=0;u<a;u++)switch(i){case ug:switch(e.charAt(u)){case Sx:s=u+1,i=vx;break;case this.delimiter:if(s=u+1,this.delimiter===" "&&this.delimWhitespace)break;o.push(""),i=ug;break;default:i=Y_,s=u;break}break;case Y_:switch(e.charAt(u)){case this.delimiter:o.push(e.substring(s,u)),i=ug,s=u+1;break;default:}break;case vx:switch(e.charAt(u)){case Sx:i=Zw;break;default:}break;case Zw:switch(e.charAt(u)){case this.delimiter:o.push(e.substring(s,u-1)),i=ug,s=u+1;break;case Sx:i=vx;break;default:i=Z_;break}break;case Z_:switch(e.charAt(u)){case Sx:i=vx;break;default:}break;default:}if(i===Zw?o.push(e.substring(s,a-1)):o.push(e.substring(s)),n&&o.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${o}`);return o}};var of=class extends sr{constructor(e){super();this.microphoneConfig=e;this.isClosed=!1;this.fftSize=e.fftSize||1024;let n=Math.log2(this.fftSize);if(this.fftSize<0||n<4||n>14||!Number.isInteger(n))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!B().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");let n=new of(e);return await n.start(),n}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(o){throw new Error(`Error thrown while initializing video stream: ${o.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let n=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,n.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,n,o=await this.getAudioData();if(this.includeSpectrogram){let s=this.flattenQueue(o.freqDataQueue);e=this.getTensorFromAudioDataArray(s,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let s=this.flattenQueue(o.timeDataQueue);n=this.getTensorFromAudioDataArray(s,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:n},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],n=[],o=0;return new Promise(s=>{let a=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&s({freqDataQueue:e,timeDataQueue:n}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),n.push(this.timeData.slice())),++o===this.numFrames&&(clearInterval(a),s({freqDataQueue:e,timeDataQueue:n}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let n=e[0].length,o=new Float32Array(e.length*n);return e.forEach((s,a)=>o.set(s,a*n)),o}getTensorFromAudioDataArray(e,n){let o=new Float32Array(y.sizeFromShape(n));return o.set(e,o.length-e.length),wr(o,n)}};var sf=class extends sr{constructor(e,n){super();this.webcamVideoElement=e;this.webcamConfig=n;this.isClosed=!0;this.resize=!1;if(this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=Xt([0],"int32"),this.webcamConfig.centerCrop){let o=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,s=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,a=(1-o)/2,i=(1-s)/2,u=a+o,p=s+i;this.cropBox=Va([i,a,p,u],[1,4])}else this.cropBox=Va([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,n={}){if(!B().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!n.resizeWidth||!n.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=n.resizeWidth,e.height=n.resizeHeight}let o=new sf(e,n);return await o.start(),o}async start(){this.webcamConfig.facingMode&&y.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=qb.fromPixels(this.webcamVideoElement)}catch(n){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(n)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(n){throw new Error(`Error thrown cropping the video: ${n.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return U(()=>{let n=_r(oe(e,"float32"),0),o;o=hp.cropAndResize(n,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let s=o.shape;return $(o,s.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(n=>n.stop());try{this.webcamVideoElement.srcObject=null}catch(n){console.log(n),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var af=class{};var pg=class extends sr{split(t){return new Qw(this,t)}},Qw=class extends pg{constructor(e,n){super();this.upstream=e;this.impl=new Jw(e,n)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},Jw=class extends Ol{constructor(e,n){super();this.upstream=e;this.separator=n;this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let n=e.value.split(this.separator);n[0]=this.carryover+n[0];for(let o of n.slice(0,-1))this.outputQueue.push(o);return this.carryover=n[n.length-1],!0}};var Ax=class extends sr{decodeUTF8(){return new eN(this)}},eN=class extends pg{constructor(e){super();this.upstream=e;this.impl=new tN(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},tN=class extends Ol{constructor(e){super();this.upstream=e;if(B().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:n}=Ew();this.decoder=new n("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),n;if(e.done)return!1;n=e.value;let o;return B().get("IS_BROWSER")?o=this.decoder.decode(n,{stream:!0}):o=this.decoder.write(Buffer.from(n.buffer)),this.outputQueue.push(o),!0}};var uf=class extends Ax{constructor(e,n={}){super();this.file=e;this.options=n;y.assert(e instanceof Uint8Array||(B().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=n.offset||0,this.chunkSize=n.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((n,o)=>{let s=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)n(new Uint8Array(this.file.slice(this.offset,s)));else{let a=new FileReader;a.onload=u=>{let p=a.result;if(p instanceof ArrayBuffer&&(p=new Uint8Array(p)),!(p instanceof Uint8Array))return o(new TypeError("FileReader returned unknown type."));n(p)},a.onabort=u=>o(new Error("Aborted")),a.onerror=u=>o(new Error(u.type));let i=this.file.slice(this.offset,s);a.readAsArrayBuffer(i)}this.offset=s}),done:!1}}};async function Q_(r,t={},e){let n,o;typeof r=="string"?n=r:(n=r.url,o=xre(r));let s=await(e||y.fetch)(n,o);if(s.ok){let a=new Uint8Array(await s.arrayBuffer());return new uf(a,t)}else throw new Error(s.statusText)}var xre=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function wx(r){return typeof r=="string"&&r.slice(0,7)==="file://"}var pf=class extends af{constructor(e,n={}){super();this.input=e;this.options=n}async iterator(){if(wx(this.input)&&B().get("IS_NODE")){let e=lg();this.input=e.readFileSync(this.input.slice(7))}return new uf(this.input,this.options)}};var lf=class extends af{constructor(e,n={}){super();this.url=e;this.fileOptions=n}async iterator(){return wx(this.url)?new pf(this.url,this.fileOptions).iterator():Q_(this.url,this.fileOptions)}};function J_(r,t={}){return new nf(new lf(r),t)}function eL(r){let t=ig(r);return Bn(async()=>t)}function tL(r){return Bn(async()=>{let t=await r();return ig(()=>t.next())})}async function rL(r,t){return sf.create(r,t)}async function nL(r){return of.create(r)}var oL="0.0.0";function re(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&y.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var Ire=xr.whereImpl,rN=class extends no{constructor(){super();this.blockSize=48;this.firstUse=!0;this.data=new ma(this,Mn())}nextDataId(){return rN.nextDataId++}write(e,n,o){this.firstUse&&(this.firstUse=!1,B().get("IS_NODE")&&C.warn(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));let s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:o,refCount:1}),s}makeTensorInfo(e,n,o){let s;if(n==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let a=o.map(i=>y.encodeString(i));s=this.write(a,e,n)}else s=this.write(o,e,n);return{dataId:s,shape:e,dtype:n}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let n=this.data.get(e);n.refCount++}decRef(e){if(this.data.has(e)){let n=this.data.get(e);n.refCount--}}move(e,n,o,s,a){this.data.set(e,{values:n,dtype:s,refCount:a})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:n,complexTensorInfos:o}=this.data.get(e);if(n==="complex64"){let s=this.readSync(o.real.dataId),a=this.readSync(o.imag.dataId);return C.mergeRealAndImagArrays(s,a)}return this.data.get(e).values}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let o=n.map(s=>y.decodeString(s));return xe(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xe(e.shape,e.dtype,n)}makeOutput(e,n,o){return Mn().makeTensorFromTensorInfo(this.makeTensorInfo(n,o,e),this)}disposeData(e,n=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!n&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:o}=this.data.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let n=y.now();return e(),{kernelMs:y.now()-n}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){re([e],"where");let n=this.readSync(e.dataId);return Ire(e.shape,n)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},mf=rN;mf.nextDataId=0;var yf={};Xe(yf,{addImpl:()=>sN,bincountImpl:()=>ff,bincountReduceImpl:()=>Nx,castImpl:()=>oN,ceilImpl:()=>aN,concatImpl:()=>zl,equalImpl:()=>iN,expImpl:()=>pN,expm1Impl:()=>mN,floorImpl:()=>cN,gatherNdImpl:()=>Dx,gatherV2Impl:()=>Fx,greaterEqualImpl:()=>fN,greaterImpl:()=>dN,lessEqualImpl:()=>gN,lessImpl:()=>hN,linSpaceImpl:()=>Rx,logImpl:()=>bN,maxImpl:()=>Px,maximumImpl:()=>yN,minimumImpl:()=>TN,multiplyImpl:()=>mg,negImpl:()=>xN,notEqualImpl:()=>IN,prodImpl:()=>CN,raggedTensorToTensorImpl:()=>Mx,rangeImpl:()=>Ul,rsqrtImpl:()=>kN,scatterImpl:()=>xu,sigmoidImpl:()=>PL,simpleAbsImpl:()=>nN,sliceImpl:()=>Wl,sparseFillEmptyRowsImpl:()=>Ex,sparseReshapeImpl:()=>_x,sparseSegmentReductionImpl:()=>bf,sqrtImpl:()=>_L,squaredDifferenceImpl:()=>vN,stridedSliceImpl:()=>Lx,stringNGramsImpl:()=>Kl,stringSplitImpl:()=>Vl,stringToHashBucketFastImpl:()=>Hl,subImpl:()=>wN,tileImpl:()=>$x,topKImpl:()=>Bx,transposeImpl:()=>hf,uniqueImpl:()=>Ox});function nN(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var Cre=r=>{let{x:t}=r.inputs,e=r.backend;re(t,"abs");let n=new Float32Array(y.sizeFromShape(t.shape)),o=e.data.get(t.dataId).values;return n=nN(o),e.makeOutput(n,t.shape,t.dtype)},aL={kernelName:ls,backendName:"cpu",kernelFunc:Cre};function st(r){return(t,e,n,o,s)=>{let a=C.assertAndGetBroadcastShape(t,e),i=a.length,u=y.computeStrides(a),p=y.sizeFromShape(a),l=y.getTypedArrayFromDType(s,p),m=t.length,c=e.length,d=y.computeStrides(t),f=y.computeStrides(e),h=C.getBroadcastDims(t,a),g=C.getBroadcastDims(e,a);if(h.length+g.length===0)for(let b=0;b<l.length;++b)l[b]=r(n[b%n.length],o[b%o.length]);else for(let b=0;b<l.length;++b){let T=y.indexToLoc(b,i,u),x=T.slice(-m);h.forEach(R=>x[R]=0);let I=y.locToIndex(x,m,d),k=T.slice(-c);g.forEach(R=>k[R]=0);let w=y.locToIndex(k,c,f);l[b]=r(n[I],o[w])}return[l,a]}}function Ar(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,i=e.makeTensorInfo(n.shape,"complex64"),u=e.data.get(i.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",s),imag:e.makeTensorInfo(o.shape,"float32",a)},i}var iL={kernelName:_u,backendName:"cpu",kernelFunc:Ar};function cf(r,t,e="float32"){if(e==="complex64"){let o=cf(r,t,"float32"),s=cf(r,t,"float32");return Ar({inputs:{real:o,imag:s},backend:r})}let n=y.makeZerosTypedArray(y.sizeFromShape(t),e);return r.makeTensorInfo(t,e,n)}function jr(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var uL={kernelName:Vn,backendName:"cpu",kernelFunc:jr};function Hs(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.real,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var pL={kernelName:Wu,backendName:"cpu",kernelFunc:Hs};function oN(r,t,e,n){if(n==="int32"){let o=Int32Array.from(r);return[t,"int32",o]}if(n==="bool"){let o=y.toTypedArray([0],e),[s,a]=st((i,u)=>i!==u?1:0)(t,[],r,o,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${e} to ${n}`)}function qs(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return jr({inputs:{x:o},backend:e});let l=cf(e,o.shape,o.dtype),m=qs({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),c=Ar({inputs:{real:m,imag:l},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(m),c}if(o.dtype==="complex64"){let l=Hs({inputs:{input:o},backend:e}),m=qs({inputs:{x:l},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(l),m}if(!y.hasEncodingLoss(o.dtype,s)){let l=jr({inputs:{x:o},backend:e});return{dataId:l.dataId,shape:l.shape,dtype:s}}let a=e.data.get(o.dataId).values,[i,u,p]=oN(a,o.shape,o.dtype,s);return e.makeTensorInfo(i,u,p)}var lL={kernelName:Wn,backendName:"cpu",kernelFunc:qs};function pt(r,t,e,n){return e==null?({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;re([a,i],r);let p=u.data.get(a.dataId).values,l=u.data.get(i.dataId).values,m=a.dtype==="string"?C.fromUint8ToStringArray(p):p,c=a.dtype==="string"?C.fromUint8ToStringArray(l):l,d=n||a.dtype,[f,h]=t(a.shape,i.shape,m,c,d);return u.makeTensorInfo(h,d,f)}:({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(a.dtype==="complex64"||i.dtype==="complex64"){let p=qs({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),l=u.data.get(p.dataId),m=l.complexTensorInfos.real,c=l.complexTensorInfos.imag,d=u.data.get(m.dataId).values,f=u.data.get(c.dataId).values,h=qs({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),b=g.complexTensorInfos.real,T=g.complexTensorInfos.imag,x=u.data.get(b.dataId).values,I=u.data.get(T.dataId).values,[k,w,R]=e(a.shape,i.shape,d,f,x,I),P=u.makeTensorInfo(R,"float32",k),M=u.makeTensorInfo(R,"float32",w),L=Ar({inputs:{real:P,imag:M},backend:u});return u.disposeIntermediateTensorInfo(p),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(P),u.disposeIntermediateTensorInfo(M),L}else{let p=u.data.get(a.dataId).values,l=u.data.get(i.dataId).values,m=n||a.dtype,[c,d]=t(a.shape,i.shape,p,l,m);return u.makeTensorInfo(d,m,c)}}}function df(r){return(t,e,n,o,s,a)=>{let i=C.assertAndGetBroadcastShape(t,e),u=y.sizeFromShape(i),p=i.length,l=y.computeStrides(i),m=y.getTypedArrayFromDType("float32",u),c=y.getTypedArrayFromDType("float32",u),d=C.getBroadcastDims(t,i),f=C.getBroadcastDims(e,i),h=C.mergeRealAndImagArrays(n,o),g=C.mergeRealAndImagArrays(s,a),b=t.length,T=y.computeStrides(t),x=e.length,I=y.computeStrides(e);if(d.length+f.length===0)for(let k=0;k<m.length;k++){let w=k%h.length,R=k%g.length,P=r(h[w*2],h[w*2+1],g[R*2],g[R*2+1]);m[k]=P.real,c[k]=P.imag}else for(let k=0;k<m.length;k++){let w=y.indexToLoc(k,p,l),R=w.slice(-b);d.forEach(W=>R[W]=0);let P=y.locToIndex(R,b,T),M=w.slice(-x);f.forEach(W=>M[W]=0);let L=y.locToIndex(M,x,I),z=r(h[P*2],h[P*2+1],g[L*2],g[L*2+1]);m[k]=z.real,c[k]=z.imag}return[m,c,i]}}var sN=st((r,t)=>r+t),kre=df((r,t,e,n)=>({real:r+e,imag:t+n})),Ri=pt(Nn,sN,kre),mL={kernelName:Nn,backendName:"cpu",kernelFunc:Ri};function ff(r,t,e,n,o){let s=y.sizeFromShape(n),a=y.makeZerosTypedArray(o,e);for(let i=0;i<r.length;i++){let u=r[i];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?a[u]+=t[i]:a[u]+=1)}return a}function Nx(r,t,e,n=!1){let o=r.shape[0],s=r.shape[1],a=xe([o,e],t.dtype);for(let i=0;i<o;i++)for(let u=0;u<s;u++){let p=r.get(i,u);if(p<0)throw new Error("Input x must be non-negative!");p>=e||(n?a.set(1,i,p):t.size>0?a.set(a.get(i,p)+t.get(i,u),i,p):a.set(a.get(i,p)+1,i,p))}return a}function Sn(r){return(t,e,n)=>{let o=y.getTypedArrayFromDType(e,t.length);for(let s=0;s<t.length;++s)o[s]=r(t[s],n);return o}}function Me(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(re(a,r),a.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,p=y.sizeFromShape(a.shape),l=e||a.dtype,m=y.getArrayFromDType(l,p);for(let c=0;c<p;++c)m[c]=t(u[c],o);return i.makeTensorInfo(a.shape,l,m)}}function js(r,t,e){return({inputs:n,attrs:o,backend:s})=>{let{x:a}=n;if(re(a,r),a.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let i=s,u=i.data.get(a.dataId).values,p=e||a.dtype,l=t(u,p,o);return i.makeTensorInfo(a.shape,p,l)}}var aN=Sn(r=>Math.ceil(r)),Sre=js(po,aN),cL={kernelName:po,backendName:"cpu",kernelFunc:Sre};function zl(r,t,e,n){let o=y.getArrayFromDType(e,y.sizeFromShape(t));if(n&&e!=="string"){let s=0;r.forEach(a=>{let i=y.sizeFromShape(a.shape);o.set(a.vals,s),s+=i})}else{let s=0;r.forEach(a=>{let i=e==="string"?C.fromUint8ToStringArray(a.vals):a.vals,u=0;for(let p=0;p<a.shape[0];++p){let l=p*t[1]+s;for(let m=0;m<a.shape[1];++m)o[l+m]=i[u++]}s+=a.shape[1]})}return o}var iN=st((r,t)=>r===t?1:0),uN=pt(ya,iN,null,"bool"),dL={kernelName:ya,backendName:"cpu",kernelFunc:uN};var pN=Sn(r=>Math.exp(r)),lN=js(To,pN,"float32"),fL={kernelName:To,backendName:"cpu",kernelFunc:lN};var mN=Sn(r=>Math.expm1(r)),vre=js(Ta,mN),hL={kernelName:Ta,backendName:"cpu",kernelFunc:vre};var cN=Sn(r=>Math.floor(r)),Are=js(xo,cN),gL={kernelName:xo,backendName:"cpu",kernelFunc:Are};function Dx(r,t,e,n,o,s,a,i,u){let p=xe([n,s],e);for(let l=0;l<n;l++){let m=[],c=0;for(let d=0;d<o;d++){let f=r[l*o+d];c+=f*a[d],m.push(f)}if(c<0||c>=u/s)throw new Error(`Invalid indices: ${m} does not index into ${i}`);for(let d=0;d<s;d++)p.values[l*s+d]=t.get(...t.indexToLoc(c*s+d))}return p}function Fx(r,t,e){let n=xe(e,r.dtype);for(let o=0;o<n.size;++o){let a=n.indexToLoc(o).slice(),i=a[0],u=a[2],p=t.locToIndex([i,u]);a[2]=t.values[p];let l=r.locToIndex(a);0<=l&&l<r.values.length&&(n.values[o]=r.values[l])}return n}var dN=st((r,t)=>r>t?1:0),wre=pt(Ca,dN,null,"bool"),bL={kernelName:Ca,backendName:"cpu",kernelFunc:wre};var fN=st((r,t)=>r>=t?1:0),Nre=pt(ko,fN,null,"bool"),yL={kernelName:ko,backendName:"cpu",kernelFunc:Nre};var hN=st((r,t)=>r<t?1:0),Dre=pt(Sa,hN,null,"bool"),TL={kernelName:Sa,backendName:"cpu",kernelFunc:Dre};var gN=st((r,t)=>r<=t?1:0),Fre=pt(va,gN,null,"bool"),xL={kernelName:va,backendName:"cpu",kernelFunc:Fre};function Rx(r,t,e){let n=(t-r)/(e-1),o=y.makeZerosTypedArray(e,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var bN=Sn(r=>Math.log(r)),Rre=js(vo,bN),IL={kernelName:vo,backendName:"cpu",kernelFunc:Rre};function Px(r,t,e,n){let o=y.getTypedArrayFromDType(n,y.sizeFromShape(e));for(let s=0;s<o.length;++s){let a=s*t,i=r[a];for(let u=0;u<t;++u){let p=r[a+u];(Number.isNaN(p)||p>i)&&(i=p)}o[s]=i}return o}var yN=st((r,t)=>Math.max(r,t)),Pre=pt(wo,yN),CL={kernelName:wo,backendName:"cpu",kernelFunc:Pre};var TN=st((r,t)=>Math.min(r,t)),Mre=pt(Ro,TN),kL={kernelName:Ro,backendName:"cpu",kernelFunc:Mre};var mg=st((r,t)=>r*t),Ere=df((r,t,e,n)=>({real:r*e-t*n,imag:r*n+t*e})),Gl=pt(Mo,mg,Ere),SL={kernelName:Mo,backendName:"cpu",kernelFunc:Gl};function xN(r,t,e){let n=y.createScalarValue(-1,e);return mg([],t,n,r,e)}function _re(r){let{inputs:t,backend:e}=r,{x:n}=t;re(n,"neg");let o=e.data.get(n.dataId).values,[s,a]=xN(o,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,s)}var vL={kernelName:hs,backendName:"cpu",kernelFunc:_re};var IN=st((r,t)=>r!==t?1:0),Lre=pt(Na,IN,null,"bool"),AL={kernelName:Na,backendName:"cpu",kernelFunc:Lre};function hf(r,t,e,n,o){let s=t.length,a=y.sizeFromShape(t),i=y.computeStrides(t),u=y.computeStrides(o),p=y.getTypedArrayFromDType(e,y.sizeFromShape(o));for(let l=0;l<a;++l){let m=y.indexToLoc(l,s,i),c=new Array(m.length);for(let f=0;f<c.length;f++)c[f]=m[n[f]];let d=y.locToIndex(c,s,u);p[d]=r[l]}return p}function Qt(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{perm:s}=e;re(o,"transpose");let a=o.shape.length,i=new Array(a);for(let m=0;m<i.length;m++)i[m]=o.shape[s[m]];let u=n.data.get(o.dataId).values,p=hf(u,o.shape,o.dtype,s,i);return{dataId:n.write(p,i,o.dtype),shape:i,dtype:o.dtype}}var wL={kernelName:Fn,backendName:"cpu",kernelFunc:Qt};function CN(r,t,e,n){let[o,s]=C.computeOutAndReduceShapes(r,n),a=$t(t,"int32"),i=y.makeZerosTypedArray(y.sizeFromShape(o),a),u=y.sizeFromShape(s);for(let p=0;p<i.length;++p){let l=p*u,m=1;for(let c=0;c<u;++c)m*=e[l+c];i[p]=m}return{outVals:i,outShape:o,outDtype:a}}function $re(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;re(o,"prod");let i=o.shape.length,u=y.parseAxisParam(s,o.shape),p=C.getAxesPermutation(u,i),l=u,m=o,c=[];p!=null&&(m=Qt({inputs:{x:o},backend:e,attrs:{perm:p}}),c.push(m),l=C.getInnerMostAxes(l.length,i));let d=e.data.get(m.dataId).values,{outVals:f,outShape:h,outDtype:g}=CN(m.shape,m.dtype,d,l),b=h;return a&&(b=C.expandShapeToKeepDim(h,u)),c.forEach(T=>e.disposeIntermediateTensorInfo(T)),e.makeTensorInfo(b,g,f)}var NL={kernelName:$o,backendName:"cpu",kernelFunc:$re};var Xs=C.RowPartitionType,gf=class{constructor(t,e,n,o,s,a,i,u,p,l){this.shape=t;this.shapeShape=e;this.values=n;this.valuesShape=o;this.valuesDType=s;this.defaultValue=a;this.defaultValueShape=i;this.rowPartitionValues=u;this.rowPartitionValuesShapes=p;this.rowPartitionTypes=C.getRowPartitionTypesHelper(l),this.raggedRank=C.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(t){return this.rowPartitionTypes[0]===Xs.FIRST_DIM_SIZE?this.rowPartitionTypes[t+1]:this.rowPartitionTypes[t]}getRowPartitionTensor(t){return this.rowPartitionTypes[0]===Xs.FIRST_DIM_SIZE?this.rowPartitionValues[t+1]:this.rowPartitionValues[t]}getMaxWidth(t){let e=this.getRowPartitionTensor(t-1);switch(this.getRowPartitionTypeByDimension(t-1)){case Xs.VALUE_ROWIDS:return gf.getMaxWidthValueRowID(e);case Xs.ROW_SPLITS:return gf.getMaxWidthRowSplit(e);default:throw new Error(`Cannot handle partition type ${Xs[this.getRowPartitionTypeByDimension(t-1)]}`)}}static getMaxWidthRowSplit(t){let e=t.length;if(e===0||e===1)return 0;let n=0;for(let o=0;o<e-1;++o){let s=t[o+1]-t[o];s>n&&(n=s)}return n}static getMaxWidthValueRowID(t){let e=t.length;if(e===0)return 0;let n=0,o=t[0],s=0;for(let a=1;a<e;++a){let i=t[a];i!==o&&(o=i,s=Math.max(a-n,s),n=a)}return Math.max(e-n,s)}tensorShapeFromTensor(t,e,n=!0){if(e.length===0){if(t[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return FL(t,n)}calculateOutputSize(t){let e=this.valuesShape,n=this.defaultValueShape;C.validateDefaultValueShape(n,e);let o=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=C.combineRaggedTensorToTensorShapes(this.raggedRank,o,e);a[0]<0&&(a[0]=t);for(let i=1;i<=this.raggedRank;++i)a[i]<0&&(a[i]=this.getMaxWidth(i));return a}calculateFirstParentOutputIndex(t,e,n){let o=Math.min(t,n),s=[],a=0;for(let i=0;i<o;++i,a+=e)s.push(a);for(let i=o;i<t;++i)s.push(-1);return y.assert(s.length===t,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(t,e,n,o){let s=t.length,a=[];for(let i=0;i<s-1;++i){let u=t[i+1]-t[i],p=Math.min(o,u),l=e[i];l===-1&&(p=0);for(let m=0;m<p;++m)a.push(l),l+=n;for(let m=0;m<u-p;++m)a.push(-1)}if(s>0&&a.length!==t[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(t,e,n,o){let s=t.length,a=[];if(s===0)return[];let i=0,u=t[0];if(u>=e.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${e.length}`);let p=e[u];a.push(p);for(let l=1;l<s;++l){let m=t[l];if(m===u)p>=0&&(++i,i<o?p+=n:p=-1);else{if(i=0,u=m,m>=e.length)throw new Error(`Got nextValueRowId=${m} which is not less than ${e.length}`);p=e[m]}a.push(p)}if(a.length!==t.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(t,e,n,o){let s=this.getRowPartitionTensor(t),a=this.getRowPartitionTypeByDimension(t);switch(a){case Xs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,e,n,o);case Xs.ROW_SPLITS:if(s.length-1>e.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${e.length}`);return this.calculateOutputIndexRowSplit(s,e,n,o);default:throw new Error(`Unsupported partition type: ${Xs[a]}`)}}getFirstDimensionSize(){let t=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");let e=this.rowPartitionTypes[0];switch(e){case Xs.FIRST_DIM_SIZE:return t[0];case Xs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case Xs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${Xs[e]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");let e=this.getFirstDimensionSize(),n=this.calculateOutputSize(e),o=new Array(this.raggedRank+1);o[o.length-1]=1;for(let u=o.length-2;u>=0;--u)o[u]=o[u+1]*n[u+1];let s=FL(n,!1),a=y.getArrayFromDType(this.valuesDType,y.sizeFromShape(s));if(o[0]*n[0]>0){let u=this.calculateFirstParentOutputIndex(e,o[0],n[0]);for(let p=1;p<=this.raggedRank;++p)u=this.calculateOutputIndex(p-1,u,o[p],n[p]);this.setOutput(this.raggedRank,u,a,s)}return[s,a]}setOutput(t,e,n,o){if(n.length===0)return;let s=this.values,a=n,i=o.slice();i=i.slice(t+1);let u=y.sizeFromShape(i),p=e.length,l=this.defaultValue;if(l.length!==u&&l.length!==1){let f=this.defaultValueShape;U(()=>{let h=$(l,f);l=ip(h,i).dataSync()})}let m=0,c=0,d=0;for(let f=0;f<=p;++f){let h=f<p?e[f]:-1;if(h===d){++d;continue}if(c<d){let g=s.subarray(m*u),b=a.subarray(c*u),T=(d-c)*u;DL(b,g,T)}if(f>=p){let g=n.length;h=Math.floor(g/u)}if(h>d)if(this.defaultValue.length===1)a.subarray(d*u,h*u).fill(this.defaultValue[0]),d=h;else for(;h>d;){let g=a.slice(d*u);DL(g,l,u),++d}h<0?(m=f+1,c=d):(m=f,c=d,d=c+1)}}};function DL(r,t,e){for(let n=0;n<e;n++)r[n]=t[n]}function FL(r,t){let e=[];for(let n of r){if(n<0){if(!t)throw new Error(`Dimension ${n} must be >= 0`);if(n<-1)throw new Error(`Dimension ${n} must be >= -1`);n=-1}e.push(n)}return e}function Mx(r,t,e,n,o,s,a,i,u,p){return new gf(r,t,e,n,o,s,a,i,u,p).compute()}function Ul(r,t,e,n){let o=r===t,s=r<t&&e<0,a=t<r&&e>1;if(o||s||a)return y.makeZerosTypedArray(0,n);let i=Math.abs(Math.ceil((t-r)/e)),u=y.makeZerosTypedArray(i,n);t<r&&e===1&&(e=-1),u[0]=r;for(let p=1;p<u.length;p++)u[p]=u[p-1]+e;return u}var kN=Sn(r=>1/Math.sqrt(r)),Bre=js(Uo,kN),RL={kernelName:Uo,backendName:"cpu",kernelFunc:Bre};function xu(r,t,e,n,o,s,a,i,u,p){let l=[n/o,o],m=r.values,c=t.values;if(n===0)return xe(e,t.dtype);let d=xe(l,t.dtype);typeof u=="string"||typeof u=="number"?d.values.fill(u):typeof u=="boolean"&&d.values.fill(+u);for(let f=0;f<s;f++){let h=[],g=0;for(let b=0;b<a;b++){let T=m[f*a+b];h.push(T),g+=T*i[b]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${e}`);for(let b=0;b<o;b++)p?d.values[g*o+b]+=c[f*o+b]:d.values[g*o+b]=t.rank===0?c[0]:c[f*o+b]}return d}var PL=Sn(r=>1/(1+Math.exp(-r))),SN=Me(Ko,r=>1/(1+Math.exp(-r))),ML={kernelName:Ko,backendName:"cpu",kernelFunc:SN};function Wl(r,t,e,n,o){let s=It.isSliceContinous(n,t,e),a=y.sizeFromShape(e),i=y.computeStrides(n);if(s){let m=It.computeFlatOffset(t,i);return o==="string"?r.slice(m,m+a):r.subarray(m,m+a)}let u=o==="string"?C.fromUint8ToStringArray(r):r,p=xe(n,o,u),l=xe(e,o);for(let m=0;m<l.size;++m){let c=l.indexToLoc(m),d=c.map((f,h)=>f+t[h]);l.set(p.get(...d),...c)}return o==="string"?C.fromStringArrayToUint8(l.values):l.values}function Ys(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:a}=n;re(o,"slice");let[i,u]=It.parseSliceParams(o,s,a);It.assertParamsValid(o,i,u);let p=e.data.get(o.dataId).values,l=Wl(p,i,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,l)}var EL={kernelName:xs,backendName:"cpu",kernelFunc:Ys};function Ex(r,t,e,n,o,s,a){let i=t[0],u=s[0],p=new Array(u),l=new Array(i),m=t[1];if(u===0){if(i!==0)throw new Error(C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(i));let g=y.getArrayFromDType(e,0),b=y.getArrayFromDType(o,0);return[g,[0,m],b,p,l]}let c=!0,d=0,f=new Array(u).fill(0);for(let g=0;g<i;++g){let b=r[g*m];if(b<0)throw new Error(C.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,b));if(b>=u)throw new Error(C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,b,u));++f[b],c=c&&b>=d,d=b}let h=!0;for(let g=0;g<u;++g){let b=f[g]===0;p[g]=b,h=h&&!b,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(h&&c){let g=r,b=n;for(let T=0;T<i;++T)l[T]=T;return[g,[i,m],b,p,l]}else{let g=f[u-1],b=y.getArrayFromDType(e,g*m),T=y.getArrayFromDType(o,g),x=new Array(u).fill(0);for(let I=0;I<i;++I){let k=r[I*m],w=x[k],R=(k===0?0:f[k-1])+w;x[k]++;for(let P=0;P<m;++P)b[R*m+P]=r[I*m+P];T[R]=n[I],l[I]=R}for(let I=0;I<u;++I)if(x[I]===0){let w=I===0?0:f[I-1];b[w*m+0]=I;for(let R=1;R<m;++R)b[w*m+R]=0;T[w]=a}return[b,[g,m],T,p,l]}}function _x(r,t,e,n,o){let s=y.sizeFromShape(n),a=t[0],i=o.length,u=[],p=1,l=-1;for(let g=0;g<i;++g){let b=o[g];if(b===-1){if(l!==-1)throw new Error(C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(l,g));l=g,u.push(1)}else{if(b<0)throw new Error(C.getSparseReshapeNegativeOutputDimErrorMessage(g,b));p*=b,u.push(b)}}if(l!==-1){if(p<=0)throw new Error(C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/p);if(p*g!==s)throw new Error(C.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[l]=g}if(y.sizeFromShape(u)!==s)throw new Error(C.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let c=n.length,d=[];if(c>0){d[c-1]=1;for(let g=c-2;g>=0;--g)d[g]=d[g+1]*n[g+1]}let f=[];if(i>0){f[i-1]=1;for(let g=i-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}let h=y.getArrayFromDType(e,a*i);for(let g=0;g<a;++g){let b=0;for(let T=0;T<c;++T)b+=r[g*c+T]*d[T];for(let T=0;T<i;++T)h[g*i+T]=Math.trunc(b/f[T]),b%=f[T]}return[h,[a,i],u]}function bf(r,t,e,n,o,s=!1,a=0){let i=n.length,u=[t[0],r.length/t[0]],p=u[1],m=i>0?o[i-1]+1:0;if(m<0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=t.slice();c[0]=m;let d=c.reduce((x,I)=>x*I,1),f=y.getArrayFromDType(e,d);if(i===0)return m>0&&f.fill(a),[f,c];if(m<=0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,b=0,T=o[h];for(;;){let x=0;if(g<i){if(x=o[g],T===x){++g;continue}if(T>=x)throw new Error(C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(T<0||T>=m)throw new Error(C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(T,m));T>b&&f.fill(a,b*p,T*p);for(let I=h;I<g;++I){let k=n[I];if(k<0||k>=u[0])throw new Error(C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(I,n[I],u[0]));for(let w=0;w<p;w++)f[T*p+w]+=r[k*p+w]}if(s)for(let I=0;I<p;I++)f[T*p+I]/=g-h;if(h=g,++g,b=T+1,T=x,g>i)break}return b<m&&f.fill(a,b*p,m*p),[f,c]}var _L=Sn(r=>Math.sqrt(r)),Ore=Me(Vo,r=>Math.sqrt(r)),LL={kernelName:Vo,backendName:"cpu",kernelFunc:Ore};var vN=st((r,t)=>{let e=r-t;return e*e}),zre=pt(jo,vN),$L={kernelName:jo,backendName:"cpu",kernelFunc:zre};function Lx(r,t,e,n){let o=xe(r,t.dtype);for(let s=0;s<o.size;s++){let a=o.indexToLoc(s),i=new Array(a.length);for(let u=0;u<i.length;u++)i[u]=a[u]*e[u]+n[u];o.set(t.get(...i),...a)}return o}var AN=class{constructor(t,e,n,o,s,a){this.separator=y.encodeString(t),this.nGramWidths=e,this.leftPad=y.encodeString(n),this.rightPad=y.encodeString(o),this.padWidth=s,this.preserveShort=a}getPadWidth(t){return Math.min(this.padWidth<0?t-1:this.padWidth,t-1)}getNumNGrams(t,e){let n=this.getPadWidth(e);return Math.max(0,t+2*n-e+1)}createNGrams(t,e,n,o,s,a){for(let i=0;i<s;++i){let u=this.getPadWidth(a),p=Math.max(0,u-i),l=Math.max(0,u-(s-(i+1))),m=a-(p+l),c=e+(p>0?0:i-u),d=0;d+=p*this.leftPad.length;for(let T=0;T<m;++T)d+=t[c+T].length;d+=l*this.rightPad.length,d+=(p+l+m-1)*this.separator.length,n[o+i]=new Uint8Array(d);let h=n[o+i],g=0,b=T=>T.forEach(x=>h[g++]=x);for(let T=0;T<p;++T)b(this.leftPad),b(this.separator);for(let T=0;T<m-1;++T)b(t[c+T]),b(this.separator);if(m>0){b(t[c+m-1]);for(let T=0;T<l;++T)b(this.separator),b(this.rightPad)}else{for(let T=0;T<l-1;++T)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(t,e){let n=t.length,o=e.length;if(o>0){let u=e[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let p=1;p<o;++p){let l=e[p]>=u;if(l=l&&e[p]<=n,!l)throw new Error(`Invalid split value ${e[p]}, must be in [${u}, ${n}]`);u=e[p]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,a=y.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let p=0;p<=s;++p)a[p]=0;return[u,a]}a[0]=0;for(let u=1;u<=s;++u){let p=e[u]-e[u-1],l=0;this.nGramWidths.forEach(m=>{l+=this.getNumNGrams(p,m)}),this.preserveShort&&p>0&&l===0&&(l=1),a[u]=a[u-1]+l}let i=new Array(a[s]);for(let u=0;u<s;++u){let p=e[u],l=a[u];if(this.nGramWidths.forEach(m=>{let c=e[u+1]-e[u],d=this.getNumNGrams(c,m);this.createNGrams(t,p,i,l,d,m),l+=d}),this.preserveShort&&l===a[u]){let m=e[u+1]-e[u];if(m===0)continue;let c=m+2*this.padWidth,d=1;this.createNGrams(t,p,i,l,d,c)}}return[i,a]}};function Kl(r,t,e,n,o,s,a,i){return new AN(e,n,o,s,a,i).compute(r,t)}function Gre(r,t,e,n){if(!r.length)return;if(t.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(t.length===1){let s=t[0],a=r.indexOf(s);for(;a!==-1;){let i=r.subarray(0,a);(!e||i.length!==0)&&n.push(i),r=r.subarray(a+1),a=r.indexOf(s)}(!e||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||t.indexOf(r[s])!==-1){let a=r.subarray(o,s);(!e||a.length!==0)&&n.push(a),o=s+1}}function Vl(r,t,e){let n=r.length,o=[],s=0,a=0,i=new Array(n);for(let c=0;c<n;++c){let d=o.length;Gre(r[c],t,e,o);let f=o.length-d;i[c]=f,s+=f,a=Math.max(a,f)}let u=y.getArrayFromDType("int32",s*2),p=new Array(s),l=[n,a],m=0;for(let c=0;c<n;++c)for(let d=0;d<i[c];++d)u[m*2]=c,u[m*2+1]=d,p[m]=o[m],++m;return[u,p,l]}function Hl(r,t){let e=y.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)e[n]=y.fingerPrint64(r[n]).modulo(t).getLowBitsUnsigned();return e}var wN=st((r,t)=>r-t),Ure=df((r,t,e,n)=>({real:r-e,imag:t-n})),cg=pt(Xo,wN,Ure),BL={kernelName:Xo,backendName:"cpu",kernelFunc:cg};function $x(r,t){let e=new Array(r.rank);for(let o=0;o<e.length;o++)e[o]=r.shape[o]*t[o];let n=xe(e,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),a=new Array(r.rank);for(let u=0;u<a.length;u++)a[u]=s[u]%r.shape[u];let i=r.locToIndex(a);n.values[o]=r.values[i]}return n}var dg=(r,t)=>{let e=t.value-r.value;return e===0?r.index-t.index:e};function OL(r,t,e=0,n=r.length-1){for(;n>e;){if(n-e>600){let i=n-e+1,u=t-e+1,p=Math.log(i),l=.5*Math.exp(2*p/3),m=.5*Math.sqrt(p*l*(i-l)/i)*Math.sign(u-i/2),c=Math.max(e,Math.floor(t-u*l/i+m)),d=Math.min(n,Math.floor(t+(i-u)*l/i+m));OL(r,t,c,d)}let o=r[t],s=e,a=n;for(y.swap(r,e,t),dg(r[n],o)>0&&y.swap(r,e,n);s<a;){for(y.swap(r,s,a),s++,a--;dg(r[s],o)<0;)s=s+1;for(;dg(r[a],o)>0;)a=a-1}dg(r[e],o)===0?y.swap(r,e,a):(a=a+1,y.swap(r,a,n)),a<=t&&(e=a+1),t<=a&&(n=a-1)}}function Bx(r,t,e,n,o){let s=t[t.length-1],[a,i]=[r.length/s,s],u=y.getTypedArrayFromDType(e,a*n),p=y.getTypedArrayFromDType("int32",a*n);for(let m=0;m<a;m++){let c=m*i,d=r.subarray(c,c+i),f=new Array(d.length);d.forEach((T,x)=>f[x]={value:T,index:x}),n<f.length&&(OL(f,n),f=f.slice(0,n)),o&&f.sort(dg);let h=m*n,g=u.subarray(h,h+n),b=p.subarray(h,h+n);for(let T=0;T<n;T++)g[T]=f[T].value,b[T]=f[T].index}let l=t.slice();return l[l.length-1]=n,[xe(l,e,u),xe(l,"int32",p)]}function Ox(r,t,e,n){let o=y.parseAxisParam(t,e)[0],s=[1,e[0],1];for(let f=0;f<o;f++)s[0]*=e[f];s[1]=e[o];for(let f=o+1;f<e.length;f++)s[2]*=e[f];let a={},i=new Int32Array(e[o]),u=new bt(s,n,r),p=[],l=s[0]===1&&s[2]===1;for(let f=0;f<e[o];f++){let h;if(l)h=r[f].toString();else{let g=[];for(let b=0;b<s[0];b++)for(let T=0;T<s[2];T++)g.push(u.get(b,f,T));h=g.join(",")}if(a[h]!==void 0)i[f]=a[h];else{let g=Object.keys(a).length;a[h]=g,i[f]=g,p.push(f)}}let m=s.slice();m[1]=Object.keys(a).length;let c=new bt(m,n);p.forEach((f,h)=>{for(let g=0;g<s[0];g++)for(let b=0;b<s[2];b++)c.set(u.get(g,f,b),g,h,b)});let d=e.slice();return d[o]=m[1],{outputValues:c.values,outputShape:d,indices:i}}var Wre="0.0.0";rp("cpu",()=>new mf,1);var NN=Me(yo,r=>r>=0?r:Math.exp(r)-1),zL={kernelName:yo,backendName:"cpu",kernelFunc:NN};function DN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n;re([o],"leakyRelu");let a=y.sizeFromShape(o.shape),i=e.data.get(o.dataId).values,u=y.getTypedArrayFromDType("float32",a);for(let p=0;p<i.length;p++)u[p]=i[p]<0?s*i[p]:i[p];return e.makeTensorInfo(o.shape,"float32",u)}var GL={kernelName:So,backendName:"cpu",kernelFunc:DN};var Kre=st((r,t)=>r<0?t*r:r);function FN(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t;re([n,o],"prelu");let s=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,[i,u]=Kre(n.shape,o.shape,s,a,"float32");return e.makeTensorInfo(u,"float32",i)}var UL={kernelName:Lo,backendName:"cpu",kernelFunc:FN};var RN=Me(Bo,r=>Math.max(0,r)),WL={kernelName:Bo,backendName:"cpu",kernelFunc:RN};var PN=Me(Go,r=>Math.min(Math.max(0,r),6)),KL={kernelName:Go,backendName:"cpu",kernelFunc:PN};function ql(r,t,e,n,o){if(e==="linear")return jr({inputs:{x:t},backend:r});if(e==="relu")return RN({inputs:{x:t},backend:r});if(e==="elu")return NN({inputs:{x:t},backend:r});if(e==="relu6")return PN({inputs:{x:t},backend:r});if(e==="prelu")return FN({inputs:{x:t,alpha:n},backend:r});if(e==="leakyrelu")return DN({inputs:{x:t},backend:r,attrs:{alpha:o}});if(e==="sigmoid")return SN({inputs:{x:t},backend:r});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function tt(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,a=y.sizeFromShape(o.shape),i=y.inferFromImplicitShape(s,a),u=y.sizeFromShape(i);y.assert(a===u,()=>`The new shape (${i}) has ${u} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),e.incRef(o.dataId);let p=e.data.get(o.dataId);if(p.complexTensorInfos!=null){let l=p.complexTensorInfos.real,m=p.complexTensorInfos.imag;l.shape=i,m.shape=i}return{dataId:o.dataId,shape:i,dtype:o.dtype}}var VL={kernelName:ys,backendName:"cpu",kernelFunc:tt};function MN(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:a,transposeB:i}=n;re([o,s],"matMul");let u=o.shape.length,p=s.shape.length,l=a?o.shape[u-2]:o.shape[u-1],m=i?s.shape[p-1]:s.shape[p-2],c=a?o.shape[u-1]:o.shape[u-2],d=i?s.shape[p-2]:s.shape[p-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(f),b=y.sizeFromShape(h),x=Nr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,d]);y.assert(l===m,()=>`Error in matMul: inner shapes (${l}) and (${m}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,l,c]:[g,c,l],k=i?[b,d,m]:[b,m,d],w=tt({inputs:{x:o},backend:e,attrs:{shape:I}}),R=tt({inputs:{x:s},backend:e,attrs:{shape:k}}),P=a?w.shape[1]:w.shape[2],M=a?w.shape[2]:w.shape[1],L=i?R.shape[1]:R.shape[2],z=Math.max(g,b),W=e.data.get(w.dataId).values,V=e.data.get(R.dataId).values,j=y.computeStrides(w.shape),H=y.computeStrides(R.shape),[X,ee,q]=a?[j[0],1,j[1]]:[j[0],j[1],1],[ne,se,ie]=i?[1,H[1],H[0]]:[H[1],1,H[0]],pe=M*L,ae=xe([z,M,L],w.dtype),ye=ae.values,fe=e.blockSize;for(let Ce=0;Ce<z;Ce++)for(let we=0;we<M;we+=fe)for(let Ee=0;Ee<L;Ee+=fe)for(let $e=0;$e<P;$e+=fe){let Ze=Math.min(we+fe,M),J=Math.min(Ee+fe,L),gt=Math.min($e+fe,P);for(let Be=we;Be<Ze;Be++)for(let Lt=Ee;Lt<J;Lt++){let Pt=0;for(let mt=$e;mt<gt;mt++){let er=Math.min(Ce,g-1)*X,zt=Math.min(Ce,b-1)*ie,on=W[er+Be*ee+mt*q],qt=V[mt*ne+Lt*se+zt];Pt+=on*qt}ye[Ce*pe+(Be*L+Lt)]+=Pt}}return e.disposeIntermediateTensorInfo(w),e.disposeIntermediateTensorInfo(R),e.makeTensorInfo(x,ae.dtype,ae.values)}var HL={kernelName:uo,backendName:"cpu",kernelFunc:MN};function Vre(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=t,{transposeA:u,transposeB:p,activation:l,leakyreluAlpha:m}=n,c,d,f,h=[];c=MN({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:p},backend:e}),a&&(d=Ri({inputs:{a:c,b:a},backend:e}),h.push(c),c=d),l&&(f=ql(e,c,l,i,m),h.push(c),c=f);for(let b of h)e.disposeIntermediateTensorInfo(b);return c}var qL={kernelName:As,backendName:"cpu",kernelFunc:Vre};var Hre=Me(Li,r=>Math.acos(r)),jL={kernelName:Li,backendName:"cpu",kernelFunc:Hre};var qre=Me($i,r=>Math.acosh(r)),XL={kernelName:$i,backendName:"cpu",kernelFunc:qre};function jre(r){let{inputs:t,backend:e}=r,n=t;re(t,"addN");let o=n.map(i=>e.data.get(i.dataId).values),s=xe(n[0].shape,n[0].dtype),a=s.values;for(let i=0;i<n.length;i++){let u=o[i];for(let p=0;p<a.length;p++)a[p]+=u[p]}return e.makeTensorInfo(s.shape,s.dtype,s.values)}var YL={kernelName:so,backendName:"cpu",kernelFunc:jre};function Xre(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;re(o,"all");let i=y.parseAxisParam(s,o.shape),u=i,p=C.getAxesPermutation(u,o.shape.length),l=o;p!=null&&(l=Qt({inputs:{x:o},backend:e,attrs:{perm:p}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("all",u,l.shape.length);let[m,c]=C.computeOutAndReduceShapes(l.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),l.dtype),h=e.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let k=h[T+I];x=x&&k}f[b]=x}p!=null&&e.disposeIntermediateTensorInfo(l);let g=e.makeTensorInfo(m,l.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=tt({inputs:{x:g},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(g),T}return g}var ZL={kernelName:Bi,backendName:"cpu",kernelFunc:Xre};function Yre(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;re(o,"any");let i=y.parseAxisParam(s,o.shape),u=i,p=C.getAxesPermutation(u,o.shape.length),l=o;p!=null&&(l=Qt({inputs:{x:o},backend:e,attrs:{perm:p}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("any",u,l.shape.length);let[m,c]=C.computeOutAndReduceShapes(l.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),l.dtype),h=e.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let k=h[T+I];x=x||k}f[b]=x}p!=null&&e.disposeIntermediateTensorInfo(l);let g=e.makeTensorInfo(m,l.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=tt({inputs:{x:g},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(g),T}return g}var QL={kernelName:Oi,backendName:"cpu",kernelFunc:Yre};function Zre(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;re(o,"argMax");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,p=[];i!=null&&(u=Qt({inputs:{x:o},backend:e,attrs:{perm:i}}),p.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMax",a,u.shape.length);let[l,m]=C.computeOutAndReduceShapes(u.shape,a),c=y.sizeFromShape(l),d=y.makeZerosTypedArray(c,"int32"),f=y.sizeFromShape(m),h=e.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let b=g*f,T=h[b],x=0;for(let I=0;I<f;++I){let k=h[b+I];k>T&&(T=k,x=I)}d[g]=x}return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(l,"int32",d)}var JL={kernelName:ao,backendName:"cpu",kernelFunc:Zre};function Qre(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n;re(o,"argMin");let a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,p=[];i!=null&&(u=Qt({inputs:{x:o},backend:e,attrs:{perm:i}}),p.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],C.assertAxesAreInnerMostDims("argMin",a,u.shape.length);let[l,m]=C.computeOutAndReduceShapes(u.shape,a),c=y.sizeFromShape(l),d=y.makeZerosTypedArray(c,"int32"),f=y.sizeFromShape(m),h=e.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let b=g*f,T=h[b],x=0;for(let I=0;I<f;++I){let k=h[b+I];k<T&&(T=k,x=I)}d[g]=x}return p.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.makeTensorInfo(l,"int32",d)}var e$={kernelName:di,backendName:"cpu",kernelFunc:Qre};var Jre=Me(zi,r=>Math.asin(r)),t$={kernelName:zi,backendName:"cpu",kernelFunc:Jre};var ene=Me(Gi,r=>Math.asinh(r)),r$={kernelName:Gi,backendName:"cpu",kernelFunc:ene};var tne=Me(Ui,r=>Math.atan(r)),n$={kernelName:Ui,backendName:"cpu",kernelFunc:tne};var rne=st((r,t)=>Math.atan2(r,t)),nne=pt(fa,rne),o$={kernelName:fa,backendName:"cpu",kernelFunc:nne};var one=Me(Wi,r=>Math.atanh(r)),s$={kernelName:Wi,backendName:"cpu",kernelFunc:one};function Tf(r,t,e,n,o,s){let a=o.strideHeight,i=o.strideWidth,u=o.dilationHeight,p=o.dilationWidth,l=o.effectiveFilterHeight,m=o.effectiveFilterWidth,c=o.padInfo.top,d=o.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=xe(o.outShape,e),g=h.values,b=o.outShape[1]*o.outShape[2]*o.outShape[3],T=o.outShape[2]*o.outShape[3],x=o.outShape[3];for(let I=0;I<o.batchSize;++I){let k=I*b,w=I*n[0];for(let R=0;R<o.inChannels;++R)for(let P=0;P<o.outHeight;++P){let M=P*a-c,L=Math.max(0,M),z=Math.min(o.inHeight,l+M),W=k+P*T;for(let V=0;V<o.outWidth;++V){let j=V*i-d,H=Math.max(0,j),X=Math.min(o.inWidth,m+j),ee=f,q=0,ne=0;for(let ie=L;ie<z;ie+=u){let pe=w+ie*n[1];for(let ae=H;ae<X;ae+=p){let ye=pe+ae*n[2],fe=r[ye+R];s==="max"&&fe>ee?ee=fe:s==="avg"&&(q+=fe,ne++)}if(isNaN(ee))break}let se=W+V*x+R;g[se]=s==="avg"?q/ne:ee}}}return h}function zx(r,t,e,n,o=!1,s=!1){let a=xe(n.outShape,"int32"),i=n.strideHeight,u=n.strideWidth,p=n.dilationHeight,l=n.dilationWidth,m=n.effectiveFilterHeight,c=n.effectiveFilterWidth,d=n.padInfo.top,f=n.padInfo.left,h=xe(t,e,r);for(let g=0;g<n.batchSize;++g)for(let b=0;b<n.inChannels;++b)for(let T=0;T<n.outHeight;++T){let x=T*i-d,I=x;for(;I<0;)I+=p;let k=Math.min(n.inHeight,m+x);for(let w=0;w<n.outWidth;++w){let R=w*u-f,P=R;for(;P<0;)P+=l;let M=Math.min(n.inWidth,c+R),L=Number.NEGATIVE_INFINITY,z=-1;for(let W=I;W<k;W+=p){let V=W-x;for(let j=P;j<M;j+=l){let H=j-R,X=h.get(g,W,j,b);X>L&&(L=X,o?z=s?((g*n.inHeight+W)*n.inWidth+j)*n.inChannels+b:(W*n.inWidth+j)*n.inChannels+b:z=V*c+H)}}a.set(z,g,T,w,b)}}return a}function Gx(r,t,e,n,o,s){let a=o.strideDepth,i=o.strideHeight,u=o.strideWidth,p=o.dilationDepth,l=o.dilationHeight,m=o.dilationWidth,c=o.effectiveFilterDepth,d=o.effectiveFilterHeight,f=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,b=o.padInfo.left,T=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=xe(o.outShape,e),I=x.values,k=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],w=o.outShape[2]*o.outShape[3]*o.outShape[4],R=o.outShape[3]*o.outShape[4],P=o.outShape[4];for(let M=0;M<o.batchSize;++M){let L=M*k,z=M*n[0];for(let W=0;W<o.inChannels;++W)for(let V=0;V<o.outDepth;++V){let j=V*a-h,H=j;for(;H<0;)H+=p;let X=Math.min(o.inDepth,c+j),ee=L+V*w;for(let q=0;q<o.outHeight;++q){let ne=q*i-g,se=ne;for(;se<0;)se+=l;let ie=Math.min(o.inHeight,d+ne),pe=ee+q*R;for(let ae=0;ae<o.outWidth;++ae){let ye=ae*u-b,fe=ye;for(;fe<0;)fe+=m;let Ce=Math.min(o.inWidth,f+ye),we=pe+ae*P,Ee=T,$e=0,Ze=0;for(let gt=H;gt<X;gt+=p){let Be=z+gt*n[1];for(let Lt=se;Lt<ie;Lt+=l){let Pt=Be+Lt*n[2];for(let mt=fe;mt<Ce;mt+=m){let er=Pt+mt*n[3],zt=r[er+W];if(s==="max"&&zt>Ee?Ee=zt:s==="avg"&&($e+=zt,Ze++),isNaN(Ee))break}if(isNaN(Ee))break}if(isNaN(Ee))break}let J=we+W;I[J]=s==="avg"?$e/Ze:Ee}}}}return x}function a$(r,t){let e=xe(t.outShape,"int32"),n=t.strideDepth,o=t.strideHeight,s=t.strideWidth,a=t.dilationDepth,i=t.dilationHeight,u=t.dilationWidth,p=t.effectiveFilterDepth,l=t.effectiveFilterHeight,m=t.effectiveFilterWidth,c=t.padInfo.front,d=t.padInfo.top,f=t.padInfo.left;for(let h=0;h<t.batchSize;++h)for(let g=0;g<t.inChannels;++g)for(let b=0;b<t.outDepth;++b){let T=b*n-c,x=T;for(;x<0;)x+=a;let I=Math.min(t.inDepth,p+T);for(let k=0;k<t.outHeight;++k){let w=k*o-d,R=w;for(;R<0;)R+=i;let P=Math.min(t.inHeight,l+w);for(let M=0;M<t.outWidth;++M){let L=M*s-f,z=L;for(;z<0;)z+=u;let W=Math.min(t.inWidth,m+L),V=Number.NEGATIVE_INFINITY,j=-1;for(let H=x;H<I;H+=a){let X=H-T;for(let ee=R;ee<P;ee+=i){let q=ee-w;for(let ne=z;ne<W;ne+=u){let se=ne-L,ie=r.get(h,H,ee,ne,g);ie>=V&&(V=ie,j=X*l*m+q*l+se)}}}e.set(j,h,b,k,M,g)}}}return e}function sne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;re(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,p=1;y.assert(C.eitherStridesOrDilationsAreOne(a,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let l=C.computePool2DInfo(o.shape,s,a,p,i,u),m;if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))m=jr({inputs:{x:o},backend:e});else{let c=e.data.get(o.dataId).values,d=y.computeStrides(o.shape),f=Tf(c,o.shape,o.dtype,d,l,"avg");m=e.makeTensorInfo(l.outShape,o.dtype,f.values)}return m}var i$={kernelName:io,backendName:"cpu",kernelFunc:sne};function ane(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:p}=n;re(o,"avgPool3d");let l=C.computePool3DInfo(o.shape,s,a,1,i,u,p),m=e.data.get(o.dataId).values,c=Gx(m,o.shape,o.dtype,y.computeStrides(o.shape),l,"avg");return e.makeTensorInfo(c.shape,"float32",c.values)}var u$={kernelName:Eu,backendName:"cpu",kernelFunc:ane};function ine(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:a,strides:i,pad:u,dimRoundingMode:p}=n;re([o,s],"avgPool3DGrad");let l=C.computePool3DInfo(s.shape,a,i,1,u,p),m=l.strideDepth,c=l.strideHeight,d=l.strideWidth,f=l.filterDepth,h=l.filterHeight,g=l.filterWidth,b=l.dilationDepth,T=l.dilationHeight,x=l.dilationWidth,I=l.effectiveFilterDepth,k=l.effectiveFilterHeight,w=l.effectiveFilterWidth,R=I-1-l.padInfo.front,P=w-1-l.padInfo.left,M=k-1-l.padInfo.top,L=xe(s.shape,"float32"),z=1/(f*h*g),W=e.bufferSync(o);for(let V=0;V<l.batchSize;++V)for(let j=0;j<l.inChannels;++j)for(let H=0;H<l.inDepth;++H)for(let X=0;X<l.inHeight;++X)for(let ee=0;ee<l.inWidth;++ee){let q=H-R,ne=X-M,se=ee-P,ie=0;for(let pe=0;pe<I;pe+=b){let ae=(q+pe)/m;if(!(ae<0||ae>=l.outDepth||Math.floor(ae)!==ae))for(let ye=0;ye<k;ye+=T){let fe=(ne+ye)/c;if(!(fe<0||fe>=l.outHeight||Math.floor(fe)!==fe))for(let Ce=0;Ce<w;Ce+=x){let we=(se+Ce)/d;if(we<0||we>=l.outWidth||Math.floor(we)!==we)continue;ie+=W.get(V,ae,fe,we,j)}}}L.set(ie*z,V,H,X,ee,j)}return e.makeTensorInfo(L.shape,L.dtype,L.values)}var p$={kernelName:Mm,backendName:"cpu",kernelFunc:ine};function une(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,a=s;re([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:p}=n,l=C.computePool2DInfo(a.shape,i,u,1,p),m=l.strideHeight,c=l.strideWidth,d=l.filterHeight,f=l.filterWidth,h=l.dilationHeight,g=l.dilationWidth,b=l.effectiveFilterHeight,T=l.effectiveFilterWidth,x=T-1-l.padInfo.left,I=b-1-l.padInfo.top,k=xe(a.shape,"float32"),w=1/(d*f),R=e.data.get(o.dataId).values,P=xe(o.shape,"float32",R);for(let M=0;M<l.batchSize;++M)for(let L=0;L<l.inChannels;++L)for(let z=0;z<l.inHeight;++z)for(let W=0;W<l.inWidth;++W){let V=z-I,j=W-x,H=0;for(let X=0;X<b;X+=h){let ee=(V+X)/m;if(!(ee<0||ee>=l.outHeight||Math.floor(ee)!==ee))for(let q=0;q<T;q+=g){let ne=(j+q)/c;if(ne<0||ne>=l.outWidth||Math.floor(ne)!==ne)continue;H+=P.get(M,ee,ne,L)}}k.set(H*w,M,z,W,L)}return e.makeTensorInfo(k.shape,k.dtype,k.values)}var l$={kernelName:Pm,backendName:"cpu",kernelFunc:une};function pne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,scale:s,offset:a,mean:i,variance:u}=t;y.assert(i.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(s==null||i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),re([o,i,u,s,a],"batchNorm");let{varianceEpsilon:p}=n;p==null&&(p=.001);let l=e.data.get(o.dataId).values,m=e.data.get(i.dataId).values,c=e.data.get(u.dataId).values,d=s?e.data.get(s.dataId).values:new Float32Array([1]),f=a?e.data.get(a.dataId).values:new Float32Array([0]),h=new Float32Array(l.length),g=f.length,b=d.length,T=c.length,x=m.length,I=0,k=0,w=0,R=0;for(let P=0;P<l.length;++P)h[P]=f[I++]+(l[P]-m[k++])*d[w++]/Math.sqrt(c[R++]+p),I>=g&&(I=0),k>=x&&(k=0),w>=b&&(w=0),R>=T&&(R=0);return e.makeTensorInfo(o.shape,o.dtype,h)}var m$={kernelName:Co,backendName:"cpu",kernelFunc:pne};function lne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:a}=n;re([o],"batchToSpaceND");let i=s.reduce((b,T)=>b*T),u=C.getReshaped(o.shape,s,i),p=C.getPermuted(u.length,s.length),l=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(l,a,s.length),d=tt({inputs:{x:o},backend:e,attrs:{shape:u}}),f=Qt({inputs:{x:d},backend:e,attrs:{perm:p}}),h=tt({inputs:{x:f},backend:e,attrs:{shape:l}}),g=Ys({inputs:{x:h},backend:e,attrs:{begin:m,size:c}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),g}var c$={kernelName:ms,backendName:"cpu",kernelFunc:lne};function mne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:a}=n,i=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,p=ff(i,u,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,p)}var d$={kernelName:Em,backendName:"cpu",kernelFunc:mne};function cne(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.data.get(n.dataId).values,a=e.data.get(o.dataId).values,i=C.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return e.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var f$={kernelName:_m,backendName:"cpu",kernelFunc:cne};var dne=Me(Kn,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),h$={kernelName:Kn,backendName:"cpu",kernelFunc:dne};var fne=r=>{let{x:t}=r.inputs,e=r.backend,n=new Float32Array(y.sizeFromShape(t.shape)),o=e.data.get(t.dataId),s=o.complexTensorInfos.real,a=o.complexTensorInfos.imag,i=e.data.get(s.dataId).values,u=e.data.get(a.dataId).values;for(let p=0;p<i.length;p++){let l=i[p],m=u[p];n[p]=Math.hypot(l,m)}return e.makeOutput(n,t.shape,"float32")},g$={kernelName:Lu,backendName:"cpu",kernelFunc:fne};function Pi(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.data.get(n.dataId).complexTensorInfos.imag,s=e.data.get(o.dataId).values;return e.makeTensorInfo(o.shape,o.dtype,s)}var b$={kernelName:zu,backendName:"cpu",kernelFunc:Pi};function Fp(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,t[0].shape)[0],a=C.computeOutShape(t.map(h=>h.shape),s);if(y.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(h=>y.sizeFromShape(h.shape)>0);if(i.length===1)return jr({inputs:{x:i[0]},backend:e});let u=i.map(h=>h.shape);if(C.assertParamsConsistent(u,s),i[0].dtype==="complex64"){let h=i.map(I=>Hs({inputs:{input:I},backend:e})),g=i.map(I=>Pi({inputs:{input:I},backend:e})),b=Fp({inputs:h,backend:e,attrs:{axis:s}}),T=Fp({inputs:g,backend:e,attrs:{axis:s}}),x=Ar({inputs:{real:b,imag:T},backend:e});return h.forEach(I=>e.disposeIntermediateTensorInfo(I)),g.forEach(I=>e.disposeIntermediateTensorInfo(I)),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),x}let p=i.map(h=>{let g=y.sizeFromShape(h.shape.slice(s));return tt({inputs:{x:h},backend:e,attrs:{shape:[-1,g]}})}),l=p.map(h=>({vals:e.data.get(h.dataId).values,shape:h.shape}));a=C.computeOutShape(p.map(h=>h.shape),1);let m=p[0].shape[0]===1,c=zl(l,a,t[0].dtype,m),d=C.computeOutShape(i.map(h=>h.shape),s),f=e.makeTensorInfo(d,t[0].dtype,c);return p.forEach(h=>e.disposeIntermediateTensorInfo(h)),f}var y$={kernelName:cs,backendName:"cpu",kernelFunc:Fp};function EN(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dataFormat:u,dilations:p,dimRoundingMode:l}=n;re([o,s],"conv2d");let m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,p,i,l,!1,m),d=c.filterHeight,f=c.filterWidth,h=c.dilationHeight,g=c.dilationWidth,b=c.padInfo.left,T=c.padInfo.top,x=c.dataFormat==="channelsLast",I=new bt(c.outShape,o.dtype),k=y.computeStrides(o.shape),w=y.computeStrides(s.shape),R=k[0],P=x?k[1]:k[2],M=x?k[2]:1,L=x?1:k[1],z=I.strides[0],W=x?I.strides[1]:I.strides[2],V=x?I.strides[2]:1,j=x?1:I.strides[1],H=e.data.get(o.dataId).values,X=e.data.get(s.dataId).values,ee=I.values;for(let q=0;q<c.batchSize;++q){let ne=q*R,se=q*z;for(let ie=0;ie<c.outHeight;++ie){let pe=se+ie*W,ae=ie*c.strideHeight-T;for(let ye=0;ye<d;++ye){let fe=ae+ye*h;if(fe<0||fe>=c.inHeight)continue;let Ce=ye*w[0],we=ne+fe*P;for(let Ee=0;Ee<c.outWidth;++Ee){let $e=pe+Ee*V,Ze=Ee*c.strideWidth-b;for(let J=0;J<f;++J){let gt=Ze+J*g;if(gt<0||gt>=c.inWidth)continue;let Be=Ce+J*w[1],Lt=we+gt*M,Pt=Be;for(let mt=0;mt<c.inChannels;++mt){let er=H[Lt+mt*L];for(let zt=0;zt<c.outChannels;++zt)ee[$e+zt*j]+=er*X[Pt+zt];Pt+=c.outChannels}}}}}}return e.makeTensorInfo(I.shape,I.dtype,ee)}var T$={kernelName:lo,backendName:"cpu",kernelFunc:EN};function hne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:a,pad:i,dataFormat:u,dimRoundingMode:p,filterShape:l}=n;re([o,s],"conv2dBackpropFilter");let m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,l,a,1,i,p,!1,m),{strideHeight:d,strideWidth:f,filterHeight:h,filterWidth:g}=c,b=c.dataFormat==="channelsLast",T=new bt(c.filterShape,"float32"),x=c.padInfo.left,I=c.padInfo.top,k=e.data.get(o.dataId).values,w=e.data.get(s.dataId).values,R=new bt(o.shape,o.dtype,k),P=new bt(s.shape,s.dtype,w);for(let M=0;M<h;++M){let L=Math.max(0,Math.ceil((I-M)/d)),z=Math.min(c.outHeight,(c.inHeight+I-M)/d);for(let W=0;W<g;++W){let V=Math.max(0,Math.ceil((x-W)/f)),j=Math.min(c.outWidth,(c.inWidth+x-W)/f);for(let H=0;H<c.inChannels;++H)for(let X=0;X<c.outChannels;++X){let ee=0;for(let q=0;q<c.batchSize;++q)for(let ne=L;ne<z;++ne){let se=M+ne*d-I;for(let ie=V;ie<j;++ie){let pe=W+ie*f-x;b?ee+=R.get(q,se,pe,H)*P.get(q,ne,ie,X):ee+=R.get(q,H,se,pe)*P.get(q,X,ne,ie)}}T.set(ee,M,W,H,X)}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}var x$={kernelName:Lm,backendName:"cpu",kernelFunc:hne};function gne(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:a,strides:i,pad:u,dataFormat:p,dimRoundingMode:l}=n;re([o,s],"conv2dBackpropInput");let m=y.computeStrides(s.shape),c=y.computeStrides(o.shape),d=C.convertConv2DDataFormat(p),f=C.computeConv2DInfo(a,s.shape,i,1,u,l,!1,d),h=new bt(f.inShape,"float32"),g=h.values,b=e.data.get(o.dataId).values,T=e.data.get(s.dataId).values,[x,I,k]=m,{batchSize:w,filterHeight:R,filterWidth:P,inChannels:M,inHeight:L,inWidth:z,outChannels:W,outHeight:V,outWidth:j,strideHeight:H,strideWidth:X}=f;d=f.dataFormat;let ee=R-1-f.padInfo.top,q=P-1-f.padInfo.left,ne=d==="channelsLast",se=h.strides[0],ie=ne?h.strides[1]:h.strides[2],pe=ne?h.strides[2]:1,ae=ne?1:h.strides[1],ye=c[0],fe=ne?c[1]:c[2],Ce=ne?c[2]:1,we=ne?1:c[1];for(let Ee=0;Ee<w;++Ee)for(let $e=0;$e<M;++$e)for(let Ze=0;Ze<L;++Ze){let J=Ze-ee,gt=Math.max(0,Math.ceil(J/H)),Be=Math.min(V,(R+J)/H);for(let Lt=0;Lt<z;++Lt){let Pt=Lt-q,mt=Math.max(0,Math.ceil(Pt/X)),er=Math.min(j,(P+Pt)/X),zt=0;for(let qt=gt;qt<Be;++qt){let na=qt*H-J;for(let Br=mt;Br<er;++Br){let sn=Br*X-Pt,an=ye*Ee+fe*qt+Ce*Br,Xr=x*(R-1-na)+I*(P-1-sn)+k*$e;for(let us=0;us<W;++us){let zn=b[an+we*us],oa=T[Xr+us];zt+=zn*oa}}}let on=se*Ee+ie*Ze+pe*Lt+ae*$e;g[on]=zt}}return e.makeTensorInfo(h.shape,h.dtype,h.values)}var I$={kernelName:mo,backendName:"cpu",kernelFunc:gne};function bne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dilations:u}=n;re([o,s],"conv3d");let p=C.computeConv3DInfo(o.shape,s.shape,a,u,i),{filterDepth:l,filterHeight:m,filterWidth:c,dilationDepth:d,dilationHeight:f,dilationWidth:h,padInfo:g}=p,b=g.front,T=g.left,x=g.top,I=new bt(p.outShape,o.dtype),k=e.data.get(o.dataId).values,w=e.data.get(s.dataId).values,R=I.values,P=y.computeStrides(o.shape),M=y.computeStrides(s.shape);for(let L=0;L<p.batchSize;++L){let z=L*P[0],W=L*I.strides[0];for(let V=0;V<p.outDepth;++V){let j=W+V*I.strides[1],H=V*p.strideDepth-b;for(let X=0;X<l;++X){let ee=H+X*d;if(ee<0||ee>=p.inDepth)continue;let q=X*M[0],ne=z+ee*P[1];for(let se=0;se<p.outHeight;++se){let ie=j+se*I.strides[2],pe=se*p.strideHeight-x;for(let ae=0;ae<m;++ae){let ye=pe+ae*f;if(ye<0||ye>=p.inHeight)continue;let fe=q+ae*M[1],Ce=ne+ye*P[2];for(let we=0;we<p.outWidth;++we){let Ee=ie+we*p.outChannels,$e=we*p.strideWidth-T;for(let Ze=0;Ze<c;++Ze){let J=$e+Ze*h;if(J<0||J>=p.inWidth)continue;let gt=fe+Ze*M[2],Be=Ce+J*p.inChannels,Lt=gt;for(let Pt=0;Pt<p.inChannels;++Pt){let mt=k[Be+Pt];for(let er=0;er<p.outChannels;++er)R[Ee+er]+=mt*w[Lt+er];Lt+=p.outChannels}}}}}}}}return e.makeTensorInfo(I.shape,I.dtype,I.values)}var C$={kernelName:$u,backendName:"cpu",kernelFunc:bne};function yne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:a,pad:i,filterShape:u}=n;re([o,s],"conv3dBackpropFilterV2");let p=y.computeStrides(o.shape),l=y.computeStrides(s.shape),m=C.computeConv3DInfo(o.shape,u,a,1,i),c=m.strideDepth,d=m.strideHeight,f=m.strideWidth,h=m.filterDepth,g=m.filterHeight,b=m.filterWidth,T=new bt(m.filterShape,"float32"),x=T.values,[I,k,w,R]=T.strides,P=e.data.get(s.dataId).values,[M,L,z,W]=l,V=e.data.get(o.dataId).values,[j,H,X,ee]=p,q=m.padInfo.front,ne=m.padInfo.left,se=m.padInfo.top;for(let ie=0;ie<h;++ie){let pe=Math.max(0,Math.ceil((q-ie)/c)),ae=Math.min(m.outDepth,(m.inDepth+q-ie)/c),ye=ie*I;for(let fe=0;fe<g;++fe){let Ce=Math.max(0,Math.ceil((se-fe)/d)),we=Math.min(m.outHeight,(m.inHeight+se-fe)/d),Ee=fe*k+ye;for(let $e=0;$e<b;++$e){let Ze=Math.max(0,Math.ceil((ne-$e)/f)),J=Math.min(m.outWidth,(m.inWidth+ne-$e)/f),gt=$e*w+Ee;for(let Be=0;Be<m.inChannels;++Be){let Lt=Be*R+gt;for(let Pt=0;Pt<m.outChannels;++Pt){let mt=0;for(let er=0;er<m.batchSize;++er){let zt=er*j,on=er*M;for(let qt=pe;qt<ae;++qt){let Br=(ie+qt*c-q)*H+zt,sn=qt*L+on;for(let an=Ce;an<we;++an){let us=(fe+an*d-se)*X+Br,zn=an*z+sn;for(let oa=Ze;oa<J;++oa){let Fu=($e+oa*f-ne)*ee+us,Op=oa*W+zn;mt+=V[Fu+Be]*P[Op+Pt]}}}}x[Lt+Pt]=mt}}}}}return e.makeTensorInfo(T.shape,T.dtype,T.values)}var k$={kernelName:$m,backendName:"cpu",kernelFunc:yne};function Tne(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:a,strides:i,inputShape:u}=n;re([o],"conv3dBackpropInputV2");let p=y.computeStrides(o.shape),l=y.computeStrides(s.shape),m=C.computeConv3DInfo(u,s.shape,i,1,a),c=new bt(m.inShape,"float32"),d=c.values,[f,h,g,b]=c.strides,T=e.data.get(o.dataId).values,[x,I,k,w]=p,R=e.data.get(s.dataId).values,[P,M,L,z]=l,{batchSize:W,filterDepth:V,filterHeight:j,filterWidth:H,inChannels:X,inDepth:ee,inHeight:q,inWidth:ne,outChannels:se,outDepth:ie,outHeight:pe,outWidth:ae,strideDepth:ye,strideHeight:fe,strideWidth:Ce}=m,we=V-1-m.padInfo.front,Ee=j-1-m.padInfo.top,$e=H-1-m.padInfo.left;for(let Ze=0;Ze<W;++Ze)for(let J=0;J<X;++J)for(let gt=0;gt<ee;++gt){let Be=gt-we,Lt=Math.max(0,Math.ceil(Be/ye)),Pt=Math.min(ie,(V+Be)/ye);for(let mt=0;mt<q;++mt){let er=mt-Ee,zt=Math.max(0,Math.ceil(er/fe)),on=Math.min(pe,(j+er)/fe);for(let qt=0;qt<ne;++qt){let na=qt-$e,Br=Math.max(0,Math.ceil(na/Ce)),sn=Math.min(ae,(H+na)/Ce),an=0;for(let Xr=Lt;Xr<Pt;++Xr){let us=Xr*ye-Be;for(let zn=zt;zn<on;++zn){let oa=zn*fe-er;for(let ps=Br;ps<sn;++ps){let Fu=ps*Ce-na,Op=x*Ze+I*Xr+k*zn+w*ps,cm=P*(V-1-us)+M*(j-1-oa)+L*(H-1-Fu)+z*J;for(let Cr=0;Cr<se;++Cr){let dm=T[Op+Cr],fm=R[cm+Cr];an+=dm*fm}}}}d[f*Ze+h*gt+g*mt+b*qt+J]=an}}}return e.makeTensorInfo(c.shape,c.dtype,c.values)}var S$={kernelName:Bm,backendName:"cpu",kernelFunc:Tne};var xne=Me(co,r=>Math.cos(r)),v$={kernelName:co,backendName:"cpu",kernelFunc:xne};var Ine=Me(fo,r=>Math.cosh(r)),A$={kernelName:fo,backendName:"cpu",kernelFunc:Ine};function Cne(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:a}=t,{cropSize:i,method:u,extrapolationValue:p}=n,[l,m,c,d]=o.shape,f=s.shape[0],[h,g]=i,b=xe([f,h,g,d],"float32"),T=e.data.get(s.dataId).values,x=e.data.get(a.dataId).values,I=e.data.get(o.dataId).values,k=y.computeStrides(o.shape),w=y.computeStrides(b.shape);for(let R=0;R<f;R++){let P=R*4,M=T[P],L=T[P+1],z=T[P+2],W=T[P+3],V=x[R];if(V>=l)continue;let j=h>1?(z-M)*(m-1)/(h-1):0,H=g>1?(W-L)*(c-1)/(g-1):0;for(let X=0;X<h;X++){let ee=h>1?M*(m-1)+X*j:.5*(M+z)*(m-1);if(ee<0||ee>m-1){for(let q=0;q<g;q++)for(let ne=0;ne<d;ne++){let se=ne+q*w[2]+X*w[1]+R*w[0];b.values[se]=p}continue}if(u==="bilinear"){let q=Math.floor(ee),ne=Math.ceil(ee),se=ee-q;for(let ie=0;ie<g;ie++){let pe=g>1?L*(c-1)+ie*H:.5*(L+W)*(c-1);if(pe<0||pe>c-1){for(let Ce=0;Ce<d;Ce++){let we=Ce+ie*w[2]+X*w[1]+R*w[0];b.values[we]=p}continue}let ae=Math.floor(pe),ye=Math.ceil(pe),fe=pe-ae;for(let Ce=0;Ce<d;Ce++){let we=Ce+ae*k[2]+q*k[1]+V*k[0],Ee=I[we];we=Ce+ye*k[2]+q*k[1]+V*k[0];let $e=I[we];we=Ce+ae*k[2]+ne*k[1]+V*k[0];let Ze=I[we];we=Ce+ye*k[2]+ne*k[1]+V*k[0];let J=I[we],gt=Ee+($e-Ee)*fe,Be=Ze+(J-Ze)*fe;we=Ce+ie*w[2]+X*w[1]+R*w[0],b.values[we]=gt+(Be-gt)*se}}}else for(let q=0;q<g;++q){let ne=g>1?L*(c-1)+q*H:.5*(L+W)*(c-1);if(ne<0||ne>c-1){for(let pe=0;pe<d;pe++){let ae=pe+q*w[2]+X*w[1]+R*w[0];b.values[ae]=p}continue}let se=Math.round(ne),ie=Math.round(ee);for(let pe=0;pe<d;pe++){let ae=pe+se*k[2]+ie*k[1]+V*k[0],ye=pe+q*w[2]+X*w[1]+R*w[0];b.values[ye]=I[ae]}}}}return e.makeTensorInfo(b.shape,b.dtype,b.values)}var w$={kernelName:ga,backendName:"cpu",kernelFunc:Cne};function kne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n;re(o,"cumprod");let u=C.getAxesPermutation([s],o.shape.length),p=o;u!=null&&(p=Qt({inputs:{x:o},backend:e,attrs:{perm:u}}));let l=C.getInnerMostAxes(1,o.shape.length)[0];if(l!==p.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${l}`);let m=$t(p.dtype,"int32"),c=y.makeOnesTypedArray(y.sizeFromShape(p.shape),m),d=e.data.get(p.dataId).values,f=p.shape[p.shape.length-1],h=i?(b,T)=>b+f-T-1:(b,T)=>b+T;for(let b=0;b<d.length;b+=f)for(let T=0;T<f;T++){let x=h(b,T);if(T===0)c[x]=a?1:d[x];else{let I=h(b,T-1);c[x]=a?d[I]*c[I]:d[x]*c[I]}}let g=e.makeTensorInfo(p.shape,m,c);if(u!=null){let b=C.getUndoAxesPermutation(u),T=Qt({inputs:{x:g},backend:e,attrs:{perm:b}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(p),T}return g}var N$={kernelName:ha,backendName:"cpu",kernelFunc:kne};function Sne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n;re(o,"cumsum");let u=C.getAxesPermutation([s],o.shape.length),p=o;u!=null&&(p=Qt({inputs:{x:o},backend:e,attrs:{perm:u}}));let l=C.getInnerMostAxes(1,o.shape.length)[0];if(l!==p.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${l}`);let m=$t(p.dtype,"int32"),c=y.makeZerosTypedArray(y.sizeFromShape(p.shape),m),d=e.data.get(p.dataId).values,f=p.shape[p.shape.length-1],h=i?(b,T)=>b+f-T-1:(b,T)=>b+T;for(let b=0;b<d.length;b+=f)for(let T=0;T<f;T++){let x=h(b,T);if(T===0)c[x]=a?0:d[x];else{let I=h(b,T-1);c[x]=a?d[I]+c[I]:d[x]+c[I]}}let g=e.makeTensorInfo(p.shape,m,c);if(u!=null){let b=C.getUndoAxesPermutation(u),T=Qt({inputs:{x:g},backend:e,attrs:{perm:b}});return e.disposeIntermediateTensorInfo(g),e.disposeIntermediateTensorInfo(p),T}return g}var D$={kernelName:ho,backendName:"cpu",kernelFunc:Sne};function vne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,l=ff(u,p,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,l)}else if(o.shape.length===2){let u=e.bufferSync(o),p=e.bufferSync(s),l=Nx(u,p,a,i);return e.makeTensorInfo(l.shape,s.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var F$={kernelName:Om,backendName:"cpu",kernelFunc:vne};function Ane(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:a}=n;y.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);let i=o.shape[0],u=o.shape[1],p=o.shape[2],l=o.shape[3],m=u*s,c=p*s,d=l/(s*s),f=e.data.get(o.dataId).values,h=new Float32Array(i*m*c*d),g=0;for(let b=0;b<i;++b)for(let T=0;T<m;++T){let x=Math.floor(T/s),I=T%s;for(let k=0;k<c;++k){let w=Math.floor(k/s),R=k%s,P=(I*s+R)*d;for(let M=0;M<d;++M){let z=M+P+l*(w+p*(x+u*b));h[g++]=f[z]}}}return e.makeTensorInfo([i,m,c,d],o.dtype,h)}var R$={kernelName:ba,backendName:"cpu",kernelFunc:Ane};function _N(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dilations:u,dimRoundingMode:p}=n;re([o,s],"depthwiseConv2DNative");let l=y.computeStrides(o.shape),m=y.computeStrides(s.shape),c=u;c==null&&(c=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,c),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);let d=C.computeConv2DInfo(o.shape,s.shape,a,c,i,p,!0),{filterHeight:f,filterWidth:h,dilationHeight:g,dilationWidth:b,padInfo:T}=d,x=T.left,I=T.top,k=d.outChannels/d.inChannels,w=new bt(d.outShape,o.dtype),R=e.data.get(o.dataId).values,P=e.data.get(s.dataId).values,M=w.values;for(let L=0;L<d.batchSize;++L){let z=L*l[0],W=L*w.strides[0];for(let V=0;V<d.outHeight;++V){let j=W+V*w.strides[1],H=V*d.strideHeight-I;for(let X=0;X<f;++X){let ee=H+X*g;if(ee<0||ee>=d.inHeight)continue;let q=X*m[0],ne=z+ee*l[1];for(let se=0;se<d.outWidth;++se){let ie=j+se*w.strides[2],pe=se*d.strideWidth-x;for(let ae=0;ae<h;++ae){let ye=pe+ae*b;if(ye<0||ye>=d.inWidth)continue;let fe=q+ae*m[1],Ce=ne+ye*d.inChannels,we=ie,Ee=fe;for(let $e=0;$e<d.inChannels;++$e){let Ze=R[Ce+$e];for(let J=0;J<k;++J)M[we+J]+=Ze*P[Ee+J];we+=k,Ee+=k}}}}}}return e.makeTensorInfo(w.shape,w.dtype,w.values)}var P$={kernelName:go,backendName:"cpu",kernelFunc:_N};function wne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:a,dilations:i,pad:u,dimRoundingMode:p,filterShape:l}=n;re([o,s],"depthwiseConv2dNativeBackpropFilter");let m=C.computeConv2DInfo(o.shape,l,a,i,u,p,!0),{strideHeight:c,strideWidth:d,filterHeight:f,filterWidth:h}=m,g=new bt(m.filterShape,"float32"),b=m.padInfo.left,T=m.padInfo.top,x=m.outChannels/m.inChannels,I=e.data.get(o.dataId).values,k=new bt(o.shape,o.dtype,I),w=e.data.get(s.dataId).values,R=new bt(s.shape,s.dtype,w);for(let P=0;P<f;++P){let M=Math.max(0,Math.ceil((T-P)/c)),L=Math.min(m.outHeight,(m.inHeight+T-P)/c);for(let z=0;z<h;++z){let W=Math.max(0,Math.ceil((b-z)/d)),V=Math.min(m.outWidth,(m.inWidth+b-z)/d);for(let j=0;j<m.outChannels;++j){let H=Math.trunc(j/x),X=j%x,ee=0;for(let q=0;q<m.batchSize;++q)for(let ne=M;ne<L;++ne){let se=P+ne*c-T;for(let ie=W;ie<V;++ie){let pe=z+ie*d-b;ee+=k.get(q,se,pe,H)*R.get(q,ne,ie,j)}}g.set(ee,P,z,H,X)}}}return e.makeTensorInfo(g.shape,g.dtype,g.values)}var M$={kernelName:zm,backendName:"cpu",kernelFunc:wne};function Nne(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:a,dilations:i,pad:u,dimRoundingMode:p,inputShape:l}=n;re([o,s],"depthwiseConv2DNativeBackpropInput");let m=y.computeStrides(o.shape),c=y.computeStrides(s.shape),d=C.computeConv2DInfo(l,s.shape,a,i,u,p,!0),f=new bt(d.inShape,"float32"),h=f.values,[g,b,T]=f.strides,x=e.data.get(o.dataId).values,[I,k,w]=m,R=e.data.get(s.dataId).values,[P,M,L]=c,{batchSize:z,filterHeight:W,filterWidth:V,inChannels:j,inHeight:H,inWidth:X,outChannels:ee,outHeight:q,outWidth:ne,strideHeight:se,strideWidth:ie}=d,pe=W-1-d.padInfo.top,ae=V-1-d.padInfo.left,ye=ee/j;for(let fe=0;fe<z;++fe)for(let Ce=0;Ce<j;++Ce)for(let we=0;we<H;++we){let Ee=we-pe,$e=Math.max(0,Math.ceil(Ee/se)),Ze=Math.min(q,(W+Ee)/se);for(let J=0;J<X;++J){let gt=J-ae,Be=Math.max(0,Math.ceil(gt/ie)),Lt=Math.min(ne,(V+gt)/ie),Pt=0;for(let mt=$e;mt<Ze;++mt){let er=mt*se-Ee;for(let zt=Be;zt<Lt;++zt){let on=zt*ie-gt,qt=I*fe+k*mt+w*zt,na=P*(W-1-er)+M*(V-1-on)+L*Ce;for(let Br=0;Br<ye;++Br){let sn=Ce*ye+Br,an=x[qt+sn],Xr=R[na+Br];Pt+=an*Xr}}}h[g*fe+b*we+T*J+Ce]=Pt}}return e.makeTensorInfo(f.shape,f.dtype,f.values)}var E$={kernelName:Gm,backendName:"cpu",kernelFunc:Nne};function Dne(r){let{inputs:t,backend:e}=r,{x:n}=t,o=y.sizeFromShape(n.shape),s=e.data.get(n.dataId).values,a=xe([o,o],n.dtype),i=a.values;for(let p=0;p<s.length;p++)i[p*o+p]=s[p];let u=[...n.shape,...n.shape];return e.makeTensorInfo(u,a.dtype,a.values)}var _$={kernelName:Um,backendName:"cpu",kernelFunc:Dne};var L$={kernelName:Bu,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o}=r,{strides:s,pad:a,dilations:i}=e,u=t,p=u.data.get(n.dataId).values,l=n.shape.length,m=u.data.get(o.dataId).values,c=o.shape.length,{batchSize:d,inHeight:f,inWidth:h,inChannels:g,outHeight:b,outWidth:T,padInfo:x,strideHeight:I,strideWidth:k,filterHeight:w,filterWidth:R,dilationHeight:P,dilationWidth:M,outShape:L}=C.computeDilation2DInfo(n.shape,o.shape,s,a,"NHWC",i),z=y.sizeFromShape(L),W=L.length,V=y.getArrayFromDType(n.dtype,z);for(let H=0;H<d;++H)for(let X=0;X<b;++X){let ee=X*I-x.top;for(let q=0;q<T;++q){let ne=q*k-x.left;for(let se=0;se<g;++se){let ie=Number.MIN_SAFE_INTEGER;for(let ae=0;ae<w;++ae){let ye=ee+ae*P;if(ye>=0&&ye<f)for(let fe=0;fe<R;++fe){let Ce=ne+fe*M;if(Ce>=0&&Ce<h){let we=y.locToIndex([H,ye,Ce,se],l,y.computeStrides(n.shape)),Ee=y.locToIndex([ae,fe,se],c,y.computeStrides(o.shape)),$e=p[we]+m[Ee];$e>ie&&(ie=$e)}}}let pe=y.locToIndex([H,X,q,se],W,y.computeStrides(L));V[pe]=ie}}}return{dataId:u.write(y.toTypedArray(V,n.dtype),L,n.dtype),shape:L,dtype:n.dtype}}};var $$={kernelName:hh,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=e,p=t,l=y.toNestedArray(n.shape,p.data.get(n.dataId).values),m=y.toNestedArray(o.shape,p.data.get(o.dataId).values),{batchSize:c,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:b,padInfo:T,strideHeight:x,strideWidth:I,filterHeight:k,filterWidth:w,dilationHeight:R,dilationWidth:P,outShape:M}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);y.assert(s.rank===M.length,()=>`Error in ${hh}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);let L=y.toNestedArray(M,p.data.get(s.dataId).values),z=y.makeZerosNestedTypedArray(o.shape,o.dtype);for(let V=0;V<c;++V)for(let j=0;j<g;++j){let H=j*x-T.top;for(let X=0;X<b;++X){let ee=X*I-T.left;for(let q=0;q<h;++q){let ne=Number.MIN_SAFE_INTEGER,se=0,ie=0;for(let pe=0;pe<k;++pe){let ae=H+pe*R;if(ae>=0&&ae<d)for(let ye=0;ye<w;++ye){let fe=ee+ye*P;if(fe>=0&&fe<f){let Ce=l[V][ae][fe][q]+m[pe][ye][q];Ce>ne&&(ne=Ce,se=pe,ie=ye)}}}z[se][ie][q]+=L[V][j][X][q]}}}return{dataId:p.write(y.toTypedArray(z,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var B$={kernelName:fh,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:o,dy:s}=r,{strides:a,pad:i,dilations:u}=e,p=t,l=y.toNestedArray(n.shape,p.data.get(n.dataId).values),m=y.toNestedArray(o.shape,p.data.get(o.dataId).values),{batchSize:c,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:b,padInfo:T,strideHeight:x,strideWidth:I,filterHeight:k,filterWidth:w,dilationHeight:R,dilationWidth:P,outShape:M}=C.computeDilation2DInfo(n.shape,o.shape,a,i,"NHWC",u);y.assert(s.rank===M.length,()=>`Error in ${fh}, dy must have the same rank as output ${M.length}, but got ${s.rank}`);let L=y.toNestedArray(M,p.data.get(s.dataId).values),z=y.makeZerosNestedTypedArray(n.shape,n.dtype);for(let V=0;V<c;++V)for(let j=0;j<g;++j){let H=j*x-T.top;for(let X=0;X<b;++X){let ee=X*I-T.left;for(let q=0;q<h;++q){let ne=Number.MIN_SAFE_INTEGER,se=H<0?0:H,ie=ee<0?0:ee;for(let pe=0;pe<k;++pe){let ae=H+pe*R;if(ae>=0&&ae<d)for(let ye=0;ye<w;++ye){let fe=ee+ye*P;if(fe>=0&&fe<f){let Ce=l[V][ae][fe][q]+m[pe][ye][q];Ce>ne&&(ne=Ce,se=ae,ie=fe)}}}z[V][se][ie][q]+=L[V][j][X][q]}}}return{dataId:p.write(y.toTypedArray(z,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function Iu(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;re(o,"sum");let i;o.dtype==="bool"?i=qs({inputs:{x:o},backend:e,attrs:{dtype:"int32"}}):i=jr({inputs:{x:o},backend:e});let u=i.shape.length,p=y.parseAxisParam(s,i.shape),l=C.getAxesPermutation(p,u),m=p,c=i;l!=null&&(c=Qt({inputs:{x:i},backend:e,attrs:{perm:l}}),m=C.getInnerMostAxes(m.length,u)),C.assertAxesAreInnerMostDims("sum",m,c.shape.length);let[d,f]=C.computeOutAndReduceShapes(c.shape,m),h=C.upcastType(c.dtype,"int32"),g=cf(e,d,h),b=y.sizeFromShape(f),T=e.data.get(g.dataId).values,x=e.data.get(c.dataId).values;for(let I=0;I<T.length;++I){let k=I*b,w=0;for(let R=0;R<b;++R)w+=x[k+R];T[I]=w}if(a){let I=C.expandShapeToKeepDim(g.shape,p),k=g;g=tt({inputs:{x:g},backend:e,attrs:{shape:I}}),e.disposeIntermediateTensorInfo(k)}return e.disposeIntermediateTensorInfo(i),l!=null&&e.disposeIntermediateTensorInfo(c),g}var O$={kernelName:Ho,backendName:"cpu",kernelFunc:Iu};function Fne(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:p,steps:l}=C.getEinsumComputePath(i,u),m=l.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of l[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=Qt({inputs:{x:s[g]},backend:e,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let k=0;k<T.length;++k)I.splice(T[k],0,1);y.arraysEqual(x.shape,I)||(x=tt({inputs:{x},backend:e,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=Gl({inputs:{a:x,b:c},backend:e}),f.push(c))}h<m-1&&(p[h]>=0&&(c=Iu({inputs:{x:c},backend:e,attrs:{axis:p[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&e.disposeIntermediateTensorInfo(h);return c}var z$={kernelName:Ou,backendName:"cpu",kernelFunc:Fne};function Rne(r){let{inputs:t,backend:e}=r,{dy:n,y:o}=t;re([n,o],"eluGrad");let s=new Float32Array(y.sizeFromShape(o.shape)),a=e.data.get(o.dataId).values,i=e.data.get(n.dataId).values;for(let u=0;u<a.length;++u){let p=a[u];p>=1?s[u]=i[u]:s[u]=i[u]*(p+1)}return e.makeTensorInfo(o.shape,"float32",s)}var G$={kernelName:Wm,backendName:"cpu",kernelFunc:Rne};var Pne=C.ERF_P,Mne=C.ERF_A1,Ene=C.ERF_A2,_ne=C.ERF_A3,Lne=C.ERF_A4,$ne=C.ERF_A5,Bne=Me(Ki,r=>{let t=Math.sign(r),e=Math.abs(r),n=1/(1+Pne*e);return t*(1-(((($ne*n+Lne)*n+_ne)*n+Ene)*n+Mne)*n*Math.exp(-e*e))}),U$={kernelName:Ki,backendName:"cpu",kernelFunc:Bne};function xf(r){let{inputs:t,backend:e,attrs:n}=r,{input:o}=t,{dim:s}=n,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),tt({inputs:{x:o},backend:e,attrs:{shape:i}})}var W$={kernelName:ds,backendName:"cpu",kernelFunc:xf};var One=st((r,t)=>r/t),fg=pt(bo,One),hg={kernelName:bo,backendName:"cpu",kernelFunc:fg};function Ux(r,t,e){let n=r.shape,o=n[0],s=n[1],a=e.data.get(r.dataId),i=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,p=[o,s],l=y.sizeFromShape(p),m=y.getTypedArrayFromDType("float32",l),c=y.getTypedArrayFromDType("float32",l);for(let g=0;g<o;g++){let b=Ys({inputs:{x:i},backend:e,attrs:{begin:[g,0],size:[1,s]}}),T=Ys({inputs:{x:u},backend:e,attrs:{begin:[g,0],size:[1,s]}}),x=Ar({inputs:{real:b,imag:T},backend:e}),{real:I,imag:k}=zne(x,t,e),w=C.mergeRealAndImagArrays(I,k);for(let R=0;R<s;R++){let P=C.getComplexWithIndex(w,R);m[g*s+R]=P.real,c[g*s+R]=P.imag}e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(T),e.disposeIntermediateTensorInfo(x)}let d=e.makeTensorInfo(p,"float32",m),f=e.makeTensorInfo(p,"float32",c),h=Ar({inputs:{real:d,imag:f},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),h}function zne(r,t,e){let n=y.sizeFromShape(r.shape),o=e.data.get(r.dataId),s=e.data.get(o.complexTensorInfos.real.dataId).values,a=e.data.get(o.complexTensorInfos.imag.dataId).values;if(Gne(n)){let i=LN(s,a,n,t,e),u=[r.shape[0],r.shape[1]];if(t){let p=e.makeTensorInfo(u,"float32",i.real),l=e.makeTensorInfo(u,"float32",i.imag),m=e.makeTensorInfo([],"float32",y.createScalarValue(n,"float32")),c=jr({inputs:{x:m},backend:e}),d=hg.kernelFunc({inputs:{a:p,b:m},backend:e}),f=hg.kernelFunc({inputs:{a:l,b:c},backend:e}),h=e.data.get(d.dataId).values,g=e.data.get(f.dataId).values;return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),{real:h,imag:g}}return i}else{let i=C.mergeRealAndImagArrays(s,a),u=Une(i,n,t);return C.splitRealAndImagArrays(u)}}function Gne(r){return(r&r-1)===0}function LN(r,t,e,n,o){if(e===1)return{real:r,imag:t};let s=C.mergeRealAndImagArrays(r,t),a=e/2,i=C.complexWithEvenIndex(s),u=i.real,p=i.imag,l=[u.length],m=o.makeTensorInfo(l,"float32",u),c=o.makeTensorInfo(l,"float32",p),d=Ar({inputs:{real:m,imag:c},backend:o}),f=C.complexWithOddIndex(s),h=f.real,g=f.imag,b=[h.length],T=o.makeTensorInfo(b,"float32",h),x=o.makeTensorInfo(b,"float32",g),I=Ar({inputs:{real:T,imag:x},backend:o}),k=LN(u,p,a,n,o),w=k.real,R=k.imag,P=[w.length],M=o.makeTensorInfo(P,"float32",w),L=o.makeTensorInfo(P,"float32",R),z=Ar({inputs:{real:M,imag:L},backend:o}),W=LN(h,g,a,n,o),V=W.real,j=W.imag,H=[V.length],X=o.makeTensorInfo(H,"float32",V),ee=o.makeTensorInfo(H,"float32",j),q=Ar({inputs:{real:X,imag:ee},backend:o}),ne=C.exponents(e,n),se=[ne.real.length],ie=o.makeTensorInfo(se,"float32",ne.real),pe=o.makeTensorInfo(se,"float32",ne.imag),ae=Ar({inputs:{real:ie,imag:pe},backend:o}),ye=Gl({inputs:{a:ae,b:q},backend:o}),fe=Ri({inputs:{a:z,b:ye},backend:o}),Ce=cg({inputs:{a:z,b:ye},backend:o}),we=Hs({inputs:{input:fe},backend:o}),Ee=Hs({inputs:{input:Ce},backend:o}),$e=Pi({inputs:{input:fe},backend:o}),Ze=Pi({inputs:{input:Ce},backend:o}),J=Fp({inputs:[we,Ee],backend:o,attrs:{axis:0}}),gt=Fp({inputs:[$e,Ze],backend:o,attrs:{axis:0}}),Be=o.data.get(J.dataId).values,Lt=o.data.get(gt.dataId).values;return o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(x),o.disposeIntermediateTensorInfo(I),o.disposeIntermediateTensorInfo(M),o.disposeIntermediateTensorInfo(L),o.disposeIntermediateTensorInfo(z),o.disposeIntermediateTensorInfo(X),o.disposeIntermediateTensorInfo(ee),o.disposeIntermediateTensorInfo(q),o.disposeIntermediateTensorInfo(ie),o.disposeIntermediateTensorInfo(pe),o.disposeIntermediateTensorInfo(ae),o.disposeIntermediateTensorInfo(ye),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(Ce),o.disposeIntermediateTensorInfo(we),o.disposeIntermediateTensorInfo($e),o.disposeIntermediateTensorInfo(Ee),o.disposeIntermediateTensorInfo(Ze),o.disposeIntermediateTensorInfo(J),o.disposeIntermediateTensorInfo(gt),{real:Be,imag:Lt}}function Une(r,t,e){let n=new Float32Array(t*2);for(let o=0;o<t;o++){let s=0,a=0;for(let i=0;i<t;i++){let u=C.exponent(o*i,t,e),p=C.getComplexWithIndex(r,i);s+=p.real*u.real-p.imag*u.imag,a+=p.real*u.imag+p.imag*u.real}e&&(s/=t,a/=t),C.assignToTypedArray(n,s,a,o)}return n}function Wne(r){let{inputs:t,backend:e}=r,{input:n}=t,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=tt({inputs:{x:n},backend:e,attrs:{shape:[a,s]}}),u=Ux(i,!1,e),p=tt({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),p}var K$={kernelName:Km,backendName:"cpu",kernelFunc:Wne};function gg(r){let{backend:t,attrs:e}=r,{shape:n,value:o,dtype:s}=e,a=s||y.inferDtype(o),i=y.getArrayFromDType(a,y.sizeFromShape(n));return Kne(i,o,a),t.makeTensorInfo(n,a,i)}var V$={kernelName:fi,backendName:"cpu",kernelFunc:gg};function Kne(r,t,e){r.fill(t)}var H$={kernelName:xa,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,o=e,s=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[a,i,u,p]=n.shape,l=o.data.get(n.dataId).values;for(let c=0;c<a;c++){let d=c*u*i*p;for(let f=0;f<i;f++){let h=f*(u*p);for(let g=0;g<u;g++){let b=g*p;for(let T=0;T<p;T++){let x=Math.round(u-g-1),I=d+h+b+T,k=l[I];if(x>=0&&x<u){let w=x*p,R=d+h+w+T;k=l[R]}s[I]=k}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Vne=st((r,t)=>Math.floor(r/t)),Hne=pt(Io,Vne,null,"int32"),q$={kernelName:Io,backendName:"cpu",kernelFunc:Hne};function qne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dataFormat:l,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=EN({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:p,dataFormat:l,dilations:m,dimRoundingMode:c}});if(a){let g=h;if(l==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){let b=tt({inputs:{x:a},backend:e,attrs:{shape:[a.shape[0],1,1]}});h=Ri({inputs:{a:h,b},backend:e}),e.disposeIntermediateTensorInfo(b)}else h=Ri({inputs:{a:h,b:a},backend:e});e.disposeIntermediateTensorInfo(g)}if(d){let g=h;if(l==="NCHW"&&d==="prelu"&&i.shape.length===1&&i.shape[0]!==1){let b=tt({inputs:{x:i},backend:e,attrs:{shape:[i.shape[0],1,1]}});h=ql(e,h,d,b,f),e.disposeIntermediateTensorInfo(b)}else h=ql(e,h,d,i,f);e.disposeIntermediateTensorInfo(g)}return h}var j$={kernelName:ws,backendName:"cpu",kernelFunc:qne};function jne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dataFormat:l,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=_N({inputs:{x:o,filter:s},backend:e,attrs:{strides:u,pad:p,dataFormat:l,dilations:m,dimRoundingMode:c}});if(a){let g=h;h=Ri({inputs:{a:h,b:a},backend:e}),e.disposeIntermediateTensorInfo(g)}if(d){let g=h;h=ql(e,h,d,i,f),e.disposeIntermediateTensorInfo(g)}return h}var X$={kernelName:Ns,backendName:"cpu",kernelFunc:jne};function Xne(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=y.sizeFromShape(n.shape),a=o.shape,i=a[a.length-1],[u,p,l,m]=C.prepareAndValidate(n,o);if(p===0)return e.makeTensorInfo(u,n.dtype,[]);let c=e.data.get(o.dataId).values,d=e.bufferSync(n),f=Dx(c,d,n.dtype,p,i,l,m,n.shape,s);return e.makeTensorInfo(u,n.dtype,f.values)}var Y$={kernelName:Ia,backendName:"cpu",kernelFunc:Xne};function Yne(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:a,batchDims:i}=n;re([o,s],"gatherV2");let u=y.parseAxisParam(a,o.shape)[0],p=e.data.get(s.dataId).values,l=o.shape[u];for(let I=0;I<p.length;++I){let k=p[I];y.assert(k<=l-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${l-1}]`)}let m=i;i==null&&(m=0);let c=y.sizeFromShape(s.shape),d=C.segment_util.collectGatherOpShapeInfo(o,s,u,m),f=tt({inputs:{x:o},backend:e,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),h=tt({inputs:{x:s},backend:e,attrs:{shape:[d.batchSize,c/d.batchSize]}}),g=[d.batchSize,d.outerSize,c/d.batchSize,d.sliceSize],b=e.bufferSync(h),T=e.bufferSync(f),x=Fx(T,b,g);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),e.makeTensorInfo(d.outputShape,x.dtype,x.values)}var Z$={kernelName:fs,backendName:"cpu",kernelFunc:Yne};function Zne(r){let{inputs:t,backend:e}=r,{input:n}=t,o=y.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],a=o/s,i=tt({inputs:{x:n},backend:e,attrs:{shape:[a,s]}}),u=Ux(i,!0,e),p=tt({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(u),p}var Q$={kernelName:Vm,backendName:"cpu",kernelFunc:Zne};var Qne=Me(Vi,r=>Number.isFinite(r)?1:0,"bool"),J$={kernelName:Vi,backendName:"cpu",kernelFunc:Qne};var Jne=Me(Hi,r=>Math.abs(r)===1/0?1:0,"bool"),eB={kernelName:Hi,backendName:"cpu",kernelFunc:Jne};var eoe=Me(ka,r=>Number.isNaN(r)?1:0,"bool"),tB={kernelName:ka,backendName:"cpu",kernelFunc:eoe};function toe(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,a=Rx(n,o,s);return t.makeTensorInfo([a.length],"float32",a)}var rB={kernelName:Hm,backendName:"cpu",kernelFunc:toe};var roe=Me(qi,r=>Math.log1p(r)),nB={kernelName:qi,backendName:"cpu",kernelFunc:roe};var noe=st((r,t)=>r&&t),ooe=pt(Aa,noe,null,"bool"),oB={kernelName:Aa,backendName:"cpu",kernelFunc:ooe};var soe=Me(wa,r=>r?0:1,"bool"),sB={kernelName:wa,backendName:"cpu",kernelFunc:soe};var aoe=st((r,t)=>r||t),ioe=pt(ji,aoe,null,"bool"),aB={kernelName:ji,backendName:"cpu",kernelFunc:ioe};function uoe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:a,alpha:i,beta:u}=n;re(o,"LRN");let p=o.shape[3],l=p-1,m=e.data.get(o.dataId).values,c=y.sizeFromShape(o.shape),d=new Float32Array(c);function f(h){let g=h%p,b=h-g+Math.max(0,g-s),T=h-g+Math.min(g+s,l),x=0;for(;b<=T;b++){let I=m[b];x+=I*I}return x}for(let h=0;h<c;h++){let g=f(h),b=m[h]*Math.pow(a+i*g,-u);d[h]=b}return e.makeTensorInfo(o.shape,o.dtype,d)}var iB={kernelName:Gu,backendName:"cpu",kernelFunc:uoe};function poe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:a}=t,{depthRadius:i,bias:u,alpha:p,beta:l}=n;re(a,"LRNGrad");let m=y.sizeFromShape(a.shape),c=a.shape[3],d=e.data.get(a.dataId).values,f=e.data.get(o.dataId).values,h=e.data.get(s.dataId).values,g=new Float32Array(m),b=m;for(let T=0;T<b;T++){let x=T%c,I=T-x+Math.max(0,x-i),k=T-x+Math.min(c,x+i+1),w=0;for(let R=I;R<k;R++)w+=Math.pow(f[R],2);w=p*w+u;for(let R=I;R<k;R++){let P=-2*p*l*f[R]*h[T]/w;T===R&&(P+=Math.pow(w,-l)),P*=d[T],g[R]+=P}}return e.makeTensorInfo(a.shape,o.dtype,g)}var uB={kernelName:qm,backendName:"cpu",kernelFunc:poe};function $N(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:a}=n,i=e,u=o.shape,p=u.length,l=y.parseAxisParam(s,u),m=l,c=C.getAxesPermutation(m,p),d=i.data.get(o.dataId).values;if(c!=null){let I=new Array(p);for(let k=0;k<I.length;k++)I[k]=u[c[k]];d=hf(d,u,o.dtype,c,I),m=C.getInnerMostAxes(m.length,p),u=I}re(o,"max"),C.assertAxesAreInnerMostDims("max",m,p);let[f,h]=C.computeOutAndReduceShapes(u,m),g=y.sizeFromShape(h),b=Px(d,g,f,o.dtype),T=i.write(b,f,o.dtype),x=f;return a&&(x=C.expandShapeToKeepDim(f,l)),{dataId:T,shape:x,dtype:o.dtype}}var pB={kernelName:Ao,backendName:"cpu",kernelFunc:$N};function loe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;re(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,p=1;y.assert(C.eitherStridesOrDilationsAreOne(a,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let l=C.computePool2DInfo(o.shape,s,a,p,i,u),m;if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))m=jr({inputs:{x:o},backend:e});else{let c=e.data.get(o.dataId).values,d=y.computeStrides(o.shape),f=Tf(c,o.shape,o.dtype,d,l,"max");m=e.makeTensorInfo(l.outShape,o.dtype,f.values)}return m}var lB={kernelName:No,backendName:"cpu",kernelFunc:loe};function moe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:p}=n;re(o,"maxPool3d");let l=C.computePool3DInfo(o.shape,s,a,1,i,u,p),m=e.data.get(o.dataId).values,c=Gx(m,o.shape,o.dtype,y.computeStrides(o.shape),l,"max");return e.makeTensorInfo(c.shape,"float32",c.values)}var mB={kernelName:Uu,backendName:"cpu",kernelFunc:moe};function coe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,{filterSize:a,strides:i,pad:u,dimRoundingMode:p}=n;re([o,s],"maxPool3DGrad");let l=C.computePool3DInfo(s.shape,a,i,1,u,p),m=e.bufferSync(s),c=a$(m,l),d=l.strideDepth,f=l.strideHeight,h=l.strideWidth,g=l.dilationDepth,b=l.dilationHeight,T=l.dilationWidth,x=l.effectiveFilterDepth,I=l.effectiveFilterHeight,k=l.effectiveFilterWidth,w=x-1-l.padInfo.front,R=k-1-l.padInfo.left,P=I-1-l.padInfo.top,M=xe(s.shape,"float32"),L=e.bufferSync(o);for(let z=0;z<l.batchSize;++z)for(let W=0;W<l.inChannels;++W)for(let V=0;V<l.inDepth;++V)for(let j=0;j<l.inHeight;++j)for(let H=0;H<l.inWidth;++H){let X=V-w,ee=j-P,q=H-R,ne=0;for(let se=0;se<x;se+=g){let ie=(X+se)/d;if(!(ie<0||ie>=l.outDepth||Math.floor(ie)!==ie))for(let pe=0;pe<I;pe+=b){let ae=(ee+pe)/f;if(!(ae<0||ae>=l.outHeight||Math.floor(ae)!==ae))for(let ye=0;ye<k;ye+=T){let fe=(q+ye)/h;if(fe<0||fe>=l.outWidth||Math.floor(fe)!==fe)continue;let Ce=x*I*k-1-c.get(z,ie,ae,fe,W),we=se*I*k+pe*k+ye,Ee=Ce===we?1:0;if(Ee===0)continue;ne+=L.get(z,ie,ae,fe,W)*Ee}}}M.set(ne,z,V,j,H,W)}return e.makeTensorInfo(M.shape,M.dtype,M.values)}var cB={kernelName:Xm,backendName:"cpu",kernelFunc:coe};function doe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:a}=t,i=s;re([s,a],"maxPoolGrad");let{filterSize:u,strides:p,pad:l,dimRoundingMode:m}=n,c=C.computePool2DInfo(i.shape,u,p,1,l,m),d=e.data.get(i.dataId).values,f=xe(c.outShape,i.dtype,zx(d,i.shape,i.dtype,c).values),h=c.strideHeight,g=c.strideWidth,b=c.dilationHeight,T=c.dilationWidth,x=c.effectiveFilterHeight,I=c.effectiveFilterWidth,k=I-1-c.padInfo.left,w=x-1-c.padInfo.top,R=xe(i.shape,"float32"),P=e.data.get(o.dataId).values,M=xe(o.shape,"float32",P);for(let L=0;L<c.batchSize;++L)for(let z=0;z<c.inChannels;++z)for(let W=0;W<c.inHeight;++W)for(let V=0;V<c.inWidth;++V){let j=W-w,H=V-k,X=0;for(let ee=0;ee<x;ee+=b){let q=(j+ee)/h;if(!(q<0||q>=c.outHeight||Math.floor(q)!==q))for(let ne=0;ne<I;ne+=T){let se=(H+ne)/g;if(se<0||se>=c.outWidth||Math.floor(se)!==se)continue;let ie=x*I-1-f.get(L,q,se,z),pe=ee*I+ne,ae=ie===pe?1:0;if(ae===0)continue;X+=M.get(L,q,se,z)*ae}}R.set(X,L,W,V,z)}return e.makeTensorInfo(R.shape,R.dtype,R.values)}var dB={kernelName:jm,backendName:"cpu",kernelFunc:doe};function fB(r,t,e,n,o){let s=y.computeStrides(t),a=Tf(r,t,e,s,o,"max"),i=zx(r,t,e,o,!0,n);return[a.values,i.values]}var hB={kernelName:Ym,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=t,u=e;re(n,"MaxPoolWithArgmax");let p=u.data.get(n.dataId).values,l=C.computePool2DInfo(n.shape,o,s,[1,1],a),[m,c]=fB(p,n.shape,n.dtype,i,l),d=u.write(m,l.outShape,n.dtype),f=u.write(c,l.outShape,n.dtype);return[{dataId:d,shape:l.outShape,dtype:n.dtype},{dataId:f,shape:l.outShape,dtype:"int32"}]}};function foe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n,i=y.parseAxisParam(s,o.shape),p=C.computeOutAndReduceShapes(o.shape,i)[1],l=y.sizeFromShape(p),m=[],c=e.makeTensorInfo([],"float32",new Float32Array([l]));m.push(c);let d=qs({inputs:{x:o},backend:e,attrs:{dtype:"float32"}});m.push(d);let f=fg({inputs:{a:d,b:c},backend:e});m.push(f);let h=Iu({inputs:{x:f},backend:e,attrs:{axis:s,keepDims:a}});return m.forEach(g=>e.disposeIntermediateTensorInfo(g)),h}var gB={kernelName:Do,backendName:"cpu",kernelFunc:foe};function hoe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;re(o,"min");let i=y.parseAxisParam(s,o.shape),u=i,p=C.getAxesPermutation(u,o.shape.length),l=o;p!=null&&(l=Qt({inputs:{x:o},backend:e,attrs:{perm:p}}),u=C.getInnerMostAxes(u.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",u,l.shape.length);let[m,c]=C.computeOutAndReduceShapes(l.shape,u),d=y.sizeFromShape(c),f=y.makeZerosTypedArray(y.sizeFromShape(m),l.dtype),h=e.data.get(l.dataId).values;for(let b=0;b<f.length;++b){let T=b*d,x=h[T];for(let I=0;I<d;++I){let k=h[T+I];(Number.isNaN(k)||k<x)&&(x=k)}f[b]=x}p!=null&&e.disposeIntermediateTensorInfo(l);let g=e.makeTensorInfo(m,l.dtype,f);if(a){let b=C.expandShapeToKeepDim(m,i),T=tt({inputs:{x:g},backend:e,attrs:{shape:b}});return e.disposeIntermediateTensorInfo(g),T}return g}var bB={kernelName:Fo,backendName:"cpu",kernelFunc:hoe};function goe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,mode:a}=n;re(o,"mirrorPad");let i=s.map((x,I)=>x[0]+o.shape[I]+x[1]),u=s.map(x=>x[0]),p=s.map((x,I)=>x[0]+o.shape[I]),l=a==="reflect"?0:1,m=e.data.get(o.dataId).values,c=o.shape.length,d=y.computeStrides(o.shape),f=y.sizeFromShape(i),h=i.length,g=y.computeStrides(i),b=y.getTypedArrayFromDType(o.dtype,f);for(let x=0;x<f;x++){let I=y.indexToLoc(x,h,g);for(let w=0;w<h;w++)I[w]<u[w]?I[w]=u[w]*2-I[w]-l:I[w]>=p[w]&&(I[w]=(p[w]-1)*2-I[w]+l);I=I.map((w,R)=>w-u[R]);let k=y.locToIndex(I,c,d);b[x]=m[k]}return{dataId:e.write(b,i,o.dtype),shape:i,dtype:o.dtype}}var yB={kernelName:Po,backendName:"cpu",kernelFunc:goe};var boe=st((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),yoe=pt(Xi,boe),TB={kernelName:Xi,backendName:"cpu",kernelFunc:yoe};var IB=wm(_h());function BN(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,a=o.shape.length,i=s;if(i===-1&&(i=a-1),i!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${i}`);let u=y.parseAxisParam([i],o.shape),p=$N({inputs:{x:o},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),l=C.expandShapeToKeepDim(p.shape,u),m=tt({inputs:{x:p},backend:e,attrs:{shape:l}}),c=cg({inputs:{a:o,b:m},backend:e}),d=lN({inputs:{x:c},backend:e}),f=Iu({inputs:{x:d},backend:e,attrs:{axis:u,keepDims:!1}}),h=tt({inputs:{x:f},backend:e,attrs:{shape:l}}),g=fg({inputs:{a:d,b:h},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(h),g}var xB={kernelName:qo,backendName:"cpu",kernelFunc:BN};function Toe(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:a,normalized:i}=n;re(o,"multinomial");let u=i?o:BN({inputs:{logits:o},backend:e,attrs:{dim:-1}}),p=u.shape[0],l=u.shape[1],m=e.data.get(u.dataId).values,c=[p,s],d=y.makeZerosTypedArray(y.sizeFromShape(c),"int32");for(let f=0;f<p;++f){let h=f*l,g=new Float32Array(l-1);g[0]=m[h];for(let x=1;x<g.length;++x)g[x]=g[x-1]+m[h+x];let b=IB.alea(a.toString()),T=f*s;for(let x=0;x<s;++x){let I=b();d[T+x]=g.length;for(let k=0;k<g.length;k++)if(I<g[k]){d[T+x]=k;break}}}return i||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(c,"int32",d)}var CB={kernelName:Zm,backendName:"cpu",kernelFunc:Toe};var xoe=xr.nonMaxSuppressionV3Impl;function Ioe(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n;re(o,"NonMaxSuppression");let p=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,{selectedIndices:m}=xoe(p,l,a,i,u);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}var kB={kernelName:Da,backendName:"cpu",kernelFunc:Ioe};var Coe=xr.nonMaxSuppressionV4Impl;function koe(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:p}=n;re(o,"NonMaxSuppressionPadded");let l=e.data.get(o.dataId).values,m=e.data.get(s.dataId).values,{selectedIndices:c,validOutputs:d}=Coe(l,m,a,i,u,p);return[e.makeTensorInfo([c.length],"int32",new Int32Array(c)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var SB={kernelName:Yi,backendName:"cpu",kernelFunc:koe};var Soe=xr.nonMaxSuppressionV5Impl;function voe(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:p}=n;re(o,"NonMaxSuppressionWithScore");let l=e.data.get(o.dataId).values,m=e.data.get(s.dataId).values,c=a,d=i,f=u,h=p,{selectedIndices:g,selectedScores:b}=Soe(l,m,c,d,f,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var vB={kernelName:Fa,backendName:"cpu",kernelFunc:voe};function Aoe(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:a,onValue:i,offValue:u}=n;re(o,"oneHot");let p=y.sizeFromShape(o.shape),l=new Float32Array(p*a);l.fill(u);let m=e.data.get(o.dataId).values;for(let c=0;c<p;++c)m[c]>=0&&m[c]<a&&(l[c*a+m[c]]=i);return e.makeTensorInfo([...o.shape,a],s,l)}var AB={kernelName:Ra,backendName:"cpu",kernelFunc:Aoe};function bg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Hs({inputs:{input:n},backend:e}),s=bg({inputs:{x:o},backend:e}),a=Pi({inputs:{input:n},backend:e}),i=bg({inputs:{x:a},backend:e}),u=Ar({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),u}else return gg({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var wB={kernelName:Ss,backendName:"cpu",kernelFunc:bg};function NB(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Hs({inputs:{input:n},backend:e}),s=NB({inputs:{x:o},backend:e}),a=Pi({inputs:{input:n},backend:e}),i=bg({inputs:{x:a},backend:e}),u=Ar({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),u}else return gg({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var DB={kernelName:gs,backendName:"cpu",kernelFunc:NB};function ON(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return xf({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,a=t[0].dtype;t.forEach(l=>{y.assertShapesMatch(s,l.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(l=>{let m=xf({inputs:{input:l},backend:e,attrs:{dim:o}});return i.push(m),m}),p=Fp({inputs:u,backend:e,attrs:{axis:o}});return i.forEach(l=>e.disposeIntermediateTensorInfo(l)),p}var FB={kernelName:bs,backendName:"cpu",kernelFunc:ON};function woe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:a}=n;re(o,"pad");let i=s.map((T,x)=>T[0]+o.shape[x]+T[1]),u=s.map(T=>T[0]),p=e.data.get(o.dataId).values,l=y.sizeFromShape(o.shape),m=o.shape.length,c=y.computeStrides(o.shape),d=y.sizeFromShape(i),f=i.length,h=y.computeStrides(i),g=y.getTypedArrayFromDType(o.dtype,d);a!==0&&g.fill(a);for(let T=0;T<l;T++){let I=y.indexToLoc(T,m,c).map((w,R)=>w+u[R]),k=y.locToIndex(I,f,h);g[k]=p[T]}return{dataId:e.write(g,i,o.dtype),shape:i,dtype:o.dtype}}var Wx={kernelName:Eo,backendName:"cpu",kernelFunc:woe};var Noe=st((r,t)=>Math.pow(r,t)),Doe=pt(_o,Noe),RB={kernelName:_o,backendName:"cpu",kernelFunc:Doe};function Foe(r){let{inputs:t,backend:e,attrs:n}=r,{shape:o,values:s,defaultValue:a,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=n,p=e.data.get(o.dataId).values,l=e.data.get(s.dataId).values,m=e.data.get(a.dataId).values,c=i.map(g=>e.data.get(g.dataId).values),d=i.map(g=>g.shape),[f,h]=Mx(p,o.shape,l,s.shape,s.dtype,m,a.shape,c,d,u);return e.makeTensorInfo(f,s.dtype,h)}var PB={kernelName:Qm,backendName:"cpu",kernelFunc:Foe};function Roe(r){let{backend:t,attrs:e}=r,{start:n,stop:o,dtype:s,step:a}=e,i=Ul(n,o,a,s);return t.makeTensorInfo([i.length],s,i)}var MB={kernelName:hi,backendName:"cpu",kernelFunc:Roe};var Poe=Me(Pa,r=>1/r),EB={kernelName:Pa,backendName:"cpu",kernelFunc:Poe};function Moe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n;re(o,"resizeBilinear");let u=y.computeStrides(o.shape),[p,l]=i,[m,c,d,f]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(y.sizeFromShape([m,p,l,f])),b=[s&&p>1?c-1:c,s&&l>1?d-1:d],T=[s&&p>1?p-1:p,s&&l>1?l-1:l],x=0,I=b[0]/T[0],k=b[1]/T[1];for(let w=0;w<m;w++)for(let R=0;R<p;R++){let P;a?P=I*(R+.5)-.5:P=I*R;let M=Math.max(0,Math.floor(P)),L=P-M,z=Math.min(c-1,Math.ceil(P)),W=w*u[0]+M*u[1],V=w*u[0]+z*u[1];for(let j=0;j<l;j++){let H;a?H=k*(j+.5)-.5:H=k*j;let X=Math.max(0,Math.floor(H)),ee=H-X,q=Math.min(d-1,Math.ceil(H)),ne=W+X*u[2],se=V+X*u[2],ie=W+q*u[2],pe=V+q*u[2];for(let ae=0;ae<f;ae++){let ye=h[ne+ae],fe=h[se+ae],Ce=h[ie+ae],we=h[pe+ae],Ee=ye+(Ce-ye)*ee,$e=fe+(we-fe)*ee,Ze=Ee+($e-Ee)*L;g[x++]=Ze}}}return e.makeTensorInfo([m,p,l,f],"float32",g)}var _B={kernelName:zo,backendName:"cpu",kernelFunc:Moe};function Eoe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:a}=n;re([s,o],"resizeBilinearGrad");let i=y.computeStrides(o.shape),[u,p,l,m]=o.shape,[,c,d]=s.shape,f=new Float32Array(u*p*l*m),h=[a&&c>1?p-1:p,a&&d>1?l-1:l],g=[a&&c>1?c-1:c,a&&d>1?d-1:d],b=h[0]/g[0],T=h[1]/g[1],x=e.data.get(s.dataId).values,I=0;for(let k=0;k<u;k++){let w=k*i[0];for(let R=0;R<c;R++){let P=R*b,M=Math.floor(P),L=Math.min(Math.ceil(P),p-1),z=w+M*i[1],W=w+L*i[1],V=P-M,j=1-V;for(let H=0;H<d;H++){let X=H*T,ee=Math.floor(X),q=Math.min(Math.ceil(X),l-1),ne=X-ee,se=1-ne,ie=z+ee*i[2],pe=z+q*i[2],ae=W+ee*i[2],ye=W+q*i[2],fe=j*se,Ce=j*ne,we=V*se,Ee=V*ne;for(let $e=0;$e<m;$e++){let Ze=x[I++];f[ie+$e]+=Ze*fe,f[pe+$e]+=Ze*Ce,f[ae+$e]+=Ze*we,f[ye+$e]+=Ze*Ee}}}}return e.makeTensorInfo([u,l,p,m],"float32",f)}var LB={kernelName:ec,backendName:"cpu",kernelFunc:Eoe};function _oe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n;re(o,"resizeNearestNeighbor");let u=y.computeStrides(o.shape),[p,l]=i,[m,c,d,f]=o.shape,h=e.data.get(o.dataId).values,g=new Float32Array(m*p*l*f),b=[s&&p>1?c-1:c,s&&l>1?d-1:d],T=[s&&p>1?p-1:p,s&&l>1?l-1:l],x=b[0]/T[0],I=b[1]/T[1],k=0;for(let w=0;w<m;w++){let R=w*u[0];for(let P=0;P<p;P++){let M=a?x*(P+.5):x*P,L=Math.min(c-1,s?Math.round(M):Math.floor(M));a&&(L=Math.max(0,L));let z=R+L*u[1];for(let W=0;W<l;W++){let V=a?I*(W+.5):I*W,j=Math.min(d-1,s?Math.round(V):Math.floor(V));a&&(j=Math.max(0,j));let H=z+j*u[2];for(let X=0;X<f;X++){let ee=h[H+X];g[k++]=ee}}}}return e.makeTensorInfo([m,p,l,f],o.dtype,g)}var $B={kernelName:Oo,backendName:"cpu",kernelFunc:_oe};function Loe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:a}=n;re([s,o],"resizeNearestNeighborGrad");let i=y.computeStrides(o.shape),u=y.computeStrides(s.shape),[p,l,m,c]=o.shape,[,d,f]=s.shape,h=new Float32Array(p*l*m*c),g=e.data.get(s.dataId).values,b=[a&&d>1?l-1:l,a&&f>1?m-1:m],T=[a&&d>1?d-1:d,a&&f>1?f-1:f],x=b[0]/T[0],I=b[1]/T[1],k=1/x,w=1/I,R=Math.ceil(k)*2+2,P=Math.ceil(w)*2+2;for(let M=0;M<p;M++){let L=M*i[0];for(let z=0;z<l;z++){let W=L+z*i[1],V=Math.floor(z*k),j=Math.floor(V-R/2);for(let H=0;H<m;H++){let X=W+H*i[2],ee=Math.floor(H*w),q=Math.floor(ee-P/2);for(let ne=0;ne<c;ne++){let se=0;for(let ie=0;ie<R;ie++){let pe=ie+j;if(pe<0||pe>=d)continue;let ae=L+pe*u[1],ye=pe*x,fe=Math.min(l-1,a?Math.round(ye):Math.floor(ye));if(z===fe)for(let Ce=0;Ce<P;Ce++){let we=Ce+q;if(we<0||we>=f)continue;let Ee=ae+we*u[2],$e=we*I,Ze=Math.min(m-1,a?Math.round($e):Math.floor($e));H===Ze&&(se+=g[Ee+ne])}}h[X+ne]=se}}}}return e.makeTensorInfo(o.shape,o.dtype,h)}var BB={kernelName:Jm,backendName:"cpu",kernelFunc:Loe};function $oe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n;re(o,"reverse");let a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return jr({inputs:{x:o},backend:e});let u=new bt(o.shape,o.dtype),p=e.bufferSync(o);for(let l=0;l<u.size;l++){let m=u.indexToLoc(l),c=m.slice();i.forEach(d=>c[d]=o.shape[d]-1-c[d]),u.set(p.get(...c),...m)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}var OB={kernelName:Ma,backendName:"cpu",kernelFunc:$oe};var zB={kernelName:Ga,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=t,i=e,u=y.getTypedArrayFromDType(n.dtype,y.sizeFromShape(n.shape)),[p,l,m,c]=n.shape,[d,f]=C.getImageCenter(a,l,m),h=255,g=Math.sin(o),b=Math.cos(o),T=i.data.get(n.dataId).values;for(let I=0;I<p;I++){let k=I*m*l*c;for(let w=0;w<l;w++){let R=w*(m*c);for(let P=0;P<m;P++){let M=P*c;for(let L=0;L<c;L++){let z=[p,w,P,L],W=z[2],V=z[1],j=(W-d)*b-(V-f)*g,H=(W-d)*g+(V-f)*b;j=Math.round(j+d),H=Math.round(H+f);let X=s;if(typeof s!="number"&&(L===3?X=h:X=s[L]),j>=0&&j<m&&H>=0&&H<l){let q=H*(m*c),ne=j*c,se=k+q+ne+L;X=T[se]}let ee=k+R+M+L;u[ee]=X}}}}return{dataId:i.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Boe=Me(Ea,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2===0?t:t+1}),GB={kernelName:Ea,backendName:"cpu",kernelFunc:Boe};function Ooe(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:p,strides:l,outputSize:m}=C.calculateShapes(s,o,a),c=!0,d=e.bufferSync(o),f=e.bufferSync(s),h=xu(d,f,a,m,p,u,i,l,0,c);return e.makeTensorInfo(a,h.dtype,h.values)}var UB={kernelName:_a,backendName:"cpu",kernelFunc:Ooe};function zoe(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<t?e=o+1:n=o;return n}function Goe(r,t){let e=0,n=r.length,o=0;for(;e<n;)o=Math.floor((e+n)/2),r[o]<=t?e=o+1:n=o;return n}function WB(r,t,e,n,o,s){let a=y.getArrayFromDType("int32",e*o);for(let i=0;i<e;++i){let u=r.slice(i*n,(i+1)*n),p=i*o;for(let l=0;l<o;++l)a[p+l]=s==="left"?zoe(u,t[l+p]):Goe(u,t[l+p])}return a}function Uoe(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:a}=n,i=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,p=WB(i,u,o.shape[0],o.shape[1],s.shape[1],a);return e.makeTensorInfo(s.shape,"int32",p)}var KB={kernelName:tc,backendName:"cpu",kernelFunc:Uoe};function Woe(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t;re([n,o,s],"select");let a=n.shape.length,i=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,l=$t(o.dtype,s.dtype),m=y.makeZerosTypedArray(y.sizeFromShape(o.shape),l),c=0,d=a===0||a>1||o.shape.length===1?1:y.sizeFromShape(o.shape.slice(1));for(let f=0;f<i.length;f++)for(let h=0;h<d;h++)i[f]===1?m[c++]=u[f]:m[c++]=p[f];return e.makeTensorInfo(o.shape,l,m)}var VB={kernelName:Ts,backendName:"cpu",kernelFunc:Woe};var Koe=C.SELU_SCALEALPHA,Voe=C.SELU_SCALE,Hoe=Me(Zi,r=>r>=0?Voe*r:Koe*(Math.exp(r)-1)),HB={kernelName:Zi,backendName:"cpu",kernelFunc:Hoe};var qoe=Me(Qi,r=>r<0?-1:r>0?1:0),qB={kernelName:Qi,backendName:"cpu",kernelFunc:qoe};var joe=Me(Wo,r=>Math.sin(r)),jB={kernelName:Wo,backendName:"cpu",kernelFunc:joe};var Xoe=Me(La,r=>Math.sinh(r)),XB={kernelName:La,backendName:"cpu",kernelFunc:Xoe};var Yoe=11920928955078125e-23,YB=Math.log(Yoe)+2,Zoe=Me(Ji,r=>{let t=r>-YB,e=r<YB,n=Math.exp(r),o;return e?o=n:t?o=r:o=Math.log(1+n),o}),ZB={kernelName:Ji,backendName:"cpu",kernelFunc:Zoe};function Qoe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:a}=n;re([o],"spaceToBatchND");let i=y.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let w=1+s.length;w<o.shape.length;++w)u.push([0,0]);let p=Wx.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),l=C.getReshaped(p.shape,s,i,!1),m=C.getPermuted(l.length,s.length,!1),c=C.getReshapedPermuted(p.shape,s,i,!1),h=tt({inputs:{x:p},backend:e,attrs:{shape:l}}),T=Qt({inputs:{x:h},backend:e,attrs:{perm:m}}),k=tt({inputs:{x:T},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(T),k}var QB={kernelName:Is,backendName:"cpu",kernelFunc:Qoe};function Joe(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=e.data.get(n.dataId).values,u=e.data.get(o.dataId).values,p=e.data.get(s.dataId).values,l=e.data.get(a.dataId).values[0],[m,c,d,f,h]=Ex(i,n.shape,n.dtype,u,o.dtype,p,l);return[e.makeTensorInfo(c,n.dtype,m),e.makeTensorInfo([c[0]],o.dtype,d),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var JB={kernelName:Ku,backendName:"cpu",kernelFunc:Joe};function ese(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(e.data.get(o.dataId).values),i=e.data.get(n.dataId).values,u=Array.from(e.data.get(s.dataId).values),[p,l,m]=_x(i,n.shape,n.dtype,a,u);return[e.makeTensorInfo(l,n.dtype,p),e.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}var eO={kernelName:eu,backendName:"cpu",kernelFunc:ese};function tse(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[p,l]=bf(a,n.shape,n.dtype,i,u,!0);return e.makeTensorInfo(l,n.dtype,p)}var tO={kernelName:Vu,backendName:"cpu",kernelFunc:tse};function rse(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let a=e.data.get(n.dataId).values,i=e.data.get(o.dataId).values,u=e.data.get(s.dataId).values,[p,l]=bf(a,n.shape,n.dtype,i,u);return e.makeTensorInfo(l,n.dtype,p)}var rO={kernelName:Hu,backendName:"cpu",kernelFunc:rse};function nse(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=t,{outputShape:i}=n,{sliceRank:u,numUpdates:p,sliceSize:l,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1,f=e.bufferSync(o),h;switch(s.dtype){case"bool":{let g=e.bufferSync(s),b=Boolean(e.data.get(a.dataId).values[0]);h=xu(f,g,i,c,l,p,u,m,b,d);break}case"float32":{let g=e.bufferSync(s),b=e.data.get(a.dataId).values[0];h=xu(f,g,i,c,l,p,u,m,b,d);break}case"int32":{let g=e.bufferSync(s),b=e.data.get(a.dataId).values[0];h=xu(f,g,i,c,l,p,u,m,b,d);break}case"string":{let g=e.bufferSync(s),b=y.decodeString(e.data.get(a.dataId).values[0]);h=xu(f,g,i,c,l,p,u,m,b,d);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return e.makeTensorInfo(i,h.dtype,h.values)}var nO={kernelName:qu,backendName:"cpu",kernelFunc:nse};function ose(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),p=new Array(o.shape.length).fill(0),l=o.shape.slice();return u.map(m=>{let c=[...l];c[i]=m;let d=Ys({inputs:{x:o},backend:e,attrs:{begin:p,size:c}});return p[i]+=m,d})}var oO={kernelName:Cs,backendName:"cpu",kernelFunc:ose};var sO={kernelName:gi,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t;re(e,"square");let o=n.data.get(e.dataId).values,s=new Float32Array(o.length);for(let i=0;i<o.length;++i){let u=o[i];s[i]=u*u}return{dataId:n.write(s,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var sse=Me(vs,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),aO={kernelName:vs,backendName:"cpu",kernelFunc:sse};function ase(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:a,strides:i,beginMask:u,endMask:p,ellipsisMask:l,newAxisMask:m,shrinkAxisMask:c}=n;re(o,"stridedSlice");let{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,p,l,m,c),k;if(h)k=tt({inputs:{x:o},backend:e,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),R=Ys({inputs:{x:o},backend:e,attrs:{begin:T,size:w}});k=tt({inputs:{x:R},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(R)}else{let w=e.bufferSync(o),R=Lx(d,w,I,T);k=e.makeTensorInfo(f,R.dtype,R.values)}return k}var iO={kernelName:$a,backendName:"cpu",kernelFunc:ase};function ise(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:p}=n,{data:l,dataSplits:m}=t,c=e.data.get(l.dataId).values,d=e.data.get(m.dataId).values,[f,h]=Kl(c,d,o,s,a,i,u,p);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(m.shape,"int32",h)]}var uO={kernelName:bi,backendName:"cpu",kernelFunc:ise};function use(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=e.data.get(s.dataId).values,u=e.data.get(a.dataId).values[0],[p,l,m]=Vl(i,u,o),c=l.length;return[e.makeTensorInfo([c,2],"int32",p),e.makeTensorInfo([c],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(m))]}var pO={kernelName:ju,backendName:"cpu",kernelFunc:use};function pse(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=e.data.get(s.dataId).values,i=Hl(a,o);return e.makeTensorInfo(s.shape,"int32",i)}var lO={kernelName:Xu,backendName:"cpu",kernelFunc:pse};var lse=Me(Ba,r=>Math.tan(r)),mO={kernelName:Ba,backendName:"cpu",kernelFunc:lse};var mse=Me(Yo,r=>Math.tanh(r)),cO={kernelName:Yo,backendName:"cpu",kernelFunc:mse};function cse(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;re(o,"tile");let a=$x(e.bufferSync(o),s);return e.makeTensorInfo(a.shape,a.dtype,a.values)}var dO={kernelName:Dn,backendName:"cpu",kernelFunc:cse};function dse(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:a}=n;re(o,"topk");let i=e.data.get(o.dataId).values,[u,p]=Bx(i,o.shape,o.dtype,s,a);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(p.shape,p.dtype,p.values)]}var fO={kernelName:Oa,backendName:"cpu",kernelFunc:dse};function fse(r){let{inputs:t,attrs:e,backend:n}=r,{image:o,transforms:s}=t,{interpolation:a,fillMode:i,fillValue:u,outputShape:p}=e,[l,m,c,d]=o.shape,[f,h]=p??[m,c],g=[l,f,h,d],b=y.computeStrides(o.shape),T=b[0],x=b[1],I=b[2],k=y.computeStrides(g),w=k[0],R=k[1],P=k[2],M=y.getTypedArrayFromDType(o.dtype,y.sizeFromShape(g));M.fill(u);let L=n.data.get(o.dataId).values,z=n.data.get(s.dataId).values;for(let V=0;V<l;++V){let j=s.shape[0]===1?z:z.subarray(V*8,V*8+8);for(let H=0;H<f;++H)for(let X=0;X<h;++X)for(let ee=0;ee<d;++ee){let q,ne=j[6]*X+j[7]*H+1;if(ne===0)continue;let se=(j[0]*X+j[1]*H+j[2])/ne,ie=(j[3]*X+j[4]*H+j[5])/ne,pe=hO(se,c,i),ae=hO(ie,m,i);switch(a){case"nearest":q=Tse(L,m,c,T,x,I,V,ae,pe,ee,u);break;case"bilinear":q=xse(L,m,c,T,x,I,V,ae,pe,ee,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}let ye=V*w+H*R+X*P+ee;M[ye]=q}return n.makeTensorInfo(g,o.dtype,M)}return{dataId:n.write(M,g,o.dtype),shape:o.shape,dtype:o.dtype}}var gO={kernelName:za,backendName:"cpu",kernelFunc:fse};function hO(r,t,e){switch(e){case"reflect":return hse(r,t);case"wrap":return gse(r,t);case"nearest":return yse(r,t);case"constant":default:return bse(r,t)}}function hse(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=2*t;e<n&&(e=n*Math.trunc(-e/n)+e),e=e<-t?e+n:-e-1}else if(e>t-1)if(t<=1)e=0;else{let n=2*t;e-=n*Math.trunc(e/n),e>=t&&(e=n-e-1)}return y.clamp(0,e,t-1)}function gse(r,t){let e=r;if(e<0)if(t<=1)e=0;else{let n=t-1;e+=t*(Math.trunc(-e/n)+1)}else if(e>t-1)if(t<=1)e=0;else{let n=t-1;e-=t*Math.trunc(e/n)}return y.clamp(0,e,t-1)}function bse(r,t){return r}function yse(r,t){return y.clamp(0,r,t-1)}function yg(r,t,e,n,o,s,a,i,u,p,l){let m=a*n+i*o+u*s+p;return 0<=i&&i<t&&0<=u&&u<e?r[m]:l}function Tse(r,t,e,n,o,s,a,i,u,p,l){let m=Math.round(i),c=Math.round(u);return yg(r,t,e,n,o,s,a,m,c,p,l)}function xse(r,t,e,n,o,s,a,i,u,p,l){let m=Math.floor(i),c=Math.floor(u),d=m+1,f=c+1,h=(f-u)*yg(r,t,e,n,o,s,a,m,c,p,l)+(u-c)*yg(r,t,e,n,o,s,a,m,f,p,l),g=(f-u)*yg(r,t,e,n,o,s,a,d,c,p,l)+(u-c)*yg(r,t,e,n,o,s,a,d,f,p,l);return(d-i)*h+(i-m)*g}function Ise(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;re(s,"unique");let a=n.data.get(s.dataId).values,{outputValues:i,outputShape:u,indices:p}=Ox(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([p.length],"int32",p)]}var bO={kernelName:rc,backendName:"cpu",kernelFunc:Ise};function Cse(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape.length,i=o.shape[s],u=new Array(a-1),p=0;for(let d=0;d<a;d++)d!==s&&(u[p++]=o.shape[d]);let l=new Array(a).fill(0),m=o.shape.slice();m[s]=1;let c=new Array(i);for(let d=0;d<c.length;d++){l[s]=d;let f=Ys({inputs:{x:o},backend:e,attrs:{begin:l,size:m}});c[d]=tt({inputs:{x:f},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(f)}return c}var yO={kernelName:ks,backendName:"cpu",kernelFunc:Cse};function kse(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:a}=n;re(o,"unsortedSegmentSum");let i=o.shape.length,u=s.shape.length,p=[],l=[],m=i-u,c=s;for(let f=0;f<m;++f){let h=xf({inputs:{input:c},backend:e,attrs:{dim:f+1}});c=h,l.push(h)}for(let f=0;f<a;++f){let h=y.createScalarValue(f,"int32"),g=e.makeTensorInfo([],"int32",h),b=uN({inputs:{a:g,b:c},backend:e}),T=qs({inputs:{x:b},backend:e,attrs:{dtype:"float32"}}),x=Gl({inputs:{a:T,b:o},backend:e}),I=Iu({inputs:{x},backend:e,attrs:{axis:0,keepDims:!1}});p.push(I),l.push(g),l.push(b),l.push(T),l.push(x),l.push(I)}let d=ON({inputs:p,backend:e,attrs:{axis:0}});return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),d}var TO={kernelName:Yu,backendName:"cpu",kernelFunc:kse};var Sse=[qL,aL,jL,XL,mL,YL,ZL,QL,JL,e$,t$,r$,n$,o$,s$,i$,u$,p$,l$,HL,m$,c$,d$,f$,lL,cL,h$,iL,g$,y$,T$,x$,I$,C$,k$,S$,v$,A$,w$,N$,D$,F$,R$,P$,M$,E$,_$,L$,$$,B$,z$,zL,G$,dL,U$,fL,W$,hL,K$,V$,H$,gL,q$,j$,X$,Y$,Z$,bL,yL,uL,Q$,b$,J$,eB,tB,GL,TL,xL,rB,IL,nB,oB,sB,aB,iB,uB,pB,CL,lB,mB,cB,dB,hB,gB,bB,kL,yB,TB,CB,SL,vL,kB,SB,vB,AL,AB,DB,FB,Wx,RB,UL,NL,PB,MB,pL,hg,EB,WL,KL,VL,_B,LB,$B,BB,OB,zB,GB,RL,UB,KB,VB,HB,ML,qB,jB,XB,EL,xB,ZB,QB,JB,eO,tO,rO,nO,oO,LL,sO,$L,aO,iO,uO,pO,lO,BL,O$,mO,cO,dO,fO,gO,wL,bO,yO,TO,wB];for(let r of Sse)tu(r);var kf={};Xe(kf,{assertNotComplex:()=>oi,bindCanvasToFramebuffer:()=>Mse,bindColorTextureToFramebuffer:()=>Cg,bindTextureToProgramUniformSampler:()=>tD,bindTextureUnit:()=>kO,bindVertexBufferToProgramAttribute:()=>Xx,callAndCheck:()=>Se,canBeRepresented:()=>WN,createFragmentShader:()=>VN,createFramebuffer:()=>QN,createProgram:()=>HN,createStaticIndexBuffer:()=>XN,createStaticVertexBuffer:()=>jN,createTexture:()=>YN,createVertexShader:()=>KN,getBatchDim:()=>ku,getExtensionOrThrow:()=>If,getFramebufferErrorMessage:()=>SO,getMaxTexturesInShader:()=>oD,getNumChannels:()=>Rse,getProgramUniformLocation:()=>eD,getProgramUniformLocationOrThrow:()=>JN,getRowsCols:()=>Su,getShapeAs3D:()=>kg,getTextureShapeFromLogicalShape:()=>rD,getWebGLDisjointQueryTimerVersion:()=>sD,getWebGLErrorMessage:()=>CO,getWebGLMaxTextureSize:()=>nD,hasExtension:()=>Jn,isCapableOfRenderingToFloatTexture:()=>aD,isDownloadFloatTextureEnabled:()=>iD,isReshapeFree:()=>Rp,isWebGLFenceEnabled:()=>uD,isWebGLVersionEnabled:()=>Zx,linkProgram:()=>qN,logShaderSourceAndInfoLog:()=>jx,resetMaxTextureSize:()=>Ese,resetMaxTexturesInShader:()=>_se,unbindColorTextureFromFramebuffer:()=>Yx,unbindTextureUnit:()=>Pse,validateFramebuffer:()=>Cf,validateProgram:()=>Ig,validateTextureSize:()=>ZN});var jl={},Kx={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function zN(r,t){jl[r]=t}function Qn(r,t){if(!(r in jl)||t!=null){let n=Ase(r,t);if(n!==null)jl[r]=n;else return console.log("Could not get context for WebGL version",r),null}let e=jl[r];return e==null||e.isContextLost()?(delete jl[r],Qn(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),jl[r])}function vse(r){if(typeof OffscreenCanvas<"u"&&r===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Ase(r,t){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=t??vse(r);return e.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete jl[r]},!1),B().getBool("SOFTWARE_WEBGL_ENABLED")&&(Kx.failIfMajorPerformanceCaveat=!1),r===1?e.getContext("webgl",Kx)||e.getContext("experimental-webgl",Kx):e.getContext("webgl2",Kx)}function Xl(r,t){return[t,r]}function xO(r,t){return r*t}function Tg(r){let t=y.sizeFromShape(r),e=Math.ceil(t/4);return y.sizeToSquarishShape(e)}function Mi(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function IO(r,t){let[e,n]=Mi(r,t);return e*n*4}function xg(r,t){let e=r,n,o,s,a,i,u,p,l,m,c;return B().getNumber("WEBGL_VERSION")===2?(n=e.R32F,o=e.R16F,s=e.RGBA16F,a=e.RGBA32F,i=e.RED,p=4,l=1,m=e.HALF_FLOAT,c=e.FLOAT,u=e.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,a=e.RGBA,i=r.RGBA,p=4,l=4,m=t!=null?t.HALF_FLOAT_OES:null,c=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:i,downloadTextureFormat:u,downloadUnpackNumChannels:p,defaultNumChannels:l,textureTypeHalfFloat:m,textureTypeFloat:c}}function Se(r,t){let e=t();return B().getBool("DEBUG")&&wse(r),e}function wse(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+CO(r,t))}var Nse=596e-10,Dse=65504;function WN(r){return!!(B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||Nse<Math.abs(r)&&Math.abs(r)<Dse)}function CO(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function If(r,t){return Cu(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function KN(r,t){let e=Cu(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Se(r,()=>r.shaderSource(e,t)),Se(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function VN(r,t){let e=Cu(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Se(r,()=>r.shaderSource(e,t)),Se(r,()=>r.compileShader(e)),B().get("ENGINE_COMPILE_ONLY"))return e;if(r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw jx(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var Fse=/ERROR: [0-9]+:([0-9]+):/g;function jx(r,t){let e=Fse.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let n=+e[1],o=r.split(`
`),s=o.length.toString().length+2,a=o.map((m,c)=>y.rightPad((c+1).toString(),s)+m),i=0;for(let m=0;m<a.length;m++)i=Math.max(a[m].length,i);let u=a.slice(0,n-1),p=a.slice(n-1,n),l=a.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${y.rightPad(p[0],i)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(l.join(`
`))}function HN(r){return Cu(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function qN(r,t){if(Se(r,()=>r.linkProgram(t)),!B().get("ENGINE_COMPILE_ONLY")&&r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function Ig(r,t){if(Se(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function jN(r,t){let e=Cu(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Se(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),Se(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function XN(r,t){let e=Cu(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Se(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),Se(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function Rse(){return B().getNumber("WEBGL_VERSION")===2?1:4}function YN(r){return Cu(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function ZN(r,t){let e=B().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let n=`[${r}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>e||t>e){let n=`[${r}x${t}]`,o=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function QN(r){return Cu(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Xx(r,t,e,n,o,s,a){let i=r.getAttribLocation(t,e);return i===-1?!1:(Se(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Se(r,()=>r.vertexAttribPointer(i,o,r.FLOAT,!1,s,a)),Se(r,()=>r.enableVertexAttribArray(i)),!0)}function kO(r,t,e){vO(r,e),Se(r,()=>r.activeTexture(r.TEXTURE0+e)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function Pse(r,t){vO(r,t),Se(r,()=>r.activeTexture(r.TEXTURE0+t)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function JN(r,t,e){return Cu(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function eD(r,t,e){return r.getUniformLocation(t,e)}function tD(r,t,e,n){Se(r,()=>kO(r,t,n)),Se(r,()=>r.uniform1i(e,n))}function Mse(r){Se(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),Se(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),Se(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function Cg(r,t,e){Se(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),Se(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function Yx(r,t){Se(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Se(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function Cf(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+SO(r,t))}function SO(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function Cu(r,t,e){let n=Se(r,()=>t());if(n==null)throw new Error(e);return n}function vO(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+r.TEXTURE0;if(n<r.TEXTURE0||n>e){let o=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${o}.`)}}function ku(r,t=2){return y.sizeFromShape(r.slice(0,r.length-t))}function Su(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function kg(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[ku(r),...Su(r)]),t}function rD(r,t=!1){let e=B().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e=e*2,r=r.map((o,s)=>s>=r.length-2?y.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=y.squeezeShape(r).newShape);let n=y.sizeFromShape(r);if(r.length<=1&&n<=e)return[1,n];if(r.length===2&&r[0]<=e&&r[1]<=e)return r;if(r.length===3&&r[0]*r[1]<=e&&r[2]<=e)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=e&&r[1]*r[2]<=e)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e)return[r[0],r[1]*r[2]*r[3]];if(t){let o=ku(r),s=2,a=2;return r.length&&([s,a]=Su(r)),n=o*(s/2)*(a/2),y.sizeToSquarishShape(n).map(i=>i*2)}return y.sizeToSquarishShape(n)}function Vx(r){return r%2===0}function Rp(r,t){if(r=r.slice(-2),t=t.slice(-2),y.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r.slice(-1)[0],n=t.slice(-1)[0];if(e===n||Vx(e)&&Vx(n)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&Vx(r[0])&&Vx(t[0])}var Hx,qx;function nD(r){if(Hx==null){let t=Qn(r);Hx=t.getParameter(t.MAX_TEXTURE_SIZE)}return Hx}function Ese(){Hx=null}function _se(){qx=null}function oD(r){if(qx==null){let t=Qn(r);qx=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,qx)}function sD(r){if(r===0)return 0;let t,e=Qn(r);return Jn(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Jn(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Jn(r,t){return r.getExtension(t)!=null}function Zx(r){try{if(Qn(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function aD(r){if(r===0)return!1;let t=Qn(r);if(r===1){if(!Jn(t,"OES_texture_float"))return!1}else if(!Jn(t,"EXT_color_buffer_float"))return!1;return UN(t)}function iD(r){if(r===0)return!1;let t=Qn(r);if(r===1){if(!Jn(t,"OES_texture_float")||!Jn(t,"WEBGL_color_buffer_float"))return!1}else{if(Jn(t,"EXT_color_buffer_float"))return UN(t);let n="EXT_color_buffer_half_float";if(Jn(t,n)){let o=t.getExtension(n);return Lse(t,o)}return!1}return UN(t)}function UN(r){let t=xg(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,n,o,0,t.textureFormatFloat,t.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(s),a}function Lse(r,t){let e=xg(r,t),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,o,s,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(a),i}function uD(r){return r!==2?!1:Qn(r).fenceSync!=null}function oi(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&y.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var Le=B();Le.registerFlag("HAS_WEBGL",()=>Le.getNumber("WEBGL_VERSION")>0);Le.registerFlag("WEBGL_VERSION",()=>Zx(2)?2:Zx(1)?1:0);Le.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Le.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Le.get("WEBGL_VERSION")===2);Le.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Le.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Le.registerFlag("WEBGL_PACK",()=>Le.getBool("HAS_WEBGL"));Le.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_CLIP",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_PACK_REDUCE",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_LAZILY_UNPACK",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_CONV_IM2COL",()=>Le.getBool("WEBGL_PACK"));Le.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>nD(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>oD(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=Le.getNumber("WEBGL_VERSION");return r===0?0:sD(r)});Le.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Le.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Ju.isMobile());Le.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>aD(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Le.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Le.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Le.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>iD(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_FENCE_API_ENABLED",()=>uD(Le.getNumber("WEBGL_VERSION")));Le.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Le.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Le.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});Le.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>Ju.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});Le.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Le.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Le.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Le.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Le.registerFlag("WEBGL_EXP_CONV",()=>!1);Le.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Le.getBool("IS_TEST"));function Jt(){let r,t,e,n,o,s,a,i,u,p;return B().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",n="in",o="texture",s="outputColor",a="out vec4 outputColor;",i=`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",p=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",n="varying",o="texture2D",s="gl_FragColor",a="",i=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,p=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:n,texture2D:o,output:s,defineOutput:a,defineSpecialNaN:i,defineSpecialInf:u,defineRound:p}}function si(r,t,e="index"){let n=y.computeStrides(t);return n.map((o,s)=>{let a=`int ${r[s]} = ${e} / ${o}`,i=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${a}; ${i};`}).join("")}function Yl(r,t,e="index"){let n=y.computeStrides(t);return n.map((o,s)=>{let a=`int ${r[s]} = ${e} / outShapeStrides[${s}]`,i=s===n.length-1?`int ${r[s+1]} = ${e} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${a}; ${i};`}).join("")}function $se(r,t){let e=r.length,n=r.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=n[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function AO(r,t,e="index"){let n=r.map((s,a)=>a),o=$se(n,t);return o.map((s,a)=>{let i=`int ${r[a]} = ${e} / ${o[a]}`,u=a===o.length-1?`int ${r[a+1]} = ${e} - ${r[a]} * ${o[a]}`:`index -= ${r[a]} * ${o[a]}`;return`${i}; ${u};`}).join("")}function Sf(r){let t=y.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}function vf(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Qx=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:wO}=C;function NO(r,t,e){let n=[];if(r.forEach(d=>{let f=y.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?n.push(`uniform float ${d.name}${f>1?`[${f}]`:""};`):(n.push(`uniform sampler2D ${d.name};`),n.push(`uniform int offset${d.name};`)),e.enableShapeUniforms){let{uniformShape:h}=Jx(e.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${d.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${d.name}TexShape;`)}}),e.enableShapeUniforms){switch(t.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}e.customUniforms&&e.customUniforms.forEach(d=>{n.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(d=>Bse(d,t,e.packedInputs,e.enableShapeUniforms)).join(`
`),a=t.texShape,i=Jt(),u=Gse(i),p,l,m=Kse(i);return t.isPacked?(p=Ose(t.logicalShape,a,e.enableShapeUniforms),l=Wse(i)):(p=zse(t.logicalShape,a,e.enableShapeUniforms),l=Use(i)),e.packedInputs&&(m+=jse),[m,u,l,o,p,s,e.userCode].join(`
`)}function wf(r,t=!1){let e=r.shapeInfo.logicalShape;switch(e.length){case 0:return aae(r,t);case 1:return uae(r,t);case 2:return lae(r,t);case 3:return cae(r,t);case 4:return fae(r,t);case 5:return hae(r);case 6:return gae(r);default:throw new Error(`${e.length}-D input sampling is not yet supported`)}}function DO(r,t){switch(r.shapeInfo.logicalShape.length){case 0:return sae(r);case 1:return iae(r,t);case 2:return pae(r,t);case 3:return mae(r,t);default:return dae(r,t)}}function Bse(r,t,e=!1,n){let o="";e?o+=DO(r,n):o+=wf(r,n);let s=r.shapeInfo.logicalShape,a=t.logicalShape;return s.length<=a.length&&(e?o+=bae(r,t):o+=yae(r,t)),o}function Ose(r,t,e){switch(r.length){case 0:return FO();case 1:return Xse(r,t,e);case 2:return nae(r,t,e);case 3:return Zse(r,t,e);default:return Jse(r,t,e)}}function zse(r,t,e){switch(r.length){case 0:return FO();case 1:return Yse(r,t,e);case 2:return oae(r,t,e);case 3:return Qse(r,t,e);case 4:return eae(r,t,e);case 5:return tae(r,t);case 6:return rae(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function Gse(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function Use(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function Wse(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function Kse(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Vse}
    ${Hse}
    ${qse}
  `}var Vse=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Hse=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,qse=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,jse=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function FO(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function Xse(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return n[0]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?e?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function Yse(r,t,e){return t[0]===1?e?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?e?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:e?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function Zse(r,t,e){if(e)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Qse(r,t,e){if(e)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Yl(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=si(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function Jse(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),a=s,i="",u="b, r, c";for(let p=2;p<r.length-1;p++)a*=r[r.length-p-1],i=`
      int b${p} = index / ${a};
      index -= b${p} * ${a};
    `+i,u=`b${p}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${i}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function eae(r,t,e){if(e)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Yl(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=si(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function tae(r,t){let e=si(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function rae(r,t){let e=si(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function nae(r,t,e){let n=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(y.arraysEqual(r,t))return e?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return e?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function oae(r,t,e){return y.arraysEqual(r,t)?e?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?e?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:e?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Zl(r){return`offset${r}`}function sae(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=Jt();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function aae(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${e};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${e}, halfCR);
      }
    `;let a=Zl(e);if(t)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], ${a});
      return sampleTexture(${e}, uv);
    }
  `;let[i,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${i}, ${u}, ${a});
      return sampleTexture(${e}, uv);
    }
  `}function iae(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=r.shapeInfo.texShape,s=Jt();if(t)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${e}, uv);
    }
  `;let a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${e}, uv);
    }
  `}function uae(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${Nf(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],a=o[1];if(a===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${e}, halfCR);
      }
    `;let i=Zl(e);return a===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / float(${e}TexShape[0]));
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${i}) + 0.5) / ${s}.0);
        return sampleTexture(${e}, uv);
      }
    `:s===1?t?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / float(${e}TexShape[1]), 0.5);
        return sampleTexture(${e}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${i}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${e}, uv);
      }
    `:t?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${e}TexShape[0], ${e}TexShape[1], index + ${i});
      return sampleTexture(${e}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${i});
      return sampleTexture(${e}, uv);
    }
  `}function pae(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=s[0],i=s[1],u=Jt();if(s!=null&&y.arraysEqual(e,s))return t?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${i}.0, ${a}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(t)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let p=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],l=Math.ceil(e[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${l}, ${p[0]}, ${p[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function lae(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&y.arraysEqual(e,s)){if(t)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let c=s[0],d=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${c}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:a,keptDims:i}=y.squeezeShape(e),u=a;if(u.length<e.length){let c=Df(r,u),d=["row","col"];return`
      ${wf(c,t)}
      float ${o}(int row, int col) {
        return ${o}(${Ff(d,i)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${e[1]}, 1)));
        ${Nf(r)}
      }
    `;let p=s[0],l=s[1],m=Zl(n);return l===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${m}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${m}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);
      return sampleTexture(${n}, uv);
    }
  `:p===1?t?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${m}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${m}), vec3(${e[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${l}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:t?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${m};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${e[1]} + col + ${m};
    vec2 uv = uvFromFlat(${p}, ${l}, index);
    return sampleTexture(${n}, uv);
  }
`}function mae(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(e[0]===1){let c=e.slice(1),d=[1,2],f=Df(r,c),h=["b","row","col"];return`
        ${DO(f,t)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Ff(h,d)});
        }
      `}let i=Jt();if(t)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `;let u=a[0],p=a[1],l=Math.ceil(e[2]/2),m=l*Math.ceil(e[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${p}, ${m}, ${l}, b, row, col);
      return ${i.texture2D}(${n}, uv);
    }
  `}function cae(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[1]*e[2],a=e[2],{newShape:i,keptDims:u}=y.squeezeShape(e),p=i;if(p.length<e.length){let h=Df(r,p),g=["row","col","depth"];return`
        ${wf(h,t)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Ff(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${Nf(r)}
      }
    `;let l=r.shapeInfo.texShape,m=l[0],c=l[1],d=r.shapeInfo.flatOffset;if(c===s&&d==null)return t?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${c}.0, ${m}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(c===a&&d==null)return t?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${e[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `;let f=Zl(n);return t?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${a} + depth + ${f};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${m}, ${c}, index);
        return sampleTexture(${n}, uv);
      }
  `}function dae(r,t){let e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=Jt();if(t)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${e}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${e}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${e}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${e}TexShape[0]) / 2.0), ceil(float(${e}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${e}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,a=s.length,i=r.shapeInfo.texShape,u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],p=u[0],l=u[1],m=Math.ceil(s[a-1]/2),c=m*Math.ceil(s[a-2]/2),d="int b, int row, int col",f=`b * ${c} + (row / 2) * ${m} + (col / 2)`;for(let h=2;h<a-1;h++)d=`int b${h}, `+d,c*=s[a-h-1],f=`b${h} * ${c} + `+f;return`
    vec4 ${n}(${d}) {
      int index = ${f};
      int texR = index / ${l};
      int texC = index - texR * ${l};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${l}, ${p});
      return ${o.texture2D}(${e}, uv);
    }
  `}function fae(r,t){let e=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=e[3],a=e[2]*s,i=e[1]*a,{newShape:u,keptDims:p}=y.squeezeShape(e);if(u.length<e.length){let T=Df(r,u),x=["row","col","depth","depth2"];return`
      ${wf(T,t)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Ff(x,p)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${i}, ${a}, ${s}, 1)));
        ${Nf(r)}
      }
    `;let l=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,c=m[0],d=m[1],f=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(d===i&&l==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${f}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(d===s&&l==null)return t?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${e[1]*e[2]}, ${e[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${c}.0);
        return sampleTexture(${n}, uv);
      }
    `;let b=Zl(n);return t?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${b});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${c}, ${d}, index + ${b});
      return sampleTexture(${n}, uv);
    }
  `}function hae(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),o=t[4],s=t[3]*o,a=t[2]*s,i=t[1]*a,{newShape:u,keptDims:p}=y.squeezeShape(t);if(u.length<t.length){let h=Df(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${wf(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Ff(g,p)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${i}, ${a}, ${s}, ${o})) +
          depth3;
        ${Nf(r)}
      }
    `;let l=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,c=m[0],d=m[1];if(d===i&&l==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${c}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===o&&l==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${c}.0);
        return sampleTexture(${e}, uv);
      }
    `;let f=Zl(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${i} + col * ${a} + depth * ${s} +
          depth2 * ${o} + depth3 + ${f};
      vec2 uv = uvFromFlat(${c}, ${d}, index);
      return sampleTexture(${e}, uv);
    }
  `}function gae(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:o,keptDims:s}=y.squeezeShape(t);if(o.length<t.length){let g=Df(r,o),b=["row","col","depth","depth2","depth3","depth4"];return`
      ${wf(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Ff(b,s)});
      }
    `}let a=t[5],i=t[4]*a,u=t[3]*i,p=t[2]*u,l=t[1]*p;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${p}, ${u}, ${i})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Nf(r)}
      }
    `;let m=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,d=c[0],f=c[1];if(f===l&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${p}, ${u}, ${i}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(f===a&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;let h=Zl(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${p} + depth * ${u} +
          depth2 * ${i} + depth3 * ${a} + depth4 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Nf(r){let t=r.name,e=y.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function bae(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,a=t.logicalShape.length,i=wO(r.shapeInfo.logicalShape,t.logicalShape),u=Ve(a),p=a-s,l,m=["x","y","z","w","u","v"];s===0?l="":a<2&&i.length>=1?l="coords = 0;":l=i.map(T=>`coords.${m[T+p]} = 0;`).join(`
`);let c="";a<2&&s>0?c="coords":c=r.shapeInfo.logicalShape.map((T,x)=>`coords.${m[x+p]}`).join(", ");let d="return outputValue;",h=y.sizeFromShape(r.shapeInfo.logicalShape)===1,b=y.sizeFromShape(t.logicalShape)===1;if(s===1&&!h&&!b)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!b)a===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(i.length){let T=s-2,x=s-1;i.indexOf(T)>-1&&i.indexOf(x)>-1?d="return vec4(outputValue.x);":i.indexOf(T)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(x)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${l}
      vec4 outputValue = get${n}(${c});
      ${d}
    }
  `}function yae(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),o="get"+n+"AtOutCoords",s=t.texShape,a=r.shapeInfo.texShape,i=r.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!r.shapeInfo.isUniform&&i===u&&r.shapeInfo.flatOffset==null&&y.arraysEqual(a,s))return`
      float ${o}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let p=Ve(u),l=wO(r.shapeInfo.logicalShape,t.logicalShape),m=u-i,c,d=["x","y","z","w","u","v"];i===0?c="":u<2&&l.length>=1?c="coords = 0;":c=l.map(h=>`coords.${d[h+m]} = 0;`).join(`
`);let f="";return u<2&&i>0?f="coords":f=r.shapeInfo.logicalShape.map((h,g)=>`coords.${d[g+m]}`).join(", "),`
    float ${o}() {
      ${p} coords = getOutputCoords();
      ${c}
      return get${n}(${f});
    }
  `}function Ve(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Jx(r,t,e){let{newShape:n,keptDims:o}=y.squeezeShape(t),s=t.length,a=r&&s===3&&t[0]===1,i=a?t.slice(1):n,u=!r&&s>1&&!y.arraysEqual(t,e)&&n.length<s||a;return{useSqueezeShape:u,uniformShape:u?i:t,keptDims:o}}function Df(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function Ff(r,t){return t.map(e=>r[e]).join(", ")}function PO(r,t,e,n){let o=e.map((l,m)=>{let c={logicalShape:l.shape,texShape:l.isUniform?null:l.texData.texShape,isUniform:l.isUniform,isPacked:l.isUniform?!1:l.texData.isPacked,flatOffset:null};return l.texData!=null&&l.texData.slice!=null&&l.texData.slice.flatOffset>0&&(c.flatOffset=l.texData.slice.flatOffset),{name:t.variableNames[m],shapeInfo:c}}),s=o.map(l=>l.shapeInfo),a={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},i=NO(o,a,t),u=VN(r.gl,i),p=r.createProgram(u);return B().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:u,source:i,webGLProgram:p,inShapeInfos:s,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:{program:t,fragmentShader:u,source:i,webGLProgram:p,inShapeInfos:s,outShapeInfo:a,...pD(r,t,p)}}function pD(r,t,e){let n={},o={},s={},a=[],i,u,p,l=null,m=null;m=r.getUniformLocation(e,"NAN",!1),B().getNumber("WEBGL_VERSION")===1&&(l=r.getUniformLocation(e,"INFINITY",!1));let c=!1;for(let d=0;d<t.variableNames.length;d++){let f=t.variableNames[d];n[f]=r.getUniformLocation(e,f,c),n[`offset${f}`]=r.getUniformLocation(e,`offset${f}`,c),t.enableShapeUniforms&&(o[`${f}Shape`]=r.getUniformLocation(e,`${f}Shape`,c),s[`${f}TexShape`]=r.getUniformLocation(e,`${f}TexShape`,c))}return t.enableShapeUniforms&&(i=r.getUniformLocation(e,"outShape",c),p=r.getUniformLocation(e,"outShapeStrides",c),u=r.getUniformLocation(e,"outTexShape",c)),t.customUniforms&&t.customUniforms.forEach((d,f)=>{a[f]=r.getUniformLocation(e,d.name,c)}),{uniformLocations:n,customUniformLocations:a,infLoc:l,nanLoc:m,inShapesLocations:o,inTexShapesLocations:s,outShapeLocation:i,outShapeStridesLocation:p,outTexShapeLocation:u}}function RO(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,n)=>{let o=e.logicalShape,s=t[n],a=s.shape;if(!y.arraysEqual(o,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${a} must match`);if(e.isUniform&&s.isUniform)return;let i=e.texShape,u=s.isUniform?null:s.texData.texShape;if(!y.arraysEqual(i,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${i} and ${u} must match`)})}function MO(r,t,e,n,o){t.program.enableShapeUniforms||(RO(t.inShapeInfos,e),RO([t.outShapeInfo],[n]));let s=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):r.setOutputMatrixTexture(s.texture,a[0],a[1]),r.setProgram(t.webGLProgram),B().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,1/0),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN),e.forEach((u,p)=>{let l=t.program.variableNames[p],m=t.uniformLocations[l],c=t.uniformLocations[`offset${l}`],d=t.inShapesLocations[`${l}Shape`],f=t.inTexShapesLocations[`${l}TexShape`];if(d){let{uniformShape:h}=Jx(t.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(d,new Int32Array(h));break;case 2:r.gl.uniform2iv(d,new Int32Array(h));break;case 3:r.gl.uniform3iv(d,new Int32Array(h));break;case 4:r.gl.uniform4iv(d,new Int32Array(h));break;default:break}}if(f&&r.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),m!=null){if(u.isUniform){if(y.sizeFromShape(u.shape)<2)r.gl.uniform1f(m,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(m,h)}return}u.texData.slice!=null&&c!=null&&r.gl.uniform1i(c,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture.texture,m,p)}});let i=t.outShapeLocation;if(i)switch(n.shape.length){case 1:r.gl.uniform1iv(i,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(i,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(i,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(i,new Int32Array(n.shape));break;default:break}if(t.outShapeStridesLocation){let u=y.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(u));break;default:break}}t.outTexShapeLocation&&r.gl.uniform2i(t.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),t.program.customUniforms&&o&&t.program.customUniforms.forEach((u,p)=>{let l=t.customUniformLocations[p],m=o[p];if(u.type==="float")r.gl.uniform1fv(l,m);else if(u.type==="vec2")r.gl.uniform2fv(l,m);else if(u.type==="vec3")r.gl.uniform3fv(l,m);else if(u.type==="vec4")r.gl.uniform4fv(l,m);else if(u.type==="int")r.gl.uniform1iv(l,m);else if(u.type==="ivec2")r.gl.uniform2iv(l,m);else if(u.type==="ivec3")r.gl.uniform3iv(l,m);else if(u.type==="ivec4")r.gl.uniform4iv(l,m);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function EO(r,t,e){let n="";t.concat(e).forEach(a=>{let i=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!a.isUniform){let u=a.texData.texShape,{useSqueezeShape:p,uniformShape:l,keptDims:m}=Jx(r.packedInputs,a.shape,u),c="",d="",f="";if(l.length===1&&r.packedInputs){let k=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];c=`${k[0]>1}_${k[1]>1}`}else if(l.length===2&&!r.packedInputs)d=`${l[0]>1}_${l[1]>1}`;else if(l.length>2&&!r.packedInputs){let k=y.computeStrides(l);f=`${k[0]===u[1]}_${k[k.length-1]===u[1]}`}let h=a.shape.length,g=l.length===2&&y.arraysEqual(a.shape,u),b=y.sizeFromShape(a.shape)===1,T=C.getBroadcastDims(a.shape,e.shape),x=!r.packedInputs&&h===e.shape.length&&y.arraysEqual(u,e.texData.texShape),I=r.packedInputs||l.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${x}_${p?m:""}_${l.length}_${b}_${T}_${g}_${c}_${d}_${f}_${I}_${i}`}else{let u=a.isUniform?"uniform":a.texData.texShape;n+=`${a.shape}_${u}_${i}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${B().getNumber("WEBGL_VERSION")}`,s}function Ft(r){return B().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var eI=class{constructor(t){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.outPackingScheme=0;this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Jt();this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Yl(["r","c","d"],t):si(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${e.output} = result;
      }
    `}};var tI=class{constructor(t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outPackingScheme=0;this.customUniforms=[{name:"texShape",type:"ivec2"}];let e=Jt();this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Yl(["r","c","d"],t):si(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${e.output} = result;
      }
    `}};var rI=class{constructor(t){this.variableNames=["A"];this.outTexUsage=3;let e=Jt();this.outputShape=t,this.userCode=`
      ${Qx}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var oI=class{constructor(t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outTexUsage=3;let e=Jt();this.outputShape=t,this.userCode=`
      ${Qx}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var sI=class{constructor(t,e=!1){this.variableNames=["A"];this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Jt();this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length);let o="result";e&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?vf():Sf(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var aI=class{constructor(t,e=!1){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Jt();this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length);let o="",s="result";e&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let i=0;i<=1;i++){let u=a*2+i;o+=`
          localCoords = coords;
          if(localCoords[2] + ${i} < ${this.enableShapeUniforms?"outShape[2]":`${t[2]}`}) {
          localCoords[2] += ${i};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${t[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?vf():Sf(t)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var AD={};Xe(AD,{bindVertexProgramAttributeStreams:()=>yD,createBufferFromOutputTexture:()=>ID,createFloat16MatrixTexture:()=>fD,createFloat16PackedMatrixTexture:()=>bD,createFloat32MatrixTexture:()=>dD,createIndexBuffer:()=>cD,createPackedMatrixTexture:()=>gD,createUnsignedBytesMatrixTexture:()=>hD,createVertexBuffer:()=>mD,createVertexShader:()=>lD,downloadByteEncodedFloatMatrixFromOutputTexture:()=>kD,downloadFloat32MatrixFromBuffer:()=>CD,downloadMatrixFromPackedOutputTexture:()=>vD,downloadPackedMatrixFromBuffer:()=>SD,getInternalFormatForFloat16MatrixTexture:()=>uI,getInternalFormatForFloat16PackedMatrixTexture:()=>mI,getInternalFormatForFloat32MatrixTexture:()=>iI,getInternalFormatForPackedMatrixTexture:()=>lI,getInternalFormatForUnsignedBytesMatrixTexture:()=>pI,uploadDenseMatrixToTexture:()=>TD,uploadPixelDataToTexture:()=>xD});function lD(r){let t=Jt(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return KN(r,e)}function mD(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return jN(r,t)}function cD(r){let t=new Uint16Array([0,1,2,2,1,3]);return XN(r,t)}function Sg(r,t,e,n,o,s){ZN(t,e);let a=YN(r),i=r.TEXTURE_2D;return Se(r,()=>r.bindTexture(i,a)),Se(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Se(r,()=>r.texParameteri(i,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Se(r,()=>r.texParameteri(i,r.TEXTURE_MIN_FILTER,r.NEAREST)),Se(r,()=>r.texParameteri(i,r.TEXTURE_MAG_FILTER,r.NEAREST)),B().getNumber("WEBGL_VERSION")===1?Se(r,()=>r.texImage2D(i,0,n,t,e,0,o,s,null)):Se(r,()=>r.texStorage2D(i,1,n,t,e)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null)),{texture:a,texShape:[e,t]}}function iI(r){return r.internalFormatFloat}function dD(r,t,e,n){let[o,s]=Xl(t,e);return Sg(r,o,s,iI(n),n.textureFormatFloat,r.FLOAT)}function uI(r){return r.internalFormatHalfFloat}function fD(r,t,e,n){let[o,s]=Xl(t,e);return Sg(r,o,s,uI(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function pI(r){return r.downloadTextureFormat}function hD(r,t,e,n){let[o,s]=Xl(t,e);return Sg(r,o,s,pI(n),r.RGBA,r.UNSIGNED_BYTE)}function lI(r){return r.internalFormatPackedFloat}function gD(r,t,e,n){let[o,s]=Mi(t,e);return Sg(r,o,s,lI(n),r.RGBA,r.FLOAT)}function mI(r){return r.internalFormatPackedHalfFloat}function bD(r,t,e,n){let[o,s]=Mi(t,e);return Sg(r,o,s,mI(n),r.RGBA,n.textureTypeHalfFloat)}function yD(r,t,e){return Se(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),Xx(r,t,"clipSpacePos",e,3,20,0)&&Xx(r,t,"uv",e,2,20,12)}function TD(r,t,e,n,o,s){Se(r,()=>r.bindTexture(r.TEXTURE_2D,t));let a,i,u;o instanceof Uint8Array?(a=new Uint8Array(e*n*4),i=r.UNSIGNED_BYTE,u=r.RGBA):(a=new Float32Array(e*n*4),i=r.FLOAT,u=s.internalFormatPackedFloat),a.set(o),B().getNumber("WEBGL_VERSION")===2?Se(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e,n,r.RGBA,i,a)):Se(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,e,n,0,r.RGBA,i,a)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function xD(r,t,e){Se(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?B().getNumber("WEBGL_VERSION")===2?Se(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,e.width,e.height,r.RGBA,r.UNSIGNED_BYTE,e.data)):Se(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):B().getNumber("WEBGL_VERSION")===2?Se(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,e)):Se(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function ID(r,t,e,n){let o=r.createBuffer();Se(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let i=4*4*t*e;return Se(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,i,r.STREAM_READ)),Se(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),Se(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function CD(r,t,e){let n=r,o=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function kD(r,t,e,n){let[o,s]=Xl(t,e),a=4,i=new Uint8Array(xO(t*e,a));return Se(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,i)),new Float32Array(i.buffer)}function SD(r,t,e,n,o,s,a,i){let u=r,p=new Float32Array(IO(s,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,p),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),p}function vD(r,t,e){let n=new Float32Array(t*e*4);return Se(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,n)),n}var Ql=class{constructor(t){this.outputTexture=null;this.program=null;this.disposed=!1;this.vertexAttrsAreBound=!1;this.itemsToPoll=[];let e=B().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,zN(e,t)):this.gl=Qn(e);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),B().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=If(this.gl,s),Jn(this.gl,a))this.textureHalfFloatExtension=If(this.gl,a);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Jn(this.gl,o))this.colorBufferHalfFloatExtension=If(this.gl,o);else if(B().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Jn(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Jn(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=mD(this.gl),this.indexBuffer=cD(this.gl),this.framebuffer=QN(this.gl),this.textureConfig=xg(this.gl,this.textureHalfFloatExtension)}get debug(){return B().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;Se(t,()=>t.finish()),Se(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),Se(t,()=>t.deleteFramebuffer(this.framebuffer)),Se(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),Se(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),Se(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),dD(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),fD(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),hD(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),xD(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,o){this.throwIfDisposed(),TD(this.gl,t,e,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),bD(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),gD(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(Yx(this.gl,this.framebuffer),this.outputTexture=null),Se(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>kD(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,o,s,a){return SD(this.gl,t,e,n,o,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return CD(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let o=ID(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(B().getBool("WEBGL_FENCE_API_ENABLED")){let o=t,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let a=o.clientWaitSync(s,0,0);return a===o.ALREADY_SIGNALED||a===o.CONDITION_SATISFIED},e=s}else B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>vD(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl;this.vertexShader==null&&(this.vertexShader=lD(e));let n=HN(e);return Se(e,()=>e.attachShader(n,this.vertexShader)),Se(e,()=>e.attachShader(n,t)),qN(e,n),this.debug&&Ig(e,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=yD(e,this.program,this.vertexBuffer)),n}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&Se(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&Ig(this.gl,this.program),Se(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?JN(this.gl,t,e):eD(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),Se(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),tD(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[o,s]=Mi(e,n);this.setOutputMatrixTextureDriver(t,o,s)}setOutputMatrixWriteRegion(t,e,n,o){this.setOutputMatrixWriteRegionDriver(n,t,o,e)}setOutputPackedMatrixWriteRegion(t,e,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Ig(this.gl,this.program),Cf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),Se(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Se(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=If(this.gl,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await y.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=Iae(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&y.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Cg(this.gl,t,this.framebuffer),this.debug&&Cf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Cg(this.gl,this.outputTexture,this.framebuffer),this.debug&&Cf(this.gl)):Yx(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let o=this.gl;Cg(o,t,this.framebuffer),this.debug&&Cf(o),this.outputTexture=t,Se(o,()=>o.viewport(0,0,e,n)),Se(o,()=>o.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,o){this.throwIfDisposed(),Se(this.gl,()=>this.gl.scissor(t,e,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function Iae(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{addImpl:LO,bincountImpl:cI,bincountReduceImpl:$O,castImpl:BO,ceilImpl:OO,concatImpl:zO,equalImpl:GO,expImpl:UO,expm1Impl:WO,floorImpl:KO,gatherNdImpl:VO,gatherV2Impl:HO,greaterImpl:qO,greaterEqualImpl:jO,lessImpl:XO,lessEqualImpl:YO,linSpaceImpl:ZO,logImpl:QO,maxImpl:JO,maximumImpl:ez,minimumImpl:tz,multiplyImpl:rz,negImpl:nz,notEqualImpl:oz,prodImpl:sz,raggedTensorToTensorImpl:az,rangeImpl:iz,rsqrtImpl:uz,scatterImpl:pz,sigmoidImpl:lz,simpleAbsImpl:dI,sliceImpl:mz,sparseFillEmptyRowsImpl:cz,sparseReshapeImpl:dz,sparseSegmentReductionImpl:fI,sqrtImpl:fz,stridedSliceImpl:hz,stringNGramsImpl:gz,stringSplitImpl:bz,stringToHashBucketFastImpl:yz,subImpl:Tz,tileImpl:xz,topKImpl:Iz,transposeImpl:Jl,uniqueImpl:Cz}=yf;function wD(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function ar(r,t){return t===1?[r]:wD(r,t)}function kz(r,t){if(r===1)return"rc";let e="";for(let n=0;n<r;n++)e+=t[n],n<r-1&&(e+=",");return e}var hI=class{constructor(t){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;if(this.outputShape=t,this.rank=t.length,this.enableShapeUniforms=Ft(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let e=ar("rc",this.rank),n=Ve(this.rank),o=this.getOutOfBoundsCondition(e),s=this.getSetup(e),a=this.getOutput(e);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(t){let e=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${t[t.length-1-a]},`+s;e.push(s)}return e}getOutOfBoundsCondition(t){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let e="";for(let n=this.rank-2;n<this.rank;n++)e+=`${t[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(e+="||");return e}getSetup(t){if(this.rank===1)return"";let e=t.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${e[0]};
      int c = ${e[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(t){let e=this.getSourceCoordsArr(t);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${e[0]}),
            cEdge ? 0. : getA(${e[1]}),
            rEdge ? 0. : getA(${e[2]}),
            rEdge || cEdge ? 0. : getA(${e[3]})`}};var Rf=class{constructor(t,e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"inputShape",type:"ivec3"}];this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2===1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${Cae(e,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?vf():Sf(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":t[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":t[2]};

        ${n}

        setOutput(result);
      }
    `}};function Cae(r,t){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${t?AO(["r","c","d"],"inputShape"):si(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var gI=class{constructor(t){this.gpgpu=t;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;this.freeTextures={};this.logEnabled=!1;this.usedTextures={}}acquireTexture(t,e,n){let o=vz(e,n),s=Az(t,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let a=Sz(t,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let i;return o===3?i=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):o===4?i=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):o===1?i=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):o===0?i=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):o===2&&(i=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[s].push(i),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),i}releaseTexture(t,e,n,o){if(this.freeTextures==null)return;let s=vz(n,o),a=Az(e,s,o);a in this.freeTextures||(this.freeTextures[a]=[]);let i=Sz(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=B().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t.texture),this._numBytesAllocated-=i):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=i),this.numUsedTextures--;let p=this.usedTextures[a],l=p.indexOf(t);if(l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");p.splice(l,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function kae(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;if(t===e.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}function Sz(r,t,e,n,o){let s=Sae(t,n),a;if(o){let[u,p]=Mi(r[0],r[1]);a=u*p}else{let[u,p]=Xl(r[0],r[1]);a=u*p}let i=kae(e,s);return a*i}function Sae(r,t){switch(r){case 3:return lI(t);case 4:return mI(t);case 1:return iI(t);case 0:return uI(t);case 2:return pI(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function vae(r){return B().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?3:1:r?4:0}function vz(r,t){if(r===1)return 3;if(r===0||r==null)return vae(t);if(r===3||r===2)return 2;throw new Error(`Unknown logical texture type ${r}`)}function Az(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var nn=class{constructor(t,e){this.variableNames=["A"];this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Ir="if (isnan(x)) return x;",wz="return x;",ND="return abs(x);";var Nz="return (x >= 0.0) ? x : (exp(x) - 1.0);",Dz=Ir+`
  return (x < 0.0) ? 0.0 : x;
`,Fz=Ir+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,em="return x;",Rz="return 1.0 / (1.0 + exp(-1.0 * x));";var Mz="return x;",Ez=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,_z=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Lz=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$z="return 1.0 / (1.0 + exp(-1.0 * x));",os=class{constructor(t,e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var bI=class{constructor(t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length);let e=t.length,n=ar("rc",e),o=Ve(e),s=kz(e,n),a=n.slice(-2),i=e<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${i}));
      }
    `}};var wae=xr.whereImpl,Nae=1e-7,Dae=1e-4,yI={};function Fae(r){return r in yI||(yI[r]={}),yI[r]}var Rae=B().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Pae=600;function Mae(){return B().global.screen==null?1024:B().global.screen.height*B().global.screen.width*window.devicePixelRatio*Pae/1024/1024}var DD=class extends no{constructor(e){super();this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.dataRefCount=new WeakMap;this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.lastGlFlushTime=0;this.warnedAboutMemory=!1;this.pendingDeletes=0;this.disposed=!1;if(!B().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof Ql)n=e;else{let o=Qn(B().getNumber("WEBGL_VERSION"),e);n=new Ql(o)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{let o=Qn(B().getNumber("WEBGL_VERSION"));n=new Ql(o),this.binaryCache=Fae(B().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new gI(this.gpgpu),this.numMBBeforeWarning=Mae(),this.texData=new ma(this,Mn())}nextDataId(){return DD.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,n,o){if((B().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||B().getBool("DEBUG"))&&this.checkNumericalProblems(e),o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.texData.set(s,{shape:n,dtype:o,values:e,usage:1,refCount:1}),s}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){let n=this.texData.get(e);n.refCount--}}move(e,n,o,s,a){if(B().getBool("DEBUG")&&this.checkNumericalProblems(n),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:o,dtype:s,values:n,usage:1,refCount:a})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let n=this.texData.get(e),{values:o,dtype:s,complexTensorInfos:a,slice:i,shape:u,isPacked:p}=n;if(i!=null){let d;p?d=new os(u,em):d=new nn(u,em);let f=this.runWebGLProgram(d,[{dataId:e,shape:u,dtype:s}],s),h=this.readSync(f.dataId);return this.disposeIntermediateTensorInfo(f),h}if(o!=null)return this.convertAndCacheOnCPU(e);if(s==="string")return o;let l=this.activeTimers!=null,m;l&&(m=y.now());let c;if(s==="complex64"){let d=this.readSync(a.real.dataId),f=this.readSync(a.imag.dataId);c=C.mergeRealAndImagArrays(d,f)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=y.now()-m),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){let h=this.pendingRead.get(e);return new Promise(g=>h.push(g))}let n=this.texData.get(e),{values:o,shape:s,slice:a,dtype:i,complexTensorInfos:u,isPacked:p}=n;if(a!=null){let h;p?h=new os(s,em):h=new nn(s,em);let g=this.runWebGLProgram(h,[{dataId:e,shape:s,dtype:i}],i),b=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),b}if(o!=null)return this.convertAndCacheOnCPU(e);if(B().getBool("DEBUG")&&!B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&B().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,m;if(i!=="complex64"&&B().get("WEBGL_BUFFER_SUPPORTED")){m=this.decode(e);let h=this.texData.get(m.dataId);l=this.gpgpu.createBufferFromTexture(h.texture.texture,...Tg(s))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(i==="complex64"){let h=await Promise.all([this.read(u.real.dataId),this.read(u.imag.dataId)]),g=h[0],b=h[1];c=C.mergeRealAndImagArrays(g,b)}else if(l==null)c=this.getValuesFromTexture(e);else{let h=y.sizeFromShape(s);c=this.gpgpu.downloadFloat32MatrixFromBuffer(l,h)}if(m!=null&&this.disposeIntermediateTensorInfo(m),l!=null){let h=this.gpgpu.gl;Se(h,()=>h.deleteBuffer(l))}let d=this.convertAndCacheOnCPU(e,c),f=this.pendingRead.get(e);return this.pendingRead.delete(e),f.forEach(h=>h(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Mn().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,n={}){let o=this.texData.get(e),{values:s,shape:a,slice:i,dtype:u,isPacked:p,texture:l}=o;if(u==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(i!=null){let f;p?f=new os(a,em):f=new nn(a,em);let h=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:u}],u),g=this.readToGPU(h,n);return this.disposeIntermediateTensorInfo(h),g}if(l==null)throw s!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let m=this.decode(e,n.customTexShape),c=Mn().makeTensorFromTensorInfo(m),d=this.texData.get(m.dataId);return{tensorRef:c,...d.texture}}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let o=n.map(s=>y.decodeString(s));return xe(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xe(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){let o=e[n];if(!WN(o))throw B().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${o} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${o} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:n,dtype:o,isPacked:s}=this.texData.get(e),a=y.sizeFromShape(n);if(B().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(e),f=this.texData.get(d.dataId),h=this.gpgpu.downloadMatrixFromPackedTexture(f.texture.texture,...Tg(n)).subarray(0,a);return this.disposeIntermediateTensorInfo(d),h}let i=B().getBool("WEBGL_PACK")&&s===!0,u=i?kg(n):n,p=i?new oI(u):new rI(u),l=this.runWebGLProgram(p,[{shape:u,dtype:o,dataId:e}],"float32"),m=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(m.texture.texture,m.texShape[0],m.texShape[1]).subarray(0,a);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){let n=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();let a=y.flatten(this.activeTimers.map(p=>p.query)).filter(p=>p!=null),i=y.flatten(this.activeTimers.map(p=>p.name)).filter(p=>p!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let p=await Promise.all(a);u.kernelMs=y.sum(p),u.getExtraProfileInfo=()=>p.map((l,m)=>({name:i[m],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else u.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,u})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:y.now(),endMs:null}}endTimer(e){return B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=y.now(),e)}async getQueryTime(e){if(B().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:o}=this.texData.get(e);return o!=null&&(this.disposeData(o.real.dataId,n),this.disposeData(o.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:n,dtype:o,texShape:s,usage:a,isPacked:i,slice:u}=this.texData.get(e),p=u&&u.origDataId||e,l=this.dataRefCount.get(p);l>1?this.dataRefCount.set(p,l-1):(this.dataRefCount.delete(p),n!=null&&(this.numBytesInGPU-=this.computeBytes(s,o),this.textureManager.releaseTexture(n,s,a,i)));let m=this.texData.get(e);m.texture=null,m.texShape=null,m.isPacked=!1,m.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=Rae){return B().getBool("WEBGL_CPU_FORWARD")&&e.every(o=>this.texData.get(o.dataId).texture==null&&y.sizeFromShape(o.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){C.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let n=e.dataSync();return wae(e.shape,n)}packedUnaryOp(e,n,o){let s=new os(e.shape,n),a=this.compileAndRun(s,[e],o);return Mn().makeTensorFromTensorInfo(a)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let s=dI(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,s)}if(B().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ND,e.dtype);let n=new nn(e.shape,ND),o=this.compileAndRun(n,[e]);return Mn().makeTensorFromTensorInfo(o)}makeTensorInfo(e,n,o){let s;if(n==="string"&&o!=null&&o.length>0&&y.isString(o[0])){let a=o.map(i=>y.encodeString(i));s=this.write(a,e,n)}else s=this.write(o,e,n);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:n}}makeOutput(e,n,o){return Mn().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,o),this)}unpackTensor(e){let n=new bI(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){let n=new hI(e.shape),o=!0;return this.runWebGLProgram(n,[e],e.dtype,null,o)}packedReshape(e,n){let o=[ku(e.shape),...Su(e.shape)],s={dtype:e.dtype,shape:o,dataId:e.dataId},a=[ku(n),...Su(n)],i=new Rf(a,o),u=!0,p=[o],l=this.runWebGLProgram(i,[s],e.dtype,p,u);return{dataId:l.dataId,shape:n,dtype:l.dtype}}decode(e,n){let o=this.texData.get(e),{isPacked:s,shape:a,dtype:i}=o;if(n!=null){let d=y.sizeFromShape(a),f=n[0]*n[1]*4;y.assert(d<=f,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}let u=kg(a),p;s?p=new tI(u):p=new eI(u);let l=!0,m=[n??Tg(u)],c=this.runWebGLProgram(p,[{shape:u,dtype:i,dataId:e}],i,m,l,n);return{dtype:i,shape:a,dataId:c.dataId}}runWebGLProgram(e,n,o,s,a=!1,i){let u=this.makeTensorInfo(e.outputShape,o),p=this.texData.get(u.dataId);if(e.packedOutput&&(p.isPacked=!0),e.outPackingScheme===0){let T=i??Tg(e.outputShape);p.texShape=T.map(x=>x*2)}if(e.outTexUsage!=null&&(p.usage=e.outTexUsage),y.sizeFromShape(u.shape)===0)return p.values=y.getTypedArrayFromDType(u.dtype,0),u;let l=[],m=n.map(T=>{if(T.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(T.dataId);if(x.texture==null){if(!e.packedInputs&&y.sizeFromShape(T.shape)<=B().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:T.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=T.shape)}if(this.uploadToGPU(T.dataId),!!x.isPacked!=!!e.packedInputs)T=x.isPacked?this.unpackTensor(T):this.packTensor(T),l.push(T),x=this.texData.get(T.dataId);else if(x.isPacked&&!Rp(x.shape,T.shape)){let I=T,k=T.shape;T.shape=x.shape,T=this.packedReshape(T,k),l.push(T),x=this.texData.get(T.dataId),I.shape=k}return{shape:T.shape,texData:x,isUniform:!1}});this.uploadToGPU(u.dataId);let c={shape:u.shape,texData:p,isUniform:!1},d=EO(e,m,c),f=this.getAndSaveBinary(d,()=>PO(this.gpgpu,e,m,c)),h=this.activeTimers!=null,g;h&&(g=this.startTimer()),B().get("ENGINE_COMPILE_ONLY")||MO(this.gpgpu,f,m,c,s),l.forEach(T=>this.disposeIntermediateTensorInfo(T)),h&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));let b=B().get("WEBGL_FLUSH_THRESHOLD");if(b>0){let T=y.now();T-this.lastGlFlushTime>b&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=T)}if(!B().getBool("WEBGL_LAZILY_UNPACK")&&p.isPacked&&a===!1){let T=this.unpackTensor(u);return this.disposeIntermediateTensorInfo(u),T}return u}compileAndRun(e,n,o,s,a=!1){return o=o||n[0].dtype,this.runWebGLProgram(e,n,o,s,a)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(B().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=U(()=>{if(!B().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=B().getBool("DEBUG");B().set("DEBUG",!1);let n=this.abs(ce(1e-8)).dataSync()[0];if(B().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Nae:Dae}uploadToGPU(e){let n=this.texData.get(e),{shape:o,dtype:s,values:a,texture:i,usage:u,isPacked:p}=n;if(i!=null)return;let l=this.activeTimers!=null,m;l&&(m=y.now());let c=n.texShape;if(c==null&&(c=rD(o,p),n.texShape=c),a!=null){let d=kg(o),f,h=c[1],g=c[0],b=a instanceof Uint8Array||a instanceof Uint8ClampedArray;(p||!b)&&([h,g]=Mi(c[0],c[1])),p?f=new aI(d,b):f=new sI(d,b);let T=b?[g,h]:c,x=this.makeTensorInfo(T,s),I=this.texData.get(x.dataId);b?I.usage=2:I.usage=1,I.texShape=T,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),h,g,a);let k=[[g,h]],w=!0,R=this.runWebGLProgram(f,[x],s,k,w),P=this.texData.get(R.dataId);n.texShape=P.texShape,n.isPacked=P.isPacked,n.usage=P.usage,B().get("ENGINE_COMPILE_ONLY")?this.disposeData(R.dataId):(n.texture=P.texture,n.values=null,this.texData.delete(R.dataId)),this.disposeIntermediateTensorInfo(x),l&&(this.uploadWaitMs+=y.now()-m)}else{let d=this.acquireTexture(c,u,s,p);n.texture=d}}convertAndCacheOnCPU(e,n){let o=this.texData.get(e),{dtype:s}=o;return this.releaseGPUData(e),n!=null&&(o.values=Eae(n,s)),o.values}acquireTexture(e,n,o,s){if(this.numBytesInGPU+=this.computeBytes(e,o),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let a=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${a} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,s)}computeBytes(e,n){return e[0]*e[1]*y.bytesPerElement(n)}checkCompileCompletion(){for(let[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){let e=[];if(this.gpgpu.parallelCompilationExtension){for(let[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(let[,n]of Object.entries(this.binaryCache)){let o=new Promise(s=>{try{this.checkCompletion_(n),s(!0)}catch(a){throw a}});e.push(o)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Bh(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(jx(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(let[,e]of Object.entries(this.binaryCache)){let{uniformLocations:n,customUniformLocations:o,infLoc:s,nanLoc:a,inShapesLocations:i,inTexShapesLocations:u,outShapeLocation:p,outShapeStridesLocation:l,outTexShapeLocation:m}=pD(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=n,e.customUniformLocations=o,e.infLoc=s,e.nanLoc=a,e.inShapesLocations=i,e.inTexShapesLocations=u,e.outShapeLocation=p,e.outShapeStridesLocation=l,e.outTexShapeLocation=m}}},Pf=DD;Pf.nextDataId=0;function Eae(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<e.length;++n)e[n]=Math.round(r[n]);return e}else throw new Error(`Unknown dtype ${t}`)}var _ae="0.0.0";function Bz(){B().set("WEBGL_FORCE_F16_TEXTURES",!0)}Ju.isBrowser()&&rp("webgl",()=>new Pf,2);var Z8t={forceHalfFloat:Bz};var TI=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var ss=class{constructor(t,e,n){this.variableNames=["A","B"];this.outputShape=C.assertAndGetBroadcastShape(e,n),this.enableShapeUniforms=Ft(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var Pp=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Zs=class{constructor(t,e,n,o=!1){this.variableNames=["A","B"];this.supportsBroadcasting=!0;this.packedInputs=!0;this.packedOutput=!0;this.outputShape=C.assertAndGetBroadcastShape(e,n);let s=this.outputShape.length;this.enableShapeUniforms=Ft(s);let a="";if(o)if(s===0||y.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Ve(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=ar("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function ir(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var Oz={kernelName:Vn,backendName:"webgl",kernelFunc:ir};function On(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),a=e.texData.get(s.dataId),i=ir({inputs:{x:n},backend:e}),u=ir({inputs:{x:o},backend:e});return a.complexTensorInfos={real:i,imag:u},s}var zz={kernelName:_u,backendName:"webgl",kernelFunc:On};var FD="return (a < 0.) ? b * a : a;",RD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Lae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,a=e.makeTensorInfo([],"float32",y.createScalarValue(s,"float32")),i=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zs(RD,o.shape,a.shape):new ss(FD,o.shape,a.shape),u=e.runWebGLProgram(i,[o,a],"float32");return e.disposeIntermediateTensorInfo(a),u}var Gz={kernelName:So,backendName:"webgl",kernelFunc:Lae};var PD="return (a < 0.) ? b * a : a;",MD=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function $ae(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zs(MD,n.shape,o.shape):new ss(PD,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],"float32")}var Uz={kernelName:Lo,backendName:"webgl",kernelFunc:$ae};var Qs="if (isnan(x)) return x;",Wz=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,Kz=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function Ae({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:o,backend:s})=>{let{x:a}=o,i=s,u=n||a.dtype;if(i.shouldExecuteOnCPU([a])&&e!=null){let m=i.texData.get(a.dataId),c=e(m.values,u);return i.makeTensorInfo(a.shape,u,c)}let p=B().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,l;return p?l=new os(a.shape,t):l=new nn(a.shape,r),i.runWebGLProgram(l,[a],u)}}function ft({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:a,backend:i})=>{let{a:u,b:p}=a,l=i;if(n&&u.dtype==="complex64"){let f=l.texData.get(u.dataId),h=l.texData.get(p.dataId),[g,b]=[[f.complexTensorInfos.real,h.complexTensorInfos.real],[f.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(x=>{let[I,k]=x,w={dataId:I.dataId,dtype:I.dtype,shape:u.shape},R={dataId:k.dataId,dtype:k.dtype,shape:p.shape},P=new ss(r,u.shape,p.shape);return l.runWebGLProgram(P,[w,R],$t(I.dtype,k.dtype))}),T=On({inputs:{real:g,imag:b},backend:l});return l.disposeIntermediateTensorInfo(g),l.disposeIntermediateTensorInfo(b),T}let m=s||$t(u.dtype,p.dtype);if((u.dtype==="string"||p.dtype==="string"||l.shouldExecuteOnCPU([u,p]))&&o!=null){let f=l.texData.get(u.dataId).values,h=l.texData.get(p.dataId).values,g=u.dtype==="string"?C.fromUint8ToStringArray(f):f,b=u.dtype==="string"?C.fromUint8ToStringArray(h):h,[T,x]=o(u.shape,p.shape,g,b,m),I=l.makeTensorInfo(x,m),k=l.texData.get(I.dataId);return k.values=T,I}let c=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,d;return c?d=new Zs(t,u.shape,p.shape,e):d=new ss(r,u.shape,p.shape),l.runWebGLProgram(d,[u,p],m)}}function vu(r,t=!1){if(r==="linear")return t?Mz:wz;if(r==="relu")return t?_z:Dz;if(r==="elu")return t?Ez:Nz;if(r==="relu6")return t?Lz:Fz;if(r==="prelu")return t?MD:PD;if(r==="leakyrelu")return t?RD:FD;if(r==="sigmoid")return t?$z:Rz;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var Mf=class{constructor(t,e,n,o=!1,s=!1,a=!1,i=null,u=!1,p=!1){this.variableNames=["matrixA","matrixB"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=n,this.enableShapeUniforms=Ft(this.outputShape.length);let l=o?t[1]:t[2],m=Math.ceil(l/2),c=o?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",f=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",b="";i&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${i}
        }`:p?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${i}
        }`:g=`vec4 activation(vec4 x) {
          ${i}
        }`,b="result = activation(result);");let T=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),p&&this.variableNames.push("leakyreluAlpha");let x="rc.x",I="rc.x";t[0]<e[0]?x=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(I=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${m}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${m}; i++) {
          int batchA = ${x};
          int batchB = ${I};
          vec4 a = getMatrixA(batchA, ${c});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${h[0]});
          result += (${f[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${T}

        ${b}

        setOutput(result);
      }
    `}};var ED={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},vg=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=C.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var Vz="return a * b;";function Ag(r){let{inputs:t,backend:e}=r,{a:n,b:o}=t,s=C.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let i=e.texData.get(n.dataId),u=e.texData.get(o.dataId),p=new vg(ED.REAL,n.shape,o.shape),l=new vg(ED.IMAG,n.shape,o.shape),m=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:n.shape},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],c=e.runWebGLProgram(p,m,"float32"),d=e.runWebGLProgram(l,m,"float32"),f=On({inputs:{real:c,imag:d},backend:e});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),f}if(e.shouldExecuteOnCPU([n,o])){let i=e.texData.get(n.dataId),u=e.texData.get(o.dataId),[p,l]=rz(n.shape,o.shape,i.values,u.values,s),m=e.makeTensorInfo(l,s),c=e.texData.get(m.dataId);return c.values=p,m}let a;return B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Zs(Vz,n.shape,o.shape):a=new ss(Vz,n.shape,o.shape),e.runWebGLProgram(a,[n,o],s)}var Hz={kernelName:Mo,backendName:"webgl",kernelFunc:Ag};function qz(r,t,e){let n=[ku(r.shape),...Su(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[ku(t),...Su(t)],a=new Rf(s,n),i=!0,u=[n],p=e.runWebGLProgram(a,[o],r.dtype,u,i);return{dataId:p.dataId,shape:t,dtype:p.dtype}}function ue(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{shape:s}=n,a=e,i=y.sizeFromShape(o.shape),u=y.inferFromImplicitShape(s,i),p=y.sizeFromShape(u);y.assert(i===p,()=>`The new shape (${u}) has ${p} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`);let l=a.texData.get(o.dataId);return l.isPacked&&!Rp(o.shape,u)&&!(l.texture!==null&&Rp(l.shape,u))?qz(o,u,a):(a.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var jz={kernelName:ys,backendName:"webgl",kernelFunc:ue};var wg=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:a}=t;this.outputShape=[o,a];let i=Math.floor(n/4)*4,u=n%4,p="sumValue += dot(values, ones);";if(e!=null){let m=1/e;p=`sumValue += dot(values * ${y.isInt(m)?m.toPrecision(2):m}, ones);`}let l="";s%n>0&&(l=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${l}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${i}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${i};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${p}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${p}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${p}
        }
        setOutput(sumValue);
      }
    `}};var xI=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:a}=t;this.outputShape=[o,a];let i="0.0",u="";e==="prod"?i="1.0":e==="min"?(i="1.0 / 1e-20",u="min"):e==="max"&&(i="-1.0 / 1e-20",u="max");let p=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?p="sumValue":e==="prod"?p="prodValue":e==="all"?p="allValue":e==="any"&&(p="anyValue");let l=Math.floor(n/4)*4,m=n%4,c=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${e==="min"} || ${e==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";e==="all"?(i="1.0",c=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):e==="any"&&(i="0.0",c=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${i};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${i});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${l};
        if (${m===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${m===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${c}
        } else if (${m===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${c}
        }
        setOutput(${p});
      }
    `}};function Oae(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],n=C.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function eo(r,t,e,n){let o=Oae(r.shape),s=r;for(let a=0;a<o.length;a++){let{inSize:i,windowSize:u,outSize:p}=o[a],l,m;e==="mean"?l=a===0?new wg({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:p},i):new wg({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:p}):l=new xI({windowSize:u,inSize:i,batchSize:r.shape[0],outSize:p},e),m=s,s=n.runWebGLProgram(l,[s],t),m.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(m)}return s}var II=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let a=0;a<n.length;a++)n[a]=t[e[a]];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=zae(e);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function zae(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let o=0;o<r.length;o++)n[r[o]]=e[o];return n.join()}var CI=class{constructor(t,e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;let n=new Array(t.length);for(let l=0;l<n.length;l++)n[l]=t[e[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=Ve(this.rank),s=wD("rc",this.rank),a=new Array(this.rank);for(let l=0;l<e.length;l++)a[e[l]]=s[l];let i=`vec2(${a.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,p=`getChannel(getA(${a.join()}), ${i})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${p};
      if(${u}) {
        result[1] = ${p};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${p};
        if(${u}) {
          result[3] = ${p};
        }
      }
      setOutput(result);
    }
    `}};function Mp(r,t,e){let n=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new CI(r.shape,t):new II(r.shape,t);return e.runWebGLProgram(n,[r],r.dtype)}function Xz(r,t,e,n){let o=t,s=r.shape.length,a=y.parseAxisParam(o,r.shape),i=a,u=C.getAxesPermutation(i,s),p=u!=null,l=r;p&&(l=Mp(r,u,n),i=C.getInnerMostAxes(i.length,s)),C.assertAxesAreInnerMostDims("sum",i,s);let[m,c]=C.computeOutAndReduceShapes(l.shape,i),d=m;e&&(d=C.expandShapeToKeepDim(m,a));let f=y.sizeFromShape(c),g=y.sizeFromShape(r.shape)/f,b=ue({inputs:{x:l},attrs:{shape:[g,f]},backend:n}),T=ou(r.dtype),x=eo(b,T,"sum",n),I=ue({inputs:{x},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(x),p&&n.disposeIntermediateTensorInfo(l),I}function tm(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;return Xz(o,s,a,e)}var Yz={kernelName:Ho,backendName:"webgl",kernelFunc:tm};function Ht(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,a=e,i=o.shape.length,u=new Array(i);for(let l=0;l<u.length;l++)u[l]=o.shape[s[l]];let p;if(a.shouldExecuteOnCPU([o])){let m=a.texData.get(o.dataId).values,c=Jl(m,o.shape,o.dtype,s,u);p=a.makeTensorInfo(u,o.dtype);let d=a.texData.get(p.dataId);d.values=c}else p=Mp(o,s,a);return p}var Zz={kernelName:Fn,backendName:"webgl",kernelFunc:Ht};var _D=1e3;function rm({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let p=r.shape.length,l=t.shape.length,m=e?r.shape[p-2]:r.shape[p-1],c=n?t.shape[l-1]:t.shape[l-2],d=e?r.shape[p-1]:r.shape[p-2],f=n?t.shape[l-2]:t.shape[l-1],h=r.shape.slice(0,-2),g=t.shape.slice(0,-2),b=y.sizeFromShape(h),T=y.sizeFromShape(g),I=Nr.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([d,f]);y.assert(m===c,()=>`Error in matMul: inner shapes (${m}) and (${c}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let k=e?[b,m,d]:[b,d,m],w=n?[T,f,c]:[T,c,f],R=ue({inputs:{x:r},backend:o,attrs:{shape:k}}),P=ue({inputs:{x:t},backend:o,attrs:{shape:w}}),M=[R,P],L=Math.max(b,T),z=e?R.shape[1]:R.shape[2],W=s!=null,V=a!=null,j=u==="leakyrelu",H=u!=null?vu(u,!0):null,X=W||V||j||H!=null,ee;if((d===1||f===1)&&z>_D&&X===!1){let ne=R,se=P;e&&(ne=Ht({inputs:{x:R},backend:o,attrs:{perm:[0,2,1]}}),M.push(ne)),n&&(se=Ht({inputs:{x:P},backend:o,attrs:{perm:[0,2,1]}}),M.push(se));let ie=f!==1,pe=f===1,ae=ne;ie&&(ae=ue({inputs:{x:ne},backend:o,attrs:{shape:[L,z,1]}}),M.push(ae));let ye=f===1?2:1,fe=se;pe&&(fe=ue({inputs:{x:se},backend:o,attrs:{shape:[L,1,z]}}),M.push(fe));let Ce=Ag({inputs:{a:ae,b:fe},backend:o});ee=tm({inputs:{x:Ce},backend:o,attrs:{axis:ye,keepDims:!0}}),M.push(Ce)}else{let ne=$t(r.dtype,t.dtype),se=new Mf(k,w,[L,d,f],e,n,W,H,V,j),ie=[R,P];if(s!=null&&ie.push(s),V&&ie.push(a),j){let pe=o.makeTensorInfo([],"float32",y.createScalarValue(i,"float32"));ie.push(pe),M.push(pe)}ee=o.runWebGLProgram(se,ie,ne)}let q=ue({inputs:{x:ee},backend:o,attrs:{shape:I}});M.push(ee);for(let ne of M)o.disposeIntermediateTensorInfo(ne);return q}function Gae(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=t,{transposeA:u,transposeB:p,activation:l,leakyreluAlpha:m}=n;return rm({a:o,b:s,transposeA:u,transposeB:p,backend:e,bias:a,preluActivationWeights:i,leakyreluAlpha:m,activation:l})}var Qz={kernelName:As,backendName:"webgl",kernelFunc:Gae};var Jz="return abs(x);";function Uae(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=e.texData.get(n.dataId),a=dI(s.values);return e.makeTensorInfo(n.shape,n.dtype,a)}let o;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new os(n.shape,Jz):o=new nn(n.shape,Jz),e.runWebGLProgram(o,[n],n.dtype)}var e3={kernelName:ls,backendName:"webgl",kernelFunc:Uae};var Wae=Ir+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Kae=Ae({opSnippet:Wae}),t3={kernelName:Li,backendName:"webgl",kernelFunc:Kae};var Vae=Ir+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Hae=Ae({opSnippet:Vae}),r3={kernelName:$i,backendName:"webgl",kernelFunc:Hae};var n3="return a + b;",qae=ft({opSnippet:n3,packedOpSnippet:n3,supportsComplex:!0,cpuKernelImpl:LO}),o3={kernelName:Nn,backendName:"webgl",kernelFunc:qae};var kI=class{constructor(t,e){this.outputShape=[];this.outputShape=t,this.variableNames=e.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var SI=class{constructor(t,e){this.outputShape=[];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=t,this.variableNames=e.map((s,a)=>`T${a}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function vI(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return ir({inputs:{x:n[0]},backend:e});if(n.length>B().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),p=vI({inputs:n.slice(0,u),backend:e}),l=vI({inputs:n.slice(u),backend:e});return vI({inputs:[p,l],backend:e})}let o=n.map(u=>u.dtype).reduce((u,p)=>$t(u,p)),s=n.map(u=>u.shape),i=B().getBool("WEBGL_PACK")?new SI(n[0].shape,s):new kI(n[0].shape,s);return e.runWebGLProgram(i,n,o)}var s3={kernelName:so,backendName:"webgl",kernelFunc:vI};function jae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),p=u,l=C.getAxesPermutation(p,i),m=o;l!=null&&(m=Ht({inputs:{x:o},backend:e,attrs:{perm:l}}),p=C.getInnerMostAxes(p.length,i)),C.assertAxesAreInnerMostDims("all",p,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,p),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:e,attrs:{shape:[-1,f]}}),g=eo(h,h.dtype,"all",e),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:e,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),l!=null&&e.disposeIntermediateTensorInfo(m),b}var a3={kernelName:Bi,backendName:"webgl",kernelFunc:jae};function Xae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),p=u,l=C.getAxesPermutation(p,i),m=o;l!=null&&(m=Ht({inputs:{x:o},backend:e,attrs:{perm:l}}),p=C.getInnerMostAxes(p.length,i)),C.assertAxesAreInnerMostDims("any",p,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,p),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:e,attrs:{shape:[-1,f]}}),g=eo(h,h.dtype,"any",e),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:e,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),l!=null&&e.disposeIntermediateTensorInfo(m),b}var i3={kernelName:Oi,backendName:"webgl",kernelFunc:Xae};var AI=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:a}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];let i=e==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${i} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var wI=class{constructor(t,e,n,o){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;y.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=t[t.length-1],a=Math.ceil(s/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),o||this.variableNames.push("bestIndicesA");let i=this.outputShape,u=i.length,p=Ve(u),l=ar("coords",u),m,c;if(a===1){c=u+1;let P=Ve(c);m=`
        ${P} sourceLocR = ${P}(${l.join()}, 0);
        ++${l[u-1]};
        ${P} sourceLocG = ${P}(${l.join()}, 0);
        ++${l[u-2]};
        ${P} sourceLocA = ${P}(${l.join()}, 0);
        --${l[u-1]};
        ${P} sourceLocB = ${P}(${l.join()}, 0);
        --${l[u-2]};`}else c=u,m=`
        ${p} sourceLocR = coords;
        ++${l[u-1]};
        ${p} sourceLocG = coords;
        ++${l[u-2]};
        ${p} sourceLocA = coords;
        --${l[u-1]};
        ${p} sourceLocB = coords;
        --${l[u-2]};`;let d=["x","y","z","w","u","v"].slice(0,c),f="."+d[c-1],h=d.map(P=>"int "+P),g=ar("sourceLocR",c-1).concat("inIdx.r"),b=ar("sourceLocG",c-1).concat("inIdx.g"),T=ar("sourceLocB",c-1).concat("inIdx.b"),x=ar("sourceLocA",c-1).concat("inIdx.a"),I=n==="max"?"greaterThan":"lessThan",k=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${T.join()}),
                             getBestIndicesAChannel(${x.join()})));`,w=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${b.join()}) : 0.,
            hasNextRow ? getAChannel(${T.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,R=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${R}
      void main() {
        ${p} coords = getOutputCoords();
        bool hasNextCol = ${l[u-1]} < ${i[u-1]-1};
        bool hasNextRow = ${l[u-2]} < ${i[u-2]-1};
        ${m}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${w};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${k}
          vec4 candidate = ${w};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${I}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function u3(r,t,e,n=null){let o=t.shape[0],s=t.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let a=C.computeOptimalWindowSize(s),i={windowSize:a,inSize:s,batchSize:o,outSize:Math.ceil(s/a)},u=new AI(i,e,n==null),p=[t];n!=null&&p.push(n);let l=r.runWebGLProgram(u,p,"int32");if(l.shape[1]===1)return l;let m=u3(r,t,e,l);return r.disposeIntermediateTensorInfo(l),m}function p3(r,t,e,n=null){let o=n!=null?n.shape:t.shape,s=o[o.length-1],a=C.computeOptimalWindowSize(s),i=new wI(o,a,e,n==null),u=n==null?[t]:[t,n],p=r.runWebGLProgram(i,u,"int32");if(p.shape.length===t.shape.length){let l=p3(r,t,e,p);return r.disposeIntermediateTensorInfo(p),l}return p}function NI(r,t,e,n){let o=[e];if(C.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,t.shape.length),!B().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let s=[],a=r.texData.get(t.dataId),i=a!==null&&a.isPacked,u=t;i&&(u=r.unpackTensor(t),s.push(u));let[p,l]=C.computeOutAndReduceShapes(u.shape,o),m=y.sizeFromShape(l),c=ue({inputs:{x:u},backend:r,attrs:{shape:[-1,m]}});s.push(c);let d=u3(r,c,n);s.push(d);let f=ue({inputs:{x:d},backend:r,attrs:{shape:p}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),f}return p3(r,t,n)}function Yae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,p=[];i!=null&&(u=Ht({inputs:{x:o},backend:e,attrs:{perm:i}}),p.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let l=NI(e,u,a[0],"max");return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),l}var l3={kernelName:ao,backendName:"webgl",kernelFunc:Yae};function Zae(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,p=[];i!=null&&(u=Ht({inputs:{x:o},backend:e,attrs:{perm:i}}),p.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let l=NI(e,u,a[0],"min");return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),l}var m3={kernelName:di,backendName:"webgl",kernelFunc:Zae};var Qae=Ir+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Jae=Ae({opSnippet:Qae}),c3={kernelName:zi,backendName:"webgl",kernelFunc:Jae};var eie=Ir+"return log(x + sqrt(x * x + 1.0));",tie=Ae({opSnippet:eie}),d3={kernelName:Gi,backendName:"webgl",kernelFunc:tie};var rie=Ir+`
  return atan(x);
`,nie=Ae({opSnippet:rie}),f3={kernelName:Ui,backendName:"webgl",kernelFunc:nie};var oie=Wz+`
  return atan(a, b);
`,sie=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Kz+`
  return result;
`,aie=ft({opSnippet:oie,packedOpSnippet:sie}),h3={kernelName:fa,backendName:"webgl",kernelFunc:aie};var iie=Ir+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,uie=Ae({opSnippet:iie}),g3={kernelName:Wi,backendName:"webgl",kernelFunc:uie};var ai=class{constructor(t,e,n,o=!1,s=!1){this.variableNames=["x"];if(e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,i=t.strideHeight,u=t.strideWidth,p=t.dilationHeight,l=t.dilationWidth,m=t.effectiveFilterHeight,c=t.effectiveFilterWidth,d=t.padInfo.top,f=t.padInfo.left;this.outputShape=t.outShape;let h=e==="avg",g=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,b=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,T="0.0";if(h||(T="-1.0 / 1e-20"),n){let P=">=";this.userCode=`
        const ivec2 strides = ivec2(${i}, ${u});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${m};
              wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${c};
                wC += ${l}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${P} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:b:`wR * ${c} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let x="max",I=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(I="avgValue / count");let k=Math.floor(a/4)*4,w=a%4,R=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${u});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${T};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${T});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${m};
            wR += ${p}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${k}; wC += 4) {
            int xC = xCCorner + wC * ${l};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              getValue(batch, xR, xC + 3 * ${l}, d)
            );

            ${R}
          }

          int xC = xCCorner + ${k};
          if (${w===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${w===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              initializationValue,
              initializationValue
            );

            ${R}
          } else if (${w===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${l}, d),
              getValue(batch, xR, xC + 2 * ${l}, d),
              initializationValue
            );

            ${R}
          }
        }
        setOutput(${I});
      }
    `}},Ep=class{constructor(t,e,n,o=!1,s=!1){this.variableNames=["x"];if(e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,i=t.strideDepth,u=t.strideHeight,p=t.strideWidth,l=t.dilationDepth,m=t.dilationHeight,c=t.dilationWidth,d=t.effectiveFilterDepth,f=t.effectiveFilterHeight,h=t.effectiveFilterWidth,g=t.padInfo.front,b=t.padInfo.top,T=t.padInfo.left;this.outputShape=t.outShape;let x=e==="avg",I="0.0";if(x||(I="-1.0 / 1e-20"),n){let L=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${i}, ${u}, ${p});
        const ivec3 pads = ivec3(${g}, ${b}, ${T});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${l}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${m}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${c}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${L} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${f} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let k="max",w=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(w="avgValue / count");let R=Math.floor(a/4)*4,P=a%4,M=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${k}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${i}, ${u}, ${p});
      const ivec3 pads = ivec3(${g}, ${b}, ${T});
      const float initializationValue = ${I};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${I});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${m}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${R}; wC += 4) {
              int xC = xCCorner + wC * ${c};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                getValue(batch, xD, xR, xC + 3 * ${c}, ch)
              );

              ${M}
            }

            int xC = xCCorner + ${R};
            if (${P===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${P===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                initializationValue,
                initializationValue
              );

              ${M}
            } else if (${P===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${c}, ch),
                getValue(batch, xD, xR, xC + 2 * ${c}, ch),
                initializationValue
              );

              ${M}
            }
          }
          setOutput(${w});
        }
      }
    `}};function pie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;oi(o,"avgPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,p=1;y.assert(C.eitherStridesOrDilationsAreOne(a,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let l=C.computePool2DInfo(o.shape,s,a,p,i,u);if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))return ir({inputs:{x:o},backend:e});let m=new ai(l,"avg",!1);return e.runWebGLProgram(m,[o],"float32")}var b3={kernelName:io,backendName:"webgl",kernelFunc:pie};function lie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:u,dataFormat:p}=n,l=[1,1,1],m=C.computePool3DInfo(o.shape,s,a,l,i,u,p),c=new Ep(m,"avg",!1);return e.runWebGLProgram(c,[o],"float32")}var y3={kernelName:Eu,backendName:"webgl",kernelFunc:lie};var DI=class{constructor(t){this.variableNames=["dy"];this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,a=t.dilationHeight,i=t.dilationWidth,u=t.effectiveFilterHeight,p=t.effectiveFilterWidth,l=u-1-t.padInfo.top,m=p-1-t.padInfo.left,c=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${l}, ${m});
      const float avgMultiplier = float(${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${p};
            wC+= ${i}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},FI=class{constructor(t){this.variableNames=["dy"];this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,a=t.strideHeight,i=t.strideWidth,u=t.dilationDepth,p=t.dilationHeight,l=t.dilationWidth,m=t.effectiveFilterDepth,c=t.effectiveFilterHeight,d=t.effectiveFilterWidth,f=m-1-t.padInfo.front,h=c-1-t.padInfo.top,g=d-1-t.padInfo.left,b=1/(e*n*o);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${h}, ${g});
      const float avgMultiplier = float(${b});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${p}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function mie(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,a=s,{filterSize:i,strides:u,pad:p,dimRoundingMode:l}=n,m=[1,1,1],c=C.computePool3DInfo(a.shape,i,u,m,p,l),d=new FI(c);return e.runWebGLProgram(d,[o],a.dtype)}var T3={kernelName:Mm,backendName:"webgl",kernelFunc:mie};function cie(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,a=s;oi([o,s],"avgPoolGrad");let{filterSize:i,strides:u,pad:p}=n,l=C.computePool2DInfo(a.shape,i,u,1,p),m=new DI(l);return e.runWebGLProgram(m,[o],a.dtype)}var x3={kernelName:Pm,backendName:"webgl",kernelFunc:cie};function die(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:a,transposeB:i}=n;return rm({a:o,b:s,transposeA:a,transposeB:i,backend:e})}var I3={kernelName:uo,backendName:"webgl",kernelFunc:die};var RI=class{constructor(t,e,n,o,s,a){this.outputShape=[];this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(t,e),C.assertAndGetBroadcastShape(t,n);let i="0.0";o!=null&&(C.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="1.0";s!=null&&(C.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${i};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var PI=class{constructor(t,e,n,o,s,a){this.packedInputs=!0;this.packedOutput=!0;this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(t,e),C.assertAndGetBroadcastShape(t,n);let i="vec4(0.0)";o!=null&&(C.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset"),i="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(C.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${i};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var fie=({inputs:r,backend:t,attrs:e})=>{let{x:n,mean:o,variance:s,offset:a,scale:i}=r;y.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),y.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),y.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);let p=[n,o,s],l=null;a!=null&&(l=a.shape,p.push(a));let m=null;i!=null&&(m=i.shape,p.push(i));let c=B().getBool("WEBGL_PACK_NORMALIZATION")?new PI(n.shape,o.shape,s.shape,l,m,u):new RI(n.shape,o.shape,s.shape,l,m,u);return t.runWebGLProgram(c,p,p[0].dtype)},C3={kernelName:Co,backendName:"webgl",kernelFunc:fie};var MI=class{constructor(t){this.variableNames=["source"];this.outputShape=t,this.rank=t.length;let e=Ve(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=hie(this.rank),o,s=t.map((a,i)=>`sourceLoc.${LD[i]} = start[${i}] + coords.${LD[i]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},LD=["x","y","z","w","u","v"];function hie(r){if(r===1)return"sourceLoc";if(r<=6)return LD.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var EI=class{constructor(t){this.variableNames=["source"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=t,this.rank=t.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let e=Ve(this.rank),n=ar("coords",this.rank),o=ar("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,a=`getChannel(getSource(${o.join()}), ${s})`,i=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${a};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${a};
        }
      }
    `,p=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((l,m)=>`start[${m}]`).join()});`:t.map((l,m)=>`${o[m]} = ${n[m]} + start[${m}];`).join(`
`);this.userCode=`
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${p}
        vec4 result = vec4(0.);
        ${i}
        ${u}
        setOutput(result);
      }
    `}};function gie(r,t,e,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(e,r.dtype),a=n.texData.get(s.dataId);Object.assign(a,o),a.refCount=1,a.shape=e,a.dtype=r.dtype;let i=It.computeFlatOffset(t,y.computeStrides(r.shape));o.slice&&(i+=o.slice.flatOffset),a.slice={flatOffset:i,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,u+1),s}function ii(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:a}=n,[i,u]=It.parseSliceParams(o,s,a);if(It.assertParamsValid(o,i,u),y.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);if(e.shouldExecuteOnCPU([o])||o.dtype==="string"){let m=e.texData.get(o.dataId),c=mz(m.values,i,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,c)}let{isPacked:p}=e.texData.get(o.dataId),l=It.isSliceContinous(o.shape,i,u);if(p||!l){let m=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new EI(u):new MI(u),c=[i];return e.runWebGLProgram(m,[o],o.dtype,c)}return e.uploadToGPU(o.dataId),gie(o,i,u,e)}var k3={kernelName:xs,backendName:"webgl",kernelFunc:ii};var bie=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:a}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((T,x)=>T*x),u=C.getReshaped(o.shape,s,i),p=C.getPermuted(u.length,s.length),l=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(l,a,s.length),d=[],f=ue({inputs:{x:o},backend:e,attrs:{shape:u}}),h=Ht({inputs:{x:f},backend:e,attrs:{perm:p}}),g=ue({inputs:{x:h},backend:e,attrs:{shape:l}}),b=ii({inputs:{x:g},backend:e,attrs:{begin:m,size:c}});return d.push(f),d.push(h),d.push(g),d.forEach(T=>e.disposeIntermediateTensorInfo(T)),b},S3={kernelName:ms,backendName:"webgl",kernelFunc:bie};function yie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:a}=n,i=e.readSync(o.dataId),u=e.readSync(s.dataId),p=cI(i,u,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,p)}var v3={kernelName:Em,backendName:"webgl",kernelFunc:yie};function Tie(r){let{inputs:t,backend:e}=r,{s0:n,s1:o}=t,s=e.readSync(n.dataId),a=e.readSync(o.dataId),i=C.assertAndGetBroadcastShape(Array.from(s),Array.from(a));return e.makeTensorInfo([i.length],"int32",Int32Array.from(i))}var A3={kernelName:_m,backendName:"webgl",kernelFunc:Tie};var xie="return float(a != b);",$D=ft({opSnippet:xie,cpuKernelImpl:oz,dtype:"bool"}),w3={kernelName:Na,backendName:"webgl",kernelFunc:$D};function Au(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return ir({inputs:{x:o.complexTensorInfos.real},backend:e})}var N3={kernelName:Wu,backendName:"webgl",kernelFunc:Au};var Iie="return float(int(x));";function D3(r,t){let e=new nn(r.shape,Iie),n=t.runWebGLProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function BD(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return ir({inputs:{x:o},backend:e});let a=Ct(o.shape),i=BD({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=On({inputs:{real:i,imag:a},backend:e});return a.dispose(),e.disposeIntermediateTensorInfo(i),u}if(o.dtype==="complex64"){let a=Au({inputs:{input:o},backend:e}),i=BD({inputs:{x:a},backend:e,attrs:{dtype:s}});return e.disposeIntermediateTensorInfo(a),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=ir({inputs:{x:o},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let a=e.texData.get(o.dataId).values,[i,u,p]=BO(a,o.shape,o.dtype,s);return e.makeTensorInfo(i,u,p)}if(s==="int32")return D3(o,e);if(s==="bool"){let a=e.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),u=$D({inputs:{a:o,b:a},backend:e});return e.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var F3={kernelName:Wn,backendName:"webgl",kernelFunc:BD};var R3="return ceil(x);",Cie=Ae({opSnippet:R3,packedOpSnippet:R3,cpuKernelImpl:OO}),P3={kernelName:po,backendName:"webgl",kernelFunc:Cie};var _I=class{constructor(t){this.variableNames=["A"];this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=t,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var LI=class{constructor(t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=t,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function kie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:a}=n,i;B().getBool("WEBGL_PACK_CLIP")?i=new LI(o.shape):i=new _I(o.shape);let u=[[s],[a]];return e.runWebGLProgram(i,[o],o.dtype,u)}var M3={kernelName:Kn,backendName:"webgl",kernelFunc:kie};var $I=class{constructor(t){this.variableNames=["real","imag"];this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function E3(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function Sie(r){let{inputs:t,backend:e}=r,{x:n}=t,o=e.texData.get(n.dataId),s=new $I(n.shape),a=[E3(n,o.complexTensorInfos.real),E3(n,o.complexTensorInfos.imag)];return e.runWebGLProgram(s,a,a[0].dtype)}var _3={kernelName:Lu,backendName:"webgl",kernelFunc:Sie};var BI=class{constructor(t){this.outputShape=[];this.outputShape=C.computeOutShape(t,1),this.variableNames=t.map((a,i)=>`T${i}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+t[a][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<e.length;a++){let i=e[a-1];n.push(`else if (yC < ${e[a]}) setOutput(getT${a}(yR, yC-${i}));`)}let o=e.length,s=e[e.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var zI=class{constructor(t,e){this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];this.outputShape=C.computeOutShape(t,e);let n=this.outputShape,o=n.length,s=Ve(o),a=ar("coords",o),i=["x","y","z","w","u","v"].slice(0,o);this.variableNames=t.map((h,g)=>`T${g}`);let u=new Array(t.length-1);u[0]=t[0][e];for(let h=1;h<u.length;h++)u[h]=u[h-1]+t[h][e];let p=i[e],l=i.slice(-2),m=i.join(),c=`if (${p} < ${u[0]}) {
        return getChannel(
            getT0(${m}), vec2(${l.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];c+=`
        if (${p} < ${u[h]}  && ${p} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${OI(i,p,g)}),
            vec2(${OI(l,p,g)}));
        }`}let d=u.length,f=u[u.length-1];c+=`
        return getChannel(
          getT${d}(${OI(i,p,f)}),
          vec2(${OI(l,p,f)}));`,this.userCode=`
      float getValue(${i.map(h=>"int "+h)}) {
        ${c}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[o-1]} = ${a[o-1]} + 1;
        if (${a[o-1]} < ${n[o-1]}) {
          result.g = getValue(${a});
        }

        ${a[o-2]} = ${a[o-2]} + 1;
        if (${a[o-2]} < ${n[o-2]}) {
          result.a = getValue(${a});
        }

        ${a[o-1]} = ${a[o-1]} - 1;
        if (${a[o-2]} < ${n[o-2]} &&
            ${a[o-1]} < ${n[o-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function OI(r,t,e){let n=r.indexOf(t);return r.map((s,a)=>a===n?`${s} - ${e}`:s).join()}function nm(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.texData.get(n.dataId);return ir({inputs:{x:o.complexTensorInfos.imag},backend:e})}var L3={kernelName:zu,backendName:"webgl",kernelFunc:nm};function Ef(r,t,e){let n=r[0].dtype;if(n==="complex64"){let m=r.map(g=>Au({inputs:{input:g},backend:e})),c=r.map(g=>nm({inputs:{input:g},backend:e})),d=Ef(m,t,e),f=Ef(c,t,e),h=On({inputs:{real:d,imag:f},backend:e});return m.forEach(g=>e.disposeIntermediateTensorInfo(g)),c.forEach(g=>e.disposeIntermediateTensorInfo(g)),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),h}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let m=r.map(T=>{let x=y.sizeFromShape(T.shape.slice(t));return ue({inputs:{x:T},backend:e,attrs:{shape:[-1,x]}})}),c=m.map(T=>({vals:e.readSync(T.dataId),shape:T.shape})),d=C.computeOutShape(m.map(T=>T.shape),1),f=m[0].shape[0]===1,h=zO(c,d,n,f),g=C.computeOutShape(r.map(T=>T.shape),t),b=e.makeTensorInfo(g,n,h);return m.forEach(T=>e.disposeIntermediateTensorInfo(T)),b}let s=B().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>s){let m=[];for(let d=0;d<r.length;d+=s){let f=r.slice(d,d+s);m.push(Ef(f,t,e))}let c=Ef(m,t,e);for(let d of m)e.disposeIntermediateTensorInfo(d);return c}if(B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let m=new zI(r.map(c=>c.shape),t);return e.runWebGLProgram(m,r,n)}let{tensors2D:a,outShape:i}=vie(r,t,e),u=new BI(a.map(m=>m.shape)),p=e.runWebGLProgram(u,a,n);a.forEach(m=>e.disposeIntermediateTensorInfo(m));let l=ue({inputs:{x:p},attrs:{shape:i},backend:e});return e.disposeIntermediateTensorInfo(p),l}function vie(r,t,e){let n=C.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>ue({inputs:{x:s},attrs:{shape:[-1,y.sizeFromShape(s.shape.slice(t))]},backend:e})),outShape:n}}function OD(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,t[0].shape)[0],a=C.computeOutShape(t.map(p=>p.shape),s);if(y.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(p=>y.sizeFromShape(p.shape)>0);if(i.length===1)return ir({inputs:{x:i[0]},backend:e});let u=i.map(p=>p.shape);return C.assertParamsConsistent(u,s),Ef(i,s,e)}var $3={kernelName:cs,backendName:"webgl",kernelFunc:OD};var _f=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.outputShape=t.outShape;let a=t.padInfo.top,i=t.padInfo.left,u=t.strideHeight,p=t.strideWidth,l=t.dilationHeight,m=t.dilationWidth,c=t.filterHeight,d=t.filterWidth,f=Math.floor(t.inChannels/4)*4,h=t.inChannels%4,g=t.dataFormat==="channelsLast",b=g?1:2,T=g?2:3,x=g?3:1,I="",k="";n&&(o?I=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?I=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:I=`
          float activation(float x) {
            ${n}
          }
        `,k="result = activation(result);");let w=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${I}

      const ivec2 strides = ivec2(${u}, ${p});
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${b}], coords[${T}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c}; wR++) {
          int xR = xRCorner + wR * ${l};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${m};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${w}
        ${k}
        setOutput(result);
      }
    `}},GI=class{constructor(t){this.variableNames=["x","W"];this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,o=t.padInfo.left,s=t.strideDepth,a=t.strideHeight,i=t.strideWidth,u=t.dilationDepth,p=t.dilationHeight,l=t.dilationWidth,m=t.filterDepth,c=t.filterHeight,d=t.filterWidth,f=Math.floor(t.inChannels/4)*4,h=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${i});
      const ivec3 pads = ivec3(${e}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${m}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${c}; wR++) {
            int xR = xRCorner + wR * ${p};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${l};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var Lf=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape,this.enableShapeUniforms=Ft(this.outputShape.length);let a=t.padInfo.left,i=t.strideWidth,u=t.dilationWidth,p=t.filterHeight,l=t.filterWidth,m=l,c=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<l;g++)c+=`
           vec4 xTexelC${g*2};
           int xTexelC${g*2}Ready;
           vec4 xTexelC${g*2+1};
           int xTexelC${g*2+1}Ready;
           vec4 xC${g};`;c+=`
     for (int r = 0; r < ${p}; r++) {
      for (int d1 = 0; d1 < ${t.inChannels}; d1 += 2) {
       `;for(let g=0;g<l;g++)c+=`
           xTexelC${g*2} = vec4(0.0);
           xTexelC${g*2}Ready = 0;
           xTexelC${g*2+1} = vec4(0.0);
           xTexelC${g*2+1}Ready = 0;
           xC${g} = vec4(0.0);`;c+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let g=0;g<(m+1)/2;g++){let b=g*2;if(c+=`
           xC = xCCorner + ${b*u};
           `,i===1){if(b<l&&(a%2===1?(c+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }
               `,u===1&&b>0?c+=`
                 xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                 `:c+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                   } else {
                     xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                   }
                   `):c+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xC${b} = xTexelC${b};
                 `,b+1<l)){let T=a%2===0?y.nearestLargerEven(u):u;u%2===0&&a%2===1||u%2!==0&&a%2!==1?(c+=`
                   xCOffset = xC + imod(pads[1], 2) + ${T};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                     xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${b+1}.zw = vec2(0.0);
                     }
                     xTexelC${b+1}Ready = 1;
                   }
                   `,u>1?c+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                     } else {
                      xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                     }
                     `:c+=`
                     xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                     `):T===1?c+=`
                     xC${b+1} = xTexelC${b};
                     `:c+=`
                     xCOffset = xC + ${T};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                       xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${b+1}.zw = vec2(0.0);
                       }
                       xTexelC${b+1}Ready = 1;
                     }

                     xC${b+1} = xTexelC${b+1};
                     `}}else b<l&&(a%2===1?(c+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.0);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
               `,b+1<l&&(c+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                 `)):(c+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                   xTexelC${b} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${b}.zw = vec2(0.0);
                   }
                   xTexelC${b}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                   xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${b+1}.zw = vec2(0.);
                   }
                   xTexelC${b+1}Ready = 1;
                 }

                 xC${b} = vec4(
                   xTexelC${b}.xy, xTexelC${b+1}.xy);
               `,b+1<l&&(c+=`
                   xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                 `)));b<l&&(c+=`
             wTexel = getW(r, ${b}, d1, d2);
             dotProd += xC${b}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${t.inChannels}) {
               dotProd += xC${b}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<l&&(c+=`
               wTexel = getW(r, ${b+1}, d1, d2);
               dotProd += xC${b+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${t.inChannels}) {
                 dotProd += xC${b+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}c+=`
     }
   `,c+=`
     }
   `,c+=`
     }
   `;let d="",f="";n&&(o?d=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${n}
         }`:s?d=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${n}
         }`:d=`vec4 activation(vec4 x) {
           ${n}
         }`,f="result = activation(result);");let h=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${d}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${c}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${h}
         ${f}
         setOutput(result);
       }
     `}};var UI=class{constructor(t,e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}];this.outputShape=t,this.enableShapeUniforms=Ft(this.outputShape.length);let{dataFormat:n}=e,o=Jt(),s=n==="channelsLast",a=s?1:2,i=s?2:3,u=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${t[2]} && pos < ${t[1]}) {`,p="";for(let l=0;l<=1;l++)for(let m=0;m<=1;m++)p+=`
          blockIndex = rc.z + ${m};
          pos = rc.y + ${l};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${i}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${l*2+m}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${l*2+m}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${p}

        ${o.output} = result;
      }
    `}};function WI(r,t){let e=r.length;return e>=3?t?[...r.slice(0,-3),r[e-3]*r[e-2],r[e-1]]:[...r.slice(0,-3),r[e-3],r[e-2]*r[e-1]]:!t&&e===1&&r[0]>1?[r[0],1]:null}function KI({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=r.shape,p=n.texData.get(r.dataId),l=e.inChannels,m=u[0]*u[1]*u[2],c=e.outChannels,d=e.dataFormat==="channelsLast",f=!1,h=!1,g,b=[];if(s!=null){let I=WI(s.shape,d);I!=null&&(s=ue({inputs:{x:s},backend:n,attrs:{shape:I}}),b.push(s))}if(o!=null){let I=WI(o.shape,d);I!=null&&(o=ue({inputs:{x:o},backend:n,attrs:{shape:I}}),b.push(o))}if(!((m===1||c===1)&&l>_D)&&p.isPacked&&d&&p.texture!=null&&u[2]%2!==0&&y.arraysEqual(p.shape.slice(-3),u.slice(-3))){let I=u[0]*u[1]*(u[2]+1),k={dataId:r.dataId,shape:[1,I,e.inChannels],dtype:r.dtype},w=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,y.assert(Rp(p.shape,k.shape),()=>`packed reshape ${p.shape} to ${k.shape} isn't free`);let R=ue({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});b.push(R);let P=rm({a:k,b:R,backend:n,transposeA:f,transposeB:h,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),M=n.texData.get(P.dataId);y.assert(M.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=w,M.shape=e.outShape,g=ir({inputs:{x:P},backend:n}),g.shape=e.outShape,b.push(P)}else{let I=e.outHeight*e.outWidth,k=ue({inputs:{x:r},backend:n,attrs:{shape:d?[e.batchSize,I,e.inChannels]:[e.batchSize,e.inChannels,I]}}),w=ue({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),R=rm({a:d?k:w,b:d?w:k,transposeA:!d,transposeB:h,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});g=ue({inputs:{x:R},backend:n,attrs:{shape:e.outShape}}),b.push(k),b.push(w),b.push(R)}for(let I of b)n.disposeIntermediateTensorInfo(I);return g}function VI({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let{filterWidth:u,filterHeight:p,inChannels:l,outWidth:m,outHeight:c,dataFormat:d}=e,f=d==="channelsLast",h=u*p*l,g=c*m,b=[e.batchSize,h,g],T=!0,x=!1,I=[];if(s!=null){let q=WI(s.shape,f);q!=null&&(s=ue({inputs:{x:s},backend:n,attrs:{shape:q}}),I.push(s))}if(o!=null){let q=WI(o.shape,f);q!=null&&(o=ue({inputs:{x:o},backend:n,attrs:{shape:q}}),I.push(o))}let k=ue({inputs:{x:t},backend:n,attrs:{shape:[1,h,y.sizeFromShape(t.shape)/h]}});I.push(k);let w=new UI(b,e),R=[r.shape,[e.padInfo.top,e.padInfo.left],[e.strideHeight,e.strideWidth],[e.dilationHeight,e.dilationWidth],[e.inChannels],[e.filterWidth*e.inChannels],[e.outWidth]],P=n.runWebGLProgram(w,[r],"float32",R),M=ue({inputs:{x:P},backend:n,attrs:{shape:b}});I.push(P),I.push(M);let L=o!=null,z=s!=null,W=i==="leakyrelu",V=i?vu(i,!0):null,j=new Mf(f?M.shape:k.shape,f?k.shape:M.shape,f?[e.batchSize,g,e.outChannels]:[e.batchSize,e.outChannels,g],T,x,L,V,z,W),H=f?[M,k]:[k,M];if(o&&H.push(o),z&&H.push(s),W){let q=n.makeTensorInfo([],"float32",y.createScalarValue(a,"float32"));H.push(q),I.push(q)}let X=n.runWebGLProgram(j,H,"float32"),ee=ue({inputs:{x:X},backend:n,attrs:{shape:e.outShape}});I.push(X);for(let q of I)n.disposeIntermediateTensorInfo(q);return ee}function Aie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dataFormat:u,dilations:p,dimRoundingMode:l}=n,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,p,i,l,!1,m),d;if(c.filterHeight===1&&c.filterWidth===1&&c.dilationHeight===1&&c.dilationWidth===1&&c.strideHeight===1&&c.strideWidth===1&&(c.padInfo.type==="SAME"||c.padInfo.type==="VALID"))d=KI({x:o,filter:s,convInfo:c,backend:e});else if(c.strideWidth<=2&&m==="channelsLast"&&B().getBool("WEBGL_EXP_CONV")){let h=new Lf(c),g=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];d=e.runWebGLProgram(h,[o,s],"float32",g)}else if(B().getBool("WEBGL_CONV_IM2COL"))d=VI({x:o,filter:s,convInfo:c,backend:e});else{let h=new _f(c);d=e.runWebGLProgram(h,[o,s],"float32")}let f=ue({inputs:{x:d},backend:e,attrs:{shape:c.outShape}});return e.disposeIntermediateTensorInfo(d),f}var B3={kernelName:lo,backendName:"webgl",kernelFunc:Aie};var HI=class{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,a=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},qI=class{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,a=t.dataFormat==="channelsLast",i=e-1-t.padInfo.top,u=n-1-t.padInfo.left,p=a?1:2,l=a?2:3,m=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${m}];

        ivec2 dyCorner = ivec2(coords[${p}], coords[${l}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},jI=class{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.padInfo.front,a=t.padInfo.top,i=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${s};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${i};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},XI=class{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,o=t.filterWidth,s=t.strideDepth,a=t.strideHeight,i=t.strideWidth,u=e-1-t.padInfo.front,p=n-1-t.padInfo.top,l=o-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${p}, ${l});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function wie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:a,pad:i,dataFormat:u,dimRoundingMode:p,filterShape:l}=n,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,l,a,1,i,p,!1,m),d=new HI(c);return e.runWebGLProgram(d,[o,s],"float32")}var O3={kernelName:Lm,backendName:"webgl",kernelFunc:wie};function Nie(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:a,strides:i,pad:u,dataFormat:p,dimRoundingMode:l}=n,m=C.convertConv2DDataFormat(p),c=C.computeConv2DInfo(a,s.shape,i,1,u,l,!1,m),d=new qI(c);return e.runWebGLProgram(d,[o,s],"float32")}var z3={kernelName:mo,backendName:"webgl",kernelFunc:Nie};function Die(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dilations:u}=n,p=C.computeConv3DInfo(o.shape,s.shape,a,u,i),l=new GI(p);return e.runWebGLProgram(l,[o,s],"float32")}var G3={kernelName:$u,backendName:"webgl",kernelFunc:Die};function Fie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:a,pad:i,filterShape:u}=n,p=C.computeConv3DInfo(o.shape,u,a,1,i),l=new jI(p);return e.runWebGLProgram(l,[o,s],"float32")}var U3={kernelName:$m,backendName:"webgl",kernelFunc:Fie};function Rie(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{pad:a,strides:i,inputShape:u}=n,p=C.computeConv3DInfo(u,s.shape,i,1,a),l=new XI(p);return e.runWebGLProgram(l,[o,s],"float32")}var W3={kernelName:Bm,backendName:"webgl",kernelFunc:Rie};var Pie=Qs+`
  return cos(x);
`,Mie=Ae({opSnippet:Pie}),K3={kernelName:co,backendName:"webgl",kernelFunc:Mie};var Eie=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,_ie=Ae({opSnippet:Eie}),V3={kernelName:fo,backendName:"webgl",kernelFunc:_ie};var YI=class{constructor(t,e,n,o,s){this.variableNames=["Image","Boxes","BoxInd"];this.outputShape=[];let[a,i,u,p]=t,[l]=e,[m,c]=n;this.outputShape=[l,m,c,p];let d=o==="bilinear"?1:0,[f,h]=[`${i-1}.0`,`${u-1}.0`],[g,b,T]=m>1?[`${(i-1)/(m-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,I,k]=c>1?[`${(u-1)/(c-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${b};
        float width_scale = ${I};

        float in_y = ${T};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${k};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Lie=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:a}=t,{cropSize:i,method:u,extrapolationValue:p}=n,l=new YI(o.shape,s.shape,i,u,p);return e.runWebGLProgram(l,[o,s,a],"float32")},H3={kernelName:ga,backendName:"webgl",kernelFunc:Lie};var Ng=class{constructor(t,e,n,o){this.op=t;this.outputShape=e;this.variableNames=["x"];this.customUniforms=[{name:"index",type:"float"}];let s=this.outputShape.length,a=this.op==="*"?"1.0":"0.0",i=n?a:`getX(${q3(s,"coords",this.op)})`,u=this.outputShape[this.outputShape.length-1],p="",l="";n?(p=o?`end != ${u-1}`:"end != 0",l=o?"end + 1":"end - 1"):(p=o?`end + pow2 < ${u}`:"end >= pow2",l=o?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Ve(s)} coords = getOutputCoords();
        int end = ${j3(s,"coords",this.op)};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${p}) {
          int idx = ${l};
          ${j3(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${q3(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function q3(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function j3(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw new Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function ZI(r,t,e,n,o,s){let a=t.shape.length,i=C.getAxesPermutation([n],a),u=t;i!=null&&(u=Ht({inputs:{x:t},backend:e,attrs:{perm:i}}));let p=C.getInnerMostAxes(1,a)[0];if(p!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let l=u.shape[p],m=ir({inputs:{x:u},backend:e});for(let c=0;c<=Math.ceil(Math.log2(l))-1;c++){let d=new Ng(r,u.shape,!1,s),f=[[c]],h=m;m=e.runWebGLProgram(d,[m],m.dtype,f),e.disposeIntermediateTensorInfo(h)}if(o){let c=new Ng(r,u.shape,o,s),d=m;m=e.runWebGLProgram(c,[m],m.dtype),e.disposeIntermediateTensorInfo(d)}if(i!=null){let c=C.getUndoAxesPermutation(i),d=Ht({inputs:{x:m},backend:e,attrs:{perm:c}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(u),d}return m}function Bie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n;return ZI("*",o,e,s,a,i)}var X3={kernelName:ha,backendName:"webgl",kernelFunc:Bie};function Oie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n;return ZI("+",o,e,s,a,i)}var Y3={kernelName:ho,backendName:"webgl",kernelFunc:Oie};function zie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,weights:s}=t,{size:a,binaryOutput:i}=n;if(o.shape.length===1){let u=e.readSync(o.dataId),p=e.readSync(s.dataId),l=cI(u,p,s.dtype,s.shape,a);return e.makeTensorInfo([a],s.dtype,l)}else if(o.shape.length===2){let u=e.bufferSync(o),p=e.bufferSync(s),l=$O(u,p,a,i);return e.makeTensorInfo(l.shape,s.dtype,l.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var Z3={kernelName:Om,backendName:"webgl",kernelFunc:zie};var QI=class{constructor(t,e,n){this.variableNames=["x"];this.outputShape=[];this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Gie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],p=a==="NHWC"?o.shape[2]:o.shape[3],l=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=p*s,d=l/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=new QI(f,s,a);return e.runWebGLProgram(h,[o],o.dtype)}var Q3={kernelName:ba,backendName:"webgl",kernelFunc:Gie};var $f=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape,this.enableShapeUniforms=Ft(this.outputShape.length);let a=t.filterHeight,i=t.filterWidth,u=t.outChannels/t.inChannels,p="",l="";n&&(o?p=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?p=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:p=`
          float activation(float x) {
            ${n}
          }
        `,l="result = activation(result);");let m=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${i}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${m}
        ${l}
        setOutput(result);
      }
    `}};var Bf=class{constructor(t,e=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=t.outShape,this.enableShapeUniforms=Ft(this.outputShape.length);let a=t.outChannels/t.inChannels,i=t.padInfo.left,u=t.strideWidth,p=t.dilationWidth,l=t.filterHeight,m=t.filterWidth,c=m,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<m;b++)d+=`
          vec4 xTexelC${b*2};
          int xTexelC${b*2}Ready;
          vec4 xTexelC${b*2+1};
          int xTexelC${b*2+1}Ready;
          vec4 xC${b};`;d+=`
    for (int r = 0; r < ${l}; r++) {
      `;for(let b=0;b<m;b++)d+=`
          xTexelC${b*2} = vec4(0.0);
          xTexelC${b*2}Ready = 0;
          xTexelC${b*2+1} = vec4(0.0);
          xTexelC${b*2+1}Ready = 0;
          xC${b} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(c+1)/2;b++){let T=b*2;if(d+=`
          xC = xCCorner + ${T*p};
          `,u===1){if(T<m&&(i%2===1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }
              `,p===1&&T>0?d+=`
                xC${T} = vec4(xTexelC${T-2}.zw, xTexelC${T}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${T} = vec4(previous.zw, xTexelC${T}.xy);
                  } else {
                    xC${T} = vec4(0.0, 0.0, xTexelC${T}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xC${T} = xTexelC${T};
                `,T+1<m)){let x=i%2===0?y.nearestLargerEven(p):p;p%2===0&&i%2===1||p%2!==0&&i%2!==1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                    xTexelC${T+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${T+1}.zw = vec2(0.0);
                    }
                    xTexelC${T+1}Ready = 1;
                  }
                  `,p>1?d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${T+1} = vec4(previous.zw, xTexelC${T+1}.xy);
                    } else {
                     xC${T+1} = vec4(0.0, 0.0, xTexelC${T+1}.xy);
                    }
                    `:d+=`
                    xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.xy);
                    `):x===1?d+=`
                    xC${T+1} = xTexelC${T};
                    `:d+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                      xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${T+1}.zw = vec2(0.0);
                      }
                      xTexelC${T+1}Ready = 1;
                    }

                    xC${T+1} = xTexelC${T+1};
                    `}}else T<m&&(i%2===1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.0);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
              `,T+1<m&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${T+1} = vec4(xTexelC${T+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${T}Ready == 0) {
                  xTexelC${T} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${T}.zw = vec2(0.0);
                  }
                  xTexelC${T}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${T+1}Ready == 0) {
                  xTexelC${T+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${T+1}.zw = vec2(0.);
                  }
                  xTexelC${T+1}Ready = 1;
                }

                xC${T} = vec4(
                  xTexelC${T}.xy, xTexelC${T+1}.xy);
              `,T+1<m&&(d+=`
                  xC${T+1} = vec4(xTexelC${T}.zw, xTexelC${T+1}.zw);
                `)));T<m&&(d+=`
            wTexel = getW(r, ${T}, d1, q);
            dotProd += xC${T} * vec4(wTexel.xz, wTexel.xz);
          `,T+1<m&&(d+=`
              wTexel = getW(r, ${T+1}, d1, q);
              dotProd += xC${T+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let f="",h="";n&&(o?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function Uie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dilations:u,dimRoundingMode:p}=n,l=u;l==null&&(l=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(a,l),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);let m=C.computeConv2DInfo(o.shape,s.shape,a,l,i,p,!0),c;B().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1?c=new Bf(m):c=new $f(m);let d=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]];return e.runWebGLProgram(c,[o,s],"float32",d)}var J3={kernelName:go,backendName:"webgl",kernelFunc:Uie};var JI=class{constructor(t){this.variableNames=["x","dy"];this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,o=t.padInfo.top,s=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${o};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},eC=class{constructor(t){this.variableNames=["dy","W"];this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,o=t.strideHeight,s=t.strideWidth,a=e-1-t.padInfo.top,i=n-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${i});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Wie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,dy:s}=t,{strides:a,dilations:i,pad:u,dimRoundingMode:p,filterShape:l}=n,m=C.computeConv2DInfo(o.shape,l,a,i,u,p,!0),c=new JI(m);return e.runWebGLProgram(c,[o,s],"float32")}var eG={kernelName:zm,backendName:"webgl",kernelFunc:Wie};function Kie(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{strides:a,dilations:i,pad:u,dimRoundingMode:p,inputShape:l}=n,m=C.computeConv2DInfo(l,s.shape,a,i,u,p,!0),c=new eC(m);return e.runWebGLProgram(c,[o,s],"float32")}var tG={kernelName:Gm,backendName:"webgl",kernelFunc:Kie};var tC=class{constructor(t){this.variableNames=["X"];this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Vie(r){let{inputs:t,backend:e}=r,{x:n}=t,o=[...n.shape,...n.shape],s=y.sizeFromShape(n.shape),a=ue({inputs:{x:n},backend:e,attrs:{shape:[s]}}),i=new tC(s),u=e.runWebGLProgram(i,[a],a.dtype),p=ue({inputs:{x:u},backend:e,attrs:{shape:o}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),p}var rG={kernelName:Um,backendName:"webgl",kernelFunc:Vie};var rC=class{constructor(t){this.variableNames=["x","W"];this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:o,strideHeight:s,strideWidth:a,filterHeight:i,filterWidth:u,dilationHeight:p,dilationWidth:l}=t,{top:m,left:c}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${m}, ${c});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${i}; h++) {
          int hIn = hBeg + h * ${p};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${l};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Hie(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dilations:u}=n,p=C.computeDilation2DInfo(o.shape,s.shape,a,i,"NHWC",u),l,m=new rC(p);l=e.runWebGLProgram(m,[o,s],"float32");let c=ue({inputs:{x:l},backend:e,attrs:{shape:p.outShape}});return e.disposeIntermediateTensorInfo(l),c}var nG={kernelName:Bu,backendName:"webgl",kernelFunc:Hie};function qie(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:p,steps:l}=C.getEinsumComputePath(i,u),m=l.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of l[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=Ht({inputs:{x:s[g]},backend:e,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let k=0;k<T.length;++k)I.splice(T[k],0,1);y.arraysEqual(x.shape,I)||(x=ue({inputs:{x},backend:e,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=Ag({inputs:{a:x,b:c},backend:e}),f.push(c))}h<m-1&&(p[h]>=0&&(c=tm({inputs:{x:c},backend:e,attrs:{axis:p[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&e.disposeIntermediateTensorInfo(h);return c}var oG={kernelName:Ou,backendName:"webgl",kernelFunc:qie};var jie="return (x >= 0.0) ? x : (exp(x) - 1.0);",Xie=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Yie=Ae({opSnippet:jie,packedOpSnippet:Xie}),sG={kernelName:yo,backendName:"webgl",kernelFunc:Yie};var Zie="return (b >= 1.0) ? a : a * (b + 1.0);",Qie=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,Jie=r=>{let{inputs:t,backend:e}=r,{dy:n,y:o}=t,s=B().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Zs(Qie,n.shape,o.shape):new ss(Zie,n.shape,o.shape);return e.runWebGLProgram(s,[n,o],n.dtype)},aG={kernelName:Wm,backendName:"webgl",kernelFunc:Jie};var eue=`
  return vec4(equal(a, b));
`,tue="return float(a == b);",rue=ft({opSnippet:tue,packedOpSnippet:eue,dtype:"bool",cpuKernelImpl:GO}),iG={kernelName:ya,backendName:"webgl",kernelFunc:rue};var nue=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${C.ERF_P};
  float a1 = ${C.ERF_A1};
  float a2 = ${C.ERF_A2};
  float a3 = ${C.ERF_A3};
  float a4 = ${C.ERF_A4};
  float a5 = ${C.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,oue=Ae({opSnippet:nue}),uG={kernelName:Ki,backendName:"webgl",kernelFunc:oue};var sue=Qs+`
  return exp(x);
`,aue=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zD=Ae({opSnippet:sue,packedOpSnippet:aue,cpuKernelImpl:UO,dtype:"float32"}),pG={kernelName:To,backendName:"webgl",kernelFunc:zD};function nC(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(y.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),ue({inputs:{x:s},backend:n,attrs:{shape:i}})}var lG={kernelName:ds,backendName:"webgl",kernelFunc:nC};var mG="return exp(x) - 1.0;",iue=Ae({opSnippet:mG,packedOpSnippet:mG,cpuKernelImpl:WO}),cG={kernelName:Ta,backendName:"webgl",kernelFunc:iue};var Dg=class{constructor(t,e,n){this.variableNames=["real","imag"];let o=e[1];this.outputShape=e;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${o}.0`:"1.0",i;if(t==="real")i="return real * expR - imag * expI;";else if(t==="imag")i="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${i}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function oC(r,t,e){let n=e.texData.get(r.dataId),o=y.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],a=o/s,i=ue({inputs:{x:r},backend:e,attrs:{shape:[a,s]}}),u=i.shape,p=new Dg("real",u,t),l=new Dg("imag",u,t),m=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],c=e.runWebGLProgram(p,m,"float32"),d=e.runWebGLProgram(l,m,"float32"),f=On({inputs:{real:c,imag:d},backend:e});e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d);let h=ue({inputs:{x:f},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(f),h}function uue(r){let{inputs:t,backend:e}=r,{input:n}=t;return oC(n,!1,e)}var dG={kernelName:Km,backendName:"webgl",kernelFunc:uue};var sC=class{constructor(t,e){this.outputShape=[];this.customUniforms=[{name:"value",type:"float"}];this.variableNames=["x"],this.outputShape=t,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function wu(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||y.inferDtype(o),s==="string"){let a=y.getArrayFromDType(s,y.sizeFromShape(n));return a.fill(o),t.makeTensorInfo(n,s,a)}else{let a=new sC(n,o),i=[[o]];return t.runWebGLProgram(a,[],s,i)}}var fG={kernelName:fi,backendName:"webgl",kernelFunc:wu};var aC=class{constructor(t){this.variableNames=["Image"];this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var hG={kernelName:xa,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new aC(e.shape);return n.runWebGLProgram(o,[e],e.dtype)}};var gG="return floor(x);",pue=Ae({opSnippet:gG,packedOpSnippet:gG,cpuKernelImpl:KO}),bG={kernelName:xo,backendName:"webgl",kernelFunc:pue};var lue=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,mue=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,cue=ft({opSnippet:lue,packedOpSnippet:mue,dtype:"int32"}),yG={kernelName:Io,backendName:"webgl",kernelFunc:cue};var iC=class{constructor(t){this.variableNames=["A"];let e=Jt(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var uC=class{constructor(t){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;let e=Jt(),[n,o]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var TG={kernelName:jp,backendName:"webgl",kernelFunc:due},Of,GD=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function due(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n,a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,[u,p]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],l=[p,u],m=[p,u,s];if(i||a){let h=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Of==null||h!==GD)&&(GD=h,Of=document.createElement("canvas").getContext("2d",{willReadFrequently:GD})),Of.canvas.width=u,Of.canvas.height=p,Of.drawImage(o,0,0,u,p),o=Of.canvas}let c=e.makeTensorInfo(l,"int32");e.texData.get(c.dataId).usage=2,e.gpgpu.uploadPixelDataToTexture(e.getTexture(c.dataId),o);let d=B().getBool("WEBGL_PACK")?new uC(m):new iC(m),f=e.runWebGLProgram(d,[c],"int32");return e.disposeData(c.dataId),f}function fue(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dataFormat:l,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=C.convertConv2DDataFormat(l),g=C.computeConv2DInfo(o.shape,s.shape,u,m,p,c,!1,h),b,T=[],x=a!=null,I=i!=null,k=d==="leakyrelu",w=()=>{let P=[o,s],M=(L,z)=>{if(z==="NCHW"&&L.shape.length===1&&L.shape[0]!==1){let W=ue({inputs:{x:L},backend:e,attrs:{shape:[L.shape[0],1,1]}});return T.push(W),W}return L};if(x&&P.push(M(a,l)),I&&P.push(M(i,l)),k){let L=e.makeTensorInfo([],"float32",y.createScalarValue(f,"float32"));P.push(L),T.push(L)}return P};if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))b=KI({x:o,filter:s,convInfo:g,backend:e,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else if(g.strideWidth<=2&&h==="channelsLast"&&B().getBool("WEBGL_EXP_CONV")){let P=d?vu(d,!0):null,M=new Lf(g,x,P,I,k),L=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],z=w();b=e.runWebGLProgram(M,z,"float32",L)}else if(B().getBool("WEBGL_CONV_IM2COL"))b=VI({x:o,filter:s,convInfo:g,backend:e,bias:a,activation:d,preluActivationWeights:i,leakyreluAlpha:f});else{let P=d?vu(d,!1):null,M=new _f(g,x,P,I,k),L=w();b=e.runWebGLProgram(M,L,"float32")}let R=ue({inputs:{x:b},backend:e,attrs:{shape:g.outShape}});return T.push(b),T.forEach(P=>e.disposeIntermediateTensorInfo(P)),R}var xG={kernelName:ws,backendName:"webgl",kernelFunc:fue};function hue(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dilations:l,dimRoundingMode:m,activation:c,leakyreluAlpha:d}=n,f=[],h=l;h==null&&(h=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=C.computeConv2DInfo(o.shape,s.shape,u,h,p,m,!0),b=B().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,T=c?vu(c,b):null,x=[o,s],I=a!=null,k=i!=null,w=c==="leakyrelu";if(I&&x.push(a),k&&x.push(i),w){let L=e.makeTensorInfo([],"float32",y.createScalarValue(d,"float32"));x.push(L),f.push(L)}let R;b?R=new Bf(g,I,T,k,w):R=new $f(g,I,T,k,w);let P=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],M=e.runWebGLProgram(R,x,"float32",P);return f.forEach(L=>e.disposeIntermediateTensorInfo(L)),M}var IG={kernelName:Ns,backendName:"webgl",kernelFunc:hue};var pC=class{constructor(t,e,n,o){this.sliceDim=t;this.strides=e;this.paramsShape=o;this.variableNames=["x","indices"];this.outputShape=n;let s=Ve(e.length),a=Ve(n.length),i=this.sliceDim>1?"strides[j]":"strides",u=Ve(o.length),p=o.length>1?"paramsShape[j]":"paramsShape";this.userCode=`
        ${s} strides = ${s}(${this.strides});
        ${u} paramsShape = ${u}(${this.paramsShape});
         void main() {
          ${a} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            out_of_bounds = out_of_bounds || index < 0;
            out_of_bounds = out_of_bounds || index >= ${p};
            flattenIndex += index * ${i};
          }
          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}};function gue(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,a=s[s.length-1],i=y.sizeFromShape(n.shape),[u,p,l,m]=C.prepareAndValidate(n,o),c=ue({inputs:{x:o},backend:e,attrs:{shape:[p,a]}}),d=ue({inputs:{x:n},backend:e,attrs:{shape:[y.sizeFromShape(n.shape)/l,l]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let b=e.readSync(o.dataId),T=e.bufferSync(n),x=VO(b,T,n.dtype,p,a,l,m,n.shape,i);return e.makeTensorInfo(u,n.dtype,x.values)}let f=new pC(a,m,[p,l],n.shape),h=e.runWebGLProgram(f,[d,c],d.dtype),g=ue({inputs:{x:h},backend:e,attrs:{shape:u}});return e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(h),g}var CG={kernelName:Ia,backendName:"webgl",kernelFunc:gue};var lC=class{constructor(t,e){this.variableNames=["A","indices"];this.outputShape=e,this.rank=e.length;let n=Ve(this.rank),o=bue(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${t[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${o}));
      }
    `}};function bue(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("index"):n.push(`${e[o]}`);return n.join()}function UD(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0];if(B().get("DEBUG")){let T=e.readSync(s.dataId),x=o.shape[u];for(let I=0;I<T.length;++I){let k=T[I];y.assert(k<=x-1&&k>=0,()=>`GatherV2: the index value ${k} is not in [0, ${x-1}]`)}}let p=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),l=y.sizeFromShape(s.shape),m=[],c=ue({inputs:{x:o},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),d=ue({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,l/p.batchSize]}});m.push(c),m.push(d);let f=[p.batchSize,p.outerSize,l/p.batchSize,p.sliceSize];if(e.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let T=e.bufferSync(d),x=e.bufferSync(c),I=HO(x,T,f);return m.forEach(k=>e.disposeIntermediateTensorInfo(k)),e.makeTensorInfo(p.outputShape,I.dtype,I.values)}let h=new lC(c.shape,f),g=e.runWebGLProgram(h,[c,d],c.dtype);m.push(g);let b=ue({inputs:{x:g},backend:e,attrs:{shape:p.outputShape}});return m.forEach(T=>e.disposeIntermediateTensorInfo(T)),b}var kG={kernelName:fs,backendName:"webgl",kernelFunc:UD};var yue="return float(a > b);",Tue=`
  return vec4(greaterThan(a, b));
`,xue=ft({opSnippet:yue,packedOpSnippet:Tue,cpuKernelImpl:qO,dtype:"bool"}),SG={kernelName:Ca,backendName:"webgl",kernelFunc:xue};var Iue="return float(a >= b);",Cue=`
  return vec4(greaterThanEqual(a, b));
`,kue=ft({opSnippet:Iue,packedOpSnippet:Cue,dtype:"bool",cpuKernelImpl:jO}),vG={kernelName:ko,backendName:"webgl",kernelFunc:kue};function Sue(r){let{inputs:t,backend:e}=r,{input:n}=t;return oC(n,!0,e)}var AG={kernelName:Vm,backendName:"webgl",kernelFunc:Sue};var vue="return float(!isnan(x) && !isinf(x));",Aue=Ae({opSnippet:vue,dtype:"bool"}),wG={kernelName:Vi,backendName:"webgl",kernelFunc:Aue};var wue="return float(isinf(x));",Nue=Ae({opSnippet:wue,dtype:"bool"}),NG={kernelName:Hi,backendName:"webgl",kernelFunc:Nue};var Due="return float(isnan(x));",Fue=Ae({opSnippet:Due,dtype:"bool"}),DG={kernelName:ka,backendName:"webgl",kernelFunc:Fue};var Rue="return float(a < b);",Pue=`
  return vec4(lessThan(a, b));
`,Mue=ft({opSnippet:Rue,packedOpSnippet:Pue,cpuKernelImpl:XO,dtype:"bool"}),FG={kernelName:Sa,backendName:"webgl",kernelFunc:Mue};var Eue="return float(a <= b);",_ue=`
  return vec4(lessThanEqual(a, b));
`,Lue=ft({opSnippet:Eue,packedOpSnippet:_ue,cpuKernelImpl:YO,dtype:"bool"}),RG={kernelName:va,backendName:"webgl",kernelFunc:Lue};function $ue(r){let{backend:t,attrs:e}=r,{start:n,stop:o,num:s}=e,a=ZO(n,o,s);return t.makeTensorInfo([a.length],"float32",a)}var PG={kernelName:Hm,backendName:"webgl",kernelFunc:$ue};var Bue=Qs+`
  return x < 0.0 ? 0./0. : log(x);
`,Oue=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,zue=Ae({opSnippet:Bue,packedOpSnippet:Oue,cpuKernelImpl:QO}),MG={kernelName:vo,backendName:"webgl",kernelFunc:zue};var Gue=Qs+`
  return log(1.0 + x);
`,Uue=Ae({opSnippet:Gue}),EG={kernelName:qi,backendName:"webgl",kernelFunc:Uue};var Wue="return float(a >= 1.0 && b >= 1.0);",Kue=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Vue=ft({opSnippet:Wue,packedOpSnippet:Kue,dtype:"bool"}),_G={kernelName:Aa,backendName:"webgl",kernelFunc:Vue};var Hue="return float(!(x >= 1.0));",que=Ae({opSnippet:Hue}),LG={kernelName:wa,backendName:"webgl",kernelFunc:que};var jue="return float(a >= 1.0 || b >= 1.0);",Xue=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Yue=ft({opSnippet:jue,packedOpSnippet:Xue,dtype:"bool"}),$G={kernelName:ji,backendName:"webgl",kernelFunc:Yue};var mC=class{constructor(t,e,n,o,s){this.variableNames=["x"];this.outputShape=[];let a=e,i=t[3]-1;this.outputShape=t;let u,p=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${p})`:s===1?u=`1.0/(${p})`:u=`exp(log(${p}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${i}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var cC=class{constructor(t,e,n,o,s){this.variableNames=["x"];this.outputShape=[];this.packedInputs=!0;this.packedOutput=!0;let a=e,i=t[3]-1;this.outputShape=t;let u,p=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${p})`:s===1?u=`1.0/(${p})`:u=`exp(log(${p}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${i}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var Zue=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{depthRadius:s,bias:a,alpha:i,beta:u}=n,p=B().getBool("WEBGL_PACK_NORMALIZATION")?new cC(o.shape,s,a,i,u):new mC(o.shape,s,a,i,u);return e.runWebGLProgram(p,[o],o.dtype)},BG={kernelName:Gu,backendName:"webgl",kernelFunc:Zue};var dC=class{constructor(t,e,n,o,s){this.variableNames=["inputImage","outputImage","dy"];this.outputShape=[];this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Que=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o,y:s,dy:a}=t,{depthRadius:i,bias:u,alpha:p,beta:l}=n,m=new dC(o.shape,i,u,p,l);return e.runWebGLProgram(m,[o,s,a],o.dtype)},OG={kernelName:qm,backendName:"webgl",kernelFunc:Que};function zG(r,t,e,n){let o=y.sizeFromShape(t),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=eo(i,r.dtype,"max",n),p=ue({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),p}function WD(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),p=u,l=C.getAxesPermutation(p,i),m=l!=null,c=e.shouldExecuteOnCPU([o]),d=o;if(m){if(c){let x=e.texData.get(d.dataId).values,I=new Array(i);for(let R=0;R<I.length;R++)I[R]=o.shape[l[R]];let k=Jl(x,o.shape,o.dtype,l,I);d=e.makeTensorInfo(I,o.dtype);let w=e.texData.get(d.dataId);w.values=k}else d=Mp(o,l,e);p=C.getInnerMostAxes(p.length,i)}C.assertAxesAreInnerMostDims("max",p,i);let[f,h]=C.computeOutAndReduceShapes(d.shape,p),g=f;a&&(g=C.expandShapeToKeepDim(f,u));let b;if(c){let x=e.texData.get(d.dataId).values,I=JO(x,y.sizeFromShape(h),g,o.dtype);b=e.makeTensorInfo(g,o.dtype);let k=e.texData.get(b.dataId);k.values=I}else b=zG(d,h,g,e);return m&&e.disposeIntermediateTensorInfo(d),b}var GG={kernelName:Ao,backendName:"webgl",kernelFunc:WD};var Jue=TI+`
  return max(a, b);
`,epe=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Pp+`
  return result;
`,tpe=ft({opSnippet:Jue,packedOpSnippet:epe,cpuKernelImpl:ez}),UG={kernelName:wo,backendName:"webgl",kernelFunc:tpe};function rpe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t;oi(o,"maxPool");let{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,p=1;y.assert(C.eitherStridesOrDilationsAreOne(a,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let l=C.computePool2DInfo(o.shape,s,a,p,i,u);if(l.filterWidth===1&&l.filterHeight===1&&y.arraysEqual(l.inShape,l.outShape))return ir({inputs:{x:o},backend:e});let m=new ai(l,"max",!1);return e.runWebGLProgram(m,[o],o.dtype)}var WG={kernelName:No,backendName:"webgl",kernelFunc:rpe};function npe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:a,pad:i,dataFormat:u,dimRoundingMode:p}=n,l=[1,1,1],m=C.computePool3DInfo(o.shape,s,a,l,i,p,u),c=new Ep(m,"max",!1);return e.runWebGLProgram(c,[o],o.dtype)}var KG={kernelName:Uu,backendName:"webgl",kernelFunc:npe};var fC=class{constructor(t){this.variableNames=["dy","maxPos"];this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,o=t.dilationHeight,s=t.effectiveFilterHeight,a=t.effectiveFilterWidth,i=s-1-t.padInfo.top,u=a-1-t.padInfo.left,p=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${p} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},hC=class{constructor(t){this.variableNames=["dy","maxPos"];this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,o=t.strideWidth,s=t.dilationDepth,a=t.dilationHeight,i=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,l=t.effectiveFilterWidth,m=u-1-t.padInfo.front,c=p-1-t.padInfo.top,d=l-1-t.padInfo.left,f=u*p*l-1;this.userCode=`
      const ivec3 pads = ivec3(${m}, ${c}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${l};
                wC += ${i}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${p} * ${l} +
                  wR * ${l} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ope(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s}=t,a=s,{filterSize:i,strides:u,pad:p,dimRoundingMode:l}=n,m=[1,1,1],c=C.computePool3DInfo(a.shape,i,u,m,p,l),d=new Ep(c,"max",!0),f=e.runWebGLProgram(d,[a],a.dtype),h=new hC(c),g=e.runWebGLProgram(h,[o,f],a.dtype);return e.disposeIntermediateTensorInfo(f),g}var VG={kernelName:Xm,backendName:"webgl",kernelFunc:ope};function spe(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,input:s,output:a}=t,i=s;oi([s,a],"maxPoolGrad");let{filterSize:u,strides:p,pad:l,dimRoundingMode:m}=n,c=C.computePool2DInfo(i.shape,u,p,1,l,m),d=!0,f=new ai(c,"max",d),h=e.runWebGLProgram(f,[i],i.dtype),g=new fC(c),b=e.runWebGLProgram(g,[o,h],i.dtype);return e.disposeIntermediateTensorInfo(h),b}var HG={kernelName:jm,backendName:"webgl",kernelFunc:spe};function qG(r,t,e,n){let o=new ai(e,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new ai(e,"max",!0,!0,t);let a=n.runWebGLProgram(o,[r],"float32");return[s,a]}var jG={kernelName:Ym,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:o,strides:s,pad:a,includeBatchInIndex:i}=t,u=e;y.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let p=[1,1];y.assert(C.eitherStridesOrDilationsAreOne(s,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${p}'`);let l=C.computePool2DInfo(n.shape,o,s,p,a),[m,c]=qG(n,i,l,u);return[m,c]}};function XG(r,t,e,n){let o=y.sizeFromShape(t),a=y.sizeFromShape(r.shape)/o,i=ue({inputs:{x:r},attrs:{shape:[a,o]},backend:n}),u=eo(i,"float32","mean",n),p=ue({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(u),p}var YG={kernelName:Do,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{keepDims:o,axis:s}=t,a=e,i=n.shape.length,u=y.parseAxisParam(s,n.shape),p=u,l=C.getAxesPermutation(p,i),m=l!=null,c=a.shouldExecuteOnCPU([n]),d=[],f=n;if(m){if(c){let I=a.texData.get(f.dataId).values,k=new Array(i);for(let P=0;P<k.length;P++)k[P]=n.shape[l[P]];let w=Jl(I,n.shape,n.dtype,l,k);f=a.makeTensorInfo(k,n.dtype);let R=a.texData.get(f.dataId);R.values=w}else f=Mp(n,l,a);d.push(f),p=C.getInnerMostAxes(p.length,i)}C.assertAxesAreInnerMostDims("sum",p,i);let[h,g]=C.computeOutAndReduceShapes(f.shape,p),b=h;o&&(b=C.expandShapeToKeepDim(h,u));let T=XG(f,g,b,a);for(let x of d)a.disposeIntermediateTensorInfo(x);return T}};function ape(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n,i=o.shape.length,u=y.parseAxisParam(s,o.shape),p=u,l=C.getAxesPermutation(p,i),m=o;l!=null&&(m=Ht({inputs:{x:o},backend:e,attrs:{perm:l}}),p=C.getInnerMostAxes(p.length,o.shape.length)),C.assertAxesAreInnerMostDims("min",p,i);let[c,d]=C.computeOutAndReduceShapes(m.shape,p),f=y.sizeFromShape(d),h=ue({inputs:{x:m},backend:e,attrs:{shape:[-1,f]}}),g=eo(h,h.dtype,"min",e),b;if(a){let T=C.expandShapeToKeepDim(c,u);b=ue({inputs:{x:g},backend:e,attrs:{shape:T}})}else b=ue({inputs:{x:g},backend:e,attrs:{shape:c}});return e.disposeIntermediateTensorInfo(h),e.disposeIntermediateTensorInfo(g),l!=null&&e.disposeIntermediateTensorInfo(m),b}var ZG={kernelName:Fo,backendName:"webgl",kernelFunc:ape};var ipe=TI+`
  return min(a, b);
`,upe=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+Pp+`
  return result;
`,ppe=ft({opSnippet:ipe,packedOpSnippet:upe,cpuKernelImpl:tz}),QG={kernelName:Ro,backendName:"webgl",kernelFunc:ppe};var gC=class{constructor(t,e,n){this.variableNames=["x"];this.outputShape=e.map((l,m)=>l[0]+t[m]+l[1]);let o=t.length,s=Ve(o),a=e.map(l=>l[0]).join(","),i=e.map((l,m)=>l[0]+t[m]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),p=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${p};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${p};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${p};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${p};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var bC=class{constructor(t,e,n){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=e.map((f,h)=>f[0]+t[h]+f[1]);let o=t.length,s=Ve(o),a=e.map(f=>f[0]).join(","),i=e.map((f,h)=>f[0]+t[h]).join(","),u=ar("rc",o),p=ar("source",o),l=`${u[o-1]} < ${this.outputShape[o-1]}`,m=o===1?"source":`vec2(${p.slice(-2).join()})`,c=n==="reflect"?0:1,d="";if(o===1){let f=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${c};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${c};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${p.join()}), ${m});
        ${u[o-1]} += 1;
        if(${l}) {
          ${f}
          result[1] = getChannel(getX(${p.join()}), ${m});
        }
      `}else{let f=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${c}) +
                gte * ((end - 1) * 2 - source + ${c});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${p.join()}), ${m});
        ${u[o-1]} += 1;
        if(${l}) {
          ${f}
          result[1] = getChannel(getX(${p.join()}), ${m});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${f}
          result[2] = getChannel(getX(${p.join()}), ${m});
          ${u[o-1]} += 1;
          if(${l}) {
            ${f}
            result[3] = getChannel(getX(${p.join()}), ${m});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var lpe=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{paddings:o,mode:s}=e,a=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bC(n.shape,o,s):new gC(n.shape,o,s);return t.runWebGLProgram(a,[n],n.dtype)},JG={kernelName:Po,backendName:"webgl",kernelFunc:lpe};var mpe=`if (b == 0.0) return NAN;
  return mod(a, b);`,cpe=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+Pp+`
  return result;
`,dpe=ft({opSnippet:mpe,packedOpSnippet:cpe}),eU={kernelName:Xi,backendName:"webgl",kernelFunc:dpe};var yC=class{constructor(t,e,n){this.variableNames=["probs"];this.customUniforms=[{name:"seed",type:"float"}];this.outputShape=[t,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}};var fpe=`
if (a == b) {
  return 1.0;
};
return a / b;`,hpe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,KD=ft({opSnippet:fpe,packedOpSnippet:hpe,checkOutOfBounds:!0}),tU={kernelName:bo,backendName:"webgl",kernelFunc:KD};var rU="return a - b;",VD=ft({opSnippet:rU,packedOpSnippet:rU,supportsComplex:!0,cpuKernelImpl:Tz}),nU={kernelName:Xo,backendName:"webgl",kernelFunc:VD};function HD(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,a=y.parseAxisParam([s],o.shape),i=WD({inputs:{x:o},backend:e,attrs:{reductionIndices:a,keepDims:!1}}),u=C.expandShapeToKeepDim(i.shape,a),p=ue({inputs:{x:i},backend:e,attrs:{shape:u}}),l=VD({inputs:{a:o,b:p},backend:e}),m=zD({inputs:{x:l},backend:e}),c=tm({inputs:{x:m},backend:e,attrs:{axis:a,keepDims:!1}}),d=ue({inputs:{x:c},backend:e,attrs:{shape:u}}),f=KD({inputs:{a:m,b:d},backend:e});return e.disposeIntermediateTensorInfo(i),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(c),e.disposeIntermediateTensorInfo(d),f}var oU={kernelName:qo,backendName:"webgl",kernelFunc:HD};function gpe(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{numSamples:s,seed:a,normalized:i}=n,u=i?o:HD({inputs:{logits:o},backend:e,attrs:{dim:o.shape.length-1}}),p=u.shape[0],l=u.shape[1],m=new yC(p,l,s),c=[[a]],d=e.runWebGLProgram(m,[u],"int32",c);return i||e.disposeIntermediateTensorInfo(u),d}var sU={kernelName:Zm,backendName:"webgl",kernelFunc:gpe};var bpe=Ir+`
  return -x;
`,ype=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Tpe(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.texData.get(n.dataId),[a,i]=nz(s.values,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,a)}let o;return B().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new os(n.shape,ype):o=new nn(n.shape,bpe),e.runWebGLProgram(o,[n],n.dtype)}var aU={kernelName:hs,backendName:"webgl",kernelFunc:Tpe};var xpe=xr.nonMaxSuppressionV3Impl;function Ipe(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,p=e.readSync(o.dataId),l=e.readSync(s.dataId),{selectedIndices:m}=xpe(p,l,a,i,u);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}var iU={kernelName:Da,backendName:"webgl",kernelFunc:Ipe};var Cpe=xr.nonMaxSuppressionV4Impl;function kpe(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,padToMaxOutputSize:p}=n,l=e.readSync(o.dataId),m=e.readSync(s.dataId),{selectedIndices:c,validOutputs:d}=Cpe(l,m,a,i,u,p);return[e.makeTensorInfo([c.length],"int32",new Int32Array(c)),e.makeTensorInfo([],"int32",new Int32Array([d]))]}var uU={kernelName:Yi,backendName:"webgl",kernelFunc:kpe};var Spe=xr.nonMaxSuppressionV5Impl;function vpe(r){C.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:p}=n,l=e.readSync(o.dataId),m=e.readSync(s.dataId),c=a,d=i,f=u,h=p,{selectedIndices:g,selectedScores:b}=Spe(l,m,c,d,f,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var pU={kernelName:Fa,backendName:"webgl",kernelFunc:vpe};var TC=class{constructor(t,e,n,o){this.variableNames=["indices"];this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var Ape=r=>{let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:a,onValue:i,offValue:u}=n,p=y.sizeFromShape(o.shape),l=new TC(p,a,i,u),m=ue({inputs:{x:o},backend:e,attrs:{shape:[p]}}),c=e.runWebGLProgram(l,[m],s);e.disposeIntermediateTensorInfo(m);let d=[...o.shape,a],f=ue({inputs:{x:c},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(c),f},lU={kernelName:Ra,backendName:"webgl",kernelFunc:Ape};function Fg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=Au({inputs:{input:n},backend:e}),s=Fg({inputs:{x:o},backend:e}),a=nm({inputs:{input:n},backend:e}),i=Fg({inputs:{x:a},backend:e}),u=On({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),u}else return wu({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var mU={kernelName:Ss,backendName:"webgl",kernelFunc:Fg};function cU(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Au({inputs:{input:n},backend:e}),s=cU({inputs:{x:o},backend:e}),a=nm({inputs:{input:n},backend:e}),i=Fg({inputs:{x:a},backend:e}),u=On({inputs:{real:s,imag:i},backend:e});return e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(i),u}else return wu({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var dU={kernelName:gs,backendName:"webgl",kernelFunc:cU};function wpe(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return nC({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,a=t[0].dtype;t.forEach(l=>{y.assertShapesMatch(s,l.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(l=>{let m=nC({inputs:{input:l},backend:e,attrs:{dim:o}});return i.push(m),m}),p=OD({inputs:u,backend:e,attrs:{axis:o}});return i.forEach(l=>e.disposeIntermediateTensorInfo(l)),p}var fU={kernelName:bs,backendName:"webgl",kernelFunc:wpe};var xC=class{constructor(t,e,n){this.variableNames=["x"];this.customUniforms=[{name:"value",type:"float"}];this.outputShape=e.map((p,l)=>p[0]+t[l]+p[1]);let o=t.length,s=Ve(o),a=e.map(p=>p[0]).join(","),i=e.map((p,l)=>p[0]+t[l]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${a};
        int end = ${i};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${i});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var IC=class{constructor(t,e,n){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"value",type:"float"}];this.outputShape=e.map((h,g)=>h[0]+t[g]+h[1]);let o=t.length,s=Ve(o),a=e.map(h=>h[0]).join(","),i=e.map((h,g)=>h[0]+t[g]).join(","),u=ar("rc",o),p=ar("source",o),l=`${u[o-1]} < ${this.outputShape[o-1]}`,m=o===1?"source":`vec2(${p.slice(-2).join()})`,c=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${l}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${l}) {`],d=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="";for(let h=0,g=o===1?2:4;h<g;h++)f+=`
        ${c[h]}
        if (${d}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${p.join()}), ${m});
        }
      `;f+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${i});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var qD=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:a}=n;if(y.sizeFromShape(o.shape)===0){let p=s.map((l,m)=>l[0]+o.shape[m]+l[1]);return wu({backend:e,attrs:{shape:p,value:a,dtype:o.dtype}})}let i=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new IC(o.shape,s,a):new xC(o.shape,s,a),u=[[a]];return e.runWebGLProgram(i,[o],o.dtype,u)},hU={kernelName:Eo,backendName:"webgl",kernelFunc:qD};var Npe=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Dpe=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+Pp+`
  return result;
`,Fpe=ft({opSnippet:Npe,packedOpSnippet:Dpe}),gU={kernelName:_o,backendName:"webgl",kernelFunc:Fpe};function Rpe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n,i=o.shape.length,u=[],p=y.parseAxisParam(s,o.shape),l=p,m=C.getAxesPermutation(l,i),c=o;m!=null&&(c=Ht({inputs:{x:o},backend:e,attrs:{perm:m}}),l=C.getInnerMostAxes(l.length,i),u.push(c)),C.assertAxesAreInnerMostDims("prod",l,i);let d;if(e.shouldExecuteOnCPU([c])){let f=e.texData.get(c.dataId).values,{outVals:h,outShape:g,outDtype:b}=sz(c.shape,c.dtype,f,l);d=e.makeTensorInfo(g,b,h)}else{let[f,h]=C.computeOutAndReduceShapes(c.shape,l),g=y.sizeFromShape(h),b=ue({inputs:{x:c},backend:e,attrs:{shape:[-1,g]}}),T=ou(o.dtype),x=eo(b,T,"prod",e);d=ue({inputs:{x},backend:e,attrs:{shape:f}}),u.push(b),u.push(x)}if(a){u.push(d);let f=C.expandShapeToKeepDim(d.shape,p);d=ue({inputs:{x:d},backend:e,attrs:{shape:f}})}return u.forEach(f=>e.disposeIntermediateTensorInfo(f)),d}var bU={kernelName:$o,backendName:"webgl",kernelFunc:Rpe};function Ppe(r){let{inputs:t,backend:e,attrs:n}=r,{shape:o,values:s,defaultValue:a,rowPartitionTensors:i}=t,{rowPartitionTypes:u}=n,p=e.readSync(o.dataId),l=e.readSync(s.dataId),m=e.readSync(a.dataId),c=i.map(g=>e.readSync(g.dataId)),d=i.map(g=>g.shape),[f,h]=az(p,o.shape,l,s.shape,s.dtype,m,a.shape,c,d,u);return e.makeTensorInfo(f,s.dtype,h)}var yU={kernelName:Qm,backendName:"webgl",kernelFunc:Ppe};var jD=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:a}=e,i=iz(n,o,s,a);return t.makeTensorInfo([i.length],a,i)},TU={kernelName:hi,backendName:"webgl",kernelFunc:jD};var Mpe="return 1.0 / x;",Epe=Ae({opSnippet:Mpe}),xU={kernelName:Pa,backendName:"webgl",kernelFunc:Epe};var _pe=Ir+`
  return (x < 0.0) ? 0.0 : x;
`,Lpe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,$pe=Ae({opSnippet:_pe,packedOpSnippet:Lpe}),IU={kernelName:Bo,backendName:"webgl",kernelFunc:$pe};var Bpe=Ir+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ope=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,zpe=Ae({opSnippet:Bpe,packedOpSnippet:Ope}),CU={kernelName:Go,backendName:"webgl",kernelFunc:zpe};var CC=class{constructor(t,e,n,o,s){this.variableNames=["A"];this.outputShape=[];let[a,i,u,p]=t;this.outputShape=[a,e,n,p];let l=[o&&e>1?i-1:i,o&&n>1?u-1:u],m=[o&&e>1?e-1:e,o&&n>1?n-1:n],c;s?c="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":c="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/m[0]},
          ${l[1]/m[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var kC=class{constructor(t,e,n,o,s){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];let[a,i,u,p]=t;this.outputShape=[a,e,n,p];let l=[o&&e>1?i-1:i,o&&n>1?u-1:u],m=[o&&e>1?e-1:e,o&&n>1?n-1:n],c;s?c="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":c="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/m[0]},
          ${l[1]/m[1]},
          ${l[1]/m[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${c};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${p-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Gpe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,p]=i,l=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new kC(o.shape,u,p,s,a):new CC(o.shape,u,p,s,a);return e.runWebGLProgram(l,[o],"float32")}var kU={kernelName:zo,backendName:"webgl",kernelFunc:Gpe};var SC=class{constructor(t,e,n){this.variableNames=["dy"];this.outputShape=[];this.outputShape=e;let[,o,s]=e,[,a,i]=t,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],p=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=u[0]/p[0],m=u[1]/p[1],c=1/l,d=1/m,f=Math.ceil(c)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${m});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Upe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:a}=n,i=new SC(s.shape,o.shape,a);return e.runWebGLProgram(i,[s],s.dtype)}var SU={kernelName:ec,backendName:"webgl",kernelFunc:Upe};var vC=class{constructor(t,e,n,o,s){this.variableNames=["A"];this.outputShape=[];let[a,i,u,p]=t;this.outputShape=[a,e,n,p];let l=[o&&e>1?i-1:i,o&&n>1?u-1:u],m=[o&&e>1?e-1:e,o&&n>1?n-1:n],c=o?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${l[0]/m[0]},
          ${l[1]/m[1]});
      const vec2 inputShapeRC = vec2(${i}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var AC=class{constructor(t,e,n,o,s){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];let[a,i,u,p]=t;this.outputShape=[a,e,n,p];let l=[o&&e>1?i-1:i,o&&n>1?u-1:u],m=[o&&e>1?e-1:e,o&&n>1?n-1:n],c=o?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${l[0]/m[0]},
          ${l[1]/m[1]},
          ${l[1]/m[1]});
      const vec3 inputShapeRC = vec3(${i}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${c})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${p-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Wpe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,p]=i,l=B().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new AC(o.shape,u,p,s,a):new vC(o.shape,u,p,s,a);return e.runWebGLProgram(l,[o],o.dtype)}var vU={kernelName:Oo,backendName:"webgl",kernelFunc:Wpe};var wC=class{constructor(t,e,n){this.variableNames=["dy"];this.outputShape=[];this.outputShape=e;let[,o,s]=e,[,a,i]=t,u=[n&&a>1?o-1:o,n&&i>1?s-1:s],p=[n&&a>1?a-1:a,n&&i>1?i-1:i],l=u[0]/p[0],m=u[1]/p[1],c=1/l,d=1/m,f=Math.ceil(c)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${l});
        const float widthScale = float(${m});

        const float invHeightScale = float(${c});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${i}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${p[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${p[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function Kpe(r){let{inputs:t,backend:e,attrs:n}=r,{images:o,dy:s}=t,{alignCorners:a}=n,i=new wC(s.shape,o.shape,a);return e.runWebGLProgram(i,[s],s.dtype)}var AU={kernelName:Jm,backendName:"webgl",kernelFunc:Kpe};var NC=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let o=i=>e.indexOf(i)!==-1&&t[i]!==1?`${t[i]} - coords[${i}] - 1`:`coords[${i}]`,s=t.map((i,u)=>o(u)).join(","),a=Ve(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var DC=class{constructor(t,e){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let o=ar("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,i=Ve(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${i} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${p(o.slice())};
          }
          if(${a}) {
            result.b = ${l(o.slice())};
            if(${s}) {
              result.a = ${m(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return c(f)}function p(f){return f[n-1]="("+f[n-1]+" + 1)",c(f)}function l(f){return f[n-2]="("+f[n-2]+" + 1)",c(f)}function m(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",c(f)}function c(f){let h=t.map((T,x)=>d(x,f)),g=h.join(","),b=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${b}))`}function d(f,h){return e.indexOf(f)!==-1&&t[f]!==1?`${t[f]} - ${h[f]} - 1`:`${h[f]}`}}};function Vpe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,a=o.shape.length,i=y.parseAxisParam(s,o.shape);if(a===0)return ir({inputs:{x:o},backend:e});let u=B().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new DC(o.shape,i):new NC(o.shape,i);return e.runWebGLProgram(u,[o],o.dtype)}var wU={kernelName:Ma,backendName:"webgl",kernelFunc:Vpe};var FC=class{constructor(t,e){this.variableNames=["Image"];this.outputShape=[];this.customUniforms=[{name:"params",type:"vec4"}];let n=t[1],o=t[2];this.outputShape=t;let s="";typeof e=="number"?s=`float outputValue = ${e.toFixed(2)};`:s=`
        vec3 fill = vec3(${e.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var NU={kernelName:Ga,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=t,i=e,u=new FC(n.shape,s),[p,l]=C.getImageCenter(a,n.shape[1],n.shape[2]),m=[[p,l,Math.sin(o),Math.cos(o)]];return i.runWebGLProgram(u,[n],n.dtype,m)}};var Hpe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,qpe=Ae({opSnippet:Hpe}),DU={kernelName:Ea,backendName:"webgl",kernelFunc:qpe};var jpe="return inversesqrt(x);",Xpe=Ae({opSnippet:jpe,cpuKernelImpl:uz}),FU={kernelName:Uo,backendName:"webgl",kernelFunc:Xpe};var zf=class{constructor(t,e,n,o,s,a,i=!0){this.variableNames=["updates","indices","defaultValue"];this.outputShape=a;let u=Ve(s.length),p=Ve(a.length),l="";n===1?l="i":n===2&&(l="i, j");let m=`getIndices(${l})`,c="";o===1?c="i":o===2&&(c="i, coords[1]");let d=`getUpdates(${c})`,f=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${p} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Ype(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:p,strides:l,outputSize:m}=C.calculateShapes(s,o,a),c=[m/p,p];if(m===0)return e.makeTensorInfo(a,o.dtype);let d=ue({inputs:{x:o},backend:e,attrs:{shape:[u,i]}}),f=ue({inputs:{x:s},backend:e,attrs:{shape:[u,p]}}),h=e.makeTensorInfo([],"float32",new Float32Array([0])),g=new zf(u,i,d.shape.length,f.shape.length,l,c),b=e.runWebGLProgram(g,[f,d,h],f.dtype),T=ue({inputs:{x:b},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(b),e.disposeIntermediateTensorInfo(h),T}var RU={kernelName:_a,backendName:"webgl",kernelFunc:Ype};var RC=class{constructor(t,e,n,o){this.variableNames=["sortedSequence","values"];this.customUniforms=[{name:"numInputs",type:"int"}];this.outputShape=[t,n];let s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(e+1))}; ++i) { if (left >= right) break;`,i=B().getNumber("WEBGL_VERSION")===2?s:a,u=o==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${i}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${u} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}};function Zpe(r){let{inputs:t,backend:e,attrs:n}=r,{sortedSequence:o,values:s}=t,{side:a}=n,i=new RC(o.shape[0],o.shape[1],s.shape[1],a),u=[[o.shape[1]]];return e.runWebGLProgram(i,[o,s],"int32",u)}var PU={kernelName:tc,backendName:"webgl",kernelFunc:Zpe};var PC=class{constructor(t,e,n){this.variableNames=["c","a","b"];this.outputShape=e;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let i=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],p=[];for(let l=0;l<e.length;l++)p.push(`${i[l]}`),l<t&&u.push(`${i[l]}`);o=u.join(),s=p.join()}let a=Ve(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Qpe(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,a=new PC(n.shape.length,o.shape,o.shape.length);return e.runWebGLProgram(a,[n,o,s],$t(o.dtype,s.dtype))}var MU={kernelName:Ts,backendName:"webgl",kernelFunc:Qpe};var Jpe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${C.SELU_SCALEALPHA};
  float scale = ${C.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,ele=Ae({opSnippet:Jpe}),EU={kernelName:Zi,backendName:"webgl",kernelFunc:ele};var tle=Qs+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,rle=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,nle=Ae({opSnippet:tle,packedOpSnippet:rle,cpuKernelImpl:lz}),_U={kernelName:Ko,backendName:"webgl",kernelFunc:nle};var ole=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,sle=Ae({opSnippet:ole}),LU={kernelName:Qi,backendName:"webgl",kernelFunc:sle};var ale=Qs+`
  return sin(x);
`,ile=Ae({opSnippet:ale}),$U={kernelName:Wo,backendName:"webgl",kernelFunc:ile};var ule=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,ple=Ae({opSnippet:ule}),BU={kernelName:La,backendName:"webgl",kernelFunc:ple};var lle=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,mle=Ae({opSnippet:lle}),OU={kernelName:Ji,backendName:"webgl",kernelFunc:mle};var cle=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:a}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let i=s.reduce((b,T)=>b*T),u=[[0,0]];u.push(...a);for(let b=1+s.length;b<o.shape.length;++b)u.push([0,0]);let p=[],l=qD({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),m=C.getReshaped(l.shape,s,i,!1),c=C.getPermuted(m.length,s.length,!1),d=C.getReshapedPermuted(l.shape,s,i,!1),f=ue({inputs:{x:l},backend:e,attrs:{shape:m}}),h=Ht({inputs:{x:f},backend:e,attrs:{perm:c}}),g=ue({inputs:{x:h},backend:e,attrs:{shape:d}});return p.push(l),p.push(f),p.push(h),p.forEach(b=>e.disposeIntermediateTensorInfo(b)),g},zU={kernelName:Is,backendName:"webgl",kernelFunc:cle};function dle(r){let{inputs:t,backend:e}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=t;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);let i=e.readSync(n.dataId),u=e.readSync(o.dataId),p=e.readSync(s.dataId),l=e.readSync(a.dataId)[0],[m,c,d,f,h]=cz(i,n.shape,n.dtype,u,o.dtype,p,l);return[e.makeTensorInfo(c,n.dtype,m),e.makeTensorInfo([c[0]],o.dtype,d),e.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),e.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var GU={kernelName:Ku,backendName:"webgl",kernelFunc:dle};function fle(r){let{inputs:t,backend:e}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=Array.from(e.readSync(o.dataId)),i=e.readSync(n.dataId),u=Array.from(e.readSync(s.dataId)),[p,l,m]=dz(i,n.shape,n.dtype,a,u);return[e.makeTensorInfo(l,n.dtype,p),e.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}var UU={kernelName:eu,backendName:"webgl",kernelFunc:fle};function hle(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let a=e.readSync(n.dataId),i=e.readSync(o.dataId),u=e.readSync(s.dataId),[p,l]=fI(a,n.shape,n.dtype,i,u,!0);return e.makeTensorInfo(l,n.dtype,p)}var WU={kernelName:Vu,backendName:"webgl",kernelFunc:hle};function gle(r){let{inputs:t,backend:e}=r,{data:n,indices:o,segmentIds:s}=t;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let a=e.readSync(n.dataId),i=e.readSync(o.dataId),u=e.readSync(s.dataId),[p,l]=fI(a,n.shape,n.dtype,i,u);return e.makeTensorInfo(l,n.dtype,p)}var KU={kernelName:Hu,backendName:"webgl",kernelFunc:gle};function ble(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=t,{outputShape:i}=n,{sliceRank:u,numUpdates:p,sliceSize:l,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1;if(s.dtype==="string"){let b=e.bufferSync(o),T=e.bufferSync(s),x=y.decodeString(e.readSync(a.dataId)[0]),I=pz(b,T,i,c,l,p,u,m,x,d);return e.makeTensorInfo(i,I.dtype,I.values)}let f=new zf(p,u,o.shape.length,s.shape.length,m,[c,1],d),h=e.runWebGLProgram(f,[s,o,a],s.dtype),g=ue({inputs:{x:h},backend:e,attrs:{shape:i}});return e.disposeIntermediateTensorInfo(h),g}var VU={kernelName:qu,backendName:"webgl",kernelFunc:ble};function yle(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),p=o.shape.length,l=new Array(p).fill(0),m=o.shape.slice();return u.map(c=>{let d=[...m];d[i]=c;let f=ii({inputs:{x:o},backend:e,attrs:{begin:l,size:d}});return l[i]+=c,f})}var HU={kernelName:Cs,backendName:"webgl",kernelFunc:yle};var qU="return sqrt(x);",Tle=Ae({opSnippet:qU,packedOpSnippet:qU,cpuKernelImpl:fz}),jU={kernelName:Vo,backendName:"webgl",kernelFunc:Tle};var xle="return x * x;",Ile=Ae({opSnippet:xle}),XU={kernelName:gi,backendName:"webgl",kernelFunc:Ile};var YU="return (a - b) * (a - b);",Cle=ft({opSnippet:YU,packedOpSnippet:YU}),ZU={kernelName:jo,backendName:"webgl",kernelFunc:Cle};function kle({inputs:r,attrs:t,backend:e}){let{x:n}=r,o=Ir+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,s=new nn(n.shape,o);return e.runWebGLProgram(s,[n],n.dtype)}var QU={kernelName:vs,backendName:"webgl",kernelFunc:kle};var MC=class{constructor(t,e,n){this.variableNames=["x"];this.outputShape=n;let o=n.length,s=Ve(n.length),a=Ve(n.length),i="";if(o===1)i="coords * strides + begin";else{let u=0;i=n.map((p,l)=>(u++,n.length===1?`coords * strides[${l}] + begin[${l}]`:`coords[${u-1}] * strides[${l}] + begin[${l}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${t});
      ${s} strides = ${s}(${e});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}};function Sle(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:a,strides:i,beginMask:u,endMask:p,ellipsisMask:l,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,p,l,m,c),k;if(h)k=ue({inputs:{x:o},backend:e,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let R=It.computeOutShape(T,x,I),P=ii({inputs:{x:o},backend:e,attrs:{begin:T,size:R}});k=ue({inputs:{x:P},backend:e,attrs:{shape:f}}),e.disposeIntermediateTensorInfo(P)}else if(e.shouldExecuteOnCPU([o])){let P=e.readSync(o.dataId),M=xe(o.shape,o.dtype,P),L=hz(d,M,I,T);k=e.makeTensorInfo(f,o.dtype,L.values)}else{let P=new MC(T,I,d);k=e.runWebGLProgram(P,[o],o.dtype)}let w=ue({inputs:{x:k},backend:e,attrs:{shape:f}});return e.disposeIntermediateTensorInfo(k),w}var JU={kernelName:$a,backendName:"webgl",kernelFunc:Sle};function vle(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:p}=n,{data:l,dataSplits:m}=t,c=e.readSync(l.dataId),d=e.readSync(m.dataId),[f,h]=gz(c,d,o,s,a,i,u,p);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(m.shape,"int32",h)]}var eW={kernelName:bi,backendName:"webgl",kernelFunc:vle};function Ale(r){let{inputs:t,backend:e,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:a}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);let i=e.readSync(s.dataId),u=e.readSync(a.dataId)[0],[p,l,m]=bz(i,u,o),c=l.length;return[e.makeTensorInfo([c,2],"int32",p),e.makeTensorInfo([c],"string",l),e.makeTensorInfo([2],"int32",new Int32Array(m))]}var tW={kernelName:ju,backendName:"webgl",kernelFunc:Ale};function wle(r){let{inputs:t,backend:e,attrs:n}=r,{numBuckets:o}=n,{input:s}=t;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let a=e.readSync(s.dataId),i=yz(a,o);return e.makeTensorInfo(s.shape,"int32",i)}var rW={kernelName:Xu,backendName:"webgl",kernelFunc:wle};var Nle="return tan(x);",Dle=Ae({opSnippet:Nle}),nW={kernelName:Ba,backendName:"webgl",kernelFunc:Dle};var Fle=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Rle=Ae({opSnippet:Fle}),oW={kernelName:Yo,backendName:"webgl",kernelFunc:Rle};var EC=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let a=0;a<n.length;a++)n[a]=t[a]*e[a];this.outputShape=n,this.rank=n.length;let o=Ve(this.rank),s=Ple(t);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function Ple(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${e[o]}, ${r[o]})`);return n.join()}function XD(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=e.readSync(o.dataId),p=o.dtype==="string"?u.map(c=>y.decodeString(c)):u,l=xe(o.shape,o.dtype,p),m=xz(l,s);return e.makeTensorInfo(m.shape,m.dtype,m.values)}let a=new EC(o.shape,s);return e.runWebGLProgram(a,[o],o.dtype)}var sW={kernelName:Dn,backendName:"webgl",kernelFunc:XD};var _C=class{constructor(t){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}];this.outputShape=t,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},LC=class{constructor(t){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}];this.outputShape=t,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function om(r,t){t!==null&&r.disposeIntermediateTensorInfo(t)}function aW(r){let t=1;for(;t<r;)t*=2;return t}function Mle(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:a}=n,i=B().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=B().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),p=o.shape,l=p[p.length-1];if(e.shouldExecuteOnCPU([o])||l<i||s>u){let L=e.readSync(o.dataId),[z,W]=Iz(L,p,o.dtype,s,a);return[e.makeTensorInfo(z.shape,z.dtype,z.values),e.makeTensorInfo(W.shape,W.dtype,W.values)]}if(s===0)return p[p.length-1]=0,[e.makeTensorInfo(p,o.dtype,[]),e.makeTensorInfo(p,"int32",[])];if(l===1)return[o,wu({attrs:{shape:p,dtype:"int32",value:0},backend:e})];let m=e.texData.get(o.dataId),c=m!==null&&m.isPacked,d=c?e.unpackTensor(o):o,h=y.sizeFromShape(p)/l,g=ue({inputs:{x:d},attrs:{shape:[h,l]},backend:e});c&&om(e,d);let b=aW(s),T=aW(l),x=null,I=()=>x===null?[g,g]:[g,x],k=(L,z,W)=>{let V=I(),j=new _C(W),X=[[l],[x===null?1:0],[Number.NEGATIVE_INFINITY],[L],[z]],ee=x;x=e.runWebGLProgram(j,V,"int32",X),om(e,ee)};for(let L=1;L<b;L*=2){let z=L*2;for(let W=L;W>=1;W/=2)k(z,W,[h,T])}for(let L=T;L>b;L/=2){let z=I(),W=new LC([h,L/2]),j=[[l],[x===null?1:0],[b]],H=x;x=e.runWebGLProgram(W,z,"int32",j),om(e,H);let X=b/2,ee=X*2;for(let q=X;q>=1;q/=2)k(ee,q,x.shape)}let w=x;x=ii({inputs:{x},backend:e,attrs:{begin:0,size:[h,s]}}),om(e,w);let R=UD({inputs:{x:g,indices:x},backend:e,attrs:{axis:1,batchDims:1}});om(e,g);let P=p.slice(0,-1);P.push(s),w=x,x=ue({inputs:{x},attrs:{shape:P},backend:e}),om(e,w);let M=R;return R=ue({inputs:{x:R},attrs:{shape:P},backend:e}),om(e,M),[R,x]}var iW={kernelName:Oa,backendName:"webgl",kernelFunc:Mle};var $C=class{constructor(t,e,n,o,s,a){this.variableNames=["Image","Transforms"];this.outputShape=a;let i=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${t} && 0 <= coordX && coordX < ${e}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${e}));
                float mapY = mapCoord(inY, float(${t}));

                if (${i} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function Ele(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:a,fillMode:i,fillValue:u,outputShape:p}=n,[l,m,c,d]=o.shape,[f,h]=p??[m,c],g=[l,f,h,d],b=new $C(m,c,a,i,u,g);return e.runWebGLProgram(b,[o,s],"float32")}var uW={kernelName:za,backendName:"webgl",kernelFunc:Ele};function _le(r){let{inputs:t,attrs:e,backend:n}=r,{axis:o}=e,{x:s}=t;oi(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=n.readSync(s.dataId),{outputValues:i,outputShape:u,indices:p}=Cz(a,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,i),n.makeTensorInfo([p.length],"int32",p)]}var pW={kernelName:rc,backendName:"webgl",kernelFunc:_le};function Lle(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],p=new Array(i-1),l=0;for(let h=0;h<i;h++)h!==s&&(p[l++]=a.shape[h]);let m=[],c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){c[s]=h;let g=ii({inputs:{x:a},backend:e,attrs:{begin:c,size:d}}),b=ue({inputs:{x:g},backend:e,attrs:{shape:p}});f[h]=b,m.push(g)}return m.forEach(h=>e.disposeIntermediateTensorInfo(h)),f}var lW={kernelName:ks,backendName:"webgl",kernelFunc:Lle};var BC=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,o=t.batchSize,s=t.inSize,a=t.numSegments,i=a*Math.ceil(s/n);this.outputShape=[o,i];let u="0.0",p="sumValue",l=Math.floor(n/4)*4,m=n%4,c=`
        sumValue += dot(values, segFilter);
    `,d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${c}
        }

        int inIdx = inOffset + ${l};
        if (${m===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${c}
        } else if (${m===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${c}
        } else if (${m===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${c}
        }
        setOutput(${p});
      }
    `}};function $le(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,segmentIds:s}=t,{numSegments:a}=n,i=o.shape.length,u=[],p=0,l=C.getAxesPermutation([p],i),m=o;l!=null&&(m=Ht({inputs:{x:o},backend:e,attrs:{perm:l}}),u.push(m),p=C.getInnerMostAxes(1,i)[0]);let c=C.segment_util.computeOutShape(m.shape,p,a),d=y.sizeFromShape([m.shape[p]]),f=ue({inputs:{x:m},backend:e,attrs:{shape:[-1,d]}});u.push(f);let h=ou(o.dtype),g=(I,k,w,R,P)=>{let M=I.shape[0],L=I.shape[1],z=C.segment_util.segOpComputeOptimalWindowSize(L,P),W={windowSize:z,inSize:L,batchSize:M,numSegments:P},V=new BC(W,k),j=e.compileAndRun(V,[I,w],R);if(u.push(j),j.shape[1]===P)return j;let H=jD({backend:e,attrs:{start:0,stop:P,step:1,dtype:"float32"}}),X=XD({inputs:{x:H},backend:e,attrs:{reps:[L/z]}});return u.push(H),u.push(X),g(j,k,X,R,P)},b=g(f,"unsortedSegmentSum",s,h,a),T=ue({inputs:{x:b},backend:e,attrs:{shape:c}}),x=T;if(l!=null){u.push(T);let I=C.getUndoAxesPermutation(l);x=Ht({inputs:{x},backend:e,attrs:{perm:I}})}return u.forEach(I=>e.disposeIntermediateTensorInfo(I)),x}var mW={kernelName:Yu,backendName:"webgl",kernelFunc:$le};var Ble=[Qz,e3,t3,r3,o3,s3,a3,i3,l3,m3,c3,d3,f3,h3,g3,b3,y3,T3,x3,I3,C3,S3,v3,A3,F3,P3,M3,zz,_3,$3,B3,O3,z3,G3,U3,W3,K3,V3,H3,X3,Y3,Z3,Q3,J3,eG,tG,rG,nG,oG,sG,aG,iG,uG,pG,lG,cG,dG,fG,hG,bG,yG,TG,xG,IG,CG,kG,SG,vG,Oz,AG,L3,wG,NG,DG,Gz,FG,RG,PG,MG,EG,_G,LG,$G,BG,OG,GG,UG,WG,KG,VG,HG,jG,YG,ZG,QG,JG,eU,sU,Hz,aU,iU,uU,pU,w3,lU,dU,fU,hU,gU,Uz,bU,yU,TU,N3,tU,xU,IU,CU,jz,kU,SU,vU,AU,wU,NU,DU,FU,RU,PU,MU,EU,_U,LU,$U,BU,k3,oU,OU,zU,GU,UU,WU,KU,VU,HU,jU,XU,ZU,QU,JU,eW,tW,rW,nU,Yz,nW,oW,sW,iW,uW,Zz,pW,lW,mW,mU];for(let r of Ble)tu(r);var _p=B();_p.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);_p.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);_p.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);_p.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1);_p.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);_p.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);_p.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);_p.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);var OC=class{constructor(t){this.device=t;this.numUsedBuffers=0;this.numFreeBuffers=0;this.freeBuffers=new Map;this.usedBuffers=new Map;this.numBytesUsed=0;this.numBytesAllocated=0}acquireUploadBuffer(t,e){return this.acquireBuffer(t,e,!0)}acquireBuffer(t,e,n=!1){let o=cW(t,e);if(this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.usedBuffers.has(o)||this.usedBuffers.set(o,[]),this.numBytesUsed+=t,this.numUsedBuffers++,this.freeBuffers.get(o).length>0){this.numFreeBuffers--;let a=this.freeBuffers.get(o).shift();return this.usedBuffers.get(o).push(a),a}this.numBytesAllocated+=t;let s=this.device.createBuffer({size:t,usage:e,mappedAtCreation:n});return this.usedBuffers.get(o).push(s),s}releaseBuffer(t,e,n){if(this.freeBuffers.size===0)return;let o=cW(e,n);this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).push(t),this.numFreeBuffers++,this.numUsedBuffers--;let s=this.usedBuffers.get(o),a=s.indexOf(t);if(a<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(a,1),this.numBytesUsed-=e}releaseUploadBuffer(t,e,n){t.mapAsync(GPUMapMode.WRITE).then(()=>{this.releaseBuffer(t,e,n)},o=>{})}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function cW(r,t){return`${r}_${t}`}var zC=class{constructor(t){this.device=t;this.numUsedTextures=0;this.numFreeTextures=0;this.freeTextures=new Map;this.usedTextures=new Map;this.numBytesUsed=0;this.numBytesAllocated=0}acquireTexture(t,e,n,o){let s=fW(n),a=t*e*s,i=dW(t,e,n,o);if(this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.usedTextures.has(i)||this.usedTextures.set(i,[]),this.numBytesUsed+=a,this.numUsedTextures++,this.freeTextures.get(i).length>0){this.numFreeTextures--;let p=this.freeTextures.get(i).shift();return this.usedTextures.get(i).push(p),p}this.numBytesAllocated+=a;let u=this.device.createTexture({size:[t,e],format:n,usage:o});return this.usedTextures.get(i).push(u),u}releaseTexture(t,e,n,o,s){if(this.freeTextures.size===0)return;let a=dW(e,n,o,s);this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.freeTextures.get(a).push(t),this.numFreeTextures++,this.numUsedTextures--;let i=this.usedTextures.get(a),u=i.indexOf(t);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");i.splice(u,1);let p=fW(o),l=e*n*p;this.numBytesUsed-=l}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.usedTextures.forEach((t,e)=>{t.forEach(n=>{n.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}};function dW(r,t,e,n){return`${r}_${t}_${e}_${n}`}function fW(r){if(r==="rgba8unorm")return 16;throw new Error(`${r} is not supported!`)}function hW(r,t){if(Math.max(...r)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");let e=r.length,n=r.map(s=>`${t}[${s}]`),o=new Array(e-1);o[e-2]=n[e-1];for(let s=e-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}var yW=(r,t,e,n)=>{let o={dtype:n.dtype,shape:n.shape},s=Ole(e,o,t),a=r.createShaderModule({code:s,label:t.constructor.name});return r.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})};function ur(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";if(r===5)return"vec5";if(r===6)return"vec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Js(r){if(r===0)return"x";if(r===1)return"y";if(r===2)return"z";if(r===3)return"w";if(r===4)return"u";if(r===5)return"v";throw Error(`Index ${r} is not yet supported`)}function Ie(...r){let t;switch(r.length){case 0:t=`
        ${Lp()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main();
        }

        fn main()
      `;break;case 1:t=`
        ${Lp()}
        fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                  @builtin(global_invocation_id) GlobalId : vec3<u32>,
                  @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
          localId = LocalId;
          globalId = GlobalId;
          numWorkgroups = NumWorkgroups;
          main(getGlobalIndex());
        }

        fn main(${r[0]} : i32)
      `;break;default:throw Error("Unreachable")}return t}function Lp(){return`
  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
`}function Ole(r,t,e){let n=[];if(n.push(`
      const workGroupSizeX = ${e.workGroupSize[0]}u;
      const workGroupSizeY = ${e.workGroupSize[1]}u;
      const workGroupSizeZ = ${e.workGroupSize[2]}u;

      var<private> localId: vec3<u32>;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${xW(e)?"  return i32(globalId.x);":`  let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
                   localId.y * workGroupSizeX + localId.x;
               let workGroupID = (globalId - localId)/vec3<u32>(
                   workGroupSizeX, workGroupSizeY, workGroupSizeZ);

               return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
                   workGroupID.y * numWorkgroups.x + workGroupID.x) *
                   (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
                   localInvocationIndex);
        `}
      }
    `),e.isFromPixels)return n.push(`
        struct Uniform {
          size            : i32,
          numChannels     : i32,
          outShapeStrides : vec2<i32>,
        };

        @group(0) @binding(0) var<storage, read_write> result: array<${Gf(t.dtype,e.isVec4)}>;
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `),[gW,n.join(`
`),bW(t.shape),e.getUserCode()].join(`
`);let o="struct Uniforms { NAN : f32, ";e.variableNames.forEach((c,d)=>{let f=ur(r[d].shape.length);o+=`${c.charAt(0).toLowerCase()+c.slice(1)}Shape : ${f}, `}),o+=`outShape : ${ur(t.shape.length)}, `;let a=t.shape.length-1;o+=`
         outShapeStrides: ${ur(a)}, `,e.size&&(o+="size : i32, "),e.uniforms&&(o+=e.uniforms),o+="};",o=Hle(o),n.push(o),e.atomic?n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):n.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${Gf(t.dtype,e.isVec4)}>;
    `),e.variableNames.forEach((c,d)=>{n.push(`
      @group(0) @binding(${1+d}) var<storage, read> ${c}: array<${e.variableTypes?e.variableTypes[d]:Gf(r[d].dtype,e.isVec4)}>;
        `)}),o!==""&&n.push(`
      @group(0) @binding(${1+e.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);let u=Wle(t.shape,e.dispatchLayout),p=[gW,n.join(`
`),bW(t.shape),u,Kle(t.shape.length)];e.atomic||p.push(Vle(t.shape,t.dtype,e.isVec4));let l=r.map((c,d)=>Ule(c,t.shape,e.variableTypes?e.variableTypes[d]==="vec4<f32>":e.isVec4,e.dispatchLayout.x.length===t.shape.length)).join(`
`);return p.push(l),p.push(e.getUserCode()),p.join(`
`)}function TW(r,t,e,n){let o=r.shaderKey;if(r.isFromPixels)return o;let s=e.map(l=>l.dtype).concat(n.dtype),a=e.map(l=>C.getBroadcastDims(l.shape,n.shape)),i=e.map(l=>y.arraysEqual(l.shape,n.shape)).join("_"),u=a.map(l=>l.join("_")).join(";"),p=xW(r)?"flatDispatch":"";return o+="_"+(r.workGroupSize?r.workGroupSize.join(","):"")+t.map(l=>l.length).join(",")+s.join(",")+r.variableNames.join(",")+u+i+p,o}var gW=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let modulo: i32 = a % b;
    if (sign < 0. && modulo != 0) {
      res = res - 1;
    }
    return res;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isnan(val[0]), isnan(val[1]), isnan(val[2]), isnan(val[3]));
  }
`;function bW(r){let t=r.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";let e=y.computeStrides(r),n=ur(t),o=[];for(let a=0;a<t;a++)o.push(`d${a}`);if(e.length===1)return`    fn getCoordsFromIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let s;return s="var index2 = index;"+e.map((a,i)=>{let u=`let ${o[i]} = index2 / uniforms.outShapeStrides.${Js(i)}`,p=i===e.length-1?`let ${o[i+1]} = index2 - ${o[i]} * uniforms.outShapeStrides.${Js(i)}`:`index2 = index2 - ${o[i]} * uniforms.outShapeStrides.${Js(i)}`;return`${u}; ${p};`}).join(""),`
    fn getCoordsFromIndex(index : i32) -> ${n} {
      ${s}
      return ${n}(${o.join(",")});
    }
  `}function zle(r,t){let e=r.name,n=r.shape.length,o=ur(n),s="get"+e.charAt(0).toUpperCase()+e.slice(1),a=["d0","d1","d2","d3","d4","d5"].slice(0,n),i=a.map(l=>`${l} : i32`).join(", ");if(n<1)return t?`
        fn ${s}() -> vec4<f32> {
          return vec4<f32>(${e}[0]);
        }
      `:`
      fn ${s}() ->f32 {
        return f32(${e}[0]);
      }
    `;let u=`uniforms.${e.charAt(0).toLowerCase()+e.slice(1)}Shape`,p=`${n}D`;return n===0&&(p="1D"),t?`
      fn ${s}(${i}) -> vec4<f32> {
        return vec4<f32>(${e}[getIndexFromCoords${p}(${o}(${a.join(",")}),
          ${u}) / 4]);
      }
      `:`
    fn ${s}(${i}) -> f32 {
      return f32(${e}[getIndexFromCoords${p}(${o}(${a.join(",")}),
        ${u})]);
    }
   `}function Gle(r,t,e,n){let o=r.name,s=o.charAt(0).toUpperCase()+o.slice(1),a="get"+s+"ByOutput",i=r.shape.length,u=t.length,p=ur(u);if(y.arraysEqual(r.shape,t)&&n)return e?`
      fn ${a}Index(globalIndex : i32) -> vec4<f32> {
        return vec4<f32>(${o}[globalIndex]);
      }

      fn ${a}Coords(coords : ${p}) -> vec4<f32> {
        return vec4<f32>(${o}[${u>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);
      }
      `:`
    fn ${a}Index(globalIndex : i32) -> f32 {
      return f32(${o}[globalIndex]);
    }

    fn ${a}Coords(coords : ${p}) -> f32 {
      return f32(${o}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}]);
    }
    `;let l=C.getBroadcastDims(r.shape,t),m=u-i,c="";if(i===0)return e?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      return get${s}();
    }

    fn ${a}Coords(coords : ${p}) -> vec4<f32> {
      return get${s}();
    }
  `:`
    fn ${a}Index(globalIndex : i32) -> f32{
      return get${s}();
    }

    fn ${a}Coords(coords : ${p}) -> f32{
      return get${s}();
    }
  `;u<2&&l.length>=1?c="coords = 0;":c=l.map(g=>`coords.${Js(g+m)} = 0;`).join(`
`);let d="";if(u<2&&i>0)d="coords";else if(u>1){let g=ur(i),b=r.shape.map((T,x)=>`coords.${Js(x+m)}`).join(", ");d=`${g}(${b})`}else d="coords";let f=`uniforms.${o.charAt(0).toLowerCase()+o.slice(1)}Shape`,h=`${i}D`;return e?`
    fn ${a}Index(globalIndex : i32) -> vec4<f32> {
      var coords = getCoordsFromIndex(globalIndex);
      ${c}
      return ${o}[getIndexFromCoords${h}(${d}, ${f}) / 4];
    }

    fn ${a}Coords(coordsIn : ${p}) -> vec4<f32> {
      var coords = coordsIn;
      ${c}
      return ${o}[getIndexFromCoords${h}(${d}, ${f}) / 4];
    }
  `:`
  fn ${a}Index(globalIndex : i32) -> f32 {
    var coords = getCoordsFromIndex(globalIndex);
    ${c}
    return f32(${o}[getIndexFromCoords${h}(${d}, ${f})]);
  }

  fn ${a}Coords(coordsIn : ${p}) -> f32 {
    var coords = coordsIn;
    ${c}
    return f32(${o}[getIndexFromCoords${h}(${d}, ${f})]);
  }
`}function Ule(r,t,e,n){let o=zle(r,e);return r.shape.length<=t.length&&(o+=Gle(r,t,e,n)),o}function Wle(r,t){let{x:e,y:n=[],z:o=[]}=t,s=r.length;if(e.length===s)return`fn getOutputCoords() -> ${ur(s)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="",i=[e,n,o],u=0;for(let c=0;c<i.length;c++){let d=i[c];if(d.length!==0)if(u+=d.length,d.length===1)a+=`let d${d[0]} = i32(globalId[${c}]);`;else{let f=hW(d,"uniforms.outShape");a+=`var index${c} = i32(globalId[${c}]);`;for(let h=0;h<f.length;h++)a+=`let d${d[h]} = index${c} / ${f[h]};`,h===f.length-1?a+=`let d${d[h+1]} = index${c} - d${d[h]} * ${f[h]};`:a+=`index${c} = index${c} - d${d[h]} * ${f[h]};`}}let p=[];for(let c=0;c<u;c++)p.push(`d${c}`);let l=ur(u),m=`fn getOutputCoords() -> ${l} {
  ${a}
`;return p.length===0?m+=`return ${l}(0); }`:m+=`return ${l}(${p.join(",")}); }`,m}function Kle(r){let t="";switch(r){case 0:case 1:t+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:t+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:t+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:t+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:t+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:t+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:y.assert(!1,()=>`Unsupported ${r}D shape`);break}return t}function xW(r){return r.dispatch[1]===1&&r.dispatch[2]===1}function Gf(r,t){return r==="float32"?t?"vec4<f32>":"f32":r==="int32"||r==="bool"?t?"vec4<i32>":"i32":r}function Vle(r,t,e){let n=r.length,o=Gf(t,e),s;if(e?s=`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {
      result[flatIndex] = ${o}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {
      result[flatIndex] = ${o}(value);
    }`:s=`fn setOutputAtIndex(flatIndex : i32, value : f32) {
      result[flatIndex] = ${o}(value);
    }
    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {
      result[flatIndex] = ${o}(value);
    }`,n>=2){let a=["d0","d1","d2","d3","d4","d5"].slice(0,n),i=ur(n);e?s+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex / 4, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex / 4, value);
      }
    `:s+=`
      fn setOutputAtCoords(${a.map(u=>`${u} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndex(flatIndex, value);
      }
      fn setOutputAtCoordsI32(${a.map(u=>`${u} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputIndexFromCoords(${i}(${a.join(", ")}));
        setOutputAtIndexI32(flatIndex, value);
      }
    `}return s}function Hle(r){let t=/(\w+)\s*:\s*vec(5|6)/g;r=r.replace(t,n=>"@align(16) "+n);let e=/vec(5|6)\s*,\s*(\w+)/g;return r=r.replace(e,(n,o,s)=>`vec${o}, @align(16) ${s}`),r}var e0={};Xe(e0,{ArrayBufferToTypedArray:()=>QD,GPUBytesPerElement:()=>ZD,MatMulProgramType:()=>JD,computeDispatch:()=>ge,computeWorkGroupInfoForMatMul:()=>YD,computeWorkGroupSizeForConv2d:()=>Rg,computeWorkPerThreadForConv2d:()=>Pg,flatDispatchLayout:()=>ve,isWebGPUSupported:()=>Mg,tilesFitEvenlyIntoShape:()=>jle});var sm=r=>{let t=1;for(let e=0;e<r.length;e++)t*=r[e];return t};function jle(r,t){if(r.length!==t.length)throw new Error(`Cannot compute whether rank ${r.length} tiles fit evenly into rank ${t.length} shape - ranks must match.`);return t.every((e,n)=>e%r[n]===0)}function ge(r,t,e=[1,1,1],n=[1,1,1]){let[o,s,a]=[Math.ceil(sm(r.x.map(i=>t[i]))/(e[0]*n[0])),r.y?Math.ceil(sm(r.y.map(i=>t[i]))/(e[1]*n[1])):1,r.z?Math.ceil(sm(r.z.map(i=>t[i]))/(e[2]*n[2])):1];return[o,s,a]}function YD(r,t,e,n=!1){let o=[8,8,1],s=[4,4,1];return n||(r<=8&&(s[1]=1),t<=16&&e<=16&&(o[0]=4)),{workGroupSize:o,elementsPerThread:s}}function Rg(r,t,e=!1){if(e)return[8,8,1];let n=sm(r.x.map(s=>t[s])),o=sm(r.y.map(s=>t[s]));return n<=4?[4,16,1]:o<=4?[16,4,1]:[16,16,1]}function Pg(r,t,e=!1){if(e)return[4,4,1];let n=sm(r.x.map(s=>t[s])),o=sm(r.y.map(s=>t[s]));return n<=4?[1,2,1]:o<=4?[2,1,1]:[2,2,1]}function ve(r){return{x:r.map((t,e)=>e)}}function ZD(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function QD(r,t){if(t==="float32")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(r));throw new Error(`Unknown dtype ${t}`)}function Mg(){return(typeof window<"u"||typeof WorkerGlobalScope<"u")&&!!navigator.gpu}var JD=(s=>(s[s.MatMulReduceProgram=0]="MatMulReduceProgram",s[s.MatMulSplitKProgram=1]="MatMulSplitKProgram",s[s.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",s[s.MatMulPackedProgram=3]="MatMulPackedProgram",s[s.MatMulMax=4]="MatMulMax",s))(JD||{});var Xle=B().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),Yle=(r,t)=>{let e=r.limits.maxComputeWorkgroupsPerDimension,n=t.dispatchLayout,o=t.dispatch;if(o.every(a=>a<=e))return o;y.assert(o[0]>e&&n.y===void 0&&n.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let s=Math.ceil(Math.sqrt(o[0]));return s>e?(s=Math.ceil(Math.cbrt(o[0])),y.assert(s<=e,()=>"Total dispatch size exceeds WebGPU maximum."),[s,s,s]):[s,s,1]},t0=class extends no{constructor(e){super();this.commandQueueOwnedIds=new WeakSet;this.dispatchNumberInEncoder=0;this.disposed=!1;this.downloadWaitMs=0;this.tensorDataPendingDisposal=[];this.stagingPendingDisposal=[];this.uniformPendingDisposal=[];this.uploadWaitMs=0;if(!Mg())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query"),this.bufferManager=new OC(this.device),this.textureManager=new zC(this.device),this.tensorMap=new ma(this,Mn()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),B().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return t0.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,n=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;let o=this.tensorMap.get(e);if(this.decRef(e),!n&&o.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;let{complexTensorInfos:s}=this.tensorMap.get(e);return s!=null&&(this.disposeData(s.real.dataId,n),this.disposeData(s.imag.dataId,n)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){let n=this.tensorMap.get(e);if(!(!n||!n.resourceInfo)){if("texture"in n.resourceInfo){let o=n.resourceInfo;o.texture instanceof GPUTexture&&this.textureManager.releaseTexture(o.texture,o.width,o.height,o.format,o.usage),o.texture=null}else{let o=n.resourceInfo;this.bufferManager.releaseBuffer(o.buffer,o.size,o.usage),o.buffer=null}n.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let n=this.tensorMap.get(e);n.refCount++}decRef(e){if(this.tensorMap.has(e)){let n=this.tensorMap.get(e);n.refCount--}}write(e,n,o){if(o==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:o,shape:n,values:e,refCount:1}),s}move(e,n,o,s,a){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:o,values:n,refCount:a})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,n){let o=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,o,0,n),this.submitQueue(),await o.mapAsync(GPUMapMode.READ);let s=o.getMappedRange().slice(0);return o.unmap(),o!=null&&this.bufferManager.releaseBuffer(o,n,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),B().getBool("WEBGPU_USE_PROFILE_TOOL")&&(y.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,n){let o=this.tensorMap.get(e);return this.releaseResource(e),o.values=n,o.values}readSync(e){let n=this.tensorMap.get(e),{values:o}=n;if(o==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return o}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let n=this.tensorMap.get(e),{values:o}=n;if(o!=null)return this.convertAndCacheOnCPU(e,o);let s;if(n.dtype==="complex64"){let a=await Promise.all([this.read(n.complexTensorInfos.real.dataId),this.read(n.complexTensorInfos.imag.dataId)]),i=a[0],u=a[1];s=C.mergeRealAndImagArrays(i,u)}else{let a=n.resourceInfo,i=await this.getBufferData(a.buffer,a.size);s=QD(i,n.dtype)}return this.convertAndCacheOnCPU(e,s),s}readToGPU(e){let n=this.tensorMap.get(e),{values:o,dtype:s,shape:a,resourceInfo:i}=n;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw o!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");let u=i.size,p=this.bufferManager.acquireBuffer(u,i.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(i.buffer,0,p,0,u),this.submitQueue();let l=this.makeTensorInfo(a,s),m=Mn().makeTensorFromTensorInfo(l),c=this.tensorMap.get(l.dataId);return c.resourceInfo={size:u,usage:this.defaultGpuBufferUsage(),buffer:p},{tensorRef:m,buffer:p,bufSize:u}}bufferSync(e){let n=this.readSync(e.dataId);if(e.dtype==="string")try{let o=n.map(s=>y.decodeString(s));return xe(e.shape,e.dtype,o)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xe(e.shape,e.dtype,n)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");let n=this.activeTimers,o=[],s=!1;this.programTimersStack==null?(this.programTimersStack=o,s=!0):this.activeTimers.push(o),this.activeTimers=o,e();let a=y.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=y.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,s&&(this.programTimersStack=null);let u={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},p=await Promise.all(a);return u.kernelMs=y.sum(p),u.getExtraProfileInfo=()=>p.map((l,m)=>({name:i[m],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,u}makeTensorInfo(e,n,o){return n==="string"&&o!=null&&o.length>0&&y.isString(o[0])&&(o=o.map(a=>y.encodeString(a))),{dataId:this.write(o,e,n),shape:e,dtype:n}}tensorToBinding(e){if(!e)return null;let n=this.tensorMap.get(e.dataId);if("texture"in n.resourceInfo){let s=n.resourceInfo;return s.texture instanceof GPUExternalTexture?s.texture:s.texture.createView()}let o=n.resourceInfo;return{offset:0,size:o.size,buffer:o.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){let n=this.tensorMap.get(e);if(n.resourceInfo)return;let o=ZD(n.dtype)*y.sizeFromShape(n.shape),s=this.bufferManager.acquireBuffer(o,this.defaultGpuBufferUsage());if(n.resourceInfo={size:o,usage:this.defaultGpuBufferUsage(),buffer:s},n.values){let a=this.bufferManager.acquireUploadBuffer(o,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),i=a.getMappedRange();n.dtype==="int32"||n.dtype==="bool"?new Int32Array(i).set(n.values):new Float32Array(i).set(n.values),a.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(a,0,s,0,o);let u={size:o,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:a};this.stagingPendingDisposal.push(u)}}makeUniforms(e){let n=0,o=0,s=[];e.forEach(p=>{p.data.length===0&&(p.data=[1]);let l;switch(p.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:y.assert(!1,()=>`Unsupported ${p.data.length}D shape`)}(o===5||o===6)&&(l=16),n=Math.ceil(n/l)*l,o=p.data.length,s.push(n),n+=p.data.length*4});let a=new ArrayBuffer(n);e.forEach((p,l)=>{let m=s[l];p.type==="int32"?new Int32Array(a,m,p.data.length).set(p.data):p.type==="uint32"?new Uint32Array(a,m,p.data.length).set(p.data):new Float32Array(a,m,p.data.length).set(p.data)});let i=this.bufferManager.acquireBuffer(n,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(i,0,a,0,n);let u={size:n,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:i};return this.uniformPendingDisposal.push(u),{offset:0,size:n,buffer:i}}runWebGPUProgram(e,n,o,s,a){if(a||(a=this.makeTensorInfo(e.outputShape,o)),y.sizeFromShape(a.shape)===0)return this.tensorMap.get(a.dataId).values=y.getTypedArrayFromDType(a.dtype,0),a;this.uploadToGPU(a.dataId),e.dispatch=Yle(this.device,e);let i=[],u=[];if(!e.isFromPixels){i.push({type:"float32",data:[NaN]}),u=n.concat(a).map(T=>T.shape);let g="int32";u.map(T=>{i.push({type:g,data:T})});let b=y.computeStrides(a.shape);if(i.push({type:g,data:b}),e.size){let T=y.sizeFromShape(e.outputShape);i.push({type:g,data:[e.isVec4?T/4:T]})}}let p=n.map((g,b)=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(g.dataId),{dtype:this.tensorMap.get(g.dataId).dtype,shape:g.shape,name:e.variableNames[b]}}),l=TW(e,u,p,a),m;l in this.pipelineCache?m=this.pipelineCache[l]:(m=yW(this.device,e,p,a),this.pipelineCache[l]=m),s&&(i=[...i,...s]);let c=[this.tensorToBinding(a),...n.map(g=>this.tensorToBinding(g)),this.makeUniforms(i)],d=this.device.createBindGroup({layout:m.getBindGroupLayout(0),entries:c.map((g,b)=>({binding:b,resource:g}))});this.ensureCommandEncoderReady();let f=this.getComputePass(),h=this.activeTimers!=null;return h&&this.supportTimeQuery&&f.writeTimestamp(this.querySet,0),f.setPipeline(m),f.setBindGroup(0,d),f.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),h&&this.supportTimeQuery&&f.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,n.forEach(g=>{this.commandQueueOwnedIds.add(g.dataId)}),this.commandQueueOwnedIds.add(a.dataId),B().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),h&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),a}async getTimeFromQuerySet(e){let n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),o=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,n,0),this.currentCommandEncoder.copyBufferToBuffer(n,0,o,0,16),this.submitQueue(),await o.mapAsync(GPUMapMode.READ);let s=new BigUint64Array(o.getMappedRange()),a=Number(s[1]-s[0]);return o.unmap(),this.bufferManager.releaseBuffer(o,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),a/1e6}shouldExecuteOnCPU(e,n=Xle){return B().getBool("WEBGPU_CPU_FORWARD")&&e.every(o=>this.tensorMap.get(o.dataId).resourceInfo==null&&y.sizeFromShape(o.shape)<n)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}},Uf=t0;Uf.nextDataId=0;Mg()&&rp("webgpu",async()=>{B().set("CHECK_COMPUTATION_FOR_ERRORS",!1);let r={powerPreference:B().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(r),e=t.limits,n={},o=t.features.has("timestamp-query");n.requiredLimits={maxComputeWorkgroupStorageSize:e.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:e.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:e.maxStorageBufferBindingSize},o&&(n.requiredFeatures=["timestamp-query"]);let s=await t.requestDevice(n);return new Uf(s)},3);var Zle=`
  if (isnan(a)) { return a; }
  if (isnan(b)) { return b; }
  `,IW=`
  if (isNaN.r) {
    resultTemp.r = valueForNaN;
  }
  if (isNaN.g) {
    resultTemp.g = valueForNaN;
  }
  if (isNaN.b) {
    resultTemp.b = valueForNaN;
  }
  if (isNaN.a) {
    resultTemp.a = valueForNaN;
  }
  `,CW=`
  let isNaN = isnanVec4(a) | isnanVec4(b);
  ${IW}
  `,Qle="return a + b;",Jle="return areal * breal - aimag * bimag;",eme="return areal * bimag + aimag * breal;",tme="return a / b;",rme="return a * b;",nme="return (a - b) * (a - b);",ome="return a - b;",sme="return f32(a == b);",ame="return vec4<f32>(a == b);",ime="return f32(a > b);",ume="return vec4<f32>(a > b);",pme="return f32(a >= b);",lme="return vec4<f32>(a >= b);",mme="return f32(a < b);",cme="return vec4<f32>(a < b);",dme="return f32(a <= b);",fme="return vec4<f32>(a <= b);",hme="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",gme=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,bme=`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `,yme=`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `,Tme=`
  if (isnan(a) || isnan(b)) {
    return 1.0;
  }
  return f32(a != b);
`,xme=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
  ${CW}

  return resultTemp;
`,Ime=`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `,Cme=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = a < vec4<f32>(0.0) & floor(b) < b;
  let valueForNaN = uniforms.NAN;
  ${IW}
  return resultTemp;
  `,kme="if (a < 0.0) { return b * a; }  return a;",Sme=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `;function r0(r,t,e="uniforms.NAN"){let n=t?CW:Zle;return t?`
    let valueForNaN = ${e};
    var resultTemp = vec4<f32>(${r}(a, b));
    `+n+`
    return resultTemp;
  `:n+`
    return ${r}(a, b);
  `}function Wf(r,t){switch(r){case 0:return rme;case 1:return Qle;case 2:return r0("atan2",t);case 3:return ome;case 4:return tme;case 5:return t?ame:sme;case 6:return t?ume:ime;case 7:return t?lme:pme;case 8:return t?cme:mme;case 9:return t?fme:dme;case 10:return t?gme:hme;case 11:return t?xme:Tme;case 12:return nme;case 13:return t?yme:bme;case 15:return t?Sme:kme;case 16:return r0("max",t);case 17:return r0("min",t);case 14:return t?Cme:Ime;case 18:return Jle;case 19:return eme;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var vme="return abs(a);",Ame="return ceil(a);",wme="return cos(a);",Nme=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,Dme="return exp(a) - 1.0;",Fme="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",Rme=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,Pme="return exp(a);",Mme="return floor(a);",Eme="return f32(isnan(a));",_me="return a;",Lme=`if (a < 0.0) { return 1.0/0.0; }
  return log(a);`,$me="return f32(!(a >= 1.0));",Bme="return -a;",Ome="if (a < 0.0) { return uniforms.alpha * a; } return a;",zme=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,Gme="return 1.0 / a;",Ume="return select(a, 0.0, a < 0.0);",Wme="return clamp(a, 0.0, 6.0);",Kme="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",Vme=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,Hme="return 1.0/sqrt(a);",qme="return 1.0 / (1.0 + exp(-1.0 * a));",jme="return sin(a);",Xme=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,Yme="return sqrt(a);",Zme="return a * a;",Qme=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Jme="return f32(i32((a)));";function Nu(r,t){switch(r){case 0:return vme;case 2:return wme;case 3:return Nme;case 1:return Ame;case 4:return t?Rme:Fme;case 5:return Pme;case 6:return Dme;case 7:return Mme;case 8:return Eme;case 9:return _me;case 10:return Lme;case 11:return $me;case 12:return Bme;case 15:return t?zme:Ome;case 16:return Gme;case 13:return t?Vme:Ume;case 14:return t?Kme:Wme;case 17:return Hme;case 20:return qme;case 18:return jme;case 19:return Xme;case 21:return Yme;case 22:return Zme;case 23:return Qme;case 24:return Jme;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var nr=r=>{switch(r){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(`${r}-component is not supported.`)}};function vn(r,t=!1,e=!1,n=3){if(r===null)return"";let o="";if(r==="linear")o=Nu(9);else if(r==="relu")o=Nu(13,e);else if(r==="elu")o=Nu(4,e);else if(r==="relu6")o=Nu(14,e);else if(r==="prelu")o=Wf(15,e);else if(r==="sigmoid")o=Nu(20,e);else if(r==="leakyrelu")o=Nu(15,e);else throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`);let a=nr(e?4:1),i="";return t?i=`
      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${o}
      }`:i=`
      fn activation(a : ${a}, coords : vec${n}<i32>) -> ${a} {
        ${o}
      }`,i}function ea(r,t){return`
      ${r?"value = value + getBiasByOutputCoords(coords);":""}
      ${t?"value = activation(value, coords);":""}
      `}function n0(r,t,e,n,o=!1,s=!1,a=!1,i=1){y.assert(e&&i===1||!e,()=>`transposeA ${e} is not compatible with component size ${i}`);let u=`
      let batch = ${r?"0":"batchIn"};
      let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
      ${e?`value = A[(batch * batchASize + col * uniforms.aShape[2] + row) / ${i}];`:`value = A[(batch * batchASize + row * uniforms.aShape[2] + col) / ${i}];`}

    `,p;return n===!1?p=`value = B[(batch * batchBSize + row * uniforms.bShape[2] + col) / ${i}];`:p=`value = B[(batch * batchBSize + col * uniforms.bShape[2] + row) / ${i}];`,`
  fn mm_readA(batchIn: i32, row: i32, colIn: i32) -> ${nr(i)} {
    var value = ${nr(i)}(0.0);
    let col = colIn * ${i};
    ${o&&a?u:`
    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${u}
    }
    `}
    return value;
  }

  fn mm_readB(batchIn: i32, row: i32, colIn: i32) -> ${nr(i)} {
    let col = colIn * ${i};
    let batch = ${t?"0":"batchIn"};
    let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
    var value = ${nr(i)}(0.0);
    ${p}
    return value;
  }
  `}function Eg(r,t,e,n,o,s,a=!1,i=!1,u=!1,p=1){return`
  ${n0(e,n,o,s,a,i,u,p)}
  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${nr(p)}) {
    let col = colIn * ${p};
    ${a&&i?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${ea(r,t)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}var ece=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / InnerElementSize + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / InnerElementSize + inputCol);
        `,tce=(r,t)=>r?`
        let ACached0 = mm_Asub[k * InnerElementSize][localRow];
        let ACached1 = mm_Asub[k * InnerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * InnerElementSize + 2][localRow];
        ${t===3?"":"let ACached3 = mm_Asub[k * InnerElementSize + 3][localRow];"}
        for (var i = 0; i < RowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }`:`
        for (var i = 0; i < RowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${t===3?"":"acc[i] = BCached3 * ACached.w + acc[i];"}
        }`;function am(r,t,e=!1,n=32,o=!1,s=32,a=!1){let i=t[1]*r[1],u=t[0]*r[0],p=e?i:n,l=e?n:i,m=p/t[0],c=n/t[1];return y.assert((e&&m===4&&r[1]===4||!e&&(m===3||m===4))&&p%t[0]===0&&n%t[1]===0&&r[0]===4,()=>`If transposeA ${e} is true, innerElementSize ${m} and workPerThread[1] ${r[1]} must be 4.
          Otherwise, innerElementSize ${m} must be 3 or 4.
      tileAWidth ${p} must be divisible by workGroupSize[0]${t[0]}. tileInner ${n} must be divisible by workGroupSize[1] ${t[1]}. ColPerThread ${r[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${m}<f32>, ${p/m}>, ${l}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/r[0]}>, ${n}>;

  const RowPerThread = ${r[1]};
  const ColPerThread = ${r[0]};
  const InnerElementSize = ${m};
  const TileInner = ${n};

  @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
  fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
            @builtin(global_invocation_id) GlobalId : vec3<u32>,
            @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
            @builtin(workgroup_id) workgroupId: vec3<u32>) {
    localId = LocalId;
    globalId = GlobalId;
    numWorkgroups = NumWorkgroups;

    let localRow = i32(localId.y);
    let tileRow = ${a?"0":"localRow * RowPerThread"};
    let tileCol = i32(localId.x);

    let globalRow = ${a?"0":"i32(globalId.y) * RowPerThread"};
    let globalCol = i32(globalId.x);
    let batch = ${o?"0":"i32(globalId.z)"};
    let globalRowStart = i32(workgroupId.y) * ${i};

    let numTiles = ${o?`${Math.ceil(s/n)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
    var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

    var acc: array<vec4<f32>, RowPerThread>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${c};
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${ece(e)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / InnerElementSize; k = k + 1) {
            let BCached0 = mm_Bsub[k * InnerElementSize][tileCol];
            let BCached1 = mm_Bsub[k * InnerElementSize + 1][tileCol];
            let BCached2 = mm_Bsub[k * InnerElementSize + 2][tileCol];
            ${m===3?"":"let BCached3 = mm_Bsub[k * InnerElementSize + 3][tileCol];"}

            ${tce(e,m)}
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}var rce=r=>r?`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,nce=r=>r?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function im(r,t,e=!1,n=32,o=!1,s=32){let a=r[1]*t[1],i=r[0]*t[0],u=e?a:n,p=e?n:a;y.assert(p%t[1]===0&&u%t[0]===0&&n%t[1]===0,()=>`tileAHight ${p} must be divisible by workGroupSize[1]${t[1]}, tileAWidth ${u} must be divisible by workGroupSize[0]${t[0]}, tileInner ${n} must be divisible by workGroupSize[1]${t[1]}`);let l=p/t[1],m=u/t[0],c=n/t[1];return`
    var<workgroup> mm_Asub : array<array<f32, ${u}>, ${p}>;
    var<workgroup> mm_Bsub : array<array<f32, ${i}>, ${n}>;
    const RowPerThread = ${r[1]};
    const ColPerThread = ${r[0]};
    const TileInner = ${n};

    @compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)
    fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
              @builtin(global_invocation_id) GlobalId : vec3<u32>,
              @builtin(num_workgroups) NumWorkgroups: vec3<u32>,
              @builtin(workgroup_id) workgroupId: vec3<u32>) {
      localId = LocalId;
      globalId = GlobalId;
      numWorkgroups = NumWorkgroups;

      let tileRow = i32(localId.y) * RowPerThread;
      let tileCol = i32(localId.x) * ColPerThread;

      let globalRow = i32(globalId.y) * RowPerThread;
      let globalCol = i32(globalId.x) * ColPerThread;
      let batch = ${o?"0":"i32(globalId.z)"};
      let globalRowStart = i32(workgroupId.y) * ${a};

      let numTiles = ${o?`${Math.ceil(s/n)}`:"(uniforms.dimInner - 1) / TileInner + 1"};
      var kStart = ${o?`i32(globalId.z) * ${s}`:"0"};

      var acc : array<array<f32, ColPerThread>, RowPerThread>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let tileRowA = i32(localId.y) * ${l};
      let tileColA = i32(localId.x) * ${m};
      let tileRowB = i32(localId.y) * ${c};
      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${l}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${m}; innerCol = innerCol + 1) {
            let inputRow = tileRowA + innerRow;
            let inputCol = tileColA + innerCol;
            ${rce(e)}
          }
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${c}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batch,
              kStart + inputRow,
              globalCol + innerCol);
          }
        }
        kStart = kStart + TileInner;
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ColPerThread>;
        for (var k = 0; k < TileInner; k = k + 1) {
          for (var inner = 0; inner < ColPerThread; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            ${nce(e)}
            for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ColPerThread; innerCol = innerCol + 1) {
          mm_write(batch, globalRow + innerRow, globalCol + innerCol,
              acc[innerRow][innerCol]);
        }
      }
    }
  `}var oce=r=>r?`
      mm_readA(batch, colA, globalRow),
      mm_readA(batch, colA + 1, globalRow),
      mm_readA(batch, colA + 2, globalRow),
      mm_readA(batch, colA + 3, globalRow)
  `:`
      mm_readA(batch, globalRow, colA),
      mm_readA(batch, globalRow, colA + 1),
      mm_readA(batch, globalRow, colA + 2),
      mm_readA(batch, globalRow, colA + 3)
  `;function sce(r,t=!1){return y.assert(r[1]===1&&r[2]===1,()=>`A linear work group size is required. But got ${r}.`),`
    const TileSize = ${r[0]*4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${Ie()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;
      let batch = i32(globalId.z);
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${oce(t)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(batch, rowB, globalCol),
                              mm_readB(batch, rowB + 1, globalCol),
                              mm_readB(batch, rowB + 2, globalCol),
                              mm_readB(batch, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}var GC=class{constructor(t,e,n,o,s=!1,a=!1,i=null,u=null,p=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0]};let l=s?t[1]:t[2];if(this.isVec4=(l%4===0&&!s||e[1]%4===0&&s)&&e[2]%4===0&&!a,this.isVectorA=e[1]===1&&!s,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workGroupSize=[32,1,1];else{let d=YD(e[1],l,e[2],s);this.workGroupSize=d.workGroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread);let m=i!=null,c=p!=null;m&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=a,this.addBias=m,this.activation=u,this.hasPreluActivationWeights=c,this.batchAEqualOne=n,this.batchBEqualOne=o,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(e[1],e[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${s}_${a}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getShapeFit(t,e,n){let o=this.workGroupSize[1]*this.elementsPerThread[1],s=this.workGroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workGroupSize[0]*4:this.tileInner=s;let a=t%o===0,i=e%s===0,u=n%this.tileInner===0;return[a,i,u]}getUserCode(){return`
      ${vn(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${Eg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?am(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA):this.isVectorA?sce(this.workGroupSize,this.transposeA):im(this.elementsPerThread,this.workGroupSize,this.transposeA,this.tileInner)}
    `}};function ace(){return`
    var<workgroup> sumValues : array<f32, workGroupSizeX>;
    ${Ie()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}var UC=class{constructor(t,e,n,o=!1,s=!1,a=null,i=null,u=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";this.workGroupSize=[256,1,1];this.outputShape=t,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize);let p=a!=null,l=u!=null;p&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=s,this.addBias=p,this.activation=i,this.hasPreluActivationWeights=l,this.batchAEqualOne=e,this.batchBEqualOne=n,this.shaderKey=`matMulReduce_${this.activation}_${o}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${vn(this.activation,this.hasPreluActivationWeights)}
      ${Eg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${ace()}
    `}};function ice(r){let t=r[1],e=r[0],n=t>e?t:e;return`
  var<workgroup> mm_Asub : array<array<f32, ${n}>, ${t}>;
  var<workgroup> mm_Bsub : array<array<f32, ${e}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${Ie()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batch, globalRow, globalColA);
    var regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${n};
    globalRowB = globalRowB + ${n};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batch, globalRow, globalColA);
      regB0 = mm_readB(batch, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batch, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${n};
      globalRowB = globalRowB + ${n};

      for (var k = 0; k < ${n}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}var WC=class{constructor(t,e,n,o=!1,s=!1,a=null,i=null,u=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";this.workGroupSize=[16,8,1];this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]/this.workGroupSize[1]),n[0]];let p=a!=null;p&&this.variableNames.push("bias");let l=u!=null;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=o,this.transposeB=s,this.addBias=p,this.activation=i,this.hasPreluActivationWeights=l,this.batchAEqualOne=t[0]===1,this.batchBEqualOne=e[0]===1,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${o}_${s}_${this.batchAEqualOne}_${this.batchBEqualOne}`}getUserCode(){return`
      ${vn(this.activation,this.hasPreluActivationWeights)}
      ${Eg(this.addBias,this.activation,this.batchAEqualOne,this.batchBEqualOne,this.transposeA,this.transposeB)}
      ${ice(this.workGroupSize)}
    `}};var KC=class{constructor(t,e,n,o,s=!1,a=!1){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,";this.workGroupSize=[8,8,1];this.atomic=!0;this.isVec4=!1;this.splitedDimInner=128;y.assert(t[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(s&&this.outputShape[1]%4===0||!s&&e%4===0)&&this.outputShape[2]%4===0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=ge(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],e],this.workGroupSize,this.elementsPerThread),this.transposeA=s,this.transposeB=a,this.batchAEqualOne=n,this.batchBEqualOne=o,this.shaderKey=`matMulSplitK_${s}_${a}_${n}_${o}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){let t=o=>`
      for (var i = 0; i < ${o}; i = i + 1)
      {
        var oldValue = atomicLoad(&(result[flatIndex + i]));
        var exchanged = false;
        for (; !exchanged;) {
          let newValueF32 = bitcast<f32>(oldValue) + ${o>1?"value[i]":"value"};
          let newValue = bitcast<i32>(newValueF32);
          let res = atomicCompareExchangeWeak(&(result[flatIndex + i]), oldValue, newValue);
          oldValue = res.old_value;
          exchanged = res.exchanged;
        }
      }
      `,e=this.isVec4?4:1;return`
      ${n0(this.batchAEqualOne,this.batchBEqualOne,!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${nr(e)}) {
        let col = colIn * ${e};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          ${t(e)}
        }
      }
      ${this.isVec4?am(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner):im(this.elementsPerThread,this.workGroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}},VC=class{constructor(t,e=null,n=null,o=null){this.uniforms="";this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.addBias=e!=null,this.hasPreluActivationWeights=o!=null,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${n}`}getUserCode(){return`
    ${vn(this.activation,this.hasPreluActivationWeights)}
    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${ea(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}};var HC=class{constructor(t){this.variableNames=[];this.outputShape=[];this.uniforms="value : f32,";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}};function as(r){let{backend:t,attrs:e}=r,{shape:n,value:o}=e,{dtype:s}=e;if(s=s||y.inferDtype(o),s==="string"){let a=y.getArrayFromDType(s,y.sizeFromShape(n));return a.fill(o),t.makeTensorInfo(n,s,a)}else{let a=new HC(n),i=[{type:"float32",data:[o]}];return t.runWebGPUProgram(a,[],s,i)}}var kW={kernelName:fi,backendName:"webgpu",kernelFunc:as};function Re(r){let{inputs:t,attrs:e}=r,{x:n}=t,{shape:o}=e,s=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(o,s),i=y.sizeFromShape(a);return y.assert(s===i,()=>`The new shape (${a}) has ${i} elements and the old shape (${n.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var SW={kernelName:ys,backendName:"webgpu",kernelFunc:Re};function Kf({a:r,b:t,transposeA:e,transposeB:n,backend:o,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:i=0,activation:u=null}){let p=r.shape.length,l=t.shape.length,m=e?r.shape[p-2]:r.shape[p-1],c=n?t.shape[l-1]:t.shape[l-2],d=e?r.shape[p-1]:r.shape[p-2],f=n?t.shape[l-2]:t.shape[l-1],h=r.shape.slice(0,-2),g=t.shape.slice(0,-2),b=y.sizeFromShape(h),T=y.sizeFromShape(g),I=Nr.assertAndGetBroadcastShape(r.shape.slice(0,-2),t.shape.slice(0,-2)).concat([d,f]);y.assert(m===c,()=>`Error in matMul: inner shapes (${m}) and (${c}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let k=e?[b,m,d]:[b,d,m],w=n?[T,f,c]:[T,c,f],R=Re({inputs:{x:r},backend:o,attrs:{shape:k}}),P=Re({inputs:{x:t},backend:o,attrs:{shape:w}}),M=[R,P],L=Math.max(b,T),z=b===1,W=T===1,V=[R,P],j=[{type:"int32",data:[d]},{type:"int32",data:[f]},{type:"int32",data:[m]}],H,X,ee=[L,d,f],q=B().get("WEBGPU_MATMUL_PROGRAM_TYPE");switch(q<0&&(d*f<=128?q=0:L===1&&d<=128&&f<=48&&c>=2e3?q=1:d<=16&&(f<=512||c>=2*f)||f<=16&&(d<=512||m>=2*d)?q=2:q=3),q){case 0:H=new UC(ee,z,W,e,n,s,u,a);break;case 1:{if(X=as({backend:o,attrs:{shape:ee,value:0,dtype:r.dtype}}),H=new KC(ee,c,z,W,e,n),s||u){X=o.runWebGPUProgram(H,V,r.dtype,j,X);let se=new VC(X.shape,s,u,a),ie=null,pe=[X];s&&pe.push(s),a&&pe.push(a),u==="leakyrelu"&&(ie=[{type:"float32",data:[i]}],se.uniforms+=" alpha : f32,");let ae=o.runWebGPUProgram(se,pe,X.dtype,ie);M.push(X);let ye=Re({inputs:{x:ae},backend:o,attrs:{shape:I}});M.push(ae);for(let fe of M)o.disposeData(fe.dataId);return ye}break}case 2:H=new WC(k,w,ee,e,n,s,u,a);break;case 3:H=new GC(k,ee,z,W,e,n,s,u,a);break;default:throw new Error(`Unsupported MatMulProgramType ${q}.`)}s&&V.push(s),a&&V.push(a),u==="leakyrelu"&&(j.push({type:"float32",data:[i]}),H.uniforms+=" alpha : f32,"),X=o.runWebGPUProgram(H,V,r.dtype,j,X);let ne=Re({inputs:{x:X},backend:o,attrs:{shape:I}});M.push(X);for(let se of M)o.disposeData(se.dataId);return ne}function uce(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=t,{transposeA:u,transposeB:p,activation:l,leakyreluAlpha:m}=n;return Kf({a:o,b:s,transposeA:u,transposeB:p,backend:e,bias:a,preluActivationWeights:i,leakyreluAlpha:m,activation:l})}var vW={kernelName:As,backendName:"webgpu",kernelFunc:uce};var _g=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.workGroupSize=[128,1,1];this.size=!0;this.outputShape=C.assertAndGetBroadcastShape(e,n),this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${t}`,this.op=t}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Wf(this.op,!1)}
      }

      ${Ie("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};var um=class{constructor(t,e,n){this.size=!0;this.variableNames=["A","B"];this.outputShape=C.assertAndGetBroadcastShape(e,n),this.dispatchLayout=ve(this.outputShape),this.op=t,this.useSharedMemoryWithA=e.length<=1&&n.length>1&&e[0]<128,this.useSharedMemoryWithB=n.length<=1&&e.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:e[0],this.shaderKey=`binary_${this.type}_${t}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workGroupSize=[256,1,1],this.workPerThread=1):(y.arraysEqual(e,n)&&y.sizeFromShape(e)%4===0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${t}`,this.workGroupSize=[128,1,1]),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1])}getUserCode(){let t,e=this.isVec4?"vec4<f32>":"f32",n=`
    fn binaryOperation(a : ${e}, b : ${e}) -> ${e} {
      ${Wf(this.op,this.isVec4)}
    };
    `;if(this.type==="shared"){let o=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",s=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${o}];`:`let a = sharedBuf[${o}];
          let b = getBByOutputIndex(index);`;t=`
        ${n}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${Ie("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${s}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else t=`
       ${n}
       ${Ie("index")} {
         if (index < uniforms.size) {
           let a = getAByOutputIndex(index);
           let b = getBByOutputIndex(index);
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return t}};function fr(r){let{inputs:t}=r,{x:e}=t;return r.backend.incRef(e.dataId),{dataId:e.dataId,shape:e.shape,dtype:e.dtype}}var AW={kernelName:Vn,backendName:"webgpu",kernelFunc:fr};function ui(r){let{inputs:t,backend:e}=r,{real:n,imag:o}=t,s=e.makeTensorInfo(n.shape,"complex64"),a=e.tensorMap.get(s.dataId),i=fr({inputs:{x:n},backend:e}),u=fr({inputs:{x:o},backend:e});return a.complexTensorInfos={real:i,imag:u},s}var wW={kernelName:_u,backendName:"webgpu",kernelFunc:ui};var ta=class{constructor(t,e){this.variableNames=["A"];this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=e,this.shaderKey=`unary_${e}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Nu(this.op,!1)}
      }
      ${Ie("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}};function ut({opType:r,cpuKernelImpl:t,dtype:e}){return({inputs:n,backend:o})=>{let{x:s}=n,a=o,i=e||s.dtype;if(a.shouldExecuteOnCPU([s])&&t!=null){let p=a.tensorMap.get(s.dataId),l=t(p.values,i);return a.makeTensorInfo(s.shape,i,l)}let u=new ta(s.shape,r);return a.runWebGPUProgram(u,[s],i)}}function Tt({opType:r,cpuKernelImpl:t,supportsComplex:e=!1,dtype:n}){return({inputs:o,backend:s})=>{let{a,b:i}=o,u=s;if(e&&a.dtype==="complex64"){let m=u.tensorMap.get(a.dataId),c=u.tensorMap.get(i.dataId),d,f;if(r!==0)[d,f]=[[m.complexTensorInfos.real,c.complexTensorInfos.real],[m.complexTensorInfos.imag,c.complexTensorInfos.imag]].map(g=>{let[b,T]=g,x={dataId:b.dataId,dtype:b.dtype,shape:a.shape},I={dataId:T.dataId,dtype:T.dtype,shape:i.shape},k=new um(r,a.shape,i.shape);return u.runWebGPUProgram(k,[x,I],$t(b.dtype,T.dtype))});else{let g=new _g(18,a.shape,i.shape),b=new _g(19,a.shape,i.shape),T=[{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:a.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape}];d=u.runWebGPUProgram(g,T,"float32"),f=u.runWebGPUProgram(b,T,"float32")}let h=ui({inputs:{real:d,imag:f},backend:u});return u.disposeData(d.dataId),u.disposeData(f.dataId),h}let p=n||$t(a.dtype,i.dtype);if((a.dtype==="string"||i.dtype==="string"||u.shouldExecuteOnCPU([a,i]))&&t!=null){let m=u.tensorMap.get(a.dataId).values,c=u.tensorMap.get(i.dataId).values,d=a.dtype==="string"?C.fromUint8ToStringArray(m):m,f=a.dtype==="string"?C.fromUint8ToStringArray(c):c,[h,g]=t(a.shape,i.shape,d,f,p);return u.makeTensorInfo(g,p,h)}let l=new um(r,a.shape,i.shape);return u.runWebGPUProgram(l,[a,i],p)}}var{addImpl:NW,castImpl:DW,ceilImpl:FW,concatImpl:RW,equalImpl:PW,expImpl:MW,expm1Impl:EW,floorImpl:_W,gatherNdImpl:LW,gatherV2Impl:$W,greaterEqualImpl:BW,greaterImpl:OW,lessEqualImpl:zW,lessImpl:GW,logImpl:UW,maxImpl:WW,maximumImpl:KW,minimumImpl:VW,multiplyImpl:HW,negImpl:qW,notEqualImpl:jW,prodImpl:XW,rangeImpl:YW,rsqrtImpl:ZW,scatterImpl:QW,simpleAbsImpl:JW,sliceImpl:eK,stridedSliceImpl:tK,stringNGramsImpl:rK,subImpl:nK,tileImpl:oK,topKImpl:sK,transposeImpl:aK,uniqueImpl:NAr}=yf;var pce=ut({opType:0,cpuKernelImpl:JW}),iK={kernelName:ls,backendName:"webgpu",kernelFunc:pce};var lce=Tt({opType:1,cpuKernelImpl:NW,supportsComplex:!0}),uK={kernelName:Nn,backendName:"webgpu",kernelFunc:lce};var qC=class{constructor(t){this.workPerThread=4;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t[0],this.variableNames=t.map((e,n)=>`T${n}`),this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let t=[];this.variableNames.forEach(o=>{t.push(`let v${o} = get${o}ByOutputCoords(coords);`)});let e=this.variableNames.map(o=>`v${o}`).join(" + ");return`
      ${Ie("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${t.join(`
        `)}
            setOutputAtIndex(flatIndex, ${e});
          }
        }
      }
    `}};function mce(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return fr({inputs:{x:n[0]},backend:e});let o=n.map(i=>i.dtype).reduce((i,u)=>$t(i,u)),s=n.map(i=>i.shape),a=new qC(s);return e.runWebGPUProgram(a,n,o)}var pK={kernelName:so,backendName:"webgpu",kernelFunc:mce};var Vf=class{constructor(t,e,n){this.workGroupSize=[64,1,1];this.variableNames=["x"];this.uniforms="infinityValue : f32,";this.size=!0;let o=[e];this.op=n==="min"?"<":">";let[s,a]=C.computeOutAndReduceShapes(t,o);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=ve(this.outputShape),y.sizeFromShape(a)<32||y.sizeFromShape(s)>1e3?(this.type="plain",this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize)):(this.type="shared",this.dispatch=ge(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=t,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){let t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${Js(this.inputShape.length-1)}`,e=()=>{let n="";if(this.outputShape.length===1)this.inputShape.length!==1&&(n+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)n+=`outputCoords.${Js(o)},`;return n};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `}

      ${Ie("index")} {
        let outputIndex = index / i32(workGroupSizeX);
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = getX(${e()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${e()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${e()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}};var jC=class{constructor(t,e){this.variableNames=["A"];this.workGroupSize=[16,16,1];let n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[e[o]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`
      const TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;
      ${Lp()}
      fn _start(@builtin(local_invocation_id) localId : vec3<u32>,
                @builtin(workgroup_id) workgroupId : vec3<u32>) {
        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);
        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = A[y * width + x];
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);
        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}};var XC=class{constructor(t,e){this.variableNames=["A"];this.workPerThread=4;this.workGroupSize=[64,1,1];this.size=!0;let n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[e[o]];this.outputShape=n,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=e,this.shaderKey=`transpose_${e}`}getUserCode(){let t=ur(this.outputShape.length),e=cce(this.newDim);return`
      ${Ie("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${t}(${e}), uniforms.aShape)]);
          }
        }
      }
    `}};function cce(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=new Array(t);for(let n=0;n<r.length;n++)e[r[n]]=`resRC.${Js(n)}`;return e.join()}function An(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{perm:s}=n,a=e,i=o.shape.length,u=new Array(i);for(let l=0;l<u.length;l++)u[l]=o.shape[s[l]];if(e.shouldExecuteOnCPU([o])){let m=a.tensorMap.get(o.dataId).values,c=aK(m,o.shape,o.dtype,s,u);return e.makeTensorInfo(u,o.dtype,c)}if(o.shape.length===2&&y.arraysEqual(s,[1,0])){let l=new jC(o.shape,s);return a.runWebGPUProgram(l,[o],o.dtype)}let p=new XC(o.shape,s);return a.runWebGPUProgram(p,[o],o.dtype)}var lK={kernelName:Fn,backendName:"webgpu",kernelFunc:An};function dce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,p=[];i!=null&&(u=An({inputs:{x:o},backend:e,attrs:{perm:i}}),p.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let l=new Vf(u.shape,a[0],"max"),m=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],c=e.runWebGPUProgram(l,[u],"int32",m);return p.forEach(d=>e.disposeData(d.dataId)),c}var mK={kernelName:ao,backendName:"webgpu",kernelFunc:dce};function fce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s}=n,a=y.parseAxisParam(s,o.shape),i=C.getAxesPermutation(a,o.shape.length),u=o,p=[];i!=null&&(u=An({inputs:{x:o},backend:e,attrs:{perm:i}}),p.push(u),a=C.getInnerMostAxes(a.length,u.shape.length)),C.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let l=new Vf(u.shape,a[0],"min"),m=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],c=e.runWebGPUProgram(l,[u],"int32",m);return p.forEach(d=>e.disposeData(d.dataId)),c}var cK={kernelName:di,backendName:"webgpu",kernelFunc:fce};var hce=Tt({opType:2}),dK={kernelName:fa,backendName:"webgpu",kernelFunc:hce};var Lg=class{constructor(t,e){this.variableNames=["x"];this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,";this.workGroupSize=[128,1,1];this.size=!0;this.outputShape=t.outShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${e}`,this.poolType=e}getUserCode(){let t="resultValue = max(value, resultValue);";this.poolType==="avg"&&(t="resultValue = resultValue + value; count = count + 1.0;");let e="resultValue";return this.poolType==="avg"&&(e="resultValue / count"),`
      ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${t}
            }
          }

          setOutputAtIndex(index, ${e});
        }
      }
    `}};var YC=class{constructor(t){this.variableNames=["x"];this.uniforms="stride : vec2<i32>,";this.workGroupSize=[256,1,1];this.size=!0;this.outputShape=t.outShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}};var ZC=class{constructor(t,e){this.workGroupSize=[64,1,1];this.variableNames=["x"];this.uniforms="reduceSize : i32,";this.size=!0;this.inputShape=[t.batchSize,t.inSize];let[n]=C.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=n.length===0?[1]:n,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=e,this.shaderKey=`reduce_${e}`}getUserCode(){let t="",e="0.0";this.reduceType==="min"||this.reduceType==="max"?(t=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,e="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?t=" bestValue = bestValue + candidate; ":this.reduceType==="prod"&&(t=" bestValue = bestValue * candidate; ",e="1.0");let n=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${Ie("index")} {
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${e};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x[offset + k]);
           ${t}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${t}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n}
        }
       }
     `}};function Ei(r,t,e,n,o){let s=r.shape.length,a=[],i=y.parseAxisParam(t,r.shape),u=i,p=C.getAxesPermutation(u,s),l=r;p!=null&&(l=An({inputs:{x:r},attrs:{perm:p},backend:o}),u=C.getInnerMostAxes(u.length,s),a.push(l)),C.assertAxesAreInnerMostDims(n,u,s);let[m,c]=C.computeOutAndReduceShapes(l.shape,u),d=m;e&&(d=C.expandShapeToKeepDim(m,i));let f;if((n==="max"||n==="prod")&&o.shouldExecuteOnCPU([l])){let h=o.tensorMap.get(l.dataId).values;switch(n){case"max":let g=WW(h,y.sizeFromShape(c),d,r.dtype);f=o.makeTensorInfo(d,r.dtype,g);break;case"prod":let{outVals:b,outShape:T,outDtype:x}=XW(l.shape,l.dtype,h,u);f=o.makeTensorInfo(T,x,b);break;default:throw new Error(`${n} CPU implementation is not yet supported.`)}}else{let h=y.sizeFromShape(c),b=y.sizeFromShape(l.shape)/h,T={windowSize:h,inSize:h,batchSize:b,outSize:1},x=n==="mean"?"float32":ou(r.dtype),I=[{type:"int32",data:[h]}],k=new ZC(T,n),w=o.runWebGPUProgram(k,[l],x,I);a.push(w),f=Re({inputs:{x:w},attrs:{shape:d},backend:o})}return a.forEach(h=>o.disposeData(h.dataId)),f}function $g(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reductionIndices:s,keepDims:a}=n;return Ei(o,s,a,"max",e)}var fK={kernelName:Ao,backendName:"webgpu",kernelFunc:$g};function o0(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{keepDims:s,axis:a}=n;return Ei(o,a,s,"mean",e)}var hK={kernelName:Do,backendName:"webgpu",kernelFunc:o0};function QC(r,t,e,n){if(t.filterWidth===1&&t.filterHeight===1&&y.arraysEqual(t.inShape,t.outShape))return fr({inputs:{x:r},backend:n});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&t.batchSize===1&&t.padInfo.type==="VALID"){let a=r.shape.length,i=Re({inputs:{x:r},backend:n,attrs:{shape:[r.shape[a-3]*r.shape[a-2],r.shape[a-1]]}}),u;e==="avg"?u=o0({inputs:{x:i},backend:n,attrs:{axis:0,keepDims:!1}}):(y.assert(e==="max",()=>`Invalid pool type ${e}`),u=$g({inputs:{x:i},backend:n,attrs:{reductionIndices:0,keepDims:!1}}));let p=Re({inputs:{x:u},backend:n,attrs:{shape:t.outShape}});return n.disposeData(i.dataId),n.disposeData(u.dataId),p}let o,s=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return t.filterHeight===1&&t.filterWidth===1?o=new YC(t):(e==="avg"?o=new Lg(t,"avg"):(y.assert(e==="max",()=>`Invalid pool type ${e}`),o=new Lg(t,"max")),s.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),n.runWebGPUProgram(o,[r],r.dtype,s)}function gce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,p=1,l=C.computePool2DInfo(o.shape,s,a,p,i,u);return QC(o,l,"avg",e)}var gK={kernelName:io,backendName:"webgpu",kernelFunc:gce};function bce(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:a,transposeB:i}=n;return Kf({a:o,b:s,transposeA:a,transposeB:i,backend:e})}var bK={kernelName:uo,backendName:"webgpu",kernelFunc:bce};var JC=class{constructor(t,e){this.variableNames=["source"];this.workPerThread=1;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.rank=e.length,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=t,this.uniforms=`start : ${ur(t.length)}, `,this.shaderKey="slice"}getUserCode(){let t=ur(this.rank),e=yce(this.rank),n;return this.start.length===1?n=this.outputShape.map((s,a)=>"sourceLoc = uniforms.start + coords;"):n=this.outputShape.map((s,a)=>`sourceLoc.${s0[a]} = uniforms.start.${Js(a)} + coords.${s0[a]};`),`
      ${Ie("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${t};
          let coords = getCoordsFromIndex(index);
          ${n.join(`
`)}
          setOutputAtIndex(index, getSource(${e}));
        }
      }
    `}},s0=["x","y","z","w","u","v"];function yce(r){if(r===1)return"sourceLoc";if(r<=6)return s0.slice(0,r).map(t=>`sourceLoc.${t}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}function pi(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,size:a}=n,[i,u]=It.parseSliceParams(o,s,a);if(It.assertParamsValid(o,i,u),e.shouldExecuteOnCPU([o])||o.dtype==="string"){let m=e.tensorMap.get(o.dataId),c=eK(m.values,i,u,o.shape,o.dtype);return e.makeTensorInfo(u,o.dtype,c)}if(y.sizeFromShape(u)===0)return e.makeTensorInfo(u,o.dtype,[]);let p=new JC(i,u),l=[{type:"int32",data:i}];return e.runWebGPUProgram(p,[o],o.dtype,l)}var yK={kernelName:xs,backendName:"webgpu",kernelFunc:pi};var Tce=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:a}=n;y.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((T,x)=>T*x),u=C.getReshaped(o.shape,s,i),p=C.getPermuted(u.length,s.length),l=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(l,a,s.length),d=[],f=Re({inputs:{x:o},backend:e,attrs:{shape:u}}),h=An({inputs:{x:f},backend:e,attrs:{perm:p}}),g=Re({inputs:{x:h},backend:e,attrs:{shape:l}}),b=pi({inputs:{x:g},backend:e,attrs:{begin:m,size:c}});return d.push(f),d.push(h),d.push(g),d.forEach(T=>e.disposeData(T.dataId)),b},TK={kernelName:ms,backendName:"webgpu",kernelFunc:Tce};var a0=Tt({opType:11,dtype:"bool",cpuKernelImpl:jW}),xK={kernelName:Na,backendName:"webgpu",kernelFunc:a0};function Du(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.tensorMap.get(n.dataId);return fr({inputs:{x:o.complexTensorInfos.real},backend:e})}var IK={kernelName:Wu,backendName:"webgpu",kernelFunc:Du};function CK(r,t){let e=new ta(r.shape,24),n=t.runWebGPUProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function i0(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return fr({inputs:{x:o},backend:e});let a=Ct(o.shape),i=i0({inputs:{x:o},backend:e,attrs:{dtype:"float32"}}),u=ui({inputs:{real:i,imag:a},backend:e});return a.dispose(),e.disposeData(i.dataId),u}if(o.dtype==="complex64"){let a=Du({inputs:{input:o},backend:e}),i=i0({inputs:{x:a},backend:e,attrs:{dtype:s}});return e.disposeData(a.dataId),i}if(!y.hasEncodingLoss(o.dtype,s)){let a=fr({inputs:{x:o},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(e.shouldExecuteOnCPU([o])){let a=e.tensorMap.get(o.dataId).values,[i,u,p]=DW(a,o.shape,o.dtype,s);return e.makeTensorInfo(i,u,p)}if(s==="int32")return CK(o,e);if(s==="bool"){let a=e.makeTensorInfo([],"bool",y.getTypedArrayFromDType("bool",1)),u=a0({inputs:{a:o,b:a},backend:e});return e.disposeData(a.dataId),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var kK={kernelName:Wn,backendName:"webgpu",kernelFunc:i0};var xce=ut({opType:1,cpuKernelImpl:FW}),SK={kernelName:po,backendName:"webgpu",kernelFunc:xce};var ek=class{constructor(t){this.variableNames=["A"];this.uniforms="minVal : f32, maxVal : f32,";this.workPerThread=4;this.workGroupSize=[64,1,1];this.isVec4=!0;this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${Ie("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isnan(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputAtIndex(index, clampedValue);
        }
      }
    `}};var tk=class{constructor(t){this.variableNames=["A"];this.uniforms="minVal : f32, maxVal : f32,";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${Ie("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function Ice(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:a}=n,i,u=[{type:"float32",data:[s]},{type:"float32",data:[a]}];return y.sizeFromShape(o.shape)%4===0?i=new ek(o.shape):i=new tk(o.shape),e.runWebGPUProgram(i,[o],o.dtype,u)}var vK={kernelName:Kn,backendName:"webgpu",kernelFunc:Ice};var rk=class{constructor(t){this.uniforms="";this.workPerThread=4;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=C.computeOutShape(t,1),this.variableNames=t.map((e,n)=>`T${n}`),this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=t.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){let t=[];if(this.offsetLength>0){t.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)t.push(`else if (yC < uniforms.offset${[s]}){ setOutputAtCoords(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);let n=this.offsetLength,o=this.offsetLength-1;t.push(`else { setOutputAtCoords(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${o})); }`)}else t.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${Ie("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${t.join(`
        `)}
          }
        }
      }
    `}};function pm(r){let{inputs:t,backend:e}=r,{input:n}=t,o=e.tensorMap.get(n.dataId);return fr({inputs:{x:o.complexTensorInfos.imag},backend:e})}var AK={kernelName:zu,backendName:"webgpu",kernelFunc:pm};function Hf(r,t,e){let n=r[0].dtype;if(n==="complex64"){let f=r.map(x=>Du({inputs:{input:x},backend:e})),h=r.map(x=>pm({inputs:{input:x},backend:e})),g=Hf(f,t,e),b=Hf(h,t,e),T=ui({inputs:{real:g,imag:b},backend:e});return f.forEach(x=>e.disposeData(x.dataId)),h.forEach(x=>e.disposeData(x.dataId)),e.disposeData(g.dataId),e.disposeData(b.dataId),T}let o=e.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let f=r.map(k=>{let w=y.sizeFromShape(k.shape.slice(t));return Re({inputs:{x:k},backend:e,attrs:{shape:[-1,w]}})}),h=f.map(k=>({vals:e.readSync(k.dataId),shape:k.shape})),g=C.computeOutShape(f.map(k=>k.shape),1),b=f[0].shape[0]===1,T=RW(h,g,n,b),x=C.computeOutShape(r.map(k=>k.shape),t),I=e.makeTensorInfo(x,n,T);return f.forEach(k=>e.disposeData(k.dataId)),I}let s=e.device.limits.maxStorageBuffersPerShaderStage-1;if(r.length>s){let f=[];for(let g=0;g<r.length;g+=s){let b=r.slice(g,g+s);f.push(Hf(b,t,e))}let h=Hf(f,t,e);for(let g of f)e.disposeData(g.dataId);return h}let{tensors2D:a,outShape:i}=Cce(r,t,e),u=a.map(f=>f.shape),p=new rk(u),l=[],m=new Array(u.length-1);if(m.length>0){m[0]=u[0][1],l.push({type:"int32",data:[m[0]]});for(let f=1;f<m.length;f++)m[f]=m[f-1]+u[f][1],l.push({type:"int32",data:[m[f]]})}let c=e.runWebGPUProgram(p,a,a[0].dtype,l);a.forEach(f=>e.disposeData(f.dataId));let d=Re({inputs:{x:c},backend:e,attrs:{shape:i}});return e.disposeData(c.dataId),d}function Cce(r,t,e){let n=C.computeOutShape(r.map(s=>s.shape),t);return{tensors2D:r.map(s=>Re({inputs:{x:s},backend:e,attrs:{shape:[y.sizeFromShape(s.shape.slice(0,t)),y.sizeFromShape(s.shape.slice(t))]}})),outShape:n}}function u0(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n,s=y.parseAxisParam(o,t[0].shape)[0],a=C.computeOutShape(t.map(p=>p.shape),s);if(y.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let i=t.filter(p=>y.sizeFromShape(p.shape)>0);if(i.length===1)return fr({inputs:{x:i[0]},backend:e});let u=i.map(p=>p.shape);return C.assertParamsConsistent(u,s),Hf(i,s,e)}var wK={kernelName:cs,backendName:"webgpu",kernelFunc:u0};function kce(r,t,e,n,o=!1,s=null,a=!1,i=4,u=4,p=4){let l=M=>{switch(M){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${M} is not supported.`)}},m=M=>{switch(M){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${M} is not supported.`)}},c=r?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,d=r?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,f=r?"uniforms.xShape[1]":"uniforms.xShape[2]",h=r?"uniforms.xShape[2]":"uniforms.xShape[3]",g=r?"row":"col",b=r?"col":"row",T=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${g} / outWidth;
      let outCol = ${g} % outWidth;

      let WRow = ${b} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${b} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];
      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];
      let xCh = ${b} % inChannels;
      var resData = ${nr(i)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${f} && xCol >= 0 && xCol < ${h}) {
        ${c}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${l(i)}
      }
      return resData;`,x=r?t&&n?`
      let col = colIn * ${i};
      ${T}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${T}
      }
      return ${nr(i)}(0.0);`:n&&e?`
      let col = colIn * ${i};
      ${T}`:`
      let col = colIn * ${i};
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${T}
      }
      return ${nr(i)}(0.0);`,I=`${m(u)}`,k=nr(p),w=r?nr(i):nr(u),R=r?nr(u):nr(i);return`
      ${vn(s,a,p===4,4)}
      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${w} {
        ${r?x:I}
      }

      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${R} {
        ${r?I:x}
      }

      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${k}) {
        let col = colIn * ${p};
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${r?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${d}
        ${ea(o,s)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}var nk=class{constructor(t,e,n,o,s=!1,a=null,i=!1){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,";this.outputShape=t.outShape,this.isChannelsLast=t.dataFormat==="channelsLast",this.isVec4=((t.inChannels%4===0||t.inChannels%3===0)&&this.isChannelsLast||t.outWidth%4===0&&!this.isChannelsLast)&&t.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workGroupSize=Rg(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Pg(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&t.inChannels%4!==0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),s&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),i&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights")),this.addBias=s,this.activation=a,this.hasPreluActivationWeights=i,this.tileAOuter=this.workGroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workGroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workGroupSize[0]*this.innerElementSize,this.workGroupSize[1]),this.fitAOuter=e%this.tileAOuter===0,this.fitBOuter=n%this.tileBOuter===0,this.fitInner=o%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}`}getUserCode(){let t=this.isVec4?am(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner):im(this.elementsPerThread,this.workGroupSize,!this.isChannelsLast,this.tileInner),e=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${kce(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,e[0],e[1],e[2])}
    ${t}
  `}};function NK(r,t){let e=r.length;return e>=3?t?[...r.slice(0,-3),r[e-3]*r[e-2],r[e-1]]:[...r.slice(0,-3),r[e-3],r[e-2]*r[e-1]]:!t&&e===1&&r[0]>1?[r[0],1]:null}function Sce({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=e.dataFormat==="channelsLast",p=!u,l=!1,m=u&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID",c=[],d,f;if(m){let b=e.inHeight*e.inWidth*e.inChannels;d=Re({inputs:{x:r},backend:n,attrs:{shape:[1,e.batchSize,b]}}),f=Re({inputs:{x:t},backend:n,attrs:{shape:[1,b,e.outChannels]}})}else d=Re({inputs:{x:r},backend:n,attrs:{shape:u?[e.batchSize,e.inHeight*e.inWidth,e.inChannels]:[e.batchSize,e.inChannels,e.inHeight*e.inWidth]}}),f=Re({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});if(c.push(d),c.push(f),s!=null){let b=NK(s.shape,u);b!=null&&(s=Re({inputs:{x:s},backend:n,attrs:{shape:b}}),c.push(s))}if(o!=null){let b=NK(o.shape,u);b!=null&&(o=Re({inputs:{x:o},backend:n,attrs:{shape:b}}),c.push(o))}let h=Kf({a:u?d:f,b:u?f:d,transposeA:p,transposeB:l,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a}),g=Re({inputs:{x:h},backend:n,attrs:{shape:e.outShape}});c.push(h);for(let b of c)n.disposeData(b.dataId);return g}function ok({x:r,filter:t,convInfo:e,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:i=null}){let u=o!=null,p=s!=null,l=e.dataFormat==="channelsLast";if(l&&e.filterHeight===e.inHeight&&e.filterWidth===e.inWidth&&e.padInfo.type==="VALID"||e.filterHeight===1&&e.filterWidth===1&&e.dilationHeight===1&&e.dilationWidth===1&&e.strideHeight===1&&e.strideWidth===1&&(e.padInfo.type==="SAME"||e.padInfo.type==="VALID"))return Sce({x:r,filter:t,convInfo:e,backend:n,bias:o,activation:i,preluActivationWeights:s,leakyreluAlpha:a});let c=l?e.outHeight*e.outWidth:e.outChannels,d=l?e.outChannels:e.outHeight*e.outWidth,f=e.filterHeight*e.filterWidth*e.inChannels,h=[e.padInfo.top,e.padInfo.left],g=[{type:"int32",data:[e.filterHeight,e.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[e.strideHeight,e.strideWidth]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[c]},{type:"int32",data:[d]},{type:"int32",data:[f]}],b=new nk(e,c,d,f,u,i,p),T=[],x=[r,t];u&&(!l&&o.shape.length===1&&(o=Re({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}}),T.push(o)),x.push(o)),p&&(!l&&s.shape.length===1&&(s=Re({inputs:{x:s},backend:n,attrs:{shape:[s.shape[0],1,1]}}),T.push(s)),x.push(s)),i==="leakyrelu"&&(g.push({type:"float32",data:[a]}),b.uniforms+=" alpha : f32,");let I=n.runWebGPUProgram(b,x,r.dtype,g);for(let k of T)n.disposeData(k.dataId);return I}function vce(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dataFormat:u,dilations:p,dimRoundingMode:l}=e,m=C.convertConv2DDataFormat(u),c=C.computeConv2DInfo(o.shape,s.shape,a,p,i,l,!1,m);return ok({x:o,filter:s,convInfo:c,backend:n})}var DK={kernelName:lo,backendName:"webgpu",kernelFunc:vce};function Ace(r=4){let t=s=>{switch(s){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${s} is not supported.`)}},n=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${nr(r)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${nr(r)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${r}];`}
      }
      return ${nr(r)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${nr(r)} {
    let col = colIn * ${r};
    ${n}
  }

  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${nr(r)} {
    let col = colIn * ${r};
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${t(r)}
    }
    return ${nr(r)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${nr(r)}) {
    let col = colIn * ${r};
    if (row < uniforms.dimAOuter && (col + ${r-1}) < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${r}] = value;
    }
  }`}var sk=class{constructor(t){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,";this.outputShape=t.inShape,y.assert(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=t.inChannels%4===0&&t.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=Rg(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Pg(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){let t=this.isVec4?am(this.elementsPerThread,this.workGroupSize):im(this.elementsPerThread,this.workGroupSize);return`
    ${Ace(this.isVec4?4:1)}
    ${t}
    `}};var ak=class{constructor(t){this.variableNames=["dy","W"];this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t.inShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){let t=this.isChannelsLast?1:2,e=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`
    ${Ie("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${t}], coords[${e}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}};function wce(r){let{inputs:t,backend:e,attrs:n}=r,{dy:o,filter:s}=t,{inputShape:a,strides:i,pad:u,dataFormat:p,dimRoundingMode:l}=n,m=C.convertConv2DDataFormat(p),c=C.computeConv2DInfo(a,s.shape,i,1,u,l,!1,m),d=[{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.batchSize,c.outHeight,c.outWidth,c.outChannels]}],f;if(B().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||c.filterHeight<=2&&c.filterWidth<=2&&c.outChannels<=16&&c.inChannels===1)f=new ak(c);else{f=new sk(c);let h=c.inHeight*c.inWidth,g=c.inChannels,b=c.filterHeight*c.filterWidth*c.outChannels;d.push({type:"uint32",data:[h]},{type:"uint32",data:[g]},{type:"uint32",data:[b]})}return e.runWebGPUProgram(f,[o,s],"float32",d)}var FK={kernelName:mo,backendName:"webgpu",kernelFunc:wce};var Nce=ut({opType:2}),RK={kernelName:co,backendName:"webgpu",kernelFunc:Nce};var Dce=ut({opType:3}),PK={kernelName:fo,backendName:"webgpu",kernelFunc:Dce};var ik=class{constructor(t,e,n,o){this.variableNames=["Image","Boxes","BoxInd"];this.uniforms="extrapolationValue : f32,";this.workGroupSize=[64,1,1];this.size=!0;let[s]=e;this.outputShape=[s,n[0],n[1],t],this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId=o==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[t,e]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,o,s]=this.cropHeightBiggerThan1?[`(${t} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${t} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${t}`],[a,i,u]=this.cropWidthBiggerThan1?[`(${e} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${e} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${e}`];return`
    ${Ie("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${a});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${o};
        let width_scale = ${i};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}};var Fce=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:o,boxes:s,boxInd:a}=t,{cropSize:i,method:u,extrapolationValue:p}=n,l=new ik(o.shape[3],s.shape,i,u),m=[{type:"float32",data:[p]}];return e.runWebGPUProgram(l,[o,s,a],"float32",m)},MK={kernelName:ga,backendName:"webgpu",kernelFunc:Fce};var Bg=class{constructor(t,e,n,o){this.variableNames=["x"];this.uniforms="index : f32,";this.size=!0;this.workGroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.exclusive=n,this.reverse=o,this.op=t,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){let t=this.outputShape.length,e=this.op==="*"?"1.0":"0.0",n=this.exclusive?e:`getX(${EK(t,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1],s="",a="";return this.exclusive?(s=this.reverse?`end != ${o-1}`:"end != 0",a=this.reverse?"end + 1":"end - 1"):(s=this.reverse?`end + pow2 < ${o}`:"end >= pow2",a=this.reverse?"end + pow2":"end - pow2"),`
      ${Ie("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${_K(t,"coords",this.op)};
         var val = ${n};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${s}) {
           let idx = ${a};
           ${_K(t,"coords",this.op)} = idx;
           val ${this.op}= getX(${EK(t,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}};function EK(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function _K(r,t,e){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative ${e} for rank ${r} is not yet supported`)}function uk(r,t,e,n,o,s){let a=t.shape.length,i=C.getAxesPermutation([n],a),u=t;i!=null&&(u=An({inputs:{x:t},backend:e,attrs:{perm:i}}));let p=C.getInnerMostAxes(1,a)[0];if(p!==a-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${n}`);let l=u.shape[p],m=fr({inputs:{x:u},backend:e});for(let c=0;c<=Math.ceil(Math.log2(l))-1;c++){let d=new Bg(r,u.shape,!1,s),f=m,h=[{type:"float32",data:[c]}];m=e.runWebGPUProgram(d,[m],m.dtype,h),e.disposeData(f.dataId)}if(o){let c=new Bg(r,u.shape,o,s),d=m,f=[{type:"float32",data:[0]}];m=e.runWebGPUProgram(c,[m],m.dtype,f),e.disposeData(d.dataId)}if(i!=null){let c=C.getUndoAxesPermutation(i),d=An({inputs:{x:m},backend:e,attrs:{perm:c}});return e.disposeData(m.dataId),e.disposeData(u.dataId),d}return m}function Pce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n;return uk("*",o,e,s,a,i)}var LK={kernelName:ha,backendName:"webgpu",kernelFunc:Pce};function Mce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n;return uk("+",o,e,s,a,i)}var $K={kernelName:ho,backendName:"webgpu",kernelFunc:Mce};var pk=class{constructor(t,e){this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.uniforms="blockSize : i32,";this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${e}`,this.dataFormat=e}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Ece(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],p=a==="NHWC"?o.shape[2]:o.shape[3],l=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=p*s,d=l/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=[{type:"int32",data:[s]}],g=new pk(f,a);return e.runWebGPUProgram(g,[o],o.dtype,h)}var BK={kernelName:ba,backendName:"webgpu",kernelFunc:Ece};var lk=class{constructor(t,e,n,o=!1,s=null,a=!1){this.variableNames=["x","W"];this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,";this.workGroupSize=[16,16,1];this.outputShape=t,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.addBias=o,this.activation=s,this.hasPreluActivation=a,this.filterHeight=e,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){let t=this.filterWidth*this.filterHeight,e=this.workGroupSize[0]*this.workGroupSize[1]*this.workGroupSize[2],n=this.workGroupSize[1]+this.filterHeight-1,o=this.workGroupSize[0]+this.filterWidth-1;return`
      ${vn(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${o}>, ${n}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${Lp()}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(num_workgroups) NumWorkgroups: vec3<u32>) {
        localId = LocalId;
        globalId = GlobalId;
        let localIndex = i32(LocalIndex);
        numWorkgroups = NumWorkgroups;
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workGroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${o}; inputCol = inputCol + ${this.workGroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = localIndex;
        ${t<e?`if (wIndex < ${t})`:`for(; wIndex < ${t}; wIndex = wIndex + ${e})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${ea(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};var qf=class{constructor(t,e=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,";this.workGroupSize=[4,4,4];this.isVec4=!0;this.outputShape=t.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[4,4,1]),y.assert(t.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}`}getUserCode(){let t=4+this.convInfo.filterWidth-1;return`
      ${vn(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, row, col, channel);
        }
        return value;
      }
      ${Lp()}
      fn _start(@builtin(global_invocation_id) globalId: vec3<u32>) {
        let batch = i32(globalId.z) / uniforms.outShape[1];
        let r = i32(globalId.z) % uniforms.outShape[1];
        let c = i32(globalId.y) * 4;
        let d1 = i32(globalId.x) * 4;
        let xRCCorner = vec2<i32>(r, c) - uniforms.pad;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${t}>;
        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          for (var i = 0; i < ${t}; i++)
          {
            xVals[i] = readX(batch, xR, xCCorner + i, d1);
          }
          for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
            let wValue = getW(wR, wC, d1, 0);
            dotProd[0] = dotProd[0] + xVals[0 + wC] * wValue;
            dotProd[1] = dotProd[1] + xVals[1 + wC] * wValue;
            dotProd[2] = dotProd[2] + xVals[2 + wC] * wValue;
            dotProd[3] = dotProd[3] + xVals[3 + wC] * wValue;
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${ea(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}};var jf=class{constructor(t,e=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms=`pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,`;this.workGroupSize=[256,1,1];this.outputShape=t.outShape,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=t.dataFormat==="channelsLast",e&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=t,this.addBias=e,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){let t=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${vn(this.activation,this.hasPreluActivation,!1,4)}

      ${Ie()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;
        let d2 = coords[${this.isChannelsLast?3:1}];
        let channelMul = uniforms.wShape[3];
        let d1 = d2 / channelMul;
        let q = d2 % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + uniforms.filterHeight *
            uniforms.dilation[0];
        let inputColEnd = inputColStart + uniforms.filterWidth *
            uniforms.dilation[1];

        // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
        // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
        // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
        // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
        var value = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] &&
              inputColEnd < uniforms.inDims[1]) {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = ${t};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = ${t};
                let wVal = getW(wR, wC, d1, q);
                value = value + xVal * wVal;
              }
            }
          }
          ${ea(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}};function _ce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s}=t,{strides:a,pad:i,dataFormat:u,dilations:p,dimRoundingMode:l}=n,m=C.convertConv2DDataFormat(u),c=p;c==null&&(c=[1,1]);let d=C.computeConv2DInfo(o.shape,s.shape,a,c,i,l,!0,m),f=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inHeight,d.inWidth]}],h=d.dataFormat==="channelsLast",g;return!h&&d.inHeight>16&&d.inWidth>16&&d.strideHeight===1&&d.strideWidth===1&&d.dilationWidth===1&&d.dilationHeight===1&&d.inChannels===d.outChannels?g=new lk(d.outShape,d.filterHeight,d.filterWidth):h&&d.inHeight>4&&d.inWidth>4&&d.strideHeight===1&&d.strideWidth===1&&d.inChannels===d.outChannels&&d.dilationHeight===1&&d.dilationWidth===1&&d.inChannels%4===0?g=new qf(d):(g=new jf(d),f.push({type:"int32",data:[d.filterHeight]},{type:"int32",data:[d.filterWidth]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]})),e.runWebGPUProgram(g,[o,s],o.dtype,f)}var OK={kernelName:go,backendName:"webgpu",kernelFunc:_ce};var p0=Tt({opType:0,cpuKernelImpl:HW,supportsComplex:!0}),zK={kernelName:Mo,backendName:"webgpu",kernelFunc:p0};function Og(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;return Ei(o,s,a,"sum",e)}var GK={kernelName:Ho,backendName:"webgpu",kernelFunc:Og};function Lce(r){let{inputs:t,backend:e,attrs:n}=r,{equation:o}=n,s=t,{allDims:a,summedDims:i,idDims:u}=C.decodeEinsumEquation(o,s.length);C.checkEinsumDimSizes(a.length,u,s);let{path:p,steps:l}=C.getEinsumComputePath(i,u),m=l.length,c=null,d=a.length,f=[];for(let h=0;h<m;++h){for(let g of l[h]){let{permutationIndices:b,expandDims:T}=C.getEinsumPermutation(d,u[g]),x;C.isIdentityPermutation(b)?x=s[g]:(x=An({inputs:{x:s[g]},backend:e,attrs:{perm:b}}),f.push(x));let I=x.shape.slice();for(let k=0;k<T.length;++k)I.splice(T[k],0,1);y.arraysEqual(x.shape,I)||(x=Re({inputs:{x},backend:e,attrs:{shape:I}}),f.push(x)),c===null?c=x:(c=p0({inputs:{a:x,b:c},backend:e}),f.push(c))}h<m-1&&(p[h]>=0&&(c=Og({inputs:{x:c},backend:e,attrs:{axis:p[h]-(a.length-d),keepDims:!1}}),f.push(c)),d--)}for(let h of f)h!==c&&e.disposeData(h.dataId);return c}var UK={kernelName:Ou,backendName:"webgpu",kernelFunc:Lce};var $ce=ut({opType:4}),WK={kernelName:yo,backendName:"webgpu",kernelFunc:$ce};var Bce=Tt({opType:5,dtype:"bool",cpuKernelImpl:PW}),KK={kernelName:ya,backendName:"webgpu",kernelFunc:Bce};var l0=ut({opType:5,cpuKernelImpl:MW,dtype:"float32"}),VK={kernelName:To,backendName:"webgpu",kernelFunc:l0};function mk(r){let{inputs:t,attrs:e,backend:n}=r,{dim:o}=e,{input:s}=t,a=s.shape.length,i=s.shape.slice(),u=o;return o<0&&(y.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),i.splice(u,0,1),Re({inputs:{x:s},backend:n,attrs:{shape:i}})}var HK={kernelName:ds,backendName:"webgpu",kernelFunc:mk};var Oce=ut({opType:6,cpuKernelImpl:EW}),qK={kernelName:Ta,backendName:"webgpu",kernelFunc:Oce};var ck=class{constructor(t){this.outputShape=[];this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}};var jK={kernelName:xa,backendName:"webgpu",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,o=new ck(e.shape);return n.runWebGPUProgram(o,[e],e.dtype)}};var zce=ut({opType:7,cpuKernelImpl:_W}),XK={kernelName:xo,backendName:"webgpu",kernelFunc:zce};var Gce=Tt({opType:13,dtype:"int32"}),YK={kernelName:Io,backendName:"webgpu",kernelFunc:Gce};var dk=class{constructor(t,e,n=!1){this.isFromPixels=!0;this.outputShape=[0];this.variableNames=[];this.workGroupSize=[256,1,1];this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[e,1,1]),this.importVideo=n,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){let t=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${Ie("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${t};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}};var ZK={kernelName:jp,backendName:"webgpu",kernelFunc:Uce},Xf,m0=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU"),fk=new Map;function Uce(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:o}=t,{numChannels:s}=n;if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let a=typeof HTMLVideoElement<"u"&&o instanceof HTMLVideoElement,i=typeof HTMLImageElement<"u"&&o instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&o instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&o instanceof OffscreenCanvas,p=typeof ImageBitmap<"u"&&o instanceof ImageBitmap,[l,m]=a?[o.videoWidth,o.videoHeight]:[o.width,o.height],c=[m,l,s],d=B().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&a,f=a||i;if(p||u||f){let T;if(d){let L=o;if(!fk.has(L)||fk.get(L).expired){let z={source:L};fk.set(L,e.device.importExternalTexture(z))}T={width:l,height:m,format:null,usage:null,texture:fk.get(L)}}else{if(f){let V=B().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Xf==null||V!==m0)&&(m0=V,Xf=document.createElement("canvas").getContext("2d",{willReadFrequently:m0})),Xf.canvas.width=l,Xf.canvas.height=m,Xf.drawImage(o,0,0,l,m),o=Xf.canvas}let L=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,z="rgba8unorm",W=e.textureManager.acquireTexture(c[1],c[0],z,L);e.queue.copyExternalImageToTexture({source:o},{texture:W},[c[1],c[0]]),T={width:l,height:m,format:z,usage:L,texture:W}}let x=y.sizeFromShape(c),I=y.computeStrides(c),k=new dk(c,s,d),w=[{type:"uint32",data:[x]},{type:"uint32",data:[s]},{type:"uint32",data:[...I]}],R=e.makeTensorInfo([m,l],"int32"),P=e.tensorMap.get(R.dataId);P.resourceInfo=T;let M=e.runWebGPUProgram(k,[R],"int32",w);return e.disposeData(R.dataId),M}let h=o.data,g=h;if(s!=null&&s!==4){g=new Uint8Array(o.width*o.height*s);let T=h.length,x=0;for(let I=0;I<T;I++)I%4<s&&(g[x++]=h[I])}let b=e.makeTensorInfo(c,"int32",new Int32Array(g));return e.uploadToGPU(b.dataId),b}var hk=class{constructor(t,e,n,o,s){this.uniforms="varianceEpsilon : f32,";this.workGroupSize=[128,1,1];this.size=!0;this.variableNames=["x","mean","variance"],C.assertAndGetBroadcastShape(t,e),C.assertAndGetBroadcastShape(t,n),this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),o!=null&&(C.assertAndGetBroadcastShape(t,o),this.variableNames.push("offset")),s!=null&&(C.assertAndGetBroadcastShape(t,s),this.variableNames.push("scale")),this.offsetShape=o,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let t="0.0";this.offsetShape!=null&&(t="getOffsetByOutputIndex(index)");let e="1.0";return this.scaleShape!=null&&(e="getScaleByOutputIndex(index)"),`
      ${Ie("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${t};
          let scaleValue = ${e};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};var QK={kernelName:Co,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n,scale:o,offset:s,mean:a,variance:i}=r,{varianceEpsilon:u}=t,p=e,l=[n,a,i],m=null;s!=null&&(m=s.shape,l.push(s));let c=null;o!=null&&(c=o.shape,l.push(o));let d=new hk(n.shape,a.shape,i.shape,m,c),f=[{type:"float32",data:[u]}];return p.runWebGPUProgram(d,l,n.dtype,f)}};function Wce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dataFormat:l,dilations:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=n,h=C.convertConv2DDataFormat(l),g=C.computeConv2DInfo(o.shape,s.shape,u,m,p,c,!1,h);return ok({x:o,filter:s,convInfo:g,backend:e,bias:a,preluActivationWeights:i,leakyreluAlpha:f,activation:d})}var JK={kernelName:ws,backendName:"webgpu",kernelFunc:Wce};function Kce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dilations:l,dimRoundingMode:m,activation:c,leakyreluAlpha:d}=n,f=l;f==null&&(f=[1,1]),y.assert(C.eitherStridesOrDilationsAreOne(u,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${f}'`);let h=C.computeConv2DInfo(o.shape,s.shape,u,f,p,m,!0),g=[o,s],b=a!=null,T=i!=null;b&&g.push(a),T&&g.push(i);let x=[{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.inHeight,h.inWidth]}],I;return h.inHeight>4&&h.inWidth>4&&h.strideHeight===1&&h.strideWidth===1&&h.inChannels===h.outChannels&&h.dilationHeight===1&&h.dilationWidth===1&&h.inChannels%4===0?I=new qf(h,b,c,T):(I=new jf(h,b,c,T),x.push({type:"int32",data:[h.filterHeight]},{type:"int32",data:[h.filterWidth]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]})),c==="leakyrelu"&&(x.push({type:"float32",data:[d]}),I.uniforms+=" alpha : f32,"),e.runWebGPUProgram(I,g,"float32",x)}var eV={kernelName:Ns,backendName:"webgpu",kernelFunc:Kce};var gk=class{constructor(t,e){this.variableNames=["A","indices"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${t}`,this.sliceDim=t,this.uniforms=`sliceDim : i32, strides : ${ur(t)},`}getUserCode(){let t;return this.sliceDim>1?t="uniforms.strides[j]":t="uniforms.strides",`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${t};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};function Vce(r){let{inputs:t,backend:e}=r,{params:n,indices:o}=t,s=o.shape,a=s[s.length-1],i=y.sizeFromShape(n.shape),[u,p,l,m]=C.prepareAndValidate(n,o),c=Re({inputs:{x:o},backend:e,attrs:{shape:[p,a]}}),d=Re({inputs:{x:n},backend:e,attrs:{shape:[y.sizeFromShape(n.shape)/l,l]}});if(e.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let T=e.readSync(o.dataId),x=e.bufferSync(n),I=LW(T,x,n.dtype,p,a,l,m,n.shape,i);return e.makeTensorInfo(u,n.dtype,I.values)}let f=new gk(a,[p,l]),h=[{type:"int32",data:[a]},{type:"int32",data:m}],g=e.runWebGPUProgram(f,[d,c],d.dtype,h),b=Re({inputs:{x:g},backend:e,attrs:{shape:u}});return e.disposeData(c.dataId),e.disposeData(d.dataId),e.disposeData(g.dataId),b}var tV={kernelName:Ia,backendName:"webgpu",kernelFunc:Vce};var bk=class{constructor(t,e){this.variableNames=["A","indices"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t.slice(),this.aShape=t,this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){let t=Hce(this.aShape);return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${t}));
        }
      }
    `}};function Hce(r){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],e=[];for(let n=0;n<r.length;n++)n===2?e.push("indexZ"):e.push(`${t[n]}`);return e.join()}function c0(r){let{inputs:t,backend:e,attrs:n}=r,{x:o,indices:s}=t,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0],p=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),l=y.sizeFromShape(s.shape),m=[],c=Re({inputs:{x:o},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),d=Re({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,l/p.batchSize]}});m.push(c),m.push(d);let f=[p.batchSize,p.outerSize,l/p.batchSize,p.sliceSize];if(e.shouldExecuteOnCPU([o,s])){let x=e.tensorMap.get(d.dataId).values,I=xe(d.shape,d.dtype,x),w=e.tensorMap.get(c.dataId).values,R=xe(c.shape,c.dtype,w),P=$W(R,I,f);return m.forEach(M=>e.disposeData(M.dataId)),e.makeTensorInfo(p.outputShape,P.dtype,P.values)}let h=new bk(c.shape,f),g=e.runWebGPUProgram(h,[c,d],c.dtype);m.push(g);let b=Re({inputs:{x:g},backend:e,attrs:{shape:p.outputShape}});return m.forEach(T=>e.disposeData(T.dataId)),b}var rV={kernelName:fs,backendName:"webgpu",kernelFunc:c0};var qce=Tt({opType:6,cpuKernelImpl:OW,dtype:"bool"}),nV={kernelName:Ca,backendName:"webgpu",kernelFunc:qce};var jce=Tt({opType:7,dtype:"bool",cpuKernelImpl:BW}),oV={kernelName:ko,backendName:"webgpu",kernelFunc:jce};var Xce=ut({opType:8,dtype:"bool"}),sV={kernelName:ka,backendName:"webgpu",kernelFunc:Xce};function Yce(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{alpha:s}=n,a=[{type:"float32",data:[s]}],i=new ta(o.shape,15);return i.uniforms="alpha : f32,",e.runWebGPUProgram(i,[o],"float32",a)}var aV={kernelName:So,backendName:"webgpu",kernelFunc:Yce};var Zce=Tt({opType:8,dtype:"bool",cpuKernelImpl:GW}),iV={kernelName:Sa,backendName:"webgpu",kernelFunc:Zce};var Qce=Tt({opType:9,dtype:"bool",cpuKernelImpl:zW}),uV={kernelName:va,backendName:"webgpu",kernelFunc:Qce};var Jce=ut({opType:10,cpuKernelImpl:UW}),pV={kernelName:vo,backendName:"webgpu",kernelFunc:Jce};var ede=Tt({opType:10,dtype:"bool"}),lV={kernelName:Aa,backendName:"webgpu",kernelFunc:ede};var tde=ut({opType:11}),mV={kernelName:wa,backendName:"webgpu",kernelFunc:tde};var rde=Tt({opType:16,cpuKernelImpl:KW}),cV={kernelName:wo,backendName:"webgpu",kernelFunc:rde};function nde(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{filterSize:s,strides:a,pad:i,dimRoundingMode:u}=n,p=1,l=C.computePool2DInfo(o.shape,s,a,p,i,u);return QC(o,l,"max",e)}var dV={kernelName:No,backendName:"webgpu",kernelFunc:nde};function ode(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;return Ei(o,s,a,"min",e)}var fV={kernelName:Fo,backendName:"webgpu",kernelFunc:ode};var sde=Tt({opType:17,cpuKernelImpl:VW}),hV={kernelName:Ro,backendName:"webgpu",kernelFunc:sde};var yk=class{constructor(t,e,n){this.uniforms="";this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e.map((o,s)=>o[0]+t[s]+o[1]),this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=t,e.map((o,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.offset=n==="reflect"?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){let t=this.xShape.length,e=this.xShape.map((p,l)=>`uniforms.pad${l}[0]`).join(","),n=this.xShape.map((p,l)=>`uniforms.pad${l}[0] + uniforms.xShape${t>1?`[${l}]`:""}`).join(","),o=t===1?"start":"start[i]",s=t===1?"end":"end[i]",a=t===1?"outC":"outC[i]",i=ur(t),u=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let start = ${i}(${e});
          let end = ${i}(${n});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${t}; i = i + 1) {
            if (${a} < ${o}) {
              ${a} = ${o} * 2 - ${a} - ${this.offset};
            } else if(${a} >= ${s}) {
              ${a} = (${s} - 1) * 2 - ${a} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}};var gV={kernelName:Po,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{paddings:o,mode:s}=t,a=e,i=o.map(l=>({type:"int32",data:[l[0],l[1]]})),u=new yk(n.shape,o,s);return a.runWebGPUProgram(u,[n],n.dtype,i)}};function ade(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let s=e.tensorMap.get(n.dataId),[a,i]=qW(s.values,n.shape,n.dtype);return e.makeTensorInfo(i,n.dtype,a)}let o=new ta(n.shape,12);return e.runWebGPUProgram(o,[n],n.dtype)}var bV={kernelName:hs,backendName:"webgpu",kernelFunc:ade};function ide(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u}=n,p=e.readSync(o.dataId),l=e.readSync(s.dataId),{selectedIndices:m}=xr.nonMaxSuppressionV3Impl(p,l,a,i,u);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}var yV={kernelName:Da,backendName:"webgpu",kernelFunc:ide};function ude(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:o,scores:s}=t,{maxOutputSize:a,iouThreshold:i,scoreThreshold:u,softNmsSigma:p}=n,l=e.readSync(o.dataId),m=e.readSync(s.dataId),c=a,d=i,f=u,h=p,{selectedIndices:g,selectedScores:b}=xr.nonMaxSuppressionV5Impl(l,m,c,d,f,h);return[e.makeTensorInfo([g.length],"int32",new Int32Array(g)),e.makeTensorInfo([b.length],"float32",new Float32Array(b))]}var TV={kernelName:Fa,backendName:"webgpu",kernelFunc:ude};function zg(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let o=Du({inputs:{input:n},backend:e}),s=zg({inputs:{x:o},backend:e}),a=pm({inputs:{input:n},backend:e}),i=zg({inputs:{x:a},backend:e}),u=ui({inputs:{real:s,imag:i},backend:e});return e.disposeData(o.dataId),e.disposeData(s.dataId),e.disposeData(a.dataId),e.disposeData(i.dataId),u}else return as({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var xV={kernelName:Ss,backendName:"webgpu",kernelFunc:zg};function IV(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=Du({inputs:{input:n},backend:e}),s=IV({inputs:{x:o},backend:e}),a=pm({inputs:{input:n},backend:e}),i=zg({inputs:{x:a},backend:e}),u=ui({inputs:{real:s,imag:i},backend:e});return e.disposeData(o.dataId),e.disposeData(s.dataId),e.disposeData(a.dataId),e.disposeData(i.dataId),u}else return as({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var CV={kernelName:gs,backendName:"webgpu",kernelFunc:IV};function pde(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return mk({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,a=t[0].dtype;t.forEach(l=>{y.assertShapesMatch(s,l.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(l=>{let m=mk({inputs:{input:l},backend:e,attrs:{dim:o}});return i.push(m),m}),p=u0({inputs:u,backend:e,attrs:{axis:o}});return i.forEach(l=>e.disposeData(l.dataId)),p}var kV={kernelName:bs,backendName:"webgpu",kernelFunc:pde};var Tk=class{constructor(t,e){this.variableNames=["x"];this.uniforms="constantValue : f32,";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e.map((n,o)=>n[0]+t[o]+n[1]),this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),e.map((n,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.xShape=t,this.shaderKey="pad"}getUserCode(){let t=this.xShape.length,e=ur(t),n=this.xShape.map((m,c)=>`uniforms.pad${c}[0]`).join(","),o=this.xShape.map((m,c)=>`uniforms.pad${c}[0] + uniforms.xShape${t>1?`[${c}]`:""}`).join(","),s=t>1?`${e}(${n})`:`${n}`,a=t>1?`${e}(${o})`:`${o}`,i=t>1?"any(outC < start)":"outC < start",u=t>1?"any(outC >= end)":"outC >= end",p=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let start = ${s};
          let end = ${a};
          let outC = getCoordsFromIndex(index);

          if (${i} || ${u}) {
            setOutputAtIndex(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputAtIndex(index, getX(${p}));
          }
        }
      }
    `}};var d0=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{paddings:s,constantValue:a}=n;if(s.every(p=>y.arraysEqual(p,[0,0])))return fr({inputs:{x:o},backend:e});if(y.sizeFromShape(o.shape)===0){let p=s.map((l,m)=>l[0]+o.shape[m]+l[1]);return as({backend:e,attrs:{shape:p,value:a,dtype:o.dtype}})}let i=[{type:"float32",data:[a]}];s.map(p=>i.push({type:"int32",data:[p[0],p[1]]}));let u=new Tk(o.shape,s);return e.runWebGPUProgram(u,[o],o.dtype,i)},SV={kernelName:Eo,backendName:"webgpu",kernelFunc:d0};var lde=Tt({opType:14}),vV={kernelName:_o,backendName:"webgpu",kernelFunc:lde};function mde(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=new um(15,n.shape,o.shape);return e.runWebGPUProgram(s,[n,o],"float32")}var AV={kernelName:Lo,backendName:"webgpu",kernelFunc:mde};function cde(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,keepDims:a}=n;return Ei(o,s,a,"prod",e)}var wV={kernelName:$o,backendName:"webgpu",kernelFunc:cde};var dde=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:a}=e,i=YW(n,o,s,a);return t.makeTensorInfo([i.length],a,i)},NV={kernelName:hi,backendName:"webgpu",kernelFunc:dde};var f0=Tt({opType:4}),DV={kernelName:bo,backendName:"webgpu",kernelFunc:f0};var fde=ut({opType:16}),FV={kernelName:Pa,backendName:"webgpu",kernelFunc:fde};var hde=ut({opType:13}),RV={kernelName:Bo,backendName:"webgpu",kernelFunc:hde};var gde=ut({opType:14}),PV={kernelName:Go,backendName:"webgpu",kernelFunc:gde};var xk=class{constructor(t,e,n){this.variableNames=["x"];this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=[t[0],e,n,t[3]],this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${Ie("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function bde(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,size:a,halfPixelCenters:i}=n,[u,p]=a,l=s&&u>1?1:0,m=s&&p>1?1:0,d=[{type:"float32",data:[l,m]},{type:"float32",data:[i?.5:0]}],f=new xk(o.shape,u,p);return e.runWebGPUProgram(f,[o],"float32",d)}var MV={kernelName:zo,backendName:"webgpu",kernelFunc:bde};var Ik=class{constructor(t,e,n,o){this.variableNames=["x"];this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=[t[0],e,n,t[3]],this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=o,this.shaderKey=`resizeNearest_${o}`}getUserCode(){let t;return this.halfPixelCenters?t="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":t="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${t};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}};function yde(r){let{inputs:t,backend:e,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,p]=i,l=s&&u>1?1:0,m=s&&p>1?1:0,d=[{type:"float32",data:[l,m]},{type:"float32",data:[s?.5:0]}],f=new Ik(o.shape,u,p,a);return e.runWebGPUProgram(f,[o],o.dtype,d)}var EV={kernelName:Oo,backendName:"webgpu",kernelFunc:yde};var Ck=class{constructor(t,e){this.outputShape=[];this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=t,typeof e=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${Ie("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}};var _V={kernelName:Ga,backendName:"webgpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:o,fillValue:s,center:a}=t,i=e,u=new Ck(n.shape,s),[p,l]=C.getImageCenter(a,n.shape[1],n.shape[2]),m=[{type:"float32",data:[p]},{type:"float32",data:[l]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return typeof s=="number"?m.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):m.push({type:"float32",data:s}),i.runWebGPUProgram(u,[n],n.dtype,m)}};var Tde=ut({opType:17,cpuKernelImpl:ZW}),LV={kernelName:Uo,backendName:"webgpu",kernelFunc:Tde};var $p=class{constructor(t,e,n,o,s,a,i,u=!0){this.variableNames=["updates","indices"];this.workGroupSize=[64,1,1];this.atomic=!0;this.outputShape=a,this.type=i,this.sumDupeIndices=u,this.dispatchLayout=ve(t),this.dispatch=ge(this.dispatchLayout,t,this.workGroupSize),this.sliceDimGreaterThanOne=e>1,this.shaderKey=`scatter_${n}_${o}_${this.sliceDimGreaterThanOne}_${i}_${u}`;let p=ur(s.length);this.uniforms=`sliceDim : i32, strides: ${p}, size: i32,`,this.updatesRank=o,this.indicesRank=n}getUserCode(){let t="";this.indicesRank===1?t="coords[0]":this.indicesRank===2&&(t="coords[0], j");let e=`getIndices(${t})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",o="",s="";this.dispatchLayout.x.length===1?(o="flattenedIndex",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(o="vec2<i32>(flattenedIndex, coords[1])",s=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);let i=`getUpdates(${Array.from({length:this.updatesRank},(l,m)=>`coords[${m}]`).join(", ")})`,u=(l,m)=>{let c=`atomicAdd(${l}, bitcast<i32>(${m}))`;this.type==="float32"&&(c=`
          {
            var oldBits = 0;
            var newBits = bitcast<i32>(${m});
            loop {
              let info = atomicCompareExchangeWeak(${l}, oldBits, newBits);
              if (info.exchanged) {
                break;
              }
              oldBits = info.old_value;
              let oldValue = bitcast<f32>(oldBits);
              let newValue = oldValue + (${m});
              newBits = bitcast<i32>(newValue);
            }
          }
        `);let d=`atomicStore(${l}, bitcast<i32>(${m}));`;return this.sumDupeIndices?c:d};return`
    ${s}

      ${Ie("index")} {
        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${e}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue =
              ${Gf(this.type,!1)}(${i});
          let flatIndex = getOutputIndexFromCoords(${o});

          ${u("&result[flatIndex]","updateValue")};
        }
      }`}};function xde(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o,updates:s}=t,{shape:a}=n,{sliceRank:i,numUpdates:u,sliceSize:p,strides:l,outputSize:m}=C.calculateShapes(s,o,a),c=[m/p,p];if(m===0)return e.makeTensorInfo(a,o.dtype);let d=Re({inputs:{x:o},backend:e,attrs:{shape:[u,i]}}),f=Re({inputs:{x:s},backend:e,attrs:{shape:[u,p]}}),h=f.dtype,g=as({backend:e,attrs:{shape:c,value:0,dtype:h}}),b=y.sizeFromShape(f.shape),T=[{type:"int32",data:[i]},{type:"int32",data:l},{type:"int32",data:[b]}],x=new $p(f.shape,i,d.shape.length,f.shape.length,l,c,h),I=e.runWebGPUProgram(x,[f,d],h,T,g),k=Re({inputs:{x:I},backend:e,attrs:{shape:a}});return e.disposeData(d.dataId),e.disposeData(f.dataId),e.disposeData(I.dataId),k}var $V={kernelName:_a,backendName:"webgpu",kernelFunc:xde};var kk=class{constructor(t,e,n){this.variableNames=["c","a","b"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=t,this.rank=n,this.shaderKey="select"}getUserCode(){let t,e;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)e="resRC",t="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],a=[];for(let i=0;i<this.outputShape.length;i++)a.push(`${o[i]}`),i<this.cRank&&s.push(`${o[i]}`);t=s.join(),e=a.join()}return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${t});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${e}));
          } else {
            setOutputAtIndex(index, getB(${e}));
          }
        }
      }
    `}};function Ide(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,a=new kk(n.shape.length,o.shape,o.shape.length);return e.runWebGPUProgram(a,[n,o,s],$t(o.dtype,s.dtype))}var BV={kernelName:Ts,backendName:"webgpu",kernelFunc:Ide};var Cde=ut({opType:20}),OV={kernelName:Ko,backendName:"webgpu",kernelFunc:Cde};var kde=ut({opType:18}),zV={kernelName:Wo,backendName:"webgpu",kernelFunc:kde};var Sde=ut({opType:19}),GV={kernelName:La,backendName:"webgpu",kernelFunc:Sde};var h0=Tt({opType:3,cpuKernelImpl:nK,supportsComplex:!0}),UV={kernelName:Xo,backendName:"webgpu",kernelFunc:h0};function vde(r){let{inputs:t,backend:e,attrs:n}=r,{logits:o}=t,{dim:s}=n,a=y.parseAxisParam([s],o.shape),i=$g({inputs:{x:o},backend:e,attrs:{reductionIndices:a,keepDims:!1}}),u=C.expandShapeToKeepDim(i.shape,a),p=Re({inputs:{x:i},backend:e,attrs:{shape:u}}),l=h0({inputs:{a:o,b:p},backend:e}),m=l0({inputs:{x:l},backend:e}),c=Og({inputs:{x:m},backend:e,attrs:{axis:a,keepDims:!1}}),d=Re({inputs:{x:c},backend:e,attrs:{shape:u}}),f=f0({inputs:{a:m,b:d},backend:e});return e.disposeData(i.dataId),e.disposeData(p.dataId),e.disposeData(l.dataId),e.disposeData(m.dataId),e.disposeData(c.dataId),e.disposeData(d.dataId),f}var WV={kernelName:qo,backendName:"webgpu",kernelFunc:vde};var Ade=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:a}=n;y.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let i=s.reduce((b,T)=>b*T),u=[[0,0]];u.push(...a);for(let b=1+s.length;b<o.shape.length;++b)u.push([0,0]);let p=[],l=d0({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),m=C.getReshaped(l.shape,s,i,!1),c=C.getPermuted(m.length,s.length,!1),d=C.getReshapedPermuted(l.shape,s,i,!1),f=Re({inputs:{x:l},backend:e,attrs:{shape:m}}),h=An({inputs:{x:f},backend:e,attrs:{perm:c}}),g=Re({inputs:{x:h},backend:e,attrs:{shape:d}});return p.push(l),p.push(f),p.push(h),p.forEach(b=>e.disposeData(b.dataId)),g},KV={kernelName:Is,backendName:"webgpu",kernelFunc:Ade};var Sk=class{constructor(t,e){this.variableNames=["A"];this.workGroupSize=[64,1,1];this.size=!0;let n=new Array(t.length);for(let o=0;o<n.length;o++)n[o]=t[o]*e[o];this.outputShape=n,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let t=wde(this.rank,"uniforms.");return`
      ${Ie("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${t}));
        }
      }
    `}};function wde(r,t=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${t}aShape)`;let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r;o++)n.push(`(${e[o]} % ${t}aShape[${o}])`);return n.join()}function g0(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{reps:s}=n;if(e.shouldExecuteOnCPU([o])||o.dtype==="string"||o.shape.length>=5){let u=e.readSync(o.dataId),p=o.dtype==="string"?u.map(c=>y.decodeString(c)):u,l=xe(o.shape,o.dtype,p),m=oK(l,s);return e.makeTensorInfo(m.shape,m.dtype,m.values)}let a=new Sk(o.shape,s);return e.runWebGPUProgram(a,[o],o.dtype)}var VV={kernelName:Dn,backendName:"webgpu",kernelFunc:g0};function Nde(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:a}=t,{outputShape:i}=n,{sliceRank:u,numUpdates:p,sliceSize:l,strides:m,outputSize:c}=C.calculateShapes(s,o,i),d=!1;if(s.dtype==="string"){let P=e.bufferSync(o),M=e.bufferSync(s),L=y.decodeString(e.readSync(a.dataId)[0]),z=QW(P,M,i,c,l,p,u,m,L,d);return e.makeTensorInfo(i,z.dtype,z.values)}let f=[c/l,l],h=Re({inputs:{x:o},backend:e,attrs:{shape:[p,u]}}),g=s.shape.length?Re({inputs:{x:s},backend:e,attrs:{shape:[p,l]}}):fr({inputs:{x:s},backend:e}),b=g.dtype,T=e.makeTensorInfo([],b,y.makeZerosTypedArray(1,b)),x=Re({inputs:{x:a},backend:e,attrs:{shape:Array(f.length).fill(1)}}),I=g0({inputs:{x},backend:e,attrs:{reps:f}}),k=y.sizeFromShape([p,l]),w=[{type:"int32",data:[u]},{type:"int32",data:m},{type:"int32",data:[k]}];switch(p){case 0:break;case 1:{let P=new $p([p,l],u,h.shape.length,g.shape.length,m,f,b,d);e.runWebGPUProgram(P,[g,h],b,w,I)}break;default:{let P=new $p([p,l],u,h.shape.length,T.shape.length,m,f,b,d);e.runWebGPUProgram(P,[T,h],b,w,I)}{let P=new $p([p,l],u,h.shape.length,g.shape.length,m,f,b);e.runWebGPUProgram(P,[g,h],b,w,I)}}let R=Re({inputs:{x:I},backend:e,attrs:{shape:i}});return e.disposeData(h.dataId),e.disposeData(g.dataId),e.disposeData(x.dataId),e.disposeData(T.dataId),e.disposeData(I.dataId),R}var HV={kernelName:qu,backendName:"webgpu",kernelFunc:Nde};function Dde(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:a}=n,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),p=o.shape.length,l=new Array(p).fill(0),m=o.shape.slice();return u.map(c=>{let d=[...m];d[i]=c;let f=pi({inputs:{x:o},backend:e,attrs:{begin:l,size:d}});return l[i]+=c,f})}var qV={kernelName:Cs,backendName:"webgpu",kernelFunc:Dde};var Fde=ut({opType:21}),jV={kernelName:Vo,backendName:"webgpu",kernelFunc:Fde};var XV={kernelName:gi,backendName:"webgpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t,o=new ta(e.shape,22);return n.runWebGPUProgram(o,[e],e.dtype)}};var Rde=Tt({opType:12}),YV={kernelName:jo,backendName:"webgpu",kernelFunc:Rde};var vk=class{constructor(t){this.variableNames=["x"];this.workPerThread=1;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let e=ur(this.outputShape.length);this.uniforms=`begin : ${e},  strides : ${e}, `,this.shaderKey="stridedSlice"}getUserCode(){let t=this.outputShape.length,e="";if(t===1)e="coords * uniforms.strides + uniforms.begin";else{let o=0;e=this.outputShape.map((s,a)=>(o++,this.outputShape.length===1?`coords * uniforms.strides[${a}] + uniforms.begin[${a}]`:`coords[${o-1}] * uniforms.strides[${a}] + uniforms.begin[${a}]`)).join(",")}return`
       ${Ie("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${e}));
         }
       }
     `}};function Pde(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{begin:s,end:a,strides:i,beginMask:u,endMask:p,ellipsisMask:l,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,p,l,m,c),k;if(h)k=Re({inputs:{x:o},backend:e,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),R=pi({inputs:{x:o},backend:e,attrs:{begin:T,size:w}});k=Re({inputs:{x:R},backend:e,attrs:{shape:f}}),e.disposeData(R.dataId)}else if(e.shouldExecuteOnCPU([o])){let R=e.readSync(o.dataId),P=xe(o.shape,o.dtype,R),M=tK(d,P,I,T);k=e.makeTensorInfo(f,o.dtype,M.values)}else{let R=new vk(d),P=[{type:"int32",data:T},{type:"int32",data:I}],M=e.runWebGPUProgram(R,[o],o.dtype,P);k=Re({inputs:{x:M},backend:e,attrs:{shape:f}}),e.disposeData(M.dataId)}return k}var ZV={kernelName:$a,backendName:"webgpu",kernelFunc:Pde};function Mde(r){let{inputs:t,backend:e,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:a,rightPad:i,padWidth:u,preserveShortSequences:p}=n,{data:l,dataSplits:m}=t,c=e.readSync(l.dataId),d=e.readSync(m.dataId),[f,h]=rK(c,d,o,s,a,i,u,p);return[e.makeTensorInfo([f.length],"string",f),e.makeTensorInfo(m.shape,"int32",h)]}var QV={kernelName:bi,backendName:"webgpu",kernelFunc:Mde};var Ede=ut({opType:23}),JV={kernelName:Yo,backendName:"webgpu",kernelFunc:Ede};var Ak=class{constructor(t){this.variableNames=["x","indices"];this.workGroupSize=[256,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${Ie("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}},wk=class{constructor(t){this.variableNames=["x","indices"];this.workGroupSize=[256,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${Ie("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}};function Yf(r,t){t!==null&&r.disposeData(t.dataId)}function e4(r){let t=1;for(;t<r;)t*=2;return t}function _de(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{k:s,sorted:a}=n,i=o.shape,u=i[i.length-1];if(e.shouldExecuteOnCPU([o])){let k=e.readSync(o.dataId),[w,R]=sK(k,i,o.dtype,s,a);return[e.makeTensorInfo(w.shape,w.dtype,w.values),e.makeTensorInfo(R.shape,R.dtype,R.values)]}if(s===0)return i[i.length-1]=0,[e.makeTensorInfo(i,o.dtype,[]),e.makeTensorInfo(i,"int32",[])];if(u===1)return[o,as({attrs:{shape:i,dtype:"int32",value:0},backend:e})];let l=y.sizeFromShape(i)/u,m=Re({inputs:{x:o},attrs:{shape:[l,u]},backend:e}),c=e4(s),d=e4(u),f=null,h=()=>f===null?[m,m]:[m,f],g=(k,w,R)=>{let P=h(),M=new Ak(R),z=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[k]},{type:"int32",data:[w]}],W=f;f=e.runWebGPUProgram(M,P,"int32",z),Yf(e,W)};for(let k=1;k<c;k*=2){let w=k*2;for(let R=k;R>=1;R/=2)g(w,R,[l,d])}for(let k=d;k>c;k/=2){let w=h(),R=new wk([l,k/2]),M=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[c]}],L=f;f=e.runWebGPUProgram(R,w,"int32",M),Yf(e,L);let z=c/2,W=z*2;for(let V=z;V>=1;V/=2)g(W,V,f.shape)}let b=f;f=pi({inputs:{x:f},backend:e,attrs:{begin:0,size:[l,s]}}),Yf(e,b);let T=c0({inputs:{x:m,indices:f},backend:e,attrs:{axis:1,batchDims:1}});Yf(e,m);let x=i.slice(0,-1);x.push(s),b=f,f=Re({inputs:{x:f},attrs:{shape:x},backend:e}),Yf(e,b);let I=T;return T=Re({inputs:{x:T},attrs:{shape:x},backend:e}),Yf(e,I),[T,f]}var t4={kernelName:Oa,backendName:"webgpu",kernelFunc:_de};var Nk=class{constructor(t){this.variableNames=["Image","Transforms"];this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=ve(this.outputShape),this.dispatch=ge(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${Ie("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}};function Lde(r){let{inputs:t,backend:e,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:a,fillMode:i,fillValue:u,outputShape:p}=n,[l,m,c,d]=o.shape,[f,h]=p??[m,c],g=[l,f,h,d],b=new Nk(g),T=a==="nearest"?1:2,x;switch(i){case"constant":x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4;break;default:x=1;break}let I=[{type:"int32",data:[T]},{type:"int32",data:[x]},{type:"float32",data:[u]}];return e.runWebGPUProgram(b,[o,s],"float32",I)}var r4={kernelName:za,backendName:"webgpu",kernelFunc:Lde};function $de(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o,i=a.shape.length,u=o.shape[s],p=new Array(i-1),l=0;for(let h=0;h<i;h++)h!==s&&(p[l++]=a.shape[h]);let m=[],c=new Array(i).fill(0),d=a.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){c[s]=h;let g=pi({inputs:{x:a},backend:e,attrs:{begin:c,size:d}}),b=Re({inputs:{x:g},backend:e,attrs:{shape:p}});f[h]=b,m.push(g)}return m.forEach(h=>e.disposeData(h.dataId)),f}var n4={kernelName:ks,backendName:"webgpu",kernelFunc:$de};var Bde=[vW,iK,uK,pK,mK,cK,dK,gK,bK,TK,kK,SK,vK,wW,wK,DK,FK,RK,PK,MK,LK,$K,BK,OK,UK,WK,KK,VK,HK,qK,kW,jK,ZK,XK,YK,QK,JK,eV,tV,rV,nV,oV,AW,AK,sV,aV,iV,uV,pV,lV,mV,fK,cV,dV,hK,fV,hV,gV,zK,bV,yV,TV,xK,CV,kV,SV,vV,AV,wV,NV,IK,DV,FV,RV,PV,SW,MV,EV,_V,LV,$V,BV,OV,zV,GV,yK,ZV,QV,WV,KV,HV,qV,jV,XV,YV,UV,GK,JV,VV,t4,r4,lK,n4,xV];for(let r of Bde)tu(r);var Je=(s=>(s[s.float32=0]="float32",s[s.int32=1]="int32",s[s.bool=2]="bool",s[s.string=3]="string",s[s.complex64=4]="complex64",s))(Je||{}),lm=(i=>(i[i.linear=0]="linear",i[i.relu=1]="relu",i[i.relu6=2]="relu6",i[i.prelu=3]="prelu",i[i.leakyrelu=4]="leakyrelu",i[i.sigmoid=5]="sigmoid",i[i.elu=6]="elu",i))(lm||{});var o4;function Ode(r){o4=r.wasm.cwrap(As,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function zde(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s,bias:a,preluActivationWeights:i}=t;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:p,activation:l,leakyreluAlpha:m}=n,c=e.dataIdMap.get(o.dataId).id,d=e.dataIdMap.get(s.dataId).id,f=0;if(a!=null){let P=e.dataIdMap.get(a.dataId);if(P.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${P.shape.length}.`);f=P.id}let h=i==null?0:e.dataIdMap.get(i.dataId).id,g=lm[l];if(g==null)throw new Error(`${l} activation not yet supported for FusedConv2D in the wasm backend.`);let b=u?o.shape[2]:o.shape[1],T=p?s.shape[1]:s.shape[2],x=Nr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),I=e.makeOutput([...x,b,T],o.dtype),k=e.dataIdMap.get(I.dataId).id,w=new Uint8Array(new Int32Array(o.shape).buffer),R=new Uint8Array(new Int32Array(s.shape).buffer);return o4(c,w,o.shape.length,d,R,s.shape.length,u,p,g,f,h,m||0,k),I}var s4={kernelName:As,backendName:"wasm",setupFunc:Ode,kernelFunc:zde};function lt(r,t){let e;function n(s){e=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:a,inputs:{x:i}}=s,u=a.dataIdMap.get(i.dataId).id,p=a.makeOutput(i.shape,t||i.dtype),l=a.dataIdMap.get(p.dataId).id;return y.sizeFromShape(p.shape)===0||e(u,Je[i.dtype],l),p}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var a4=lt(ls);function ht(r,t,e){let n;function o(a){n=a.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(a){let{backend:i,inputs:u}=a,{a:p,b:l}=u,m=i.dataIdMap.get(p.dataId).id,c=i.dataIdMap.get(l.dataId).id,d=e??p.dtype,f=C.assertAndGetBroadcastShape(p.shape,l.shape),h=i.makeOutput(f,d);if(y.sizeFromShape(f)===0)return h;let g=new Uint8Array(new Int32Array(p.shape).buffer),b=new Uint8Array(new Int32Array(l.shape).buffer),T=i.dataIdMap.get(h.dataId).id;return(()=>n(m,g,p.shape.length,c,b,l.shape.length,Je[p.dtype],T))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var Gde=!0,i4=ht(Nn,Gde);var u4;function Ude(r){u4=r.wasm.cwrap(so,null,["array","number","number","number"])}function Wde(r){let{inputs:t,backend:e}=r,n=e.makeOutput(t[0].shape,t[0].dtype);if(y.sizeFromShape(n.shape)===0)return n;let o=t.map(i=>e.dataIdMap.get(i.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),a=e.dataIdMap.get(n.dataId).id;return u4(s,o.length,Je[n.dtype],a),n}var p4={kernelName:so,backendName:"wasm",setupFunc:Ude,kernelFunc:Wde};function mm(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype),o=e.typedArrayFromHeap(t);return e.typedArrayFromHeap(n).set(o),n}var l4={kernelName:Vn,backendName:"wasm",kernelFunc:mm};var m4;function Kde(r){m4=r.wasm.cwrap(Fn,null,["number","array","number","number","number","array","number"])}function is(r){let{inputs:t,backend:e,attrs:n}=r,[o,s]=Hde(t.x.shape,n.perm),a=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(a=!1);let i=Vde(t.x.shape,n.perm),u={dataId:t.x.dataId,shape:o,dtype:t.x.dtype};if(a){let f=mm({inputs:t,backend:e});return f.shape=i,f}let p=e.makeOutput(i,u.dtype),l=e.dataIdMap.get(u.dataId).id,m=e.dataIdMap.get(p.dataId).id,c=new Uint8Array(new Int32Array(s).buffer),d=new Uint8Array(new Int32Array(u.shape).buffer);return m4(l,d,u.shape.length,Je[u.dtype],m,c,s.length),p}function Vde(r,t){let e=new Array(r.length);for(let n=0;n<e.length;n++)e[n]=r[t[n]];return e}function Hde(r,t){let e=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&e.push(r[o]),r[t[o]]!==1&&n.push(t[o]);for(let o=0;o<n.length;++o){let s=-1;for(let a=0;a<n.length;++a)n[a]>=o&&(s===-1||n[s]>n[a])&&(s=a);n[s]=o}return[e,n]}var c4={kernelName:Fn,backendName:"wasm",kernelFunc:is,setupFunc:Kde};function wn(r,t,e){let n=r.shape,o=r.shape.length,s=y.parseAxisParam(t,n),a=s,i=C.getAxesPermutation(a,o),u=null,p=!1;if(i!=null){let l=new Array(o);for(let d=0;d<l.length;d++)l[d]=n[i[d]];a=C.getInnerMostAxes(a.length,o),u=is({inputs:{x:r},attrs:{perm:i},backend:e});let m=e.dataIdMap.get(r.dataId).id;e.dataIdMap.get(u.dataId).id!==m&&(p=!0)}return{transposed:u,originalAxes:s,axes:a,inputWasTransposed:p}}var d4;function qde(r){d4=r.wasm.cwrap(Bi,null,["number, number, number"])}function jde(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=e,u=t.dataIdMap.get(a.dataId).id,p=a,{transposed:l,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,t);if(d){let x=t.dataIdMap.get(l.dataId).id;p=l,u=x}let f=p.shape.length;C.assertAxesAreInnerMostDims("all",m,f);let[h,g]=C.computeOutAndReduceShapes(p.shape,m),b=y.sizeFromShape(g),T=t.makeOutput(h,a.dtype);if(y.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(T.dataId).id;d4(u,b,x)}if(d&&t.disposeData(l.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var f4={kernelName:Bi,backendName:"wasm",setupFunc:qde,kernelFunc:jde};var h4;function Xde(r){h4=r.wasm.cwrap(Oi,null,["number, number, number"])}function Yde(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=e,u=t.dataIdMap.get(a.dataId).id,p=a,{transposed:l,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,t);if(d){let x=t.dataIdMap.get(l.dataId).id;p=l,u=x}let f=p.shape.length;C.assertAxesAreInnerMostDims("any",m,f);let[h,g]=C.computeOutAndReduceShapes(p.shape,m),b=y.sizeFromShape(g),T=t.makeOutput(h,a.dtype);if(y.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(T.dataId).id;h4(u,b,x)}if(d&&t.disposeData(l.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var g4={kernelName:Oi,backendName:"wasm",setupFunc:Xde,kernelFunc:Yde};var b4;function Zde(r){b4=r.wasm.cwrap(ao,null,["number","number","number","number","number"])}function Qde(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o}=n,{x:s}=e,a=t.dataIdMap.get(s.dataId).id,i=a,u=s,{transposed:p,axes:l,inputWasTransposed:m}=wn(s,o,t);if(m){let b=t.dataIdMap.get(p.dataId).id;b!==a&&(u=p,i=b)}let c=u.shape.slice(0,-1),d=t.makeOutput(c,"int32"),f=t.dataIdMap.get(d.dataId).id,h=y.sizeFromShape(d.shape),g=u.shape[l[0]];return b4(i,Je[u.dtype],h,g,f),m&&t.disposeData(p.dataId),d}var y4={kernelName:ao,backendName:"wasm",kernelFunc:Qde,setupFunc:Zde};var T4;function Jde(r){T4=r.wasm.cwrap(io,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function efe(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:a,strides:i,pad:u,dimRoundingMode:p}=e,l=C.computePool2DInfo(o.shape,a,i,1,u,p),m=l.filterHeight,c=l.filterWidth,d=l.padInfo.top,f=l.padInfo.right,h=l.padInfo.bottom,g=l.padInfo.left,b=l.strideHeight,T=l.strideWidth,x=l.inChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);if(l.dilationWidth!==1||l.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${l.dilationHeight}, ${l.dilationWidth}].`);let I=n.makeOutput(l.outShape,"float32"),k=n.dataIdMap.get(I.dataId).id;return T4(s,o.shape[0],o.shape[1],o.shape[2],m,c,d,f,h,g,b,T,x,k),I}var x4={kernelName:io,backendName:"wasm",setupFunc:Jde,kernelFunc:efe};function hr(r){let{inputs:t,attrs:e}=r,{x:n}=t,{shape:o}=e,s=y.sizeFromShape(n.shape),a=y.inferFromImplicitShape(o,s);return y.assert(s===y.sizeFromShape(a),()=>`new shape: ${a}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:a,dtype:n.dtype}}var I4={kernelName:ys,backendName:"wasm",kernelFunc:hr};var C4;function tfe(r){C4=r.wasm.cwrap(uo,null,["number","array","number","number","array","number","number","number","number"])}function rfe(r){let{inputs:t,backend:e,attrs:n}=r,{a:o,b:s}=t,{transposeA:a,transposeB:i}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,p=s.shape.length,l=a?o.shape[u-2]:o.shape[u-1],m=i?s.shape[p-1]:s.shape[p-2],c=a?o.shape[u-1]:o.shape[u-2],d=i?s.shape[p-2]:s.shape[p-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=y.sizeFromShape(f),b=y.sizeFromShape(h),x=Nr.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([c,d]);y.assert(l===m,()=>`Error in matMul: inner shapes (${l}) and (${m}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${a} and transposeB=${i} must match.`);let I=a?[g,l,c]:[g,c,l],k=i?[b,d,m]:[b,m,d],w=hr({inputs:{x:o},backend:e,attrs:{shape:I}}),R=hr({inputs:{x:s},backend:e,attrs:{shape:k}}),P=e.dataIdMap.get(w.dataId).id,M=e.dataIdMap.get(R.dataId).id,L=a?w.shape[2]:w.shape[1],z=i?R.shape[1]:R.shape[2],W=Math.max(g,b),V=e.makeOutput([W,L,z],w.dtype),j=e.dataIdMap.get(V.dataId).id,H=new Uint8Array(new Int32Array(w.shape).buffer),X=new Uint8Array(new Int32Array(R.shape).buffer);return C4(P,H,w.shape.length,M,X,R.shape.length,a,i,j),e.disposeData(w.dataId),e.disposeData(R.dataId),V.shape=x,V}var k4={kernelName:uo,backendName:"wasm",setupFunc:tfe,kernelFunc:rfe};function ra(r){let{inputs:{x:t},attrs:{begin:e,size:n},backend:o}=r,[s,a]=It.parseSliceParams(t,e,n),i=It.isSliceContinous(t.shape,s,a),u=o.readSync(t.dataId),p=o.makeOutput(a,t.dtype),l=y.computeStrides(t.shape),m=o.dataIdMap.get(p.dataId);if(i){let f=It.computeFlatOffset(s,l);return t.dtype==="string"?m.stringBytes=u.slice(f,f+y.sizeFromShape(a)):o.typedArrayFromHeap(p).set(u.subarray(f,f+y.sizeFromShape(a))),p}if(t.dtype==="string"){let f=Wl(u,s,a,t.shape,t.dtype);return m.stringBytes=f,p}let c=o.typedArrayFromHeap(p),d=t.shape.length;if(d===2)nfe(u,l[0],c,s,a);else if(d===3)ofe(u,l[0],l[1],c,s,a);else if(d===4)sfe(u,l[0],l[1],l[2],c,s,a);else{let f=Wl(u,s,a,t.shape,t.dtype);c.set(f)}return p}function nfe(r,t,e,n,o){let s=0,a=n[0],i=n[1],u=a+o[0];for(let p=a;p<u;p++){let l=p*t+i;e.set(r.subarray(l,l+o[1]),s),s+=o[1]}}function ofe(r,t,e,n,o,s){let a=0,i=o[0],u=o[1],p=o[2],l=i+s[0],m=u+s[1];for(let c=i;c<l;c++)for(let d=u;d<m;d++){let f=c*t+d*e+p;n.set(r.subarray(f,f+s[2]),a),a+=s[2]}}function sfe(r,t,e,n,o,s,a){let i=0,u=s[0],p=s[1],l=s[2],m=u+a[0],c=p+a[1],d=l+a[2],f=s[3];for(let h=u;h<m;h++)for(let g=p;g<c;g++)for(let b=l;b<d;b++){let T=h*t+g*e+b*n+f;o.set(r.subarray(T,T+a[3]),i),i+=a[3]}}var S4={kernelName:xs,backendName:"wasm",kernelFunc:ra};function afe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,crops:a}=n,i=s.reduce((b,T)=>b*T),u=C.getReshaped(o.shape,s,i),p=C.getPermuted(u.length,s.length),l=C.getReshapedPermuted(o.shape,s,i),m=C.getSliceBeginCoords(a,s.length),c=C.getSliceSize(l,a,s.length),d=hr({inputs:{x:o},backend:e,attrs:{shape:u}}),f=is({inputs:{x:d},backend:e,attrs:{perm:p}}),h=hr({inputs:{x:f},backend:e,attrs:{shape:l}}),g=ra({inputs:{x:h},backend:e,attrs:{begin:m,size:c}});return e.disposeData(d.dataId),e.disposeData(f.dataId),e.disposeData(d.dataId),g}var v4={kernelName:ms,backendName:"wasm",kernelFunc:afe};function li(r){let{inputs:{x:t},attrs:{dtype:e},backend:n}=r,o=n.makeOutput(t.shape,e),s=n.typedArrayFromHeap(t);return n.typedArrayFromHeap(o).set(s),o}var A4={kernelName:Wn,backendName:"wasm",kernelFunc:li};var w4=lt(po);var N4;function ife(r){N4=r.wasm.cwrap(Kn,null,["number","number","number","number"])}function ufe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{clipValueMin:s,clipValueMax:a}=n,i=e.dataIdMap.get(o.dataId).id,u=e.makeOutput(o.shape,o.dtype),p=e.dataIdMap.get(u.dataId).id;return N4(i,s,a,p),u}var D4={kernelName:Kn,backendName:"wasm",setupFunc:ife,kernelFunc:ufe};function b0(r){let{inputs:t,backend:e}=r,n=y.parseAxisParam(r.attrs.axis,t[0].shape)[0],o=C.computeOutShape(t.map(d=>d.shape),n),s=t.filter(d=>y.sizeFromShape(d.shape)>0);if(s.length===1)return mm({inputs:{x:s[0]},backend:e});let a=e.makeOutput(o,t[0].dtype);if(y.sizeFromShape(o)===0)return a;let i=s.map(d=>d.shape);if(C.assertParamsConsistent(i,n),s[0].dtype==="string"){let d=s.map(x=>{let I=y.sizeFromShape(x.shape.slice(n));return hr({inputs:{x},backend:e,attrs:{shape:[-1,I]}})}),f=d.map(x=>({vals:e.readSync(x.dataId),shape:x.shape}));o=C.computeOutShape(d.map(x=>x.shape),1);let h=d[0].shape[0]===1,g=zl(f,o,t[0].dtype,h),b=C.computeOutShape(s.map(x=>x.shape),n);a.shape=b;let T=e.dataIdMap.get(a.dataId);return T.stringBytes=C.fromStringArrayToUint8(g),d.forEach(x=>e.disposeData(x.dataId)),a}let u=y.sizeFromShape(s[0].shape.slice(0,n)),p=0,l=s.map(d=>{let f=y.sizeFromShape(d.shape.slice(n));return p+=f,f}),m=s.map(d=>e.typedArrayFromHeap(d)),c=e.typedArrayFromHeap(a);for(let d=0;d<u;d++){let f=d*p;for(let h=0;h<m.length;h++){let g=l[h],b=d*g,T=m[h].subarray(b,b+g);c.set(T,f),f+=g}}return a}var F4={kernelName:cs,backendName:"wasm",kernelFunc:b0};var R4;function pfe(r){R4=r.wasm.cwrap(lo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function lfe(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:p,pad:l,dimRoundingMode:m,dataFormat:c}=e,d=C.convertConv2DDataFormat(c),f=C.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!1,d),h=f.filterHeight,g=f.filterWidth,b=f.padInfo.top,T=f.padInfo.right,x=f.padInfo.bottom,I=f.padInfo.left,k=f.dilationHeight,w=f.dilationWidth,R=f.strideHeight,P=f.strideWidth,M=f.inChannels,L=f.outChannels,z=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let W=n.makeOutput(f.outShape,"float32"),V=n.dataIdMap.get(W.dataId).id;return R4(a,o.shape[0],o.shape[1],o.shape[2],i,h,g,b,T,x,I,z,k,w,R,P,M,L,V),W}var P4={kernelName:lo,backendName:"wasm",setupFunc:pfe,kernelFunc:lfe};var M4;function mfe(r){M4=r.wasm.cwrap(mo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function cfe(r){let{backend:t,inputs:e,attrs:n}=r,{dy:o,filter:s}=e,{strides:a,pad:i,dataFormat:u,dimRoundingMode:p,inputShape:l}=n,m=1,c=C.convertConv2DDataFormat(u),d=C.computeConv2DInfo(l,s.shape,a,m,i,p,!1,c),{batchSize:f,filterHeight:h,filterWidth:g,inChannels:b,inHeight:T,inWidth:x,outChannels:I,outHeight:k,outWidth:w,strideHeight:R,strideWidth:P}=d,M=h-1-d.padInfo.top,L=g-1-d.padInfo.left,z=d.dataFormat==="channelsLast",W=y.computeStrides(d.inShape),V=y.computeStrides(o.shape),[j,H,X]=y.computeStrides(s.shape),ee=W[0],q=z?W[1]:W[2],ne=z?W[2]:1,se=z?1:W[1],ie=V[0],pe=z?V[1]:V[2],ae=z?V[2]:1,ye=z?1:V[1],fe=t.makeOutput(d.inShape,"float32"),Ce=t.dataIdMap.get(fe.dataId).id,we=t.dataIdMap.get(o.dataId).id,Ee=t.dataIdMap.get(s.dataId).id;return M4(we,Ee,f,h,g,T,x,b,k,w,I,R,P,M,L,j,H,X,ee,q,ne,se,ie,pe,ae,ye,Ce),fe}var E4={kernelName:mo,backendName:"wasm",setupFunc:mfe,kernelFunc:cfe};var _4=lt(co);var L4=lt(fo);var $4=(e=>(e[e.bilinear=0]="bilinear",e[e.nearest=1]="nearest",e))($4||{}),B4;function dfe(r){B4=r.wasm.cwrap(ga,null,["number","number","number","number","array","number","number","number","number","number"])}function ffe(r){let{backend:t,inputs:e,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:a}=n,{image:i,boxes:u,boxInd:p}=e,l=u.shape[0],[m,c]=a,d=[l,m,c,i.shape[3]],f=t.dataIdMap.get(i.dataId),h;i.dtype!=="float32"&&(h=li({backend:t,inputs:{x:i},attrs:{dtype:"float32"}}),f=t.dataIdMap.get(h.dataId));let g=f.id,b=t.dataIdMap.get(u.dataId).id,T=t.dataIdMap.get(p.dataId).id,x=t.makeOutput(d,"float32"),I=t.dataIdMap.get(x.dataId).id,k=new Uint8Array(new Int32Array(i.shape).buffer);return B4(g,b,T,l,k,m,c,$4[o],s,I),h!=null&&t.disposeData(h.dataId),x}var O4={kernelName:ga,backendName:"wasm",setupFunc:dfe,kernelFunc:ffe};var z4;function hfe(r){z4=r.wasm.cwrap(ha,null,["number","number","number","number","number","number"])}function gfe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumprod does not support ${o.dtype} tensors in the WASM backend`);let p=C.getAxesPermutation([s],u),l=o;p!==null&&(l=is({inputs:{x:o},attrs:{perm:p},backend:e}));let m=C.getInnerMostAxes(1,u)[0];C.assertAxesAreInnerMostDims("cumprod",[m],u);let c=e.makeOutput(l.shape,l.dtype),d=l.shape[m],f=e.dataIdMap.get(l.dataId).id,h=e.dataIdMap.get(c.dataId).id;z4(f,a?1:0,i?1:0,d,h,Je[o.dtype]);let g=c;if(p!==null){let b=C.getUndoAxesPermutation(p);g=is({inputs:{x:c},attrs:{perm:b},backend:e}),e.disposeData(l.dataId),e.disposeData(c.dataId)}return g}var G4={kernelName:ha,backendName:"wasm",setupFunc:hfe,kernelFunc:gfe};var U4;function bfe(r){U4=r.wasm.cwrap(ho,null,["number","number","number","number","number","number"])}function yfe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{axis:s,exclusive:a,reverse:i}=n,u=o.shape.length;y.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let p=C.getAxesPermutation([s],u),l=o;p!==null&&(l=is({inputs:{x:o},attrs:{perm:p},backend:e}));let m=C.getInnerMostAxes(1,u)[0];C.assertAxesAreInnerMostDims("cumsum",[m],u);let c=e.makeOutput(l.shape,l.dtype),d=l.shape[m],f=e.dataIdMap.get(l.dataId).id,h=e.dataIdMap.get(c.dataId).id;U4(f,a?1:0,i?1:0,d,h,Je[o.dtype]);let g=c;if(p!==null){let b=C.getUndoAxesPermutation(p);g=is({inputs:{x:c},attrs:{perm:b},backend:e}),e.disposeData(l.dataId),e.disposeData(c.dataId)}return g}var W4={kernelName:ho,backendName:"wasm",setupFunc:bfe,kernelFunc:yfe};var K4;function Tfe(r){K4=r.wasm.cwrap(ba,null,["number","number","number","array","number","array","array","number","number"])}function xfe(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:a}=n,i=o.shape[0],u=a==="NHWC"?o.shape[1]:o.shape[2],p=a==="NHWC"?o.shape[2]:o.shape[3],l=a==="NHWC"?o.shape[3]:o.shape[1],m=u*s,c=p*s,d=l/(s*s),f=a==="NHWC"?[i,m,c,d]:[i,d,m,c],h=t.makeOutput(f,"float32"),b=t.dataIdMap.get(o.dataId).id,T=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),x=new Uint8Array(new Int32Array(f).buffer),I=new Uint8Array(new Int32Array(y.computeStrides(f)).buffer),k=t.dataIdMap.get(h.dataId).id;return K4(b,s,a==="NHWC"?1:0,T,o.shape.length-1,x,I,f.length,k),h}var V4={kernelName:ba,backendName:"wasm",setupFunc:Tfe,kernelFunc:xfe};var H4;function Ife(r){H4=r.wasm.cwrap(go,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Cfe(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s}=t,a=n.dataIdMap.get(o.dataId).id,i=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:p,pad:l,dimRoundingMode:m}=e,c=p??[1,1],d=C.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!0),f=d.filterHeight,h=d.filterWidth,g=d.padInfo.top,b=d.padInfo.right,T=d.padInfo.bottom,x=d.padInfo.left,I=d.dilationHeight,k=d.dilationWidth,w=d.strideHeight,R=d.strideWidth,P=d.inChannels,M=d.outChannels,L=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let z=n.makeOutput(d.outShape,"float32"),W=n.dataIdMap.get(z.dataId).id;return H4(a,o.shape[0],o.shape[1],o.shape[2],i,f,h,g,b,T,x,L,I,k,w,R,P,M,W),z}var q4={kernelName:go,backendName:"wasm",setupFunc:Ife,kernelFunc:Cfe};var j4=lt(yo);var kfe=!1,X4=ht(ya,kfe,"bool");var Y4=lt(To,"float32");function Dk(r){let{inputs:t,attrs:e,backend:n}=r,{input:o}=t,{dim:s}=e,a=o.shape.length,i=o.shape.slice(),u=s;return s<0&&(y.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),i.splice(u,0,1),hr({inputs:{x:o},backend:n,attrs:{shape:i}})}var Z4={kernelName:ds,backendName:"wasm",kernelFunc:Dk};function y0(r){let{attrs:{shape:t,value:e,dtype:n},backend:o}=r,s=o.makeOutput(t,n);return o.typedArrayFromHeap(s).fill(e),s}var Q4={kernelName:fi,backendName:"wasm",kernelFunc:y0};var J4;function Sfe(r){J4=r.wasm.cwrap(xa,null,["number","number","number","number","number","number"])}function vfe(r){let{inputs:t,backend:e}=r,{image:n}=t,o=e.makeOutput(n.shape,n.dtype),s=e.dataIdMap.get(n.dataId).id,a=e.dataIdMap.get(o.dataId).id,[i,u,p,l]=n.shape;return J4(s,i,u,p,l,a),o}var eH={kernelName:xa,backendName:"wasm",kernelFunc:vfe,setupFunc:Sfe};var tH=lt(xo);var Afe=!1,rH=ht(Io,Afe);var nH;function wfe(r){nH=r.wasm.cwrap(Co,null,["number","number","number","number","number","number","number"])}function Nfe(r){let{backend:t,inputs:e,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:a,variance:i,offset:u,scale:p}=e,l=t.dataIdMap.get(s.dataId).id,m=t.dataIdMap.get(a.dataId).id,c=t.dataIdMap.get(i.dataId).id,d=u!=null?t.dataIdMap.get(u.dataId).id:0,f=p!=null?t.dataIdMap.get(p.dataId).id:0,h=t.makeOutput(s.shape,s.dtype);if(y.sizeFromShape(s.shape)===0)return h;let g=t.dataIdMap.get(h.dataId).id;return nH(l,m,c,d,f,o,g),h}var oH={kernelName:Co,backendName:"wasm",setupFunc:wfe,kernelFunc:Nfe};var sH;function Dfe(r){sH=r.wasm.cwrap(ws,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ffe(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dilations:l,dataFormat:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=e,h=C.computeConv2DInfo(o.shape,s.shape,u,l,p,c),g=lm[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);let b=n.dataIdMap.get(o.dataId).id,T=n.dataIdMap.get(s.dataId).id,x=h.outChannels,I=0;if(a!=null){let ae=n.dataIdMap.get(a.dataId);if(ae.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==x)throw new Error(`FusedConv2D bias shape (${ae.shape}) does not match the number of output channels (${x})`);I=ae.id}let k=h.filterHeight,w=h.filterWidth,R=h.padInfo.top,P=h.padInfo.right,M=h.padInfo.bottom,L=h.padInfo.left,z=h.dilationHeight,W=h.dilationWidth,V=h.strideHeight,j=h.strideWidth,H=h.inChannels,X=h.padInfo.type==="SAME"?1:0,ee=h.batchSize,q=h.inHeight,ne=h.inWidth;if(m!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);let se=n.makeOutput(h.outShape,"float32"),ie=n.dataIdMap.get(se.dataId).id,pe=i==null?0:n.dataIdMap.get(i.dataId).id;return sH(b,ee,q,ne,T,k,w,I,R,P,M,L,X,z,W,V,j,H,x,g,pe,f||0,ie),se}var aH={kernelName:ws,backendName:"wasm",setupFunc:Dfe,kernelFunc:Ffe};var iH;function Rfe(r){iH=r.wasm.cwrap(Ns,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Pfe(r){let{inputs:t,attrs:e,backend:n}=r,{x:o,filter:s,bias:a,preluActivationWeights:i}=t,{strides:u,pad:p,dilations:l,dataFormat:m,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=e,h=C.computeConv2DInfo(o.shape,s.shape,u,l,p,c,!0),g=lm[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let b=n.dataIdMap.get(o.dataId).id,T=n.dataIdMap.get(s.dataId).id,x=h.outChannels,I=0;if(a!=null){let ae=n.dataIdMap.get(a.dataId);if(ae.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ae.shape.length}.`);if(ae.shape[0]!==x)throw new Error(`FusedDepthwiseConv2D bias shape (${ae.shape}) does not match the number of output channels (${x})`);I=ae.id}let k=h.filterHeight,w=h.filterWidth,R=h.padInfo.top,P=h.padInfo.right,M=h.padInfo.bottom,L=h.padInfo.left,z=h.dilationHeight,W=h.dilationWidth,V=h.strideHeight,j=h.strideWidth,H=h.inChannels,X=h.padInfo.type==="SAME"?1:0,ee=h.batchSize,q=h.inHeight,ne=h.inWidth;if(m!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${m}'. Please use 'NHWC'.`);let se=n.makeOutput(h.outShape,"float32"),ie=n.dataIdMap.get(se.dataId).id,pe=i==null?0:n.dataIdMap.get(i.dataId).id;return iH(b,ee,q,ne,T,k,w,I,R,P,M,L,X,z,W,V,j,H,x,g,pe,f||0,ie),se}var uH={kernelName:Ns,backendName:"wasm",setupFunc:Rfe,kernelFunc:Pfe};var pH;function Mfe(r){pH=r.wasm.cwrap(Ia,null,["number","number","number","number","number","number","array","number"])}function Efe(r){let{backend:t,inputs:e}=r,{params:n,indices:o}=e,[s,a,i,u]=jb.prepareAndValidate(n,o),p=t.makeOutput(s,n.dtype);if(a===0)return p;let l=o.shape,m=l[l.length-1],d=t.dataIdMap.get(n.dataId).id,h=t.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),b=t.dataIdMap.get(p.dataId).id;return pH(d,Je[n.dtype],h,a,m,i,g,b),p}var lH={kernelName:Ia,backendName:"wasm",setupFunc:Mfe,kernelFunc:Efe};var mH;function _fe(r){mH=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Lfe(r){let{backend:t,inputs:e,attrs:n}=r,{x:o,indices:s}=e,{axis:a,batchDims:i}=n,u=y.parseAxisParam(a,o.shape)[0],p=t.readSync(s.dataId),l=o.shape[u];for(let M=0;M<p.length;++M){let L=p[M];y.assert(L<=l-1&&L>=0,()=>`GatherV2: the index value ${L} is not in [0, ${l-1}]`)}let m=C.segment_util.collectGatherOpShapeInfo(o,s,u,i),c=hr({inputs:{x:o},attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]},backend:t}),d=y.sizeFromShape(s.shape),f=hr({inputs:{x:s},attrs:{shape:[m.batchSize,d/m.batchSize]},backend:t}),h=[m.batchSize,m.outerSize,d/m.batchSize,m.sliceSize],g=t.makeOutput(h,o.dtype);if(y.sizeFromShape(o.shape)===0)return g;let b=c.shape.length-1,x=t.dataIdMap.get(c.dataId).id,k=t.dataIdMap.get(f.dataId).id,w=t.dataIdMap.get(g.dataId).id,R=new Uint8Array(new Int32Array(y.computeStrides(c.shape)).buffer),P=new Uint8Array(new Int32Array(y.computeStrides(h)).buffer);return mH(x,Je[o.dtype],R,b,k,m.batchSize,P,w),t.disposeData(c.dataId),t.disposeData(f.dataId),g.shape=m.outputShape,g}var cH={kernelName:fs,backendName:"wasm",setupFunc:_fe,kernelFunc:Lfe};var $fe=!1,dH=ht(Ca,$fe,"bool");var Bfe=!1,fH=ht(ko,Bfe,"bool");var hH;function Ofe(r){hH=r.wasm.cwrap(So,null,["number","number","number","number"])}function zfe(r){let{inputs:{x:t},attrs:{alpha:e},backend:n}=r,o=n.dataIdMap.get(t.dataId).id,s=n.makeOutput(t.shape,"float32");if(y.sizeFromShape(t.shape)!==0){let a=n.dataIdMap.get(s.dataId).id;hH(o,Je[t.dtype],e,a)}return s}var gH={kernelName:So,backendName:"wasm",setupFunc:Ofe,kernelFunc:zfe};var Gfe=!1,bH=ht(Sa,Gfe,"bool");var Ufe=!1,yH=ht(va,Ufe,"bool");var TH=lt(vo);var Wfe=!1,xH=ht(Aa,Wfe,"bool");var IH=lt(wa);var Kfe=!1,CH=ht(ji,Kfe,"bool");var Vfe=!1,kH=ht(u1,Vfe,"bool");var SH;function Hfe(r){SH=r.wasm.cwrap(Ao,null,["number","number","number","number"])}function qfe(r){let{backend:t,inputs:e,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:a}=e,u=t.dataIdMap.get(a.dataId).id,p=a,{transposed:l,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,t);if(d){let x=t.dataIdMap.get(l.dataId).id;p=l,u=x}let f=p.shape.length;C.assertAxesAreInnerMostDims("max",m,f);let[h,g]=C.computeOutAndReduceShapes(p.shape,m),b=y.sizeFromShape(g),T=t.makeOutput(h,a.dtype);if(y.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(T.dataId).id;SH(u,Je[a.dtype],b,x)}if(d&&t.disposeData(l.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var vH={kernelName:Ao,backendName:"wasm",setupFunc:Hfe,kernelFunc:qfe};var jfe=!1,AH=ht(wo,jfe);var wH;function Xfe(r){wH=r.wasm.cwrap(No,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Yfe(r){let{inputs:t,attrs:e,backend:n}=r,o=t.x,s=n.dataIdMap.get(o.dataId).id;y.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:a,strides:i,pad:u,dimRoundingMode:p}=e,l=C.computePool2DInfo(o.shape,a,i,1,u,p),m=l.filterHeight,c=l.filterWidth,d=l.padInfo.top,f=l.padInfo.right,h=l.padInfo.bottom,g=l.padInfo.left,b=l.dilationHeight,T=l.dilationWidth,x=l.strideHeight,I=l.strideWidth,k=l.inChannels,w=l.outChannels;if(l.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${l.dataFormat}'. Please use 'channelsLast'.`);let R=n.makeOutput(l.outShape,"float32"),P=n.dataIdMap.get(R.dataId).id;return wH(s,o.shape[0],o.shape[1],o.shape[2],m,c,d,f,h,g,b,T,x,I,k,w,P),R}var NH={kernelName:No,backendName:"wasm",setupFunc:Xfe,kernelFunc:Yfe};var DH;function Zfe(r){DH=r.wasm.cwrap(Do,null,["number, number, number"])}function Qfe(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=e,i=t.dataIdMap.get(a.dataId).id,u=i,p=a,{transposed:l,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,t),f=m;if(d){let I=t.dataIdMap.get(l.dataId).id;I!==i&&(p=l,u=I,f=C.getInnerMostAxes(f.length,p.shape.length))}C.assertAxesAreInnerMostDims("mean",f,p.shape.length);let[h,g]=C.computeOutAndReduceShapes(p.shape,f),b=y.sizeFromShape(g),T=p;p.dtype!=="float32"&&(T=li({backend:t,inputs:{x:p},attrs:{dtype:"float32"}}),u=t.dataIdMap.get(T.dataId).id);let x=t.makeOutput(h,"float32");if(y.sizeFromShape(p.shape)!==0){let I=t.dataIdMap.get(x.dataId).id;DH(u,b,I)}if(d&&t.disposeData(l.dataId),s){let I=C.expandShapeToKeepDim(x.shape,c);x.shape=I}return p.dtype!=="float32"&&t.disposeData(T.dataId),x}var FH={kernelName:Do,backendName:"wasm",setupFunc:Zfe,kernelFunc:Qfe};var RH;function Jfe(r){RH=r.wasm.cwrap(Fo,null,["number","number","number","number"])}function ehe(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=e,i=t.dataIdMap.get(a.dataId).id,u=i,p=a,{transposed:l,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,t);if(d){let x=t.dataIdMap.get(l.dataId).id;x!==i&&(p=l,u=x)}let f=p.shape.length;C.assertAxesAreInnerMostDims("min",m,f);let[h,g]=C.computeOutAndReduceShapes(p.shape,m),b=y.sizeFromShape(g),T=t.makeOutput(h,p.dtype);if(y.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(T.dataId).id;RH(u,Je[a.dtype],b,x)}if(d&&t.disposeData(l.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var PH={kernelName:Fo,backendName:"wasm",setupFunc:Jfe,kernelFunc:ehe};var the=!1,MH=ht(Ro,the);var EH=(e=>(e[e.reflect=0]="reflect",e[e.symmetric=1]="symmetric",e))(EH||{}),_H;function rhe(r){_H=r.wasm.cwrap(Po,null,["number","array","number","number","array","array","number","number"])}function nhe(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,mode:o}}=r,s=n.map((f,h)=>f[0]+t.shape[h]+f[1]),a=e.dataIdMap.get(t.dataId).id,i=e.makeOutput(s,t.dtype),u=e.dataIdMap.get(i.dataId).id,p=new Uint8Array(new Int32Array(t.shape).buffer),l=n.map(f=>f[0]),m=n.map(f=>f[1]),c=new Uint8Array(new Int32Array(l).buffer),d=new Uint8Array(new Int32Array(m).buffer);return _H(a,p,t.shape.length,Je[t.dtype],c,d,EH[o],u),i}var LH={kernelName:Po,backendName:"wasm",kernelFunc:nhe,setupFunc:rhe};var ohe=!0,$H=ht(Mo,ohe);var BH=lt(hs);function Zf(r,t){let e=new Int32Array(r.wasm.HEAPU8.buffer,t,4),n=e[0],o=e[1],s=e[2],a=e[3];return r.wasm._free(t),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:a}}var OH;function she(r){OH=r.wasm.cwrap(Da,"number",["number","number","number","number","number"])}function ahe(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a}=n,{boxes:i,scores:u}=e,p=t.dataIdMap.get(i.dataId).id,l=t.dataIdMap.get(u.dataId).id,m=OH(p,l,s,o,a),{pSelectedIndices:c,selectedSize:d,pSelectedScores:f,pValidOutputs:h}=Zf(t,m);return t.wasm._free(f),t.wasm._free(h),t.makeOutput([d],"int32",c)}var zH={kernelName:Da,backendName:"wasm",setupFunc:she,kernelFunc:ahe};var GH;function ihe(r){GH=r.wasm.cwrap(Yi,"number",["number","number","number","number","number","bool"])}function uhe(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,padToMaxOutputSize:i}=n,{boxes:u,scores:p}=e,l=t.dataIdMap.get(u.dataId).id,m=t.dataIdMap.get(p.dataId).id,c=GH(l,m,s,o,a,i),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Zf(t,c);t.wasm._free(h);let b=t.makeOutput([f],"int32",d),T=t.makeOutput([],"int32",g);return[b,T]}var UH={kernelName:Yi,backendName:"wasm",setupFunc:ihe,kernelFunc:uhe};var WH;function phe(r){WH=r.wasm.cwrap(Fa,"number",["number","number","number","number","number","number"])}function lhe(r){let{backend:t,inputs:e,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:a,softNmsSigma:i}=n,{boxes:u,scores:p}=e,l=t.dataIdMap.get(u.dataId).id,m=t.dataIdMap.get(p.dataId).id,c=WH(l,m,s,o,a,i),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Zf(t,c);t.wasm._free(g);let b=t.makeOutput([f],"int32",d),T=t.makeOutput([f],"float32",h);return[b,T]}var KH={kernelName:Fa,backendName:"wasm",setupFunc:phe,kernelFunc:lhe};var mhe=!1,VH=ht(Na,mhe,"bool");var HH;function che(r){HH=r.wasm.cwrap(Ra,null,["number","number","number","number","number"])}function dhe(r){let{inputs:t,backend:e,attrs:n}=r,{indices:o}=t,{dtype:s,depth:a,onValue:i,offValue:u}=n,p=e.makeOutput([...o.shape,a],s),l=e.dataIdMap.get(p.dataId).id,c=e.dataIdMap.get(o.dataId).id;return HH(c,a,i,u,l),p}var qH={kernelName:Ra,backendName:"wasm",setupFunc:che,kernelFunc:dhe};function fhe(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(1),n}var jH={kernelName:gs,backendName:"wasm",kernelFunc:fhe};function hhe(r){let{inputs:t,backend:e,attrs:n}=r,{axis:o}=n;if(t.length===1)return Dk({inputs:{input:t[0]},backend:e,attrs:{dim:o}});let s=t[0].shape,a=t[0].dtype;t.forEach(l=>{y.assertShapesMatch(s,l.shape,"All tensors passed to stack must have matching shapes"),y.assert(a===l.dtype,()=>"All tensors passed to stack must have matching dtypes")});let i=[],u=t.map(l=>{let m=Dk({inputs:{input:l},backend:e,attrs:{dim:o}});return i.push(m),m}),p=b0({inputs:u,backend:e,attrs:{axis:o}});return i.forEach(l=>e.disposeData(l.dataId)),p}var XH={kernelName:bs,backendName:"wasm",kernelFunc:hhe};var YH;function ghe(r){YH=r.wasm.cwrap(Eo,null,["number","array","number","number","array","array","number","number"])}function bhe(r){let{inputs:{x:t},backend:e,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+t.shape[g]+h[1]);if(y.sizeFromShape(t.shape)===0)return y0({backend:e,attrs:{shape:s,value:o,dtype:t.dtype}});let a=e.dataIdMap.get(t.dataId).id,i=e.makeOutput(s,t.dtype),p=e.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(t.shape).buffer),m=n.map(h=>h[0]),c=n.map(h=>h[1]),d=new Uint8Array(new Int32Array(m).buffer),f=new Uint8Array(new Int32Array(c).buffer);return YH(a,l,t.shape.length,Je[t.dtype],d,f,o,p),i}var Fk={kernelName:Eo,backendName:"wasm",kernelFunc:bhe,setupFunc:ghe};var yhe=!1,ZH=ht(_o,yhe);var QH;function The(r){QH=r.wasm.cwrap(Lo,null,["number","number","number"])}function xhe(r){let{inputs:t,backend:e}=r,{x:n,alpha:o}=t,s=e.dataIdMap.get(n.dataId).id,a=e.dataIdMap.get(o.dataId).id,i=s,u=n,p=u;u.dtype!=="float32"&&(p=li({backend:e,inputs:{x:n},attrs:{dtype:"float32"}}),i=e.dataIdMap.get(p.dataId).id);let l=e.makeOutput(n.shape,"float32"),m=e.dataIdMap.get(l.dataId).id;return QH(i,a,m),u.dtype!=="float32"&&e.disposeData(p.dataId),l}var JH={kernelName:Lo,backendName:"wasm",setupFunc:The,kernelFunc:xhe};var eq;function Ihe(r){eq=r.wasm.cwrap($o,null,["number","number","number","number"])}function Che(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=e,i=t.dataIdMap.get(a.dataId).id,u=i,p=a,{transposed:l,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,t),f=m;if(d){let x=t.dataIdMap.get(l.dataId).id;x!==i&&(p=l,u=x,f=C.getInnerMostAxes(f.length,p.shape.length))}C.assertAxesAreInnerMostDims("prod",f,p.shape.length);let[h,g]=C.computeOutAndReduceShapes(p.shape,f),b=y.sizeFromShape(g),T=t.makeOutput(h,p.dtype);if(y.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(T.dataId).id;eq(u,b,Je[T.dtype],x)}if(d&&t.disposeData(l.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var tq={kernelName:$o,backendName:"wasm",setupFunc:Ihe,kernelFunc:Che};var khe=r=>{let{backend:t,attrs:e}=r,{start:n,stop:o,step:s,dtype:a}=e,i=Ul(n,o,s,a),u=t.makeOutput([i.length],a);return t.typedArrayFromHeap(u).set(i),u},rq={kernelName:hi,backendName:"wasm",kernelFunc:khe};var She=!0,nq=ht(bo,She);var oq=lt(Bo);var sq=lt(Go);var aq;function vhe(r){aq=r.wasm.cwrap(zo,null,["number","number","number","number","number","number","number","number","number","number"])}function Ahe(r){let{backend:t,inputs:e,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,p]=i,[l,m,c,d]=o.shape,f=[l,u,p,d],h=t.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=li({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),h=t.dataIdMap.get(g.dataId));let b=h.id,T=t.makeOutput(f,"float32");if(y.sizeFromShape(o.shape)===0)return T;let x=t.dataIdMap.get(T.dataId).id;return aq(b,l,m,c,d,u,p,s?1:0,a?1:0,x),g!=null&&t.disposeData(g.dataId),T}var iq={kernelName:zo,backendName:"wasm",setupFunc:vhe,kernelFunc:Ahe};var uq;function whe(r){uq=r.wasm.cwrap(Oo,null,["number","number","number","number","number","number","number","number","number","number"])}function Nhe(r){let{backend:t,inputs:e,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:a,size:i}=n,[u,p]=i,[l,m,c,d]=o.shape,f=[l,u,p,d],h=t.makeOutput(f,"float32");if(y.sizeFromShape(o.shape)===0)return h;let g=t.dataIdMap.get(o.dataId),b;g.dtype!=="float32"&&(b=li({backend:t,inputs:{x:o},attrs:{dtype:"float32"}}),g=t.dataIdMap.get(b.dataId));let T=g.id,x=t.dataIdMap.get(h.dataId).id;return uq(T,l,m,c,d,u,p,s?1:0,a?1:0,x),b!=null&&t.disposeData(b.dataId),h}var pq={kernelName:Oo,backendName:"wasm",setupFunc:whe,kernelFunc:Nhe};var lq;function Dhe(r){lq=r.wasm.cwrap(Ma,null,["number","array","number","array","number","number"])}function Fhe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{dims:s}=n,a=y.parseAxisParam(s,o.shape);if(o.shape.length===0)return mm({inputs:{x:o},backend:e});let i=e.makeOutput(o.shape,o.dtype),u=e.dataIdMap.get(o.dataId).id,p=e.dataIdMap.get(i.dataId).id,l=new Uint8Array(new Int32Array(a).buffer),m=new Uint8Array(new Int32Array(o.shape).buffer);lq(u,l,a.length,m,o.shape.length,p);let c=hr({inputs:{x:i},attrs:{shape:o.shape},backend:e});return e.disposeData(i.dataId),c}var mq={kernelName:Ma,backendName:"wasm",kernelFunc:Fhe,setupFunc:Dhe};var cq;function Rhe(r){cq=r.wasm.cwrap(Ga,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Phe(r){let{inputs:t,backend:e,attrs:n}=r,{image:o}=t,{radians:s,fillValue:a,center:i}=n,u=e.makeOutput(o.shape,o.dtype),p=e.dataIdMap.get(o.dataId).id,l=e.dataIdMap.get(u.dataId).id,[m,c,d,f]=o.shape,[h,g]=C.getImageCenter(i,c,d),b=a===0,T=255,x=typeof a=="number"?[a,a,a,b?0:T]:[...a,T],I=new Uint8Array(new Int32Array(x).buffer);return cq(p,m,c,d,f,s,h,g,I,x.length,l),u}var dq={kernelName:Ga,backendName:"wasm",kernelFunc:Phe,setupFunc:Rhe};var fq=lt(Ea);var hq=lt(Uo);var gq;function Mhe(r){gq=r.wasm.cwrap(_a,null,["number","number","number","number","number","number","array","number","number"])}function Ehe(r){let{backend:t,inputs:e,attrs:n}=r,{indices:o,updates:s}=e,{shape:a}=n,i=t.makeOutput(a,s.dtype);if(y.sizeFromShape(a)===0)return i;let{sliceRank:u,numUpdates:p,sliceSize:l,strides:m,outputSize:c}=Nh.calculateShapes(s,o,a),f=t.dataIdMap.get(o.dataId).id,g=t.dataIdMap.get(s.dataId).id,b=new Uint8Array(new Int32Array(m).buffer),T=t.dataIdMap.get(i.dataId).id;return gq(f,g,Je[s.dtype],u,p,l,b,c,T),i}var bq={kernelName:_a,backendName:"wasm",setupFunc:Mhe,kernelFunc:Ehe};var yq;function _he(r){yq=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function Lhe(r){let{inputs:t,backend:e}=r,{condition:n,t:o,e:s}=t,a=e.dataIdMap.get(n.dataId).id,i=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,p=e.makeOutput(o.shape,o.dtype),l=e.dataIdMap.get(p.dataId).id,m=n.shape.length,c=o.shape.length,d=m===0||m>1||c===1?1:y.sizeFromShape(o.shape.slice(1));return yq(a,i,u,d,l),p}var Tq={kernelName:Ts,backendName:"wasm",kernelFunc:Lhe,setupFunc:_he};var xq;function $he(r){xq=r.wasm.cwrap(Ko,null,["number","number"])}function Bhe(r){let{backend:t,inputs:{x:e}}=r,n=t.dataIdMap.get(e.dataId).id,o=t.makeOutput(e.shape,e.dtype),s=t.dataIdMap.get(o.dataId).id;return y.sizeFromShape(o.shape)===0||xq(n,s),o}var Iq={kernelName:"Sigmoid",backendName:"wasm",setupFunc:$he,kernelFunc:Bhe};var Cq=lt(Wo);var kq;function Ohe(r){kq=r.wasm.cwrap(qo,null,["number","number","number","number"])}function zhe(r){let{backend:t,inputs:{logits:e},attrs:{dim:n}}=r,o=t.dataIdMap.get(e.dataId).id,s=t.makeOutput(e.shape,e.dtype),a=t.dataIdMap.get(s.dataId).id,i=e.shape[n],u=y.sizeFromShape(e.shape)/i;return y.sizeFromShape(s.shape)===0||kq(o,a,i,u),s}var Sq={kernelName:qo,backendName:"wasm",setupFunc:Ohe,kernelFunc:zhe};function Ghe(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,{blockShape:s,paddings:a}=n,i=y.sizeFromShape(s),u=[[0,0]];u.push(...a);for(let w=1+s.length;w<o.shape.length;++w)u.push([0,0]);let p=Fk.kernelFunc({inputs:{x:o},backend:e,attrs:{paddings:u,constantValue:0}}),l=C.getReshaped(p.shape,s,i,!1),m=C.getPermuted(l.length,s.length,!1),c=C.getReshapedPermuted(p.shape,s,i,!1),h=hr({inputs:{x:p},backend:e,attrs:{shape:l}}),T=is({inputs:{x:h},backend:e,attrs:{perm:m}}),k=hr({inputs:{x:T},backend:e,attrs:{shape:c}});return e.disposeData(p.dataId),e.disposeData(h.dataId),e.disposeData(T.dataId),k}var vq={kernelName:Is,backendName:"wasm",kernelFunc:Ghe};var Aq;function Uhe(r){Aq=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Whe(r){let{backend:t,inputs:e}=r,{indices:n,values:o,denseShape:s,defaultValue:a}=e,i=n.shape[0],u=n.shape[1],p=t.readSync(s.dataId)[0],l=[i+p,u],m=t.dataIdMap.get(n.dataId).id,c=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(a.dataId).id,f=t.makeOutput(l,n.dtype),h=t.dataIdMap.get(f.dataId).id,g=t.makeOutput(l.slice(0,1),o.dtype),b=t.dataIdMap.get(g.dataId).id,T=t.makeOutput([p],"bool"),x=t.dataIdMap.get(T.dataId).id,I=t.makeOutput([i],n.dtype),k=t.dataIdMap.get(I.dataId).id,w=t.makeOutput([4],"int32"),R=t.dataIdMap.get(w.dataId).id,P=Aq(m,c,Je[o.dtype],i,p,u,d,h,b,x,k,R),M=t.readSync(w.dataId),L;switch(M[0]){case 1:{L=C.getSparseFillEmptyRowsIndicesDenseShapeMismatch(M[1]);break}case 2:{L=C.getSparseFillEmptyRowsNegativeIndexErrorMessage(M[1],M[2]);break}case 3:L=C.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(M[1],M[2],M[3]);break;default:L=""}if(t.disposeData(w.dataId),L)throw t.disposeData(f.dataId),t.disposeData(g.dataId),t.disposeData(T.dataId),t.disposeData(I.dataId),new Error(L);let z=f,W=g;return P!==l[0]&&(z=ra({inputs:{x:f},attrs:{begin:0,size:[P,u]},backend:t}),W=ra({inputs:{x:g},attrs:{begin:0,size:P},backend:t}),t.disposeData(f.dataId),t.disposeData(g.dataId)),[z,W,T,I]}var wq={kernelName:Ku,backendName:"wasm",setupFunc:Uhe,kernelFunc:Whe};var Nq;function Khe(r){Nq=r.wasm.cwrap(eu,null,["number","number","number","number","number","number","number"])}function Vhe(r){let{backend:t,inputs:e}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let a=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,p=n.shape[0],l=y.sizeFromShape(s.shape),m=t.makeOutput([p,l],n.dtype),c=t.dataIdMap.get(m.dataId).id,d=t.makeOutput([l],s.dtype),f=t.dataIdMap.get(d.dataId).id,h=t.makeOutput([3],"int32"),g=t.dataIdMap.get(h.dataId).id;Nq(a,i,u,p,c,f,g);let b=t.readSync(h.dataId),T;switch(b[0]){case 0:{T=C.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(b[1],b[2]);break}case 1:{T=C.getSparseReshapeNegativeOutputDimErrorMessage(b[1],b[2]);break}case 2:T=C.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let x=Array.from(t.readSync(o.dataId)),I=Array.from(t.readSync(d.dataId));T=C.getSparseReshapeInputOutputMultipleErrorMessage(x,I);break}case 4:{let x=Array.from(t.readSync(o.dataId)),I=Array.from(t.readSync(d.dataId));T=C.getSparseReshapeInputOutputMismatchErrorMessage(x,I);break}default:T=""}if(t.disposeData(h.dataId),T)throw t.disposeData(m.dataId),t.disposeData(d.dataId),new Error(T);return[m,d]}var Dq={kernelName:eu,backendName:"wasm",setupFunc:Khe,kernelFunc:Vhe};var Fq;function Rk(r){Fq=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function Pk(r,t){let{backend:e,inputs:n}=r,{data:o,indices:s,segmentIds:a}=n,i=s.shape[0],u=e.readSync(a.dataId,i-1,i)[0],l=i>0?u+1:0;if(l<0)throw new Error(C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=o.shape.slice();m[0]=l;let c=e.dataIdMap.get(o.dataId).id,d=e.dataIdMap.get(s.dataId).id,f=e.dataIdMap.get(a.dataId).id,h=e.makeOutput(m,o.dtype),g=e.dataIdMap.get(h.dataId).id,b=e.makeOutput([4],"int32"),T=e.dataIdMap.get(b.dataId).id;Fq(c,Je[o.dtype],o.shape[0],d,f,g,T,t,0);let x=e.readSync(b.dataId),I;switch(x[0]){case 0:{I=C.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{I=C.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:I=C.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x[1],x[2]);break;case 3:I=C.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(x[1],x[2],x[3]);break;default:I=""}if(e.disposeData(b.dataId),I)throw e.disposeData(h.dataId),new Error(I);return h}function Hhe(r){return Pk(r,!0)}var Rq={kernelName:Vu,backendName:"wasm",setupFunc:Rk,kernelFunc:Hhe};function qhe(r){return Pk(r,!1)}var Pq={kernelName:Hu,backendName:"wasm",setupFunc:Rk,kernelFunc:qhe};function jhe(r){let{inputs:t,attrs:e,backend:n}=r,{x:o}=t,{numOrSizeSplits:s,axis:a}=e,i=y.parseAxisParam(a,o.shape)[0],u=C.prepareSplitSize(o,s,i),p=new Array(o.shape.length).fill(0),l=o.shape.slice();return u.map(m=>{let c=[...l];c[i]=m;let d=ra({inputs:{x:o},attrs:{begin:p,size:c},backend:n});return p[i]+=m,d})}var Mq={kernelName:Cs,backendName:"wasm",kernelFunc:jhe};var Eq=lt(Vo);var _q=lt(gi);var Xhe=!0,Lq=ht(jo,Xhe);var $q;function Yhe(r){$q=r.wasm.cwrap(vs,null,["number","number","number","number"])}function Zhe(r){let{backend:t,inputs:e,attrs:n}=r,{alpha:o}=n,{x:s}=e,a=t.dataIdMap.get(s.dataId).id,i=t.makeOutput(s.shape,s.dtype),u=t.dataIdMap.get(i.dataId).id;return $q(a,o,Je[s.dtype],u),i}var Bq={kernelName:vs,backendName:"wasm",setupFunc:Yhe,kernelFunc:Zhe};var Oq;function Qhe(r){Oq=r.wasm.cwrap($a,null,["number","array","number","array","array","array","array","array","number","number"])}function Jhe(r){let{backend:t,inputs:e,attrs:n}=r,{x:o}=e,{begin:s,end:a,strides:i,beginMask:u,endMask:p,ellipsisMask:l,newAxisMask:m,shrinkAxisMask:c}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:b,begin:T,end:x,strides:I}=It.sliceInfo(o.shape,s,a,i,u,p,l,m,c),k;if(h)k=hr({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||b){y.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let w=It.computeOutShape(T,x,I),R=ra({inputs:{x:o},backend:t,attrs:{begin:T,size:w}});k=hr({inputs:{x:R},backend:t,attrs:{shape:f}}),t.disposeData(R.dataId)}else{let w=t.makeOutput(d,"float32"),R=t.dataIdMap.get(o.dataId).id,P=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),M=new Uint8Array(new Int32Array(T).buffer),L=new Uint8Array(new Int32Array(x).buffer),z=new Uint8Array(new Int32Array(I).buffer),W=new Uint8Array(new Int32Array(d).buffer),V=new Uint8Array(new Int32Array(y.computeStrides(d)).buffer),j=t.dataIdMap.get(w.dataId).id;Oq(R,P,o.shape.length,M,L,z,W,V,d.length,j),k=hr({inputs:{x:w},backend:t,attrs:{shape:f}}),t.disposeData(w.dataId)}return k}var zq={kernelName:$a,backendName:"wasm",setupFunc:Qhe,kernelFunc:Jhe};function ege(r){let{backend:t,inputs:e,attrs:n}=r,{data:o,dataSplits:s}=e,{separator:a,nGramWidths:i,leftPad:u,rightPad:p,padWidth:l,preserveShortSequences:m}=n,c=t.readSync(o.dataId),d=t.readSync(s.dataId),[f,h]=Kl(c,d,a,i,u,p,l,m),g=t.makeOutput([f.length],"string"),b=t.dataIdMap.get(g.dataId);b.stringBytes=f;let T=t.makeOutput(s.shape,"int32");return t.typedArrayFromHeap(T).set(h),[g,T]}var Gq={kernelName:bi,backendName:"wasm",kernelFunc:ege};function tge(r){let{backend:t,inputs:e,attrs:n}=r,{input:o,delimiter:s}=e,{skipEmpty:a}=n,i=t.readSync(o.dataId),u=t.readSync(s.dataId),[p,l,m]=Vl(i,u[0],a),c=l.length,d=t.makeOutput([c,2],"int32");t.typedArrayFromHeap(d).set(p);let h=t.makeOutput([c],"string"),g=t.dataIdMap.get(h.dataId);g.stringBytes=l;let b=t.makeOutput([2],"int32");return t.typedArrayFromHeap(b).set(m),[d,h,b]}var Uq={kernelName:ju,backendName:"wasm",kernelFunc:tge};function rge(r){let{backend:t,inputs:e,attrs:n}=r,{input:o}=e,{numBuckets:s}=n,a=t.readSync(o.dataId),i=Hl(a,s),u=t.makeOutput(o.shape,"int32");return t.typedArrayFromHeap(u).set(i),u}var Wq={kernelName:Xu,backendName:"wasm",kernelFunc:rge};var nge=!0,Kq=ht(Xo,nge);var Vq;function oge(r){Vq=r.wasm.cwrap(Ho,null,["number","number","number","number"])}function sge(r){let{backend:t,inputs:e,attrs:n}=r,{axis:o,keepDims:s}=n,{x:a}=e,i=t.dataIdMap.get(a.dataId).id,u=i,p=a,{transposed:l,axes:m,originalAxes:c,inputWasTransposed:d}=wn(a,o,t),f=m;if(d){let x=t.dataIdMap.get(l.dataId).id;x!==i&&(p=l,u=x,f=C.getInnerMostAxes(f.length,p.shape.length))}C.assertAxesAreInnerMostDims("sum",f,p.shape.length);let[h,g]=C.computeOutAndReduceShapes(p.shape,f),b=y.sizeFromShape(g),T=t.makeOutput(h,p.dtype);if(y.sizeFromShape(p.shape)!==0){let x=t.dataIdMap.get(T.dataId).id;Vq(u,b,Je[T.dtype],x)}if(d&&t.disposeData(l.dataId),s){let x=C.expandShapeToKeepDim(T.shape,c);T.shape=x}return T}var Hq={kernelName:Ho,backendName:"wasm",setupFunc:oge,kernelFunc:sge};var qq=lt(Ba);var jq=lt(Yo);var Xq;function age(r){Xq=r.wasm.cwrap(Dn,null,["number","array","number","array","number","number"])}function ige(r){let{inputs:t,backend:e,attrs:n}=r,{x:o}=t,s=e.dataIdMap.get(o.dataId).id,{reps:a}=n,i=new Array(o.shape.length);for(let c=0;c<i.length;c++)i[c]=o.shape[c]*a[c];let u=new Uint8Array(new Int32Array(o.shape).buffer),p=new Uint8Array(new Int32Array(i).buffer),l=e.makeOutput(i,o.dtype),m=e.dataIdMap.get(l.dataId).id;return Xq(s,u,o.shape.length,p,i.length,Je[l.dtype],m),l}var Yq={kernelName:Dn,backendName:"wasm",setupFunc:age,kernelFunc:ige};var Zq;function uge(r){Zq=r.wasm.cwrap(Oa,null,["number","array","number","number","number","bool","number","number"])}var pge=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{k:o,sorted:s}=e,a=t.dataIdMap.get(n.dataId).id,i=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let p=t.makeOutput(u,n.dtype),l=t.dataIdMap.get(p.dataId).id,m=t.makeOutput(u,"int32"),c=t.dataIdMap.get(m.dataId).id;return Zq(a,i,n.shape.length,Je[n.dtype],o,s,l,c),[p,m]},Qq={kernelName:Oa,backendName:"wasm",setupFunc:uge,kernelFunc:pge};var Jq;function lge(r){Jq=r.wasm.cwrap(za,null,["number","number","bool","number","number","number","number","number","number","array","number","array","number","number","number","number","number"])}function mge(r){let{backend:t,inputs:e,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:a,fillMode:i,fillValue:u,outputShape:p}=n,[l,m,c,d]=o.shape,[f,h]=p??[m,c],g=[l,f,h,d],b=new Uint8Array(new Int32Array(y.computeStrides(o.shape)).buffer),T=new Uint8Array(new Int32Array(y.computeStrides(g)).buffer),x=t.makeOutput(g,o.dtype),I=t.dataIdMap.get(x.dataId).id,w=t.dataIdMap.get(o.dataId).id,P=t.dataIdMap.get(s.dataId).id,M=a==="nearest"?1:2,L;switch(i){case"constant":L=1;break;case"reflect":L=2;break;case"wrap":L=3;break;case"nearest":L=4;break;default:L=1;break}return Jq(w,P,s.shape[0]>1,l,f,h,d,c,m,b,o.shape.length-1,T,g.length-1,M,L,u,I),x}var ej={kernelName:za,backendName:"wasm",setupFunc:lge,kernelFunc:mge};function cge(r){let{inputs:t,backend:e,attrs:n}=r,{value:o}=t,{axis:s}=n;s<0&&(s+=o.shape.length);let a=o.shape[s],i=o.shape.length,u=new Array(i-1),p=0;for(let d=0;d<i;d++)d!==s&&(u[p++]=o.shape[d]);let l=new Array(a),m=new Array(i).fill(0),c=o.shape.slice();c[s]=1;for(let d=0;d<l.length;d++)m[s]=d,l[d]=ra({inputs:{x:o},attrs:{begin:m,size:c},backend:e});return l.map(({dataId:d,dtype:f})=>({dataId:d,dtype:f,shape:u}))}var tj={kernelName:ks,backendName:"wasm",kernelFunc:cge};function dge(r){let{inputs:{x:t},backend:e}=r,n=e.makeOutput(t.shape,t.dtype);return e.typedArrayFromHeap(n).fill(0),n}var rj={kernelName:Ss,backendName:"wasm",kernelFunc:dge};var fge=[s4,a4,i4,p4,f4,g4,y4,x4,k4,v4,A4,w4,D4,F4,P4,E4,_4,L4,O4,G4,W4,V4,q4,j4,X4,Y4,Z4,Q4,eH,tH,rH,oH,aH,uH,lH,cH,dH,fH,l4,gH,bH,yH,TH,xH,IH,CH,kH,vH,AH,NH,FH,PH,MH,LH,$H,BH,zH,UH,KH,VH,qH,jH,XH,Fk,ZH,JH,tq,rq,nq,oq,sq,I4,iq,pq,mq,dq,fq,hq,bq,Tq,Iq,Cq,S4,Sq,vq,wq,Dq,Rq,Pq,Mq,Eq,_q,Lq,Bq,zq,Gq,Uq,Wq,Kq,Hq,qq,jq,Yq,Qq,ej,c4,tj,rj];for(let r of fge)tu(r);var T0=B();T0.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));T0.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(T0.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var D0=wm(sj());var Rt={},aj=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";aj&&(k0=x0(),S0=k0.parentPort,S0.on("message",function(r){onmessage({data:r})}),v0=lg(),Object.assign(global,{self:global,require:J0,Module:Rt,location:{href:__filename},Worker:k0.Worker,importScripts:function(r){(0,eval)(v0.readFileSync(r,"utf8"))},postMessage:function(r){S0.postMessage(r)},performance:global.performance||{now:function(){return Date.now()}}}));var k0,S0,v0;function hge(){var r=Array.prototype.slice.call(arguments).join(" ");if(aj){v0.writeSync(2,r+`
`);return}console.error(r)}function gge(){var r=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:r,threadId:Rt._pthread_self()})}var Ek=hge;self.alert=gge;Rt.instantiateWasm=(r,t)=>{var e=new WebAssembly.Instance(Rt.wasmModule,r);return t(e),Rt.wasmModule=null,e.exports};self.onmessage=r=>{try{if(r.data.cmd==="load"){if(Rt.wasmModule=r.data.wasmModule,Rt.wasmMemory=r.data.wasmMemory,Rt.buffer=Rt.wasmMemory.buffer,Rt.ENVIRONMENT_IS_PTHREAD=!0,typeof r.data.urlOrBlob=="string")importScripts(r.data.urlOrBlob);else{var t=URL.createObjectURL(r.data.urlOrBlob);importScripts(t),URL.revokeObjectURL(t)}WasmBackendModuleThreadedSimd(Rt).then(function(n){Rt=n})}else if(r.data.cmd==="run"){Rt.__performance_now_clock_drift=performance.now()-r.data.time,Rt.__emscripten_thread_init(r.data.threadInfoStruct,0,0,1),Rt.establishStackSpace(),Rt.PThread.receiveObjectTransfer(r.data),Rt.PThread.threadInit();try{var e=Rt.invokeEntryPoint(r.data.start_routine,r.data.arg);Rt.keepRuntimeAlive()?Rt.PThread.setExitStatus(e):Rt.__emscripten_thread_exit(e)}catch(n){if(n!="unwind")if(n instanceof Rt.ExitStatus)Rt.keepRuntimeAlive()||Rt.__emscripten_thread_exit(n.status);else throw n}}else r.data.cmd==="cancel"?Rt._pthread_self()&&Rt.__emscripten_thread_exit(-1):r.data.target==="setimmediate"||(r.data.cmd==="processThreadQueue"?Rt._pthread_self()&&Rt._emscripten_current_thread_process_queued_calls():r.data.cmd==="processProxyingQueue"?Rt._pthread_self()&&Rt._emscripten_proxy_execute_queue(r.data.queue):(Ek("worker.js received unknown command "+r.data.cmd),Ek(r.data)))}catch(n){throw Ek("worker.js onmessage() captured an uncaught exception: "+n),n&&n.stack&&Ek(n.stack),Rt.__emscripten_thread_crashed&&Rt.__emscripten_thread_crashed(),n}};var F0=wm(ij());var uj=D0.default||D0,bge=F0.default||F0,Vg=class extends no{constructor(e){super();this.wasm=e;this.dataIdNextNumber=1;this.wasm.tfjs.initWithThreadsCount(cj),N0=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new ma(this,Mn())}write(e,n,o){let s={id:this.dataIdNextNumber++};return this.move(s,e,n,o,1),s}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let n=y.now();return e(),{kernelMs:y.now()-n}}move(e,n,o,s,a){let i=this.dataIdNextNumber++;if(s==="string"){let m=n;this.dataIdMap.set(e,{id:i,stringBytes:m,shape:o,dtype:s,memoryOffset:null,refCount:a});return}let u=y.sizeFromShape(o),p=u*y.bytesPerElement(s),l=this.wasm._malloc(p);this.dataIdMap.set(e,{id:i,memoryOffset:l,shape:o,dtype:s,refCount:a}),this.wasm.tfjs.registerTensor(i,u,l),n!=null&&this.wasm.HEAPU8.set(new Uint8Array(n.buffer,n.byteOffset,p),l)}async read(e){return this.readSync(e)}readSync(e,n,o){let{memoryOffset:s,dtype:a,shape:i,stringBytes:u}=this.dataIdMap.get(e);if(a==="string")return(n==null||n===0)&&(o==null||o>=u.length)?u:u.slice(n,o);n=n||0,o=o||y.sizeFromShape(i);let p=y.bytesPerElement(a),l=this.wasm.HEAPU8.slice(s+n*p,s+o*p);return Tge(l.buffer,a)}disposeData(e,n=!1){if(this.dataIdMap.has(e)){let o=this.dataIdMap.get(e);if(o.refCount--,!n&&o.refCount>0)return!1;this.wasm._free(o.memoryOffset),this.wasm.tfjs.disposeData(o.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let n=this.dataIdMap.get(e);n!=null&&n.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,n,o){let s;if(o==null)s=this.write(null,e,n);else{let a=this.dataIdNextNumber++;s={id:a},this.dataIdMap.set(s,{id:a,memoryOffset:o,shape:e,dtype:n,refCount:1});let i=y.sizeFromShape(e);this.wasm.tfjs.registerTensor(a,i,o)}return{dataId:s,shape:e,dtype:n}}typedArrayFromHeap({shape:e,dtype:n,dataId:o}){let s=this.wasm.HEAPU8.buffer,{memoryOffset:a}=this.dataIdMap.get(o),i=y.sizeFromShape(e);switch(n){case"float32":return new Float32Array(s,a,i);case"int32":return new Int32Array(s,a,i);case"bool":return new Uint8Array(s,a,i);default:throw new Error(`Unknown dtype ${n}`)}}};function yge(r){return(t,e)=>(y.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||t.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,t).then(s=>{e(s.instance,s.module)})})}),{})}function pj(r,t,e){if(Lk!=null)return Lk;let n="tfjs-backend-wasm.wasm";return r&&t?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),Wg!=null&&Wg[n]!=null?Wg[n]:e+n}async function mj(){let[r,t]=await Promise.all([B().getAsync("WASM_HAS_SIMD_SUPPORT"),B().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((e,n)=>{let o={};o.locateFile=(i,u)=>{if(i.endsWith(".worker.js")){let p=(void 0).replace(/\n/g,"\\n"),l=new Blob([p],{type:"application/javascript"});return URL.createObjectURL(l)}return i.endsWith(".wasm")?pj(r,t,Ug??u):u+i},R0&&(o.instantiateWasm=yge(pj(r,t,Ug??"")));let s=!1;o.onAbort=()=>{if(s||Kg)return;Kg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let a;t&&r&&Lk==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+uj.toString()],{type:"text/javascript"}),a=uj(o)):a=bge(o),a.then(i=>{s=!0,Kg=!1;let u=null;i.tfjs={init:i.cwrap("init",null,[]),initWithThreadsCount:i.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:i.cwrap("get_threads_count","number",[]),registerTensor:i.cwrap("register_tensor",null,["number","number","number"]),disposeData:i.cwrap("dispose_data",u,["number"]),dispose:i.cwrap("dispose",u,[])},e({wasm:i})}).catch(n)})}function Tge(r,t){switch(t){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${t}`)}}var xge=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],Lk=null,Ug=null,Wg={},Kg=!1,R0=!1;function Ige(r,t=!1){if(rA("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Kg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");Lk=r,R0=t}function Cge(r,t=!1){if(Kg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")Ug=r;else{Wg=r;let e=xge.filter(n=>Wg[n]==null);if(e.length>0)throw new Error(`There were no entries found for the following binaries: ${e.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}R0=t}var cj=-1,N0=-1;function kge(r){cj=r}function Sge(){if(N0===-1)throw new Error("WASM backend not initialized.");return N0}var vge="0.0.0";var Age=2;rp("wasm",async()=>{let{wasm:r}=await mj();return new Vg(r)},Age);var Bp="3.20.0-20220828",nJr={tfjs:Bp,"tfjs-core":Bp,"tfjs-data":Bp,"tfjs-layers":Bp,"tfjs-converter":Bp,"tfjs-backend-cpu":Bp,"tfjs-backend-webgl":Bp,"tfjs-backend-wasm":Bp};export{ls as Abs,Li as Acos,$i as Acosh,gp as AdadeltaOptimizer,bp as AdagradOptimizer,yp as AdamOptimizer,Tp as AdamaxOptimizer,Nn as Add,so as AddN,Bi as All,Oi as Any,ao as ArgMax,di as ArgMin,zi as Asin,Gi as Asinh,Ui as Atan,fa as Atan2,Wi as Atanh,io as AvgPool,Eu as AvgPool3D,Mm as AvgPool3DGrad,Pm as AvgPoolGrad,Vg as BackendWasm,uo as BatchMatMul,ms as BatchToSpaceND,Em as Bincount,_m as BroadcastArgs,i1 as BroadcastTo,ex as Callback,cT as CallbackList,Wn as Cast,po as Ceil,Kn as ClipByValue,_u as Complex,Lu as ComplexAbs,cs as Concat,lo as Conv2D,Lm as Conv2DBackpropFilter,mo as Conv2DBackpropInput,$u as Conv3D,$m as Conv3DBackpropFilterV2,Bm as Conv3DBackpropInputV2,co as Cos,fo as Cosh,ga as CropAndResize,ha as Cumprod,ho as Cumsum,fT as CustomCallback,ma as DataStorage,Om as DenseBincount,ba as DepthToSpace,go as DepthwiseConv2dNative,zm as DepthwiseConv2dNativeBackpropFilter,Gm as DepthwiseConv2dNativeBackpropInput,Um as Diag,Bu as Dilation2D,hh as Dilation2DBackpropFilter,fh as Dilation2DBackpropInput,Sv as ENV,tx as EarlyStopping,Ou as Einsum,yo as Elu,Wm as EluGrad,ch as Environment,ya as Equal,Ki as Erf,To as Exp,ds as ExpandDims,Ta as Expm1,Km as FFT,fi as Fill,xa as FlipLeftRight,xo as Floor,Io as FloorDiv,jp as FromPixels,Co as FusedBatchNorm,ws as FusedConv2D,Ns as FusedDepthwiseConv2D,Ql as GPGPUContext,Ia as GatherNd,fs as GatherV2,sg as GraphModel,Ca as Greater,ko as GreaterEqual,dT as History,Vm as IFFT,Vn as Identity,zu as Imag,Nt as InputSpec,Vi as IsFinite,Hi as IsInf,ka as IsNan,no as KernelBackend,Gu as LRN,qm as LRNGrad,Wh as LayerVariable,Yn as LayersModel,So as LeakyRelu,Sa as Less,va as LessEqual,Hm as LinSpace,vo as Log,qi as Log1p,p1 as LogSoftmax,Aa as LogicalAnd,wa as LogicalNot,ji as LogicalOr,u1 as LogicalXor,Pge as LowerBound,mf as MathBackendCPU,Pf as MathBackendWebGL,Ao as Max,No as MaxPool,Uu as MaxPool3D,Xm as MaxPool3DGrad,jm as MaxPoolGrad,Ym as MaxPoolWithArgmax,wo as Maximum,Do as Mean,Fo as Min,Ro as Minimum,Po as MirrorPad,Xi as Mod,xp as MomentumOptimizer,Zm as Multinomial,Mo as Multiply,hs as Neg,Da as NonMaxSuppressionV3,Yi as NonMaxSuppressionV4,Fa as NonMaxSuppressionV5,Na as NotEqual,Gv as OP_SCOPE_SUFFIX,Ra as OneHot,gs as OnesLike,Vr as Optimizer,qa as OptimizerConstructors,bs as Pack,Eo as PadV2,Mge as Pool,_o as Pow,Lo as Prelu,$o as Prod,Ip as RMSPropOptimizer,ns as RNN,Qm as RaggedTensorToTensor,hi as Range,M1 as Rank,Wu as Real,bo as RealDiv,Pa as Reciprocal,Ha as Reduction,Bo as Relu,Go as Relu6,ys as Reshape,zo as ResizeBilinear,ec as ResizeBilinearGrad,Oo as ResizeNearestNeighbor,Jm as ResizeNearestNeighborGrad,Ma as Reverse,Ga as RotateWithOffset,Ea as Round,Uo as Rsqrt,Ai as SGDOptimizer,_a as ScatterNd,tc as SearchSorted,Ts as Select,Zi as Selu,Dl as Sequential,Ko as Sigmoid,Qi as Sign,Wo as Sin,La as Sinh,xs as Slice,qo as Softmax,Ji as Softplus,Is as SpaceToBatchND,Ku as SparseFillEmptyRows,eu as SparseReshape,Vu as SparseSegmentMean,Hu as SparseSegmentSum,qu as SparseToDense,Cs as SplitV,Vo as Sqrt,gi as Square,jo as SquaredDifference,vs as Step,$a as StridedSlice,bi as StringNGrams,ju as StringSplit,Xu as StringToHashBucketFast,Xo as Sub,Ho as Sum,tn as SymbolicTensor,Ba as Tan,Yo as Tanh,qe as Tensor,bt as TensorBuffer,Dn as Tile,Oa as TopK,za as Transform,Fn as Transpose,rc as Unique,ks as Unpack,Yu as UnsortedSegmentSum,Ege as UpperBound,nu as Variable,Uf as WebGPUBackend,Ss as ZerosLike,As as _FusedMatMul,Wt as abs,L2 as acos,$2 as acosh,Z as add,B2 as addN,Qb as all,Fh as any,op as argMax,O2 as argMin,z2 as asin,G2 as asinh,U2 as atan,W2 as atan2,K2 as atanh,hc as avgPool,ey as avgPool3d,g2 as backend,C as backend_util,q2 as basicLSTMCell,ap as batchNorm,ty as batchNorm2d,ry as batchNorm3d,ny as batchNorm4d,gc as batchToSpaceND,oy as bincount,_Z as booleanMaskAsync,X2 as broadcastArgs,ip as broadcastTo,Nr as broadcast_util,qb as browser,xe as buffer,fte as callbacks,oe as cast,Y2 as ceil,Gr as clipByValue,fn as clone,Rn as complex,ct as concat,sy as concat1d,ay as concat2d,iy as concat3d,uy as concat4d,AE as constraints,py as conv1d,es as conv2d,ly as conv2dTranspose,my as conv3d,dy as conv3dTranspose,Gge as copyRegisteredKernels,yc as cos,fy as cosh,$h as cosineWindow,Rh as cumprod,hy as cumsum,gn as customGrad,sL as data,Z2 as denseBincount,rA as deprecationWarn,Q2 as depthToSpace,up as depthwiseConv2d,Tte as deregisterOp,Ju as device_util,J2 as diag,eF as dilation2d,Rxe as disableDeprecationWarnings,Pe as dispose,Pxe as disposeVariables,me as div,tF as divNoNan,rF as dot,IA as dropout,nF as einsum,pp as elu,Fxe as enableDebugMode,Dxe as enableProdMode,CA as enclosingPowerOfTwo,Mn as engine,B as env,Yr as equal,oF as erf,iF as euclideanNorm,br as exp,_r as expandDims,uF as expm1,ol as eye,Nc as fft,ki as fill,Bxe as findBackend,Oxe as findBackendFactory,lp as floor,Zb as floorDiv,Bz as forceHalfFloat,fp as fused,mp as gather,KZ as gatherND,jb as gather_util,Lxe as getBackend,wv as getGradient,bh as getKernel,Nb as getKernelsForBackend,Sge as getThreadsCount,AD as gpgpu_util,JX as grad,eY as grads,mr as greater,Ms as greaterEqual,ll as ifft,np as imag,hp as image,qZ as inTopKAsync,wE as initializers,XA as input,Pn as io,_y as irfft,pF as isFinite,lF as isInf,mF as isNaN,Ut as keep,xr as kernel_impls,o_ as layers,Tc as leakyRelu,gy as less,Es as lessEqual,SA as linalg,cF as linspace,cre as loadGraphModel,dre as loadGraphModelSync,A9 as loadLayersModel,dF as localResponseNormalization,Ur as log,xc as log1p,fF as logSigmoid,Ty as logSoftmax,xy as logSumExp,Qr as logicalAnd,Ic as logicalNot,Iy as logicalOr,hF as logicalXor,qQ as losses,gF as lowerBound,je as matMul,y2 as math,hn as max,Cc as maxPool,ky as maxPool3d,bF as maxPoolWithArgmax,ts as maximum,Ot as mean,wh as memory,yF as meshgrid,s_ as metrics,Mh as min,cp as minimum,TF as mirrorPad,xF as mod,S9 as model,a_ as models,sl as moments,$Z as movingAverage,_ as mul,IF as multiRNNCell,CF as multinomial,et as neg,Bh as nextFrame,nl as norm,pu as notEqual,tp as oneHot,yr as ones,Lr as onesLike,A as op,kF as outerProduct,jn as pad,SF as pad1d,vF as pad2d,AF as pad3d,wF as pad4d,NF as pool,qn as pow,Sc as prelu,Gb as print,DF as prod,Mxe as profile,FF as raggedTensorToTensor,RF as rand,jF as randomGamma,ul as randomNormal,XF as randomStandardNormal,Si as randomUniform,dp as range,_xe as ready,iu as real,YF as reciprocal,rp as registerBackend,w9 as registerCallbackConstructor,m1 as registerGradient,tu as registerKernel,yte as registerOp,i_ as regularizers,Jr as relu,Ny as relu6,$xe as removeBackend,$ as reshape,Dr as reverse,ZF as reverse1d,QF as reverse2d,JF as reverse3d,eR as reverse4d,Dc as rfft,Dy as round,Fy as rsqrt,ce as scalar,OZ as scatterND,Nh as scatter_util,Eh as searchSorted,Ry as selu,Py as separableConv2d,v9 as sequential,te as serialization,M5 as setBackend,zxe as setPlatform,kge as setThreadsCount,Ige as setWasmPath,Cge as setWasmPaths,zN as setWebGLContext,tR as setdiff1dAsync,yf as shared,_n as sigmoid,rR as sign,HQ as signal,My as sin,Ey as sinh,Ge as slice,vc as slice1d,Lh as slice2d,Ac as slice3d,pl as slice4d,It as slice_util,wc as softmax,uu as softplus,kc as spaceToBatchND,jQ as sparse,UZ as sparseToDense,VQ as spectral,Fr as split,Bt as sqrt,Ye as square,Ly as squaredDifference,_s as squeeze,Tr as stack,vi as step,nR as stridedSlice,XQ as string,le as sub,de as sum,ou as sumOutType,oR as tan,sp as tanh,wr as tensor,Xt as tensor1d,Va as tensor2d,Hb as tensor3d,sR as tensor4d,aR as tensor5d,iR as tensor6d,Rs as tensor_util,_2 as test_util,U as tidy,Zr as tile,Exe as time,uR as topk,hl as train,Ke as transpose,Fc as truncatedNormal,pR as unique,zge as unregisterGradient,Oge as unregisterKernel,$y as unsortedSegmentSum,Wr as unstack,$t as upcastType,lR as upperBound,y as util,tY as valueAndGrad,rY as valueAndGrads,By as variable,by as variableGrads,nJr as version,hre as version_converter,p8 as version_core,Wre as version_cpu,Qh as version_layers,vge as version_wasm,_ae as version_webgl,Z8t as webgl,kf as webgl_util,e0 as webgpu_util,Kt as where,zy as whereAsync,Ct as zeros,Fe as zerosLike};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** @license See the LICENSE file. */
//# sourceMappingURL=tfjs.min.esm.js.map
