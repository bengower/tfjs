var sH=Object.create;var ib=Object.defineProperty;var aH=Object.getOwnPropertyDescriptor;var iH=Object.getOwnPropertyNames;var uH=Object.getPrototypeOf,lH=Object.prototype.hasOwnProperty;var aD=r=>ib(r,"__esModule",{value:!0});var _r=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),Xe=(r,e)=>{aD(r);for(var t in e)ib(r,t,{get:e[t],enumerable:!0})},pH=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let n of iH(e))!lH.call(r,n)&&n!=="default"&&ib(r,n,{get:()=>e[n],enumerable:!(t=aH(e,n))||t.enumerable});return r},wl=r=>pH(aD(ib(r!=null?sH(uH(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var _D=_r((Vde,wD)=>{wD.exports=Jt;var Ps=null;try{Ps=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Jt(r,e,t){this.low=r|0,this.high=e|0,this.unsigned=!!t}Jt.prototype.__isLong__;Object.defineProperty(Jt.prototype,"__isLong__",{value:!0});function Hn(r){return(r&&r.__isLong__)===!0}Jt.isLong=Hn;var bD={},yD={};function Pl(r,e){var t,n,o;return e?(r>>>=0,(o=0<=r&&r<256)&&(n=yD[r],n)?n:(t=er(r,(r|0)<0?-1:0,!0),o&&(yD[r]=t),t)):(r|=0,(o=-128<=r&&r<128)&&(n=bD[r],n)?n:(t=er(r,r<0?-1:0,!1),o&&(bD[r]=t),t))}Jt.fromInt=Pl;function Ms(r,e){if(isNaN(r))return e?Ml:Fs;if(e){if(r<0)return Ml;if(r>=TD)return SD}else{if(r<=-kD)return qn;if(r+1>=kD)return vD}return r<0?Ms(-r,e).neg():er(r%Pc|0,r/Pc|0,e)}Jt.fromNumber=Ms;function er(r,e,t){return new Jt(r,e,t)}Jt.fromBits=er;var mb=Math.pow;function Xk(r,e,t){if(r.length===0)throw Error("empty string");if(r==="NaN"||r==="Infinity"||r==="+Infinity"||r==="-Infinity")return Fs;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=r.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return Xk(r.substring(1),e,t).neg();for(var o=Ms(mb(t,8)),s=Fs,i=0;i<r.length;i+=8){var a=Math.min(8,r.length-i),u=parseInt(r.substring(i,i+a),t);if(a<8){var l=Ms(mb(t,a));s=s.mul(l).add(Ms(u))}else s=s.mul(o),s=s.add(Ms(u))}return s.unsigned=e,s}Jt.fromString=Xk;function wa(r,e){return typeof r=="number"?Ms(r,e):typeof r=="string"?Xk(r,e):er(r.low,r.high,typeof e=="boolean"?e:r.unsigned)}Jt.fromValue=wa;var xD=1<<16,EH=1<<24,Pc=xD*xD,TD=Pc*Pc,kD=TD/2,ID=Pl(EH),Fs=Pl(0);Jt.ZERO=Fs;var Ml=Pl(0,!0);Jt.UZERO=Ml;var Mc=Pl(1);Jt.ONE=Mc;var CD=Pl(1,!0);Jt.UONE=CD;var Yk=Pl(-1);Jt.NEG_ONE=Yk;var vD=er(4294967295|0,2147483647|0,!1);Jt.MAX_VALUE=vD;var SD=er(4294967295|0,4294967295|0,!0);Jt.MAX_UNSIGNED_VALUE=SD;var qn=er(0,2147483648|0,!1);Jt.MIN_VALUE=qn;var ke=Jt.prototype;ke.toInt=function(){return this.unsigned?this.low>>>0:this.low};ke.toNumber=function(){return this.unsigned?(this.high>>>0)*Pc+(this.low>>>0):this.high*Pc+(this.low>>>0)};ke.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(qn)){var t=Ms(e),n=this.div(t),o=n.mul(t).sub(this);return n.toString(e)+o.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=Ms(mb(e,6),this.unsigned),i=this,a="";;){var u=i.div(s),l=i.sub(u.mul(s)).toInt()>>>0,p=l.toString(e);if(i=u,i.isZero())return p+a;for(;p.length<6;)p="0"+p;a=""+p+a}};ke.getHighBits=function(){return this.high};ke.getHighBitsUnsigned=function(){return this.high>>>0};ke.getLowBits=function(){return this.low};ke.getLowBitsUnsigned=function(){return this.low>>>0};ke.getNumBitsAbs=function(){if(this.isNegative())return this.eq(qn)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};ke.isZero=function(){return this.high===0&&this.low===0};ke.eqz=ke.isZero;ke.isNegative=function(){return!this.unsigned&&this.high<0};ke.isPositive=function(){return this.unsigned||this.high>=0};ke.isOdd=function(){return(this.low&1)==1};ke.isEven=function(){return(this.low&1)==0};ke.equals=function(e){return Hn(e)||(e=wa(e)),this.unsigned!==e.unsigned&&this.high>>>31==1&&e.high>>>31==1?!1:this.high===e.high&&this.low===e.low};ke.eq=ke.equals;ke.notEquals=function(e){return!this.eq(e)};ke.neq=ke.notEquals;ke.ne=ke.notEquals;ke.lessThan=function(e){return this.comp(e)<0};ke.lt=ke.lessThan;ke.lessThanOrEqual=function(e){return this.comp(e)<=0};ke.lte=ke.lessThanOrEqual;ke.le=ke.lessThanOrEqual;ke.greaterThan=function(e){return this.comp(e)>0};ke.gt=ke.greaterThan;ke.greaterThanOrEqual=function(e){return this.comp(e)>=0};ke.gte=ke.greaterThanOrEqual;ke.ge=ke.greaterThanOrEqual;ke.compare=function(e){if(Hn(e)||(e=wa(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};ke.comp=ke.compare;ke.negate=function(){return!this.unsigned&&this.eq(qn)?qn:this.not().add(Mc)};ke.neg=ke.negate;ke.add=function(e){Hn(e)||(e=wa(e));var t=this.high>>>16,n=this.high&65535,o=this.low>>>16,s=this.low&65535,i=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,p=0,c=0,m=0,d=0;return d+=s+l,m+=d>>>16,d&=65535,m+=o+u,c+=m>>>16,m&=65535,c+=n+a,p+=c>>>16,c&=65535,p+=t+i,p&=65535,er(m<<16|d,p<<16|c,this.unsigned)};ke.subtract=function(e){return Hn(e)||(e=wa(e)),this.add(e.neg())};ke.sub=ke.subtract;ke.multiply=function(e){if(this.isZero())return Fs;if(Hn(e)||(e=wa(e)),Ps){var t=Ps.mul(this.low,this.high,e.low,e.high);return er(t,Ps.get_high(),this.unsigned)}if(e.isZero())return Fs;if(this.eq(qn))return e.isOdd()?qn:Fs;if(e.eq(qn))return this.isOdd()?qn:Fs;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(ID)&&e.lt(ID))return Ms(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,o=this.high&65535,s=this.low>>>16,i=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,p=e.low&65535,c=0,m=0,d=0,f=0;return f+=i*p,d+=f>>>16,f&=65535,d+=s*p,m+=d>>>16,d&=65535,d+=i*l,m+=d>>>16,d&=65535,m+=o*p,c+=m>>>16,m&=65535,m+=s*l,c+=m>>>16,m&=65535,m+=i*u,c+=m>>>16,m&=65535,c+=n*p+o*l+s*u+i*a,c&=65535,er(d<<16|f,c<<16|m,this.unsigned)};ke.mul=ke.multiply;ke.divide=function(e){if(Hn(e)||(e=wa(e)),e.isZero())throw Error("division by zero");if(Ps){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?Ps.div_u:Ps.div_s)(this.low,this.high,e.low,e.high);return er(t,Ps.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?Ml:Fs;var n,o,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return Ml;if(e.gt(this.shru(1)))return CD;s=Ml}else{if(this.eq(qn)){if(e.eq(Mc)||e.eq(Yk))return qn;if(e.eq(qn))return Mc;var i=this.shr(1);return n=i.div(e).shl(1),n.eq(Fs)?e.isNegative()?Mc:Yk:(o=this.sub(e.mul(n)),s=n.add(o.div(e)),s)}else if(e.eq(qn))return this.unsigned?Ml:Fs;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=Fs}for(o=this;o.gte(e);){n=Math.max(1,Math.floor(o.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),u=a<=48?1:mb(2,a-48),l=Ms(n),p=l.mul(e);p.isNegative()||p.gt(o);)n-=u,l=Ms(n,this.unsigned),p=l.mul(e);l.isZero()&&(l=Mc),s=s.add(l),o=o.sub(p)}return s};ke.div=ke.divide;ke.modulo=function(e){if(Hn(e)||(e=wa(e)),Ps){var t=(this.unsigned?Ps.rem_u:Ps.rem_s)(this.low,this.high,e.low,e.high);return er(t,Ps.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};ke.mod=ke.modulo;ke.rem=ke.modulo;ke.not=function(){return er(~this.low,~this.high,this.unsigned)};ke.and=function(e){return Hn(e)||(e=wa(e)),er(this.low&e.low,this.high&e.high,this.unsigned)};ke.or=function(e){return Hn(e)||(e=wa(e)),er(this.low|e.low,this.high|e.high,this.unsigned)};ke.xor=function(e){return Hn(e)||(e=wa(e)),er(this.low^e.low,this.high^e.high,this.unsigned)};ke.shiftLeft=function(e){return Hn(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?er(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):er(0,this.low<<e-32,this.unsigned)};ke.shl=ke.shiftLeft;ke.shiftRight=function(e){return Hn(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?er(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):er(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};ke.shr=ke.shiftRight;ke.shiftRightUnsigned=function(e){if(Hn(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var n=this.low;return er(n>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?er(t,0,this.unsigned):er(t>>>e-32,0,this.unsigned)};ke.shru=ke.shiftRightUnsigned;ke.shr_u=ke.shiftRightUnsigned;ke.toSigned=function(){return this.unsigned?er(this.low,this.high,!1):this};ke.toUnsigned=function(){return this.unsigned?this:er(this.low,this.high,!0)};ke.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};ke.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};ke.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};Jt.fromBytes=function(e,t,n){return n?Jt.fromBytesLE(e,t):Jt.fromBytesBE(e,t)};Jt.fromBytesLE=function(e,t){return new Jt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};Jt.fromBytesBE=function(e,t){return new Jt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}});var h0=_r(()=>{});var g0=_r(()=>{});var Z0=_r((Q0,dC)=>{(function(r,e,t){function n(a){var u=this,l=i();u.next=function(){var p=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=p-(u.c=p|0)},u.c=1,u.s0=l(" "),u.s1=l(" "),u.s2=l(" "),u.s0-=l(a),u.s0<0&&(u.s0+=1),u.s1-=l(a),u.s1<0&&(u.s1+=1),u.s2-=l(a),u.s2<0&&(u.s2+=1),l=null}function o(a,u){return u.c=a.c,u.s0=a.s0,u.s1=a.s1,u.s2=a.s2,u}function s(a,u){var l=new n(a),p=u&&u.state,c=l.next;return c.int32=function(){return l.next()*4294967296|0},c.double=function(){return c()+(c()*2097152|0)*11102230246251565e-32},c.quick=c,p&&(typeof p=="object"&&o(p,l),c.state=function(){return o(l,{})}),c}function i(){var a=4022871197,u=function(l){l=String(l);for(var p=0;p<l.length;p++){a+=l.charCodeAt(p);var c=.02519603282416938*a;a=c>>>0,c-=a,c*=a,a=c>>>0,c-=a,a+=c*4294967296}return(a>>>0)*23283064365386963e-26};return u}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.alea=s})(Q0,typeof dC=="object"&&dC,typeof define=="function"&&define)});var e2=_r((J0,fC)=>{(function(r,e,t){function n(i){var a=this,u="";a.x=0,a.y=0,a.z=0,a.w=0,a.next=function(){var p=a.x^a.x<<11;return a.x=a.y,a.y=a.z,a.z=a.w,a.w^=a.w>>>19^p^p>>>8},i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a}function s(i,a){var u=new n(i),l=a&&a.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,d=(c+m)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor128=s})(J0,typeof fC=="object"&&fC,typeof define=="function"&&define)});var r2=_r((t2,hC)=>{(function(r,e,t){function n(i){var a=this,u="";a.next=function(){var p=a.x^a.x>>>2;return a.x=a.y,a.y=a.z,a.z=a.w,a.w=a.v,(a.d=a.d+362437|0)+(a.v=a.v^a.v<<4^(p^p<<1))|0},a.x=0,a.y=0,a.z=0,a.w=0,a.v=0,i===(i|0)?a.x=i:u+=i;for(var l=0;l<u.length+64;l++)a.x^=u.charCodeAt(l)|0,l==u.length&&(a.d=a.x<<10^a.x>>>4),a.next()}function o(i,a){return a.x=i.x,a.y=i.y,a.z=i.z,a.w=i.w,a.v=i.v,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,d=(c+m)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorwow=s})(t2,typeof hC=="object"&&hC,typeof define=="function"&&define)});var o2=_r((n2,gC)=>{(function(r,e,t){function n(i){var a=this;a.next=function(){var l=a.x,p=a.i,c,m,d;return c=l[p],c^=c>>>7,m=c^c<<24,c=l[p+1&7],m^=c^c>>>10,c=l[p+3&7],m^=c^c>>>3,c=l[p+4&7],m^=c^c<<7,c=l[p+7&7],c=c^c<<13,m^=c^c<<9,l[p]=m,a.i=p+1&7,m};function u(l,p){var c,m,d=[];if(p===(p|0))m=d[0]=p;else for(p=""+p,c=0;c<p.length;++c)d[c&7]=d[c&7]<<15^p.charCodeAt(c)+d[c+1&7]<<13;for(;d.length<8;)d.push(0);for(c=0;c<8&&d[c]===0;++c);for(c==8?m=d[7]=-1:m=d[c],l.x=d,l.i=0,c=256;c>0;--c)l.next()}u(a,i)}function o(i,a){return a.x=i.x.slice(),a.i=i.i,a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,d=(c+m)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(l.x&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xorshift7=s})(n2,typeof gC=="object"&&gC,typeof define=="function"&&define)});var a2=_r((s2,bC)=>{(function(r,e,t){function n(i){var a=this;a.next=function(){var l=a.w,p=a.X,c=a.i,m,d;return a.w=l=l+1640531527|0,d=p[c+34&127],m=p[c=c+1&127],d^=d<<13,m^=m<<17,d^=d>>>15,m^=m>>>12,d=p[c]=d^m,a.i=c,d+(l^l>>>16)|0};function u(l,p){var c,m,d,f,h,g=[],x=128;for(p===(p|0)?(m=p,p=null):(p=p+"\0",m=0,x=Math.max(x,p.length)),d=0,f=-32;f<x;++f)p&&(m^=p.charCodeAt((f+32)%p.length)),f===0&&(h=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,f>=0&&(h=h+1640531527|0,c=g[f&127]^=m+h,d=c==0?d+1:0);for(d>=128&&(g[(p&&p.length||0)&127]=-1),d=127,f=4*128;f>0;--f)m=g[d+34&127],c=g[d=d+1&127],m^=m<<13,c^=c<<17,m^=m>>>15,c^=c>>>12,g[d]=m^c;l.w=h,l.X=g,l.i=d}u(a,i)}function o(i,a){return a.i=i.i,a.w=i.w,a.X=i.X.slice(),a}function s(i,a){i==null&&(i=+new Date);var u=new n(i),l=a&&a.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,d=(c+m)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(l.X&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.xor4096=s})(s2,typeof bC=="object"&&bC,typeof define=="function"&&define)});var u2=_r((i2,yC)=>{(function(r,e,t){function n(i){var a=this,u="";a.next=function(){var p=a.b,c=a.c,m=a.d,d=a.a;return p=p<<25^p>>>7^c,c=c-m|0,m=m<<24^m>>>8^d,d=d-p|0,a.b=p=p<<20^p>>>12^c,a.c=c=c-m|0,a.d=m<<16^c>>>16^d,a.a=d-p|0},a.a=0,a.b=0,a.c=2654435769|0,a.d=1367130551,i===Math.floor(i)?(a.a=i/4294967296|0,a.b=i|0):u+=i;for(var l=0;l<u.length+20;l++)a.b^=u.charCodeAt(l)|0,a.next()}function o(i,a){return a.a=i.a,a.b=i.b,a.c=i.c,a.d=i.d,a}function s(i,a){var u=new n(i),l=a&&a.state,p=function(){return(u.next()>>>0)/4294967296};return p.double=function(){do var c=u.next()>>>11,m=(u.next()>>>0)/4294967296,d=(c+m)/(1<<21);while(d===0);return d},p.int32=u.next,p.quick=p,l&&(typeof l=="object"&&o(l,u),p.state=function(){return o(u,{})}),p}e&&e.exports?e.exports=s:t&&t.amd?t(function(){return s}):this.tychei=s})(i2,typeof yC=="object"&&yC,typeof define=="function"&&define)});var l2=_r(()=>{});var c2=_r((p2,Rb)=>{(function(r,e,t){var n=256,o=6,s=52,i="random",a=t.pow(n,o),u=t.pow(2,s),l=u*2,p=n-1,c;function m(T,k,C){var A=[];k=k==!0?{entropy:!0}:k||{};var M=g(h(k.entropy?[T,y(e)]:T??x(),3),A),P=new d(A),F=function(){for(var B=P.g(o),U=a,W=0;B<u;)B=(B+W)*n,U*=n,W=P.g(1);for(;B>=l;)B/=2,U/=2,W>>>=1;return(B+W)/U};return F.int32=function(){return P.g(4)|0},F.quick=function(){return P.g(4)/4294967296},F.double=F,g(y(P.S),e),(k.pass||C||function(B,U,W,K){return K&&(K.S&&f(K,P),B.state=function(){return f(P,{})}),W?(t[i]=B,U):B})(F,M,"global"in k?k.global:this==t,k.state)}function d(T){var k,C=T.length,A=this,M=0,P=A.i=A.j=0,F=A.S=[];for(C||(T=[C++]);M<n;)F[M]=M++;for(M=0;M<n;M++)F[M]=F[P=p&P+T[M%C]+(k=F[M])],F[P]=k;(A.g=function(B){for(var U,W=0,K=A.i,j=A.j,V=A.S;B--;)U=V[K=p&K+1],W=W*n+V[p&(V[K]=V[j=p&j+U])+(V[j]=U)];return A.i=K,A.j=j,W})(n)}function f(T,k){return k.i=T.i,k.j=T.j,k.S=T.S.slice(),k}function h(T,k){var C=[],A=typeof T,M;if(k&&A=="object")for(M in T)try{C.push(h(T[M],k-1))}catch{}return C.length?C:A=="string"?T:T+"\0"}function g(T,k){for(var C=T+"",A,M=0;M<C.length;)k[p&M]=p&(A^=k[p&M]*19)+C.charCodeAt(M++);return y(k)}function x(){try{var T;return c&&(T=c.randomBytes)?T=T(n):(T=new Uint8Array(n),(r.crypto||r.msCrypto).getRandomValues(T)),y(T)}catch{var k=r.navigator,C=k&&k.plugins;return[+new Date,r,C,r.screen,y(e)]}}function y(T){return String.fromCharCode.apply(0,T)}if(g(t.random(),e),typeof Rb=="object"&&Rb.exports){Rb.exports=m;try{c=l2()}catch{}}else typeof define=="function"&&define.amd?define(function(){return m}):t["seed"+i]=m})(typeof self!="undefined"?self:p2,[],Math)});var Wd=_r((sPe,m2)=>{var K8=Z0(),V8=e2(),j8=r2(),H8=o2(),q8=a2(),X8=u2(),Ql=c2();Ql.alea=K8;Ql.xor128=V8;Ql.xorwow=j8;Ql.xorshift7=H8;Ql.xor4096=q8;Ql.tychei=X8;m2.exports=Ql});var xS=_r(()=>{});var Oh=_r(()=>{});var Qm=_r(()=>{});var ej=_r(()=>{});var tj=_r(()=>{});var rj=_r(()=>{});var nj=_r((lT,GN)=>{var zN=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};function t(){return se.buffer!=at&&Gr(se.buffer),Ut}function n(){return se.buffer!=at&&Gr(se.buffer),On}function o(){return se.buffer!=at&&Gr(se.buffer),zr}function s(){return se.buffer!=at&&Gr(se.buffer),as}function i(){return se.buffer!=at&&Gr(se.buffer),zn}var a=typeof e!="undefined"?e:{},u,l;a.ready=new Promise(function(w,E){u=w,l=E});var p;typeof process!="undefined"&&process.listeners&&(p={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var c={},m;for(m in a)a.hasOwnProperty(m)&&(c[m]=a[m]);var d=[],f="./this.program",h=function(w,E){throw E},g=!1,x=!1,y=!1,T=!1;g=typeof window=="object",x=typeof importScripts=="function",y=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",T=!g&&!y&&!x;var k=a.ENVIRONMENT_IS_PTHREAD||!1;k&&(at=a.buffer);var C="";function A(w){return a.locateFile?a.locateFile(w,C):C+w}var M,P,F,B,U,W;if(y){x?C=Qm().dirname(C)+"/":C=__dirname+"/",M=function(E,z){return U||(U=Oh()),W||(W=Qm()),E=W.normalize(E),U.readFileSync(E,z?null:"utf8")},F=function(E){var z=M(E,!0);return z.buffer||(z=new Uint8Array(z)),Te(z.buffer),z},process.argv.length>1&&(f=process.argv[1].replace(/\\/g,"/")),d=process.argv.slice(2),process.on("uncaughtException",function(w){if(!(w instanceof pd))throw w}),process.on("unhandledRejection",wi),h=function(w){process.exit(w)},a.inspect=function(){return"[Emscripten Module object]"};var K;try{K=ej()}catch(w){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),w}global.Worker=K.Worker}else T?(typeof read!="undefined"&&(M=function(E){return read(E)}),F=function(E){var z;return typeof readbuffer=="function"?new Uint8Array(readbuffer(E)):(z=read(E,"binary"),Te(typeof z=="object"),z)},typeof scriptArgs!="undefined"?d=scriptArgs:typeof arguments!="undefined"&&(d=arguments),typeof quit=="function"&&(h=function(w){quit(w)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(g||x)&&(x?C=self.location.href:typeof document!="undefined"&&document.currentScript&&(C=document.currentScript.src),typeof r!="undefined"&&r&&(C=r),C.indexOf("blob:")!==0?C=C.substr(0,C.lastIndexOf("/")+1):C="",y?(M=function(E,z){return U||(U=Oh()),W||(W=Qm()),E=W.normalize(E),U.readFileSync(E,z?null:"utf8")},F=function(E){var z=M(E,!0);return z.buffer||(z=new Uint8Array(z)),Te(z.buffer),z}):(M=function(w){var E=new XMLHttpRequest;return E.open("GET",w,!1),E.send(null),E.responseText},x&&(F=function(w){var E=new XMLHttpRequest;return E.open("GET",w,!1),E.responseType="arraybuffer",E.send(null),new Uint8Array(E.response)}),P=function(w,E,z){var H=new XMLHttpRequest;H.open("GET",w,!0),H.responseType="arraybuffer",H.onload=function(){if(H.status==200||H.status==0&&H.response){E(H.response);return}z()},H.onerror=z,H.send(null)}),B=function(w){document.title=w});y&&typeof performance=="undefined"&&(global.performance=tj().performance);var j=a.print||console.log.bind(console),V=a.printErr||console.warn.bind(console);for(m in c)c.hasOwnProperty(m)&&(a[m]=c[m]);c=null,a.arguments&&(d=a.arguments),a.thisProgram&&(f=a.thisProgram),a.quit&&(h=a.quit);function q(w){q.shown||(q.shown={}),q.shown[w]||(q.shown[w]=1,V(w))}var ee=Atomics.load,Z=Atomics.store,te=Atomics.compareExchange,oe;a.wasmBinary&&(oe=a.wasmBinary);var ie=a.noExitRuntime||!0;typeof WebAssembly!="object"&&wi("no native wasm support detected");var se,ue,ye=!1,fe;function Te(w,E){w||wi("Assertion failed: "+E)}function we(w){var E=a["_"+w];return Te(E,"Cannot call unknown function "+w+", make sure it is exported"),E}function Re(w,E,z,H,xe){var ge={string:function(an){var ec=0;if(an!=null&&an!==0){var sD=(an.length<<2)+1;ec=Qp(sD),It(an,ec,sD)}return ec},array:function(an){var ec=Qp(an.length);return Gt(an,ec),ec}};function be(an){return E==="string"?Y(an):E==="boolean"?Boolean(an):an}var Pe=we(w),Dt=[],Fr=0;if(H)for(var wr=0;wr<H.length;wr++){var Fu=ge[z[wr]];Fu?(Fr===0&&(Fr=ld()),Dt[wr]=Fu(H[wr])):Dt[wr]=H[wr]}var Jp=Pe.apply(null,Dt);return Jp=be(Jp),Fr!==0&&Yp(Fr),Jp}function Le(w,E,z,H){z=z||[];var xe=z.every(function(be){return be==="number"}),ge=E!=="string";return ge&&xe&&!H?we(w):function(){return Re(w,E,z,arguments,H)}}function Ue(w,E,z){for(var H=E+z,xe="";!(E>=H);){var ge=w[E++];if(!ge)return xe;if(!(ge&128)){xe+=String.fromCharCode(ge);continue}var be=w[E++]&63;if((ge&224)==192){xe+=String.fromCharCode((ge&31)<<6|be);continue}var Pe=w[E++]&63;if((ge&240)==224?ge=(ge&15)<<12|be<<6|Pe:ge=(ge&7)<<18|be<<12|Pe<<6|w[E++]&63,ge<65536)xe+=String.fromCharCode(ge);else{var Dt=ge-65536;xe+=String.fromCharCode(55296|Dt>>10,56320|Dt&1023)}}return xe}function Y(w,E){return w?Ue(n(),w,E):""}function gt(w,E,z,H){if(!(H>0))return 0;for(var xe=z,ge=z+H-1,be=0;be<w.length;++be){var Pe=w.charCodeAt(be);if(Pe>=55296&&Pe<=57343){var Dt=w.charCodeAt(++be);Pe=65536+((Pe&1023)<<10)|Dt&1023}if(Pe<=127){if(z>=ge)break;E[z++]=Pe}else if(Pe<=2047){if(z+1>=ge)break;E[z++]=192|Pe>>6,E[z++]=128|Pe&63}else if(Pe<=65535){if(z+2>=ge)break;E[z++]=224|Pe>>12,E[z++]=128|Pe>>6&63,E[z++]=128|Pe&63}else{if(z+3>=ge)break;E[z++]=240|Pe>>18,E[z++]=128|Pe>>12&63,E[z++]=128|Pe>>6&63,E[z++]=128|Pe&63}}return E[z]=0,z-xe}function It(w,E,z){return gt(w,n(),E,z)}function Nt(w){for(var E=0,z=0;z<w.length;++z){var H=w.charCodeAt(z);H>=55296&&H<=57343&&(H=65536+((H&1023)<<10)|w.charCodeAt(++z)&1023),H<=127?++E:H<=2047?E+=2:H<=65535?E+=3:E+=4}return E}function Gt(w,E){t().set(w,E)}function ft(w,E){return w%E>0&&(w+=E-w%E),w}var at,Ut,On,pr,ss,zr,as,vn,zn;function Gr(w){at=w,a.HEAP8=Ut=new Int8Array(w),a.HEAP16=pr=new Int16Array(w),a.HEAP32=zr=new Int32Array(w),a.HEAPU8=On=new Uint8Array(w),a.HEAPU16=ss=new Uint16Array(w),a.HEAPU32=as=new Uint32Array(w),a.HEAPF32=vn=new Float32Array(w),a.HEAPF64=zn=new Float64Array(w)}var ro=a.INITIAL_MEMORY||16777216;if(k)se=a.wasmMemory,at=a.buffer;else if(a.wasmMemory)se=a.wasmMemory;else if(se=new WebAssembly.Memory({initial:ro/65536,maximum:2147483648/65536,shared:!0}),!(se.buffer instanceof SharedArrayBuffer))throw V("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),y&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");se&&(at=se.buffer),ro=at.byteLength,Gr(at);var br,is=[],us=[],kl=[],Zm=[],Gn=[],Kp=!1,Jm=!1;k||us.push({func:function(){Zg()}});function Rg(){if(!k){if(a.preRun)for(typeof a.preRun=="function"&&(a.preRun=[a.preRun]);a.preRun.length;)dT(a.preRun.shift());Vp(is)}}function Lg(){Kp=!0,!k&&Vp(us)}function Bg(){k||Vp(kl)}function Sn(){k||(Jm=!0)}function $g(){if(!k){if(a.postRun)for(typeof a.postRun=="function"&&(a.postRun=[a.postRun]);a.postRun.length;)fT(a.postRun.shift());Vp(Gn)}}function dT(w){is.unshift(w)}function fT(w){Gn.unshift(w)}var ls=0,ed=null,Il=null;function hT(w){Te(!k,"addRunDependency cannot be used in a pthread worker"),ls++,a.monitorRunDependencies&&a.monitorRunDependencies(ls)}function gT(w){if(ls--,a.monitorRunDependencies&&a.monitorRunDependencies(ls),ls==0&&(ed!==null&&(clearInterval(ed),ed=null),Il)){var E=Il;Il=null,E()}}a.preloadedImages={},a.preloadedAudios={};function wi(w){a.onAbort&&a.onAbort(w),k&&console.error("Pthread aborting at "+new Error().stack),w+="",V(w),ye=!0,fe=1,w="abort("+w+"). Build with -s ASSERTIONS=1 for more info.";var E=new WebAssembly.RuntimeError(w);throw l(E),E}function Cl(w,E){return String.prototype.startsWith?w.startsWith(E):w.indexOf(E)===0}var bT="data:application/octet-stream;base64,";function Og(w){return Cl(w,bT)}var yT="file://";function zg(w){return Cl(w,yT)}var wn="tfjs-backend-wasm-threaded-simd.wasm";Og(wn)||(wn=A(wn));function xT(w){try{if(w==wn&&oe)return new Uint8Array(oe);if(F)return F(w);throw"both async and sync fetching of the wasm failed"}catch(E){wi(E)}}function Gg(){if(!oe&&(g||x)){if(typeof fetch=="function"&&!zg(wn))return fetch(wn,{credentials:"same-origin"}).then(function(w){if(!w.ok)throw"failed to load wasm binary file at '"+wn+"'";return w.arrayBuffer()}).catch(function(){return xT(wn)});if(P)return new Promise(function(w,E){P(wn,function(z){w(new Uint8Array(z))},E)})}return Promise.resolve().then(function(){return xT(wn)})}function TT(){var w={a:mk};function E(be,Pe){var Dt=be.exports;if(a.asm=Dt,br=a.asm.nb,ue=Pe,!k){var Fr=Me.unusedWorkers.length;Me.unusedWorkers.forEach(function(wr){Me.loadWasmModuleToWorker(wr,function(){--Fr||gT("wasm-instantiate")})})}}k||hT("wasm-instantiate");function z(be){E(be.instance,be.module)}function H(be){return Gg().then(function(Pe){return WebAssembly.instantiate(Pe,w)}).then(be,function(Pe){V("failed to asynchronously prepare wasm: "+Pe),wi(Pe)})}function xe(){return!oe&&typeof WebAssembly.instantiateStreaming=="function"&&!Og(wn)&&!zg(wn)&&typeof fetch=="function"?fetch(wn,{credentials:"same-origin"}).then(function(be){var Pe=WebAssembly.instantiateStreaming(be,w);return Pe.then(z,function(Dt){return V("wasm streaming compile failed: "+Dt),V("falling back to ArrayBuffer instantiation"),H(z)})}):H(z)}if(a.instantiateWasm)try{var ge=a.instantiateWasm(w,E);return ge}catch(be){return V("Module.instantiateWasm callback failed with error: "+be),!1}return xe().catch(l),{}}var Ug={10216:function(){throw"Canceled!"},10234:function(w,E){setTimeout(function(){JN(w,E)},0)}};function kT(){Me.initRuntime()}function Vp(w){for(;w.length>0;){var E=w.shift();if(typeof E=="function"){E(a);continue}var z=E.func;typeof z=="number"?E.arg===void 0?br.get(z)():br.get(z)(E.arg):z(E.arg===void 0?null:E.arg)}}var Au={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};function td(w,E){if(w<=0||w>t().length||w&!0||E<0)return-28;if(E==0)return 0;E>=2147483647&&(E=1/0);var z=Atomics.load(o(),Zp>>2),H=0;if(z==w){var xe=Atomics.compareExchange(o(),Zp>>2,z,0);if(xe==z&&(--E,H=1,E<=0))return 1}var ge=Atomics.notify(o(),w>>2,E);if(ge>=0)return ge+H;throw"Atomics.notify returned an unexpected value "+ge}a._emscripten_futex_wake=td;function IT(w){if(k)throw"Internal Error! killThread() can only ever be called from main application thread!";if(!w)throw"Internal Error! Null pthread_ptr in killThread!";o()[w+12>>2]=0;var E=Me.pthreads[w];E.worker.terminate(),Me.freeThreadData(E),Me.runningWorkers.splice(Me.runningWorkers.indexOf(E.worker),1),E.worker.pthread=void 0}function CT(w){if(k)throw"Internal Error! cancelThread() can only ever be called from main application thread!";if(!w)throw"Internal Error! Null pthread_ptr in cancelThread!";var E=Me.pthreads[w];E.worker.postMessage({cmd:"cancel"})}function Wg(w){if(k)throw"Internal Error! cleanupThread() can only ever be called from main application thread!";if(!w)throw"Internal Error! Null pthread_ptr in cleanupThread!";var E=Me.pthreads[w];if(E){o()[w+12>>2]=0;var z=E.worker;Me.returnWorkerToPool(z)}}var Me={unusedWorkers:[],runningWorkers:[],initMainThreadBlock:function(){for(var w=8,E=0;E<w;++E)Me.allocateUnusedWorker()},initRuntime:function(){for(var w=Sl(228),E=0;E<228/4;++E)s()[w/4+E]=0;o()[w+12>>2]=w;var z=w+152;o()[z>>2]=z;for(var H=Sl(512),E=0;E<128;++E)s()[H/4+E]=0;Atomics.store(s(),w+100>>2,H),Atomics.store(s(),w+40>>2,w),Lk(w,!x,1),QN(w)},initWorker:function(){},pthreads:{},threadExitHandlers:[],setThreadStatus:function(){},runExitHandlers:function(){for(;Me.threadExitHandlers.length>0;)Me.threadExitHandlers.pop()();k&&Mu()&&YN()},runExitHandlersAndDeinitThread:function(w,E){Atomics.store(s(),w+56>>2,1),Atomics.store(s(),w+60>>2,0),Me.runExitHandlers(),Atomics.store(s(),w+4>>2,E),Atomics.store(s(),w+0>>2,1),td(w+0,2147483647),Lk(0,0,0)},threadExit:function(w){var E=Mu();E&&(Me.runExitHandlersAndDeinitThread(E,w),k&&postMessage({cmd:"exit"}))},threadCancel:function(){Me.runExitHandlersAndDeinitThread(Mu(),-1),postMessage({cmd:"cancelDone"})},terminateAllThreads:function(){for(var w in Me.pthreads){var E=Me.pthreads[w];E&&E.worker&&Me.returnWorkerToPool(E.worker)}Me.pthreads={};for(var z=0;z<Me.unusedWorkers.length;++z){var H=Me.unusedWorkers[z];H.terminate()}Me.unusedWorkers=[];for(var z=0;z<Me.runningWorkers.length;++z){var H=Me.runningWorkers[z],E=H.pthread;Me.freeThreadData(E),H.terminate()}Me.runningWorkers=[]},freeThreadData:function(w){if(!!w){if(w.threadInfoStruct){var E=o()[w.threadInfoStruct+100>>2];o()[w.threadInfoStruct+100>>2]=0,ud(E),ud(w.threadInfoStruct)}w.threadInfoStruct=0,w.allocatedOwnStack&&w.stackBase&&ud(w.stackBase),w.stackBase=0,w.worker&&(w.worker.pthread=null)}},returnWorkerToPool:function(w){Me.runWithoutMainThreadQueuedCalls(function(){delete Me.pthreads[w.pthread.threadInfoStruct],Me.unusedWorkers.push(w),Me.runningWorkers.splice(Me.runningWorkers.indexOf(w),1),Me.freeThreadData(w.pthread),w.pthread=void 0})},runWithoutMainThreadQueuedCalls:function(w){o()[oD>>2]=0;try{w()}finally{o()[oD>>2]=1}},receiveObjectTransfer:function(w){},loadWasmModuleToWorker:function(w,E){w.onmessage=function(z){var H=z.data,xe=H.cmd;if(w.pthread&&(Me.currentProxiedOperationCallerThread=w.pthread.threadInfoStruct),H.targetThread&&H.targetThread!=Mu()){var ge=Me.pthreads[H.targetThread];ge?ge.worker.postMessage(z.data,H.transferList):console.error('Internal error! Worker sent a message "'+xe+'" to target pthread '+H.targetThread+", but that thread no longer exists!"),Me.currentProxiedOperationCallerThread=void 0;return}if(xe==="processQueuedMainThreadWork")nb();else if(xe==="spawnThread")Yg(z.data);else if(xe==="cleanupThread")Wg(H.thread);else if(xe==="killThread")IT(H.thread);else if(xe==="cancelThread")CT(H.thread);else if(xe==="loaded")w.loaded=!0,E&&E(w),w.runPthread&&(w.runPthread(),delete w.runPthread);else if(xe==="print")j("Thread "+H.threadId+": "+H.text);else if(xe==="printErr")V("Thread "+H.threadId+": "+H.text);else if(xe==="alert")alert("Thread "+H.threadId+": "+H.text);else if(xe==="exit"){var be=w.pthread&&Atomics.load(s(),w.pthread.threadInfoStruct+64>>2);be&&Me.returnWorkerToPool(w)}else if(xe==="exitProcess")try{nH(H.returnCode)}catch(Pe){if(Pe instanceof pd)return;throw Pe}else xe==="cancelDone"?Me.returnWorkerToPool(w):xe==="objectTransfer"?Me.receiveObjectTransfer(z.data):z.data.target==="setimmediate"?w.postMessage(z.data):V("worker sent an unknown command "+xe);Me.currentProxiedOperationCallerThread=void 0},w.onerror=function(z){V("pthread sent an error! "+z.filename+":"+z.lineno+": "+z.message)},y&&(w.on("message",function(z){w.onmessage({data:z})}),w.on("error",function(z){w.onerror(z)}),w.on("exit",function(z){})),w.postMessage({cmd:"load",urlOrBlob:a.mainScriptUrlOrBlob||r,wasmMemory:se,wasmModule:ue})},allocateUnusedWorker:function(){var w=A("tfjs-backend-wasm-threaded-simd.worker.js");Me.unusedWorkers.push(new Worker(w))},getNewWorker:function(){return Me.unusedWorkers.length==0&&(Me.allocateUnusedWorker(),Me.loadWasmModuleToWorker(Me.unusedWorkers[0])),Me.unusedWorkers.length>0?Me.unusedWorkers.pop():null},busySpinWait:function(w){for(var E=performance.now()+w;performance.now()<E;);}};function vT(w,E){rD(w,E),Yp(w)}a.establishStackSpace=vT;function ST(){return ie}a.getNoExitRuntime=ST;function wT(w,E){return br.get(w)(E)}a.invokeEntryPoint=wT;function _T(w,E,z,H){wi("Assertion failed: "+Y(w)+", at: "+[E?Y(E):"unknown filename",z,H?Y(H):"unknown function"])}function AT(w,E){var z=_main(w,E)}var vl;y?vl=function(){var w=process.hrtime();return w[0]*1e3+w[1]/1e6}:k?vl=function(){return performance.now()-a.__performance_now_clock_drift}:typeof dateNow!="undefined"?vl=dateNow:vl=function(){return performance.now()};function NT(w){return o()[qN()>>2]=w,w}function DT(w,E){if(k)return Nu(1,1,w,E)}function PT(w,E){if(w==E)postMessage({cmd:"processQueuedMainThreadWork"});else if(k)postMessage({targetThread:w,cmd:"processThreadQueue"});else{var z=Me.pthreads[w],H=z&&z.worker;if(!H)return;H.postMessage({cmd:"processThreadQueue"})}return 1}function MT(){wi()}function FT(w,E,z){var H=BT(E,z);return Ug[w].apply(null,H)}function ET(w,E){}function Kg(w,E,z){if(w<=0||w>t().length||w&!0)return-28;if(g){if(Atomics.load(o(),w>>2)!=E)return-6;for(var xe=performance.now(),ge=xe+z,be=Atomics.exchange(o(),Zp>>2,w);;){if(xe=performance.now(),xe>ge)return be=Atomics.exchange(o(),Zp>>2,0),-73;if(be=Atomics.exchange(o(),Zp>>2,0),be==0)break;if(nb(),Atomics.load(o(),w>>2)!=E)return-6;be=Atomics.exchange(o(),Zp>>2,w)}return 0}else{var H=Atomics.wait(o(),w>>2,E,z);if(H==="timed-out")return-73;if(H==="not-equal")return-6;if(H==="ok")return 0;throw"Atomics.wait returned an unexpected value "+H}}function RT(w,E,z){n().copyWithin(w,E,E+z)}function LT(){return y?rj().cpus().length:navigator.hardwareConcurrency}function Nu(w,E){for(var z=arguments.length-2,H=ld(),xe=z,ge=Qp(xe*8),be=ge>>3,Pe=0;Pe<z;Pe++){var Dt=arguments[2+Pe];i()[be+Pe]=Dt}var Fr=tD(w,xe,ge,E);return Yp(H),Fr}var rd=[],nd=[];function BT(w,E){nd.length=0;var z;for(E>>=2;z=n()[w++];){var H=z<105;H&&E&1&&E++,nd.push(H?i()[E++>>1]:o()[E]),++E}return nd}function $T(w,E,z){rd.length=E;for(var H=z>>3,xe=0;xe<E;xe++)rd[xe]=i()[H+xe];var ge=w<0,be=ge?Ug[-w-1]:ck[w];return be.apply(null,rd)}function OT(){return n().length}function zT(w){try{return se.grow(w-at.byteLength+65535>>>16),Gr(se.buffer),1}catch{}}function GT(w){var E=OT();if(w<=E)return!1;var z=2147483648;if(w>z)return!1;for(var H=1;H<=4;H*=2){var xe=E*(1+.2/H);xe=Math.min(xe,w+100663296);var ge=Math.min(z,ft(Math.max(w,xe),65536)),be=zT(ge);if(be)return!0}return!1}var rt={inEventHandler:0,removeAllEventListeners:function(){for(var w=rt.eventHandlers.length-1;w>=0;--w)rt._removeHandler(w);rt.eventHandlers=[],rt.deferredCalls=[]},registerRemoveEventListeners:function(){rt.removeEventListenersRegistered||(Zm.push(rt.removeAllEventListeners),rt.removeEventListenersRegistered=!0)},deferredCalls:[],deferCall:function(w,E,z){function H(be,Pe){if(be.length!=Pe.length)return!1;for(var Dt in be)if(be[Dt]!=Pe[Dt])return!1;return!0}for(var xe in rt.deferredCalls){var ge=rt.deferredCalls[xe];if(ge.targetFunction==w&&H(ge.argsList,z))return}rt.deferredCalls.push({targetFunction:w,precedence:E,argsList:z}),rt.deferredCalls.sort(function(be,Pe){return be.precedence<Pe.precedence})},removeDeferredCalls:function(w){for(var E=0;E<rt.deferredCalls.length;++E)rt.deferredCalls[E].targetFunction==w&&(rt.deferredCalls.splice(E,1),--E)},canPerformEventHandlerRequests:function(){return rt.inEventHandler&&rt.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!!rt.canPerformEventHandlerRequests())for(var w=0;w<rt.deferredCalls.length;++w){var E=rt.deferredCalls[w];rt.deferredCalls.splice(w,1),--w,E.targetFunction.apply(null,E.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(w,E){for(var z=0;z<rt.eventHandlers.length;++z)rt.eventHandlers[z].target==w&&(!E||E==rt.eventHandlers[z].eventTypeString)&&rt._removeHandler(z--)},_removeHandler:function(w){var E=rt.eventHandlers[w];E.target.removeEventListener(E.eventTypeString,E.eventListenerFunc,E.useCapture),rt.eventHandlers.splice(w,1)},registerOrRemoveHandler:function(w){var E=function(xe){++rt.inEventHandler,rt.currentEventHandler=w,rt.runDeferredCalls(),w.handlerFunc(xe),rt.runDeferredCalls(),--rt.inEventHandler};if(w.callbackfunc)w.eventListenerFunc=E,w.target.addEventListener(w.eventTypeString,E,w.useCapture),rt.eventHandlers.push(w),rt.registerRemoveEventListeners();else for(var z=0;z<rt.eventHandlers.length;++z)rt.eventHandlers[z].target==w.target&&rt.eventHandlers[z].eventTypeString==w.eventTypeString&&rt._removeHandler(z--)},queueEventHandlerOnThread_iiii:function(w,E,z,H,xe){var ge=ld(),be=Qp(12);o()[be>>2]=z,o()[be+4>>2]=H,o()[be+8>>2]=xe,Rk(0,w,637534208,E,H,be),Yp(ge)},getTargetThreadForEventCallback:function(w){switch(w){case 1:return 0;case 2:return Me.currentProxiedOperationCallerThread;default:return w}},getNodeNameForTarget:function(w){return w?w==window?"#window":w==screen?"#screen":w&&w.nodeName?w.nodeName:"":""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};function UT(w){var E=Nt(w)+1,z=Sl(E);return It(w,z,E),z}function WT(w,E,z,H){var xe=ld(),ge=Qp(12),be=0;E&&(be=UT(E)),o()[ge>>2]=be,o()[ge+4>>2]=z,o()[ge+8>>2]=H,Rk(0,w,657457152,0,be,ge),Yp(xe)}function KT(w,E,z,H){E=E?Y(E):"",WT(w,E,z,H)}function VT(w){return w>2?Y(w):w}var jT=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function HT(w){w=VT(w);var E=jT[w]||(typeof document!="undefined"?document.querySelector(w):void 0);return E}function od(w){return HT(w)}function Vg(w,E,z){var H=od(w);if(!H)return-4;if(H.canvasSharedPtr&&(o()[H.canvasSharedPtr>>2]=E,o()[H.canvasSharedPtr+4>>2]=z),H.offscreenCanvas||!H.controlTransferredOffscreen){H.offscreenCanvas&&(H=H.offscreenCanvas);var xe=!1;if(H.GLctxObject&&H.GLctxObject.GLctx){var ge=H.GLctxObject.GLctx.getParameter(2978);xe=ge[0]===0&&ge[1]===0&&ge[2]===H.width&&ge[3]===H.height}H.width=E,H.height=z,xe&&H.GLctxObject.GLctx.viewport(0,0,E,z)}else if(H.canvasSharedPtr){var be=o()[H.canvasSharedPtr+8>>2];return KT(be,w,E,z),1}else return-4;return 0}function jg(w,E,z){return k?Nu(2,1,w,E,z):Vg(w,E,z)}function qT(w,E,z){var H=od(w);return H?Vg(w,E,z):jg(w,E,z)}function XT(w){}function YT(w,E){}function QT(w){var E=w.getExtension("ANGLE_instanced_arrays");if(E)return w.vertexAttribDivisor=function(z,H){E.vertexAttribDivisorANGLE(z,H)},w.drawArraysInstanced=function(z,H,xe,ge){E.drawArraysInstancedANGLE(z,H,xe,ge)},w.drawElementsInstanced=function(z,H,xe,ge,be){E.drawElementsInstancedANGLE(z,H,xe,ge,be)},1}function ZT(w){var E=w.getExtension("OES_vertex_array_object");if(E)return w.createVertexArray=function(){return E.createVertexArrayOES()},w.deleteVertexArray=function(z){E.deleteVertexArrayOES(z)},w.bindVertexArray=function(z){E.bindVertexArrayOES(z)},w.isVertexArray=function(z){return E.isVertexArrayOES(z)},1}function JT(w){var E=w.getExtension("WEBGL_draw_buffers");if(E)return w.drawBuffers=function(z,H){E.drawBuffersWEBGL(z,H)},1}function ek(w){return!!(w.multiDrawWebgl=w.getExtension("WEBGL_multi_draw"))}var Ct={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],uniforms:[],shaders:[],vaos:[],contexts:{},offscreenCanvases:{},timerQueriesEXT:[],programInfos:{},stringCache:{},unpackAlignment:4,recordError:function(E){Ct.lastError||(Ct.lastError=E)},getNewId:function(w){for(var E=Ct.counter++,z=w.length;z<E;z++)w[z]=null;return E},getSource:function(w,E,z,H){for(var xe="",ge=0;ge<E;++ge){var be=H?o()[H+ge*4>>2]:-1;xe+=Y(o()[z+ge*4>>2],be<0?void 0:be)}return xe},createContext:function(w,E){var z=w.getContext("webgl",E);if(!z)return 0;var H=Ct.registerContext(z,E);return H},registerContext:function(w,E){var z=Sl(8);o()[z+4>>2]=Mu();var H={handle:z,attributes:E,version:E.majorVersion,GLctx:w};return w.canvas&&(w.canvas.GLctxObject=H),Ct.contexts[z]=H,(typeof E.enableExtensionsByDefault=="undefined"||E.enableExtensionsByDefault)&&Ct.initExtensions(H),z},makeContextCurrent:function(w){return Ct.currentContext=Ct.contexts[w],a.ctx=Du=Ct.currentContext&&Ct.currentContext.GLctx,!(w&&!Du)},getContext:function(w){return Ct.contexts[w]},deleteContext:function(w){Ct.currentContext===Ct.contexts[w]&&(Ct.currentContext=null),typeof rt=="object"&&rt.removeAllHandlersOnTarget(Ct.contexts[w].GLctx.canvas),Ct.contexts[w]&&Ct.contexts[w].GLctx.canvas&&(Ct.contexts[w].GLctx.canvas.GLctxObject=void 0),ud(Ct.contexts[w].handle),Ct.contexts[w]=null},initExtensions:function(w){if(w||(w=Ct.currentContext),!w.initExtensionsDone){w.initExtensionsDone=!0;var E=w.GLctx;QT(E),ZT(E),JT(E),E.disjointTimerQueryExt=E.getExtension("EXT_disjoint_timer_query"),ek(E);var z=E.getSupportedExtensions()||[];z.forEach(function(H){H.indexOf("lose_context")<0&&H.indexOf("debug")<0&&E.getExtension(H)})}},populateUniformTable:function(w){for(var E=Ct.programs[w],z=Ct.programInfos[w]={uniforms:{},maxUniformLength:0,maxAttributeLength:-1,maxUniformBlockNameLength:-1},H=z.uniforms,xe=Du.getProgramParameter(E,35718),ge=0;ge<xe;++ge){var be=Du.getActiveUniform(E,ge),Pe=be.name;z.maxUniformLength=Math.max(z.maxUniformLength,Pe.length+1),Pe.slice(-1)=="]"&&(Pe=Pe.slice(0,Pe.lastIndexOf("[")));var Dt=Du.getUniformLocation(E,Pe);if(Dt){var Fr=Ct.getNewId(Ct.uniforms);H[Pe]=[be.size,Fr],Ct.uniforms[Fr]=Dt;for(var wr=1;wr<be.size;++wr){var Fu=Pe+"["+wr+"]";Dt=Du.getUniformLocation(E,Fu),Fr=Ct.getNewId(Ct.uniforms),Ct.uniforms[Fr]=Dt}}}}},tk=["default","low-power","high-performance"];function rk(w,E){var z=E>>2,H=o()[z+(24>>2)],xe={alpha:!!o()[z+(0>>2)],depth:!!o()[z+(4>>2)],stencil:!!o()[z+(8>>2)],antialias:!!o()[z+(12>>2)],premultipliedAlpha:!!o()[z+(16>>2)],preserveDrawingBuffer:!!o()[z+(20>>2)],powerPreference:tk[H],failIfMajorPerformanceCaveat:!!o()[z+(28>>2)],majorVersion:o()[z+(32>>2)],minorVersion:o()[z+(36>>2)],enableExtensionsByDefault:o()[z+(40>>2)],explicitSwapControl:o()[z+(44>>2)],proxyContextToMainThread:o()[z+(48>>2)],renderViaOffscreenBackBuffer:o()[z+(52>>2)]},ge=od(w);if(!ge||xe.explicitSwapControl)return 0;var be=Ct.createContext(ge,xe);return be}function nk(w,E){return rk(w,E)}var jp={mappings:{},buffers:[null,[],[]],printChar:function(w,E){var z=jp.buffers[w];E===0||E===10?((w===1?j:V)(Ue(z,0)),z.length=0):z.push(E)},varargs:void 0,get:function(){jp.varargs+=4;var w=o()[jp.varargs-4>>2];return w},getStr:function(w){var E=Y(w);return E},get64:function(w,E){return w}};function Hg(w){return k?Nu(3,1,w):0}function qg(w,E,z,H,xe){if(k)return Nu(4,1,w,E,z,H,xe)}function Xg(w,E,z,H){if(k)return Nu(5,1,w,E,z,H);for(var xe=0,ge=0;ge<z;ge++){for(var be=o()[E+ge*8>>2],Pe=o()[E+(ge*8+4)>>2],Dt=0;Dt<Pe;Dt++)jp.printChar(w,n()[be+Dt]);xe+=Pe}return o()[H>>2]=xe,0}function ok(w){var E=Me.threadExitHandlers.pop();w&&E()}function sk(w,E){Me.threadExitHandlers.push(function(){br.get(w)(E)})}function Yg(w){if(k)throw"Internal Error! spawnThread() can only ever be called from main application thread!";var E=Me.getNewWorker();if(E.pthread!==void 0)throw"Internal error!";if(!w.pthread_ptr)throw"Internal error, no pthread ptr!";Me.runningWorkers.push(E);for(var z=Sl(128*4),H=0;H<128;++H)o()[z+H*4>>2]=0;var xe=w.stackBase+w.stackSize,ge=Me.pthreads[w.pthread_ptr]={worker:E,stackBase:w.stackBase,stackSize:w.stackSize,allocatedOwnStack:w.allocatedOwnStack,threadInfoStruct:w.pthread_ptr},be=ge.threadInfoStruct>>2;Atomics.store(s(),be+(64>>2),w.detached),Atomics.store(s(),be+(100>>2),z),Atomics.store(s(),be+(40>>2),ge.threadInfoStruct),Atomics.store(s(),be+(80>>2),w.stackSize),Atomics.store(s(),be+(76>>2),xe),Atomics.store(s(),be+(104>>2),w.stackSize),Atomics.store(s(),be+(104+8>>2),xe),Atomics.store(s(),be+(104+12>>2),w.detached);var Pe=XN(),Dt=Pe+40;Atomics.store(s(),be+(172>>2),Dt),E.pthread=ge;var Fr={cmd:"run",start_routine:w.startRoutine,arg:w.arg,threadInfoStruct:w.pthread_ptr,stackBase:w.stackBase,stackSize:w.stackSize};E.runPthread=function(){Fr.time=performance.now(),E.postMessage(Fr,w.transferList)},E.loaded&&(E.runPthread(),delete E.runPthread)}function ak(w,E,z,H){if(typeof SharedArrayBuffer=="undefined")return V("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;if(!w)return V("pthread_create called with a null thread pointer!"),28;var xe=[],ge=0;if(k&&(xe.length===0||ge))return eD(687865856,w,E,z,H);if(ge)return ge;var be=0,Pe=0,Dt=0;E&&E!=-1?(be=o()[E>>2],be+=81920,Pe=o()[E+8>>2],Dt=o()[E+12>>2]!==0):be=2097152;var Fr=Pe==0;Fr?Pe=nD(16,be):(Pe-=be,Te(Pe>0));for(var wr=Sl(228),Fu=0;Fu<228>>2;++Fu)s()[(wr>>2)+Fu]=0;o()[w>>2]=wr,o()[wr+12>>2]=wr;var Jp=wr+152;o()[Jp>>2]=Jp;var an={stackBase:Pe,stackSize:be,allocatedOwnStack:Fr,detached:Dt,startRoutine:z,pthread_ptr:wr,arg:H,transferList:xe};return k?(an.cmd="spawnThread",postMessage(an,xe)):Yg(an),0}function ik(){if(!!k){var w=Mu();if(!!w){var E=Atomics.load(s(),w+56>>2);if(!E){var z=Atomics.load(s(),w+0>>2);if(z==2)throw"Canceled!"}}}}function uk(){y||x||q("Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread")}function lk(w,E,z){if(!w)return V("pthread_join attempted on a null thread pointer!"),Au.ESRCH;if(k&&Mu()==w)return V("PThread "+w+" is attempting to join to itself!"),Au.EDEADLK;if(!k&&ZN()==w)return V("Main thread "+w+" is attempting to join to itself!"),Au.EDEADLK;var H=o()[w+12>>2];if(H!==w)return V("pthread_join attempted on thread "+w+", which does not point to a valid thread, or does not exist anymore!"),Au.ESRCH;var xe=Atomics.load(s(),w+64>>2);if(xe)return V("Attempted to join thread "+w+", which was already detached!"),Au.EINVAL;for(z&&uk();;){var ge=Atomics.load(s(),w+0>>2);if(ge==1){var be=Atomics.load(s(),w+4>>2);return E&&(o()[E>>2]=be),Atomics.store(s(),w+64>>2,1),k?postMessage({cmd:"cleanupThread",thread:w}):Wg(w),0}if(!z)return Au.EBUSY;ik(),k||nb(),Kg(w+0,ge,k?100:1)}}function pk(w,E){return lk(w,E,!0)}function Qg(w){if(k)return Nu(6,1,w);switch(w){case 30:return 16384;case 85:var E=2147483648;return E/16384;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:case 80:case 81:case 79:return-1;case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1e3;case 89:return 700;case 71:return 256;case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return typeof navigator=="object"&&navigator.hardwareConcurrency||1}return NT(28),-1}k||Me.initMainThreadBlock();var Du,ck=[null,DT,jg,Hg,qg,Xg,Qg],mk={e:_T,r:AT,x:PT,b:MT,y:FT,j:ET,d:Kg,c:td,f:vl,p:RT,A:LT,u:$T,q:GT,v:qT,i:XT,s:YT,w:nk,l:Hg,n:qg,g:Xg,o:kT,a:se||a.wasmMemory,z:ok,k:sk,h:ak,m:pk,t:Qg},HN=TT(),Zg=a.___wasm_call_ctors=function(){return(Zg=a.___wasm_call_ctors=a.asm.B).apply(null,arguments)},dk=a._init=function(){return(dk=a._init=a.asm.C).apply(null,arguments)},fk=a._init_with_threads_count=function(){return(fk=a._init_with_threads_count=a.asm.D).apply(null,arguments)},hk=a._get_threads_count=function(){return(hk=a._get_threads_count=a.asm.E).apply(null,arguments)},gk=a._register_tensor=function(){return(gk=a._register_tensor=a.asm.F).apply(null,arguments)},bk=a._dispose_data=function(){return(bk=a._dispose_data=a.asm.G).apply(null,arguments)},yk=a._dispose=function(){return(yk=a._dispose=a.asm.H).apply(null,arguments)},xk=a._Abs=function(){return(xk=a._Abs=a.asm.I).apply(null,arguments)},Tk=a._Add=function(){return(Tk=a._Add=a.asm.J).apply(null,arguments)},kk=a._AddN=function(){return(kk=a._AddN=a.asm.K).apply(null,arguments)},Ik=a._All=function(){return(Ik=a._All=a.asm.L).apply(null,arguments)},Ck=a._Any=function(){return(Ck=a._Any=a.asm.M).apply(null,arguments)},vk=a._ArgMax=function(){return(vk=a._ArgMax=a.asm.N).apply(null,arguments)},Sk=a._AvgPool=function(){return(Sk=a._AvgPool=a.asm.O).apply(null,arguments)},wk=a._BatchMatMul=function(){return(wk=a._BatchMatMul=a.asm.P).apply(null,arguments)},_k=a._Ceil=function(){return(_k=a._Ceil=a.asm.Q).apply(null,arguments)},Ak=a._ClipByValue=function(){return(Ak=a._ClipByValue=a.asm.R).apply(null,arguments)},Nk=a._Conv2D=function(){return(Nk=a._Conv2D=a.asm.S).apply(null,arguments)},Dk=a._Conv2DBackpropInput=function(){return(Dk=a._Conv2DBackpropInput=a.asm.T).apply(null,arguments)},Pk=a._Cos=function(){return(Pk=a._Cos=a.asm.U).apply(null,arguments)},Mk=a._Cosh=function(){return(Mk=a._Cosh=a.asm.V).apply(null,arguments)},Jg=a._CropAndResize=function(){return(Jg=a._CropAndResize=a.asm.W).apply(null,arguments)},eb=a._Cumsum=function(){return(eb=a._Cumsum=a.asm.X).apply(null,arguments)},sd=a._DepthToSpace=function(){return(sd=a._DepthToSpace=a.asm.Y).apply(null,arguments)},Hp=a._DepthwiseConv2dNative=function(){return(Hp=a._DepthwiseConv2dNative=a.asm.Z).apply(null,arguments)},Fk=a._Elu=function(){return(Fk=a._Elu=a.asm._).apply(null,arguments)},ad=a._Equal=function(){return(ad=a._Equal=a.asm.$).apply(null,arguments)},qp=a._Exp=function(){return(qp=a._Exp=a.asm.aa).apply(null,arguments)},Xp=a._FlipLeftRight=function(){return(Xp=a._FlipLeftRight=a.asm.ba).apply(null,arguments)},Ek=a._Floor=function(){return(Ek=a._Floor=a.asm.ca).apply(null,arguments)},Q=a._FloorDiv=function(){return(Q=a._FloorDiv=a.asm.da).apply(null,arguments)},ae=a._FusedBatchNorm=function(){return(ae=a._FusedBatchNorm=a.asm.ea).apply(null,arguments)},Ae=a._FusedConv2D=function(){return(Ae=a._FusedConv2D=a.asm.fa).apply(null,arguments)},bt=a._FusedDepthwiseConv2D=function(){return(bt=a._FusedDepthwiseConv2D=a.asm.ga).apply(null,arguments)},cr=a._Gather=function(){return(cr=a._Gather=a.asm.ha).apply(null,arguments)},rr=a._GatherNd=function(){return(rr=a._GatherNd=a.asm.ia).apply(null,arguments)},ut=a._Greater=function(){return(ut=a._Greater=a.asm.ja).apply(null,arguments)},pt=a._GreaterEqual=function(){return(pt=a._GreaterEqual=a.asm.ka).apply(null,arguments)},Ur=a._LeakyRelu=function(){return(Ur=a._LeakyRelu=a.asm.la).apply(null,arguments)},_i=a._Less=function(){return(_i=a._Less=a.asm.ma).apply(null,arguments)},Ai=a._LessEqual=function(){return(Ai=a._LessEqual=a.asm.na).apply(null,arguments)},tb=a._Log=function(){return(tb=a._Log=a.asm.oa).apply(null,arguments)},id=a._LogicalAnd=function(){return(id=a._LogicalAnd=a.asm.pa).apply(null,arguments)},Un=a._Max=function(){return(Un=a._Max=a.asm.qa).apply(null,arguments)},Pu=a._MaxPool=function(){return(Pu=a._MaxPool=a.asm.ra).apply(null,arguments)},rb=a._Maximum=function(){return(rb=a._Maximum=a.asm.sa).apply(null,arguments)},pj=a._Mean=function(){return(pj=a._Mean=a.asm.ta).apply(null,arguments)},cj=a._Min=function(){return(cj=a._Min=a.asm.ua).apply(null,arguments)},mj=a._Minimum=function(){return(mj=a._Minimum=a.asm.va).apply(null,arguments)},dj=a._MirrorPad=function(){return(dj=a._MirrorPad=a.asm.wa).apply(null,arguments)},fj=a._Multiply=function(){return(fj=a._Multiply=a.asm.xa).apply(null,arguments)},hj=a._Neg=function(){return(hj=a._Neg=a.asm.ya).apply(null,arguments)},gj=a._NonMaxSuppressionV3=function(){return(gj=a._NonMaxSuppressionV3=a.asm.za).apply(null,arguments)},bj=a._NonMaxSuppressionV4=function(){return(bj=a._NonMaxSuppressionV4=a.asm.Aa).apply(null,arguments)},yj=a._NonMaxSuppressionV5=function(){return(yj=a._NonMaxSuppressionV5=a.asm.Ba).apply(null,arguments)},xj=a._NotEqual=function(){return(xj=a._NotEqual=a.asm.Ca).apply(null,arguments)},Tj=a._OneHot=function(){return(Tj=a._OneHot=a.asm.Da).apply(null,arguments)},kj=a._PadV2=function(){return(kj=a._PadV2=a.asm.Ea).apply(null,arguments)},Ij=a._Pow=function(){return(Ij=a._Pow=a.asm.Fa).apply(null,arguments)},Cj=a._Prelu=function(){return(Cj=a._Prelu=a.asm.Ga).apply(null,arguments)},vj=a._Prod=function(){return(vj=a._Prod=a.asm.Ha).apply(null,arguments)},Sj=a._RealDiv=function(){return(Sj=a._RealDiv=a.asm.Ia).apply(null,arguments)},wj=a._Relu=function(){return(wj=a._Relu=a.asm.Ja).apply(null,arguments)},_j=a._Relu6=function(){return(_j=a._Relu6=a.asm.Ka).apply(null,arguments)},Aj=a._ResizeBilinear=function(){return(Aj=a._ResizeBilinear=a.asm.La).apply(null,arguments)},Nj=a._Reverse=function(){return(Nj=a._Reverse=a.asm.Ma).apply(null,arguments)},Dj=a._RotateWithOffset=function(){return(Dj=a._RotateWithOffset=a.asm.Na).apply(null,arguments)},Pj=a._Round=function(){return(Pj=a._Round=a.asm.Oa).apply(null,arguments)},Mj=a._Rsqrt=function(){return(Mj=a._Rsqrt=a.asm.Pa).apply(null,arguments)},Fj=a._ScatterNd=function(){return(Fj=a._ScatterNd=a.asm.Qa).apply(null,arguments)},Ej=a._SelectV2=function(){return(Ej=a._SelectV2=a.asm.Ra).apply(null,arguments)},Rj=a._Sigmoid=function(){return(Rj=a._Sigmoid=a.asm.Sa).apply(null,arguments)},Lj=a._Sin=function(){return(Lj=a._Sin=a.asm.Ta).apply(null,arguments)},Bj=a._Softmax=function(){return(Bj=a._Softmax=a.asm.Ua).apply(null,arguments)},$j=a._SparseFillEmptyRows=function(){return($j=a._SparseFillEmptyRows=a.asm.Va).apply(null,arguments)},Oj=a._SparseReshape=function(){return(Oj=a._SparseReshape=a.asm.Wa).apply(null,arguments)},zj=a._SparseSegmentReduction=function(){return(zj=a._SparseSegmentReduction=a.asm.Xa).apply(null,arguments)},Gj=a._Sqrt=function(){return(Gj=a._Sqrt=a.asm.Ya).apply(null,arguments)},Uj=a._Square=function(){return(Uj=a._Square=a.asm.Za).apply(null,arguments)},Wj=a._SquaredDifference=function(){return(Wj=a._SquaredDifference=a.asm._a).apply(null,arguments)},Kj=a._Step=function(){return(Kj=a._Step=a.asm.$a).apply(null,arguments)},Vj=a._StridedSlice=function(){return(Vj=a._StridedSlice=a.asm.ab).apply(null,arguments)},jj=a._Sub=function(){return(jj=a._Sub=a.asm.bb).apply(null,arguments)},Hj=a._Sum=function(){return(Hj=a._Sum=a.asm.cb).apply(null,arguments)},qj=a._Tan=function(){return(qj=a._Tan=a.asm.db).apply(null,arguments)},Xj=a._Tanh=function(){return(Xj=a._Tanh=a.asm.eb).apply(null,arguments)},Yj=a._Tile=function(){return(Yj=a._Tile=a.asm.fb).apply(null,arguments)},Qj=a._TopK=function(){return(Qj=a._TopK=a.asm.gb).apply(null,arguments)},Zj=a._Transform=function(){return(Zj=a._Transform=a.asm.hb).apply(null,arguments)},Jj=a._Transpose=function(){return(Jj=a._Transpose=a.asm.ib).apply(null,arguments)},eH=a.__FusedMatMul=function(){return(eH=a.__FusedMatMul=a.asm.jb).apply(null,arguments)},Sl=a._malloc=function(){return(Sl=a._malloc=a.asm.kb).apply(null,arguments)},ud=a._free=function(){return(ud=a._free=a.asm.lb).apply(null,arguments)},qN=a.___errno_location=function(){return(qN=a.___errno_location=a.asm.mb).apply(null,arguments)},XN=a._emscripten_get_global_libc=function(){return(XN=a._emscripten_get_global_libc=a.asm.ob).apply(null,arguments)},Mu=a._pthread_self=function(){return(Mu=a._pthread_self=a.asm.pb).apply(null,arguments)},YN=a.___pthread_tsd_run_dtors=function(){return(YN=a.___pthread_tsd_run_dtors=a.asm.qb).apply(null,arguments)},nb=a._emscripten_main_thread_process_queued_calls=function(){return(nb=a._emscripten_main_thread_process_queued_calls=a.asm.rb).apply(null,arguments)},tH=a._emscripten_current_thread_process_queued_calls=function(){return(tH=a._emscripten_current_thread_process_queued_calls=a.asm.sb).apply(null,arguments)},QN=a._emscripten_register_main_browser_thread_id=function(){return(QN=a._emscripten_register_main_browser_thread_id=a.asm.tb).apply(null,arguments)},ZN=a._emscripten_main_browser_thread_id=function(){return(ZN=a._emscripten_main_browser_thread_id=a.asm.ub).apply(null,arguments)},JN=a.__emscripten_do_dispatch_to_thread=function(){return(JN=a.__emscripten_do_dispatch_to_thread=a.asm.vb).apply(null,arguments)},eD=a._emscripten_sync_run_in_main_thread_4=function(){return(eD=a._emscripten_sync_run_in_main_thread_4=a.asm.wb).apply(null,arguments)},tD=a._emscripten_run_in_main_runtime_thread_js=function(){return(tD=a._emscripten_run_in_main_runtime_thread_js=a.asm.xb).apply(null,arguments)},Rk=a.__emscripten_call_on_thread=function(){return(Rk=a.__emscripten_call_on_thread=a.asm.yb).apply(null,arguments)},rH=a._emscripten_tls_init=function(){return(rH=a._emscripten_tls_init=a.asm.zb).apply(null,arguments)},Lk=a.__emscripten_thread_init=function(){return(Lk=a.__emscripten_thread_init=a.asm.Ab).apply(null,arguments)},ld=a.stackSave=function(){return(ld=a.stackSave=a.asm.Bb).apply(null,arguments)},Yp=a.stackRestore=function(){return(Yp=a.stackRestore=a.asm.Cb).apply(null,arguments)},Qp=a.stackAlloc=function(){return(Qp=a.stackAlloc=a.asm.Db).apply(null,arguments)},rD=a._emscripten_stack_set_limits=function(){return(rD=a._emscripten_stack_set_limits=a.asm.Eb).apply(null,arguments)},nD=a._memalign=function(){return(nD=a._memalign=a.asm.Fb).apply(null,arguments)},oD=a.__emscripten_allow_main_runtime_queued_calls=10208,Zp=a.__emscripten_main_thread_futex=10412;a.cwrap=Le,a.PThread=Me,a.PThread=Me,a.wasmMemory=se,a.ExitStatus=pd;var ob;function pd(w){this.name="ExitStatus",this.message="Program terminated with exit("+w+")",this.status=w}Il=function w(){ob||Bk(),ob||(Il=w)};function Bk(w){if(w=w||d,ls>0)return;if(k){u(a),Lg(),postMessage({cmd:"loaded"});return}if(Rg(),ls>0)return;function E(){ob||(ob=!0,a.calledRun=!0,!ye&&(Lg(),Bg(),u(a),a.onRuntimeInitialized&&a.onRuntimeInitialized(),$g()))}a.setStatus?(a.setStatus("Running..."),setTimeout(function(){setTimeout(function(){a.setStatus("")},1),E()},1)):E()}a.run=Bk;function nH(w,E){if(!(E&&ie&&w===0)){if(!E&&k)throw postMessage({cmd:"exitProcess",returnCode:w}),new pd(w);ie||(Me.terminateAllThreads(),fe=w,Sn(),a.onExit&&a.onExit(w),ye=!0),h(w,new pd(w))}}if(a.preInit)for(typeof a.preInit=="function"&&(a.preInit=[a.preInit]);a.preInit.length>0;)a.preInit.pop()();k&&(ie=!1,Me.initWorker()),Bk();var sb;p&&(sb={uncaughtException:process.listeners("uncaughtException").filter(function(w){return!p.uncaughtException.indexOf(w)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(w){return!p.unhandledRejection.indexOf(w)>-1})});var ab;if(typeof WasmBackendModule!="undefined")ab=WasmBackendModule;else if(typeof e!="undefined")ab=e;else throw new Error("Could not find wasm module in post.js");if(sb){var oH=ab._dispose;ab._dispose=function(){oH(),sb.uncaughtException.forEach(function(w){process.removeListener("uncaughtException",w)}),sb.unhandledRejection.forEach(function(w){process.removeListener("unhandledRejection",w)})}}return e.ready}}();typeof lT=="object"&&typeof GN=="object"?GN.exports=zN:typeof define=="function"&&define.amd?define([],function(){return zN}):typeof lT=="object"&&(lT.WasmBackendModuleThreadedSimd=zN)});var sj=_r((pT,WN)=>{var UN=function(){var r=typeof document!="undefined"&&document.currentScript?document.currentScript.src:void 0;return typeof __filename!="undefined"&&(r=r||__filename),function(e){e=e||{};var t=typeof e!="undefined"?e:{},n,o;t.ready=new Promise(function(Q,ae){n=Q,o=ae});var s;typeof process!="undefined"&&process.listeners&&(s={uncaughtException:process.listeners("uncaughtException"),unhandledRejection:process.listeners("unhandledRejection")});var i={},a;for(a in t)t.hasOwnProperty(a)&&(i[a]=t[a]);var u=[],l="./this.program",p=function(Q,ae){throw ae},c=!1,m=!1,d=!1,f=!1;c=typeof window=="object",m=typeof importScripts=="function",d=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",f=!c&&!d&&!m;var h="";function g(Q){return t.locateFile?t.locateFile(Q,h):h+Q}var x,y,T,k,C,A;d?(m?h=Qm().dirname(h)+"/":h=__dirname+"/",x=function(ae,Ae){return C||(C=Oh()),A||(A=Qm()),ae=A.normalize(ae),C.readFileSync(ae,Ae?null:"utf8")},T=function(ae){var Ae=x(ae,!0);return Ae.buffer||(Ae=new Uint8Array(Ae)),j(Ae.buffer),Ae},process.argv.length>1&&(l=process.argv[1].replace(/\\/g,"/")),u=process.argv.slice(2),process.on("uncaughtException",function(Q){if(!(Q instanceof Fk))throw Q}),process.on("unhandledRejection",Gn),p=function(Q){process.exit(Q)},t.inspect=function(){return"[Emscripten Module object]"}):f?(typeof read!="undefined"&&(x=function(ae){return read(ae)}),T=function(ae){var Ae;return typeof readbuffer=="function"?new Uint8Array(readbuffer(ae)):(Ae=read(ae,"binary"),j(typeof Ae=="object"),Ae)},typeof scriptArgs!="undefined"?u=scriptArgs:typeof arguments!="undefined"&&(u=arguments),typeof quit=="function"&&(p=function(Q){quit(Q)}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)):(c||m)&&(m?h=self.location.href:typeof document!="undefined"&&document.currentScript&&(h=document.currentScript.src),r&&(h=r),h.indexOf("blob:")!==0?h=h.substr(0,h.lastIndexOf("/")+1):h="",x=function(Q){var ae=new XMLHttpRequest;return ae.open("GET",Q,!1),ae.send(null),ae.responseText},m&&(T=function(Q){var ae=new XMLHttpRequest;return ae.open("GET",Q,!1),ae.responseType="arraybuffer",ae.send(null),new Uint8Array(ae.response)}),y=function(Q,ae,Ae){var bt=new XMLHttpRequest;bt.open("GET",Q,!0),bt.responseType="arraybuffer",bt.onload=function(){if(bt.status==200||bt.status==0&&bt.response){ae(bt.response);return}Ae()},bt.onerror=Ae,bt.send(null)},k=function(Q){document.title=Q});var M=t.print||console.log.bind(console),P=t.printErr||console.warn.bind(console);for(a in i)i.hasOwnProperty(a)&&(t[a]=i[a]);i=null,t.arguments&&(u=t.arguments),t.thisProgram&&(l=t.thisProgram),t.quit&&(p=t.quit);var F;t.wasmBinary&&(F=t.wasmBinary);var B=t.noExitRuntime||!0;typeof WebAssembly!="object"&&Gn("no native wasm support detected");var U,W=!1,K;function j(Q,ae){Q||Gn("Assertion failed: "+ae)}function V(Q){var ae=t["_"+Q];return j(ae,"Cannot call unknown function "+Q+", make sure it is exported"),ae}function q(Q,ae,Ae,bt,cr){var rr={string:function(Un){var Pu=0;if(Un!=null&&Un!==0){var rb=(Un.length<<2)+1;Pu=sd(rb),se(Un,Pu,rb)}return Pu},array:function(Un){var Pu=sd(Un.length);return ue(Un,Pu),Pu}};function ut(Un){return ae==="string"?oe(Un):ae==="boolean"?Boolean(Un):Un}var pt=V(Q),Ur=[],_i=0;if(bt)for(var Ai=0;Ai<bt.length;Ai++){var tb=rr[Ae[Ai]];tb?(_i===0&&(_i=Jg()),Ur[Ai]=tb(bt[Ai])):Ur[Ai]=bt[Ai]}var id=pt.apply(null,Ur);return id=ut(id),_i!==0&&eb(_i),id}function ee(Q,ae,Ae,bt){Ae=Ae||[];var cr=Ae.every(function(ut){return ut==="number"}),rr=ae!=="string";return rr&&cr&&!bt?V(Q):function(){return q(Q,ae,Ae,arguments,bt)}}var Z=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0;function te(Q,ae,Ae){for(var bt=ae+Ae,cr=ae;Q[cr]&&!(cr>=bt);)++cr;if(cr-ae>16&&Q.subarray&&Z)return Z.decode(Q.subarray(ae,cr));for(var rr="";ae<cr;){var ut=Q[ae++];if(!(ut&128)){rr+=String.fromCharCode(ut);continue}var pt=Q[ae++]&63;if((ut&224)==192){rr+=String.fromCharCode((ut&31)<<6|pt);continue}var Ur=Q[ae++]&63;if((ut&240)==224?ut=(ut&15)<<12|pt<<6|Ur:ut=(ut&7)<<18|pt<<12|Ur<<6|Q[ae++]&63,ut<65536)rr+=String.fromCharCode(ut);else{var _i=ut-65536;rr+=String.fromCharCode(55296|_i>>10,56320|_i&1023)}}return rr}function oe(Q,ae){return Q?te(we,Q,ae):""}function ie(Q,ae,Ae,bt){if(!(bt>0))return 0;for(var cr=Ae,rr=Ae+bt-1,ut=0;ut<Q.length;++ut){var pt=Q.charCodeAt(ut);if(pt>=55296&&pt<=57343){var Ur=Q.charCodeAt(++ut);pt=65536+((pt&1023)<<10)|Ur&1023}if(pt<=127){if(Ae>=rr)break;ae[Ae++]=pt}else if(pt<=2047){if(Ae+1>=rr)break;ae[Ae++]=192|pt>>6,ae[Ae++]=128|pt&63}else if(pt<=65535){if(Ae+2>=rr)break;ae[Ae++]=224|pt>>12,ae[Ae++]=128|pt>>6&63,ae[Ae++]=128|pt&63}else{if(Ae+3>=rr)break;ae[Ae++]=240|pt>>18,ae[Ae++]=128|pt>>12&63,ae[Ae++]=128|pt>>6&63,ae[Ae++]=128|pt&63}}return ae[Ae]=0,Ae-cr}function se(Q,ae,Ae){return ie(Q,we,ae,Ae)}function ue(Q,ae){Te.set(Q,ae)}function ye(Q,ae){return Q%ae>0&&(Q+=ae-Q%ae),Q}var fe,Te,we,Re,Le,Ue,Y,gt,It;function Nt(Q){fe=Q,t.HEAP8=Te=new Int8Array(Q),t.HEAP16=Re=new Int16Array(Q),t.HEAP32=Ue=new Int32Array(Q),t.HEAPU8=we=new Uint8Array(Q),t.HEAPU16=Le=new Uint16Array(Q),t.HEAPU32=Y=new Uint32Array(Q),t.HEAPF32=gt=new Float32Array(Q),t.HEAPF64=It=new Float64Array(Q)}var Gt=t.INITIAL_MEMORY||16777216,ft,at=[],Ut=[],On=[],pr=[],ss=!1;Ut.push({func:function(){Gg()}});function zr(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)Gr(t.preRun.shift());ls(at)}function as(){ss=!0,ls(Ut)}function vn(){ls(On)}function zn(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)ro(t.postRun.shift());ls(pr)}function Gr(Q){at.unshift(Q)}function ro(Q){pr.unshift(Q)}var br=0,is=null,us=null;function kl(Q){br++,t.monitorRunDependencies&&t.monitorRunDependencies(br)}function Zm(Q){if(br--,t.monitorRunDependencies&&t.monitorRunDependencies(br),br==0&&(is!==null&&(clearInterval(is),is=null),us)){var ae=us;us=null,ae()}}t.preloadedImages={},t.preloadedAudios={};function Gn(Q){t.onAbort&&t.onAbort(Q),Q+="",P(Q),W=!0,K=1,Q="abort("+Q+"). Build with -s ASSERTIONS=1 for more info.";var ae=new WebAssembly.RuntimeError(Q);throw o(ae),ae}function Kp(Q,ae){return String.prototype.startsWith?Q.startsWith(ae):Q.indexOf(ae)===0}var Jm="data:application/octet-stream;base64,";function Rg(Q){return Kp(Q,Jm)}var Lg="file://";function Bg(Q){return Kp(Q,Lg)}var Sn="tfjs-backend-wasm.wasm";Rg(Sn)||(Sn=g(Sn));function $g(Q){try{if(Q==Sn&&F)return new Uint8Array(F);if(T)return T(Q);throw"both async and sync fetching of the wasm failed"}catch(ae){Gn(ae)}}function dT(){if(!F&&(c||m)){if(typeof fetch=="function"&&!Bg(Sn))return fetch(Sn,{credentials:"same-origin"}).then(function(Q){if(!Q.ok)throw"failed to load wasm binary file at '"+Sn+"'";return Q.arrayBuffer()}).catch(function(){return $g(Sn)});if(y)return new Promise(function(Q,ae){y(Sn,function(Ae){Q(new Uint8Array(Ae))},ae)})}return Promise.resolve().then(function(){return $g(Sn)})}function fT(){var Q={a:wn};function ae(ut,pt){var Ur=ut.exports;t.asm=Ur,U=t.asm.h,Nt(U.buffer),ft=t.asm.Va,Zm("wasm-instantiate")}kl("wasm-instantiate");function Ae(ut){ae(ut.instance)}function bt(ut){return dT().then(function(pt){return WebAssembly.instantiate(pt,Q)}).then(ut,function(pt){P("failed to asynchronously prepare wasm: "+pt),Gn(pt)})}function cr(){return!F&&typeof WebAssembly.instantiateStreaming=="function"&&!Rg(Sn)&&!Bg(Sn)&&typeof fetch=="function"?fetch(Sn,{credentials:"same-origin"}).then(function(ut){var pt=WebAssembly.instantiateStreaming(ut,Q);return pt.then(Ae,function(Ur){return P("wasm streaming compile failed: "+Ur),P("falling back to ArrayBuffer instantiation"),bt(Ae)})}):bt(Ae)}if(t.instantiateWasm)try{var rr=t.instantiateWasm(Q,ae);return rr}catch(ut){return P("Module.instantiateWasm callback failed with error: "+ut),!1}return cr().catch(o),{}}function ls(Q){for(;Q.length>0;){var ae=Q.shift();if(typeof ae=="function"){ae(t);continue}var Ae=ae.func;typeof Ae=="number"?ae.arg===void 0?ft.get(Ae)():ft.get(Ae)(ae.arg):Ae(ae.arg===void 0?null:ae.arg)}}function ed(){Gn()}function Il(Q,ae,Ae){we.copyWithin(Q,ae,ae+Ae)}function hT(){return we.length}function gT(Q){try{return U.grow(Q-fe.byteLength+65535>>>16),Nt(U.buffer),1}catch{}}function wi(Q){var ae=hT(),Ae=2147483648;if(Q>Ae)return!1;for(var bt=1;bt<=4;bt*=2){var cr=ae*(1+.2/bt);cr=Math.min(cr,Q+100663296);var rr=Math.min(Ae,ye(Math.max(Q,cr),65536)),ut=gT(rr);if(ut)return!0}return!1}var Cl={mappings:{},buffers:[null,[],[]],printChar:function(Q,ae){var Ae=Cl.buffers[Q];ae===0||ae===10?((Q===1?M:P)(te(Ae,0)),Ae.length=0):Ae.push(ae)},varargs:void 0,get:function(){Cl.varargs+=4;var Q=Ue[Cl.varargs-4>>2];return Q},getStr:function(Q){var ae=oe(Q);return ae},get64:function(Q,ae){return Q}};function bT(Q){return 0}function Og(Q,ae,Ae,bt,cr){}function yT(Q,ae,Ae,bt){for(var cr=0,rr=0;rr<Ae;rr++){for(var ut=Ue[ae+rr*8>>2],pt=Ue[ae+(rr*8+4)>>2],Ur=0;Ur<pt;Ur++)Cl.printChar(Q,we[ut+Ur]);cr+=pt}return Ue[bt>>2]=cr,0}function zg(){return 28}var wn={a:ed,d:Il,e:wi,f:bT,c:Og,b:yT,g:zg},xT=fT(),Gg=t.___wasm_call_ctors=function(){return(Gg=t.___wasm_call_ctors=t.asm.i).apply(null,arguments)},TT=t._init=function(){return(TT=t._init=t.asm.j).apply(null,arguments)},Ug=t._init_with_threads_count=function(){return(Ug=t._init_with_threads_count=t.asm.k).apply(null,arguments)},kT=t._get_threads_count=function(){return(kT=t._get_threads_count=t.asm.l).apply(null,arguments)},Vp=t._register_tensor=function(){return(Vp=t._register_tensor=t.asm.m).apply(null,arguments)},Au=t._dispose_data=function(){return(Au=t._dispose_data=t.asm.n).apply(null,arguments)},td=t._dispose=function(){return(td=t._dispose=t.asm.o).apply(null,arguments)},IT=t._Abs=function(){return(IT=t._Abs=t.asm.p).apply(null,arguments)},CT=t._Add=function(){return(CT=t._Add=t.asm.q).apply(null,arguments)},Wg=t._AddN=function(){return(Wg=t._AddN=t.asm.r).apply(null,arguments)},Me=t._All=function(){return(Me=t._All=t.asm.s).apply(null,arguments)},vT=t._Any=function(){return(vT=t._Any=t.asm.t).apply(null,arguments)},ST=t._ArgMax=function(){return(ST=t._ArgMax=t.asm.u).apply(null,arguments)},wT=t._AvgPool=function(){return(wT=t._AvgPool=t.asm.v).apply(null,arguments)},_T=t._BatchMatMul=function(){return(_T=t._BatchMatMul=t.asm.w).apply(null,arguments)},AT=t._Ceil=function(){return(AT=t._Ceil=t.asm.x).apply(null,arguments)},vl=t._ClipByValue=function(){return(vl=t._ClipByValue=t.asm.y).apply(null,arguments)},NT=t._Conv2D=function(){return(NT=t._Conv2D=t.asm.z).apply(null,arguments)},DT=t._Conv2DBackpropInput=function(){return(DT=t._Conv2DBackpropInput=t.asm.A).apply(null,arguments)},PT=t._Cos=function(){return(PT=t._Cos=t.asm.B).apply(null,arguments)},MT=t._Cosh=function(){return(MT=t._Cosh=t.asm.C).apply(null,arguments)},FT=t._CropAndResize=function(){return(FT=t._CropAndResize=t.asm.D).apply(null,arguments)},ET=t._Cumsum=function(){return(ET=t._Cumsum=t.asm.E).apply(null,arguments)},Kg=t._DepthToSpace=function(){return(Kg=t._DepthToSpace=t.asm.F).apply(null,arguments)},RT=t._DepthwiseConv2dNative=function(){return(RT=t._DepthwiseConv2dNative=t.asm.G).apply(null,arguments)},LT=t._Elu=function(){return(LT=t._Elu=t.asm.H).apply(null,arguments)},Nu=t._Equal=function(){return(Nu=t._Equal=t.asm.I).apply(null,arguments)},rd=t._Exp=function(){return(rd=t._Exp=t.asm.J).apply(null,arguments)},nd=t._FlipLeftRight=function(){return(nd=t._FlipLeftRight=t.asm.K).apply(null,arguments)},BT=t._Floor=function(){return(BT=t._Floor=t.asm.L).apply(null,arguments)},$T=t._FloorDiv=function(){return($T=t._FloorDiv=t.asm.M).apply(null,arguments)},OT=t._FusedBatchNorm=function(){return(OT=t._FusedBatchNorm=t.asm.N).apply(null,arguments)},zT=t._FusedConv2D=function(){return(zT=t._FusedConv2D=t.asm.O).apply(null,arguments)},GT=t._FusedDepthwiseConv2D=function(){return(GT=t._FusedDepthwiseConv2D=t.asm.P).apply(null,arguments)},rt=t._Gather=function(){return(rt=t._Gather=t.asm.Q).apply(null,arguments)},UT=t._GatherNd=function(){return(UT=t._GatherNd=t.asm.R).apply(null,arguments)},WT=t._Greater=function(){return(WT=t._Greater=t.asm.S).apply(null,arguments)},KT=t._GreaterEqual=function(){return(KT=t._GreaterEqual=t.asm.T).apply(null,arguments)},VT=t._LeakyRelu=function(){return(VT=t._LeakyRelu=t.asm.U).apply(null,arguments)},jT=t._Less=function(){return(jT=t._Less=t.asm.V).apply(null,arguments)},HT=t._LessEqual=function(){return(HT=t._LessEqual=t.asm.W).apply(null,arguments)},od=t._Log=function(){return(od=t._Log=t.asm.X).apply(null,arguments)},Vg=t._LogicalAnd=function(){return(Vg=t._LogicalAnd=t.asm.Y).apply(null,arguments)},jg=t._Max=function(){return(jg=t._Max=t.asm.Z).apply(null,arguments)},qT=t._MaxPool=function(){return(qT=t._MaxPool=t.asm._).apply(null,arguments)},XT=t._Maximum=function(){return(XT=t._Maximum=t.asm.$).apply(null,arguments)},YT=t._Mean=function(){return(YT=t._Mean=t.asm.aa).apply(null,arguments)},QT=t._Min=function(){return(QT=t._Min=t.asm.ba).apply(null,arguments)},ZT=t._Minimum=function(){return(ZT=t._Minimum=t.asm.ca).apply(null,arguments)},JT=t._MirrorPad=function(){return(JT=t._MirrorPad=t.asm.da).apply(null,arguments)},ek=t._Multiply=function(){return(ek=t._Multiply=t.asm.ea).apply(null,arguments)},Ct=t._Neg=function(){return(Ct=t._Neg=t.asm.fa).apply(null,arguments)},tk=t._NonMaxSuppressionV3=function(){return(tk=t._NonMaxSuppressionV3=t.asm.ga).apply(null,arguments)},rk=t._NonMaxSuppressionV4=function(){return(rk=t._NonMaxSuppressionV4=t.asm.ha).apply(null,arguments)},nk=t._NonMaxSuppressionV5=function(){return(nk=t._NonMaxSuppressionV5=t.asm.ia).apply(null,arguments)},jp=t._NotEqual=function(){return(jp=t._NotEqual=t.asm.ja).apply(null,arguments)},Hg=t._OneHot=function(){return(Hg=t._OneHot=t.asm.ka).apply(null,arguments)},qg=t._PadV2=function(){return(qg=t._PadV2=t.asm.la).apply(null,arguments)},Xg=t._Pow=function(){return(Xg=t._Pow=t.asm.ma).apply(null,arguments)},ok=t._Prelu=function(){return(ok=t._Prelu=t.asm.na).apply(null,arguments)},sk=t._Prod=function(){return(sk=t._Prod=t.asm.oa).apply(null,arguments)},Yg=t._RealDiv=function(){return(Yg=t._RealDiv=t.asm.pa).apply(null,arguments)},ak=t._Relu=function(){return(ak=t._Relu=t.asm.qa).apply(null,arguments)},ik=t._Relu6=function(){return(ik=t._Relu6=t.asm.ra).apply(null,arguments)},uk=t._ResizeBilinear=function(){return(uk=t._ResizeBilinear=t.asm.sa).apply(null,arguments)},lk=t._Reverse=function(){return(lk=t._Reverse=t.asm.ta).apply(null,arguments)},pk=t._RotateWithOffset=function(){return(pk=t._RotateWithOffset=t.asm.ua).apply(null,arguments)},Qg=t._Round=function(){return(Qg=t._Round=t.asm.va).apply(null,arguments)},Du=t._Rsqrt=function(){return(Du=t._Rsqrt=t.asm.wa).apply(null,arguments)},ck=t._ScatterNd=function(){return(ck=t._ScatterNd=t.asm.xa).apply(null,arguments)},mk=t._SelectV2=function(){return(mk=t._SelectV2=t.asm.ya).apply(null,arguments)},HN=t._Sigmoid=function(){return(HN=t._Sigmoid=t.asm.za).apply(null,arguments)},Zg=t._Sin=function(){return(Zg=t._Sin=t.asm.Aa).apply(null,arguments)},dk=t._Softmax=function(){return(dk=t._Softmax=t.asm.Ba).apply(null,arguments)},fk=t._SparseFillEmptyRows=function(){return(fk=t._SparseFillEmptyRows=t.asm.Ca).apply(null,arguments)},hk=t._SparseReshape=function(){return(hk=t._SparseReshape=t.asm.Da).apply(null,arguments)},gk=t._SparseSegmentReduction=function(){return(gk=t._SparseSegmentReduction=t.asm.Ea).apply(null,arguments)},bk=t._Sqrt=function(){return(bk=t._Sqrt=t.asm.Fa).apply(null,arguments)},yk=t._Square=function(){return(yk=t._Square=t.asm.Ga).apply(null,arguments)},xk=t._SquaredDifference=function(){return(xk=t._SquaredDifference=t.asm.Ha).apply(null,arguments)},Tk=t._Step=function(){return(Tk=t._Step=t.asm.Ia).apply(null,arguments)},kk=t._StridedSlice=function(){return(kk=t._StridedSlice=t.asm.Ja).apply(null,arguments)},Ik=t._Sub=function(){return(Ik=t._Sub=t.asm.Ka).apply(null,arguments)},Ck=t._Sum=function(){return(Ck=t._Sum=t.asm.La).apply(null,arguments)},vk=t._Tan=function(){return(vk=t._Tan=t.asm.Ma).apply(null,arguments)},Sk=t._Tanh=function(){return(Sk=t._Tanh=t.asm.Na).apply(null,arguments)},wk=t._Tile=function(){return(wk=t._Tile=t.asm.Oa).apply(null,arguments)},_k=t._TopK=function(){return(_k=t._TopK=t.asm.Pa).apply(null,arguments)},Ak=t._Transform=function(){return(Ak=t._Transform=t.asm.Qa).apply(null,arguments)},Nk=t._Transpose=function(){return(Nk=t._Transpose=t.asm.Ra).apply(null,arguments)},Dk=t.__FusedMatMul=function(){return(Dk=t.__FusedMatMul=t.asm.Sa).apply(null,arguments)},Pk=t._malloc=function(){return(Pk=t._malloc=t.asm.Ta).apply(null,arguments)},Mk=t._free=function(){return(Mk=t._free=t.asm.Ua).apply(null,arguments)},Jg=t.stackSave=function(){return(Jg=t.stackSave=t.asm.Wa).apply(null,arguments)},eb=t.stackRestore=function(){return(eb=t.stackRestore=t.asm.Xa).apply(null,arguments)},sd=t.stackAlloc=function(){return(sd=t.stackAlloc=t.asm.Ya).apply(null,arguments)};t.cwrap=ee;var Hp;function Fk(Q){this.name="ExitStatus",this.message="Program terminated with exit("+Q+")",this.status=Q}us=function Q(){Hp||ad(),Hp||(us=Q)};function ad(Q){if(Q=Q||u,br>0||(zr(),br>0))return;function ae(){Hp||(Hp=!0,t.calledRun=!0,!W&&(as(),vn(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),zn()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),ae()},1)):ae()}if(t.run=ad,t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();ad();var qp;s&&(qp={uncaughtException:process.listeners("uncaughtException").filter(function(Q){return!s.uncaughtException.indexOf(Q)>-1}),unhandledRejection:process.listeners("unhandledRejection").filter(function(Q){return!s.unhandledRejection.indexOf(Q)>-1})});var Xp;if(typeof e!="undefined")Xp=e;else if(typeof WasmBackendModuleThreadedSimd!="undefined")Xp=WasmBackendModuleThreadedSimd;else throw new Error("Could not find wasm module in post.js");if(qp){var Ek=Xp._dispose;Xp._dispose=function(){Ek(),qp.uncaughtException.forEach(function(Q){process.removeListener("uncaughtException",Q)}),qp.unhandledRejection.forEach(function(Q){process.removeListener("unhandledRejection",Q)})}}return e.ready}}();typeof pT=="object"&&typeof WN=="object"?WN.exports=UN:typeof define=="function"&&define.amd?define([],function(){return UN}):typeof pT=="object"&&(pT.WasmBackendModule=UN)});var cH=1e-7,mH=1e-4,qa=class{constructor(e,t){this.backend=e;this.dataMover=t;this.data=new WeakMap;this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},ps=class{refCount(e){return cs("refCount")}incRef(e){return cs("incRef")}timerAvailable(){return!0}time(e){return cs("time")}read(e){return cs("read")}readSync(e){return cs("readSync")}numDataIds(){return cs("numDataIds")}disposeData(e,t){return cs("disposeData")}write(e,t,n){return cs("write")}move(e,t,n,o,s){return cs("move")}memory(){return cs("memory")}floatPrecision(){return cs("floatPrecision")}epsilon(){return this.floatPrecision()===32?cH:mH}dispose(){return cs("dispose")}};function cs(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function iD(r){let e=r.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,ub(r,e,t)}function dH(r,e){if(r.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${e.length}`);let t=r.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,ub(r,t,n),ub(e,t,n)}function tc(r,e,t){return Math.max(r,Math.min(e,t))}function fH(r){return r%2==0?r:r+1}function ub(r,e,t){let n=r[e];r[e]=r[t],r[t]=n}function hH(r){let e=0;for(let t=0;t<r.length;t++)e+=r[t];return e}function gH(r,e){let t=Math.random();return e*t+(1-t)*r}function bH(r,e){let t=0;for(let n=0;n<r.length;n++){let o=Number(r[n])-Number(e[n]);t+=o*o}return t}function D(r,e){if(!r)throw new Error(typeof e=="string"?e:e())}function Wt(r,e,t=""){D(Wn(r,e),()=>t+` Shapes ${r} and ${e} must match`)}function no(r){D(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Js(r,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(r)||kr(r)&&!t)for(let n=0;n<r.length;++n)Js(r[n],e,t);else e.push(r);return e}function nt(r){if(r.length===0)return 1;let e=r[0];for(let t=1;t<r.length;t++)e*=r[t];return e}function yH(r){return r.length===0}function Wn(r,e){if(r===e)return!0;if(r==null||e==null||r.length!==e.length)return!1;for(let t=0;t<r.length;t++)if(r[t]!==e[t])return!1;return!0}function Ni(r){return r%1==0}function xH(r){if(Math.tanh!=null)return Math.tanh(r);if(r===1/0)return 1;if(r===-1/0)return-1;{let e=Math.exp(2*r);return(e-1)/(e+1)}}function TH(r){let e=Math.ceil(Math.sqrt(r));return[e,Math.ceil(r/e)]}function kH(r){let e=new Uint32Array(r);for(let t=0;t<r;++t)e[t]=t;return iD(e),e}function _l(r,e){return e<=r.length?r:r+" ".repeat(e-r.length)}function IH(r,e=n=>0,t){return new Promise((n,o)=>{let s=0,i=()=>{if(r()){n();return}s++;let a=e(s);if(t!=null&&s>=t){o();return}setTimeout(i,a)};i()})}function CH(r,e){let t=1,n=-1;for(let s=0;s<r.length;++s)if(r[s]>=0)t*=r[s];else if(r[s]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${s}`);n=s}else if(r[s]<0)throw Error(`Shapes can not be < 0. Found ${r[s]} at dim ${s}`);if(n===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${r}`);return r}if(t===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);let o=r.slice();return o[n]=e/t,o}function yr(r,e){let t=e.length;return r=r==null?e.map((n,o)=>o):[].concat(r),D(r.every(n=>n>=-t&&n<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${r}`),D(r.every(n=>Ni(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?t+n:n)}function $k(r,e){let t=[],n=[],o=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||o?null:yr(e,r).sort(),i=0;for(let a=0;a<r.length;++a){if(s!=null){if(s[i]===a&&r[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${r[a]}' is not 1`);(s[i]==null||s[i]>a)&&r[a]===1&&(t.push(r[a]),n.push(a)),s[i]<=a&&i++}r[a]!==1&&(t.push(r[a]),n.push(a))}return{newShape:t,keptDims:n}}function Ok(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${r}`);return t}function zk(r,e){let t=null;if(r==null||r==="float32")t=new Float32Array(e);else if(r==="int32")t=new Int32Array(e);else if(r==="bool")t=new Uint8Array(e);else if(r==="string")t=new Array(e);else throw new Error(`Unknown data type ${r}`);return t}function Gk(r,e){for(let t=0;t<r.length;t++){let n=r[t];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${e} being uploaded contains ${n}.`)}}function Uk(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function vH(r,e){return!(e==="complex64"||e==="float32"&&r!=="complex64"||e==="int32"&&r!=="float32"&&r!=="complex64"||e==="bool"&&r==="bool")}function kr(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray}function lb(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function Wk(r){if(r==null)return 0;let e=0;return r.forEach(t=>e+=t.length),e}function ea(r){return typeof r=="string"||r instanceof String}function uD(r){return typeof r=="boolean"}function lD(r){return typeof r=="number"}function rc(r){return Array.isArray(r)?rc(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array||r instanceof Uint8ClampedArray?"int32":lD(r)?"float32":ea(r)?"string":uD(r)?"bool":"float32"}function Xa(r){return!!(r&&r.constructor&&r.call&&r.apply)}function nc(r,e){for(let t=e;t<r;++t)if(r%t==0)return t;return r}function Ya(r){let e=r.length;if(e<2)return[];let t=new Array(e-1);t[e-2]=r[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*r[n+1];return t}function pD(r,e,t,n=!1){let o=new Array;if(e.length===1){let s=e[0]*(n?2:1);for(let i=0;i<s;i++)o[i]=t[r+i]}else{let s=e[0],i=e.slice(1),a=i.reduce((u,l)=>u*l)*(n?2:1);for(let u=0;u<s;u++)o[u]=pD(r+u*a,i,t,n)}return o}function Al(r,e,t=!1){if(r.length===0)return e[0];let n=r.reduce((o,s)=>o*s)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error(`[${r}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return pD(0,r,e,t)}function cd(r,e){let t=oc(r,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function oc(r,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${e}`)}function SH(r,e){let t=r.reduce((n,o)=>n*o,1);if(e==null||e==="float32")return Al(r,new Float32Array(t));if(e==="int32")return Al(r,new Int32Array(t));if(e==="bool")return Al(r,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function md(r){r.forEach(e=>{D(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function wH(r,e,t){if(e===0)return 0;if(e===1)return r[0];let n=r[r.length-1];for(let o=0;o<r.length-1;++o)n+=t[o]*r[o];return n}function _H(r,e,t){if(e===0)return[];if(e===1)return[r];let n=new Array(e);for(let o=0;o<n.length-1;++o)n[o]=Math.floor(r/t[o]),r-=n[o]*t[o];return n[n.length-1]=r,n}function dd(r){return r&&r.then&&typeof r.then=="function"}var cD="tfjsflags",pb=class{constructor(e){this.global=e;this.flags={};this.flagRegistry={};this.urlFlags={};this.getQueryParams=NH;this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&($().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){let o=this.urlFlags[e];$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];let t=this.evaluateFlag(e);if(dd(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let e=this.getQueryParams(this.global.location.search);cD in e&&e[cD].split(",").forEach(n=>{let[o,s]=n.split(":");this.urlFlags[o]=PH(o,s)})}};function NH(r){let e={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(DH(e,n[0],n[1]),n.join("="))),e}function DH(r,e,t){r[decodeURIComponent(e)]=decodeURIComponent(t||"")}function PH(r,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${r}.`)}function $(){return Kk}var Kk=null;function mD(r){Kk=r}var Vk;function jk(){if(Vk==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");Vk=r}return Vk}function MH(){let r=jk();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function fd(r,e){let t=MH();if(t.has(r))return t.get(r);{let n=e();return t.set(r,n),t.get(r)}}var ms="Abs",Di="Acos",Pi="Acosh",_n="Add",oo="AddN",Mi="All",Fi="Any",so="ArgMax",Qa="ArgMin",Ei="Asin",Ri="Asinh",Li="Atan",Bi="Atanh",$i="Atan2",ao="AvgPool",sc="AvgPoolGrad",Eu="AvgPool3D",ac="AvgPool3DGrad",io="BatchMatMul",ds="BatchToSpaceND",ic="Bincount",dD="BroadcastTo",uc="BroadcastArgs",Kn="Cast",uo="Ceil",Vn="ClipByValue",Ru="Complex",Lu="ComplexAbs",fs="Concat",lo="Conv2D",lc="Conv2DBackpropFilter",po="Conv2DBackpropInput",Bu="Conv3D",pc="Conv3DBackpropFilterV2",cc="Conv3DBackpropInputV2",co="Cos",mo="Cosh",ta="Cumsum",ra="CropAndResize",mc="DenseBincount",na="DepthToSpace",fo="DepthwiseConv2dNative",dc="DepthwiseConv2dNativeBackpropFilter",fc="DepthwiseConv2dNativeBackpropInput",hc="Diag",$u="Dilation2D",hd="Dilation2DBackpropInput",gd="Dilation2DBackpropFilter",ho="RealDiv",Ou="Einsum",go="Elu",gc="EluGrad",Oi="Erf",oa="Equal",bo="Exp",hs="ExpandDims",sa="Expm1",bc="FFT",Za="Fill",aa="FlipLeftRight",yo="Floor",xo="FloorDiv",To="FusedBatchNorm",gs="GatherV2",ia="GatherNd",ua="Greater",ko="GreaterEqual",jn="Identity",yc="IFFT",zu="Imag",zi="IsFinite",Gi="IsInf",Ui="IsNan",Io="LeakyRelu",la="Less",pa="LessEqual",xc="LinSpace",Co="Log",Wi="Log1p",ca="LogicalAnd",Ki="LogicalNot",Nl="LogicalOr",fD="LogSoftmax",Gu="LRN",Tc="LRNGrad",vo="Max",So="Maximum",wo="MaxPool",kc="MaxPoolGrad",Uu="MaxPool3D",Ic="MaxPool3DGrad",Cc="MaxPoolWithArgmax",_o="Mean",Ao="Min",No="Minimum",Do="MirrorPad",Vi="Mod",vc="Multinomial",Po="Multiply",bs="Neg",ma="NotEqual",da="NonMaxSuppressionV3",ji="NonMaxSuppressionV4",fa="NonMaxSuppressionV5",ys="OnesLike",ha="OneHot",xs="Pack",Mo="PadV2",Lde="Pool",Fo="Pow",Eo="Prelu",ga="Prod",Ja="Range",Wu="Real",Hi="Reciprocal",Ro="Relu",Ts="Reshape",ei="ResizeNearestNeighbor",Sc="ResizeNearestNeighborGrad",Lo="ResizeBilinear",wc="ResizeBilinearGrad",Bo="Relu6",ba="Reverse",ya="Round",$o="Rsqrt",xa="ScatterNd",ks="Select",qi="Selu",Is="Slice",Oo="Sin",Ta="Sinh",Xi="Sign",zo="Sigmoid",Yi="Softplus",Go="Sqrt",Uo="Sum",Cs="SpaceToBatchND",vs="SplitV",Wo="Softmax",Ku="SparseFillEmptyRows",Qi="SparseReshape",Vu="SparseSegmentMean",ju="SparseSegmentSum",Hu="SparseToDense",Ko="SquaredDifference",ti="Square",ka="StridedSlice",qu="StringNGrams",_c="StringSplit",Ac="StringToHashBucketFast",Vo="Sub",Ia="Tan",jo="Tanh",An="Tile",Ca="TopK",va="Transform",Ho="Transpose",Nc="Unique",Ss="Unpack",Xu="UnsortedSegmentSum",ws="ZerosLike",_s="Step",Dl="FromPixels",Sa="RotateWithOffset",As="_FusedMatMul",Ns="FusedConv2D",Ds="FusedDepthwiseConv2D";function ri(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.warn(...r)}function FH(...r){$().getBool("IS_TEST")||$().getBool("PROD")||console.log(...r)}var Dc=fd("kernelRegistry",()=>new Map),bd=fd("gradRegistry",()=>new Map);function yd(r,e){let t=qk(r,e);return Dc.get(t)}function Hk(r){return bd.get(r)}function cb(r){let e=Dc.entries(),t=[];for(;;){let{done:n,value:o}=e.next();if(n)break;let[s,i]=o,[a]=s.split("_");a===r&&t.push(i)}return t}function Zi(r){let{kernelName:e,backendName:t}=r,n=qk(e,t);Dc.has(n)&&ri(`The kernel '${e}' for backend '${t}' is already registered`),Dc.set(n,r)}function gD(r){let{kernelName:e}=r;bd.has(e)&&$().getBool("DEBUG")&&ri(`Overriding the gradient for '${e}'`),bd.set(e,r)}function Gde(r,e){let t=qk(r,e);if(!Dc.has(t))throw new Error(`The kernel '${r}' for backend '${e}' is not registered`);Dc.delete(t)}function Ude(r){if(!bd.has(r))throw new Error(`The gradient '${r}' for backend is not registered`);bd.delete(r)}function Wde(r,e){cb(r).forEach(n=>{let o=Object.assign({},n,{backendName:e});Zi(o)})}function qk(r,e){return`${e}_${r}`}var b={};Xe(b,{arraysEqual:()=>Wn,assert:()=>D,assertNonNegativeIntegerDimensions:()=>md,assertNonNull:()=>no,assertShapesMatch:()=>Wt,bytesFromStringArray:()=>Wk,bytesPerElement:()=>lb,checkConversionForErrors:()=>Gk,clamp:()=>tc,computeStrides:()=>Ya,createScalarValue:()=>zH,createShuffledIndices:()=>kH,decodeString:()=>Ec,distSquared:()=>bH,encodeString:()=>Qu,fetch:()=>UH,fingerPrint64:()=>OH,flatten:()=>Js,getArrayFromDType:()=>zk,getTypedArrayFromDType:()=>Ok,hasEncodingLoss:()=>vH,hexToLong:()=>xd,indexToLoc:()=>_H,inferDtype:()=>rc,inferFromImplicitShape:()=>CH,isBoolean:()=>uD,isFunction:()=>Xa,isInt:()=>Ni,isNumber:()=>lD,isPromise:()=>dd,isScalarShape:()=>yH,isString:()=>ea,isTypedArray:()=>kr,isValidDtype:()=>Uk,locToIndex:()=>wH,makeOnesTypedArray:()=>cd,makeZerosNestedTypedArray:()=>SH,makeZerosTypedArray:()=>oc,nearestDivisor:()=>nc,nearestLargerEven:()=>fH,now:()=>Rl,parseAxisParam:()=>yr,randUniform:()=>gH,repeatedTry:()=>IH,rightPad:()=>_l,shuffle:()=>iD,shuffleCombo:()=>dH,sizeFromShape:()=>nt,sizeToSquarishShape:()=>TH,squeezeShape:()=>$k,sum:()=>hH,swap:()=>ub,tanh:()=>xH,toNestedArray:()=>Al,toTypedArray:()=>Fc});var Qk=wl(_D());var Fl=Qk.default||Qk;function xd(r){return Fl.fromString(r,!0,16)}var AD=xd("c3a5c85c97cb3127"),El=xd("b492b66fbe98f273"),un=xd("9ae16a3b2f90404f");function Zk(r){return r.xor(r.shru(47))}function ND(r,e,t){let n=r.slice(e,e+t);return Fl.fromBytes(Array.from(n),!0,!0)}function qt(r,e){return ND(r,e,8)}function DD(r,e){return ND(r,e,4)}function Er(r,e){return e===0?r:r.shru(e).or(r.shl(64-e))}function Yu(r,e,t=xd("9ddfea08eb382d69")){let n=r.xor(e).mul(t);n=n.xor(n.shru(47));let o=e.xor(n).mul(t);return o=o.xor(o.shru(47)),o=o.mul(t),o}function RH(r,e,t,n,o,s){o=o.add(r),s=Er(s.add(o).add(n),21);let i=o;return o=o.add(e),o=o.add(t),s=s.add(Er(o,44)),[o.add(n),s.add(i)]}function db(r,e,t,n){return RH(qt(r,e),qt(r,e+8),qt(r,e+16),qt(r,e+24),t,n)}function LH(r,e=r.length){if(e>=8){let t=un.add(e*2),n=qt(r,0).add(un),o=qt(r,e-8),s=Er(o,37).mul(t).add(n),i=Er(n,25).add(o).mul(t);return Yu(s,i,t)}if(e>=4){let t=un.add(e*2),n=DD(r,0);return Yu(n.shl(3).add(e),DD(r,e-4),t)}if(e>0){let t=r[0],n=r[e>>1],o=r[e-1],s=t+(n<<8),i=e+(o<<2);return Zk(un.mul(s).xor(AD.mul(i))).mul(un)}return un}function BH(r,e=r.length){let t=un.add(e*2),n=qt(r,0).mul(El),o=qt(r,8),s=qt(r,e-8).mul(t),i=qt(r,e-16).mul(un);return Yu(Er(n.add(o),43).add(Er(s,30)).add(i),n.add(Er(o.add(un),18)).add(s),t)}function $H(r,e=r.length){let t=un.add(e*2),n=qt(r,0).mul(un),o=qt(r,8),s=qt(r,e-8).mul(t),i=qt(r,e-16).mul(un),a=Er(n.add(o),43).add(Er(s,30)).add(i),u=Yu(a,n.add(Er(o.add(un),18)).add(s),t),l=qt(r,16).mul(t),p=qt(r,24),c=a.add(qt(r,e-32)).mul(t),m=u.add(qt(r,e-24)).mul(t);return Yu(Er(l.add(p),43).add(Er(c,30)).add(m),l.add(Er(p.add(n),18)).add(c),t)}function OH(r,e=r.length){let t=Fl.fromNumber(81,!0);if(e<=32)return e<=16?LH(r,e):BH(r,e);if(e<=64)return $H(r,e);let n=t,o=t.mul(El).add(113),s=Zk(o.mul(un).add(113)).mul(un),i=[Fl.UZERO,Fl.UZERO],a=[Fl.UZERO,Fl.UZERO];n=n.mul(un).add(qt(r,0));let u=0,l=(e-1>>6)*64,p=l+(e-1&63)-63;do n=Er(n.add(o).add(i[0]).add(qt(r,u+8)),37).mul(El),o=Er(o.add(i[1]).add(qt(r,u+48)),42).mul(El),n=n.xor(a[1]),o=o.add(i[0]).add(qt(r,u+40)),s=Er(s.add(a[0]),33).mul(El),i=db(r,u,i[1].mul(El),n.add(a[0])),a=db(r,u+32,s.add(a[1]),o.add(qt(r,u+16))),[s,n]=[n,s],u+=64;while(u!==l);let c=El.add(s.and(255).shl(1));return u=p,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),n=Er(n.add(o).add(i[0]).add(qt(r,u+8)),37).mul(c),o=Er(o.add(i[1]).add(qt(r,u+48)),42).mul(c),n=n.xor(a[1].mul(9)),o=o.add(i[0].mul(9).add(qt(r,u+40))),s=Er(s.add(a[0]),33).mul(c),i=db(r,u,i[1].mul(c),n.add(a[0])),a=db(r,u+32,s.add(a[1]),o.add(qt(r,u+16))),[s,n]=[n,s],Yu(Yu(i[0],a[0],c).add(Zk(o).mul(AD)).add(s),Yu(i[1],a[1],c).add(n),c)}function zH(r,e){return e==="string"?Qu(r):Fc([r],e)}function GH(r,e){return r instanceof Float32Array&&e==="float32"||r instanceof Int32Array&&e==="int32"||r instanceof Uint8Array&&e==="bool"}function Fc(r,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Js(r)),$().getBool("DEBUG")&&Gk(r,e),GH(r,e))return r;if(e==null||e==="float32"||e==="complex64")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"){let t=new Uint8Array(r.length);for(let n=0;n<t.length;++n)Math.round(r[n])!==0&&(t[n]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Rl(){return $().platform.now()}function UH(r,e){return $().platform.fetch(r,e)}function Qu(r,e="utf-8"){return e=e||"utf-8",$().platform.encode(r,e)}function Ec(r,e="utf-8"){return e=e||"utf-8",$().platform.decode(r,e)}var Jk=class{constructor(e,t){this.backendTimer=e;this.logger=t;t==null&&(this.logger=new PD)}profileKernel(e,t,n){let o,s=()=>{o=n()},i,a=Rl();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(s);else{s();for(let l of o)l.dataSync();i=Promise.resolve({kernelMs:Rl()-a})}if($().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<o.length;l++){let p=o[l];p.data().then(c=>{WH(c,p.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){let{kernelName:t,outputs:n,timeMs:o,inputs:s,extraInfo:i}=e;n.forEach(a=>{Promise.all([a.data(),o,i]).then(u=>{this.logger.logKernelProfile(t,a,u[0],u[1],s,u[2])})})}};function WH(r,e,t){if(e!=="float32")return!1;for(let n=0;n<r.length;n++){let o=r[n];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}var PD=class{logKernelProfile(e,t,n,o,s,i){let a=typeof o=="number"?_l(`${o}ms`,9):o.error,u=_l(e,25),l=t.rank,p=t.size,c=_l(t.shape.toString(),14),m="";for(let d in s){let f=s[d];if(f!=null){let h=f.shape||t.shape,g=h.length;m+=`${d}: ${g}D ${g>0?h:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${c}	%c${p}	%c${m}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function MD(r,e,t){let n={},o={};for(let u=0;u<e.length;u++)n[e[u].id]=!0;for(let u=0;u<r.length;u++){let l=r[u],p=l.inputs;for(let c in p){let m=p[c],d=!1;for(let f=0;f<e.length;f++)if(n[m.id]){l.outputs.forEach(h=>n[h.id]=!0),d=!0,o[l.id]=!0;break}if(d)break}}let s={};s[t.id]=!0;let i={};for(let u=r.length-1;u>=0;u--){let l=r[u],p=l.inputs;for(let c=0;c<l.outputs.length;c++)if(s[l.outputs[c].id]){for(let m in p)s[p[m].id]=!0,i[l.id]=!0;break}}let a=[];for(let u=0;u<r.length;u++){let l=r[u];if(o[l.id]&&i[l.id]){let p={};for(let m in l.inputs){let d=l.inputs[m];n[d.id]&&(p[m]=d)}let c=Object.assign({},l);c.inputs=p,c.outputs=l.outputs,a.push(c)}}return a}function FD(r,e,t,n){for(let o=e.length-1;o>=0;o--){let s=e[o],i=[];if(s.outputs.forEach(u=>{let l=r[u.id];l!=null?i.push(l):i.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);let a=s.gradient(i);for(let u in s.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);let l=t(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);let p=s.inputs[u];if(!Wn(l.shape,p.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${p.shape}'`);if(r[p.id]==null)r[p.id]=l;else{let c=r[p.id];r[p.id]=n(c,l),c.dispose()}}}}var ED=20,Td=3,eI=7;function RD(r,e,t,n){let o=Ya(e),s=KH(r,e,t,o),i=e.length,a=fb(r,e,t,o,s),u=["Tensor"];return n&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function KH(r,e,t,n){let o=nt(e),s=n[n.length-1],i=new Array(s).fill(0),a=e.length,u=t==="complex64"?Id(r):r;if(a>1)for(let l=0;l<o/s;l++){let p=l*s;for(let c=0;c<s;c++)i[c]=Math.max(i[c],kd(u[p+c],0,t).length)}return i}function kd(r,e,t){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(eI))} + ${parseFloat(r[1].toFixed(eI))}j`:ea(r)?n=`'${r}'`:t==="bool"?n=LD(r):n=parseFloat(r.toFixed(eI)).toString(),_l(n,e)}function LD(r){return r===0?"false":"true"}function fb(r,e,t,n,o,s=!0){let i=t==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(t==="complex64"){let h=Id(r);return[kd(h[0],0,t)]}return t==="bool"?[LD(r[0])]:[r[0].toString()]}if(u===1){if(a>ED){let g=Td*i,x=Array.from(r.slice(0,g)),y=Array.from(r.slice((a-Td)*i,a*i));return t==="complex64"&&(x=Id(x),y=Id(y)),["["+x.map((T,k)=>kd(T,o[k],t)).join(", ")+", ..., "+y.map((T,k)=>kd(T,o[a-Td+k],t)).join(", ")+"]"]}let h=t==="complex64"?Id(r):Array.from(r);return["["+h.map((g,x)=>kd(g,o[x],t)).join(", ")+"]"]}let l=e.slice(1),p=n.slice(1),c=n[0]*i,m=[];if(a>ED){for(let h=0;h<Td;h++){let g=h*c,x=g+c;m.push(...fb(r.slice(g,x),l,t,p,o,!1))}m.push("...");for(let h=a-Td;h<a;h++){let g=h*c,x=g+c;m.push(...fb(r.slice(g,x),l,t,p,o,h===a-1))}}else for(let h=0;h<a;h++){let g=h*c,x=g+c;m.push(...fb(r.slice(g,x),l,t,p,o,h===a-1))}let d=u===2?",":"";m[0]="["+m[0]+d;for(let h=1;h<m.length-1;h++)m[h]=" "+m[h]+d;let f=`,
`;for(let h=2;h<u;h++)f+=`
`;return m[m.length-1]=" "+m[m.length-1]+"]"+(s?"":f),m}function Id(r){let e=[];for(let t=0;t<r.length;t+=2)e.push([r[t],r[t+1]]);return e}var yt=class{constructor(e,t,n){this.dtype=t;if(this.shape=e.slice(),this.size=nt(e),n!=null){let o=n.length;D(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||zk(t,this.size),this.strides=Ya(e)}set(e,...t){t.length===0&&(t=[0]),D(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);let n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(let o of e){if(o<0||o>=this.shape[t]){let s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let n=e[e.length-1];for(let o=0;o<e.length-1;++o)n+=this.strides[o]*e[o];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];let t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return ni().makeTensor(this.values,this.shape,this.dtype)}},ni=null,Rc=null,VH=null;function BD(r){ni=r}function $D(r){Rc=r}function OD(r){VH=r}var Ye=class{constructor(e,t,n,o){this.kept=!1;this.isDisposedInternal=!1;this.shape=e.slice(),this.dtype=t||"float32",this.size=nt(e),this.strides=Ya(e),this.dataId=n,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let e=await this.data();return Rc.buffer(this.shape,this.dtype,e)}bufferSync(){return Rc.buffer(this.shape,this.dtype,this.dataSync())}async array(){let e=await this.data();return Al(this.shape,e,this.dtype==="complex64")}arraySync(){return Al(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();let e=ni().read(this.dataId);if(this.dtype==="string"){let t=await e;try{return t.map(n=>Ec(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();let e=ni().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Ec(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();let e=await ni().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(ni().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Rc.print(this,e)}clone(){return this.throwIfDisposed(),Rc.clone(this)}toString(e=!1){let t=this.dataSync();return RD(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Rc.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),ni().makeVariable(this,e,t,n)}};Object.defineProperty(Ye,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function jH(){return fd("Tensor",()=>Ye)}jH();var Zu=class extends Ye{constructor(e,t,n,o){super(e.shape,e.dtype,e.dataId,o);this.trainable=t;this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Wn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);ni().disposeTensor(this),this.dataId=e.dataId,ni().incRef(this,null)}dispose(){ni().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(Zu,Symbol.hasInstance,{value:r=>r instanceof Ye&&r.assign!=null&&r.assign instanceof Function});var Es={};Xe(Es,{assertTypesMatch:()=>tI,getTensorsInContainer:()=>Cd,isTensorInList:()=>qH,makeTypesMatch:()=>Qe});var zD=(a=>(a.R0="R0",a.R1="R1",a.R2="R2",a.R3="R3",a.R4="R4",a.R5="R5",a.R6="R6",a))(zD||{}),GD=(o=>(o.float32="float32",o.int32="int32",o.bool="int32",o.complex64="complex64",o))(GD||{}),UD=(o=>(o.float32="float32",o.int32="int32",o.bool="bool",o.complex64="complex64",o))(UD||{}),WD=(o=>(o.float32="float32",o.int32="float32",o.bool="float32",o.complex64="complex64",o))(WD||{}),KD=(o=>(o.float32="complex64",o.int32="complex64",o.bool="complex64",o.complex64="complex64",o))(KD||{}),HH={float32:WD,int32:GD,bool:UD,complex64:KD};function Kt(r,e){if(r==="string"||e==="string"){if(r==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${r} with ${e}`)}return HH[r][e]}function Ji(r){return Kt(r,"int32")}function Qe(r,e){if(r.dtype===e.dtype)return[r,e];let t=Kt(r.dtype,e.dtype);return[r.cast(t),e.cast(t)]}function tI(r,e){D(r.dtype===e.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${e.dtype}) input must match`)}function qH(r,e){return e.some(t=>t.id===r.id)}function Cd(r){let e=[];return VD(r,e,new Set),e}function VD(r,e,t){if(r==null)return;if(r instanceof Ye){e.push(r);return}if(!XH(r))return;let n=r;for(let o in n){let s=n[o];t.has(s)||(t.add(s),VD(s,e,t))}}function XH(r){return Array.isArray(r)||typeof r=="object"}function rI(r){return r.kernelName!=null}var nI=class{constructor(){this.registeredVariables={};this.nextTapeNodeId=0;this.numBytes=0;this.numTensors=0;this.numStringTensors=0;this.numDataBuffers=0;this.gradientDepth=0;this.kernelDepth=0;this.scopeStack=[];this.numDataMovesStack=[];this.nextScopeId=0;this.tensorInfo=new WeakMap;this.profiling=!1;this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(let e in this.registeredVariables)this.registeredVariables[e].dispose()}},gb=class{constructor(e){this.ENV=e;this.registry={};this.registryFactory={};this.pendingBackendInitId=0;this.state=new nI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){let{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(ri(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;let{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Jk(this.backendInstance),!0}setupRegisteredKernels(){cb(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){cb(e).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[e])})}initializeBackend(e){let t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{let n=t.factory();if(n&&!(n instanceof ps)&&typeof n.then=="function"){let o=++this.pendingBackendInitId,s=n.then(i=>o<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,ri(`Initialization of backend ${e} failed`),ri(i.stack||i.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return ri(`Initialization of backend ${e} failed`),ri(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){let e=this.getSortedBackends();for(let t=0;t<e.length;t++){let n=e[t],{success:o,asyncInit:s}=this.initializeBackend(n);if(s||o)return{name:n,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){let n=this.state.tensorInfo.get(t),o=n.backend,s=this.readSync(t),i=o.refCount(t);o.disposeData(t,!0),n.backend=e,e.move(t,s,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let o;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(o),()=>(o=t(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,t,n){e();try{let o=n();return t(),o}catch(o){throw t(),o}}nextTensorId(){return gb.nextTensorId++}nextVariableId(){return gb.nextVariableId++}clone(e){let t=N.runKernel(jn,{x:e}),n={x:e},o=i=>({x:()=>{let a="float32",u={x:i},l={dtype:a};return N.runKernel(Kn,u,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,n,[t],o,s,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,!(yd(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){let o=this.backend.numDataIds(),s=0;n.forEach(u=>{s+=u.dtype==="complex64"?3:1});let i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=o-t-s-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[],o=this.isTapeOn(),s=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u,l=rI(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(rI(e)){let{kernelName:f,inputs:h,attrs:g}=e;this.backendName==null&&this.backend;let x=yd(f,this.backendName);D(x!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{let y=this.backend.numDataIds();u=x.kernelFunc({inputs:h,attrs:g,backend:this.backend});let T=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,y,T);let k=T.map(C=>{if(C.rank!=null)return C;let{dataId:A,shape:M,dtype:P}=C;return this.makeTensorFromDataId(A,M,P)});if(o){let C=this.getTensorsForGradient(f,h,k);n=this.saveTensorsForBackwardMode(C)}return k}}else{let{forwardFunc:f}=e,h=g=>{!o||(n=g.map(x=>this.keep(this.clone(x))))};a=()=>{let g=this.backend.numDataIds();u=this.tidy(()=>f(this.backend,h));let x=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,g,x),x}}let{inputs:p,attrs:c}=e,m=rI(e)?null:e.backwardsFunc,d;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(d=this.profiler.profileKernel(l,p,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs)}),o&&this.addTapeNode(l,p,t,m,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(p).map(f=>p[f]!=null?p[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(e,t,n){let o=Hk(e);if(o!=null){let s=o.inputsToSave||[],i=o.outputsToSave||[],a;o.saveAllInputs?(D(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(l=>t[l])):a=s.map(l=>t[l]);let u=n.filter((l,p)=>i[p]);return a.concat(u)}return[]}makeTensor(e,t,n,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",o=o||this.backend;let s=e;n==="string"&&ea(e[0])&&(s=e.map(u=>Qu(u)));let i=o.write(s,t,n),a=new Ye(t,n,i,this.nextTensorId());if(this.trackTensor(a,o),n==="string"){let u=this.state.tensorInfo.get(i),l=Wk(s);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(e,t,n,o){n=n||"float32";let s=new Ye(t,n,e,this.nextTensorId());return this.trackTensor(s,o),s}makeVariable(e,t=!0,n,o){n=n||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));let s=new Zu(e,t,n,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*lb(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Zu||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;let t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){let n=e.size*lb(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(let e in this.state.registeredVariables){let t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){let e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;let t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,o,s,i){let a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:s},u=Hk(e);u!=null&&(o=u.gradFunc),o!=null&&(a.gradient=l=>(l=l.map((p,c)=>{if(p==null){let m=n[c],d=oc(m.size,m.dtype);return this.makeTensor(d,m.shape,m.dtype)}return p}),o(l.length>1?l:l[0],s,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){let t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){let t=Cd(e),n=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){let i=this.state.activeScope.track[s];!i.kept&&!n.has(i.id)&&i.dispose()}let o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===o.id&&this.track(s)})}gradients(e,t,n,o=!1){if(D(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));D(s instanceof Ye,()=>"The result y returned by f() must be a tensor.");let i=MD(this.state.activeTape,t,s);if(!o&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let a={};a[s.id]=n??YH(s.shape),FD(a,i,l=>this.tidy(l),QH);let u=t.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(let p of l.saved)p.dispose()}),this.state.activeTape=null),{value:s,grads:u}})}customGrad(e){return D(Xa(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{D(t.every(a=>a instanceof Ye),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,o={};t.forEach((a,u)=>{o[u]=a});let s=(a,u)=>(n=e(...t,u),D(n.value instanceof Ye,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),D(Xa(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),i=(a,u)=>{let l=n.gradFunc(a,u),p=Array.isArray(l)?l:[l];D(p.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),D(p.every(m=>m instanceof Ye),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let c={};return p.forEach((m,d)=>{c[d]=()=>m}),c};return this.runKernelFunc({forwardFunc:s,backwardsFunc:i,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){let t=Rl(),n=await this.backend.time(e);return n.wallMs=Rl()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new nI;for(let e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}},hb=gb;hb.nextTensorId=0,hb.nextVariableId=0;function YH(r){let e=cd(nt(r),"float32");return N.makeTensor(e,r,"float32")}function oI(){let r=jk();if(r._tfengine==null){let e=new pb(r);r._tfengine=new hb(e)}return mD(r._tfengine.ENV),BD(()=>r._tfengine),r._tfengine}var N=oI();function QH(r,e){let t={a:r,b:e};return N.runKernel(_n,t)}var oi={};Xe(oi,{isBrowser:()=>aI,isMobile:()=>eq,mockIsMobile:()=>JH});function ZH(){return typeof navigator!="undefined"&&navigator!=null}var sI;function JH(r){sI=r}function eq(r){if(sI!==void 0)return sI;if(r||ZH()){if(r||(r=navigator),r.product==="ReactNative")return!0;let e=r.userAgent||r.vendor||(typeof window!="undefined"?window.opera:"");if(!e){let t=r;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function aI(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var _a=$();_a.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});_a.registerFlag("IS_BROWSER",()=>aI());_a.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");_a.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));_a.registerFlag("PROD",()=>!1);_a.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>_a.getBool("DEBUG"));_a.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);_a.registerFlag("IS_TEST",()=>!1);_a.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);_a.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);function Wr(r,e){let t=r;if(kr(r))return e==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(t)||kr(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(r)&&$().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&jD(r,n,[]),n}function jD(r,e,t){if(t=t||[],!Array.isArray(r)&&!kr(r)){D(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}D(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${r.length} elements`),D(r.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${r.length} elements`);let n=e.slice(1);for(let o=0;o<r.length;++o)jD(r[o],n,t.concat(o))}function HD(r,e,t,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==e||r==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${n}' must be ${r} tensor, but got ${e} tensor`)}}function v(r,e,t,n="numeric"){if(r instanceof Ye)return HD(n,r.dtype,e,t),r;let o=rc(r);if(o!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(o=n),HD(n,o,e,t),r==null||!kr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}let s=Wr(r,o);!kr(r)&&!Array.isArray(r)&&(r=[r]);let a=o!=="string"?Fc(r,o):Js(r,[],!0);return N.makeTensor(a,s,o)}function eu(r,e,t,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((s,i)=>v(s,`${e}[${i}]`,t,n))}var qD="__op";function _(r){let e=Object.keys(r);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0],n=r[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+qD;let o=(...s)=>{N.startScope(t);try{let i=n(...s);return dd(i)&&console.error("Cannot return a Promise inside of tidy."),N.endScope(i),i}catch(i){throw N.endScope(null),i}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}function tq(r,e){let t=v(r,"real","complex"),n=v(e,"imag","complex");Wt(t.shape,n.shape,`real and imag shapes, ${t.shape} and ${n.shape}, must match in call to tf.complex().`);let o={real:t,imag:n};return N.runKernel(Ru,o)}var Xn=_({complex_:tq});function ln(r,e,t,n){if(n==null&&(n=rc(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!kr(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){md(e);let o=nt(e),s=nt(t);D(o===s,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${s}`);for(let i=0;i<t.length;++i){let a=t[i],u=i===t.length-1?a!==nt(e.slice(i)):!0;D(t[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!kr(r)&&!Array.isArray(r)&&(r=[r]),e=e||t,r=n!=="string"?Fc(r,n):Js(r,[],!0),N.makeTensor(r,e,n)}function Rr(r,e,t){let n=Wr(r,t);return ln(r,e,n,t)}var vd={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var bb=4;async function XD(r,e){let t=[],n=[],o=Array.isArray(r)?r.map(i=>i.name):Object.keys(r);for(let i=0;i<o.length;++i){let a=o[i],u=Array.isArray(r)?r[i].tensor:r[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);let l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let p=new Promise(async c=>{let m=await u.bytes(),d=m.reduce((g,x)=>g+x.length,0)+bb*m.length,f=new Uint8Array(d),h=0;for(let g=0;g<m.length;g++){let x=m[g],y=new Uint8Array(new Uint32Array([x.length]).buffer);f.set(y,h),h+=bb,f.set(x,h),h+=x.length}c(f)});n.push(p)}else n.push(u.data());e!=null&&(l.group=e),t.push(l)}let s=await Promise.all(n);return{data:rq(s),specs:t}}function yb(r,e){let t={},n,o=0;for(let s of e){let i=s.name,a=s.dtype,u=s.shape,l=nt(u),p;if("quantization"in s){let c=s.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${s.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let m=vd[c.dtype],d=r.slice(o,o+l*m),f=c.dtype==="uint8"?new Uint8Array(d):new Uint16Array(d);if(a==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){p=new Float32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];p[h]=g*c.scale+c.min}}else if(c.dtype==="float16")n===void 0&&(n=aq()),p=n(f);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(a==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);p=new Int32Array(f.length);for(let h=0;h<f.length;h++){let g=f[h];p[h]=Math.round(g*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*m}else if(a==="string"){let c=nt(s.shape);p=[];for(let m=0;m<c;m++){let d=new Uint32Array(r.slice(o,o+bb))[0];o+=bb;let f=new Uint8Array(r.slice(o,o+d));p.push(f),o+=d}}else{let c=vd[a],m=r.slice(o,o+l*c);if(a==="float32")p=new Float32Array(m);else if(a==="int32")p=new Int32Array(m);else if(a==="bool")p=new Uint8Array(m);else if(a==="complex64"){p=new Float32Array(m);let d=new Float32Array(p.length/2),f=new Float32Array(p.length/2);for(let x=0;x<d.length;x++)d[x]=p[x*2],f[x]=p[x*2+1];let h=Rr(d,u,"float32"),g=Rr(f,u,"float32");t[i]=Xn(h,g),h.dispose(),g.dispose()}else throw new Error(`Unsupported dtype in weight '${i}': ${a}`);o+=l*c}a!=="complex64"&&(t[i]=Rr(p,u,a))}return t}function rq(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let e=0,t=[];r.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});let n=new Uint8Array(e),o=0;return t.forEach(s=>{n.set(new Uint8Array(s.buffer),o),o+=s.byteLength}),n.buffer}var iI=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function YD(r){return iI?Buffer.byteLength(r):new Blob([r]).size}function QD(r){if(iI)return Buffer.from(r).toString("base64");let e=new Uint8Array(r),t="";for(let n=0,o=e.length;n<o;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function ZD(r){if(iI){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let e=atob(r),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function Lc(r){if(r.length===1)return r[0];let e=0;r.forEach(o=>{e+=o.byteLength});let t=new Uint8Array(e),n=0;return r.forEach(o=>{t.set(new Uint8Array(o),n),n+=o.byteLength}),t.buffer}function uI(r){let e="/";for(r=r.trim();r.endsWith(e);)r=r.slice(0,r.length-1);let t=r.split(e);return t[t.length-1]}function xb(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy,weightsManifest:e};return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),t}async function Bc(r,e){let t={modelTopology:r.modelTopology,format:r.format,generatedBy:r.generatedBy,convertedBy:r.convertedBy};if(r.trainingConfig!=null&&(t.trainingConfig=r.trainingConfig),r.weightsManifest!=null){let[n,o]=await e(r.weightsManifest);t.weightSpecs=n,t.weightData=o}return r.signature!=null&&(t.signature=r.signature),r.userDefinedMetadata!=null&&(t.userDefinedMetadata=r.userDefinedMetadata),r.modelInitializer!=null&&(t.modelInitializer=r.modelInitializer),t}function si(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:YD(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:YD(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function nq(){let r=t=>{let n=t<<13,o=0;for(;(n&8388608)==0;)o-=8388608,n<<=1;return n&=~8388608,o+=947912704,n|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=r(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function oq(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let e=1;e<31;e++)r[e]=e<<23;for(let e=33;e<63;e++)r[e]=2147483648+(e-32<<23);return r}function sq(){let r=new Uint32Array(64);for(let e=0;e<64;e++)r[e]=1024;return r[0]=r[32]=0,r}function aq(){let r=nq(),e=oq(),t=sq();return n=>{let o=new ArrayBuffer(4*n.length),s=new Uint32Array(o);for(let i=0;i<n.length;i++){let a=n[i],u=r[t[a>>10]+(a&1023)]+e[a>>10];s[i]=u}return new Float32Array(o)}}var Et=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Et.instance==null&&(Et.instance=new Et),Et.instance}static registerSaveRouter(e){Et.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Et.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Et.getHandlers(e,"save")}static getLoadHandlers(e,t){return Et.getHandlers(e,"load",t)}static getHandlers(e,t,n){let o=[];return(t==="load"?Et.getInstance().loadRouters:Et.getInstance().saveRouters).forEach(i=>{let a=i(e,n);a!==null&&o.push(a)}),o}},JD=r=>Et.registerSaveRouter(r),e0=r=>Et.registerLoadRouter(r),t0=r=>Et.getSaveHandlers(r),r0=(r,e)=>Et.getLoadHandlers(r,e);var lI="tensorflowjs",pI=1,Ll="models_store",Ju="model_info_store";function n0(){if(!$().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,e=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function cI(r){let e=r.result;e.createObjectStore(Ll,{keyPath:"modelPath"}),e.createObjectStore(Ju,{keyPath:"modelPath"})}var tu=class{constructor(e){if(this.indexedDB=n0(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,o)=>{let s=this.indexedDB.open(lI,pI);s.onupgradeneeded=()=>cI(s),s.onsuccess=()=>{let i=s.result;if(t==null){let a=i.transaction(Ll,"readonly"),l=a.objectStore(Ll).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(l.result.modelArtifacts)},l.onerror=p=>(i.close(),o(l.error)),a.oncomplete=()=>i.close()}else{let a=si(t),u=i.transaction(Ju,"readwrite"),l=u.objectStore(Ju),p=l.put({modelPath:this.modelPath,modelArtifactsInfo:a}),c;p.onsuccess=()=>{c=i.transaction(Ll,"readwrite");let d=c.objectStore(Ll).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});d.onsuccess=()=>n({modelArtifactsInfo:a}),d.onerror=f=>{l=u.objectStore(Ju);let h=l.delete(this.modelPath);h.onsuccess=()=>(i.close(),o(d.error)),h.onerror=g=>(i.close(),o(d.error))}},p.onerror=m=>(i.close(),o(p.error)),u.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}}},s.onerror=i=>o(s.error)})}};tu.URL_SCHEME="indexeddb://";var o0=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(tu.URL_SCHEME)?iq(r.slice(tu.URL_SCHEME.length)):null;Et.registerSaveRouter(o0);Et.registerLoadRouter(o0);function iq(r){return new tu(r)}function uq(r){return r.startsWith(tu.URL_SCHEME)?r.slice(tu.URL_SCHEME.length):r}var mI=class{constructor(){this.indexedDB=n0()}async listModels(){return new Promise((e,t)=>{let n=this.indexedDB.open(lI,pI);n.onupgradeneeded=()=>cI(n),n.onsuccess=()=>{let o=n.result,s=o.transaction(Ju,"readonly"),a=s.objectStore(Ju).getAll();a.onsuccess=()=>{let u={};for(let l of a.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},a.onerror=u=>(o.close(),t(a.error)),s.oncomplete=()=>o.close()},n.onerror=o=>t(n.error)})}async removeModel(e){return e=uq(e),new Promise((t,n)=>{let o=this.indexedDB.open(lI,pI);o.onupgradeneeded=()=>cI(o),o.onsuccess=()=>{let s=o.result,i=s.transaction(Ju,"readwrite"),a=i.objectStore(Ju),u=a.get(e),l;u.onsuccess=()=>{if(u.result==null)return s.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{let p=a.delete(e),c=()=>{l=s.transaction(Ll,"readwrite");let d=l.objectStore(Ll).delete(e);d.onsuccess=()=>t(u.result.modelArtifactsInfo),d.onerror=f=>n(u.error)};p.onsuccess=c,p.onerror=m=>(c(),s.close(),n(u.error))}},u.onerror=p=>(s.close(),n(u.error)),i.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},o.onerror=s=>n(o.error)})}};var ru="/",$c="tensorflowjs_models",s0="info",lq="model_topology",pq="weight_specs",cq="weight_data",mq="model_metadata";function a0(r){return{info:[$c,r,s0].join(ru),topology:[$c,r,lq].join(ru),weightSpecs:[$c,r,pq].join(ru),weightData:[$c,r,cq].join(ru),modelMetadata:[$c,r,mq].join(ru)}}function i0(r){for(let e of Object.values(r))window.localStorage.removeItem(e)}function dq(r){let e=r.split(ru);if(e.length<3)throw new Error(`Invalid key format: ${r}`);return e.slice(1,e.length-1).join(ru)}function fq(r){return r.startsWith(nu.URL_SCHEME)?r.slice(nu.URL_SCHEME.length):r}var nu=class{constructor(e){if(!$().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=a0(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),o=si(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,QD(e.weightData));let s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:o}}catch{throw i0(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){let e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;let o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;let s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){let a=JSON.parse(s);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}let i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=ZD(i),t}};nu.URL_SCHEME="localstorage://";var u0=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(nu.URL_SCHEME)?hq(r.slice(nu.URL_SCHEME.length)):null;Et.registerSaveRouter(u0);Et.registerLoadRouter(u0);function hq(r){return new nu(r)}var dI=class{constructor(){D($().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),D(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let e={},t=$c+ru,n=ru+s0;for(let o=0;o<this.LS.length;++o){let s=this.LS.key(o);if(s.startsWith(t)&&s.endsWith(n)){let i=dq(s);e[i]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=fq(e);let t=a0(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);let n=JSON.parse(this.LS.getItem(t.info));return i0(t),n}};var Oc="://",pn=class{constructor(){this.managers={}}static getInstance(){return pn.instance==null&&(pn.instance=new pn),pn.instance}static registerManager(e,t){D(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Oc)&&(e=e.slice(0,e.indexOf(Oc))),D(e.length>0,()=>"scheme must not be an empty string.");let n=pn.getInstance();D(n.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),n.managers[e]=t}static getManager(e){let t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}};function Tb(r){if(r.indexOf(Oc)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${pn.getSchemes().join(",")}`);return{scheme:r.split(Oc)[0],path:r.split(Oc)[1]}}async function l0(r,e,t=!1){D(r!==e,()=>`Old path and new path are the same: '${r}'`);let n=Et.getLoadHandlers(r);D(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),D(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let o=n[0],s=Et.getSaveHandlers(e);D(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),D(s.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${e}.`);let i=s[0],a=Tb(r).scheme,u=Tb(r).path,l=a===Tb(r).scheme,p=await o.load();t&&l&&await pn.getManager(a).removeModel(u);let c=await i.save(p);return t&&!l&&await pn.getManager(a).removeModel(u),c.modelArtifactsInfo}async function p0(){let r=pn.getSchemes(),e={};for(let t of r){let n=await pn.getManager(t).listModels();for(let o in n){let s=t+Oc+o;e[s]=n[o]}}return e}async function c0(r){let e=Tb(r);return pn.getManager(e.scheme).removeModel(e.path)}async function m0(r,e){return l0(r,e,!1)}async function d0(r,e){return l0(r,e,!0)}var f0=class{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}};if($().get("IS_BROWSER")){$().setPlatform("browser",new f0);try{pn.registerManager(nu.URL_SCHEME,new dI)}catch{}try{pn.registerManager(tu.URL_SCHEME,new mI)}catch{}}var gq={importFetch:()=>h0()},fI;var b0=class{constructor(){this.util=g0(),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return $().global.fetch!=null?$().global.fetch(e,t):(fI==null&&(fI=gq.importFetch()),fI(e,t))}now(){let e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}};$().get("IS_NODE")&&$().setPlatform("node",new b0);function Ce(r,e="float32",t){return e=e||"float32",md(r),new yt(r,e,t)}function bq(r,e){let t=v(r,"x","cast");if(!Uk(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:t},o={dtype:e};return N.runKernel(Kn,n,o)}var J=_({cast_:bq});function yq(r){let t={x:v(r,"x","clone","string_or_numeric")};return N.runKernel(jn,t)}var Nn=_({clone_:yq});function hI(r,e=!1){console.log(r.toString(e))}oI();var xq={buffer:Ce,cast:J,clone:Nn,print:hI};$D(xq);var Kr={};Xe(Kr,{browserFiles:()=>T0,browserHTTPRequest:()=>C0,concatenateArrayBuffers:()=>Lc,copyModel:()=>m0,decodeWeights:()=>yb,encodeWeights:()=>XD,fromMemory:()=>S0,getLoadHandlers:()=>r0,getModelArtifactsForJSON:()=>Bc,getModelArtifactsInfoForJSON:()=>si,getSaveHandlers:()=>t0,http:()=>vb,isHTTPScheme:()=>Cb,listModels:()=>p0,loadWeights:()=>k0,moveModel:()=>d0,registerLoadRouter:()=>e0,registerSaveRouter:()=>JD,removeModel:()=>c0,weightsLoaderFactory:()=>yI,withSaveHandler:()=>w0});var Tq="model",kq=".json",Iq=".weights.bin";function y0(r){return new Promise(e=>setTimeout(e)).then(r)}var kb=class{constructor(e){if(!$().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(kb.URL_SCHEME)&&(e=e.slice(kb.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Tq),this.modelJsonFileName=e+kq,this.weightDataFileName=e+Iq}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=xb(e,n),s=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=s,await y0(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){let a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await y0(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:si(e)}}}},Sd=kb;Sd.URL_SCHEME="downloads://";var x0=class{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{let n=new FileReader;n.onload=o=>{let s=JSON.parse(o.target.result),i=s.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}let u=Bc(s,l=>this.loadWeights(l));e(u)},n.onerror=o=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){let t=[],n=[];for(let i of e)t.push(...i.weights),n.push(...i.paths);let o=this.checkManifestAndWeightFiles(e),s=n.map(i=>this.loadWeightsFile(i,o[i]));return Promise.all(s).then(i=>[t,Lc(i)])}loadWeightsFile(e,t){return new Promise((n,o)=>{let s=new FileReader;s.onload=i=>{let a=i.target.result;n(a)},s.onerror=i=>o(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){let t=[],n=this.weightsFiles.map(s=>uI(s.name)),o={};for(let s of e)s.paths.forEach(i=>{let a=uI(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),n.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);o[i]=this.weightsFiles[n.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return o}},Cq=r=>$().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(Sd.URL_SCHEME)?vq(r.slice(Sd.URL_SCHEME.length)):null;Et.registerSaveRouter(Cq);function vq(r="model"){return new Sd(r)}function T0(r){return new x0(r)}function gI(r,e,t,n){i(r),t=t??0,n=n??1,a(t,n);let o=0,s=u=>(u.then(l=>{let p=t+ ++o/r.length*(n-t);return e(p),l}),u);function i(u){D(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){D(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),D(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),D(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(r.map(s))}async function bI(r,e){e==null&&(e={});let t=e.fetchFunc==null?$().platform.fetch:e.fetchFunc,n=r.map(c=>t(c,e.requestInit,{isBinary:!0})),o=0,s=.5,a=(e.onProgress==null?await Promise.all(n):await gI(n,e.onProgress,o,s)).map(c=>c.arrayBuffer()),u=.5,l=1;return e.onProgress==null?await Promise.all(a):await gI(a,e.onProgress,u,l)}async function k0(r,e="",t,n){return yI(i=>bI(i,{requestInit:n}))(r,e,t)}function yI(r){return async(e,t="",n)=>{let o=e.map(()=>!1),s={},i=n!=null?n.map(()=>!1):[],a=[];if(e.forEach((d,f)=>{let h=0;d.weights.forEach(g=>{let x="quantization"in g?g.quantization.dtype:g.dtype,y=vd[x]*nt(g.shape),T=()=>{o[f]=!0,s[f]==null&&(s[f]=[]),s[f].push({manifestEntry:g,groupOffset:h,sizeBytes:y})};n!=null?n.forEach((k,C)=>{k===g.name&&(T(),i[C]=!0)}):T(),a.push(g.name),h+=y})}),!i.every(d=>d)){let d=n.filter((f,h)=>!i[h]);throw new Error(`Could not find weights in manifest with names: ${d.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}let u=o.reduce((d,f,h)=>(f&&d.push(h),d),[]),l=[];u.forEach(d=>{e[d].paths.forEach(f=>{let h=t+(t.endsWith("/")?"":"/")+f;l.push(h)})});let p=await r(l),c={},m=0;return u.forEach(d=>{let f=e[d].paths.length,h=0;for(let k=0;k<f;k++)h+=p[m+k].byteLength;let g=new ArrayBuffer(h),x=new Uint8Array(g),y=0;for(let k=0;k<f;k++){let C=new Uint8Array(p[m+k]);x.set(C,y),y+=C.byteLength}s[d].forEach(k=>{let C=g.slice(k.groupOffset,k.groupOffset+k.sizeBytes),A=yb(C,[k.manifestEntry]);for(let M in A)c[M]=A[M]}),m+=f}),c}}var Sq="application/octet-stream",wq="application/json",Ib=class{constructor(e,t){this.DEFAULT_METHOD="POST";if(t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(D(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=$().platform.fetch,D(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&D(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o=xb(e,n);t.body.append("model.json",new Blob([JSON.stringify(o)],{type:wq}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Sq}),"model.weights.bin");let s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:si(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){let e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}let n=t.modelTopology,o=t.weightsManifest;if(n==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return Bc(t,s=>this.loadWeights(s))}async loadWeights(e){let t=Array.isArray(this.path)?this.path[1]:this.path,[n,o]=_q(t),s=this.weightPathPrefix||n,i=[];for(let p of e)i.push(...p.weights);let a=[],u=[];for(let p of e)for(let c of p.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(c)):a.push(s+c+o);this.weightUrlConverter&&a.push(...await Promise.all(u));let l=await bI(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[i,Lc(l)]}};Ib.URL_SCHEME_REGEX=/^https?:\/\//;function _q(r){let e=r.lastIndexOf("/"),t=r.lastIndexOf("?"),n=r.substring(0,e),o=t>e?r.substring(t):"";return[n+"/",o]}function Cb(r){return r.match(Ib.URL_SCHEME_REGEX)!=null}var I0=(r,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(r)?t=r.every(n=>Cb(n)):t=Cb(r),t)return vb(r,e)}return null};Et.registerSaveRouter(I0);Et.registerLoadRouter(I0);function vb(r,e){return new Ib(r,e)}function C0(r,e){return vb(r,e)}var Sb=class{constructor(e){this.modelArtifacts=e}async load(){return this.modelArtifacts}},v0=class{constructor(e){this.saveHandler=e}async save(e){return this.saveHandler(e)}};function S0(r,e,t,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new Sb(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Sb({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Sb({modelTopology:r,weightSpecs:e,weightData:t,trainingConfig:n}))}function w0(r){return new v0(r)}var A0={};Xe(A0,{confusionMatrix:()=>_0});function Aq(r,e,t=!1,n=!1){let o=v(r,"a","matMul"),s=v(e,"b","matMul");[o,s]=Qe(o,s);let i={a:o,b:s},a={transposeA:t,transposeB:n};return N.runKernel(io,i,a)}var Ve=_({matMul_:Aq});function Nq(r,e,t=1,n=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);let s={indices:v(r,"indices","oneHot","int32")},i={depth:e,onValue:t,offValue:n};return N.runKernel(ha,s,i)}var ou=_({oneHot_:Nq});function Dq(r,e){let t=v(r,"x","transpose");if(e==null&&(e=t.shape.map((s,i)=>i).reverse()),D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(s=>{D(s>=0&&s<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();let n={x:t},o={perm:e};return N.runKernel(Ho,n,o)}var He=_({transpose_:Dq});function Pq(r,e,t){let n=v(r,"labels","confusionMatrix"),o=v(e,"predictions","confusionMatrix");D(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),D(n.rank===1,()=>`Expected the rank of labels to be 1, but got ${n.rank}`),D(o.rank===1,()=>`Expected the rank of predictions to be 1, but got ${o.rank}`),D(n.shape[0]===o.shape[0],()=>`Mismatch in the number of examples: ${n.shape[0]} vs. ${o.shape[0]}. Labels and predictions should have the same number of elements.`),D(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);let s=ou(J(n,"int32"),t),i=ou(J(o,"int32"),t),a=He(s),u=Ve(a,i);return J(u,"int32")}var _0=_({confusionMatrix_:Pq});var Ar={};Xe(Ar,{assertAndGetBroadcastShape:()=>Ge,getBroadcastDims:()=>N0,getReductionAxes:()=>vt});function N0(r,e){let t=r.length,n=[];for(let o=0;o<t;o++){let s=t-1-o,i=r[s]||1;(e[e.length-1-o]||1)>1&&i===1&&n.unshift(s)}return n}function vt(r,e){let t=[];for(let n=0;n<e.length;n++){let o=r[r.length-n-1],s=e.length-n-1,i=e[s];(o==null||o===1&&i>1)&&t.unshift(s)}return t}function Ge(r,e){let t=[],n=Math.max(r.length,e.length);for(let o=0;o<n;o++){let s=r[r.length-o-1];s==null&&(s=1);let i=e[e.length-o-1];if(i==null&&(i=1),s===1)t.unshift(i);else if(i===1)t.unshift(s);else if(s!==i){let a=`Operands could not be broadcast together with shapes ${r} and ${e}.`;throw Error(a)}else t.unshift(s)}return t}var wb={};Xe(wb,{fromPixels:()=>$q,fromPixelsAsync:()=>Lq,toPixels:()=>Bq});function xI(r,e,t){if(no(r),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=Wr(r,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return ln(r,e,n,t)}var Bl;function D0(r,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,o=!1,s=!1,i=!1,a=!1;if(r.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)o=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)s=!0;else if(r.getContext!=null)i=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(o){let f=2;if(o&&r.readyState<f)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(yd(Dl,N.backendName)!=null){let f={pixels:r},h={numChannels:e};return N.runKernel(Dl,f,h)}let[l,p]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],c;if(i)c=r.getContext("2d").getImageData(0,0,l,p).data;else if(n||t)c=r.data;else if(s||o||a){if(Bl==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Bl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Bl=document.createElement("canvas").getContext("2d");Bl.canvas.width=l,Bl.canvas.height=p,Bl.drawImage(r,0,0,l,p),c=Bl.getImageData(0,0,l,p).data}let m;if(e===4)m=new Int32Array(c);else{let f=l*p;m=new Int32Array(f*e);for(let h=0;h<f;h++)for(let g=0;g<e;++g)m[h*e+g]=c[h*4+g]}return xI(m,[p,l,e],"int32")}function Mq(r){return r!=null&&r.data instanceof Uint8Array}function Fq(){return typeof window!="undefined"&&typeof ImageBitmap!="undefined"&&window.hasOwnProperty("createImageBitmap")}function Eq(r){return r!=null&&r.width!==0&&r.height!==0}function Rq(r){return Fq()&&!(r instanceof ImageBitmap)&&Eq(r)&&!Mq(r)}async function Lq(r,e=3){let t=null;if($().getBool("WRAP_TO_IMAGEBITMAP")&&Rq(r)){let n;try{n=await createImageBitmap(r,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===r.width&&n.height===r.height?t=n:t=r}else t=r;return D0(t,e)}async function Bq(r,e){let t=v(r,"img","toPixels");if(!(r instanceof Ye)){let l=t;t=J(l,"int32"),l.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);let[n,o]=t.shape.slice(0,2),s=t.rank===2?1:t.shape[2];if(s>4||s===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${s}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);let i=await t.data(),a=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(o*n*4);for(let l=0;l<n*o;++l){let p=[0,0,0,255];for(let m=0;m<s;m++){let d=i[l*s+m];if(t.dtype==="float32"){if(d<0||d>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${d}.`)}else if(t.dtype==="int32"&&(d<0||d>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${d}.`);s===1?(p[0]=d*a,p[1]=d*a,p[2]=d*a):p[m]=d*a}let c=l*4;u[c+0]=Math.round(p[0]),u[c+1]=Math.round(p[1]),u[c+2]=Math.round(p[2]),u[c+3]=Math.round(p[3])}if(e!=null){e.width=o,e.height=n;let l=e.getContext("2d"),p=new ImageData(u,o,n);l.putImageData(p,0,0)}return t!==r&&t.dispose(),u}var $q=_({fromPixels_:D0});var _b={};Xe(_b,{prepareAndValidate:()=>P0});function P0(r,e){let t=r.shape.length,n=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[n-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[n-1]} vs. ${t}`);if(nt(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let o=e.shape,s=o[o.length-1],i=1;for(let c=0;c<o.length-1;++c)i*=o[c];let a=r.shape,u=o.slice();u.pop();let l=1;for(let c=s;c<t;++c)l*=a[c],u.push(a[c]);let p=[...Ya(r.shape).map(c=>c/l),1].slice(0,s);return[u,i,l,p]}var wd={};Xe(wd,{calculateShapes:()=>M0,validateInput:()=>Ab,validateUpdateShape:()=>TI});function TI(r,e,t){let n=e.rank>1?e.shape[e.rank-1]:1,o=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${o}.`;if(t.rank<o)throw new Error(s+` update.rank < ${o}. `);if(r.length<n+(t.rank-o))throw new Error(s+` Output shape length < ${n+(t.rank-o)}`);if(t.rank!==o+r.length-n)throw new Error(s+` update.rank != ${o+r.length-n}`);for(let i=0;i<o;++i)if(t.shape[i]!==e.shape[i])throw new Error(s+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-o;++i)if(t.shape[i+o]!==r[i+n])throw new Error(s+` updates.shape[${i+o}] (${t.shape[i+o]}) != shape[${i+o}] (${r[i+o]})`)}function Ab(r,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}TI(t,e,r)}function M0(r,e,t){let n=e.shape.length,o=n>1?e.shape[n-1]:1,s=t.length,i=1;for(let c=o;c<s;++c)i*=t[c];let a=o<1?1:o,u=nt(e.shape)/a,l=[...Ya(t.slice(0,o)),1],p=nt(t);return{sliceRank:o,numUpdates:u,sliceSize:i,strides:l,outputSize:p}}var Tt={};Xe(Tt,{assertParamsValid:()=>zq,computeFlatOffset:()=>Vq,computeOutShape:()=>Uq,getNormalizedAxes:()=>Wq,isSliceContinous:()=>Kq,maskToAxes:()=>Gq,parseSliceParams:()=>II,sliceInfo:()=>jq,startForAxis:()=>O0,startIndicesWithElidedDims:()=>L0,stopForAxis:()=>z0,stopIndicesWithElidedDims:()=>B0,stridesForAxis:()=>$0,stridesWithElidedDims:()=>F0});var kI=-2,Oq=-1;function zq(r,e,t){let n=r.shape.length;D(n===e.length,()=>`Error in slice${n}D: Length of begin ${e} must match the rank of the array (${n}).`),D(n===t.length,()=>`Error in slice${n}D: Length of size ${t} must match the rank of the array (${n}).`);for(let o=0;o<n;++o)D(e[o]+t[o]<=r.shape[o],()=>`Error in slice${n}D: begin[${o}] + size[${o}] (${e[o]+t[o]}) would overflow input.shape[${o}] (${r.shape[o]})`)}function Gq(r){let e=[],t=0;for(;r>0;)r&1&&e.push(t),r/=2,t++;return e}function Uq(r,e,t){let n=[];for(let o=0;o<r.length;o++)n[o]=Math.ceil((e[o]-r[o])/t[o]);return n}function F0(r,e,t,n){let o=[...r];for(let s=o.length;s<n.length;s++)o.push(1);for(let s=0;s<t;s++)s===0?o[e]=1:(o.splice(e,0,1),o.pop());return o}function E0(r,e,t){return t<=r?t:t-(e-1)}function R0(r,e){let t=[];for(let n=0;n<r;n++)t.push(e+n);return t}function Wq(r,e,t,n,o,s,i,a,u){let l=r.length,p=new Array(l),c=new Array(l),m=new Array(l);if(e.length&&t>0){let d=e[0],f=t+1;p=L0(i,d,f,n,r),c=B0(a,d,f,o,r),m=F0(s,d,f,r)}else for(let d=0;d<l;d++)p[d]=O0(i,n,s,r,d,u),c[d]=z0(a,o,s,r,d,u),m[d]=$0(s,d,u);return{begin:p,end:c,strides:m}}function L0(r,e,t,n,o){let s=[...o],i=R0(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=0;else{let u=E0(e,t,a),l=n[u];r&1<<u&&(l=0),s[a]=l}return s}function B0(r,e,t,n,o){let s=[...o],i=R0(t,e);for(let a=0;a<s.length;a++)if(i.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{let u=E0(e,t,a),l=n[u];r&1<<u&&(l=Number.MAX_SAFE_INTEGER),s[a]=l}for(let a=0;a<s.length;a++){let u=o[a];s[a]<0&&(s[a]+=u),s[a]=tc(0,s[a],o[a])}return s}function $0(r,e,t){let n=r[e];return(t&1<<e||n==null)&&(n=1),n}function O0(r,e,t,n,o,s){let i=e[o],a=t[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MIN_SAFE_INTEGER:i=Number.MAX_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),i=tc(0,i,u-1),i}function z0(r,e,t,n,o,s){let i=e[o],a=t[o]||1;(r&1<<o||s&1<<o||i==null)&&(a>0?i=Number.MAX_SAFE_INTEGER:i=Number.MIN_SAFE_INTEGER);let u=n[o];return i<0&&(i+=u),a>0?i=tc(0,i,u):i=tc(-1,i,u-1),i}function Kq(r,e,t){let n=t.length;for(let o=0;o<t.length;o++)if(t[o]>1){n=o;break}for(let o=n+1;o<t.length;o++)if(e[o]>0||t[o]!==r[o])return!1;return!0}function Vq(r,e){let t=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)t+=r[n]*e[n];return t}function II(r,e,t){let n,o=r.shape.length;typeof e=="number"?n=[e,...new Array(o-1).fill(0)]:e.length<o?n=e.concat(new Array(o-e.length).fill(0)):n=e.slice(),n.forEach(i=>{D(i!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(o).fill(-1):typeof t=="number"?s=[t,...new Array(o-1).fill(-1)]:t.length<o?s=t.concat(new Array(o-t.length).fill(-1)):s=t,s=s.map((i,a)=>i>=0?i:(D(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),r.shape[a]-n[a])),[n,s]}function jq(r,e,t,n,o,s,i,a,u){let l;if(n==null?(l=new Array(e.length),l.fill(1)):l=n,i!=null&&(i&i-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let p=!1,c={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let T=0;T<c.dims;T++)p&&(1<<T&a)!=0&&c.numAddAxisAfterEllipsis++,1<<T&i&&(p=!0);p||(c.ellipsisMask|=1<<c.dims,c.dims++);let m={dims:r.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};Hq(c,m);let d=!0,f=!0,h=!0,g=[],x=[];for(let T=0;T<r.length;++T){if(m.strides[T]===0)throw Error(`strides[${T}] must be non-zero`);let k=!!(m.shrinkAxisMask&1<<T),C=r[T];if(C===-1){g.push(k?1:-1);continue}let A=[m.beginMask&1<<T,m.endMask&1<<T],M=[m.strides[T]>0?0:-1,m.strides[T]>0?C:C-1];if(k&&m.strides[T]<=0)throw Error("only stride 1 allowed on non-range indexing.");h=h&&m.strides[T]===1;let P=!!(m.beginMask&1<<T&&m.endMask&1<<T);if(m.beginValid&&m.endValid){if(k){let W=m.begin[T]<0?C+m.begin[T]:m.begin[T];if(m.begin[T]=W,m.end[T]=m.begin[T]+1,W<0||W>=C)throw Error(`slice index ${m.begin[T]} of dimension ${T} out of bounds.`)}else m.begin[T]=G0(m.begin[T],0,m.strides[T],C,A,M),m.end[T]=G0(m.end[T],1,m.strides[T],C,A,M);let U=m.strides[T]===1&&m.begin[T]===0&&m.end[T]===C;d=d&&U,f=f&&(T===0&&m.strides[T]===1||U)}else d=d&&m.strides[T]===1&&P,f=f&&(T===0&&m.strides[T]===1||P);let F,B=!1;if(m.beginValid&&m.endValid?(F=m.end[T]-m.begin[T],B=!0):k?(F=1,B=!0):P&&C>=0&&(m.strides[T]<0?F=-C:F=C,B=!0),B){let U;F===0||F<0!=m.strides[T]<0?U=0:U=Math.trunc(F/m.strides[T])+(F%m.strides[T]!=0?1:0),g.push(U)}else g.push(-1)}for(let T=0;T<m.finalShapeGatherIndices.length;++T){let k=m.finalShapeGatherIndices[T];k>=0?x.push(g[k]):k===kI&&x.push(1)}return{finalShapeSparse:x.filter((T,k)=>m.finalShapeGatherIndices[k]!==kI),finalShape:x,isIdentity:d,sliceDim0:f,isSimpleSlice:h,begin:m.begin,end:m.end,strides:m.strides}}function Hq(r,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=r.begin!=null,e.endValid=r.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<r.dims;n++)if(1<<n&r.ellipsisMask){let o=Math.min(e.dims-(r.dims-n)+1+r.numAddAxisAfterEllipsis,e.dims);for(;t<o;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&r.newAxisMask)e.finalShapeGatherIndices.push(kI),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);r.begin!=null&&(e.begin[t]=r.begin[n]),r.end!=null&&(e.end[t]=r.end[n]),e.strides[t]=r.strides[n],r.beginMask&1<<n&&(e.beginMask|=1<<t),r.endMask&1<<n&&(e.endMask|=1<<t),r.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(Oq),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function G0(r,e,t,n,o,s){if(o[e])return t>0?s[e]:s[e+1&1];{let i=r<0?n+r:r;return i<s[0]?s[0]:i>s[1]?s[1]:i}}var re={};Xe(re,{Serializable:()=>Nb,SerializationMap:()=>su,registerClass:()=>Dn});var Nb=class{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}},su=class{constructor(){this.classNameMap={}}static getMap(){return su.instance==null&&(su.instance=new su),su.instance}static register(e){su.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function Dn(r){D(r.className!=null,()=>"Class being registered does not have the static className property defined."),D(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),D(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),su.register(r)}var V0={};Xe(V0,{TEST_EPSILON_FLOAT16:()=>U0,encodeStrings:()=>K0,expectArrayBuffersEqual:()=>Jq,expectArraysClose:()=>Xq,expectArraysEqual:()=>Qq,expectNumbersClose:()=>W0,expectPromiseToFail:()=>Yq,expectValuesInRange:()=>Zq,testEpsilon:()=>Db});var qq=.001,U0=.1;function Xq(r,e,t){return t==null&&(t=Db()),CI(r,e,(n,o)=>vI(n,o,t))}function Db(){return N.backend.floatPrecision()===32?qq:U0}function CI(r,e,t){let n=!0;if((kr(r)||kr(e))&&(n=!1),kr(r)&&kr(e)&&(n=!0),n){let i=r.constructor.name,a=e.constructor.name;if(i!==a)throw new Error(`Arrays are of different type. Actual: ${i}. Expected: ${a}`)}if(Array.isArray(r)&&Array.isArray(e)){let i=Wr(r),a=Wr(e);if(!Wn(i,a))throw new Error(`Arrays have different shapes. Actual: [${i}]. Expected: [${a}]`)}let o=kr(r)?r:Js(r),s=kr(e)?e:Js(e);if(o.length!==s.length)throw new Error(`Arrays have different lengths actual: ${o.length} vs expected: ${s.length}.
Actual:   ${o}.
Expected: ${s}.`);for(let i=0;i<s.length;++i){let a=o[i],u=s[i];if(!t(a,u))throw new Error(`Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${u}.
Actual:   ${o}.
Expected: ${s}.`)}}function Yq(r,e){r().then(()=>e.fail(),()=>e())}function Qq(r,e){let t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return ea(r)||ea(r[0])||ea(e)||ea(e[0])?CI(r,t,(n,o)=>n==o):CI(r,e,(n,o)=>vI(n,o,0))}function W0(r,e,t){if(t==null&&(t=Db()),!vI(r,e,t))throw new Error(`Numbers differ: actual === ${r}, expected === ${e}`)}function vI(r,e,t){return!isFinite(r)&&!isFinite(e)?!0:!(isNaN(r)||isNaN(e)||Math.abs(r-e)>t)}function Zq(r,e,t){for(let n=0;n<r.length;n++)if(r[n]<e||r[n]>t)throw new Error(`Value out of range:${r[n]} low: ${e}, high: ${t}`)}function Jq(r,e){expect(new Float32Array(r)).toEqual(new Float32Array(e))}function K0(r){for(let e=0;e<r.length;e++){let t=r[e];Array.isArray(t)?K0(t):r[e]=Qu(t)}return r}var e6="0.0.0";function Tye(){$().set("PROD",!0)}function kye(){$().set("DEBUG",!0)}function Iye(){$().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function SI(r){$().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}OD(SI);function Cye(){N.disposeVariables()}function qo(){return N}function _d(){return N.memory()}function vye(r){return N.profile(r)}function G(r,e){return N.tidy(r,e)}function Fe(r){Cd(r).forEach(t=>t.dispose())}function Vt(r){return N.keep(r)}function Sye(r){return N.time(r)}function t6(r){return N.setBackend(r)}function wye(){return N.ready()}function _ye(){return N.backendName}function Aye(r){N.removeBackend(r)}function Nye(r){return N.findBackend(r)}function Dye(r){return N.findBackendFactory(r)}function el(r,e,t=1){return N.registerBackend(r,e,t)}function j0(){return N.backend}function Pye(r,e){$().setPlatform(r,e)}function r6(r,e){let t=v(r,"a","add"),n=v(e,"b","add");[t,n]=Qe(t,n);let o={a:t,b:n};return N.runKernel(_n,o)}var X=_({add_:r6});function n6(r,e){let t=v(r,"a","floorDiv"),n=v(e,"b","floorDiv");[t,n]=Qe(t,n);let o={a:t,b:n};return N.runKernel(xo,o)}var Ad=_({floorDiv_:n6});function o6(r,e){let t=v(r,"a","div"),n=v(e,"b","div");if([t,n]=Qe(t,n),t.dtype==="int32"&&n.dtype==="int32")return Ad(t,n);let o={a:t,b:n},s={};return N.runKernel(ho,o,s)}var ce=_({div_:o6});function s6(r,e){let t=v(r,"a","mul"),n=v(e,"b","mul");[t,n]=Qe(t,n);let o={a:t,b:n};return N.runKernel(Po,o)}var R=_({mul_:s6});function a6(r){let e=v(r,"x","abs");if(e.dtype==="complex64"){let t={x:e};return N.runKernel(Lu,t)}else{let t={x:e};return N.runKernel(ms,t)}}var $t=_({abs_:a6});function i6(r){let t={x:v(r,"x","acos")};return N.runKernel(Di,t)}var wI=_({acos_:i6});function u6(r){let t={x:v(r,"x","acosh")};return N.runKernel(Pi,t)}var _I=_({acosh_:u6});function l6(r){D(Array.isArray(r),()=>"The argument passed to tf.addN() must be a list of tensors"),D(r.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${r.length}`);let e=r.map((o,s)=>v(o,`tensors${s}`,"addN")),t=e[0];e.forEach(o=>{if(o.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(o=>{if(!Wn(o.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});let n=e;return N.runKernel(oo,n)}var AI=_({addN_:l6});function p6(r,e=null,t=!1){let o={x:v(r,"x","all","bool")},s={axis:e,keepDims:t};return N.runKernel(Mi,o,s)}var Nd=_({all_:p6});function c6(r,e=null,t=!1){let o={x:v(r,"x","any","bool")},s={axis:e,keepDims:t};return N.runKernel(Fi,o,s)}var zc=_({any_:c6});function m6(r,e=0){let n={x:v(r,"x","argMax")},o={axis:e};return N.runKernel(so,n,o)}var au=_({argMax_:m6});function d6(r,e=0){let n={x:v(r,"x","argMin")},o={axis:e};return N.runKernel(Qa,n,o)}var NI=_({argMin_:d6});function f6(r){let t={x:v(r,"x","asin")};return N.runKernel(Ei,t)}var DI=_({asin_:f6});function h6(r){let t={x:v(r,"x","asinh")};return N.runKernel(Ri,t)}var PI=_({asinh_:h6});function g6(r){let t={x:v(r,"x","atan")};return N.runKernel(Li,t)}var MI=_({atan_:g6});function b6(r,e){let t=v(r,"a","atan2"),n=v(e,"b","atan2");[t,n]=Qe(t,n);let o={a:t,b:n};return N.runKernel($i,o)}var FI=_({atan2_:b6});function y6(r){let t={x:v(r,"x","atanh")};return N.runKernel(Bi,t)}var EI=_({atanh_:y6});function x6(r,e,t,n,o="NHWC",s){let i=r[3],a=[...e,i],u=q0(o);return $l(r,a,t,s,n,null,null,u)}function RI(r,e,t,n,o,s,i="channelsLast"){let[a,u]=Pb(e),l;if(i==="channelsLast")l=[a,u,r[3],r[3]];else if(i==="channelsFirst")l=[a,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return $l(r,l,t,n,o,s,!1,i)}function T6(r,e,t,n,o,s,i="NDHWC"){let[a,u,l]=BI(e),p,c;if(i==="NDHWC")c="channelsLast",p=[a,u,l,r[4],r[4]];else if(i==="NCDHW")c="channelsFirst",p=[a,u,l,r[1],r[1]];else throw new Error(`Unknown dataFormat ${i}`);return H0(r,p,t,n,o,!1,c,s)}function $l(r,e,t,n,o,s,i=!1,a="channelsLast"){let[u,l,p,c]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,p,c]=r;else if(a==="channelsFirst")[u,c,l,p]=r;else throw new Error(`Unknown dataFormat ${a}`);let[m,d,,f]=e,[h,g]=Pb(t),[x,y]=Pb(n),T=Gc(m,x),k=Gc(d,y),{padInfo:C,outHeight:A,outWidth:M}=C6(o,l,p,h,g,T,k,s,a),P=i?f*c:f,F;return a==="channelsFirst"?F=[u,P,A,M]:a==="channelsLast"&&(F=[u,A,M,P]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:p,inChannels:c,outHeight:A,outWidth:M,outChannels:P,padInfo:C,strideHeight:h,strideWidth:g,filterHeight:m,filterWidth:d,effectiveFilterHeight:T,effectiveFilterWidth:k,dilationHeight:x,dilationWidth:y,inShape:r,outShape:F,filterShape:e}}function H0(r,e,t,n,o,s=!1,i="channelsLast",a){let[u,l,p,c,m]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,p,c,m]=r;else if(i==="channelsFirst")[u,m,l,p,c]=r;else throw new Error(`Unknown dataFormat ${i}`);let[d,f,h,,g]=e,[x,y,T]=BI(t),[k,C,A]=BI(n),M=Gc(d,k),P=Gc(f,C),F=Gc(h,A),{padInfo:B,outDepth:U,outHeight:W,outWidth:K}=v6(o,l,p,c,x,y,T,M,P,F,a),j=s?g*m:g,V;return i==="channelsFirst"?V=[u,j,U,W,K]:i==="channelsLast"&&(V=[u,U,W,K,j]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:p,inWidth:c,inChannels:m,outDepth:U,outHeight:W,outWidth:K,outChannels:j,padInfo:B,strideDepth:x,strideHeight:y,strideWidth:T,filterDepth:d,filterHeight:f,filterWidth:h,effectiveFilterDepth:M,effectiveFilterHeight:P,effectiveFilterWidth:F,dilationDepth:k,dilationHeight:C,dilationWidth:A,inShape:r,outShape:V,filterShape:e}}function k6(r,e,t,n,o){n==null&&(n=LI(r,e,t));let s=r[0],i=r[1],a=Ol((s-e+2*n)/t+1,o),u=Ol((i-e+2*n)/t+1,o);return[a,u]}function I6(r,e,t,n,o,s){o==null&&(o=LI(r,e,n));let i=r[0],a=r[1],u=r[2],l=Ol((i-e+2*o)/n+1,s),p=Ol((a-e+2*o)/n+1,s),c=Ol((u-e+2*o)/n+1,s);return[l,p,c,t]}function LI(r,e,t,n=1){let o=Gc(e,n);return Math.floor((r[0]*(t-1)-t+o)/2)}function Pb(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function BI(r){return typeof r=="number"?[r,r,r]:r}function Gc(r,e){return e<=1?r:r+(r-1)*(e-1)}function C6(r,e,t,n,o,s,i,a,u){let l,p,c;if(typeof r=="number"){l={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let d=k6([e,t],s,n,r,a);p=d[0],c=d[1]}else if(r==="same"){p=Math.ceil(e/n),c=Math.ceil(t/o);let m=Math.max(0,(p-1)*n+s-e),d=Math.max(0,(c-1)*o+i-t),f=Math.floor(m/2),h=m-f,g=Math.floor(d/2),x=d-g;l={top:f,bottom:h,left:g,right:x,type:"SAME"}}else if(r==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},p=Math.ceil((e-s+1)/n),c=Math.ceil((t-i+1)/o);else if(typeof r=="object"){let m=u==="channelsLast"?r[1][0]:r[2][0],d=u==="channelsLast"?r[1][1]:r[2][1],f=u==="channelsLast"?r[2][0]:r[3][0],h=u==="channelsLast"?r[2][1]:r[3][1];l={top:m,bottom:d,left:f,right:h,type:m===0&&d===0&&f===0&&h===0?"VALID":"EXPLICIT"},p=Ol((e-s+m+d)/n+1,a),c=Ol((t-i+f+h)/o+1,a)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:l,outHeight:p,outWidth:c}}function v6(r,e,t,n,o,s,i,a,u,l,p){let c,m,d,f;if(typeof r=="number"){c={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let g=I6([e,t,n,1],a,1,o,r,p);m=g[0],d=g[1],f=g[2]}else if(r==="same"){m=Math.ceil(e/o),d=Math.ceil(t/s),f=Math.ceil(n/i);let h=(m-1)*o+a-e,g=(d-1)*s+u-t,x=(f-1)*i+l-n,y=Math.floor(h/2),T=h-y,k=Math.floor(g/2),C=g-k,A=Math.floor(x/2),M=x-A;c={top:k,bottom:C,left:A,right:M,front:y,back:T,type:"SAME"}}else if(r==="valid")c={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},m=Math.ceil((e-a+1)/o),d=Math.ceil((t-u+1)/s),f=Math.ceil((n-l+1)/i);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:c,outDepth:m,outHeight:d,outWidth:f}}function Ol(r,e){if(!e)return Math.trunc(r);switch(e){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${e}`)}}function Xo(r){let[e,t,n]=Pb(r);return e===1&&t===1&&n===1}function Lr(r,e){return Xo(r)||Xo(e)}function q0(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function Pt(r,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")D(Ni(e),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(n=>{n.forEach(o=>{D(Ni(o),()=>`Error in ${r}: pad must be an integer when using dimRoundingMode ${t} but got pad ${o}.`)})});else throw Error(`Error in ${r}: Unknown padding parameter: ${e}`)}}function S6(r,e){let n={x:v(r,"x","reshape","string_or_numeric")},o={shape:e};return N.runKernel(Ts,n,o)}var L=_({reshape_:S6});function w6(r,e,t,n,o){let s=v(r,"x","avgPool","float32"),i=1;D(Lr(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=s,u=!1;s.rank===3&&(u=!0,a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Pt("avgPool",n,o);let l={x:a},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},c=N.runKernel(ao,l,p);return c=J(c,s.dtype),u?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var zl=_({avgPool_:w6});function _6(r,e,t,n,o,s="NDHWC"){let i=v(r,"x","avgPool3d","float32"),a=i,u=!1;i.rank===4&&(u=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Pt("avgPool3d",n,o);let l={x:a},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},c=N.runKernel(Eu,l,p);return c=J(c,a.dtype),u?L(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Dd=_({avgPool3d_:_6});function A6(r,e=0){D(r.length>=1,()=>"Pass at least one tensor to concat");let t=eu(r,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return Nn(t[0]);let n=t,o={axis:e};return N.runKernel(fs,n,o)}var lt=_({concat_:A6});function N6(r){let t={x:v(r,"x","sigmoid","float32")};return N.runKernel(zo,t)}var cn=_({sigmoid_:N6});function D6(r,e,t){let n=v(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let o={x:n},s={begin:e,size:t};return N.runKernel(Is,o,s)}var ze=_({slice_:D6});function P6(r){let t={x:v(r,"x","tanh","float32")};return N.runKernel(jo,t)}var iu=_({tanh_:P6});function M6(r,e,t,n,o,s){let i=v(r,"forgetBias","basicLSTMCell"),a=v(e,"lstmKernel","basicLSTMCell"),u=v(t,"lstmBias","basicLSTMCell"),l=v(n,"data","basicLSTMCell"),p=v(o,"c","basicLSTMCell"),c=v(s,"h","basicLSTMCell"),m=lt([l,c],1),d=Ve(m,a),f=X(d,u),h=f.shape[0],g=f.shape[1]/4,x=[h,g],y=ze(f,[0,0],x),T=ze(f,[0,g],x),k=ze(f,[0,g*2],x),C=ze(f,[0,g*3],x),A=X(R(cn(y),iu(T)),R(p,cn(X(i,k)))),M=R(iu(A),cn(C));return[A,M]}var F6=_({basicLSTMCell_:M6});function E6(r,e,t){let n=v(r,"x","batchToSpaceND"),o=e.reduce((a,u)=>a*u);D(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),D(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),D(n.shape[0]%o==0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);let s={x:n},i={blockShape:e,crops:t};return N.runKernel(ds,s,i)}var Gl=_({batchToSpaceND_:E6});function X0(r){let e;return r.rank===0||r.rank===1?e=L(r,[1,1,1,r.size]):r.rank===2?e=L(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?e=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]):e=r,e}function R6(r,e,t,n,o,s){s==null&&(s=.001);let i=v(r,"x","batchNorm"),a=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;n!=null&&(p=v(n,"offset","batchNorm")),D(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),D(p==null||a.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),D(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let m={x:X0(i),scale:l,offset:p,mean:a,variance:u},d={varianceEpsilon:s},f=N.runKernel(To,m,d);return L(f,i.shape)}var ai=_({batchNorm_:R6});function L6(r,e,t,n,o,s){let i=v(r,"x","batchNorm"),a=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),D(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),D(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),ai(i,a,u,p,l,s)}var $I=_({batchNorm2d_:L6});function B6(r,e,t,n,o,s){let i=v(r,"x","batchNorm"),a=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),D(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),D(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),ai(i,a,u,p,l,s)}var OI=_({batchNorm3d_:B6});function $6(r,e,t,n,o,s){let i=v(r,"x","batchNorm"),a=v(e,"mean","batchNorm"),u=v(t,"variance","batchNorm"),l;o!=null&&(l=v(o,"scale","batchNorm"));let p;return n!=null&&(p=v(n,"offset","batchNorm")),D(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),D(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),D(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&D(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&D(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),ai(i,a,u,p,l,s)}var zI=_({batchNorm4d_:$6});function O6(r,e,t){let n=v(r,"x","bincount"),o=v(e,"weights","bincount");D(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(o.size===n.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${o.shape}.`);let s={x:n,weights:o},i={size:t};return N.runKernel(ic,s,i)}var Pd=_({bincount_:O6});function z6(r,e){let t=v(r,"s0","broadcastArgs","int32"),n=v(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);let o={s0:t,s1:n};return N.runKernel(uc,o)}var GI=_({broadcastArgs_:z6});function G6(r,e){let t=v(r,"broadcastTo","x"),n=t.shape;if(e.some(l=>!(l>0)||l%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){let l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=L(t,l)}let o=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(o[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${e}].`);if(s.map((l,p)=>l>1?p:-1).filter(l=>l>=0).length===0)return Nn(t);let a={x:t},u={reps:s};return N.runKernel(An,a,u)}var Ul=_({broadcastTo_:G6});function U6(r){let t={x:v(r,"x","ceil","float32")};return N.runKernel(uo,t)}var UI=_({ceil_:U6});function W6(r,e,t){let n=v(r,"x","clipByValue");D(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);let o={x:n},s={clipValueMin:e,clipValueMax:t};return N.runKernel(Vn,o,s)}var Br=_({clipByValue_:W6});function K6(r){return lt(r,0)}var WI=_({concat1d_:K6});function V6(r,e){return lt(r,e)}var KI=_({concat2d_:V6});function j6(r,e){return lt(r,e)}var VI=_({concat3d_:j6});function H6(r,e){return lt(r,e)}var jI=_({concat4d_:H6});function q6(r,e,t,n,o="NHWC",s=[1,1],i){let a=v(r,"x","conv2d","float32"),u=v(e,"filter","conv2d","float32"),l=a,p=!1;a.rank===3&&(p=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Pt("conv2d",n,i);let c=o==="NHWC"?l.shape[3]:l.shape[1];D(c===u.shape[2],()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${u.shape[2]}.`),D(Lr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);let m={x:l,filter:u},d={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},f=N.runKernel(lo,m,d);return p?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Yn=_({conv2d_:q6});function X6(r,e,t,n,o="NWC",s=1,i){let a=v(r,"x","conv1d"),u=v(e,"filter","conv1d"),l=a,p=!1;a.rank===2&&(p=!0,l=L(a,[1,a.shape[0],a.shape[1]])),D(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),D(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Pt("conv1d",n,i),D(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),D(Lr(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),D(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);let c=L(u,[1,u.shape[0],u.shape[1],u.shape[2]]),m=L(l,[l.shape[0],1,l.shape[1],l.shape[2]]),g=Yn(m,c,[1,t],n,"NHWC",[1,s],i);return p?L(g,[g.shape[2],g.shape[3]]):L(g,[g.shape[0],g.shape[2],g.shape[3]])}var Md=_({conv1d_:X6});function Y6(r,e,t,n,o,s="NHWC",i){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let a=r,u=e,l=!1;e.rank===3&&(l=!0,u=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,r[0],r[1],r[2]]),D(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),D(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),D(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);let p=s==="NHWC"?a[3]:a[1],c=s==="NHWC"?u.shape[3]:u.shape[1];D(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),D(c===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[3]}.`),Pt("conv2dDerInput",o,i);let m={dy:u,filter:t},d={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,inputShape:a},f=N.runKernel(po,m,d);return l?L(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var Uc=_({conv2DBackpropInput_:Y6});function Q6(r,e,t,n,o,s){let i=v(r,"x","conv2dTranspose"),a=v(e,"filter","conv2dTranspose");return Uc(t,i,a,n,o,"NHWC",s)}var Fd=_({conv2dTranspose_:Q6});function Z6(r,e,t,n,o="NDHWC",s=[1,1,1]){let i=v(r,"x","conv3d"),a=v(e,"filter","conv3d"),u=i,l=!1;i.rank===4&&(l=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),D(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),D(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),D(Lr(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);let p={x:u,filter:a},c={strides:t,pad:n,dataFormat:o,dilations:s},m=N.runKernel(Bu,p,c);return l?L(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Ed=_({conv3d_:Z6});function J6(r,e,t,n,o){D(r.length===e.rank,()=>`Length of inShape (${r.length}) and rank of dy (${e.rank}) must match`);let s=r,i=e,a=!1;e.rank===4&&(a=!0,i=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,r[0],r[1],r[2],r[3]]);let u=s[4],l=i.shape[4];D(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),D(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),D(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),D(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),D(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);let p={dy:i,filter:t},c={pad:o,strides:n,inputShape:s},m=N.runKernel(cc,p,c);return a?L(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Mb=_({conv3DBackpropInput_:J6});function e5(r,e,t,n,o){let s=v(r,"x","conv3dTranspose"),i=v(e,"filter","conv3dTranspose");return Mb(t,s,i,n,o)}var HI=_({conv3dTranspose_:e5});function t5(r){let t={x:v(r,"x","cos","float32")};return N.runKernel(co,t)}var Wl=_({cos_:t5});function r5(r){let t={x:v(r,"x","cosh","float32")};return N.runKernel(mo,t)}var Rd=_({cosh_:r5});function n5(r,e=0,t=!1,n=!1){let s={x:v(r,"x","cumsum")},i={axis:e,exclusive:t,reverse:n};return N.runKernel(ta,s,i)}var Ld=_({cumsum_:n5});function o5(r,e,t,n=!1){let o=v(r,"x","denseBincount"),s=v(e,"weights","denseBincount");D(o.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${o.dtype}`),D(o.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${o.rank}.`),D(t>=0,()=>`size must be non-negative, but got ${t}.`),D(s.size===o.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${o.shape}, weights shape: ${s.shape}.`);let i={x:o,weights:s},a={size:t,binaryOutput:n};return N.runKernel(mc,i,a)}var qI=_({denseBincount_:o5});function s5(r,e,t="NHWC"){let n=v(r,"x","depthToSpace","float32"),o=t==="NHWC"?n.shape[1]:n.shape[2],s=t==="NHWC"?n.shape[2]:n.shape[3],i=t==="NHWC"?n.shape[3]:n.shape[1];D(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),D(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e}  for depthToSpace with input shape
    ${n.shape}`),D(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${n.shape}`),D(i%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${n.shape}`);let a={x:n},u={blockSize:e,dataFormat:t};return N.runKernel(na,a,u)}var XI=_({depthToSpace_:s5});function a5(r,e,t,n,o="NHWC",s=[1,1],i){let a=v(r,"x","depthwiseConv2d","float32"),u=v(e,"filter","depthwiseConv2d","float32"),l=a,p=!1;a.rank===3&&(p=!0,l=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),D(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),Pt("depthwiseConv2d",n,i);let c={x:l,filter:u},m={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i},d=N.runKernel(fo,c,m);return p?L(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var uu=_({depthwiseConv2d_:a5});function i5(r){let t={x:v(r,"x","diag")};return N.runKernel(hc,t)}var u5=_({diag_:i5});function l5(r,e,t,n,o=[1,1],s="NHWC"){let i=v(r,"x","dilation2d"),a=v(e,"filter","dilation2d");D(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),D(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),D(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let u=i,l=!1;i.rank===3&&(u=L(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0);let p={x:u,filter:a},c={strides:t,pad:n,dilations:o},m=N.runKernel($u,p,c);return l?L(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var YI=_({dilation2d_:l5});function p5(r,e){let t=v(r,"a","equal","string_or_numeric"),n=v(e,"b","equal","string_or_numeric");[t,n]=Qe(t,n),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(oa,o)}var Vr=_({equal_:p5});function c5(r,e,t){let n=v(e,"a","where"),o=v(t,"b","where"),s=v(r,"condition","where","bool"),i=Ge(Ge(s.shape,n.shape),o.shape),a=Ul(s,i),u=Ul(n,i),l=Ul(o,i),p={condition:a,t:u,e:l};return N.runKernel(ks,p)}var Ot=_({where_:c5});function m5(r){let t={x:v(r,"x","zerosLike")};return N.runKernel(ws,t)}var Ne=_({zerosLike_:m5});function d5(r,e){let t=v(r,"a","div"),n=v(e,"b","div");[t,n]=Qe(t,n);let o=ce(t,n),s=Ne(o),i=Vr(n,s);return Ot(i,s,o)}var QI=_({divNoNan_:d5});function f5(r,e){let t=v(r,"t1","dot"),n=v(e,"t2","dot");D((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);let o=t.rank===1?t.size:t.shape[1],s=n.rank===1?n.size:n.shape[0];if(D(o===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${o} and ${s}.`),t.rank===1&&n.rank===1){let i=L(t,[1,-1]),a=L(n,[-1,1]),u=Ve(i,a);return L(u,[])}else if(t.rank===1&&n.rank===2){let i=L(t,[1,-1]),a=L(n,[n.shape[0],n.shape[1]]),u=Ve(i,a);return L(u,[u.size])}else if(t.rank===2&&n.rank===1){let i=L(n,[-1,1]),a=Ve(t,i);return L(a,[a.size])}else{let i=L(n,[n.shape[0],n.shape[1]]);return Ve(t,i)}}var h5=_({dot_:f5});function g5(r,...e){let t=e.map((o,s)=>v(o,`tensors${s}`,"einsum")),n={equation:r};return N.runKernel(Ou,t,n)}var ZI=_({einsum_:g5});function b5(r){let t={x:v(r,"x","elu","float32")};return N.runKernel(go,t)}var lu=_({elu_:b5});function y5(r){let e=v(r,"x","erf");D(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=J(e,"float32"));let t={x:e};return N.runKernel(Oi,t)}var JI=_({erf_:y5});function x5(r){let t={x:v(r,"x","exp")};return N.runKernel(bo,t)}var mr=_({exp_:x5});function T5(r,e=0){let t=v(r,"x","expandDims","string_or_numeric");D(e<=t.rank,()=>"Axis must be <= rank of the tensor");let n={input:t},o={dim:e};return N.runKernel(hs,n,o)}var Nr=_({expandDims_:T5});function k5(r){let t={x:v(r,"x","expm1")};return N.runKernel(sa,t)}var eC=_({expm1_:k5});function I5(r,e){let t=v(r,"x","tile","string_or_numeric");D(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);let n={x:t},o={reps:e};return N.runKernel(An,n,o)}var jr=_({tile_:I5});function C5(r,e,t,n="float32"){e==null&&(e=r);let o=Ce([r,e],n),s=r<=e?r:e;for(let a=0;a<s;++a)o.set(1,a,a);let i=L(o.toTensor(),[r,e]);if(t==null)return i;if(t.length===1)return jr(Nr(i,0),[t[0],1,1]);if(t.length===2)return jr(Nr(Nr(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return jr(Nr(Nr(Nr(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}var Wc=_({eye_:C5});function Aa(r,e,t){let n={shape:r,value:e,dtype:t};return N.runKernel(Za,{},n)}function v5(r){let t={x:v(r,"x","floor","float32")};return N.runKernel(yo,t)}var pu=_({floor_:v5});function S5(r,e,t=0,n=0){let o=v(r,"x","gather"),s=v(e,"indices","gather","int32"),i={x:o,indices:s},a={axis:t,batchDims:n};return N.runKernel(gs,i,a)}var ii=_({gather_:S5});function w5(r,e){let t=v(r,"a","greater","string_or_numeric"),n=v(e,"b","greater","string_or_numeric");[t,n]=Qe(t,n),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(ua,o)}var nr=_({greater_:w5});function _5(r,e){let t=v(r,"a","greaterEqual","string_or_numeric"),n=v(e,"b","greaterEqual","string_or_numeric");[t,n]=Qe(t,n),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(ko,o)}var Qo=_({greaterEqual_:_5});function A5(r){let t={input:v(r,"input","imag")};return N.runKernel(zu,t)}var Kl=_({imag_:A5});function N5(r){let t={x:v(r,"x","isFinite")};return N.runKernel(zi,t)}var D5=_({isFinite_:N5});function P5(r){let t={x:v(r,"x","isInf")};return N.runKernel(Gi,t)}var M5=_({isInf_:P5});function F5(r){let t={x:v(r,"x","isNaN")};return N.runKernel(Ui,t)}var tC=_({isNaN_:F5});function E5(r,e=.2){let n={x:v(r,"x","leakyRelu")},o={alpha:e};return N.runKernel(Io,n,o)}var Vl=_({leakyRelu_:E5});function R5(r,e){let t=v(r,"a","less","string_or_numeric"),n=v(e,"b","less","string_or_numeric");[t,n]=Qe(t,n),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(la,o)}var Bd=_({less_:R5});function L5(r,e){let t=v(r,"a","lessEqual","string_or_numeric"),n=v(e,"b","lessEqual","string_or_numeric");[t,n]=Qe(t,n),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(pa,o)}var Zo=_({lessEqual_:L5});function rC(r,e,t){if(t<=0)throw new Error("The number of values should be positive.");let n={start:r,stop:e,num:t};return N.runKernel(xc,{},n)}function B5(r,e=5,t=1,n=1,o=.5){let s=v(r,"x","localResponseNormalization");D(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),D(Ni(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=s,a=!1;s.rank===3&&(a=!0,i=L(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let u={x:i},l={depthRadius:e,bias:t,alpha:n,beta:o},p=N.runKernel(Gu,u,l);return a?L(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var nC=_({localResponseNormalization_:B5});function $5(r){let t={x:v(r,"x","log","float32")};return N.runKernel(Co,t)}var $r=_({log_:$5});function O5(r){let t={x:v(r,"x","log1p")};return N.runKernel(Wi,t)}var jl=_({log1p_:O5});function z5(r){return D(Xa(r),()=>"The f passed in grad(f) must be a function"),(e,t)=>{let n=v(e,"x","tf.grad","string_or_numeric"),o=t!=null?v(t,"dy","tf.grad"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>r(n),[n],o);return o!=null&&Wt(s.shape,o.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Eb(i),i[0]})}}function G5(r){return D(Xa(r),()=>"The f passed in grads(f) must be a function"),(e,t)=>{D(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");let n=eu(e,"args","tf.grads","string_or_numeric"),o=t!=null?v(t,"dy","tf.grads"):null;return N.tidy(()=>{let{value:s,grads:i}=N.gradients(()=>r(...n),n,o);return o!=null&&Wt(s.shape,o.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Eb(i),i})}}function U5(r){return D(Xa(r),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{D(e instanceof Ye,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),D(t==null||t instanceof Ye,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");let{grads:n,value:o}=N.gradients(()=>r(e),[e],t);return Eb(n),{grad:n[0],value:o}}}function W5(r){return D(Xa(r),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{D(Array.isArray(e)&&e.every(o=>o instanceof Ye),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),D(t==null||t instanceof Ye,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");let n=N.gradients(()=>r(...e),e,t);return t!=null&&Wt(n.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Eb(n.grads),n}}function Fb(r,e){D(Xa(r),()=>"The f passed in variableGrads(f) must be a function"),D(e==null||Array.isArray(e)&&e.every(l=>l instanceof Zu),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let t=e!=null;if(!t){e=[];for(let l in N.registeredVariables)e.push(N.registeredVariables[l])}let n=t?e.filter(l=>!l.trainable):null,o=e.length;e=e.filter(l=>l.trainable),D(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);let s=!0,{value:i,grads:a}=N.gradients(r,e,null,s);D(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),D(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);let u={};return e.forEach((l,p)=>{a[p]!=null&&(u[l.name]=a[p])}),n!=null&&n.forEach(l=>u[l.name]=null),{value:i,grads:u}}function mn(r){return N.customGrad(r)}function Eb(r){if(r.filter(t=>t==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function K5(r){let t={x:v(r,"x","neg")};return N.runKernel(bs,t)}var Ze=_({neg_:K5});function V5(r){let t={x:v(r,"x","softplus")};return N.runKernel(Yi,t)}var ui=_({softplus_:V5});function j5(r){let e=v(r,"x","logSigmoid");return mn(n=>({value:Ze(ui(Ze(n))),gradFunc:i=>R(i,cn(Ze(n)))}))(e)}var H5=_({logSigmoid_:j5});function q5(r,e=null,t=!1){let o={x:v(r,"x","max")},s={reductionIndices:e,keepDims:t};return N.runKernel(vo,o,s)}var en=_({max_:q5});function X5(r,e){let t=v(r,"a","sub"),n=v(e,"b","sub");[t,n]=Qe(t,n);let o={a:t,b:n};return N.runKernel(Vo,o)}var pe=_({sub_:X5});function Y5(r,e=null,t=!1){let n=v(r,"x","sum");n.dtype==="bool"&&(n=J(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(Uo,o,s)}var he=_({sum_:Y5});function Q5(r,e=-1){let t=v(r,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return mn((o,s)=>{let i=!0,a=en(o,e,!0),u=pe(o,a),l=pe(J(u,"float32"),$r(he(mr(u),e,i)));return s([l]),{value:l,gradFunc:(c,m)=>{let[d]=m,f=!0,h=mr(d);return pe(c,R(he(c,e,f),h))}}})(t)}var $d=_({logSoftmax_:Q5});function oC(r,e){for(let t=0;t<r.length;++t)if(r[r.length-t-1]!==e-1-t)return!1;return!0}function Y0(r,e,t){let n=r.length+e.length,o=[],s=0,i=0;for(let a=0;a<n;a++)t.indexOf(a)===-1?o.push(r[s++]):o.push(e[i++]);return o}function sC(r,e){let t=[],n=r.length;for(let s=0;s<n;s++)e.indexOf(s)===-1&&t.push(r[s]);let o=e.map(s=>r[s]);return[t,o]}function Rs(r,e){let t=e.map(n=>1);return Y0(r,t,e)}function Z5(r,e,t){D(oC(e,t),()=>`${r} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function aC(r,e){if(oC(r,e))return null;let t=[];for(let n=0;n<e;++n)r.indexOf(n)===-1&&t.push(n);return r.forEach(n=>t.push(n)),t}function Od(r){return r.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function J5(r,e){let t=[];for(let n=e-r;n<e;++n)t.push(n);return t}function e8(r,e=null,t=!1){let n=v(r,"x","logSumExp"),o=yr(e,n.shape),s=en(n,o,!0),i=pe(n,s),a=mr(i),u=he(a,o),l=$r(u),p=X(L(s,l.shape),l);if(t){let c=Rs(p.shape,o);return L(p,c)}return p}var uC=_({logSumExp_:e8});function t8(r,e){let t=v(r,"a","logicalAnd","bool"),n=v(e,"b","logicalAnd","bool");Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(ca,o)}var Hr=_({logicalAnd_:t8});function r8(r){let t={x:v(r,"x","logicalNot","bool")};return N.runKernel(Ki,t)}var Hl=_({logicalNot_:r8});function n8(r,e){let t=v(r,"a","logicalOr","bool"),n=v(e,"b","logicalOr","bool");Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(Nl,o)}var zd=_({logicalOr_:n8});function o8(r,e){let t=v(r,"a","logicalXor","bool"),n=v(e,"b","logicalXor","bool");return Ge(t.shape,n.shape),Hr(zd(r,e),Hl(Hr(r,e)))}var s8=_({logicalXor_:o8});function a8(r,e,t,n,o){let s=v(r,"x","maxPool"),i=1,a=s,u=!1;s.rank===3&&(u=!0,a=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),D(Lr(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Pt("maxPool",n,o);let l={x:a},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o},c=N.runKernel(wo,l,p);return u?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var ql=_({maxPool_:a8});function i8(r,e=[1,1,1],t,n,o,s="NDHWC"){let i=v(r,"x","maxPool3d"),a=i,u=!1;i.rank===4&&(u=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),D(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),D(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),Pt("maxPool3d",n,o);let l={x:a},p={filterSize:e,strides:t,pad:n,dimRoundingMode:o,dataFormat:s},c=N.runKernel(Uu,l,p);return u?L(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}var Gd=_({maxPool3d_:i8});function u8(r,e,t,n,o=!1){let i={x:v(r,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:n,includeBatchInIndex:o},u=N.runKernel(Cc,i,a);return{result:u[0],indexes:u[1]}}var lC=_({maxPoolWithArgmax_:u8});function l8(r,e){let t=v(r,"a","maximum"),n=v(e,"b","maximum");[t,n]=Qe(t,n),t.dtype==="bool"&&(t=J(t,"int32"),n=J(n,"int32")),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(So,o)}var Qn=_({maximum_:l8});function p8(r,e=null,t=!1){let o={x:v(r,"x","mean")},s={axis:e,keepDims:t};return N.runKernel(_o,o,s)}var Rt=_({mean_:p8});function xt(r,e="float32"){if(e==="complex64"){let n=xt(r,"float32"),o=xt(r,"float32");return Xn(n,o)}let t=oc(nt(r),e);return N.makeTensor(t,r,e)}function dr(r,e="float32"){if(e==="complex64"){let n=dr(r,"float32"),o=xt(r,"float32");return Xn(n,o)}let t=cd(nt(r),e);return N.makeTensor(t,r,e)}function c8(r,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(r===void 0)return[];let n=v(r,"x","meshgrid",r instanceof Ye?r.dtype:"float32");if(e===void 0)return[n];let o=v(e,"y","meshgrid",e instanceof Ye?e.dtype:"float32"),s=nt(n.shape),i=nt(o.shape);return t==="xy"?(n=L(n,[1,-1]),o=L(o,[-1,1]),[Ve(dr([i,1],n.dtype),n),Ve(o,dr([1,s],o.dtype))]):(n=L(n,[-1,1]),o=L(o,[1,-1]),[Ve(n,dr([1,i],n.dtype)),Ve(dr([s,1],o.dtype),o)])}function m8(r,e=null,t=!1){let o={x:v(r,"x","min")},s={axis:e,keepDims:t};return N.runKernel(Ao,o,s)}var Kc=_({min_:m8});function d8(r,e){let t=v(r,"a","minimum"),n=v(e,"b","minimum");[t,n]=Qe(t,n),t.dtype==="bool"&&(t=J(t,"int32"),n=J(n,"int32")),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(No,o)}var cu=_({minimum_:d8});function f8(r,e,t){D(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);let n=v(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");D(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);let o=t==="reflect"?1:0;for(let a=0;a<n.rank;a++)D(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),D(e[a][0]>=0&&e[a][0]<=n.shape[a]-o&&e[a][1]>=0&&e[a][1]<=n.shape[a]-o,()=>`Padding in dimension ${a} cannot be greater than or equal to ${n.shape[a]-o} or less than 0 for input of shape ${n.shape}`);let s={paddings:e,mode:t},i={x:n};return N.runKernel(Do,i,s)}var pC=_({mirrorPad_:f8});function h8(r,e){let t=v(r,"a","mod"),n=v(e,"b","mod");[t,n]=Qe(t,n);let o={a:t,b:n};return N.runKernel(Vi,o)}var cC=_({mod_:h8});function g8(r){let e=v(r,"x","square"),t={};return N.runKernel("Square",{x:e},t)}var qe=_({square_:g8});function b8(r,e=null,t=!1){r=v(r,"x","moments");let n=yr(e,r.shape),o=Rt(r,n,t),s=o.shape;t||(s=Rs(o.shape,n));let i=qe(pe(J(r,"float32"),L(o,s))),a=Rt(i,n,t);return{mean:o,variance:a}}var Vc=_({moments_:b8});function y8(r,e,t,n){let o=v(e,"data","multiRNNCell"),s=eu(t,"c","multiRNNCell"),i=eu(n,"h","multiRNNCell"),a=o,u=[];for(let c=0;c<r.length;c++){let m=r[c](a,s[c],i[c]);u.push(m[0]),u.push(m[1]),a=m[1]}let l=[],p=[];for(let c=0;c<u.length;c+=2)l.push(u[c]),p.push(u[c+1]);return[l,p]}var x8=_({multiRNNCell_:y8});function T8(r,e,t,n=!1){let o=v(r,"logits","multinomial"),s=o.size,i=o.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();let u={logits:i===1?L(o,[1,-1]):o},l={numSamples:e,seed:t,normalized:n},p=N.runKernel(vc,u,l);return i===1?L(p,[p.size]):p}var mC=_({multinomial_:T8});function k8(r,e){let t=v(r,"a","notEqual","string_or_numeric"),n=v(e,"b","notEqual","string_or_numeric");[t,n]=Qe(t,n),Ge(t.shape,n.shape);let o={a:t,b:n};return N.runKernel(ma,o)}var li=_({notEqual_:k8});function I8(r){let t={x:v(r,"x","onesLike")};return N.runKernel(ys,t)}var Dr=_({onesLike_:I8});function C8(r,e){let t=v(r,"v1","outerProduct"),n=v(e,"v2","outerProduct");D(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);let o=L(t,[-1,1]),s=L(n,[1,-1]);return Ve(o,s)}var v8=_({outerProduct_:C8});function S8(r,e,t=0){let n=v(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let o={paddings:e,constantValue:t},s={x:n};return N.runKernel(Mo,s,o)}var Pn=_({pad_:S8});function w8(r,e,t=0){return D(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Pn(r,[e],t)}var _8=_({pad1d_:w8});function A8(r,e,t=0){return D(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pn(r,e,t)}var N8=_({pad2d_:A8});function D8(r,e,t=0){return D(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pn(r,e,t)}var P8=_({pad3d_:D8});function M8(r,e,t=0){return D(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Pn(r,e,t)}var F8=_({pad4d_:M8});function E8(r,e,t){let n=v(r,"x","spaceToBatchND");D(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),D(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),D(n.shape.reduce((i,a,u)=>u>0&&u<=e.length?i&&(a+t[u-1][0]+t[u-1][1])%e[u-1]==0:i,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);let o={x:n},s={blockShape:e,paddings:t};return N.runKernel(Cs,o,s)}var Xl=_({spaceToBatchND_:E8});function R8(r,e,t,n,o,s,i){o==null&&(o=[1,1]),s==null&&(s=1),n===0&&(n="valid");let a=v(r,"x","maxPool"),u=a,l=!1;a.rank===3&&(l=!0,u=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),D(Lr(s,o),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${o}'`);let p=RI(u.shape,e,s,o,n),c=[p.dilationHeight,p.dilationWidth],m;n==="same"?m=B8([p.filterHeight,p.filterWidth],c):m=[[0,0],[0,0]];let d=c[0]===1&&c[1]===1,[f,h]=L8([p.inHeight,p.inWidth],c,m),g=d?n:"valid",x=d?u:Xl(u,c,f),T=(t==="avg"?()=>zl(x,e,s,g,i):()=>ql(x,e,s,g,i))(),k=d?T:Gl(T,c,h);return l?L(k,[k.shape[1],k.shape[2],k.shape[3]]):k}function L8(r,e,t){let n=t.map(p=>p[0]),o=t.map(p=>p[1]),s=r.concat(n,o),i=e.map((p,c)=>(p-s[c]%p)%p),a=o.map((p,c)=>p+i[c]),u=e.map((p,c)=>[n[c],a[c]]),l=e.map((p,c)=>[0,i[c]]);return[u,l]}function B8(r,e){let n=r.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),o=n.map(i=>Math.floor(i/2)),s=n.map((i,a)=>i-o[a]);return n.map((i,a)=>[o[a],s[a]])}var $8=_({pool_:R8});function O8(r,e){let t=v(r,"base","pow"),n=v(e,"exp","pow");[t,n]=Qe(t,n);let o={a:t,b:n};return N.runKernel(Fo,o)}var Mn=_({pow_:O8});function z8(r,e){let t=v(r,"x","prelu"),n=v(e,"alpha","prelu"),o={x:t,alpha:n};return N.runKernel(Eo,o)}var Yl=_({prelu_:z8});function G8(r,e=null,t=!1){let n=v(r,"x","prod");n.dtype==="bool"&&(n=J(n,"int32"));let o={x:n},s={axis:e,keepDims:t};return N.runKernel(ga,o,s)}var Ud=_({prod_:G8});function U8(r,e,t){let n=nt(r),o=null;if(t==null||t==="float32")o=new Float32Array(n);else if(t==="int32")o=new Int32Array(n);else if(t==="bool")o=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let s=0;s<n;s++)o[s]=e();return N.makeTensor(o,r,t)}var W8=_({rand_:U8});var Lb=wl(Wd());var jc=class{constructor(e,t,n,o,s){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let i=s||Math.random();this.random=Lb.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){let o=this.nextVal;return this.nextVal=NaN,o}let e,t,n=!1;for(;!n;){let o,s,i;do o=2*this.random()-1,s=2*this.random()-1,i=o*o+s*s;while(i>=1||i===0);let a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*o*a,t=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}},xC=class{constructor(e,t,n,o){this.alpha=e,this.beta=1/t,this.dtype=n;let s=o||Math.random();this.randu=Lb.alea(s.toString()),this.randn=new jc(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,o,s,i;for(;;){do o=this.randn.nextValue(),i=1+this.c*o;while(i<=0);if(i*=i*i,e=o*o,t=1-.331*e*e,n=.5*e+this.d*(1-i+Math.log(i)),s=this.randu(),s<t||Math.log(s)<n)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}},TC=class{constructor(e=0,t=1,n,o){this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32";if(this.min=e,this.range=t-e,this.dtype=n,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Lb.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function Y8(r,e,t=1,n="float32",o){if(t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);let s=new xC(e,t,n,o),i=Ce(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Q8=_({randomGamma_:Y8});function Z8(r,e=0,t=1,n,o){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let s=new jc(e,t,n,!1,o),i=Ce(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var Bb=_({randomNormal_:Z8});function J8(r,e=0,t=1,n="float32",o){let s=Ce(r,n),i=new TC(e,t,null,o);for(let a=0;a<s.values.length;a++)s.values[a]=i.nextValue();return s.toTensor()}var Na=_({randomUniform_:J8});function mu(r,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");let o={start:r,stop:e,step:t,dtype:n};return N.runKernel(Ja,{},o)}function eX(r){let t={input:v(r,"input","real")};return N.runKernel(Wu,t)}var tl=_({real_:eX});function tX(r){let t={x:v(r,"x","reciprocal")};return N.runKernel(Hi,t)}var kC=_({reciprocal_:tX});function rX(r){let t={x:v(r,"x","relu")};return N.runKernel(Ro,t)}var qr=_({relu_:rX});function nX(r){let t={x:v(r,"x","relu6")};return N.runKernel(Bo,t)}var Kd=_({relu6_:nX});function oX(r,e){let n={x:v(r,"x","reverse")},o={dims:e};return N.runKernel(ba,n,o)}var xr=_({reverse_:oX});function sX(r){let e=v(r,"x","reverse");return D(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),xr(e,0)}var aX=_({reverse1d_:sX});function iX(r,e){let t=v(r,"x","reverse");return D(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),xr(t,e)}var uX=_({reverse2d_:iX});function lX(r,e){let t=v(r,"x","reverse");return D(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),xr(t,e)}var pX=_({reverse3d_:lX});function cX(r,e){let t=v(r,"x","reverse");return D(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),xr(t,e)}var mX=_({reverse4d_:cX});function dX(r){let t={x:v(r,"x","round")};return N.runKernel(ya,t)}var Vd=_({round_:dX});function fX(r){let t={x:v(r,"x","rsqrt","float32")};return N.runKernel($o,t)}var jd=_({rsqrt_:fX});function me(r,e){if((kr(r)&&e!=="string"||Array.isArray(r))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&kr(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ln(r,[],[],e)}function hX(r){let t={x:v(r,"x","selu")};return N.runKernel(qi,t)}var Hd=_({selu_:hX});function gX(r,e,t,n,o,s=[1,1],i="NHWC"){let a=v(r,"x","separableConv2d"),u=v(e,"depthwiseFilter","separableConv2d"),l=v(t,"pointwiseFilter","separableConv2d"),p=a,c=!1;if(a.rank===3&&(c=!0,p=L(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");D(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),D(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),D(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),D(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);let m=u.shape[2],d=u.shape[3];D(l.shape[2]===m*d,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${m*d}, but got ${l.shape[2]}.`);let f=uu(p,u,n,o,i,s),g=Yn(f,l,1,"valid",i);return c?L(g,[g.shape[1],g.shape[2],g.shape[3]]):g}var IC=_({separableConv2d_:gX});async function bX(r,e){let t=v(r,"x","setdiff1d"),n=v(e,"y","setdiff1d");D(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),D(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),D(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);let o=await t.data(),s=await n.data(),i=new Set(s),a=0;for(let p=0;p<o.length;p++)i.has(o[p])||a++;let u=new yt([a],t.dtype),l=new yt([a],"int32");for(let p=0,c=0;p<o.length;p++)i.has(o[p])||(u.values[c]=o[p],l.values[c]=p,c++);return[u.toTensor(),l.toTensor()]}var CC=bX;function yX(r){let t={x:v(r,"x","sign")};return N.runKernel(Xi,t)}var vC=_({sign_:yX});function xX(r){let t={x:v(r,"x","sin","float32")};return N.runKernel(Oo,t)}var qd=_({sin_:xX});function TX(r){let t={x:v(r,"x","sinh")};return N.runKernel(Ta,t)}var Xd=_({sinh_:TX});function kX(r,e,t){let n=v(r,"x","slice1d");return D(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),ze(n,[e],[t])}var Yd=_({slice1d_:kX});function IX(r,e,t){let n=v(r,"x","slice2d");return D(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var $b=_({slice2d_:IX});function CX(r,e,t){let n=v(r,"x","slice3d");return D(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var Qd=_({slice3d_:CX});function vX(r,e,t){let n=v(r,"x","slice4d");return D(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),ze(n,e,t)}var Hc=_({slice4d_:vX});function SX(r,e=-1){let t=v(r,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);let n={logits:t},o={dim:e};return N.runKernel(Wo,n,o)}var Zl=_({softmax_:SX});function wX(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(bc,e)}var Jl=_({fft_:wX});function _X(r){D(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let e={input:r};return N.runKernel(yc,e)}var rl=_({ifft_:_X});function AX(r){let e=r.shape[r.shape.length-1],t=r.size/e,n;if(e<=2){let o=L(r,[t,e]);n=rl(o)}else{let o=[t,2*(e-1)],s=L(tl(r),[t,e]),i=L(Kl(r),[t,e]),a=xr(ze(s,[0,1],[t,e-2]),1),u=R(xr(ze(i,[0,1],[t,e-2]),1),me(-1)),l=lt([s,a],1),p=lt([i,u],1),c=L(Xn(l,p),[o[0],o[1]]);n=rl(c)}if(n=tl(n),r.rank===3&&r.shape[0]!==0){let o=n,s=r.shape[0];n=L(n,[s,n.shape[0]/s,n.shape[1]]),o.dispose()}return n}var Zd=_({irfft_:AX});function NX(r,e,t=0){let o={x:v(r,"x","split")},s={numOrSizeSplits:e,axis:t};return N.runKernel(vs,o,s)}var Ir=_({split_:NX});function DX(r,e){D(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let t=r.shape[r.shape.length-1],n=r.size/t,o;if(e!=null&&e<t){let f=r.shape.map(g=>0),h=r.shape.map(g=>g);h[r.shape.length-1]=e,o=ze(r,f,h),t=e}else if(e!=null&&e>t){let f=r.shape.map(h=>h);f[r.shape.length-1]=e-t,o=lt([r,xt(f)],r.shape.length-1),t=e}else o=r;let s=Ne(o),i=L(Xn(o,s),[n,t]),a=Jl(i),u=Math.floor(t/2)+1,l=tl(a),p=Kl(a),c=Ir(l,[u,t-u],l.shape.length-1),m=Ir(p,[u,t-u],p.shape.length-1),d=o.shape.slice();return d[o.shape.length-1]=u,L(Xn(c[0],m[0]),d)}var ep=_({rfft_:DX});function PX(r){let t={x:v(r,"x","sqrt","float32")};return N.runKernel(Go,t)}var Lt=_({sqrt_:PX});function MX(r,e){let t=v(r,"a","squaredDifference"),n=v(e,"b","squaredDifference");[t,n]=Qe(t,n),Ge(t.shape,n.shape);let o={a:t,b:n},s={};return N.runKernel(Ko,o,s)}var Jd=_({squaredDifference_:MX});function FX(r,e){let t=v(r,"x","squeeze");return L(t,$k(t.shape,e).newShape)}var dn=_({squeeze_:FX});function EX(r,e=0){let t=eu(r,"tensors","stack","string_or_numeric");D(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&D(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");let n=t,o={axis:e};return N.runKernel(xs,n,o)}var fr=_({stack_:EX});function RX(r,e=0){let n={x:v(r,"x","step")},o={alpha:e};return N.runKernel(_s,n,o)}var du=_({step_:RX});function LX(r,e,t,n,o=0,s=0,i=0,a=0,u=0){let p={x:v(r,"x","stridedSlice","string_or_numeric")},c={begin:e,end:t,strides:n,beginMask:o,endMask:s,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return N.runKernel(ka,p,c)}var SC=_({stridedSlice_:LX});function BX(r){let t={x:v(r,"x","tan","float32")};return N.runKernel(Ia,t)}var wC=_({tan_:BX});function zt(r,e){no(r);let t=Wr(r,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ln(r,null,t,e)}function pi(r,e,t){if(no(r),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=Wr(r,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ln(r,e,n,t)}function $X(r,e,t){if(no(r),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");let n=Wr(r,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return ln(r,e,n,t)}function OX(r,e,t){if(no(r),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");let n=Wr(r,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return ln(r,e,n,t)}function zX(r,e,t){if(no(r),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");let n=Wr(r,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,ln(r,e,n,t)}function GX(r,e=1,t=!0){let n=v(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let o=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>o)throw new Error(`'k' passed to topk() must be <= the last dimension (${o}) but got ${e}`);let s={x:n},i={k:e,sorted:t},[a,u]=N.runKernel(Ca,s,i);return{values:a,indices:u}}var _C=_({topk_:GX});function UX(r,e=0,t=1,n,o){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let s=new jc(e,t,n,!0,o),i=Ce(r,n);for(let a=0;a<i.values.length;a++)i.values[a]=s.nextValue();return i.toTensor()}var tp=_({truncatedNormal_:UX});function WX(r,e=0){let t=v(r,"x","unique","string_or_numeric");D(t.rank>0,()=>"The input tensor must be at least 1D");let n={x:t},o={axis:e},[s,i]=N.runKernel(Nc,n,o);return{values:s,indices:i}}var Ob=_({unique_:WX});function KX(r,e,t){let n=v(r,"x","unsortedSegmentSum"),o=v(e,"segmentIds","unsortedSegmentSum","int32");D(Ni(t),()=>"numSegments must be of dtype int");let s={x:n,segmentIds:o},i={numSegments:t};return N.runKernel(Xu,s,i)}var AC=_({unsortedSegmentSum_:KX});function VX(r,e=0){let t=v(r,"x","unstack","string_or_numeric");D(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);let n={value:t},o={axis:e};return N.runKernel(Ss,n,o)}var Or=_({unstack_:VX});function NC(r,e=!0,t,n){return N.makeVariable(r,e,t,n)}function zb(r,e){let t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);let n=Ce(r,"int32"),o=Ce([t.length,r.length],"int32");for(let s=0;s<t.length;s++){let i=n.indexToLoc(t[s]),a=s*r.length;o.values.set(i,a)}return o.toTensor()}async function jX(r){let e=v(r,"condition","whereAsync","bool"),t=await e.data(),n=zb(e.shape,t);return r!==e&&e.dispose(),n}var ef=jX;async function HX(r,e,t){let n=v(r,"tensor","boolMask"),o=v(e,"mask","boolMask","bool"),s=t??0,i=o.rank,a=n.shape;D(i>0,()=>"mask cannot be scalar"),Wt(a.slice(s,s+i),o.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let h=s;h<s+i;h++)u*=a[h];let l=a.slice(0,s).concat([u],a.slice(s+i)),p=L(n,l),c=L(o,[-1]),m=await ef(c),d=dn(m,[1]),f=ii(p,d,s);return r!==n&&n.dispose(),e!==o&&o.dispose(),d.dispose(),p.dispose(),c.dispose(),m.dispose(),f}var NLe=HX;function qX(r,e="euclidean",t=null,n=!1){r=v(r,"x","norm");let o=d2(r,e,t),s=o.shape;if(n){let i=yr(t,r.shape);s=Rs(o.shape,i)}return L(o,s)}function d2(r,e,t=null){if(r.rank===0)return $t(r);if(r.rank!==1&&t===null)return d2(L(r,[-1]),e,t);if(r.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return he($t(r),t);if(e===1/0)return en($t(r),t);if(e===-1/0)return Kc($t(r),t);if(e==="euclidean"||e===2)return Lt(he(Mn($t(r),me(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return en(he($t(r),t[0]),t[1]-1);if(e===1/0)return en(he($t(r),t[1]),t[0]);if(e===-1/0)return Kc(he($t(r),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Lt(he(qe(r),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}var Gb=_({norm_:qX});function XX(r,e,t,n,o=!0){let s=v(r,"v","movingAverage"),i=v(e,"x","movingAverage"),a=v(t,"decay","movingAverage");tI(s,i),D(Wn(s.shape,i.shape),()=>"Shape mismatch in v and x");let u=me(1),l=pe(u,a),p=R(pe(i,s),l);if(o){D(n!=null,()=>"When using zeroDebias: true, step is required.");let c=v(n,"step","movingAverage");p=ce(p,pe(u,Mn(a,c)))}return X(s,p)}var JLe=_({movingAverage_:XX});function YX(r,e,t){let n=v(r,"indices","scatterND","int32"),o=v(e,"updates","scatterND");Ab(o,n,t);let s={indices:n,updates:o},i={shape:t};return N.runKernel(xa,s,i)}var f2=_({scatterND_:YX});function h2(r,e,t,n){if(r.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${r.dtype}.`);if(r.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${r.shape}.`);let o=r.rank>0?r.shape[0]:1,s=r.rank>1?r.shape[1]:1;if(t.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${s}.`);let i=e.size;if(!(e.rank===0||e.rank===1&&i===o))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${o}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function ZX(r,e,t,n=0){let o=v(r,"sparseIndices","sparseToDense","int32"),s=v(e,"sparseValues","sparseToDense"),i=v(n,"defaultValue","sparseToDense",s.dtype);h2(o,s,t,i);let a={sparseIndices:o,sparseValues:s,defaultValue:i},u={outputShape:t};return N.runKernel(Hu,a,u)}var Ub=_({sparseToDense_:ZX});function JX(r,e){let t=v(e,"indices","gatherND","int32"),o={params:v(r,"x","gatherND","string_or_numeric"),indices:t};return N.runKernel(ia,o)}var g2=_({gatherND_:JX});function b2(r,e){if(e==null)return r.shape.slice();if(Wn(r.shape,e))return e;if(r.shape.length===e.length){let t=[];for(let n=0;n<r.shape.length;n++)e[n]==null&&r.shape[n]!=null?t.push(r.shape[n]):t.push(e[n]);return t}return e}function eY(r,e,t,n){let o=v(r,"x","dropout");if(D(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),D(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return r instanceof Ye?o.clone():o;let s=b2(o,t),i=1-e,a=ce(pu(X(Na(s,0,1,"float32",n),i)),i);return R(o,a)}var y2=_({dropout_:eY});function x2(r){return Math.floor(Math.pow(2,Math.ceil(Math.log(r)/Math.log(2))))}function Wb(r,e,t){let n=1-r%2,o=new Float32Array(r);for(let s=0;s<r;++s){let i=2*Math.PI*s/(r+n-1);o[s]=e-t*Math.cos(i)}return zt(o,"float32")}async function tY(r,e,t=1){let n=v(r,"predictions","inTopK"),o=v(e,"targets","inTopK");D(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),D(n.rank-1===o.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${o.rank}`),Wt(n.shape.slice(0,n.shape.length-1),o.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");let s=n.shape[n.shape.length-1];D(t>0&&t<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${t}`);let i=await n.data(),a=await o.data(),[u,l]=[i.length/s,s],p=Ok("bool",u);for(let c=0;c<u;c++){let m=c*l,d=i.subarray(m,m+l),f=[];for(let h=0;h<d.length;h++)f.push({value:d[h],index:h});f.sort((h,g)=>g.value-h.value),p[c]=0;for(let h=0;h<t;h++)if(f[h].index===a[c]){p[c]=1;break}}return r!==n&&n.dispose(),e!==o&&o.dispose(),Rr(p,o.shape,"bool")}var BBe=tY;var Ls={};Xe(Ls,{conv2d:()=>T2,depthwiseConv2d:()=>k2,matMul:()=>I2});function rY(r,e,t,n,o,s="NHWC",i){let a=r;r.rank===3&&(a=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=L(e,[1,e.shape[0],e.shape[1],e.shape[2]])),D(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),D(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),D(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);let l=s==="NHWC"?a.shape[3]:a.shape[1],p=s==="NHWC"?u.shape[3]:u.shape[1];D(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),D(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),Pt("conv2dDerFilter",o,i);let c={x:a,dy:u},m={strides:n,pad:o,dataFormat:s,dimRoundingMode:i,filterShape:t};return N.runKernel(lc,c,m)}var qc=_({conv2DBackpropFilter_:rY});function rp(r,e,t){if(t==null||t==="linear")return r;if(t==="relu")return R(r,du(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function np(r,e){let t=e,n=vt(r.shape,e.shape);return n.length>0&&(t=he(t,n)),L(t,r.shape)}function op(r,e,t,n){if(e==="linear")return r;if(e==="relu")return qr(r);if(e==="elu")return lu(r);if(e==="relu6")return Kd(r);if(e==="prelu")return Yl(r,t);if(e==="leakyrelu")return Vl(r,n);if(e==="sigmoid")return cn(r);throw new Error(`Unknown fused activation ${e}.`)}var sp=(r,e)=>!(r>0)||e==="linear";function nY({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(u=u||"linear",sp(N.state.gradientDepth,u)===!1){let C=Yn(r,e,t,n,o,s,i);return a!=null&&(C=X(C,a)),op(C,u,l,p)}let c=v(r,"x","conv2d","float32"),m=v(e,"filter","conv2d","float32"),d=c,f=!1;c.rank===3&&(f=!0,d=L(c,[1,c.shape[0],c.shape[1],c.shape[2]])),D(d.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${d.rank}.`),D(m.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${m.rank}.`),Pt("fused conv2d",n,i),D(d.shape[3]===m.shape[2],()=>`Error in conv2d: depth of input (${d.shape[3]}) must match input depth for filter ${m.shape[2]}.`),D(Lr(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),D(o==="NHWC",()=>`Error in conv2d: got dataFormat of ${o} but only NHWC is currently supported.`);let h=$l(d.shape,m.shape,t,s,n,i),g;a!=null&&(g=v(a,"bias","fused conv2d"),[g]=Qe(g,c),Ge(h.outShape,g.shape));let x;l!=null&&(x=v(l,"prelu weights","fused conv2d"));let y=(C,A)=>{let[M,P,F,B]=A,U=rp(C,F,u);D(Xo(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);let W=Uc(P.shape,U,M,t,n),K=qc(P,U,M.shape,t,n),j=[W,K];if(B!=null){let V=np(B,U);j.push(V)}return j},T={x:d,filter:m,bias:g,preluActivationWeights:x},k={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:p};return a==null?mn((A,M,P)=>{let F=N.runKernel(Ns,T,k);return P([M,A,F]),f&&(F=L(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:y}})(d,m):mn((A,M,P,F)=>{let B=N.runKernel(Ns,T,k);return F([M,A,B,P]),f&&(B=L(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:y}})(d,m,g)}var T2=_({fusedConv2d_:nY});function oY(r,e,t,n,o,s=[1,1],i){let a=r;r.rank===3&&(a=L(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=e;u.rank===3&&(u=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={x:a,dy:u},p={strides:n,pad:o,dimRoundingMode:i,dilations:s,filterShape:t};return N.runKernel(dc,l,p)}var Kb=_({depthwiseConv2dNativeBackpropFilter_:oY});function sY(r,e,t,n,o,s=[1,1],i){let a=e,u=!1;e.rank===3&&(u=!0,a=L(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l={dy:a,filter:t},p={strides:n,pad:o,dimRoundingMode:i,dilations:s,inputShape:r},c=N.runKernel(fc,l,p);return u?L(c,[c.shape[1],c.shape[2],c.shape[3]]):c}var Vb=_({depthwiseConv2dNativeBackpropInput_:sY});function aY({x:r,filter:e,strides:t,pad:n,dataFormat:o="NHWC",dilations:s=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(sp(N.state.gradientDepth,u)===!1){let C=uu(r,e,t,n,o,s,i);return a!=null&&(C=X(C,a)),op(C,u,l,p)}let c=v(r,"x","depthwiseConv2d","float32"),m=v(e,"filter","depthwiseConv2d","float32"),d=c,f=!1;c.rank===3&&(f=!0,d=L(c,[1,c.shape[0],c.shape[1],c.shape[2]])),D(d.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),D(m.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${m.rank}.`),D(d.shape[3]===m.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${d.shape[3]}) must match the inChannels dimension in filter ${m.shape[2]}.`),s==null&&(s=[1,1]),D(Lr(t,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),Pt("fused depthwiseConv2d",n,i);let h=$l(d.shape,m.shape,t,s,n,i,!0),g;a!=null&&(g=v(a,"bias","fused conv2d"),[g]=Qe(g,c),Ge(h.outShape,g.shape));let x;l!=null&&(x=v(l,"prelu weights","fused depthwiseConv2d"));let y=(C,A)=>{D(Xo(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);let[M,P,F,B]=A,U=rp(C,F,u),W=Vb(P.shape,U,M,t,n,s,i),K=Kb(P,U,M.shape,t,n,s,i);if(B!=null){let j=np(g,U);return[W,K,j]}return[W,K]},T={x:d,filter:m,bias:g,preluActivationWeights:x},k={strides:t,pad:n,dataFormat:o,dilations:s,dimRoundingMode:i,activation:u,leakyreluAlpha:p};return a==null?mn((A,M,P)=>{let F=N.runKernel(Ds,T,k);return P([M,A,F]),f&&(F=L(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:y}})(d,m):mn((A,M,P,F)=>{let B=N.runKernel(Ds,T,k);return F([M,A,B,P]),f&&(B=L(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:y}})(d,m,g)}var k2=_({fusedDepthwiseConv2d_:aY});function iY({a:r,b:e,transposeA:t=!1,transposeB:n=!1,bias:o,activation:s="linear",preluActivationWeights:i,leakyreluAlpha:a}){if(sp(N.state.gradientDepth,s)===!1){let U=Ve(r,e,t,n);return o!=null&&(U=X(U,o)),op(U,s,i,a)}let u=v(r,"a","fused matMul"),l=v(e,"b","fused matMul");[u,l]=Qe(u,l);let p=t?u.shape[u.rank-2]:u.shape[u.rank-1],c=n?l.shape[l.rank-1]:l.shape[l.rank-2],m=t?u.shape[u.rank-1]:u.shape[u.rank-2],d=n?l.shape[l.rank-2]:l.shape[l.rank-1],f=u.shape.slice(0,-2),h=l.shape.slice(0,-2),g=nt(f),x=nt(h);D(p===c,()=>`Error in fused matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${n} must match.`);let T=Ge(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([m,d]),k=t?L(u,[g,p,m]):L(u,[g,m,p]),C=n?L(l,[x,d,c]):L(l,[x,c,d]),A;o!=null&&(A=v(o,"bias","fused matMul"),[A]=Qe(A,u),Ge(T,A.shape));let M;i!=null&&(M=v(i,"prelu weights","fused matMul"));let P=(U,W)=>{let[K,j,V,q]=W,ee=rp(L(U,V.shape),V,s),Z,te;if(!t&&!n?(Z=Ve(ee,j,!1,!0),te=Ve(K,ee,!0,!1)):!t&&n?(Z=Ve(ee,j,!1,!1),te=Ve(ee,K,!0,!1)):t&&!n?(Z=Ve(j,ee,!1,!0),te=Ve(K,ee,!1,!1)):(Z=Ve(j,ee,!0,!0),te=Ve(ee,K,!0,!0)),o!=null){let oe=np(q,ee);return[Z,te,oe]}else return[Z,te]},F={a:k,b:C,bias:A,preluActivationWeights:M},B={transposeA:t,transposeB:n,activation:s,leakyreluAlpha:a};return o==null?mn((W,K,j)=>{let V=N.runKernel(As,F,B);return j([W,K,V]),{value:L(V,T),gradFunc:P}})(k,C):mn((W,K,j,V)=>{let q=N.runKernel(As,F,B);return V([W,K,q,j]),{value:L(q,T),gradFunc:P}})(k,C,A)}var I2=_({fusedMatMul_:iY});function uY(r){return Wb(r,.54,.46)}var C2=_({hammingWindow_:uY});function lY(r){return Wb(r,.5,.5)}var jb=_({hannWindow_:lY});function pY(r,e,t,n=!1,o=0){let s=0,i=[];for(;s+e<=r.size;)i.push(ze(r,s,e)),s+=t;if(n)for(;s<r.size;){let a=s+e-r.size,u=lt([ze(r,s,e-a),Aa([a],o)]);i.push(u),s+=t}return i.length===0?pi([],[0,e]):L(lt(i),[i.length,e])}var Hb=_({frame_:pY});function cY(r,e,t,n,o=jb){n==null&&(n=x2(e));let s=Hb(r,e,t),i=R(s,o(e));return ep(i,n)}var v2=_({stft_:cY});function mY(r,e,t,n,o="bilinear",s=0){let i=v(r,"image","cropAndResize"),a=v(e,"boxes","cropAndResize","float32"),u=v(t,"boxInd","cropAndResize","int32"),l=a.shape[0];D(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),D(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),D(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),D(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),D(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),D(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);let p={image:i,boxes:a,boxInd:u},c={method:o,extrapolationValue:s,cropSize:n};return N.runKernel(ra,p,c)}var S2=_({cropAndResize_:mY});function dY(r){let e=v(r,"image","flipLeftRight","float32");D(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);let t={image:e};return N.runKernel(aa,t,{})}var w2=_({flipLeftRight_:dY});function fY(r){let e=v(r,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];D(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),D(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);let o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,jr(e,o)}var _2=_({grayscaleToRGB_:fY});function hY(r,e,t=0,n=.5){let o=v(r,"image","rotateWithOffset","float32");D(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);let s={image:o},i={radians:e,fillValue:t,center:n};return N.runKernel(Sa,s,i)}var A2=_({rotateWithOffset_:hY});function Bs(r,e,t,n,o,s){n==null&&(n=.5),o==null&&(o=Number.NEGATIVE_INFINITY),s==null&&(s=0);let i=r.shape[0];return t=Math.min(t,i),D(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),D(r.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${r.rank}'`),D(r.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${r.shape[1]}`),D(e.rank===1,()=>"scores must be a 1D tensor"),D(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),D(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s}}function gY(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppression","float32"),i=v(e,"scores","nonMaxSuppression","float32"),a=Bs(s,i,t,n,o);t=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u={maxOutputSize:t,iouThreshold:n,scoreThreshold:o};return N.runKernel(da,{boxes:s,scores:i},u)}var N2=_({nonMaxSuppression_:gY});function D2(r,e,t){let n=bY(r,e,t),o=n<0?-(n+1):n;r.splice(o,0,e)}function bY(r,e,t){return xY(r,e,t||yY)}function yY(r,e){return r>e?1:r<e?-1:0}function xY(r,e,t){let n=0,o=r.length,s=0,i=!1;for(;n<o;){s=n+(o-n>>>1);let a=t(e,r[s]);a>0?n=s+1:(o=s,i=!a)}return i?n:-n-1}function qb(r,e,t,n,o){return DC(r,e,t,n,o,0)}function Xb(r,e,t,n,o,s){return DC(r,e,t,n,o,0,!1,s,!0)}function Yb(r,e,t,n,o,s){return DC(r,e,t,n,o,s,!0)}function DC(r,e,t,n,o,s,i=!1,a=!1,u=!1){let l=[];for(let g=0;g<e.length;g++)e[g]>o&&l.push({score:e[g],boxIndex:g,suppressBeginIndex:0});l.sort(P2);let p=s>0?-.5/s:0,c=[],m=[];for(;c.length<t&&l.length>0;){let g=l.pop(),{score:x,boxIndex:y,suppressBeginIndex:T}=g;if(x<o)break;let k=!1;for(let C=c.length-1;C>=T;--C){let A=TY(r,y,c[C]);if(A>=n){k=!0;break}if(g.score=g.score*kY(n,p,A),g.score<=o)break}g.suppressBeginIndex=c.length,k||(g.score===x?(c.push(y),m.push(g.score)):g.score>o&&D2(l,g,P2))}let d=c.length,f=t-d;a&&f>0&&(c.push(...new Array(f).fill(0)),m.push(...new Array(f).fill(0)));let h={selectedIndices:c};return i&&(h.selectedScores=m),u&&(h.validOutputs=d),h}function TY(r,e,t){let n=r.subarray(e*4,e*4+4),o=r.subarray(t*4,t*4+4),s=Math.min(n[0],n[2]),i=Math.min(n[1],n[3]),a=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),l=Math.min(o[0],o[2]),p=Math.min(o[1],o[3]),c=Math.max(o[0],o[2]),m=Math.max(o[1],o[3]),d=(a-s)*(u-i),f=(c-l)*(m-p);if(d<=0||f<=0)return 0;let h=Math.max(s,l),g=Math.max(i,p),x=Math.min(a,c),y=Math.min(u,m),T=Math.max(x-h,0)*Math.max(y-g,0);return T/(d+f-T)}function kY(r,e,t){let n=Math.exp(e*t*t);return t<=r?n:0}function P2(r,e){return r.score-e.score||r.score===e.score&&e.boxIndex-r.boxIndex}async function IY(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY){let s=v(r,"boxes","nonMaxSuppressionAsync"),i=v(e,"scores","nonMaxSuppressionAsync"),a=Bs(s,i,t,n,o);t=a.maxOutputSize,n=a.iouThreshold,o=a.scoreThreshold;let u=await Promise.all([s.data(),i.data()]),l=u[0],p=u[1],{selectedIndices:c}=qb(l,p,t,n,o);return s!==r&&s.dispose(),i!==e&&i.dispose(),zt(c,"int32")}var M2=IY;function CY(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=v(r,"boxes","nonMaxSuppression"),a=v(e,"scores","nonMaxSuppression"),u=Bs(i,a,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l={boxes:i,scores:a},p={maxOutputSize:t,iouThreshold:n,scoreThreshold:o,softNmsSigma:s},c=N.runKernel(fa,l,p);return{selectedIndices:c[0],selectedScores:c[1]}}var F2=_({nonMaxSuppressionWithScore_:CY});async function vY(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=0){let i=v(r,"boxes","nonMaxSuppressionAsync"),a=v(e,"scores","nonMaxSuppressionAsync"),u=Bs(i,a,t,n,o,s);t=u.maxOutputSize,n=u.iouThreshold,o=u.scoreThreshold,s=u.softNmsSigma;let l=await Promise.all([i.data(),a.data()]),p=l[0],c=l[1],{selectedIndices:m,selectedScores:d}=Yb(p,c,t,n,o,s);return i!==r&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:zt(m,"int32"),selectedScores:zt(d)}}var E2=vY;function SY(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=v(r,"boxes","nonMaxSuppression"),a=v(e,"scores","nonMaxSuppression"),u=Bs(i,a,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,c=u.scoreThreshold,m={boxes:i,scores:a},d={maxOutputSize:l,iouThreshold:p,scoreThreshold:c,padToMaxOutputSize:s},f=N.runKernel(ji,m,d);return{selectedIndices:f[0],validOutputs:f[1]}}var R2=_({nonMaxSuppressionPadded_:SY});async function wY(r,e,t,n=.5,o=Number.NEGATIVE_INFINITY,s=!1){let i=v(r,"boxes","nonMaxSuppressionAsync"),a=v(e,"scores","nonMaxSuppressionAsync"),u=Bs(i,a,t,n,o,null),l=u.maxOutputSize,p=u.iouThreshold,c=u.scoreThreshold,[m,d]=await Promise.all([i.data(),a.data()]),{selectedIndices:f,validOutputs:h}=Xb(m,d,l,p,c,s);return i!==r&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:zt(f,"int32"),validOutputs:me(h,"int32")}}var L2=wY;function _Y(r,e,t=!1,n=!1){let o=v(r,"images","resizeBilinear");D(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),D(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(Lo,a,u);return i?L(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var B2=_({resizeBilinear_:_Y});function AY(r,e,t=!1,n=!1){let o=v(r,"images","resizeNearestNeighbor");D(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),D(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),D(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),D(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=o,i=!1;o.rank===3&&(i=!0,s=L(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let[]=e,a={images:s},u={alignCorners:t,halfPixelCenters:n,size:e},l=N.runKernel(ei,a,u);return i?L(l,[l.shape[1],l.shape[2],l.shape[3]]):l}var $2=_({resizeNearestNeighbor_:AY});function NY(r,e="binary",t=!1,n=.5){let o=v(r,"image","threshold"),s=.2989,i=.587,a=.114,u=o.shape[0]*o.shape[1],l=R(zt([n]),255),p,c,m,d;if(D(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),D(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),D(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),D(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[p,c,m]=Ir(o,[1,1,1],-1);let g=R(p,s),x=R(c,i),y=R(m,a);d=X(X(g,x),y)}else d=r;if(e==="otsu"){let g=Pd(J(Vd(d),"int32"),Rr([]),256);l=DY(g,u)}let f=t?Zo(d,l):nr(d,l);return J(R(f,255),"int32")}function DY(r,e){let t=zt([-1]),n=zt([0]),o=zt([0]),s,i,a,u,l,p;for(let c=0;c<r.size-1;c++){s=ze(r,0,c+1),i=ze(r,c+1),l=ce(he(s),e),p=ce(he(i),e);let m=he(R(s,mu(0,s.size)));a=ce(m,he(s));let d=Aa(i.shape,s.size),f=X(mu(0,i.size),d),h=R(i,f);u=ce(he(h),he(i));let g=pe(a,u),x=pe(a,u),y=R(l,p);o=R(R(y,g),x);let T=nr(o,n);n=Ot(T,o,n),t=Ot(T,zt([c]),t)}return t}var O2=_({threshold_:NY});function PY(r,e,t="nearest",n="constant",o=0,s){let i=v(r,"image","transform","float32"),a=v(e,"transforms","transform","float32");D(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),D(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),D(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);let u={image:i,transforms:a},l={interpolation:t,fillMode:n,fillValue:o,outputShape:s};return N.runKernel(va,u,l)}var z2=_({transform_:PY});function MY(r,e,t){D(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),D(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);let n=v(r,"a","bandPart");D(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let o=n.shape,[s,i]=n.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(t<=i))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`);e<0&&(e=s),t<0&&(t=i);let a=L(mu(0,s,1,"int32"),[-1,1]),u=mu(0,i,1,"int32"),l=pe(a,u),p=Hr(Zo(l,me(+e,"int32")),Qo(l,me(-t,"int32"))),c=xt([s,i],n.dtype);return L(fr(Or(L(n,[-1,s,i])).map(m=>Ot(p,m,c))),o)}var G2=_({bandPart_:MY});function FY(r){let e;if(Array.isArray(r)){e=!1,D(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let o=r[0].shape[0];for(let s=1;s<r.length;++s)D(r[s].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[s].shape[0]} vs. ${o})`)}else e=!0,r=Ir(r,r.shape[0],0).map(o=>dn(o,[0]));D(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let t=[],n=r;for(let o=0;o<r.length;++o)t.push(N.tidy(()=>{let s=n[o];if(o>0)for(let i=0;i<o;++i){let a=R(he(R(t[i],s)),t[i]);s=pe(s,a)}return ce(s,Gb(s,"euclidean"))}));return e?fr(t,0):t}var U2=_({gramSchmidt_:FY});function EY(r,e=!1){if(D(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return W2(r,e);{let t=r.shape.slice(0,r.shape.length-2).reduce((u,l)=>u*l),n=Or(L(r,[t,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),o=[],s=[];n.forEach(u=>{let[l,p]=W2(u,e);o.push(l),s.push(p)});let i=L(fr(o,0),r.shape),a=L(fr(s,0),r.shape);return[i,a]}}function W2(r,e=!1){return N.tidy(()=>{D(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let t=r.shape[0],n=r.shape[1],o=Wc(t),s=Nn(r),i=pi([[1]],[1,1]),a=Nn(i),u=t>=n?n:t;for(let l=0;l<u;++l){let p=s,c=a,m=o;[a,s,o]=N.tidy(()=>{let d=ze(s,[l,l],[t-l,1]),f=Gb(d),h=ze(s,[l,l],[1,1]),g=Ot(nr(h,0),pi([[-1]]),pi([[1]])),x=pe(h,R(g,f)),y=ce(d,x);y.shape[0]===1?a=Nn(i):a=lt([i,ze(y,[1,0],[y.shape[0]-1,y.shape[1]])],0);let T=Ze(ce(Ve(g,x),f)),k=ze(s,[l,0],[t-l,n]),C=R(T,a),A=He(a);if(l===0)s=pe(k,Ve(C,Ve(A,k)));else{let F=pe(k,Ve(C,Ve(A,k)));s=lt([ze(s,[0,0],[l,n]),F],0)}let M=He(C),P=ze(o,[0,l],[t,o.shape[1]-l]);if(l===0)o=pe(P,Ve(Ve(P,a),M));else{let F=pe(P,Ve(Ve(P,a),M));o=lt([ze(o,[0,0],[t,l]),F],1)}return[a,s,o]}),Fe([p,c,m])}return!e&&t>n&&(o=ze(o,[0,0],[t,n]),s=ze(s,[0,0],[n,n])),[o,s]})}var K2=_({qr_:EY});var ir=(o=>(o[o.NONE=0]="NONE",o[o.MEAN=1]="MEAN",o[o.SUM=2]="SUM",o[o.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS",o))(ir||{});function RY(r,e,t=ir.SUM_BY_NONZERO_WEIGHTS){let n=v(r,"losses","computeWeightedLoss"),o=null;e!=null&&(o=v(e,"weights","computeWeightedLoss"));let s=o==null?n:R(n,o);if(t===ir.NONE)return s;if(t===ir.SUM)return he(s);if(t===ir.MEAN){if(o==null)return Rt(s);{let i=n.size/o.size,a=ce(he(s),he(o));return i>1?ce(a,me(i)):a}}if(t===ir.SUM_BY_NONZERO_WEIGHTS){if(o==null)return ce(he(s),me(n.size));{let i=R(o,dr(n.shape)),a=J(he(li(i,me(0))),"float32");return ce(he(s),a)}}throw Error(`Unknown reduction: ${t}`)}var Xr=_({computeWeightedLoss_:RY});function LY(r,e,t,n=ir.SUM_BY_NONZERO_WEIGHTS){let o=v(r,"labels","absoluteDifference"),s=v(e,"predictions","absoluteDifference"),i=null;t!=null&&(i=v(t,"weights","absoluteDifference")),Wt(o.shape,s.shape,"Error in absoluteDifference: ");let a=$t(pe(o,s));return Xr(a,i,n)}var V2=_({absoluteDifference_:LY});function BY(r,e,t,n,o=ir.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","cosineDistance"),i=v(e,"predictions","cosineDistance"),a=null;n!=null&&(a=v(n,"weights","cosineDistance")),Wt(s.shape,i.shape,"Error in cosineDistance: ");let u=me(1),l=pe(u,he(R(s,i),t,!0));return Xr(l,a,o)}var j2=_({cosineDistance_:BY});function $Y(r,e,t,n=ir.SUM_BY_NONZERO_WEIGHTS){let o=v(r,"labels","hingeLoss"),s=v(e,"predictions","hingeLoss"),i=null;t!=null&&(i=v(t,"weights","hingeLoss")),Wt(o.shape,s.shape,"Error in hingeLoss: ");let a=me(1);o=pe(R(me(2),o),a);let u=qr(pe(a,R(o,s)));return Xr(u,i,n)}var H2=_({hingeLoss_:$Y});function OY(r,e,t,n=1,o=ir.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","huberLoss"),i=v(e,"predictions","huberLoss"),a=null;t!=null&&(a=v(t,"weights","huberLoss")),Wt(s.shape,i.shape,"Error in huberLoss: ");let u=me(n),l=$t(pe(i,s)),p=cu(l,u),c=pe(l,p),m=X(R(me(.5),qe(p)),R(u,c));return Xr(m,a,o)}var q2=_({huberLoss_:OY});function zY(r,e,t,n=1e-7,o=ir.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"labels","logLoss"),i=v(e,"predictions","logLoss"),a=null;t!=null&&(a=v(t,"weights","logLoss")),Wt(s.shape,i.shape,"Error in logLoss: ");let u=me(1),l=me(n),p=Ze(R(s,$r(X(i,l)))),c=R(pe(u,s),$r(X(pe(u,i),l))),m=pe(p,c);return Xr(m,a,o)}var X2=_({logLoss_:zY});function GY(r,e,t,n=ir.SUM_BY_NONZERO_WEIGHTS){let o=v(r,"labels","meanSquaredError"),s=v(e,"predictions","meanSquaredError"),i=null;t!=null&&(i=v(t,"weights","meanSquaredError")),Wt(o.shape,s.shape,"Error in meanSquaredError: ");let a=Jd(o,s);return Xr(a,i,n)}var Y2=_({meanSquaredError_:GY});function UY(r,e){let t=v(r,"labels","sigmoidCrossEntropyWithLogits"),n=v(e,"logits","sigmoidCrossEntropyWithLogits");Wt(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");let o=qr(n),s=R(n,t),i=jl(mr(Ze($t(n))));return X(pe(o,s),i)}function WY(r,e,t,n=0,o=ir.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"multiClassLabels","sigmoidCrossEntropy"),i=v(e,"logits","sigmoidCrossEntropy"),a=null;if(t!=null&&(a=v(t,"weights","sigmoidCrossEntropy")),Wt(s.shape,i.shape,"Error in sigmoidCrossEntropy: "),n>0){let l=me(n),p=me(1),c=me(.5);s=X(R(s,pe(p,l)),R(c,l))}let u=UY(s,i);return Xr(u,a,o)}var Q2=_({sigmoidCrossEntropy_:WY});function KY(r,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return mn((o,s,i)=>{let u=uC(s,[t],!0),l=pe(J(s,"float32"),u);i([o,l]);let p=Ze(R(l,o));return{value:he(p,[t]),gradFunc:(d,f)=>{let[h,g]=f,x=Rs(d.shape,[t]);return[R(L(d,x),pe(J(h,"float32"),mr(g))),R(L(d,x),pe(mr(g),J(h,"float32")))]}}})(r,e)}function VY(r,e,t,n=0,o=ir.SUM_BY_NONZERO_WEIGHTS){let s=v(r,"onehotLabels","softmaxCrossEntropy"),i=v(e,"logits","softmaxCrossEntropy"),a=null;if(t!=null&&(a=v(t,"weights","softmaxCrossEntropy")),Wt(s.shape,i.shape,"Error in softmaxCrossEntropy: "),n>0){let l=me(n),p=me(1),c=me(s.shape[1]);s=X(R(s,pe(p,l)),ce(l,c))}let u=KY(s,i);return Xr(u,a,o)}var Z2=_({softmaxCrossEntropy_:VY});function jY(r,e,t,n){let o=v(r,"indices","sparseFillEmptyRows","int32"),s=v(e,"values","sparseFillEmptyRows"),i=v(t,"denseShape","sparseFillEmptyRows","int32"),a=v(n,"defaultValue","sparseFillEmptyRows",s.dtype);if(o.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${o.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);let u={indices:o,values:s,denseShape:i,defaultValue:a},l=N.runKernel(Ku,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}var J2=_({sparseFillEmptyRows_:jY});function HY(r,e,t){let n=v(r,"inputIndices","sparseReshape","int32"),o=v(e,"inputShape","sparseReshape","int32"),s=v(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(o.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${o.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);let i={inputIndices:n,inputShape:o,newShape:s},a=N.runKernel(Qi,i);return{outputIndices:a[0],outputShape:a[1]}}var e1=_({sparseReshape_:HY});function qY(r,e,t){let n=v(r,"data","sparseSegmentMean"),o=v(e,"indices","sparseSegmentMean","int32"),s=v(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return N.runKernel(Vu,i)}var t1=_({sparseSegmentMean_:qY});function XY(r,e,t){let n=v(r,"data","sparseSegmentSum"),o=v(e,"indices","sparseSegmentSum","int32"),s=v(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${o.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);let i={data:n,indices:o,segmentIds:s};return N.runKernel(ju,i)}var r1=_({sparseSegmentSum_:XY});function YY(r,e,t,n,o,s,i,a){let u=v(r,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);let l=v(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");let p={separator:t,nGramWidths:n,leftPad:o,rightPad:s,padWidth:i,preserveShortSequences:a},c={data:u,dataSplits:l},m=N.runKernel(qu,c,p);return{nGrams:m[0],nGramsSplits:m[1]}}var n1=_({stringNGrams_:YY});function QY(r,e,t=!0){let n=v(r,"input","stringSplit","string"),o=v(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(o.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${o.shape}`);let s={skipEmpty:t},i={input:n,delimiter:o},a=N.runKernel(_c,i,s);return{indices:a[0],values:a[1],shape:a[2]}}var o1=_({stringSplit_:QY});function ZY(r,e){let t=v(r,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");let o={input:t};return N.runKernel(Ac,o,n)}var s1=_({stringToHashBucketFast_:ZY});var IKe={fft:Jl,ifft:rl,rfft:ep,irfft:Zd},_Ke={hammingWindow:C2,hannWindow:jb,frame:Hb,stft:v2},Fn={flipLeftRight:w2,grayscaleToRGB:_2,resizeNearestNeighbor:$2,resizeBilinear:B2,rotateWithOffset:A2,cropAndResize:S2,nonMaxSuppression:N2,nonMaxSuppressionAsync:M2,nonMaxSuppressionWithScore:F2,nonMaxSuppressionWithScoreAsync:E2,nonMaxSuppressionPadded:R2,nonMaxSuppressionPaddedAsync:L2,threshold:O2,transform:z2},a1={bandPart:G2,gramSchmidt:U2,qr:K2},eVe={absoluteDifference:V2,computeWeightedLoss:Xr,cosineDistance:j2,hingeLoss:H2,huberLoss:q2,logLoss:X2,meanSquaredError:Y2,sigmoidCrossEntropy:Q2,softmaxCrossEntropy:Z2},tf={sparseFillEmptyRows:J2,sparseReshape:e1,sparseSegmentMean:t1,sparseSegmentSum:r1},Qb={stringNGrams:n1,stringSplit:o1,stringToHashBucketFast:s1};var tn=class extends Nb{minimize(e,t=!1,n){let{value:o,grads:s}=this.computeGradients(e,n);if(n!=null){let i=n.map(a=>({name:a.name,tensor:s[a.name]}));this.applyGradients(i)}else this.applyGradients(s);return Fe(s),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Fb(e,t)}dispose(){this.iterations_!=null&&Fe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:me(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}};Object.defineProperty(tn,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var ap=class extends tn{constructor(e,t,n=null){super();this.learningRate=e;this.rho=t;this.epsilon=n;this.accumulatedGrads=[];this.accumulatedUpdates=[];n==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n],i=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${n}/accum_grad`,variable:G(()=>Ne(s).variable(i))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${n}/accum_var`,variable:G(()=>Ne(s).variable(i))});let a=Array.isArray(e)?e[o].tensor:e[n];if(a==null)return;let u=this.accumulatedGrads[o].variable,l=this.accumulatedUpdates[o].variable;G(()=>{let p=X(R(u,this.rho),R(qe(a),1-this.rho)),c=R(ce(Lt(X(l,this.epsilon)),Lt(X(u,this.epsilon))),a),m=X(R(l,this.rho),R(qe(c),1-this.rho));u.assign(p),l.assign(m);let d=X(R(c,-this.learningRate),s);s.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Fe(this.accumulatedGrads.map(e=>e.variable)),Fe(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){let e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=e.length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedUpdates=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}};ap.className="Adadelta";Dn(ap);var ip=class extends tn{constructor(e,t=.1){super();this.learningRate=e;this.initialAccumulatorValue=t;this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n];if(this.accumulatedGrads[o]==null){let u=!1;this.accumulatedGrads[o]={originalName:`${n}/accumulator`,variable:G(()=>Aa(s.shape,this.initialAccumulatorValue).variable(u))}}let i=Array.isArray(e)?e[o].tensor:e[n];if(i==null)return;let a=this.accumulatedGrads[o].variable;G(()=>{let u=X(a,qe(i));a.assign(u);let l=X(R(ce(i,Lt(X(u,N.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Fe(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulatedGrads=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}};ip.className="Adagrad";Dn(ip);var up=class extends tn{constructor(e,t,n,o=null){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=o;this.accumulatedFirstMoment=[];this.accumulatedSecondMoment=[];G(()=>{this.accBeta1=me(t).variable(),this.accBeta2=me(n).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);G(()=>{let n=pe(1,this.accBeta1),o=pe(1,this.accBeta2);t.forEach((s,i)=>{let a=N.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:G(()=>Ne(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${s}/v`,variable:G(()=>Ne(a).variable(u))});let l=Array.isArray(e)?e[i].tensor:e[s];if(l==null)return;let p=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,m=X(R(p,this.beta1),R(l,1-this.beta1)),d=X(R(c,this.beta2),R(qe(l),1-this.beta2)),f=ce(m,n),h=ce(d,o);p.assign(m),c.assign(d);let g=X(R(ce(f,X(Lt(h),this.epsilon)),-this.learningRate),a);a.assign(g)}),this.accBeta1.assign(R(this.accBeta1,this.beta1)),this.accBeta2.assign(R(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Fe(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),G(()=>{this.accBeta1.assign(Mn(this.beta1,this.iterations_+1)),this.accBeta2.assign(Mn(this.beta2,this.iterations_+1))});let t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}};up.className="Adam";Dn(up);var lp=class extends tn{constructor(e,t,n,o=null,s=0){super();this.learningRate=e;this.beta1=t;this.beta2=n;this.epsilon=o;this.decay=s;this.accumulatedFirstMoment=[];this.accumulatedWeightedInfNorm=[];G(()=>{this.iteration=me(0).variable(),this.accBeta1=me(t).variable()}),o==null&&(this.epsilon=N.backend.epsilon())}applyGradients(e){let t=Array.isArray(e)?e.map(n=>n.name):Object.keys(e);G(()=>{let n=pe(1,this.accBeta1),o=ce(-this.learningRate,X(R(this.iteration,this.decay),1));t.forEach((s,i)=>{let a=N.registeredVariables[s],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${s}/m`,variable:Ne(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${s}/v`,variable:Ne(a).variable(u)});let l=Array.isArray(e)?e[i].tensor:e[s];if(l==null)return;let p=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,m=X(R(p,this.beta1),R(l,1-this.beta1)),d=R(c,this.beta2),f=$t(l),h=Qn(d,f);p.assign(m),c.assign(h);let g=X(R(ce(o,n),ce(m,X(h,this.epsilon))),a);a.assign(g)}),this.iteration.assign(X(this.iteration,1)),this.accBeta1.assign(R(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Fe(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Fe(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}};lp.className="Adamax";Dn(lp);var fu=class extends tn{constructor(e){super();this.learningRate=e;this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=Array.isArray(e)?e[o].tensor:e[n];if(s==null)return;let i=N.registeredVariables[n];G(()=>{let a=X(R(this.c,s),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=Vt(me(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}};fu.className="SGD";Dn(fu);var pp=class extends fu{constructor(e,t,n=!1){super(e);this.learningRate=e;this.momentum=t;this.useNesterov=n;this.accumulations=[];this.m=me(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n];if(this.accumulations[o]==null){let u=!1;this.accumulations[o]={originalName:`${n}/momentum`,variable:G(()=>Ne(s).variable(u))}}let i=this.accumulations[o].variable,a=Array.isArray(e)?e[o].tensor:e[n];a!=null&&G(()=>{let u,l=X(R(this.m,i),a);this.useNesterov?u=X(R(this.c,X(a,R(l,this.m))),s):u=X(R(this.c,l),s),i.assign(l),s.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Fe(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=!1;this.accumulations=e.map(n=>({originalName:n.name,variable:n.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}};pp.className="Momentum";Dn(pp);var cp=class extends tn{constructor(e,t=.9,n=0,o=null,s=!1){super();this.learningRate=e;this.decay=t;this.momentum=n;this.epsilon=o;this.accumulatedMeanSquares=[];this.accumulatedMoments=[];this.accumulatedMeanGrads=[];if(this.centered=s,o==null&&(this.epsilon=N.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(n=>n.name):Object.keys(e)).forEach((n,o)=>{let s=N.registeredVariables[n],i=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${n}/rms`,variable:G(()=>Ne(s).variable(i))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${n}/momentum`,variable:G(()=>Ne(s).variable(i))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${n}/mg`,variable:G(()=>Ne(s).variable(i))});let a=Array.isArray(e)?e[o].tensor:e[n];if(a==null)return;let u=this.accumulatedMeanSquares[o].variable,l=this.accumulatedMoments[o].variable;G(()=>{let p=X(R(u,this.decay),R(qe(a),1-this.decay));if(this.centered){let c=this.accumulatedMeanGrads[o].variable,m=X(R(c,this.decay),R(a,1-this.decay)),d=ce(R(a,this.learningRate),Lt(pe(p,X(qe(m),this.epsilon)))),f=X(R(l,this.momentum),d);u.assign(p),c.assign(m),l.assign(f);let h=pe(s,f);s.assign(h)}else{let c=X(R(u,this.decay),R(qe(a),1-this.decay)),m=X(R(l,this.momentum),ce(R(a,this.learningRate),Lt(X(c,this.epsilon))));u.assign(c),l.assign(m);let d=pe(s,m);s.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Fe(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Fe(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Fe(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){let e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);let t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.accumulatedMoments=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(o=>({originalName:o.name,variable:o.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}};cp.className="RMSProp";Dn(cp);var ci=class{static sgd(e){return new fu(e)}static momentum(e,t,n=!1){return new pp(e,t,n)}static rmsprop(e,t=.9,n=0,o=null,s=!1){return new cp(e,t,n,o,s)}static adam(e=.001,t=.9,n=.999,o=null){return new up(e,t,n,o)}static adadelta(e=.001,t=.95,n=null){return new ap(e,t,n)}static adamax(e=.002,t=.9,n=.999,o=null,s=0){return new lp(e,t,n,o,s)}static adagrad(e,t=.1){return new ip(e,t)}};var mp={sgd:ci.sgd,momentum:ci.momentum,adadelta:ci.adadelta,adagrad:ci.adagrad,rmsprop:ci.rmsprop,adamax:ci.adamax,adam:ci.adam};var JY=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function PC(){return new Promise(r=>JY(()=>r()))}var I={};Xe(I,{ERF_A1:()=>p7,ERF_A2:()=>c7,ERF_A3:()=>m7,ERF_A4:()=>d7,ERF_A5:()=>f7,ERF_P:()=>l7,PARALLELIZE_THRESHOLD:()=>Zb,SELU_SCALE:()=>FC,SELU_SCALEALPHA:()=>MC,applyActivation:()=>op,assertAndGetBroadcastShape:()=>Ge,assertAxesAreInnerMostDims:()=>Z5,assertParamsConsistent:()=>e7,assignToTypedArray:()=>T7,axesAreInnerMostDims:()=>oC,calculateShapes:()=>M0,checkEinsumDimSizes:()=>w7,checkPadOnDimRoundingMode:()=>Pt,combineLocations:()=>Y0,complexWithEvenIndex:()=>b7,complexWithOddIndex:()=>y7,computeConv2DInfo:()=>$l,computeConv3DInfo:()=>H0,computeDefaultPad:()=>LI,computeDilation2DInfo:()=>x6,computeOptimalWindowSize:()=>r7,computeOutAndReduceShapes:()=>sC,computeOutShape:()=>t7,computePool2DInfo:()=>RI,computePool3DInfo:()=>T6,convertConv2DDataFormat:()=>q0,decodeEinsumEquation:()=>v7,eitherStridesOrDilationsAreOne:()=>Lr,expandShapeToKeepDim:()=>Rs,exponent:()=>I7,exponents:()=>k7,fromStringArrayToUint8:()=>H7,fromUint8ToStringArray:()=>j7,getAxesPermutation:()=>aC,getBroadcastDims:()=>N0,getComplexWithIndex:()=>x7,getEinsumComputePath:()=>_7,getEinsumPermutation:()=>S7,getFusedBiasGradient:()=>np,getFusedDyActivation:()=>rp,getImageCenter:()=>n7,getInnerMostAxes:()=>J5,getPermuted:()=>s7,getReductionAxes:()=>vt,getReshaped:()=>o7,getReshapedPermuted:()=>a7,getSliceBeginCoords:()=>i7,getSliceSize:()=>u7,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>P7,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>M7,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>F7,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>L7,getSparseReshapeInputOutputMismatchErrorMessage:()=>$7,getSparseReshapeInputOutputMultipleErrorMessage:()=>B7,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>E7,getSparseReshapeNegativeOutputDimErrorMessage:()=>R7,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>U7,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>O7,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>z7,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>G7,getUndoAxesPermutation:()=>Od,isIdentityPermutation:()=>A7,log:()=>FH,mergeRealAndImagArrays:()=>h7,prepareAndValidate:()=>P0,prepareSplitSize:()=>D7,segment_util:()=>RC,shouldFuse:()=>sp,slice_util:()=>Tt,splitRealAndImagArrays:()=>g7,tupleValuesAreOne:()=>Xo,upcastType:()=>Kt,validateInput:()=>Ab,validateUpdateShape:()=>TI,warn:()=>ri});function e7(r,e){let t=r[0].length;r.forEach((o,s)=>{D(o.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),D(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);let n=r[0];r.forEach((o,s)=>{for(let i=0;i<t;i++)D(i===e||o[i]===n[i],()=>`Error in concat${t}D: Shape of tensors[${s}] (${o}) does not match the shape of the rest (${n}) along the non-concatenated axis ${s}.`)})}function t7(r,e){let t=r[0].slice();for(let n=1;n<r.length;n++)t[e]+=r[n][e];return t}var Zb=30;function r7(r){return r<=Zb?r:nc(r,Math.floor(Math.sqrt(r)))}function n7(r,e,t){let n=t*(typeof r=="number"?r:r[0]),o=e*(typeof r=="number"?r:r[1]);return[n,o]}function o7(r,e,t,n=!0){let o=[];if(n)o=o.concat(e.slice(0)),o.push(r[0]/t),o=o.concat(r.slice(1));else{o=o.concat(r[0]);let s=e.length;for(let i=0;i<s;++i)o=o.concat([r[i+1]/e[i],e[i]]);o=o.concat(r.slice(s+1))}return o}function s7(r,e,t=!0){let n=[];if(t){n.push(e);for(let o=e+1;o<r;++o)o<=2*e?(n.push(o),n.push(o-(e+1))):n.push(o)}else{let o=[],s=[];for(let i=1;i<r;++i)i>=e*2+1||i%2==1?s.push(i):o.push(i);n.push(...o),n.push(0),n.push(...s)}return n}function a7(r,e,t,n=!0){let o=[];n?o.push(r[0]/t):o.push(r[0]*t);for(let s=1;s<r.length;++s)s<=e.length?n?o.push(e[s-1]*r[s]):o.push(r[s]/e[s-1]):o.push(r[s]);return o}function i7(r,e){let t=[0];for(let n=0;n<e;++n)t.push(r[n][0]);return t}function u7(r,e,t){let n=r.slice(0,1);for(let o=0;o<t;++o)n.push(r[o+1]-e[o][0]-e[o][1]);return n}var MC=1.7580993408473768,FC=1.0507009873554805;var l7=.3275911,p7=.254829592,c7=-.284496736,m7=1.421413741,d7=-1.453152027,f7=1.061405429;function h7(r,e){if(r.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${e.length}.`);let t=new Float32Array(r.length*2);for(let n=0;n<t.length;n+=2)t[n]=r[n/2],t[n+1]=e[n/2];return t}function g7(r){let e=new Float32Array(r.length/2),t=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)e[n/2]=r[n],t[n/2]=r[n+1];return{real:e,imag:t}}function b7(r){let e=Math.ceil(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=0;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function y7(r){let e=Math.floor(r.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let o=2;o<r.length;o+=4)t[Math.floor(o/4)]=r[o],n[Math.floor(o/4)]=r[o+1];return{real:t,imag:n}}function x7(r,e){let t=r[e*2],n=r[e*2+1];return{real:t,imag:n}}function T7(r,e,t,n){r[n*2]=e,r[n*2+1]=t}function k7(r,e){let t=new Float32Array(r/2),n=new Float32Array(r/2);for(let o=0;o<Math.ceil(r/2);o++){let s=(e?2:-2)*Math.PI*(o/r);t[o]=Math.cos(s),n[o]=Math.sin(s)}return{real:t,imag:n}}function I7(r,e,t){let n=(t?2:-2)*Math.PI*(r/e),o=Math.cos(n),s=Math.sin(n);return{real:o,imag:s}}var EC="->",C7=/->/g,i1=",",u1="...";function v7(r,e){r=r.replace(/\s/g,"");let t=(r.length-r.replace(C7,"").length)/EC.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${EC}").`);let[n,o]=r.split(EC);D(n.indexOf(u1)===-1,()=>`The ellipsis notation ("${u1}") is not supported yet.`);let s=n.split(i1),i=s.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");let a=[];for(let m=0;m<o.length;++m){let d=o[m];if(!s.some(f=>f.indexOf(d)!==-1))throw new Error(`Output subscripts contain the label ${d} not present in the input subscripts.`);a.indexOf(d)===-1&&a.push(d)}for(let m=0;m<n.length;++m){let d=n[m];a.indexOf(d)===-1&&d!==i1&&a.push(d)}let u=new Array(s.length);for(let m=0;m<i;++m){if(new Set(s[m].split("")).size!==s[m].length)throw new Error(`Found duplicate axes in input component ${s[m]}. Support for duplicate axes in input is not implemented yet.`);u[m]=[];for(let d=0;d<s[m].length;++d)u[m].push(a.indexOf(s[m][d]))}let l=a.length,p=o.length,c=[];for(let m=p;m<l;++m)c.push(m);return{allDims:a,summedDims:c,idDims:u}}function S7(r,e){let t=new Array(r);t.fill(-1);for(let o=0;o<e.length;++o)t[e[o]]=o;let n=[];for(let o=0;o<r;++o)t[o]===-1&&n.push(o);return t=t.filter(o=>o!==-1),{permutationIndices:t,expandDims:n}}function w7(r,e,t){let n=new Array(r);for(let o=0;o<t.length;++o){let s=t[o].shape;for(let i=0;i<e[o].length;++i)n[e[o][i]]===void 0?n[e[o][i]]=s[i]:D(n[e[o][i]]===s[i],()=>`Expected dimension ${n[e[o][i]]} at axis ${i} of input shaped ${JSON.stringify(s)}, but got dimension ${s[i]}`)}}function _7(r,e){let t=r,n=[],o=0;r.length===0&&t.push(-1),o=r.length+1;for(let i=0;i<o;++i)n.push([]);let s=[];for(let i=0;i<t.length;++i){let a=t[i],u=N7(e,a);for(let l of u)s.indexOf(l)===-1&&(n[i].push(l),s.push(l))}return{path:t,steps:n}}function A7(r){return r.every((e,t)=>e===t)}function N7(r,e){let t=[];for(let n=0;n<r.length;++n)(r[n].length===0||r[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function D7(r,e,t=0){let n=[];if(typeof e=="number")D(r.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(r.shape[t]/e);else{let o=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);D(o<=1,()=>"There should be only one negative value in split array.");let s=e.indexOf(-1);if(s!==-1){let i=e.reduce((a,u)=>u>0?a+u:a);e[s]=r.shape[t]-i}D(r.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}function P7(r){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${r}`}function M7(r,e){return`indices(${r}, 0) is invalid: ${e} < 0`}function F7(r,e,t){return`indices(${r}, 0) is invalid: ${e} >= ${t}`}function E7(r,e){return`only one output dimension may be -1, not both ${r} and ${e}`}function R7(r,e){return`size ${r} must be non-negative, not ${e}`}function L7(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function B7(r,e){let t=nt(r),n=nt(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${n}. inputShape=${r} outputShape= ${e}`}function $7(r,e){let t=nt(r),n=nt(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${n}. inputShape=${r} outputShape=${e}`}function O7(){return"segment ids must be >= 0"}function z7(){return"segment ids are not increasing"}function G7(r,e){return`Segment id ${r} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function U7(r,e,t){return`Bad: indices[${r}] == ${e} out of range [0, ${t})`}var RC={};Xe(RC,{collectGatherOpShapeInfo:()=>V7,computeOutShape:()=>K7,segOpComputeOptimalWindowSize:()=>W7});function W7(r,e){let t=!1,n;for(r<=Zb?(n=r,t=!0):n=nc(r,Math.floor(Math.sqrt(r)));!t;)n>e||n===r?t=!0:n=nc(r,n+1);return n}function K7(r,e,t){let n=[],o=r.length;for(let s=0;s<o;s++)s!==e?n.push(r[s]):n.push(t);return n}function V7(r,e,t,n){let o=e.shape.length,s=r.shape.length;if(n!==0&&(n<-o||n>o))throw new Error(`Expect batchDims in the range of [-${o}, ${o}], but got ${n}`);if(n<0&&(n+=o),n>s)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${s}).`);if(t<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${t}).`);for(let c=0;c<n;++c)if(r.shape[c]!==e.shape[c])throw new Error(`x.shape[${c}]: ${r.shape[c]} should be equal to indices.shape[${c}]: ${e.shape[c]}.`);let i=r.shape[t],a=[],u=1,l=1,p=1;for(let c=0;c<n;++c)a.push(r.shape[c]),u*=r.shape[c];for(let c=n;c<t;c++)a.push(r.shape[c]),l*=r.shape[c];for(let c=n;c<o;c++)a.push(e.shape[c]);for(let c=t+1;c<s;c++)a.push(r.shape[c]),p*=r.shape[c];return{batchSize:u,sliceSize:p,outerSize:l,dimSize:i,outputShape:a}}function j7(r){try{return r.map(e=>Ec(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function H7(r){return r.map(e=>Qu(e))}var Tr={};Xe(Tr,{nonMaxSuppressionV3Impl:()=>qb,nonMaxSuppressionV4Impl:()=>Xb,nonMaxSuppressionV5Impl:()=>Yb,whereImpl:()=>zb});var Jb={kernelName:ms,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,du(J(t,"float32"),-1))}}};var l1={kernelName:Di,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=qe(J(t,"float32")),o=Lt(pe(me(1),n));return Ze(ce(r,o))}}}};var p1={kernelName:Pi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Lt(pe(qe(J(t,"float32")),1));return ce(r,n)}}}};var c1={kernelName:_n,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Ge(t.shape,n.shape);return{a:()=>{let a=r,u=vt(t.shape,o);return u.length>0&&(a=he(a,u)),L(a,t.shape)},b:()=>{let a=r,u=vt(n.shape,o);return u.length>0&&(a=he(a,u)),L(a,n.shape)}}}};var m1={kernelName:oo,saveAllInputs:!0,gradFunc:(r,e)=>{let t={};return e.forEach((n,o)=>{t[o]=()=>r.clone()}),t}};var d1={kernelName:so,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>Ne(t)}}};var f1={kernelName:Qa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>Ne(t)}}};var h1={kernelName:Ei,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,Lt(pe(me(1),qe(J(t,"float32")))))}}};var g1={kernelName:Ri,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=Lt(X(me(1),qe(J(t,"float32"))));return ce(r,n)}}}};var b1={kernelName:$i,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Ge(t.shape,n.shape);return{a:()=>{let a=X(qe(t),qe(n)),u=R(r,ce(n,a)),l=vt(t.shape,o);return l.length>0&&(u=he(u,l)),L(u,t.shape)},b:()=>{let a=X(qe(t),qe(n)),u=Ze(R(r,ce(t,a))),l=vt(n.shape,o);return l.length>0&&(u=he(u,l)),L(u,n.shape)}}}};var y1={kernelName:Li,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,X(qe(J(t,"float32")),1))}}};var x1={kernelName:Bi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,pe(me(1),qe(J(t,"float32"))))}}};function q7(r,e,t,n,o,s){let i=v(r,"dy","avgPool3dGrad"),a=v(e,"input","avgPool3dGrad"),u=i,l=a,p=!1;a.rank===4&&(p=!0,u=L(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),l=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),D(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),D(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),Pt("avgPool3dGrad",o,s);let c={dy:u,input:l},m={filterSize:t,strides:n,pad:o,dimRoundingMode:s},d=N.runKernel(ac,c,m);return p?L(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var T1=_({avgPool3dGrad_:q7});var k1={kernelName:Eu,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:i,dimRoundingMode:a}=t;return{x:()=>T1(r,n,o,s,i,a)}}};function X7(r,e,t,n,o){let s=v(r,"dy","avgPoolGrad"),i=v(e,"input","avgPoolGrad");D(i.rank===s.rank,()=>`Rank of input (${i.rank}) does not match rank of dy (${s.rank})`);let a=i,u=s,l=!1;i.rank===3&&(l=!0,a=L(i,[1,i.shape[0],i.shape[1],i.shape[2]]),u=L(s,[1,s.shape[0],s.shape[1],s.shape[2]])),D(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),D(a.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${a.rank}.`);let p={dy:u,input:a},c={filterSize:t,strides:n,pad:o},m=N.runKernel(sc,p,c);return l?L(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var I1=_({avgPoolGrad_:X7});var C1={kernelName:ao,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{filterSize:o,strides:s,pad:i}=t;return{x:()=>I1(r,n,o,s,i)}}};var v1={kernelName:io,inputsToSave:["a","b"],gradFunc:(r,e,t)=>{let[n,o]=e,{transposeA:s,transposeB:i}=t;return!s&&!i?{a:()=>Ve(r,o,!1,!0),b:()=>Ve(n,r,!0,!1)}:!s&&i?{a:()=>Ve(r,o,!1,!1),b:()=>Ve(r,n,!0,!1)}:s&&!i?{a:()=>Ve(o,r,!1,!0),b:()=>Ve(n,r,!1,!1)}:{a:()=>Ve(o,r,!0,!0),b:()=>Ve(r,n,!0,!0)}}};var S1={kernelName:ds,gradFunc:(r,e,t)=>{let{blockShape:n,crops:o}=t;return{x:()=>Xl(r,n,o)}}};var w1={kernelName:dD,gradFunc:(r,e,t)=>{let n=t,o=n.inputShape,s=n.shape,i=Array.from(s);for(let u=o.length-1;u>=0;u--)if(o[u]===s[u])i[u]=1;else if(o[u]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${s}].`);let a=[];for(let u=0;u<i.length;u++)i[u]>1&&a.push(u);return{x:()=>he(r,a,!0)}}};var _1={kernelName:Kn,gradFunc:r=>({x:()=>r.clone()})};var A1={kernelName:uo,gradFunc:r=>({x:()=>Ne(r)})};var N1={kernelName:Vn,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{clipValueMin:o,clipValueMax:s}=t;return{x:()=>Ot(Hr(Qo(n,o),Zo(n,s)),r,Ne(r))}}};var D1={kernelName:Lu,inputsToSave:["x"],gradFunc:Jb.gradFunc};var P1={kernelName:fs,saveAllInputs:!0,gradFunc:(r,e,t)=>{let n=e.map(u=>u.shape),{axis:o}=t,s=yr(o,e[0].shape)[0],i=n.map(u=>u[s]);return Ir(r,i,s).map(u=>()=>u)}};var M1={kernelName:lo,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{dilations:s,strides:i,pad:a,dataFormat:u}=t;return D(Xo(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>Uc(n.shape,r,o,i,a,u),filter:()=>qc(n,r,o.shape,i,a,u)}}};var F1={kernelName:po,inputsToSave:["dy","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,{strides:s,pad:i,dataFormat:a,dimRoundingMode:u}=t;return{dy:()=>Yn(r,o,s,i,a,1,u),filter:()=>qc(r,n,o.shape,s,i,a,u)}}};function Y7(r,e,t,n,o){let s=r;r.rank===4&&(s=L(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let i=e;i.rank===4&&(i=L(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),D(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),D(i.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${i.shape}.`),D(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),D(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),D(i.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${i.shape[4]}) must match output depth for filter (${t[4]}).`);let a={x:s,dy:i},u={strides:n,pad:o,filterShape:t};return N.runKernel(pc,a,u)}var E1=_({conv3DBackpropFilter_:Y7});var R1={kernelName:Bu,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s}=t;D(Xo(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[i,a]=e;return{x:()=>Mb(i.shape,r,a,o,s),filter:()=>E1(i,r,a.shape,o,s)}}};var L1={kernelName:co,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(Ze(qd(J(t,"float32"))),r)}}};var B1={kernelName:mo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(Xd(J(t,"float32")),r)}}};var $1={kernelName:ta,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o,exclusive:s,reverse:i}=t;return{x:()=>{let a=aC([o],n.rank),u=Ld(r,o,s,!i);return a!=null&&(u=He(u,a)),u}}}};var O1={kernelName:fo,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let{dilations:n,strides:o,pad:s,dimRoundingMode:i}=t,a=n??[1,1];D(Xo(a),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);let[u,l]=e;return D(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),D(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),D(u.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),D(Lr(o,a),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${a}'.`),Pt("depthwiseConv2d",s,i),{x:()=>Vb(u.shape,r,l,o,s,a,i),filter:()=>Kb(u,r,l.shape,o,s,a,i)}}};var z1={kernelName:$u,inputsToSave:["x","filter"],gradFunc:(r,e,t)=>{let[n,o]=e,s={x:n,filter:o,dy:r},i={x:n,filter:o,dy:r};return{x:()=>N.runKernel(hd,s,t),filter:()=>N.runKernel(gd,i,t)}}};var G1={kernelName:go,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e,n={dy:r,y:t};return{x:()=>N.runKernel(gc,n)}}};var U1={kernelName:Oi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=R(mr(Ze(qe(t))),2/Math.sqrt(Math.PI));return{x:()=>R(r,n)}}};var W1={kernelName:bo,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,t)}}};var K1={kernelName:hs,inputsToSave:["input"],gradFunc:(r,e)=>{let[t]=e;return{input:()=>L(r,t.shape)}}};var V1={kernelName:sa,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,mr(t))}}};var j1={kernelName:yo,gradFunc:r=>({x:()=>Ne(r)})};var H1={kernelName:xo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Ge(t.shape,n.shape);return{a:()=>{let a=ce(r,J(n,"float32")),u=vt(t.shape,o);return u.length>0?L(he(a,u),t.shape):a},b:()=>{let a=R(r,J(t,"float32")),u=vt(n.shape,o);u.length>0&&(a=L(he(a,u),n.shape));let l=qe(n);return Ze(ce(a,J(l,"float32")))}}}};var q1={kernelName:To,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,e,t)=>{let{varianceEpsilon:n}=t,[o,s,i,a]=e,u=a??me(1),l=vt(s.shape,o.shape),p=[];if(s.rank===1){for(let k=0;k<o.shape.length-1;++k)p.push(o.shape[k]);p.push(1)}let c=pe(o,s),m=R(r,u),d=jd(X(i,me(n))),f=R(R(R(d,d),d),me(-.5));return{x:()=>s.rank===1?L(R(R(r,jr(L(d,[1,1,1,s.shape[0]]),p)),u),o.shape):L(R(R(r,d),u),o.shape),mean:()=>{let k=R(R(d,me(-1)),m);return s.rank===1&&(k=he(k,l)),L(k,s.shape)},variance:()=>{let k=R(R(f,c),m);return s.rank===1&&(k=he(k,l)),L(k,s.shape)},scale:()=>{let k=R(c,d),C=R(r,k);return s.rank===1&&(C=he(C,l)),L(C,s.shape)},offset:()=>{let k=r;return s.rank===1&&(k=he(k,l)),L(k,s.shape)}}}};var X1={kernelName:gs,inputsToSave:["x","indices"],gradFunc:(r,e,t)=>{let[n,o]=e,{axis:s}=t,i=yr(s,n.shape)[0];return{x:()=>{let u=n.shape,l=o.size,p=u.slice(0,i),c=p.length,m=u.slice(s,u.length).slice(1),d=m.length,f=Y1(0,c),h=Y1(c+1,c+1+d),g=Q1([p,[l],m]),x=L(r,g),y=L(o,[l]),T=Q1([[c],f,h]),k=He(x,T),C=AC(k,y,n.shape[i]),A=Od(T);return C=He(C,A),C},indices:()=>o}}};function Y1(r,e){let t=[];for(let n=r;n<e;++n)t.push(n);return t}function Q1(r){let e=[];for(let t=0;t<r.length;++t)for(let n=0;n<r[t].length;++n)e.push(r[t][n]);return e}var Z1={kernelName:ko,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>Ne(t),b:()=>Ne(n)}}};var J1={kernelName:jn,gradFunc:r=>({x:()=>J(r,"float32")})};var eP={kernelName:zi,gradFunc:r=>({x:()=>Ne(r)})};var tP={kernelName:Gi,gradFunc:r=>({x:()=>Ne(r)})};var rP={kernelName:Ui,gradFunc:r=>({x:()=>Ne(r)})};var nP={kernelName:Io,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{alpha:o}=t,s=nr(n,0);return{x:()=>Ot(s,r,R(r,o))}}};var oP={kernelName:Wi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,X(t,1))}}};var sP={kernelName:Co,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,J(t,"float32"))}}};var aP={kernelName:fD,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t;return{logits:()=>{let s=!0,i=mr(n);return pe(r,R(he(r,o,s),i))}}}};function Q7(r,e,t,n=5,o=1,s=1,i=.5){let a={x:r,y:e,dy:t},u={depthRadius:n,bias:o,alpha:s,beta:i};return N.runKernel(Tc,a,u)}var iP=_({localResponseNormalizationBackprop_:Q7});var uP={kernelName:Gu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{depthRadius:s,bias:i,alpha:a,beta:u}=t;return{x:()=>iP(n,o,r,s,i,a,u)}}};function ey(r,e,t,n){return e.rank<t.rank&&(e=L(e,Rs(e.shape,n))),r.rank<t.rank&&(r=L(r,Rs(r.shape,n))),{x:()=>R(r,J(Vr(t,e),r.dtype))}}var LC={kernelName:vo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{reductionIndices:o}=n,s=e[0],i=e[1],a=yr(o,s.shape),u=ey(r,i,s,a);return{x:()=>u.x()}}};var lP={kernelName:So,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>R(r,J(Qo(t,n),"float32")),b:()=>R(r,J(Bd(t,n),"float32"))}}};function Z7(r,e,t,n,o,s,i){let a=v(r,"dy","maxPool3dGrad"),u=v(e,"input","maxPool3dGrad"),l=v(t,"output","maxPool3dGrad"),p=a,c=u,m=l,d=!1;u.rank===4&&(d=!0,p=L(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=L(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),m=L(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),D(p.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${p.rank}.`),D(c.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),D(m.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${m.rank}.`),Pt("maxPool3dGrad",s,i);let f={dy:p,input:c,output:m},h={filterSize:n,strides:o,pad:s,dimRoundingMode:i},g=N.runKernel(Ic,f,h);return d?L(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}var pP=_({maxPool3dGrad_:Z7});var cP={kernelName:Uu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=t;return{x:()=>pP(r,n,o,s,i,a,u)}}};function J7(r,e,t,n,o,s,i){let a=v(r,"dy","maxPoolGrad"),u=v(e,"input","maxPoolGrad"),l=v(t,"output","maxPoolGrad");D(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`),D(a.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${a.rank}.`),D(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),Pt("maxPoolGrad",s,i);let p={dy:a,input:u,output:l},c={filterSize:n,strides:o,pad:s,dimRoundingMode:i};return N.runKernel(kc,p,c)}var mP=_({maxPoolGrad_:J7});var dP={kernelName:wo,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n,o]=e,{filterSize:s,strides:i,pad:a}=t;return{x:()=>mP(r,n,o,s,i,a)}}};var fP={kernelName:_o,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{axis:o}=t,s=yr(o,n.shape),a=sC(n.shape,s)[1],u=nt(a);return{x:()=>{let p=n.shape.slice();s.forEach(d=>{p[d]=1});let c=L(r,p);return ce(R(c,dr(n.shape,"float32")),u)}}}};var hP={kernelName:Ao,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,e,t)=>{let n=t,{axis:o}=n,[s,i]=e,a=yr(o,s.shape),u=ey(r,i,s,a);return{x:()=>u.x()}}};var gP={kernelName:No,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e;return{a:()=>R(r,J(Zo(t,n),"float32")),b:()=>R(r,J(nr(t,n),"float32"))}}};var bP={kernelName:Do,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(i=>i[0]);return{x:()=>ze(r,s,n.shape)}}};var yP={kernelName:Vi,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Ge(t.shape,n.shape);return{a:()=>{let a=vt(t.shape,o);return a.length>0?L(he(r,a),t.shape):r},b:()=>{let a=R(r,Ze(pu(ce(t,n)))),u=vt(n.shape,o);return u.length>0?L(he(a,u),n.shape):a}}}};var xP={kernelName:Po,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Ge(t.shape,n.shape);return{a:()=>{let a=R(r,J(n,"float32")),u=vt(t.shape,o);return u.length>0?L(he(a,u),t.shape):a},b:()=>{let a=R(r,J(t,"float32")),u=vt(n.shape,o);return u.length>0?L(he(a,u),n.shape):a}}}};var TP={kernelName:bs,gradFunc:r=>({x:()=>Ze(r)})};var kP={kernelName:ha,inputsToSave:["indices"],gradFunc:(r,e)=>{let t=e[0];return{indices:()=>xt(t.shape,"float32")}}};var IP={kernelName:ys,gradFunc:r=>({x:()=>Ne(r)})};var CP={kernelName:xs,saveAllInputs:!0,gradFunc:(r,e,t)=>{let{axis:n}=t;return Or(r,n).map(s=>()=>s)}};var BC={kernelName:Mo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let n=e[0],{paddings:o}=t,s=o.map(i=>i[0]);return{x:()=>ze(r,s,n.shape)}}};var vP={kernelName:Fo,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,e)=>{let[t,n,o]=e,s=t,i=n,a=Ge(s.shape,i.shape);return{a:()=>{let p=J(i,"float32"),c=R(r,R(p,Mn(s,pe(p,me(1))))),m=vt(s.shape,a);return m.length>0&&(c=he(c,m)),L(c,s.shape)},b:()=>{let p=nr(s,0),c=Ot(p,$r(s),Ne(s)),m=R(r,R(o,c)),d=vt(i.shape,a);return d.length>0&&(m=he(m,d)),L(m,i.shape)}}}};var SP={kernelName:Eo,inputsToSave:["x","alpha"],gradFunc:(r,e)=>{let[t,n]=e,o=nr(t,0);return{x:()=>Ot(o,r,R(r,n)),alpha:()=>{let s=Ot(o,Ne(r),R(r,t)),i=vt(n.shape,r.shape);return i.length>0&&(s=he(s,i)),L(s,n.shape)}}}};var wP={kernelName:ho,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Ge(t.shape,n.shape);return{a:()=>{let a=ce(r,J(n,"float32")),u=vt(t.shape,o);return u.length>0?L(he(a,u),t.shape):a},b:()=>{let a=R(r,J(t,"float32")),u=vt(n.shape,o);u.length>0&&(a=L(he(a,u),n.shape));let l=qe(n);return Ze(ce(a,J(l,"float32")))}}}};var _P={kernelName:Hi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,Ze(qe(t)))}}};var AP={kernelName:Bo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e,n=R(Zo(t,6),du(t));return{x:()=>R(r,J(n,"float32"))}}};var NP={kernelName:Ro,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,J(du(t),"float32"))}}};var DP={kernelName:Ts,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>L(r,t.shape)}}};var PP={kernelName:Lo,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(wc,o,t)}}};var MP={kernelName:ei,inputsToSave:["images"],gradFunc:(r,e,t)=>{let[n]=e,o={dy:r,images:n};return{images:()=>N.runKernel(Sc,o,t)}}};var FP={kernelName:ba,gradFunc:(r,e,t)=>{let{dims:n}=t,o=yr(n,r.shape);return{x:()=>xr(r,o)}}};var EP={kernelName:ya,gradFunc:r=>({x:()=>Ne(r)})};var RP={kernelName:$o,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>Ze(ce(r,R(Mn(t,1.5),2)))}}};var LP={kernelName:ks,inputsToSave:["condition"],gradFunc:(r,e)=>{let[t]=e;return{condition:()=>J(Ne(t),"float32"),t:()=>R(r,J(t,r.dtype)),e:()=>R(r,J(Hl(t),r.dtype))}}};var BP={kernelName:qi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>{let n=nr(t,me(0)),o=me(MC),s=me(FC),i=R(r,s),a=R(R(r,o),mr(J(t,"float32")));return Ot(n,i,a)}}}};var $P={kernelName:zo,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,R(t,pe(me(1),t)))}}};var OP={kernelName:Xi,gradFunc:r=>({x:()=>Ne(r)})};var zP={kernelName:Oo,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(Wl(J(t,"float32")),r)}}};var GP={kernelName:Ta,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(Rd(J(t,"float32")),r)}}};var UP={kernelName:Is,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{begin:o,size:s}=t,i=n.shape,[a,u]=II(n,o,s),l=[];for(let p=0;p<r.rank;p++)l.push([a[p],i[p]-a[p]-u[p]]);return{x:()=>Pn(r,l)}}};var WP={kernelName:Wo,outputsToSave:[!0],gradFunc:(r,e,t)=>{let[n]=e,{dim:o}=t,s=!0,i=R(r,n);return{logits:()=>pe(i,R(he(i,[o],s),n))}}};var KP={kernelName:Yi,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,cn(t))}}};var $C={kernelName:Cs,gradFunc:(r,e,t)=>{let{blockShape:n,paddings:o}=t;return{x:()=>Gl(r,n,o)}}};var OC={kernelName:vs,gradFunc:(r,e,t)=>{let{axis:n}=t;return{x:()=>lt(r,n)}}};var VP={kernelName:Go,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,R(Lt(J(t,"float32")),2))}}};var jP={kernelName:ti,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(r,R(J(t,"float32"),2))}}};var HP={kernelName:Ko,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=me(2);return{a:()=>R(r,R(o,pe(t,n))),b:()=>R(r,R(o,pe(n,t)))}}};var qP={kernelName:_s,gradFunc:r=>({x:()=>Ne(r)})};var XP={kernelName:Vo,inputsToSave:["a","b"],gradFunc:(r,e)=>{let[t,n]=e,o=Ge(t.shape,n.shape);return{a:()=>{let a=r,u=vt(t.shape,o);return u.length>0&&(a=he(a,u)),L(a,t.shape)},b:()=>{let a=r,u=vt(n.shape,o);return u.length>0&&(a=he(a,u)),L(Ze(a),n.shape)}}}};var YP={kernelName:Uo,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,o=n.shape.slice(),{axis:s}=t;yr(s,n.shape).forEach(l=>{o[l]=1});let a=L(r,o),u=R(a,dr(n.shape,"float32"));return{x:()=>u}}};var QP={kernelName:Ia,inputsToSave:["x"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>ce(r,qe(Wl(t)))}}};var ZP={kernelName:jo,outputsToSave:[!0],gradFunc:(r,e)=>{let[t]=e;return{x:()=>R(pe(me(1),qe(t)),r)}}};var JP={kernelName:An,inputsToSave:["x"],gradFunc:(r,e,t)=>{let[n]=e,{reps:o}=t;return{x:()=>{let i=Ne(n);if(n.rank===1)for(let a=0;a<o[0];++a)i=X(i,ze(r,[a*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)i=X(i,ze(r,[a*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)i=X(i,ze(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let a=0;a<o[0];++a)for(let u=0;u<o[1];++u)for(let l=0;l<o[2];++l)for(let p=0;p<o[3];++p)i=X(i,ze(r,[a*n.shape[0],u*n.shape[1],l*n.shape[2],p*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return i}}}};var eM={kernelName:Ho,gradFunc:(r,e,t)=>{let n=t,{perm:o}=n,s=Od(o);return{x:()=>He(r,s)}}};var tM={kernelName:Ss,gradFunc:(r,e,t)=>{let n=t,{axis:o}=n;return{value:()=>fr(r,o)}}};var rM={kernelName:Xu,inputsToSave:["segmentIds"],gradFunc:(r,e)=>{let[t]=e;return{x:()=>eQ(r,t)}}};function eQ(r,e){let t=Qn(e,Ne(e)),n=ii(r,t),o=Qo(e,me(0,"int32")),s=n.rank-o.rank;for(let a=0;a<s;++a)o=Nr(o,a+1);o=Hr(o,dr(n.shape,"bool"));let i=Ne(n);return Ot(o,n,i)}var nM={kernelName:ws,gradFunc:r=>({x:()=>Ne(r)})};var tQ=[Jb,l1,p1,c1,m1,d1,f1,h1,g1,b1,y1,x1,k1,C1,v1,S1,w1,_1,A1,N1,D1,P1,F1,M1,R1,L1,B1,$1,O1,z1,wP,G1,U1,W1,K1,V1,H1,j1,q1,X1,Z1,J1,eP,tP,rP,nP,oP,sP,aP,uP,LC,LC,lP,cP,dP,fP,hP,gP,bP,yP,xP,TP,kP,IP,CP,BC,BC,vP,SP,_P,AP,NP,DP,PP,MP,FP,EP,RP,LP,BP,$P,OP,zP,GP,UP,WP,KP,$C,$C,OC,OC,VP,HP,jP,qP,XP,YP,QP,ZP,JP,eM,tM,rM,nM];for(let r of tQ)gD(r);var lM={};Xe(lM,{maxNorm:()=>nQ,minMaxNorm:()=>aQ,nonNeg:()=>sQ,unitNorm:()=>oQ});var zC;function hr(){return zC==null&&(zC=j0().epsilon()),zC}function fn(){return"channelsLast"}var Zn=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,Zn.prototype)}},rn=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,rn.prototype)}},O=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,O.prototype)}},De=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,De.prototype)}},rf=class extends Error{constructor(e){super(e);Object.setPrototypeOf(this,rf.prototype)}};function $s(r,e){if(Array.isArray(r)){let t=[];for(let n=0;n<e;n++)t=t.concat(r);return t}else{let t=new Array(e);return t.fill(r),t}}function Jo(r,e){if(!r)throw new rf(e)}function GC(r,e){let t=0;for(let n of r)n===e&&t++;return t}function Pr(r){return r.length===1?r[0]:r}function St(r){return Array.isArray(r)?r:[r]}function Os(r){let t=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function hu(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}var zs={};function Xc(r){if(r==null)return null;let e={};return e.className=r.getClassName(),e.config=r.getConfig(),e}function UC(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(e=>UC(e));else{let e=Object.keys(r);for(let t of e){let n=r[t];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[t]=n.value:UC(n))}}}function mi(r,e={},t={},n="object",o=!1){if(typeof r=="string"){let s=r,i;if(s in t)i=t[s];else if(s in zs)i=zs[s];else if(i=e[s],i==null)throw new O(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}else{let s=r;if(s.className==null||s.config==null)throw new O(`${n}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);let i=s.className,a,u;if(i in t?[a,u]=t[i]:i in zs?[a,u]=zs.className:i in e&&([a,u]=e[i]),a==null)throw new O(`Unknown ${n}: ${i}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let l={};for(let d of Object.keys(zs))l[d]=zs[d];for(let d of Object.keys(t))l[d]=t[d];let p=s.config;p.customObjects=l;let c={...zs};for(let d of Object.keys(t))zs[d]=t[d];UC(s.config);let m=u(a,s.config,t,o);return zs={...c},m}else{let l={...zs};for(let c of Object.keys(t))zs[c]=t[c];let p=new a(s.config);return zs={...l},p}}}function rQ(r,e){return r<e?-1:r>e?1:0}function nf(r,e){return-1*rQ(r,e)}function Gs(r){if(r==null)return r;let e=[];for(let t of r)e.indexOf(t)===-1&&e.push(t);return e}function oM(r){if(r==null)throw new O(`Invalid value in obj: ${JSON.stringify(r)}`);for(let e in r)if(r.hasOwnProperty(e))return!1;return!0}function di(r,e,t){if(t!=null&&r.indexOf(t)<0)throw new O(`${t} is not a valid ${e}.  Valid values are ${r} or null/undefined.`)}function ty(r,e,t=0,n=1/0){return Jo(t>=0),Jo(n>=t),Array.isArray(r)&&r.length>=t&&r.length<=n&&r.every(o=>typeof o===e)}function or(r,e){Array.isArray(r)?(b.assert(r.length>0,()=>`${e} is unexpectedly an empty array.`),r.forEach((t,n)=>or(t,`element ${n+1} of ${e}`))):b.assert(Number.isInteger(r)&&r>0,()=>`Expected ${e} to be a positive integer, but got ${sM(r)}.`)}function sM(r){return r===null?"null":Array.isArray(r)?"["+r.map(e=>sM(e)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function aM(r,e,t){let n=t!=null?t():b.now(),o;return(...i)=>{let a=t!=null?t():b.now();return a-n<e||(n=a,o=r(...i)),o}}function ry(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}function WC(r,e){return G(()=>Lt(he(R(r,r),e,!0)))}var Yc=class extends re.Serializable{getConfig(){return{}}},of=class extends Yc{constructor(e){super();this.defaultMaxValue=2;this.defaultAxis=0;this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return G(()=>{let t=WC(e,this.axis),n=Br(t,0,this.maxValue);return R(e,ce(n,X(hr(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};of.className="MaxNorm";re.registerClass(of);var sf=class extends Yc{constructor(e){super();this.defaultAxis=0;this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return G(()=>ce(e,X(hr(),WC(e,this.axis))))}getConfig(){return{axis:this.axis}}};sf.className="UnitNorm";re.registerClass(sf);var af=class extends Yc{apply(e){return qr(e)}};af.className="NonNeg";re.registerClass(af);var uf=class extends Yc{constructor(e){super();this.defaultMinValue=0;this.defaultMaxValue=1;this.defaultRate=1;this.defaultAxis=0;this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return G(()=>{let t=WC(e,this.axis),n=X(R(this.rate,Br(t,this.minValue,this.maxValue)),R(1-this.rate,t));return R(e,ce(n,X(hr(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};uf.className="MinMaxNorm";re.registerClass(uf);var iM={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Xt(r){return Xc(r)}function uM(r,e={}){return mi(r,re.SerializationMap.getMap().classNameMap,e,"constraint")}function Yt(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in iM?iM[r]:r,config:{}};return uM(t)}else return r instanceof Yc?r:uM(r)}function nQ(r){return new of(r)}function oQ(r){return new sf(r)}function sQ(){return new af}function aQ(r){return new uf(r)}var NM={};Xe(NM,{constant:()=>fQ,glorotNormal:()=>kQ,glorotUniform:()=>TQ,heNormal:()=>IQ,heUniform:()=>CQ,identity:()=>yQ,leCunNormal:()=>vQ,leCunUniform:()=>SQ,ones:()=>dQ,orthogonal:()=>wQ,randomNormal:()=>gQ,randomUniform:()=>hQ,truncatedNormal:()=>bQ,varianceScaling:()=>xQ,zeros:()=>mQ});var pM=["channelsFirst","channelsLast"],cM=["nearest","bilinear"],mM=["valid","same","causal"],dM=["max","avg"],fM=["sum","mul","concat","ave"];var Qc=new Map;function jt(r){di(pM,"DataFormat",r)}function hM(r){di(cM,"InterpolationFormat",r)}function hn(r){di(mM,"PaddingMode",r)}function KC(r){di(dM,"PoolMode",r)}var lf=[],gM="/";function Pa(r,e){lf.push(r);try{let t=e();return lf.pop(),t}catch(t){throw lf.pop(),t}}function iQ(){return lf.length===0?"":lf.join(gM)+gM}function ny(r){if(!bM(r))throw new Error("Not a valid tensor name: '"+r+"'");return iQ()+r}function oy(r){if(!bM(r))throw new Error("Not a valid tensor name: '"+r+"'");Qc.has(r)||Qc.set(r,0);let e=Qc.get(r);if(Qc.set(r,Qc.get(r)+1),e>0){let t=`${r}_${e}`;return Qc.set(t,1),t}else return r}var uQ=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function bM(r){return!!r.match(uQ)}function yM(r){return r===parseInt(r.toString(),10)}function Us(r,e,t){e==null&&(e=0),t==null&&(t=r.length);let n=1;for(let o=e;o<t;++o)n*=r[o];return n}function dp(r){if(r.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n<e&&(e=n)}return e}function Ma(r){if(r.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<r.length;t++){let n=r[t];n>e&&(e=n)}return e}function nn(r,e){if(e<r)throw new O(`end (${e}) < begin (${r}) is forbidden.`);let t=[];for(let n=r;n<e;++n)t.push(n);return t}function fp(r,e){return J(r,e)}function gu(r,e=-1){let t=r.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),L(r,t)}function xM(r,e){return G(()=>{if(r.shape.length!==2)throw new O(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let t=gu(r,1);return ay(t,[1,e,1])})}function TM(r){let e=[Us(r.shape)];return L(r,e)}function kM(r){if(r.rank<=1)throw new O(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let e=[r.shape[0],Us(r.shape,1)];return L(r,e)}function bu(r,e,t){return G(()=>{switch(r.rank){case 1:return Yd(r,e,t);case 2:return $b(r,[e,0],[t,r.shape[1]]);case 3:return Qd(r,[e,0,0],[t,r.shape[1],r.shape[2]]);case 4:return Hc(r,[e,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3]]);case 5:return ze(r,[e,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return ze(r,[e,0,0,0,0,0],[t,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new O(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function VC(r,e,t){return G(()=>{switch(r.rank){case 1:return Yd(r,e,t);case 2:return $b(r,[0,e],[r.shape[0],t]);case 3:return Qd(r,[0,0,e],[r.shape[0],r.shape[1],t]);case 4:return Hc(r,[0,0,0,e],[r.shape[0],r.shape[1],r.shape[2],t]);default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function pf(r,e,t,n){return G(()=>{switch(r.rank){case 1:return Yd(r,e,t);case 2:switch(n){case 1:return bu(r,e,t);case 2:return VC(r,e,t);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return bu(r,e,t);case 2:return Qd(r,[0,e,0],[r.shape[0],t,r.shape[2]]);case 3:return VC(r,e,t);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return bu(r,e,t);case 2:return Hc(r,[0,e,0,0],[r.shape[0],t,r.shape[2],r.shape[3]]);case 3:return Hc(r,[0,0,e,0],[r.shape[0],r.shape[1],t,r.shape[3]]);case 4:return VC(r,e,t);default:throw new O(`The axis is not within the rank of the tensor ${n}`)}default:throw new O(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Zc(r,e=-1){let t;return e<0&&(t=r[0].rank,t!==0?e=t:e=0),e===r[0].rank&&(e=-1),lt(r,e)}function jC(r,e){switch(r.rank){case 1:return WI([r,e]);case 2:return KI([r,e],0);case 3:return VI([r,e],0);case 4:return jI([r,e],0);default:throw new O(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function ay(r,e){if(Array.isArray(e)||(e=[e]),r.rank!==e.length)throw new O(`The length of input n (${e.length}) does not match the number of dimensions in input x (${r.rank})`);return jr(r,e)}function Jc(r,e=0,t=1,n,o){return Bb(r,e,t,n,o)}function Ws(r,e,t,n){if(r.rank<2||e.rank<2)throw new De(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${e.shape}`);if(e.rank>=3){let o=r.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(o!==s)throw new De(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${e.shape}`)}if(r.rank===2&&e.rank===2){let o=!1,s=!1;return Ls.matMul({a:r,b:e,transposeA:o,transposeB:s,bias:n?HC(r.rank,n,fn()):null,activation:t})}else{let o=r.shape.slice(),s=o.pop();r=L(r,[-1,s]);let i=e.shape.slice(),a=i.pop(),u=i.pop(),l=[...i,a],p=Array.from({length:e.rank},(f,h)=>h===0?e.rank-2:h<=e.rank-2?h-1:h);e=L(He(e,p),[u,-1]);let c=[...o,...l],m=!1,d=!1;return L(Ls.matMul({a:r,b:e,transposeA:m,transposeB:d,bias:n?HC(r.rank,n,fn()):null,activation:t}),c)}}function iy(r,e,t){return G(()=>(Array.isArray(e)?e=zt(e,"int32"):e=J(e,"int32"),ii(r,e,t)))}function hp(r){return R(r,r)}function HC(r,e,t){let n=e.shape;if(e.rank!==1&&e.rank!==r)throw new O(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${r}`);if(r===5){if(t==="channelsFirst")return n.length===1?L(e,[1,n[0],1,1,1]):L(e,[1,n[3],n[0],n[1],n[2]]);if(t==="channelsLast")return n.length===1?L(e,[1,1,1,1,n[0]]):L(e,[1].concat(n))}else if(r===4){if(t==="channelsFirst")return n.length===1?L(e,[1,n[0],1,1]):L(e,[1,n[2],n[0],n[1]]);if(t==="channelsLast")return n.length===1?L(e,[1,1,1,n[0]]):L(e,[1].concat(n))}else if(r===3){if(t==="channelsFirst")return n.length===1?L(e,[1,n[0],1]):L(e,[1,n[1],n[0]]);if(t==="channelsLast")return n.length===1?L(e,[1,1,n[0]]):L(e,[1].concat(n))}else if(r<3)return e;throw new O(`Unsupported input rank by biasAdd: ${e.rank}`)}function gn(r,e,t){return G(()=>(t==null&&(t=fn()),jt(t),X(r,HC(r.rank,e,t))))}function IM(r,e=1){if(e!==1)throw new De(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return lu(r)}function CM(r){return G(()=>ce(r,X($t(r),1)))}function uy(r,e,t,n){return G(()=>y2(r,e,t,n))}function vM(r){return G(()=>{let e=X(.5,R(.2,r));return Br(e,0,1)})}function nl(r,e,t=!1){return t?r():e()}var SM=["fanIn","fanOut","fanAvg"],wM=["normal","uniform","truncatedNormal"];function lQ(r){di(SM,"FanMode",r)}function pQ(r){di(wM,"Distribution",r)}var En=class extends re.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},cf=class extends En{apply(e,t){return xt(e,t)}};cf.className="Zeros";re.registerClass(cf);var gp=class extends En{apply(e,t){return dr(e,t)}};gp.className="Ones";re.registerClass(gp);var mf=class extends En{constructor(e){super();if(typeof e!="object")throw new O(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new O(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return G(()=>R(me(this.value),dr(e,t)))}getConfig(){return{value:this.value}}};mf.className="Constant";re.registerClass(mf);var df=class extends En{constructor(e){super();this.DEFAULT_MINVAL=-.05;this.DEFAULT_MAXVAL=.05;this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Na(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};df.className="RandomUniform";re.registerClass(df);var ff=class extends En{constructor(e){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new De(`randomNormal does not support dType ${t}.`);return Jc(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};ff.className="RandomNormal";re.registerClass(ff);var hf=class extends En{constructor(e){super();this.DEFAULT_MEAN=0;this.DEFAULT_STDDEV=.05;this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new De(`truncatedNormal does not support dType ${t}.`);return tp(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};hf.className="TruncatedNormal";re.registerClass(hf);var gf=class extends En{constructor(e){super();this.gain=e.gain!=null?e.gain:1}apply(e,t){return G(()=>{if(e.length!==2||e[0]!==e[1])throw new O("Identity matrix initializer can only be used for 2D square matrices.");return R(this.gain,Wc(e[0]))})}getConfig(){return{gain:this.gain}}};gf.className="Identity";re.registerClass(gf);function cQ(r,e="channelsLast"){let t,n;if(jt(e),r.length===2)t=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(e==="channelsFirst"){let o=Us(r,2);t=r[1]*o,n=r[0]*o}else if(e==="channelsLast"){let o=Us(r,0,r.length-2);t=r[r.length-2]*o,n=r[r.length-1]*o}}else{let o=Us(r);t=Math.sqrt(o),n=Math.sqrt(o)}return[t,n]}var on=class extends En{constructor(e){super();if(e.scale<0)throw new O(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,lQ(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,pQ(this.distribution),this.seed=e.seed}apply(e,t){let n=cQ(e),o=n[0],s=n[1],i=this.scale;if(this.mode==="fanIn"?i/=Math.max(1,o):this.mode==="fanOut"?i/=Math.max(1,s):i/=Math.max(1,(o+s)/2),this.distribution==="normal"){let a=Math.sqrt(i);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new De(`${this.getClassName()} does not support dType ${t}.`);return tp(e,0,a,t,this.seed)}else{let a=Math.sqrt(3*i);return Na(e,-a,a,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};on.className="VarianceScaling";re.registerClass(on);var em=class extends on{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return on.className}};em.className="GlorotUniform";re.registerClass(em);var tm=class extends on{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return on.className}};tm.className="GlorotNormal";re.registerClass(tm);var rm=class extends on{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return on.className}};rm.className="HeNormal";re.registerClass(rm);var nm=class extends on{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return on.className}};nm.className="HeUniform";re.registerClass(nm);var om=class extends on{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return on.className}};om.className="LeCunNormal";re.registerClass(om);var sm=class extends on{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return on.className}};sm.className="LeCunNormal";re.registerClass(sm);var bf=class extends En{constructor(e){super();this.DEFAULT_GAIN=1;if(this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new De("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return G(()=>{if(e.length<2)throw new De("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);let n=e[0]>e[1]?[e[1],e[0]]:e,o=Jc(n,0,1,"float32"),s=a1.gramSchmidt(o);return e[0]>e[1]&&(s=He(s)),R(this.gain,s)})}getConfig(){return{gain:this.gain,seed:this.seed}}};bf.className="Orthogonal";re.registerClass(bf);var _M={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function AM(r,e={}){return mi(r,re.SerializationMap.getMap().classNameMap,e,"initializer")}function Mt(r){return Xc(r)}function kt(r){if(typeof r=="string"){let e=r in _M?_M[r]:r;if(e==="GlorotNormal")return new tm;if(e==="GlorotUniform")return new em;if(e==="HeNormal")return new rm;if(e==="HeUniform")return new nm;if(e==="LeCunNormal")return new om;if(e==="LeCunUniform")return new sm;{let t={};return t.className=e,t.config={},AM(t)}}else return r instanceof En?r:AM(r)}function mQ(){return new cf}function dQ(){return new gp}function fQ(r){return new mf(r)}function hQ(r){return new df(r)}function gQ(r){return new ff(r)}function bQ(r){return new hf(r)}function yQ(r){return new gf(r)}function xQ(r){return new on(r)}function TQ(r){return new em(r)}function kQ(r){return new tm(r)}function IQ(r){return new rm(r)}function CQ(r){return new nm(r)}function vQ(r){return new om(r)}function SQ(r){return new sm(r)}function wQ(r){return new bf(r)}var mF={};Xe(mF,{Layer:()=>We,RNN:()=>Ks,RNNCell:()=>pl,activation:()=>QZ,add:()=>a9,alphaDropout:()=>W9,average:()=>i9,averagePooling1d:()=>$v,averagePooling2d:()=>Ov,averagePooling3d:()=>zv,avgPool1d:()=>g9,avgPool2d:()=>y9,avgPool3d:()=>T9,avgPooling1d:()=>b9,avgPooling2d:()=>x9,avgPooling3d:()=>k9,batchNormalization:()=>d9,bidirectional:()=>R9,concatenate:()=>u9,conv1d:()=>UZ,conv2d:()=>WZ,conv2dTranspose:()=>KZ,conv3d:()=>VZ,conv3dTranspose:()=>jZ,convLstm2d:()=>P9,convLstm2dCell:()=>M9,cropping2D:()=>qZ,dense:()=>ZZ,depthwiseConv2d:()=>YZ,dot:()=>m9,dropout:()=>JZ,elu:()=>LZ,embedding:()=>s9,flatten:()=>t9,gaussianDropout:()=>U9,gaussianNoise:()=>G9,globalAveragePooling1d:()=>I9,globalAveragePooling2d:()=>C9,globalMaxPool1d:()=>B9,globalMaxPool2d:()=>$9,globalMaxPooling1d:()=>uF,globalMaxPooling2d:()=>lF,gru:()=>S9,gruCell:()=>w9,input:()=>av,inputLayer:()=>RZ,layerNormalization:()=>f9,leakyReLU:()=>$Z,lstm:()=>_9,lstmCell:()=>A9,masking:()=>K9,maxPool1d:()=>O9,maxPool2d:()=>z9,maxPooling1d:()=>pF,maxPooling2d:()=>cF,maxPooling3d:()=>v9,maximum:()=>l9,minimum:()=>p9,multiply:()=>c9,permute:()=>o9,prelu:()=>OZ,reLU:()=>BZ,repeatVector:()=>r9,reshape:()=>n9,rnn:()=>F9,separableConv2d:()=>HZ,simpleRNN:()=>N9,simpleRNNCell:()=>D9,softmax:()=>zZ,spatialDropout1d:()=>e9,stackedRNNCells:()=>E9,thresholdedReLU:()=>GZ,timeDistributed:()=>L9,upSampling2d:()=>XZ,zeroPadding2d:()=>h9});var _Q=0;function ly(){return _Q++}var py={};function ol(r=""){return r in py||(py[r]=0),py[r]+=1,r+py[r].toString()}function cy(r){return Array.isArray(r)&&Array.isArray(r[0])}function am(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function Oe(r){let e;if(Array.isArray(r)){if(r.length!==1)throw new O(`Expected Tensor length to be 1; got ${r.length}`);e=r[0]}else e=r;return e}function Je(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new O(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function im(r){let e=0;for(let t of r)t.shape.length===0?e+=1:e+=t.shape.reduce((n,o)=>n*o);return e}var PM="Variable",my=class{constructor(e,t="float32",n=PM,o=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=ly(),n=n??PM,this.originalName=ny(n),this.name=oy(this.originalName),this.trainable_=o,this.constraint=s,this.val=NC(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),NQ(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}};function NQ(r,e){if(r.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(e.shape))}function yf(r){return r.map(e=>e.read())}function um(r){r.forEach(e=>{e[0].write(e[1])})}var Ft=class{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}},yn=class{constructor(e,t,n,o,s,i,a){this.dtype=e;this.shape=t;this.sourceLayer=n;this.inputs=o;this.callArgs=s;this.outputTensorIndex=a;this.id=ly(),i!=null&&(this.originalName=ny(i),this.name=oy(this.originalName)),this.rank=t.length}},DQ=0,sl=class{constructor(e,t){this.callArgs=t;this.id=DQ++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(let n of e.inboundLayers)n!=null&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){let e=[];for(let t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},PQ=0,We=class extends re.Serializable{constructor(e={}){super();this._callHook=null;this._addedWeightNames=[];this._stateful=!1;this.id=PQ++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){let n=this.getClassName();t=Os(n)+"_"+ol(n)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let n;if(e.batchInputShape!=null)n=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),n=[s].concat(e.inputShape)}this.batchInputShape=n;let o=e.dtype;o==null&&(o=e.inputDType),o==null&&(o="float32"),this.dtype=o}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new rn(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new O(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Pr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Pr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Zn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Zn(`Layer ${this.name} is not connected, no input to return.`);return Pr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Zn(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Zn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Pr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=St(e),this.inputSpec==null||this.inputSpec.length===0)return;let t=St(this.inputSpec);if(e.length!==t.length)throw new O(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let n=0;n<e.length;n++){let o=e[n],s=t[n];if(s==null)continue;let i=o.rank;if(s.ndim!=null&&i!==s.ndim)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${s.ndim}, found ndim=${i}`);if(s.maxNDim!=null&&i>s.maxNDim)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${s.maxNDim}, found ndim=${i}`);if(s.minNDim!=null&&i<s.minNDim)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${s.minNDim}, found ndim=${i}.`);if(s.dtype!=null&&o.dtype!==s.dtype)throw new O(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${s.dtype}, found dtype=${o.dtype}.`);if(s.axes){let a=o.shape;for(let u in s.axes){let l=Number(u),p=s.axes[u],c=l>=0?a[l]:a[a.length+l];if(p!=null&&[p,null].indexOf(c)===-1)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected axis ${l} of input shape to have value ${p} but got shape ${a}.`)}}if(s.shape!=null)for(let a=0;a<s.shape.length;++a){let u=s.shape[a],l=o.shape[a];if(u!=null&&l!=null&&u!==l)throw new O(`Input ${n} is incompatible with layer ${this.name}: expected shape=${s.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();let n=St(e),o=!0;for(let i of n)if(!(i instanceof yn)){o=!1;break}let s=!0;for(let i of n)if(i instanceof yn){s=!1;break}if(o===s)throw new O("Arguments to apply() must be all SymbolicTensors or all Tensors");return Pa(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);let i=[];for(let a of St(e))i.push(a.shape);this.build(Pr(i)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let i=this.call(e,t),a=St(i),u=[];for(let l of a)n.indexOf(l)!==-1&&(l=l.clone()),u.push(l);if(i=Pr(u),this.activityRegularizer!=null)throw new De("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return i}else{let i=MQ(e),a=this.computeOutputShape(i),u,l=FQ(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?i[0]:i),a!=null&&a.length>0&&Array.isArray(a[0])?u=a.map((p,c)=>new yn(l,p,this,St(e),t,this.name,c)):u=new yn(l,a,this,St(e),t,this.name),this.addInboundNode(e,u,null,null,i,a,t),this._refCount++,this.activityRegularizer!=null)throw new De("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((n,o)=>{n!=null&&e[o]!=null&&e[o]!==n&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Zn(`The layer ${this.name} has never been called and thus has no defined output shape.`);let e=[];for(let t of this.inboundNodes){let n=JSON.stringify(t.outputShapes);e.indexOf(n)===-1&&e.push(n)}if(e.length===1){let t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new Zn(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new rn(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return im(this.weights)}build(e){this.built=!0}getWeights(e=!1){return yf(e?this.trainableWeights:this.weights)}setWeights(e){G(()=>{let t=this.weights;if(t.length!==e.length)throw new O(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;let n=[],o=yf(t);for(let s=0;s<o.length;++s){let i=o[s],a=t[s],u=e[s];if(!b.arraysEqual(i.shape,u.shape))throw new O(`Layer weight shape ${i.shape} not compatible with provided weight shape ${u.shape}`);n.push([a,u])}um(n)})}addWeight(e,t,n,o,s,i,a,u){if(this._addedWeightNames.indexOf(e)!==-1)throw new O(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(o=u!=null?u():kt("zeros"));let l=o.apply(t,n),p=new my(l,n,e,i,a);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(p.read())),i==null&&(i=!0),i?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=St(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,n,o,s,i,a=null){let u=St(e);t=St(t),n=St(n),o=St(o),s=am(s),i=am(i);let l=[],p=[],c=[];for(let m of u)l.push(m.sourceLayer),p.push(m.nodeIndex),c.push(m.tensorIndex);new sl({outboundLayer:this,inboundLayers:l,nodeIndices:p,tensorIndices:c,inputTensors:u,outputTensors:t,inputMasks:n,outputMasks:o,inputShapes:s,outputShapes:i},a);for(let m=0;m<t.length;m++)t[m].sourceLayer=this,t[m].nodeIndex=this.inboundNodes.length-1,t[m].tensorIndex=m}getConfig(){let e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount==0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function MQ(r){r=St(r);let e=[];for(let t of r)e.push(t.shape);return Pr(e)}function FQ(r){return"float32"}function qC(r,e,t){if((e==null||t!=null&&t>0)&&(e=r.sourceLayer,t=r.nodeIndex),e.inboundNodes.length===0)return[r];{let n=e.inboundNodes[t];if(n.inboundLayers.length===0)return n.inputTensors;{let o=[];for(let s=0;s<n.inboundLayers.length;s++){let i=n.inputTensors[s],a=n.inboundLayers[s],u=n.nodeIndices[s],l=qC(i,a,u);for(let p of l)o.indexOf(p)===-1&&o.push(p)}return o}}}var fi=class extends We{constructor(e){super({dtype:e.dtype,name:e.name!=null?e.name:ol("input").toString()});if(e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new O("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new O("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new O("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];let o=new yn(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new sl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new O(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};fi.className="InputLayer";re.registerClass(fi);function dy(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new O("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=r.batchShape;r.shape!=null&&e==null&&(e=[null].concat(r.shape));let t=r.dtype;return t==null&&(t="float32"),new fi({batchInputShape:e,name:r.name,dtype:t,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}async function hi(r){if(r==null)return;let e=[],t=[],n=[];for(let o in r){let s=r[o];if(typeof s!="number"){let i=s;e.push(i.data()),t.push(o),n.push(i)}}if(e.length>0){let o=await Promise.all(e);for(let s=0;s<o.length;++s)r[t[s]]=o[s][0];Fe(n)}}function fy(r){if(r!=null)for(let e in r){let t=r[e];typeof t!="number"&&t.dispose()}}var EQ=125,al=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}},XC=class{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(let t of this.callbacks)t.setParams(e)}setModel(e){for(let t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(let n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(let t of this.callbacks)await t.onTrainEnd(e)}},MM=class extends al{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});let n=t.size==null?0:t.size;this.seen+=n;for(let o in t){let s=t[o];if(typeof s=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+s*n;else{let i;o in this.totals?i=this.totals[o]:this.totals[o]=0;let a=G(()=>X(this.totals[o],R(s,n)));this.totals[o]=a,i!=null&&i.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?t[n]=this.totals[n]/this.seen:G(()=>{let o=R(ce(1,this.seen),this.totals[n]);t[n]=o,this.totals[n].dispose(),Vt(t[n])}))}},YC=class extends al{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(let n in t)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){let e=[],t=[],n=[];for(let s in this.history){let i=this.history[s];for(let a=0;a<i.length;++a)if(typeof i[a]!="number"){let u=i[a];e.push(u.data()),t.push(s),n.push(a)}}let o=await Promise.all(e);for(let s=0;s<o.length;++s)this.history[t[s]][n[s]].dispose(),this.history[t[s]][n[s]]=o[s][0]}},QC=class extends al{constructor(e,t){super();this.currentEpoch=0;if(this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||PC,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=EQ),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");b.isNumber(this.yieldEvery)&&(this.maybeWait=aM(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){let o=[];this.yield!=null&&(await hi(n),o.push(this.yield(e,t,n))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await hi(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){let n=[];this.epochEnd!=null&&(await hi(t),n.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){this.batchBegin!=null&&(await hi(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){let n=[];this.batchEnd!=null&&(await hi(t),n.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?n.push(this.nextFrameFunc()):b.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){this.trainBegin!=null&&(await hi(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await hi(e),await this.trainEnd(e))}};function hy(r,e){return r==null&&(r={}),r instanceof al?[r]:Array.isArray(r)&&r[0]instanceof al?r:St(r).map(n=>new QC(n,e))}var Fa=class{constructor(){}static registerCallbackConstructor(e,t){b.assert(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Fa.checkForDuplicate(t),Fa.constructors[e]==null&&(Fa.constructors[e]=[]),Fa.constructors[e].push(t)}static checkForDuplicate(e){for(let t in Fa.constructors)Fa.constructors[+t].forEach(o=>{if(o===e)throw new O("Duplicate callback constructor.")})}static clear(){Fa.constructors={}}static createCallbacks(e){let t=[];for(let n in Fa.constructors){let o=+n;e>=o&&t.push(...Fa.constructors[o])}return t.map(n=>new n)}},xf=Fa;xf.constructors={};function gy(r,e,t,n,o,s,i,a,u){let l=new YC,p=[new MM,...xf.createCallbacks(e)];r!=null&&p.push(...r),p.push(l);let c=new XC(p);return c.setParams({epochs:t,initialEpoch:n,samples:o,steps:s,batchSize:i,verbose:e,doValidation:a,metrics:u}),{callbackList:c,history:l}}function xn(r,e={},t=!1){return mi(r,re.SerializationMap.getMap().classNameMap,e,"layer",t)}function Tf(r,e){return G(()=>{r.dtype!=="float32"&&(r=J(r,"float32"));let t=he(hp(r),e,!0),n=Aa(t.shape,hr()),o=Lt(Qn(t,n));return ce(r,o)})}function gi(r,e){return G(()=>Rt(hp(pe(e,r)),-1))}function lm(r,e){return G(()=>Rt($t(pe(e,r)),-1))}function il(r,e){return G(()=>{let t=pe(r,e),n=Br($t(r),hr(),Number.MAX_VALUE),o=$t(ce(t,n));return R(100,Rt(o,-1))})}function RQ(r,e){return G(()=>{let t=Br(e,hr(),Number.MAX_VALUE),n=$r(X(1,t)),o=Br(r,hr(),Number.MAX_VALUE),s=$r(X(1,o));return Rt(hp(pe(n,s)),-1)})}function LQ(r,e){return G(()=>{let t=Qn(0,pe(1,R(r,e)));return Rt(hp(t),-1)})}function BQ(r,e){return G(()=>{let t=Qn(0,pe(1,R(r,e)));return Rt(t,-1)})}function $Q(r,e){return G(()=>{let t=he(R(r,e),-1),n=en(R(pe(1,r),e),-1);return Qn(0,X(1,pe(n,t)))})}function OQ(r,e){return G(()=>{let t=Math.log(2),n=pe(e,r),o=pe(X(n,ui(R(-2,n))),t);return Rt(o,-1)})}function bp(r,e,t=!1){return G(()=>{if(t)e=Zl(e);else{let n=he(e,e.shape.length-1,!0);e=ce(e,n)}return e=Br(e,hr(),1-hr()),Ze(he(R(J(r,"float32"),$r(e)),e.shape.length-1))})}function pm(r,e,t=!1){return G(()=>{let n=J(pu(TM(r)),"int32");e=Br(e,hr(),1-hr());let o=e.shape,s=L(ou(n,o[o.length-1]),o);return bp(s,e,t)})}function zQ(r,e){if(!b.arraysEqual(r.shape,e.shape))throw new O(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(e.shape)}`);return G(()=>{let t=qr(e),n=Ze($t(e));return X(pe(t,R(e,r)),jl(mr(n)))})}function cm(r,e){return G(()=>{let t;return t=Br(e,hr(),1-hr()),t=$r(ce(t,pe(1,t))),Rt(zQ(r,t),-1)})}function GQ(r,e){return G(()=>{let t=Br(r,hr(),1),n=Br(e,hr(),1);return he(R(r,$r(ce(t,n))),-1)})}function UQ(r,e){return G(()=>{let t=$r(X(hr(),e));return Rt(pe(e,R(r,t)),-1)})}function kf(r,e){return G(()=>{let t=Tf(r,-1),n=Tf(e,-1),o=R(t,n);return Ze(he(o,-1))})}var If={meanSquaredError:gi,meanAbsoluteError:lm,meanAbsolutePercentageError:il,meanSquaredLogarithmicError:RQ,squaredHinge:LQ,hinge:BQ,categoricalHinge:$Q,logcosh:OQ,categoricalCrossentropy:bp,sparseCategoricalCrossentropy:pm,binaryCrossentropy:cm,kullbackLeiblerDivergence:GQ,poisson:UQ,cosineProximity:kf};function by(r){if(typeof r=="string"){if(r in If)return If[r];let e=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new O(e)}else return r}function Cf(r,e){return G(()=>{let t=R(.5,Dr(e)),n=fp(nr(e,t),r.dtype);return Rt(Vr(r,n),-1)})}function vf(r,e){return G(()=>fp(Vr(au(r,-1),au(e,-1)),"float32"))}function EM(r,e){return G(()=>J(he(Hr(Vr(r,1),Vr(e,1))),"float32"))}function WQ(r,e){return G(()=>J(he(Hr(Vr(r,1),Vr(e,0))),"float32"))}function KQ(r,e){return G(()=>J(he(Hr(Vr(r,0),Vr(e,1))),"float32"))}function ZC(r,e){return G(()=>{let t=EM(r,e),n=KQ(r,e),o=X(t,n);return J(Ot(nr(o,0),ce(t,o),0),"float32")})}function RM(r,e){return G(()=>{let t=EM(r,e),n=WQ(r,e),o=X(t,n);return J(Ot(nr(o,0),ce(t,o),0),"float32")})}function yy(r,e){return cm(r,e)}function xy(r,e){return r.rank===e.rank&&(r=dn(r,[r.rank-1])),e=au(e,-1),e.dtype!==r.dtype&&(e=J(e,r.dtype)),J(Vr(r,e),"float32")}var VQ=gi,jQ=gi,HQ=lm,qQ=lm,XQ=il,YQ=il,Sf=bp,QQ=kf,JC=pm,Ty={binaryAccuracy:Cf,categoricalAccuracy:vf,precision:ZC,categoricalCrossentropy:Sf,sparseCategoricalCrossentropy:JC,mse:VQ,MSE:jQ,mae:HQ,MAE:qQ,mape:XQ,MAPE:YQ,cosine:QQ};function LM(r){if(typeof r=="string"&&r in Ty)return Ty[r];if(typeof r!="string"&&r!=null)return r;throw new O(`Unknown metric ${r}`)}function wf(r){if(Jo(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let e;for(let t of Object.keys(If))if(If[t]===r){e=t;break}if(e!==void 0)return e;for(let t of Object.keys(Ty))if(Ty[t]===r){e=t;break}return e!==void 0?e:r.name}}function $M(r){let e={Adagrad:()=>mp.adagrad(.01),Adadelta:()=>mp.adadelta(1,.95,hr()),Adam:()=>mp.adam(.001,.9,.999,hr()),Adamax:()=>mp.adamax(.002,.9,.999,hr(),0),RMSProp:()=>mp.rmsprop(.001,.9,0,hr()),SGD:()=>mp.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,r in e)return e[r]();throw new O(`Unknown Optimizer ${r}`)}var OM=1*1024*1024;function ev(r,e,t=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!tv(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){let n=JSON.stringify(r);n.length>OM&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${OM}.`)}}function tv(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let e=Object.keys(r);for(let t of e)if(typeof t!="string"||!tv(r[t]))return!1;return!0}else if(Array.isArray(r)){for(let e of r)if(!tv(e))return!1;return!0}else return!1;else{let e=typeof r;return e==="string"||e==="number"||e==="boolean"}}function zM(r,e,t,n=console.log){let o=eZ(r),s=["Layer (type)","Output shape","Param #"];o?(e=e||65,t=t||[.45,.85,1]):(e=e||98,t=t||[.33,.55,.67,1]),t[t.length-1]<=1&&(t=t.map(p=>Math.floor(e*p)));let i;if(!o){s.push("Receives inputs"),i=[];for(let p in r.nodesByDepth)i.push(...r.nodesByDepth[p])}n("_".repeat(e)),ky(s,t,n),n("=".repeat(e));let a=r.layers;for(let p=0;p<a.length;++p)o?tZ(a[p],t,n):rZ(a[p],t,i,n),n((p===a.length-1?"=":"_").repeat(e));r.checkTrainableWeightsConsistency();let u=JQ(r),l=im(r.nonTrainableWeights);n(`Total params: ${u+l}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${l}`),n("_".repeat(e))}function JQ(r){let e;return r.collectedTrainableWeights!=null?e=im(r.collectedTrainableWeights):e=im(r.trainableWeights),e}function eZ(r){let e=!0,t=[],n=[];for(let o in r.nodesByDepth)t.push(r.nodesByDepth[o]);for(let o of t){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){e=!1;break}n.push(...o)}if(e)for(let o of r.layers){let s=!1;for(let i of o.inboundNodes)if(n.indexOf(i)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function ky(r,e,t=console.log){let n="";for(let o=0;o<r.length;++o)o>0&&(n=n.slice(0,n.length-1)+" "),n+=r[o],n=n.slice(0,e[o]),n+=" ".repeat(e[o]-n.length);t(n)}function tZ(r,e,t){let n;try{n=JSON.stringify(r.outputShape)}catch{n="multiple"}let o=r.name,s=r.getClassName(),i=[`${o} (${s})`,n,r.countParams().toString()];ky(i,e,t)}function rZ(r,e,t,n){let o;try{o=JSON.stringify(r.outputShape)}catch{o="multiple"}let s=[];for(let p of r.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(p)===-1))for(let c=0;c<p.inboundLayers.length;++c){let m=p.inboundLayers[c].name,d=p.nodeIndices[c],f=p.tensorIndices[c];s.push(`${m}[${d}][${f}]`)}let i=r.name,a=r.getClassName(),u=s.length===0?"":s[0],l=[`${i} (${a})`,o,r.countParams().toString(),u];ky(l,e,n);for(let p=1;p<s.length;++p)ky(["","","",s[p]],e,n)}function GM(r,e,t){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&e===0&&typeof t=="string"}function yp(r,e){if(r===null)return null;if(typeof r=="string")return hu(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];GM(e,o,s)?t.push(s):t.push(yp(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n];if(n==="name"&&typeof o=="string")t[n]=o;else{let s=hu(n);t[s]=yp(o,s)}}return t}}function Iy(r,e){if(r==null)return null;if(typeof r=="string")return Os(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let t=[],n=r.length;for(let o=0;o<n;++o){let s=r[o];GM(e,o,s)?t.push(s):t.push(Iy(s,e))}return t}else{let t={};for(let n of Object.keys(r)){let o=r[n],s=Os(n);(n==="name"||n==="className")&&typeof o=="string"?t[s]=o:t[s]=Iy(o,n)}return t}}var _f="0.0.0";function nZ(r,e){if(r.dtype==null||r.dtype===e.dtype)return e;try{return J(e,r.dtype)}catch{throw new O(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Ea=class{constructor(e){this.id2Value={};this.id2Mask={};this.name2Id={};if(e instanceof Ea)for(let t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(let t of e)this.add(t.key,t.value)}}add(e,t,n){if(this.id2Value[e.id]==null)this.id2Value[e.id]=nZ(e,t),this.name2Id[e.name]=e.id,n!=null&&(this.id2Mask[e.id]=n);else throw new O(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof yn){if(this.id2Value[e.id]==null)throw new O(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{let t=this.name2Id[e];if(t==null)throw new O(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof yn){if(this.id2Value[e.id]==null)throw new O(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{let t=this.name2Id[e];if(t==null)throw new O(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Fe(this.id2Mask)}},rv={},UM={};function xp(r,e,t,n){let o=t==null?!1:t.training,s=Array.isArray(r),i=s?r:[r],a=i.map(f=>f.name),u=[],l=e.names();for(let f of a)l.indexOf(f)!==-1?u.push(e.getValue(f)):u.push(null);n!=null&&(n.maxNumTensors=-1/0,n.minNumTensors=1/0);let p=a.join(",")+"|"+e.names().join(","),c,m;if(rv[p]==null){let f=oZ(i,e);c=f.sorted,m=f.recipientCounts,rv[p]=c,UM[p]=m}c=rv[p],m={},o||Object.assign(m,UM[p]);let d=new Ea(e);for(let f=0;f<c.length;++f){if(n!=null){let F=_d().numTensors;F>n.maxNumTensors&&(n.maxNumTensors=F),F<n.minNumTensors&&(n.minNumTensors=F)}let h=c[f],g=h.sourceLayer;if(g instanceof fi)continue;let x=[],y=[],T=[],k=!1;for(let F of h.inputs){let B=d.getValue(F),U=d.getMask(F);x.push(B),y.push(U),U!=null&&(k=!0),o||(m[F.name]--,m[F.name]===0&&!e.hasKey(F)&&a.indexOf(F.name)===-1&&!B.isDisposed&&F.sourceLayer.stateful!==!0&&T.push(B))}k&&(t=t||{},t.mask=y[0]);let C=St(g.apply(x,t)),A=null;g.supportsMasking&&(A=g.computeMask(x,y));let M=aZ(h),P=Array.isArray(M)?M:[M];for(let F=0;F<P.length;++F){d.hasKey(P[F])||d.add(P[F],C[F],Array.isArray(A)?A[0]:A);let B=a.indexOf(P[F].name);B!==-1&&(u[B]=C[F])}o||Fe(T)}return d.disposeMasks(),s?u:u[0]}function oZ(r,e){b.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let t=[],n={};if(r.length===1){let o=WM(r[0],e);t=o.sorted,n=o.recipientMap}else{let o=new Set;for(let s of r){let{sorted:i,recipientMap:a}=WM(s,e);for(let u of i)o.has(u.name)||(t.push(u),o.add(u.name));for(let u in a)n[u]==null&&(n[u]=new Set),a[u].forEach(l=>n[u].add(l))}}return{sorted:t,recipientCounts:sZ(n)}}function sZ(r){let e={};for(let t in r)e[t]=r[t].size;return e}function WM(r,e){let t=new Set,n=[],o={};for(let a of e.names())t.add(a);let s=[],i=[];for(s.push(r);s.length>0;){let a=s[s.length-1];if(t.has(a.name)){s.pop();continue}let u=i[i.length-1]===s.length-1;if(a.inputs.length===0||u)s.pop(),n.push(a),t.add(a.name),u&&i.pop();else{i.push(s.length-1);for(let l of a.inputs)o[l.name]==null&&(o[l.name]=new Set),o[l.name].add(a.name),!t.has(l.name)&&s.push(l)}}return{sorted:n,recipientMap:o}}function aZ(r){let e;if(r.sourceLayer.inboundNodes.length===1)e=r.sourceLayer.output;else{let t=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let o of r.sourceLayer.inboundNodes[n].outputTensors)if(o.id===r.id){t=n;break}e=r.sourceLayer.getOutputAt(t)}return e}var es=class extends We{constructor(e){super({});this.containerNodes=new Set;if(this.name=e.name,this.name==null){let y=this.getClassName().toLowerCase();this.name=ol(y)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Gs(this.inputs).length!==this.inputs.length)throw new O(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(y=>y.name)}`);Gs(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(y=>y.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let y of this.outputs){let T=y.sourceLayer,k=y.nodeIndex,C=y.tensorIndex;this.outputLayers.push(T),this.outputLayersNodeIndices.push(k),this.outputLayersTensorIndices.push(C)}for(let y of this.inputs){let T=y.sourceLayer,k=y.nodeIndex,C=y.tensorIndex;Jo(k===0,"input layer has >1 nodes"),Jo(C===0,"input layer has >1 tensors"),this.inputLayers.push(T),this.inputLayersNodeIndices.push(k),this.inputLayersTensorIndices.push(C)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){let T=this.inputLayers[y];if(!(T instanceof fi))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${y} (0-based) originates from layer type ${T.getClassName()}.`);this.inputNames.push(T.name),this.feedInputShapes.push(T.batchInputShape),this.feedInputNames.push(T.name)}for(let y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map(y=>y.shape),this.internalOutputShapes=this.outputs.map(y=>y.shape);let t={},n={},o={},s={},i={},a=[],u=(y,T,k,C,A,M)=>{(C==null||A==null||M==null)&&(C=y.sourceLayer,A=y.nodeIndex,M=y.tensorIndex);let P=C.inboundNodes[A];if(k.indexOf(P)!==-1)throw new rn(`The tensor ${y.name} at layer "${C.name}" is part of a cycle.`);if(T.indexOf(P)!==-1)return;this.containerNodes.add(es.nodeKey(C,A)),C.id in i||(i[C.id]=Object.keys(i).length),k.indexOf(P)===-1&&k.push(P);let F=P.inboundLayers.length;for(let B=0;B<F;B++){let U=P.inputTensors[B],W=P.inboundLayers[B],K=P.nodeIndices[B],j=P.tensorIndices[B];u(U,T,k,W,K,j)}for(T.push(P);k.indexOf(P)>=0;)k.splice(k.indexOf(P),1);a.push(P)},l=[],p=[];for(let y of this.outputs)u(y,l,p);let c=a.slice().reverse();for(let y of c){n[y.id]=y,y.id in t||(t[y.id]=0);let T=t[y.id],k=o[y.outboundLayer.id]==null?0:o[y.outboundLayer.id];T=Math.max(T,k),o[y.outboundLayer.id]=T,s[y.outboundLayer.id]=y.outboundLayer,t[y.id]=T;for(let C=0;C<y.inboundLayers.length;C++){let A=y.inboundLayers[C],M=y.nodeIndices[C],P=A.inboundNodes[M],F=t[P.id]==null?0:t[P.id];t[P.id]=Math.max(T+1,F),n[P.id]=P}}let m={};for(let y in t){let T=t[y];T in m||(m[T]=[]),m[T].push(n[y])}let d={};for(let y in o){let T=o[y];T in d||(d[T]=[]),d[T].push(s[y])}let f=Object.keys(d).map(y=>parseInt(y,10)).sort(nf);this.layers=[];for(let y of f){let T=d[y];T.sort((k,C)=>{let A=i[k.id],M=i[C.id];return A<M?-1:A>M?1:0});for(let k of T)k instanceof es&&this.internalContainerRefs.push(k),this.layers.push(k)}this.layersByDepth=d,f=Object.keys(m).map(y=>parseInt(y,10)).sort(nf);let h=this.inputs.slice(),g=[];for(let y of f)for(let T of m[y]){let k=T.outboundLayer;if(k!=null){for(let C of T.inputTensors)if(h.indexOf(C)===-1)throw new rn(`Graph disconnected: cannot obtain value for tensor ${C} at layer "${k.name}". The following previous layers were accessed without issue: ${g}`);for(let C of T.outputTensors)h.push(C);g.push(k.name)}}this.nodesByDepth=m;let x=this.layers.map(y=>y.name);for(let y of x){let T=x.filter(k=>k===y).length;if(T!==1)throw new rn(`The name "${y}" is used ${T} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(x))}this.outboundNodes=[],this.inboundNodes=[],new sl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(y=>null),outputMasks:this.outputs.map(y=>null),inputShapes:this.inputs.map(y=>y.shape),outputShapes:this.outputs.map(y=>y.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(let t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(n=>n.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new O("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(let t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.layers)t.push(...n.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){let n={},o=0;for(let i of this.layers)for(let a of i.weights){if(n[a.originalName]!=null)throw new O(`Duplicate weight name: ${a.originalName}`);n[a.originalName]=a,o++}let s=[];for(let i in e){let a=i;if(n[i]==null){let u=i.split("/");a=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[a]!=null)s.push([n[a],e[i]]);else if(t)throw new O(`Provided weight data has no target variable: ${i}`);delete n[a]}if(t){let i=[];for(let a in n)i.push(a);if(i.length>0)throw new O(`${i.length} of ${o} weights are not set: ${i}`)}um(s)}updatedConfig(){let e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${_f}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){let n=Iy(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return G(()=>{e=St(e);let n=new Ea;for(let o=0;o<this.inputs.length;++o)n.add(this.inputs[o],e[o]);return xp(this.outputs,n,t)})}computeMask(e,t){return G(()=>{e=St(e);let n;return t==null?n=$s(null,e.length):n=St(t),this.runInternalGraph(e,n)[1]})}computeOutputShape(e){let t=am(e);if(t.length!==this.inputLayers.length)throw new O(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let a=0;a<t.length;a++){let u=this.inputLayers[a],l=t[a],p=u.name+"_0_0";n[p]=l}let o=Object.keys(this.nodesByDepth).map(a=>parseInt(a,10)).sort(nf);if(o.length>1)for(let a of o){let u=this.nodesByDepth[a];for(let l of u){let p=l.outboundLayer;if(this.inputLayers.map(h=>h.id).indexOf(p.id)!==-1)continue;let c=[];for(let h=0;h<l.inboundLayers.length;h++){let g=l.inboundLayers[h],x=l.nodeIndices[h],y=l.tensorIndices[h],T=`${g.name}_${x}_${y}`,k=n[T];c.push(k)}let m=p.computeOutputShape(Pr(c)),d=am(m),f=p.inboundNodes.indexOf(l);for(let h=0;h<d.length;h++){let g=`${p.name}_${f}_${h}`;n[g]=d[h]}}}let s=[],i=[];for(let a=0;a<this.outputLayers.length;a++){let u=this.outputLayers[a],l=this.outputLayersNodeIndices[a],p=this.outputLayersTensorIndices[a],c=`${u.name}_${l}_${p}`;i.push(c)}for(let a=0;a<i.length;a++){let u=i[a];Jo(u in n),s.push(n[u])}return Pr(s)}runInternalGraph(e,t){t==null&&(t=$s(null,e.length));let n={};for(let u=0;u<this.inputs.length;++u){let l=this.inputs[u],p=e[u],c=t[u];n[l.id]=[p,c]}let o=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(nf);for(let u of o){let l=this.nodesByDepth[u];for(let p of l){let c=p.outboundLayer,m=p.inputTensors,d=p.outputTensors,f=new Array;for(let h of m)h.id in n&&f.push(n[h.id]);if(f.length===m.length){let h={},g,x,y,T;if(p.callArgs!=null&&(h=p.callArgs),f.length===1){let[k,C]=f[0];h.mask==null&&(h.mask=C),y=St(c.call(k,h)),T=St(c.computeMask(k,C)),g=[k],x=[C]}else g=f.map(k=>k[0]),x=f.map(k=>k[1]),h.mask==null&&(h.mask=x),y=St(c.call(g,h)),T=St(c.computeMask(g,x));if(c.activityRegularizer)throw new De("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let k=0;k<d.length;++k){let C=d[k],A=y[k],M=T[k];n[C.id]=[A,M]}}}}let s=[],i=[],a=[];for(let u of this.outputs){Jo(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[l,p]=n[u.id];a.push(l.shape),s.push(l),i.push(p)}return[s,i,a]}buildNodeConversionMap(e){let t={},n;for(let o of this.layers){n=o instanceof es?1:0;for(let s=0;s<o.inboundNodes.length;s++){let i=es.nodeKey(o,s);this.containerNodes.has(i)&&(t[i]=n,n+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new O(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new O("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===e)return n;throw new O(`No such layer: ${e}`)}calculateLosses(){return G(()=>{let e=[];for(let t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){let o=es.nodeKey(t,n);this.containerNodes.has(o)&&e.push(...t.calculateLosses())}return e})}getConfig(){let e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(let i of this.layers){let a=i.getClassName(),u=i.getConfig(),l=[];for(let c=0;c<i.inboundNodes.length;c++){let m=i.inboundNodes[c],d=es.nodeKey(i,c),f={};if(this.containerNodes.has(d)){if(m.callArgs)try{JSON.stringify(m.callArgs),f=m.callArgs}catch{console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${m.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(m.inboundLayers.length>0){let h=[];for(let g=0;g<m.inboundLayers.length;g++){let x=m.inboundLayers[g],y=m.nodeIndices[g],T=m.tensorIndices[g],k=es.nodeKey(x,y),C=t[k];C==null&&(C=0),h.push([x.name,C,T,f])}l.push(h)}}}let p={};p.name=i.name,p.className=a,p.config=u,p.inboundNodes=l,n.push(p)}e.layers=n;let o=[];for(let i=0;i<this.inputLayers.length;i++){let a=this.inputLayers[i],u=this.inputLayersNodeIndices[i],l=es.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let c=this.inputLayersTensorIndices[i];o.push([a.name,p,c])}e.inputLayers=o;let s=[];for(let i=0;i<this.outputLayers.length;i++){let a=this.outputLayers[i],u=this.outputLayersNodeIndices[i],l=es.nodeKey(a,u);if(!this.containerNodes.has(l))continue;let p=t[l];p==null&&(p=0);let c=this.outputLayersTensorIndices[i];s.push([a.name,p,c])}return e.outputLayers=s,e}static fromConfig(e,t,n={},o=!1){let s={},i={};function a(g,x){g.name in i?i[g.name].push(x):i[g.name]=[x]}function u(g,x){let y=[],T;for(let k of x){let C=k[0],A=k[1],M=k[2];if(T=k[3]==null?{}:k[3],!(C in s)){a(g,x);return}let P=s[C];if(P.inboundNodes.length<=A){a(g,x);return}let F=P.inboundNodes[A];y.push(F.outputTensors[M])}y.length>0&&g.apply(Pr(y),T)}function l(g){let x=g.name,y=xn(g,t.customObjects!=null?t.customObjects:{});y.setFastWeightInitDuringBuild(o),s[x]=y,g.inboundNodes.forEach(k=>{if(!(k instanceof Array))throw new O(`Corrupted configuration, expected array for nodeData: ${k}`);a(y,k)})}let p=t.name,c=t.layers;for(let g of c)l(g);for(;!oM(i);)for(let g of c){let x=s[g.name];if(x.name in i){let y=i[x.name];delete i[x.name];for(let T of y)u(x,T)}}let m=[],d=[],f=t.inputLayers;for(let g of f){let x=g[0],y=g[1],T=g[2];Jo(x in s);let C=s[x].inboundNodes[y].outputTensors;m.push(C[T])}let h=t.outputLayers;for(let g of h){let x=g[0],y=g[1],T=g[2];Jo(x in s);let C=s[x].inboundNodes[y].outputTensors;d.push(C[T])}return new e({inputs:m,outputs:d,name:p})}get stateful(){if(this._stateful)throw new O("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let e of this.layers)if(e.stateful)return!0;return!1}resetStates(){G(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};function iZ(r,e,t){let n=e.length;if(r==null||Array.isArray(r)&&r.length===0)return e.map(o=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&e[0]in r?[r[e[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${t} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let o=[];return e.forEach(s=>{s in r?o.push(r[s]):o.push(null)}),o}else throw new Error(`The model has multiple (${n}) outputs, so ${t} must be either an array with ${n} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(r)}`)}function Cy(r,e){return iZ(r,e,"classWeight")}async function vy(r,e,t,n){if(e!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){let o=G(()=>{if(r.shape.length===1)return Nn(r);if(r.shape.length===2){if(r.shape[1]>1)return au(r,1);if(r.shape[1]===1)return L(r,[r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await o.data());Fe(o);let i=[];return s.forEach(a=>{if(t[a]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${a} exists in the data but not in classWeight`);i.push(t[a])}),zt(i,"float32")}else return null}function KM(r,e){return R(r,e)}var uZ=32;function VM(r,e){let t,n,o=e;t=o.xs,n=o.ys,b.assert(t!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);let s=jM("input",r.inputNames,t),i=jM("output",r.outputNames,n),a=s[0].shape[0];b.assert(s.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),b.assert(i.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${i.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<s.length;u++)b.assert(s[u].shape[0]===a,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${s[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);for(let u=0;u<i.length;u++)b.assert(i[u].shape[0]===a,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${i[u].shape[0]}; expected  ${a} based on input ${r.inputNames[0]}.`);return{xs:s,ys:i}}function jM(r,e,t){if(t instanceof Ye)return[t];if(Array.isArray(t))return b.assert(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${r} keys ${e}.`),t;{let n=[];for(let o of e){if(t[o]==null)throw new O(`The feature data generated by the dataset lacks the required ${r} key '${o}'.`);n.push(t[o])}return n}}function lZ(r){if(r.length===3)throw new De("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function HM(r,e,t){let n=t.batchesPerEpoch!=null;if(b.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),b.assert(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),b.assert(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),b.assert(!n||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),b.assert(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let o=t.validationData!=null,s,i;if(o)if(qM(t.validationData))b.assert(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{let g=lZ(t.validationData);s=g.xs,i=g.ys}let a=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),l;o?l=u.slice().concat(u.map(g=>"val_"+g)):l=u.slice();let p=hy(t.callbacks,t.yieldEvery),c=t.verbose==null?1:t.verbose,{callbackList:m,history:d}=gy(p,c,t.epochs,null,null,pZ(e,t),null,o,l);m.setModel(r),r.history=d,await m.onTrainBegin(),r.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,h=await e.iterator();for(;f<t.epochs;){let g={};await m.onEpochBegin(f);let x=0,y=0;for(n||(h=await e.iterator());n?x<t.batchesPerEpoch:!0;){let T=await h.next();if(n&&T.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${x} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(T.value!=null){let{xs:k,ys:C}=VM(r,T.value),A={};A.batch=y,A.size=k[0].shape[0],await m.onBatchBegin(y,A);let M=[];if(t.classWeight!=null){let B=Cy(t.classWeight,r.outputNames);for(let U=0;U<B.length;++U)M.push(await vy(C[U],null,B[U]))}let P=k.concat(C).concat(M),F=a(P);Fe(P);for(let B=0;B<u.length;++B){let U=u[B],W=F[B];A[U]=W,Vt(W)}await m.onBatchEnd(y,A),fy(A),y++,x++}if(n?x>=t.batchesPerEpoch:T.done){if(o){let k;qM(t.validationData)?k=St(await r.evaluateDataset(t.validationData,{batches:t.validationBatches})):k=St(r.evaluate(s,i,{batchSize:t.validationBatchSize==null?uZ:t.validationBatchSize,verbose:0}));for(let C=0;C<r.metricsNames.length;++C)g[`val_${r.metricsNames[C]}`]=k[C]}break}if(r.stopTraining_)break}if(await m.onEpochEnd(f,g),f++,r.stopTraining_)break}return await m.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function pZ(r,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(r.size)&&(t=r.size),t}function qM(r){return typeof r.iterator=="function"}function cZ(r){return typeof r.next=="function"}async function XM(r,e,t){t=t||{};let n=t.batches!=null,o=r.testFunction,s=[];if(t.verbose>0)throw new De("Verbose mode is not implemented yet.");b.assert(!n||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);let i=cZ(e)?e:await e.iterator(),a=0,u=0;for(;n?u<t.batches:!0;){let l=await i.next();if(s=G(()=>{if(l.value){let{xs:p,ys:c}=VM(r,l.value),m=p.concat(c),d=G(()=>o(m));if(Fe(m),u===0)for(let h=0;h<d.length;++h)s.push(me(0));let f=m[0].shape[0];for(let h=0;h<d.length;++h){let g=d[h],x=s[h];s[h]=G(()=>X(s[h],R(f,g))),u>0&&Fe(x)}Fe(d),a+=f,++u}return s}),l.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){let p=s[l];s[l]=ce(s[l],a),Fe(p)}return Pr(s)}function Sy(r){b.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function mm(r,e,t){return r==null?[null]:Array.isArray(r)?r.map(n=>bu(n,e,t-e)):bu(r,e,t-e)}function wy(r,e){return G(()=>r==null?null:Array.isArray(r)?r.map(t=>wy(t,e)):iy(r,e.dtype==="int32"?e:J(e,"int32")))}function _y(r,e){let t=[],n=0,o=null;for(;n<r;)o=n+e,o>=r&&(o=r),t.push([n,o]),n=o;return t}async function mZ(r,e,t,n,o,s,i,a,u,l,p,c,m,d,f){o==null&&(o=32),s==null&&(s=1),p==null&&(p=!0),m==null&&(m=0);let h=!1;if(u!=null&&l!=null&&(h=!0),f!=null&&(h=!0,d==null))throw new O("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let g=r.checkNumSamples(t,o,d,"steps_per_epoch"),x;g!=null&&(x=nn(0,g)),i==null&&(i=1);let{callbackList:y,history:T}=gy(a,i,s,m,g,d,o,h,c);y.setModel(r),r.history=T,await y.onTrainBegin(),r.stopTraining_=!1;for(let k=m;k<s;++k){await y.onEpochBegin(k);let C={};if(d!=null)throw new De("stepsPerEpoch mode is not implemented yet.");{if(p==="batch")throw new De("batch shuffling is not implemneted yet");p&&b.shuffle(x);let A=zt(x),M=_y(g,o);for(let P=0;P<M.length;++P){let F={};if(await y.onBatchBegin(P,F),G(()=>{let B=M[P][0],U=M[P][1],W=bu(A,B,U-B);F.batch=P,F.size=U-B;let K=wy(t,W),j=e(K);for(let V=0;V<n.length;++V){let q=n[V],ee=j[V];F[q]=ee,Vt(ee)}if(P===M.length-1&&h){let V=r.testLoop(u,l,o);for(let q=0;q<n.length;++q){let ee=n[q],Z=V[q];Vt(Z),C["val_"+ee]=Z}}}),await y.onBatchEnd(P,F),fy(F),r.stopTraining_)break}A.dispose()}if(await y.onEpochEnd(k,C),r.stopTraining_)break}return await y.onTrainEnd(),await r.history.syncData(),r.history}async function YM(r,e,t,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let o,s,i,a,u,l,p;try{let c=n.batchSize==null?32:n.batchSize;Sy(c);let m=!1,d=await r.standardizeUserData(e,t,n.sampleWeight,n.classWeight,m,c);o=d[0],s=d[1],p=d[2];let f=!1,h;if(n.validationData!=null&&n.validationData.length>0){if(f=!0,n.validationData.length===2)i=n.validationData[0],a=n.validationData[1];else throw n.validationData.length===3?new De("validationData including sample weights is not supported yet."):new O(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let M=!0,P=await r.standardizeUserData(i,a,null,null,M,c);u=P[0],l=P[1],h=u.concat(l)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){f=!0;let M=Math.floor(o[0].shape[0]*(1-n.validationSplit)),P=o[0].shape[0];u=mm(o,M,P),o=mm(o,0,M),l=mm(s,M,P),s=mm(s,0,M),h=u.concat(l)}else n.validationSteps!=null&&(f=!0);let g=o.concat(s).concat(p);r.checkTrainableWeightsConsistency();let x=r.makeTrainFunction(),y=r.getDedupedMetricsNames(),T,k;f?(r.makeTestFunction(),T=r.testFunction,k=y.slice().concat(y.map(M=>"val_"+M))):(T=null,h=[],k=y.slice());let C=hy(n.callbacks,n.yieldEvery);return await mZ(r,x,g,y,c,n.epochs,n.verbose,C,T,h,n.shuffle,k,n.initialEpoch,null,null)}finally{r.isTraining=!1,ul(o,e),ul(s,t),ul(u,i),ul(l,a),p!=null&&Fe(p)}}function nv(r){let e=[];r instanceof Ye&&(r=[r]);for(let t=0;t<r.length;++t){let n=r[t];if(n.rank===1)e.push(gu(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(n)}}return e}function ul(r,e){if(r==null)return;let t=[];if(e instanceof Ye)t.push(e.id);else if(Array.isArray(e))e.forEach(o=>t.push(o.id));else if(e!=null)for(let o in e){let s=e[o];t.push(s.id)}let n=[];if(r instanceof Ye)t.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(o=>{t.indexOf(o.id)===-1&&n.push(o)});else if(r!=null)for(let o in r){let s=r[o];t.indexOf(s.id)===-1&&n.push(s)}n.forEach(o=>{o.isDisposed||o.dispose()})}function dZ(r){return r instanceof Ye}function ov(r){return Array.isArray(r)}function QM(r){return!dZ(r)&&!ov(r)}function ZM(r,e,t,n=!0,o=""){if(e==null||e.length===0){if(r!=null){let i=!1;if(ov(r)&&r.length>0)i=!0;else if(QM(r)){for(let a in r)if(r.hasOwnProperty(a)){i=!0;break}}else i=!0;if(i)throw new O(`Error when checking model ${o} expected no data, but got ${r}`)}return[]}if(r==null)return e.map(i=>null);let s;if(QM(r)){r=r,s=[];for(let i of e){if(r[i]==null)throw new O(`No data provided for "${i}". Need data for each key in: ${e}`);s.push(r[i])}}else if(ov(r)){if(r=r,r.length!==e.length)throw new O(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);s=r}else{if(r=r,e.length>1)throw new O(`The model ${o} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);s=[r]}if(s=nv(s),t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;let a=s[i];if(a.shape.length!==t[i].length)throw new O(`Error when checking ${o}: expected ${e[i]} to have ${t[i].length} dimension(s). but got array with shape ${a.shape}`);for(let u=0;u<t[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],p=t[i][u];if(p!=null&&p>=0&&l!==p)throw new O(`${o} expected a batch of elements where each example has shape [${t[i].slice(1,t[i].length)}] (i.e.,tensor shape [*,${t[i].slice(1,t[i].length)}]) but the ${o} received an input with ${a.shape[0]} examples, each with shape [${a.shape.slice(1,a.shape.length)}] (tensor shape [${a.shape}])`)}}return s}function fZ(r,e,t){let n=Gs(r.map(s=>s.shape[0]));n.sort();let o=Gs(e.map(s=>s.shape[0]));if(o.sort(),n.length>1)throw new O(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(s=>s.shape))}`);if(o.length>1)throw new O(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(n.length>0&&o.length>0&&!b.arraysEqual(n,o))throw new O(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${o[0]} target sample(s).`)}function hZ(r,e,t){let n=[gi,cm,bp];for(let o=0;o<r.length;++o){let s=r[o],i=e[o],a=t[o];if(i!=null){if(i===bp&&s.shape[s.shape.length-1]===1)throw new O(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(i)!==-1){let u=s.shape.slice(1),l=a.slice(1);for(let p=0;p<u.length;++p){let c=u[p],m=l[p];if(m!=null&&c!==m)throw new O(`A target Tensor with shape ${s.shape} was passed for an output of shape ${a}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function JM(r,e,t,n=!0,o=""){let s;if(Array.isArray(r)){if(r.length!==e.length)throw new O(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${r.length} Tensors(s).`);s=r}else{if(e.length>1)throw new O(`The model expects ${e.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);s=[r]}if(t!=null)for(let i=0;i<e.length;++i){if(t[i]==null)continue;let a=s[i];if(a.shape.length!==t[i].length)throw new O(`Error when checking ${o}: expected ${e[i]} to have ${t[i].length} dimension(s), but got array with shape ${JSON.stringify(a.shape)}`);for(let u=0;u<t[i].length;++u){if(u===0&&!n)continue;let l=a.shape[u],p=t[i][u];if(p!=null&&p!==l)throw new O(`Error when checking ${o}: expected ${e[i]} to have shape ${JSON.stringify(t[i])} but got array with shape ${JSON.stringify(a.shape)}.`)}}}function gZ(r,e){if(r==null||Array.isArray(r)&&r.length===0)return e.map(n=>[]);let t;if(typeof r=="string"||typeof r=="function")t=[r];else if(Array.isArray(r)||typeof r=="object")t=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(t))return e.map(n=>t);{let n=[];for(let o of e){let s=t.hasOwnProperty(o)?t[o]:[];Array.isArray(s)||(s=[s]),n.push(s)}return n}}var bZ="layers-model",ts=class extends es{constructor(e){super(e);this.isTraining=!1}summary(e,t,n=console.log){if(!this.built)throw new O("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");zM(this,e,t,n)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=$M(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof tn))throw new O("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(let i in e.loss)if(this.outputNames.indexOf(i)===-1)throw new O(`Unknown entry in loss dictionary: "${i}". Only expected the following keys: ${this.outputNames}`);for(let i of this.outputNames)e.loss[i]==null&&console.warn(`Output "${i}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${i} during training`),t.push(by(e.loss[i]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new O(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>by(a))}else{let i=by(e.loss);this.outputs.forEach(a=>{t.push(i)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){let a=this.internalOutputShapes[i],u=this.outputNames[i];this.feedOutputNames.push(u),this.feedOutputShapes.push(a),this.feedLossFns.push(this.lossFunctions[i])}let n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Pa("loss",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=this.lossFunctions[i];this.outputs.length>1&&(this.metricsTensors.push([a,i]),this.metricsNames.push(this.outputNames[i]+"_loss"))}});let o=gZ(e.metrics,this.outputNames),s=(i,a,u)=>{this.outputNames.length>1&&(a=this.outputNames[i]+"_"+a),this.metricsNames.push(a),this.metricsTensors.push([u,i])};Pa("metric",()=>{for(let i=0;i<this.outputs.length;++i){if(n.indexOf(i)!==-1)continue;let a=o[i];(l=>{let p="",c,m,d;for(let f of l){if(typeof f=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(f)!==-1){let g=this.internalOutputShapes[i];g[g.length-1]===1||this.lossFunctions[i]===cm?["accuracy","acc"].indexOf(f)!==-1?m=Cf:["crossentropy","ce"].indexOf(f)!==-1&&(m=yy):this.lossFunctions[i]===pm?["accuracy","acc"].indexOf(f)!==-1?m=xy:["crossentropy","ce"].indexOf(f)!==-1&&(m=JC):["accuracy","acc"].indexOf(f)!==-1?m=vf:["crossentropy","ce"].indexOf(f)!==-1&&(m=Sf);let x;["accuracy","acc"].indexOf(f)!==-1?x="acc":["crossentropy","ce"].indexOf(f)!==-1&&(x="ce"),d=m,c=p+x}else d=LM(f),c=p+wf(f);let h;Pa(c,()=>{h=d}),s(i,c,h)}})(a)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,n={}){let o=n.batchSize==null?32:n.batchSize;Sy(o);let s=!0,i=this.standardizeUserDataXY(e,t,s,o);try{let a=i[0].concat(i[1]);this.makeTestFunction();let u=this.testFunction,l=this.testLoop(u,a,o,n.verbose,n.steps);return Pr(l)}finally{ul(i[0],e),ul(i[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),XM(this,e,t)}checkNumSamples(e,t,n,o="steps"){let s;if(n!=null){if(s=null,t!=null)throw new O(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new O(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new O("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(t),o=n?t:[t],s=this.retrieveSymbolicTensors(o),i=new Ea;if(e instanceof Ye&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new O(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)i.add(this.inputs[u],e[u])}else for(let u of this.inputs){let l=e[u.name];if(l==null)throw new O(`No value is provided for the model's input ${u.name}`);i.add(u,l)}let a=xp(s,i);return n?a:a[0]}retrieveSymbolicTensors(e){let t=$s(null,e.length),n=e.length;for(let o of this.layers){let s=Array.isArray(o.output)?o.output:[o.output],i=s.map(a=>a.name);for(let a=0;a<e.length;++a){let u=i.indexOf(e[a]);if(u!==-1&&(t[a]=s[u],n--),n===0)break}if(n===0)break}if(n>0){let o=[];throw t.forEach((s,i)=>{s==null&&o.push(e[i])}),new O(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return t}predictLoop(e,t=32,n=!1){return G(()=>{let o=this.checkNumSamples(e);if(n)throw new De("Verbose predictLoop() is not implemented yet.");let s=_y(o,t),i=this.outputs.map(a=>[]);for(let a=0;a<s.length;++a)G(()=>{let l=s[a][0],p=s[a][1],c=mm(e,l,p),m=[];if(Array.isArray(c))for(let f=0;f<c.length;++f)m.push({key:this.inputs[f],value:c[f]});else m.push({key:this.inputs[0],value:c});let d=new Ea(m);return xp(this.outputs,d)}).forEach((l,p)=>i[p].push(l));return Pr(i.map(a=>lt(a,0)))})}predict(e,t={}){let n=nv(e);JM(n,this.inputNames,this.feedInputShapes,!1);try{let o=t.batchSize==null?32:t.batchSize;return Sy(o),this.predictLoop(n,o)}finally{ul(n,e)}}predictOnBatch(e){JM(e,this.inputNames,this.feedInputShapes,!0);let t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,n=!0,o){if(this.optimizer_==null)throw new rn("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let s=[];for(let i=0;i<this.feedOutputShapes.length;++i){let a=this.feedOutputShapes[i];this.feedLossFns[i]===pm?s.push(a.slice(0,a.length-1).concat([1])):s.push(a)}if(e=ZM(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=ZM(t,this.feedOutputNames,s,!1,"target"),fZ(e,t,null),hZ(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&e[0].shape[0]%o!=0)throw new O(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,o,s=!0,i){let[a,u]=this.standardizeUserDataXY(e,t,s,i);if(n!=null)throw new Error("sample weight is not supported yet.");let l=null;if(o!=null){let p=Cy(o,this.outputNames);l=[];for(let c=0;c<p.length;++c)l.push(await vy(u[c],null,p[c]))}return[a,u,l]}testLoop(e,t,n,o=0,s){return G(()=>{let i=this.checkNumSamples(t,n,s,"steps"),a=[];if(o>0)throw new De("Verbose mode is not implemented yet.");if(s!=null)throw new De("steps mode in testLoop() is not implemented yet");{let u=_y(i,n),l=zt(nn(0,i));for(let p=0;p<u.length;++p){let c=u[p][0],m=u[p][1],d=bu(l,c,m-c),f=wy(t,d),h=e(f);if(p===0)for(let g=0;g<h.length;++g)a.push(me(0));for(let g=0;g<h.length;++g){let x=h[g];a[g]=X(a[g],R(m-c,x))}}for(let p=0;p<a.length;++p)a[p]=ce(a[p],i)}return a})}getDedupedMetricsNames(){let e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){let o=e[n],s=o;GC(e,o)>1&&(s+=`_${GC(e.slice(0,n),o)}`),t.push(s)}return t}makeTrainFunction(){return e=>{let t=[],n=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),i=[],a=()=>{let c=[];for(let h=0;h<this.inputs.length;++h)c.push({key:this.inputs[h],value:n[h]});let m=new Ea(c),d=xp(this.outputs,m,{training:!0}),f;for(let h=0;h<this.lossFunctions.length;++h){let x=this.lossFunctions[h](o[h],d[h]);s[h]!=null&&(x=KM(x,s[h]));let y=Rt(x);t.push(y),h===0?f=x:f=X(f,x)}for(let h=0;h<this.metricsTensors.length;++h){let g;if(this.outputs.length>1&&h<this.outputs.length)g=t[h];else{let x=this.metricsTensors[h][0],y=this.metricsTensors[h][1];g=Rt(x(o[y],d[y]))}Vt(g),i.push(g)}return f=Rt(f),this.calculateLosses().forEach(h=>{f=X(f,h)}),f},u=this.collectedTrainableWeights.map(c=>c.read()),l=!0;return[this.optimizer_.minimize(a,l,u)].concat(i)}}makeTestFunction(){this.testFunction=e=>G(()=>{let t=[],n,o=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let l=0;l<this.inputs.length;++l)i.push({key:this.inputs[l],value:o[l]});let a=new Ea(i),u=xp(this.outputs,a);for(let l=0;l<this.lossFunctions.length;++l){let p=this.lossFunctions[l],c=Rt(p(s[l],u[l]));l===0?n=c:n=X(n,c),t.push(n)}for(let l=0;l<this.metricsTensors.length;++l){let p=this.metricsTensors[l][0],c=this.metricsTensors[l][1],m=Rt(p(s[c],u[c]));t.push(m)}return t})}async fit(e,t,n={}){return YM(this,e,t,n)}async fitDataset(e,t){return HM(this,e,t)}async trainOnBatch(e,t){let n=await this.standardizeUserData(e,t),o=n[0],s=n[1],a=this.makeTrainFunction()(o.concat(s)),u=[];for(let l of a){let p=await l.data();u.push(p[0])}return Fe(a),Pr(u)}getNamedWeights(e){let t=[],n=e!=null&&e.trainableOnly,o=n?this.trainableWeights:this.weights,s=this.getWeights(n);for(let i=0;i<o.length;++i)n&&!o[i].trainable||t.push({name:o[i].originalName,tensor:s[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){let e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let t=_d().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-_d().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Os(this.loss);else if(Array.isArray(this.loss)){for(let t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Os(t))}else{let t=Object.keys(this.loss);e={};let n=this.loss;for(let o of t)if(typeof n[o]=="string")e[o]=Os(n[o]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Os(wf(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Os(wf(e)));{let e={};for(let t in this.metrics)e[t]=Os(wf(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let t=yp(e.optimizer_config),n=xn(t),o;if(typeof e.loss=="string")o=hu(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(i=>hu(i));else if(e.loss!=null){o={};for(let i in e.loss)o[i]=hu(e.loss[i])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(i=>hu(i));else if(e.metrics!=null){s={};for(let i in e.metrics)s[i]=hu(e.metrics[i])}this.compile({loss:o,metrics:s,optimizer:n})}async save(e,t){if(typeof e=="string"){let l=Kr.getSaveHandlers(e);if(l.length===0)throw new O(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new O(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new O("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Kr.encodeWeights(this.getNamedWeights(t)),o=!1,s=null,a={modelTopology:this.toJSON(s,o),format:bZ,generatedBy:`TensorFlow.js tfjs-layers v${_f}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();let l="optimizer",{data:p,specs:c}=await Kr.encodeWeights(await this.optimizer.getWeights(),l);n.specs.push(...c),n.data=Kr.concatenateArrayBuffers([n.data,p])}if(this.userDefinedMetadata!=null){let l=!0;ev(this.userDefinedMetadata,this.name,l),a.userDefinedMetadata=this.userDefinedMetadata}return a.weightData=n.data,a.weightSpecs=n.specs,e.save(a)}setUserDefinedMetadata(e){ev(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}};ts.className="Model";re.registerClass(ts);var sv=class extends ts{};sv.className="Functional";re.registerClass(sv);async function eF(r,e){"modelTopology"in r||(r={modelTopology:r}),r=r;let t=r.modelTopology;t.model_config!=null&&(t=t.model_config);let n=yp(t),o=xn(n,e);if(r.weightsManifest!=null){let s=await Kr.loadWeights(r.weightsManifest,r.pathPrefix,o.weights.map(a=>a.originalName)),i={};for(let a of o.weights)i[a.originalName]=s[a.originalName];o.loadWeights(i),Fe(s)}return o}async function tF(r,e){if(e==null&&(e={}),typeof r=="string"){let t=Kr.getLoadHandlers(r,e);if(t.length===0)t.push(Kr.browserHTTPRequest(r,e));else if(t.length>1)throw new O(`Found more than one (${t.length}) load handlers for URL '${r}'`);r=t[0]}return yZ(r,void 0,e)}async function yZ(r,e,t){if(t==null&&(t={}),r.load==null)throw new O("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),o=n.modelTopology;o.model_config!=null&&(o=o.model_config);let s=t.strict==null?!0:t.strict,i=n.weightData!=null&&n.weightSpecs!=null&&s,a=xn(yp(o),e,i),u=n.trainingConfig;if(u!=null&&a.loadTrainingConfig(u),n.userDefinedMetadata!=null&&a.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new O("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:l,optimizerWeights:p}=xZ(n.weightData,n.weightSpecs);a.loadWeights(l,s),a.optimizer!=null&&p.length>0&&await a.optimizer.setWeights(p),Fe(l),Fe(p.map(c=>c.tensor))}return a}function xZ(r,e){let t=Kr.decodeWeights(r,e),n={},o=[];return e.forEach(s=>{s.group==="optimizer"?o.push({name:s.name,tensor:t[s.name]}):n[s.name]=t[s.name]}),{modelWeights:n,optimizerWeights:o}}var Ay=class extends ts{constructor(e){super({inputs:[],outputs:[]});if(e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:ol("sequential_"),e.layers!=null)for(let t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new O(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){let t=e instanceof Ay||e instanceof ts,n;if(t){if(n=e,n.outputs.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new O("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new O("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let o=dy({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(e.inboundNodes.length!==1)throw new O(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new O("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=qC(this.outputs[0])}this.inboundNodes=[],new sl({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:$s(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{let o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Je(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new ts({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,n=console.log){this.built||this.build(),super.summary(e,t,n)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,n={}){if(!this.built)throw new rn("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new rn("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,n={}){if(!this.built)throw new rn("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new rn("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,n={},o=!1){let s,i={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new O("Legacy serialization format not supported yet.");s=t}else b.assert(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,i=t;let a=new e(i);if(!(a instanceof Ay))throw new De(`Sequential.fromConfig called on non-Sequential input: ${a}`);for(let u of s){let p=xn(u,void 0,o);o&&p.setFastWeightInitDuringBuild(!0),a.add(p)}return a}set stopTraining(e){if(this.model==null)throw new O("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new O("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let e=[];for(let t of this.layers){let n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}},dm=Ay;dm.className="Sequential";re.registerClass(dm);function TZ(r){return new ts(r)}function kZ(r){return new dm(r)}function IZ(r,e){return e==null&&(e={}),tF(r,e)}function av(r){return dy(r)}function CZ(r,e){xf.registerCallbackConstructor(r,e)}var Tn=class extends re.Serializable{getConfig(){return{}}},iv=class extends Tn{apply(e,t=1){return IM(e,t)}};iv.className="elu";re.registerClass(iv);var uv=class extends Tn{apply(e){return Hd(e)}};uv.className="selu";re.registerClass(uv);var lv=class extends Tn{apply(e){return qr(e)}};lv.className="relu";re.registerClass(lv);var pv=class extends Tn{apply(e){return G(()=>cu(6,qr(e)))}};pv.className="relu6";re.registerClass(pv);var cv=class extends Tn{apply(e){return e}};cv.className="linear";re.registerClass(cv);var mv=class extends Tn{apply(e){return cn(e)}};mv.className="sigmoid";re.registerClass(mv);var dv=class extends Tn{apply(e){return vM(e)}};dv.className="hardSigmoid";re.registerClass(dv);var fv=class extends Tn{apply(e){return ui(e)}};fv.className="softplus";re.registerClass(fv);var hv=class extends Tn{apply(e){return CM(e)}};hv.className="softsign";re.registerClass(hv);var gv=class extends Tn{apply(e){return iu(e)}};gv.className="tanh";re.registerClass(gv);var Af=class extends Tn{apply(e,t=-1){return Zl(e,t)}};Af.className="softmax";re.registerClass(Af);var bv=class extends Tn{apply(e,t=-1){return $d(e,t)}};bv.className="logSoftmax";re.registerClass(bv);var yv=class extends Tn{apply(e,t=1){return G(()=>R(cn(R(e,t)),e))}};yv.className="swish";re.registerClass(yv);var xv=class extends Tn{apply(e){return G(()=>R(e,iu(ui(e))))}};xv.className="mish";re.registerClass(xv);function Ra(r){return r.getClassName()}function Tv(r,e={}){return mi(r,re.SerializationMap.getMap().classNameMap,e,"activation")}function La(r){if(r==null){let e={};return e.className="linear",e.config={},Tv(e)}if(typeof r=="string"){let e={};return e.className=r,e.config={},Tv(e)}else return r instanceof Tn?r:Tv(r)}function kv(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var Iv=class extends re.Serializable{},Tp=class extends Iv{constructor(e){super();kv(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return G(()=>{let t=xt([1]);return this.hasL1&&(t=X(t,he(R(this.l1,$t(e))))),this.hasL2&&(t=X(t,he(R(this.l2,hp(e))))),L(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}};Tp.className="L1L2";re.registerClass(Tp);function rF(r){return kv(r),new Tp({l1:r!=null?r.l1:null,l2:0})}function nF(r){return kv(r),new Tp({l2:r!=null?r.l2:null,l1:0})}var oF={l1l2:"L1L2"};function ht(r){return Xc(r)}function sF(r,e={}){return mi(r,re.SerializationMap.getMap().classNameMap,e,"regularizer")}function wt(r){if(r==null)return null;if(typeof r=="string"){let t={className:r in oF?oF[r]:r,config:{}};return sF(t)}else return r instanceof Iv?r:sF(r)}var Nf=class extends We{constructor(e){super(e??{});this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Oe(e);let n=qr(e);return this.maxValue!=null&&(n=Br(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){let e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}};Nf.className="ReLU";re.registerClass(Nf);var Df=class extends We{constructor(e){super(e??{});this.DEFAULT_ALPHA=.3;e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Oe(e);return Vl(n,this.alpha)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Df.className="LeakyReLU";re.registerClass(Df);var Pf=class extends We{constructor(e){super(e??{});this.DEFAULT_ALPHA_INITIALIZER="zeros";if(e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=kt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=wt(e.alphaRegularizer),this.alphaConstraint=Yt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new O(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Je(e);let t=e.slice(1);if(this.sharedAxes!=null)for(let o of this.sharedAxes)t[o-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let o=1;o<e.length;++o)n[o]=e[o];this.inputSpec=[new Ft({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=Oe(e),Yl(e,this.alpha.read())}getConfig(){let e={alphaInitializer:Mt(this.alphaInitializer),alphaRegularizer:ht(this.alphaRegularizer),alphaConstraint:Xt(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}};Pf.className="PReLU";re.registerClass(Pf);var Mf=class extends We{constructor(e){super(e??{});this.DEFAULT_ALPHA=1;if(e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new De(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){let n=Oe(e);return lu(n)}computeOutputShape(e){return e}getConfig(){let e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};Mf.className="ELU";re.registerClass(Mf);var Ff=class extends We{constructor(e){super(e??{});this.DEFAULT_THETA=1;e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){let n=Oe(e);return R(n,J(nr(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){let e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};Ff.className="ThresholdedReLU";re.registerClass(Ff);var Ef=class extends We{constructor(e){super(e??{});this.DEFAULT_AXIS=1;e==null&&(e={}),this.softmax=new Af().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){let n=Oe(e);return this.softmax(n,this.axis)}computeOutputShape(e){return e}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};Ef.className="Softmax";re.registerClass(Ef);function ll(r,e,t){if(typeof r=="number")return $s(r,e);if(r.length!==e)throw new O(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${r.length} elements.`);for(let n=0;n<e;++n){let o=r[n];if(!yM(o))throw new O(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(r)} including a non-integer number ${o}`)}return r}function Rn(r,e,t,n,o=1){if(r==null)return r;let s=e+(e-1)*(o-1),i;return t==="same"?i=r:i=r-s+1,Math.floor((i+n-1)/n)}function Ba(r,e,t,n){if(r==null)return null;if(n==="valid")r=r*e+Ma([t-e,0]);else if(n==="same")r=r*e;else throw new O(`Unsupport padding mode: ${n}.`);return r}function Rf(r,e){return G(()=>(jt(e),e==="channelsFirst"?He(r,[0,2,3,1]):r))}function Cv(r,e){return G(()=>(jt(e),e==="channelsFirst"?He(r,[0,2,3,4,1]):r))}function SZ(r,e,t,n=1,o="valid",s,i=1){return G(()=>{if(s==null&&(s=fn()),jt(s),r.shape.length!==3)throw new O(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(e.shape.length!==3)throw new O(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new O(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(s==="channelsFirst"&&(r=He(r,[0,2,1])),o==="causal")throw new De("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let a=Md(r,e,n,o==="same"?"same":"valid","NWC",i);return t!=null&&(a=gn(a,t)),a})}function aF(r,e,t,n=[1,1],o="valid",s,i,a=null){return G(()=>{if(s==null&&(s=fn()),jt(s),r.rank!==3&&r.rank!==4)throw new O(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(e.rank!==3&&e.rank!==4)throw new O(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=Rf(r,s);if(o==="causal")throw new De("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=Ls.conv2d({x:u,filter:e,strides:n,pad:o==="same"?"same":"valid",dilations:i,dataFormat:"NHWC",bias:t,activation:a}),s==="channelsFirst"&&(u=He(u,[0,3,1,2])),u})}function wZ(r,e,t,n=[1,1,1],o="valid",s,i){return G(()=>{if(s==null&&(s=fn()),jt(s),r.rank!==4&&r.rank!==5)throw new O(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(e.rank!==4&&e.rank!==5)throw new O(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let a=Cv(r,s);if(o==="causal")throw new De("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return a=Ed(a,e,n,o==="same"?"same":"valid","NDHWC",i),t!=null&&(a=gn(a,t)),s==="channelsFirst"&&(a=He(a,[0,4,1,2,3])),a})}var fm=class extends We{constructor(e,t){super(t);this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(fm.verifyArgs(t),this.rank=e,or(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new De(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=ll(t.kernelSize,e,"kernelSize"),this.strides=ll(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,hn(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,jt(this.dataFormat),this.activation=La(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=kt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Yt(t.biasConstraint),this.biasRegularizer=wt(t.biasRegularizer),this.activityRegularizer=wt(t.activityRegularizer),this.dilationRate=ll(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new O(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new O(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new O(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(Jo("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!ty(e.kernelSize,"number",1,3))throw new O(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){let e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Ra(this.activation),useBias:this.useBias,biasInitializer:Mt(this.biasInitializer),biasRegularizer:ht(this.biasRegularizer),activityRegularizer:ht(this.activityRegularizer),biasConstraint:Xt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}},kp=class extends fm{constructor(e,t){super(e,t);this.kernel=null;kp.verifyArgs(t),this.filters=t.filters,or(this.filters,"filters"),this.kernelInitializer=kt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Yt(t.kernelConstraint),this.kernelRegularizer=wt(t.kernelRegularizer)}build(e){e=Je(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return G(()=>{e=Oe(e);let n,o=this.bias==null?null:this.bias.read(),s=ry(this.activation.getClassName());if(s!=null&&this.rank===2)n=aF(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)n=SZ(e,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=aF(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=wZ(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new De("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(e){e=Je(e);let t=[],n=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<n.length;++s){let i=Rn(n[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(i)}let o=[e[0]];return this.dataFormat==="channelsLast"?(o=o.concat(t),o.push(this.filters)):(o.push(this.filters),o=o.concat(t)),o}getConfig(){let e={filters:this.filters,kernelInitializer:Mt(this.kernelInitializer),kernelRegularizer:ht(this.kernelRegularizer),kernelConstraint:Xt(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new O(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}},Sv=class extends kp{constructor(e){super(2,e);Sv.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!ty(e.kernelSize,"number",1,2))throw new O(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}},hm=Sv;hm.className="Conv2D";re.registerClass(hm);var wv=class extends kp{constructor(e){super(3,e);wv.verifyArgs(e)}getConfig(){let e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new O(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}},gm=wv;gm.className="Conv3D";re.registerClass(gm);var Lf=class extends hm{constructor(e){super(e);if(this.inputSpec=[new Ft({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Je(e),e.length!==4)throw new O("Input should have rank 4; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ft({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return G(()=>{let n=Oe(e);if(n.shape.length!==4)throw new O(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a;this.dataFormat==="channelsFirst"?(i=2,a=3):(i=1,a=2);let u=o[i],l=o[a],p=this.kernelSize[0],c=this.kernelSize[1],m=this.strides[0],d=this.strides[1],f=Ba(u,m,p,this.padding),h=Ba(l,d,c,this.padding),g=[s,f,h,this.filters];this.dataFormat!=="channelsLast"&&(n=He(n,[0,2,3,1]));let x=Fd(n,this.kernel.read(),g,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(x=He(x,[0,3,1,2])),this.bias!=null&&(x=gn(x,this.bias.read(),this.dataFormat)),this.activation!=null&&(x=this.activation.apply(x)),x})}computeOutputShape(e){e=Je(e);let t=e.slice(),n,o,s;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3):(n=3,o=1,s=2);let i=this.kernelSize[0],a=this.kernelSize[1],u=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[o]=Ba(t[o],u,i,this.padding),t[s]=Ba(t[s],l,a,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Lf.className="Conv2DTranspose";re.registerClass(Lf);var Bf=class extends gm{constructor(e){super(e);if(this.inputSpec=[new Ft({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new O(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Je(e),e.length!==5)throw new O("Input should have rank 5; Received input shape: "+JSON.stringify(e));let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O("The channel dimension of the inputs should be defined. Found `None`.");let n=e[t],o=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Ft({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return G(()=>{let n=Oe(e);if(n.shape.length!==5)throw new O(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let o=n.shape,s=o[0],i,a,u;this.dataFormat==="channelsFirst"?(u=2,i=3,a=4):(u=1,i=2,a=3);let l=o[u],p=o[i],c=o[a],m=this.kernelSize[0],d=this.kernelSize[1],f=this.kernelSize[2],h=this.strides[0],g=this.strides[1],x=this.strides[2],y=Ba(l,h,m,this.padding),T=Ba(p,g,d,this.padding),k=Ba(c,x,f,this.padding),C=[s,y,T,k,this.filters];this.dataFormat!=="channelsLast"&&(n=He(n,[0,2,3,4,1]));let A=HI(n,this.kernel.read(),C,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(A=He(A,[0,4,1,2,3])),this.bias!==null&&(A=gn(A,this.bias.read(),this.dataFormat)),this.activation!==null&&(A=this.activation.apply(A)),A})}computeOutputShape(e){e=Je(e);let t=e.slice(),n,o,s,i;this.dataFormat==="channelsFirst"?(n=1,o=2,s=3,i=4):(n=4,o=1,s=2,i=3);let a=this.kernelSize[0],u=this.kernelSize[1],l=this.kernelSize[2],p=this.strides[0],c=this.strides[1],m=this.strides[2];return t[n]=this.filters,t[o]=Ba(t[o],p,a,this.padding),t[s]=Ba(t[s],c,u,this.padding),t[i]=Ba(t[i],m,l,this.padding),t}getConfig(){let e=super.getConfig();return delete e.dilationRate,e}};Bf.className="Conv3DTranspose";re.registerClass(Bf);var vv=class extends kp{constructor(e,t){super(e,t);this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform";this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform";this.depthwiseKernel=null;this.pointwiseKernel=null;if(t.filters==null)throw new O("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new O("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new O(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=kt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=wt(t.depthwiseRegularizer),this.depthwiseConstraint=Yt(t.depthwiseConstraint),this.pointwiseInitializer=kt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=wt(t.pointwiseRegularizer),this.pointwiseConstraint=Yt(t.pointwiseConstraint)}build(e){if(e=Je(e),e.length<this.rank+2)throw new O(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new O(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);let n=e[t],o=this.kernelSize.concat([n,this.depthMultiplier]),s=[];for(let a=0;a<this.rank;++a)s.push(1);s.push(n*this.depthMultiplier,this.filters);let i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new Ft({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return G(()=>{e=Oe(e);let n;if(this.rank===1)throw new De("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=He(e,[0,2,3,1])),n=IC(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=gn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=He(n,[0,3,1,2])),n})}getConfig(){let e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.pointwiseInitializer=Mt(this.pointwiseInitializer),e.depthwiseRegularizer=ht(this.depthwiseRegularizer),e.pointwiseRegularizer=ht(this.pointwiseRegularizer),e.depthwiseConstraint=Xt(this.depthwiseConstraint),e.pointwiseConstraint=Xt(this.pointwiseConstraint),e}};vv.className="SeparableConv";var $f=class extends vv{constructor(e){super(2,e)}};$f.className="SeparableConv2D";re.registerClass($f);var _v=class extends kp{constructor(e){super(1,e);_v.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){let e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!ty(e.kernelSize,"number",1,1))throw new O(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}},Of=_v;Of.className="Conv1D";re.registerClass(Of);var zf=class extends We{constructor(e){super(e);typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return G(()=>{if(e=Oe(e),this.dataFormat==="channelsLast"){let n=pf(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return pf(n,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=pf(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return pf(n,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};zf.className="Cropping2D";re.registerClass(zf);var Gf=class extends We{constructor(e){super(e);this.DEFAULT_SIZE=[2,2];this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,jt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,hM(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){let t=e[2]==null?null:this.size[0]*e[2],n=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,n]}else{let t=e[1]==null?null:this.size[0]*e[1],n=e[2]==null?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return G(()=>{let n=Oe(e),o=n.shape;if(this.dataFormat==="channelsFirst"){n=He(n,[0,2,3,1]);let s=this.size[0]*o[2],i=this.size[1]*o[3],a=this.interpolation==="nearest"?Fn.resizeNearestNeighbor(n,[s,i]):Fn.resizeBilinear(n,[s,i]);return He(a,[0,3,1,2])}else{let s=this.size[0]*o[1],i=this.size[1]*o[2];return this.interpolation==="nearest"?Fn.resizeNearestNeighbor(n,[s,i]):Fn.resizeBilinear(n,[s,i])}})}getConfig(){let e={size:this.size,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Gf.className="UpSampling2D";re.registerClass(Gf);function _Z(r,e,t=[1,1],n="valid",o,s){return G(()=>{o==null&&(o=fn()),jt(o);let i=Rf(r,o);if(r.rank!==4)throw new O(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(e.rank!==4)throw new O(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return i=uu(i,e,t,n==="same"?"same":"valid","NHWC",s),o==="channelsFirst"&&(i=He(i,[0,3,1,2])),i})}var Uf=class extends fm{constructor(e){super(2,e);this.depthwiseKernel=null;this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=kt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Yt(e.depthwiseConstraint),this.depthwiseRegularizer=wt(e.depthwiseRegularizer)}build(e){if(e=Je(e),e.length<4)throw new O(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);let t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new O(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);let n=e[t],o=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G(()=>{e=Oe(e);let n=_Z(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=gn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(e){e=Je(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=Rn(t,this.kernelSize[0],this.padding,this.strides[0]),i=Rn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],o,s,i]:[e[0],s,i,o]}getConfig(){let e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=Mt(this.depthwiseInitializer),e.depthwiseRegularizer=ht(this.depthwiseRegularizer),e.depthwiseConstraint=Xt(this.depthwiseRegularizer),e}};Uf.className="DepthwiseConv2D";re.registerClass(Uf);function Av(r,e,t,n){if(Array.isArray(r)){if(e!=null||t!=null)throw new O("When inputs is an array, neither initialState or constants should be provided");n!=null&&(t=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(e=r.slice(1,r.length)),r=r[0]}function o(s){return s==null||Array.isArray(s)?s:[s]}return e=o(e),t=o(t),{inputs:r,initialState:e,constants:t}}function Nv(r,e,t,n=!1,o,s,i=!1,a=!1){return G(()=>{let u=e.shape.length;if(u<3)throw new O(`Input should be at least 3D, but is ${u}D.`);let l=[1,0].concat(nn(2,u));if(e=He(e,l),s!=null)throw new De("The rnn() functoin of the deeplearn.js backend does not support constants yet.");i&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=J(J(o,"bool"),"float32"),o.rank===u-1&&(o=Nr(o,-1)),o=He(o,l)),n&&(e=xr(e,0),o!=null&&(o=xr(o,0)));let p=[],c,m=t,d=e.shape[0],f=Or(e),h;o!=null&&(h=Or(o));for(let x=0;x<d;++x){let y=f[x],T=G(()=>r(y,m));if(o==null)c=T[0],m=T[1];else{let k=G(()=>{let C=h[x],A=pe(Dr(C),C),M=X(R(T[0],C),R(m[0],A)),P=m.map((F,B)=>X(R(T[1][B],C),R(F,A)));return{output:M,newStates:P}});c=k.output,m=k.newStates}a&&p.push(c)}let g;return a&&(g=fr(p,1)),[c,g,m]})}var Dv=class extends We{constructor(e){super(e);let t;if(e.cell==null)throw new O("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new xm({cells:e.cell}):t=e.cell,t.stateSize==null)throw new O("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Ft({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return nn(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){cy(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);let n=t[0],o;if(this.returnSequences?o=[e[0],e[1],n]:o=[e[0],n],this.returnState){let s=[];for(let i of t)s.push([e[0],i]);return[o].concat(s)}else return o}computeMask(e,t){return G(()=>{Array.isArray(t)&&(t=t[0]);let n=this.returnSequences?t:null;if(this.returnState){let o=this.states.map(s=>null);return[n].concat(o)}else return n})}get states(){if(this.states_==null){let e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){let t=null;if(this.numConstants!=null)throw new De("Constants support is not implemented in RNN yet.");cy(e)&&(e=e[0]),e=e;let n=this.stateful?e[0]:null,o=e.slice(2);this.inputSpec[0]=new Ft({shape:[n,null,...o]});let s=[e[0]].concat(e.slice(2));if(t!=null)throw new De("Constants support is not implemented in RNN yet.");this.cell.build(s);let i;if(Array.isArray(this.cell.stateSize)?i=this.cell.stateSize:i=[this.cell.stateSize],this.stateSpec!=null){if(!b.arraysEqual(this.stateSpec.map(a=>a.shape[a.shape.length-1]),i))throw new O(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=i.map(a=>new Ft({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){G(()=>{if(!this.stateful)throw new Zn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>xt([n,o])):this.states_=[xt([n,this.cell.stateSize])];else if(e==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>xt([n,o])):this.states_[0]=xt([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let o=0;o<this.states_.length;++o){let s=e[o],i=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,a=[n,i];if(!b.arraysEqual(s.shape,a))throw new O(`State ${o} is incompatible with layer ${this.name}: expected shape=${a}, received shape=${s.shape}`);this.states_[o]=s}}this.states_=this.states_.map(o=>Vt(o.clone()))})}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=Av(e,n,o,this.numConstants);e=s.inputs,n=s.initialState,o=s.constants;let i=[],a=[];if(n!=null){t.initialState=n,i=i.concat(n),this.stateSpec=[];for(let l of n)this.stateSpec.push(new Ft({shape:l.shape}));a=a.concat(this.stateSpec)}if(o!=null&&(t.constants=o,i=i.concat(o),this.numConstants=o.length),i[0]instanceof yn){let l=[e].concat(i),p=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=p;let m=super.apply(l,t);return this.inputSpec=c,m}else return super.apply(e,t)}call(e,t){return G(()=>{let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;e=Oe(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));let i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==i)throw new O(`RNN Layer has ${i} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let a={training:o},l=Nv((f,h)=>{let g=this.cell.call([f].concat(h),a);return[g[0],g.slice(1)]},e,s,this.goBackwards,n,null,this.unroll,this.returnSequences),p=l[0],c=l[1],m=l[2];this.stateful&&this.resetStates(m,o);let d=this.returnSequences?c:p;return this.returnState?[d].concat(m):d})}getInitialState(e){return G(()=>{let t=xt(e.shape);return t=he(t,[1,2]),t=gu(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?ay(t,[1,n]):t):this.cell.stateSize>1?[ay(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){let e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===Dv.className&&(t.cell={className:this.cell.getClassName(),config:n}),{...n,...e,...t}}static fromConfig(e,t,n={}){let o=t.cell,s=xn(o,n);return new e(Object.assign(t,{cell:s}))}},Ks=Dv;Ks.className="RNN";re.registerClass(Ks);var pl=class extends We{},bm=class extends pl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=e.units,or(this.units,"units"),this.activation=La(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=dp([1,Ma([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=dp([1,Ma([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Je(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G(()=>{if(e=e,e.length!==2)throw new O(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];let o=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yu({ones:()=>Dr(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yu({ones:()=>Dr(n),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let s,i=this.dropoutMask,a=this.recurrentDropoutMask;i!=null?s=Ws(R(e,i),this.kernel.read()):s=Ws(e,this.kernel.read()),this.bias!=null&&(s=gn(s,this.bias.read())),a!=null&&(n=R(n,a));let u=X(s,Ws(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ra(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:ht(this.kernelRegularizer),recurrentRegularizer:ht(this.recurrentRegularizer),biasRegularizer:ht(this.biasRegularizer),activityRegularizer:ht(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return{...e,...t}}};bm.className="SimpleRNNCell";re.registerClass(bm);var Wf=class extends Ks{constructor(e){e.cell=new bm(e);super(e)}call(e,t){return G(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return new e(t)}};Wf.className="SimpleRNN";re.registerClass(Wf);var ym=class extends pl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(e.resetAfter)throw new O("GRUCell does not support reset_after parameter set to true.");this.units=e.units,or(this.units,"units"),this.activation=La(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=La(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=dp([1,Ma([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=dp([1,Ma([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Je(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return G(()=>{if(e=e,e.length!==2)throw new O(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training==null?!1:t.training,o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yu({ones:()=>Dr(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yu({ones:()=>Dr(o),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));let s=this.dropoutMask,i=this.recurrentDropoutMask,a,u,l;0<this.dropout&&this.dropout<1&&(e=R(e,s[0]));let p=Ws(e,this.kernel.read());this.useBias&&(p=gn(p,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=R(o,i[0]));let c=this.recurrentKernel.read(),[m,d]=Ir(c,[2*this.units,this.units],c.rank-1),f=Ws(o,m),[h,g,x]=Ir(p,3,p.rank-1),[y,T]=Ir(f,2,f.rank-1);a=this.recurrentActivation.apply(X(h,y)),u=this.recurrentActivation.apply(X(g,T));let k=Ws(R(u,o),d);l=this.activation.apply(X(x,k));let C=X(R(a,o),R(X(1,Ze(a)),l));return[C,C]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ra(this.activation),recurrentActivation:Ra(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:ht(this.kernelRegularizer),recurrentRegularizer:ht(this.recurrentRegularizer),biasRegularizer:ht(this.biasRegularizer),activityRegularizer:ht(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return{...e,...t}}};ym.className="GRUCell";re.registerClass(ym);var Kf=class extends Ks{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new ym(e);super(e)}call(e,t){return G(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Kf.className="GRU";re.registerClass(Kf);var cl=class extends pl{constructor(e){super(e);this.DEFAULT_ACTIVATION="tanh";this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid";this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_RECURRENT_INITIALIZER="orthogonal";this.DEFAULT_BIAS_INITIALIZER="zeros";this.units=e.units,or(this.units,"units"),this.activation=La(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=La(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=kt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=wt(e.kernelRegularizer),this.recurrentRegularizer=wt(e.recurrentRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.kernelConstraint=Yt(e.kernelConstraint),this.recurrentConstraint=Yt(e.recurrentConstraint),this.biasConstraint=Yt(e.biasConstraint),this.dropout=dp([1,Ma([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=dp([1,Ma([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var o;e=Je(e);let t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let n;if(this.useBias){if(this.unitForgetBias){let s=this.biasInitializer,i=this.units;n=new(o=class extends En{apply(u,l){let p=s.apply([i]),c=new gp().apply([i]),m=s.apply([i*2]);return jC(jC(p,c),m)}},o.className="CustomInit",o)}else n=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,n,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return G(()=>{let n=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new O(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1],s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yu({ones:()=>Dr(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yu({ones:()=>Dr(o),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));let i=this.dropoutMask,a=this.recurrentDropoutMask,u,l,p,c;0<this.dropout&&this.dropout<1&&(e=R(e,i[0]));let m=Ws(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=R(o,a[0])),m=X(m,Ws(o,this.recurrentKernel.read())),this.useBias&&(m=gn(m,this.bias.read()));let[d,f,h,g]=Ir(m,4,m.rank-1);u=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(f),p=X(R(l,s),R(u,this.activation.apply(h))),c=this.recurrentActivation.apply(g);let x=R(c,this.activation.apply(p));return[x,x,p]})}getConfig(){let e=super.getConfig(),t={units:this.units,activation:Ra(this.activation),recurrentActivation:Ra(this.recurrentActivation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),recurrentInitializer:Mt(this.recurrentInitializer),biasInitializer:Mt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:ht(this.kernelRegularizer),recurrentRegularizer:ht(this.recurrentRegularizer),biasRegularizer:ht(this.biasRegularizer),activityRegularizer:ht(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),recurrentConstraint:Xt(this.recurrentConstraint),biasConstraint:Xt(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return{...e,...t}}};cl.className="LSTMCell";re.registerClass(cl);var Vf=class extends Ks{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new cl(e);super(e)}call(e,t){return G(()=>{this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Vf.className="LSTM";re.registerClass(Vf);var xm=class extends pl{constructor(e){super(e);this.cells=e.cells}get stateSize(){let e=[];for(let t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return G(()=>{e=e;let n=e.slice(1),o=[];for(let a of this.cells.slice().reverse())Array.isArray(a.stateSize)?o.push(n.splice(0,a.stateSize.length)):o.push(n.splice(0,1));o.reverse();let s=[],i;for(let a=0;a<this.cells.length;++a){let u=this.cells[a];n=o[a],a===0?i=[e[0]].concat(n):i=[i[0]].concat(n),i=u.call(i,t),s.push(i.slice(1))}n=[];for(let a of s.slice().reverse())n.push(...a);return[i[0]].concat(n)})}build(e){cy(e)&&(e=e[0]),e=e;let t;this.cells.forEach((n,o)=>{Pa(`RNNCell_${o}`,()=>{n.build(e),Array.isArray(n.stateSize)?t=n.stateSize[0]:t=n.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){let e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),o={cells:this.cells.map(t)};return{...e,...o}}static fromConfig(e,t,n={}){let o=[];for(let s of t.cells)o.push(xn(s,n));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];let e=[];for(let t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){let e=[];for(let t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){let t=[];for(let n of this.cells)t.push(...n.trainableWeights);return t.concat(e)}return e}getWeights(){let e=[];for(let t of this.cells)e.push(...t.weights);return yf(e)}setWeights(e){let t=[];for(let n of this.cells){let o=n.weights.length,s=e.splice(o);for(let i=0;i<n.weights.length;++i)t.push([n.weights[i],s[i]])}um(t)}};xm.className="StackedRNNCells";re.registerClass(xm);function yu(r){let{ones:e,rate:t,training:n=!1,count:o=1,dropoutFunc:s}=r,i=()=>s!=null?s(e(),t):uy(e(),t),a=()=>nl(i,e,n);return!o||o<=1?Vt(a().clone()):Array(o).fill(void 0).map(a).map(l=>Vt(l.clone()))}var Pv=class extends Ks{constructor(e){if(e.unroll)throw new De("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new De("It is not possible at the moment to stack convolutional cells.");super(e);this.inputSpec=[new Ft({ndim:5})]}call(e,t){return G(()=>{if(this.cell.dropoutMask!=null&&(Fe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Fe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new O("ConvRNN2D cell does not support constants");let n=t==null?null:t.mask,o=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:n,training:o,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return G(()=>{let{stateSize:t}=this.cell,n=e.shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)],i=xt(s);return Array.isArray(t)?Array(t.length).fill(i):[i]})}resetStates(e,t=!1){G(()=>{if(!this.stateful)throw new Zn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,o=this.computeSingleOutputShape(n),s=[o[0],...o.slice(2)];if(n[0]==null)throw new O("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xt(s)):this.states_=[xt(s)];else if(e==null)Fe(this.states_),this.keptStates!=null&&(Fe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>xt(s)):this.states_[0]=xt(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new O(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Fe(this.states_);for(let a=0;a<this.states_.length;++a){let u=e[a],l=s;if(!b.arraysEqual(u.shape,l))throw new O(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${u.shape}`);this.states_[a]=u}}this.states_=this.states_.map(a=>Vt(a.clone()))})}computeSingleOutputShape(e){let{dataFormat:t,filters:n,kernelSize:o,padding:s,strides:i,dilationRate:a}=this.cell,u=t==="channelsFirst",l=e[u?3:2],p=e[u?4:3],c=Rn(l,o[0],s,i[0],a[0]),m=Rn(p,o[1],s,i[1],a[1]);return[...e.slice(0,2),...u?[n,c,m]:[c,m,n]]}};Pv.className="ConvRNN2D";var Tm=class extends cl{constructor(e){let{filters:t,kernelSize:n,strides:o,padding:s,dataFormat:i,dilationRate:a}=e;super({...e,units:t});this.filters=t,or(this.filters,"filters"),this.kernelSize=ll(n,2,"kernelSize"),this.kernelSize.forEach(u=>or(u,"kernelSize")),this.strides=ll(o||1,2,"strides"),this.strides.forEach(u=>or(u,"strides")),this.padding=s||"valid",hn(this.padding),this.dataFormat=i||"channelsLast",jt(this.dataFormat),this.dilationRate=ll(a||1,2,"dilationRate"),this.dilationRate.forEach(u=>or(u,"dilationRate"))}build(e){var a;e=Je(e);let t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new O(`The channel dimension of the input should be defined. Found ${e[t]}`);let n=e[t],o=4,s=this.kernelSize.concat([n,this.filters*o]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let i=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let l=this.biasInitializer,p=this.filters;u=new(a=class extends En{apply(m,d){let f=l.apply([p]),h=dr([p]),g=l.apply([p*2]);return Zc([f,h,g])}},a.className="CustomInit",a)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return G(()=>{if(e.length!==3)throw new O(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let n=t.training||!1,o=e[0],s=e[1],i=e[2],a=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=yu({ones:()=>Dr(o),rate:this.dropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let u=this.dropoutMask,l=(oe,ie,se)=>!ie||!ie[se]?oe:R(ie[se],oe),p=l(o,u,0),c=l(o,u,1),m=l(o,u,2),d=l(o,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=yu({ones:()=>Dr(s),rate:this.recurrentDropout,training:n,count:a,dropoutFunc:this.dropoutFunc}));let f=this.recurrentDropoutMask,h=l(s,f,0),g=l(s,f,1),x=l(s,f,2),y=l(s,f,3),T=3,[k,C,A,M]=Ir(this.kernel.read(),a,T),[P,F,B,U]=this.useBias?Ir(this.bias.read(),a):[null,null,null,null];p=this.inputConv(p,k,P,this.padding),c=this.inputConv(c,C,F,this.padding),m=this.inputConv(m,A,B,this.padding),d=this.inputConv(d,M,U,this.padding);let[W,K,j,V]=Ir(this.recurrentKernel.read(),a,T);h=this.recurrentConv(h,W),g=this.recurrentConv(g,K),x=this.recurrentConv(x,j),y=this.recurrentConv(y,V);let q=this.recurrentActivation.apply(X(p,h)),ee=this.recurrentActivation.apply(X(c,g)),Z=X(R(ee,i),R(q,this.activation.apply(X(m,x)))),te=R(this.recurrentActivation.apply(X(d,y)),this.activation.apply(Z));return[te,te,Z]})}getConfig(){let{units:e,...t}=super.getConfig(),n={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return{...t,...n}}inputConv(e,t,n,o){let s=Yn(e,t,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?gn(s,n,this.dataFormat):s}recurrentConv(e,t){return Yn(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Tm.className="ConvLSTM2DCell";re.registerClass(Tm);var jf=class extends Pv{constructor(e){let t=new Tm(e);super({...e,cell:t})}static fromConfig(e,t){return new e(t)}};jf.className="ConvLSTM2D";re.registerClass(jf);var km=class extends We{constructor(e){super(e);this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;let t=e.shape,n=[];for(let o=0;o<this.noiseShape.length;++o)n.push(this.noiseShape[o]==null?t[o]:this.noiseShape[o]);return n}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e);if(0<this.rate&&this.rate<1){let o=t.training==null?!1:t.training,s=this.getNoiseShape(n);return nl(()=>uy(n,this.rate,s,this.seed),()=>n,o)}return e})}getConfig(){let e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};km.className="Dropout";re.registerClass(km);var Hf=class extends km{constructor(e){super(e);this.inputSpec=[{ndim:3}]}getNoiseShape(e){let t=e.shape;return[t[0],1,t[2]]}};Hf.className="SpatialDropout1D";re.registerClass(Hf);var qf=class extends We{constructor(e){super(e);this.activation=null;this.useBias=!0;this.kernel=null;this.bias=null;this.DEFAULT_KERNEL_INITIALIZER="glorotNormal";this.DEFAULT_BIAS_INITIALIZER="zeros";if(e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,or(this.units,"units"),this.activation=La(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=kt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=kt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Yt(e.kernelConstraint),this.biasConstraint=Yt(e.biasConstraint),this.kernelRegularizer=wt(e.kernelRegularizer),this.biasRegularizer=wt(e.biasRegularizer),this.activityRegularizer=wt(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Je(e);let t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Je(e);let t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e),o=ry(this.activation.getClassName()),s;return o!=null?s=Ws(n,this.kernel.read(),o,this.bias?this.bias.read():null):(s=Ws(n,this.kernel.read()),this.bias!=null&&(s=gn(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){let e={units:this.units,activation:Ra(this.activation),useBias:this.useBias,kernelInitializer:Mt(this.kernelInitializer),biasInitializer:Mt(this.biasInitializer),kernelRegularizer:ht(this.kernelRegularizer),biasRegularizer:ht(this.biasRegularizer),activityRegularizer:ht(this.activityRegularizer),kernelConstraint:Xt(this.kernelConstraint),biasConstraint:Xt(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};qf.className="Dense";re.registerClass(qf);var Xf=class extends We{constructor(e){e=e||{};super(e);this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Je(e);for(let t of e.slice(1))if(t==null)throw new O(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Us(e,1)]}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e);if(this.dataFormat==="channelsFirst"&&n.rank>1){let o=[0];for(let s=2;s<n.rank;++s)o.push(s);o.push(1),n=He(n,o)}return kM(n)})}getConfig(){let e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);let t=super.getConfig();return Object.assign(e,t),e}};Xf.className="Flatten";re.registerClass(Xf);var Yf=class extends We{constructor(e){super(e);this.supportsMasking=!0,this.activation=La(e.activation)}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e);return this.activation.apply(n)})}getConfig(){let e={activation:Ra(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};Yf.className="Activation";re.registerClass(Yf);var Qf=class extends We{constructor(e){super(e);this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return G(()=>(e=Oe(e),xM(e,this.n)))}getConfig(){let e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};Qf.className="RepeatVector";re.registerClass(Qf);var Zf=class extends We{constructor(e){super(e);this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){let n="Total size of new array must be unchanged.",o=t.slice(),s=1,i=null;for(let u=0;u<o.length;++u){let l=o[u];if(this.isUnknown(l))if(i===null)i=u;else throw new O("Can only specifiy one unknown dimension.");else s*=l}let a=Us(e);if(i!==null){if(s===0||a%s!=0)throw new O(n);o[i]=a/s}else if(a!==s)throw new O(n);return o}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e),o=n.shape,s=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return L(n,s)})}getConfig(){let e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Zf.className="Reshape";re.registerClass(Zf);var Jf=class extends We{constructor(e){super(e);if(e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);let t=nn(1,e.dims.length+1);if(!b.arraysEqual(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Ft({ndim:this.dims.length+1})]}computeOutputShape(e){e=Je(e);let t=e.slice();return this.dims.forEach((n,o)=>{t[o+1]=e[n]}),t}call(e,t){return He(Oe(e),this.dimsIncludingBatch)}getConfig(){let e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};Jf.className="Permute";re.registerClass(Jf);var eh=class extends We{constructor(e){super(e??{});this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){let n=Oe(e),o=-1;return zc(li(n,this.maskValue),o)}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e),o=-1,s=!0,i=zc(li(n,this.maskValue),o,s);return R(n,J(i,n.dtype))})}};eh.className="Masking";re.registerClass(eh);var th=class extends We{constructor(e){super(e);this.embeddings=null;this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform";if(e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(St(e.inputLength))}this.inputDim=e.inputDim,or(this.inputDim,"inputDim"),this.outputDim=e.outputDim,or(this.outputDim,"outputDim"),this.embeddingsInitializer=kt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=wt(e.embeddingsRegularizer),this.activityRegularizer=wt(e.activityRegularizer),this.embeddingsConstraint=Yt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return G(()=>this.maskZero?(e=Oe(e),li(e,Ne(e))):null)}computeOutputShape(e){if(e=Je(e),this.inputLength==null)return[...e,this.outputDim];let t=St(this.inputLength);if(t.length!==e.length-1)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let o=0;o<t.length;++o){let s=t[o],i=e[o+1];if(s!=null&&i!=null&&s!==i)throw new O(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e);n.dtype!=="int32"&&(n=fp(n,"int32"));let o=iy(this.embeddings.read(),L(n,[n.size]));return L(o,Je(this.computeOutputShape(n.shape)))})}getConfig(){let e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:Mt(this.embeddingsInitializer),embeddingsRegularizer:ht(this.embeddingsRegularizer),activityRegularizer:ht(this.activityRegularizer),embeddingsConstraint:Xt(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};th.className="Embedding";re.registerClass(th);var ml=class extends We{constructor(e){super(e||{});this.supportsMasking=!0}mergeFunction(e){throw new De}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;let n=e.slice(0,e.length-t.length);for(let o=0;o<t.length;++o){let s=e[e.length-t.length+o],i=t[o];if(s==null||i==null||s<0||i<0)n.push(null);else if(s===1)n.push(i);else if(i===1)n.push(s);else{if(s!==i)throw new O("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(s)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Je(e)]),e=e,e.length<2)throw new O(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(let s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Gs(t),t.length>1)throw new O(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){let i=e[s]==null?null:e[s].slice(1);n=this.computeElementwiseOpOutputShape(n,i)}let o=e.map(s=>s.length);e.indexOf(null)===-1&&Gs(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return G(()=>{if(e=e,this.reshapeRequired){let n=[],o=e.map(s=>s.rank);if(o.indexOf(null)===-1){let s=Ma(o);for(let i of e){let a=i.rank;for(let u=0;u<s-a;++u)i=gu(i,1);n.push(i)}return this.mergeFunction(n)}else{let s=!1;for(let u of e){let l=u.rank;if(l==null){let p=u.shape,c=p[0],m=p.slice(1).concat([c]),d=L(u,[c].concat(Us(p.slice(1))));d=He(d,[1,0]),d=L(d,m),n.push(d),s=!0}else if(l>1){let p=nn(1,l).concat([0]);n.push(He(u,p)),s=!0}else n.push(u)}let i=this.mergeFunction(n),a=i.rank;if(s){if(a==null){let u=i.shape,l=u.length,p=u[l-1],c=[p].concat(u.slice(0,u.length-1));i=L(He(L(i,[-1,p]),[1,0]),c)}else if(a>1){let u=[a-1].concat(nn(0,a-1));i=He(i,u)}}return i}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let o=1;o<e.length;++o){let s=e[o]==null?null:e[o].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let n=[];for(let o of e)o!=null&&o[0]!==null&&n.push(o[0]);return n=Gs(n),n.length===1?t=n.concat(t):t=[null].concat(t),t}computeMask(e,t){return G(()=>{if(t==null)return null;if(!Array.isArray(t))throw new O("`mask` should be an Array");if(!Array.isArray(e))throw new O("`inputs` should be an Array");if(t.length!==e.length)throw new O(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(o=>o==null))return null;t=t.map(o=>o==null?o:Nr(o,0));let n=t[0];for(let o=1;o<t.length-1;++o)n=Hr(n,t[o]);return n})}},rh=class extends ml{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return t})}};rh.className="Add";re.registerClass(rh);var nh=class extends ml{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=R(t,e[n]);return t})}};nh.className="Multiply";re.registerClass(nh);var oh=class extends ml{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=X(t,e[n]);return R(1/e.length,t)})}};oh.className="Average";re.registerClass(oh);var sh=class extends ml{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Qn(t,e[n]);return t})}};sh.className="Maximum";re.registerClass(sh);var ah=class extends ml{constructor(e){super(e)}mergeFunction(e){return G(()=>{let t=e[0];for(let n=1;n<e.length;++n)t=cu(t,e[n]);return t})}};ah.className="Minimum";re.registerClass(ah);var ih=class extends ml{constructor(e){super(e);this.DEFAULT_AXIS=-1;e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new O("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(let o of e)if(o!=null){t=!1;break}if(t)return;let n=[];for(let o=0;o<e.length;++o){let s=e[o].slice();s.splice(this.axis,1);let i=!1;for(let a of n)if(b.arraysEqual(a,s)){i=!0;break}i||n.push(s)}if(n.length>1)throw new O("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return G(()=>Zc(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new O("A `Concatenate` layer should be called on a list of inputs.");let t=e,n=t[0].slice(),o=this.axis<0?n.length+this.axis:this.axis;for(let s of t.slice(1)){if(n[o]==null||s[o]==null){n[o]=null;break}n[o]+=s[o]}return n}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new O("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new O("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new O(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return G(()=>{let n=!0;if(t.forEach(i=>{if(i!=null){n=!1;return}}),n)return null;let o=[];for(let i=0;i<e.length;++i)t[i]==null?o.push(J(Dr(e[i]),"bool")):t[i].rank<e[i].rank?o.push(Nr(t[i],-1)):o.push(t[i]);let s=lt(o,this.axis);return Nd(s,-1,!1)})}getConfig(){let e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};ih.className="Concatenate";re.registerClass(ih);function uh(r,e){for(;r<0;)r+=e;return r}function AZ(r,e,t){if(r.shape.length>3||e.shape.length>3)throw new De("batchDot is not implemented for tensors of 4D or higher rank yet");if(b.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),b.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),r.dtype==="complex64"||e.dtype==="complex64")throw new De("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,o=e.shape.length;t==null&&(t=[n-1,o-2]);let s=t;return G(()=>{let i;if(n>o){i=n-o;let u=[];for(let l=0;l<i;++l)u.push(1);e=L(e,e.shape.concat(u))}else if(o>n){i=o-n;let u=[];for(let l=0;l<i;++l)u.push(1);r=L(r,r.shape.concat(u))}else i=0;let a;if(r.shape.length===2&&e.shape.length===2)s[0]===s[1]?a=he(R(r,e),s[0]):a=he(R(He(r,[1,0]),e),s[1]);else{let u=s[0]!==r.shape.length-1,l=s[1]===e.shape.length-1;a=Ve(r,e,u,l)}if(i>0){let u;n>o?u=n+o-3:u=n-1;let l=[];for(let p=u;p<u+i;++p)l.push(p);a=dn(a,l)}return a.shape.length===1&&(a=Nr(a,1)),a})}var lh=class extends ml{constructor(e){super(e);this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0],n=e[1];if(t.length>3||n.length>3)throw new De("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);if(t[o[0]]!==n[o[1]])throw new O(`Dimension incompatibility: ${t[o[0]]} !== ${n[o[1]]}`)}mergeFunction(e){if(e.length!==2)throw new O(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],n=e[1],o;return Array.isArray(this.axes)?o=this.axes.map((s,i)=>uh(s,e[i].shape.length)):o=[uh(this.axes,t.shape.length),uh(this.axes,n.shape.length)],this.normalize&&(t=Tf(t,o[0]),n=Tf(n,o[1])),AZ(t,n,o)}interpretAxes(e,t){let n;return Array.isArray(this.axes)?n=this.axes:n=[uh(this.axes,e.length),uh(this.axes,t.length)],n}computeOutputShape(e){b.assert(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new De("Dot layer does not support tensors of 4D or higher rank yet.");let o=this.interpretAxes(t,n);t.splice(o[0],1),n.splice(o[1],1),n.splice(0,1);let s=t.concat(n);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){let e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};lh.className="Dot";re.registerClass(lh);var ph=class extends We{constructor(e){super(e);this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e);return nl(()=>X(Jc(n.shape,0,this.stddev),n),()=>n,t.training||!1)})}};ph.className="GaussianNoise";re.registerClass(ph);var ch=class extends We{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return G(()=>{this.invokeCallHook(e,t);let n=Oe(e);return this.rate>0&&this.rate<1?nl(()=>{let s=Math.sqrt(this.rate/(1-this.rate));return R(n,Jc(n.shape,1,s))},()=>n,t.training||!1):n})}};ch.className="GaussianDropout";re.registerClass(ch);var mh=class extends We{constructor(e){super(e);this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Oe(e).shape}computeOutputShape(e){return e}getConfig(){let e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return G(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(e);return nl(()=>{let s=Oe(e),i=1.6732632423543772,a=1.0507009873554805,u=-i*a,l=Qo(Na(n),this.rate);l=fp(l,"float32");let p=((1-this.rate)*(1+this.rate*u**2))**-.5,c=-p*u*this.rate,m=X(R(s,l),R(X(l,-1),u));return X(R(m,p),c)},()=>Oe(e),t.training||!1)}return e})}};mh.className="AlphaDropout";re.registerClass(mh);function dh(r,e,t,n,o,s=.001){let i;if(r.rank===2)i=$I(r,e,t,n,o,s);else if(r.rank===3)i=OI(r,e,t,n,o,s);else if(r.rank===4)i=zI(r,e,t,n,o,s);else throw new De(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return i}function NZ(r,e,t,n,o=.001){return G(()=>{let s=Vc(r,n),i=s.mean,a=s.variance;return[dh(r,i,a,t,e,o),i,a]})}function DZ(r,e,t,n,o=.001){return G(()=>{let s=Vc(r,n),i=s.mean,a=s.variance,u=[];for(let f of nn(0,r.rank))n.indexOf(f)!==-1?u.push(1):u.push(r.shape[f]);let l=L(i,u),p=L(a,u),c=e==null?null:L(e,u),m=t==null?null:L(t,u);return[dh(r,l,p,m,c,o),i,a]})}function PZ(r,e,t,n,o=.001){return b.arraysEqual(n.slice().sort(),nn(0,r.rank-1))?NZ(r,e,t,n,o):DZ(r,e,t,n,o)}var fh=class extends We{constructor(e){e==null&&(e={});super(e);this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.movingMeanInitializer=kt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=kt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Yt(e.betaConstraint),this.gammaConstraint=Yt(e.gammaConstraint),this.betaRegularizer=wt(e.betaRegularizer),this.gammaRegularizer=wt(e.gammaRegularizer)}build(e){e=Je(e);let t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(n==null)throw new O(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Ft({ndim:e.length,axes:{[t]:n}})];let o=[n];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return G(()=>{let n=t.training==null?!1:t.training,o=Oe(e),s=o.shape,i=s.length,a=nn(0,i),u=this.axis>=0?this.axis:this.axis+i;a.splice(u,1);let l=$s(1,i);l[u]=s[u];let p=a.slice();p.sort();let c=!b.arraysEqual(p,nn(0,i).slice(0,i-1)),m=()=>{if(c){let y=L(this.movingMean.read(),l),T=L(this.movingVariance.read(),l),k=this.center?L(this.beta.read(),l):null,C=this.scale?L(this.gamma.read(),l):null;return dh(o,y,T,k,C,this.epsilon)}else return dh(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return m();let[d,f,h]=PZ(o,this.gamma.read(),this.beta.read(),a,this.epsilon),g=(y,T,k)=>{G(()=>{let C=1-k,A=y.read(),M=R(pe(A,T),C);y.write(pe(A,M))})};return(()=>{g(this.movingMean,f,this.momentum),g(this.movingVariance,h,this.momentum)})(),d})}getConfig(){let e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),movingMeanInitializer:Mt(this.movingMeanInitializer),movingVarianceInitializer:Mt(this.movingVarianceInitializer),betaRegularizer:ht(this.betaRegularizer),gammaRegularizer:ht(this.gammaRegularizer),betaConstraint:Xt(this.betaConstraint),gammaConstraint:Xt(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};fh.className="BatchNormalization";re.registerClass(fh);var hh=class extends We{constructor(e){e==null&&(e={});super(e);if(this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=kt(e.betaInitializer||"zeros"),this.gammaInitializer=kt(e.gammaInitializer||"ones"),this.betaRegularizer=wt(e.betaRegularizer),this.gammaRegularizer=wt(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Je(e);let t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(let s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Gs(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(s=>e[s]),o=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(e,t){let n=Oe(e),o=n.shape,s=o.length;return G(()=>{let i=!0,{mean:a,variance:u}=Vc(n,this.axis,i),l=$s(1,s);for(let h of this.axis)l[h]=o[h];let p=h=>h!=null&&h.shape.length!==s?L(h,l):h,c=p(this.gamma.read()),m=p(this.beta.read()),d=[],f=[];for(let h=0;h<s;++h)this.axis.indexOf(h)!==-1?(d.push(o[h]),f.push(1)):(d.push(1),f.push(o[h]));return a=jr(a,d),u=jr(u,d),c=jr(c,f),m=jr(m,f),dh(n,a,u,m,c,this.epsilon)})}getConfig(){let e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:Mt(this.betaInitializer),gammaInitializer:Mt(this.gammaInitializer),betaRegularizer:ht(this.betaRegularizer),gammaRegularizer:ht(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};hh.className="LayerNormalization";re.registerClass(hh);function MZ(r,e,t){return G(()=>{if(r.rank!==4)throw new O(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new O("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=fn()),t!=="channelsLast"&&t!=="channelsFirst")throw new O(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return t==="channelsFirst"?n=[[0,0],[0,0],e[0],e[1]]:n=[[0,0],e[0],e[1],[0,0]],Pn(r,n)})}var gh=class extends We{constructor(e){e==null&&(e={});super(e);if(this.dataFormat=e.dataFormat==null?fn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new O(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new O(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new O(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){e=Je(e);let t,n;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?n=e[3]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],e[1],t,n]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?n=e[2]+this.padding[1][0]+this.padding[1][1]:n=null,[e[0],t,n,e[3]])}call(e,t){return G(()=>MZ(Oe(e),this.padding,this.dataFormat))}getConfig(){let e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};gh.className="ZeroPadding2D";re.registerClass(gh);function Ny(r,e,t,n,o,s){return G(()=>{jt(o),KC(s),hn(n),t==null&&(t=[1,1]),n==null&&(n="valid"),o==null&&(o=fn()),s==null&&(s="max"),r=Rf(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=ql(r,e,t,a):i=zl(r,e,t,a),o==="channelsFirst"&&(i=He(i,[0,3,1,2])),i})}function iF(r,e,t,n,o,s){return G(()=>{jt(o),KC(s),hn(n),t==null&&(t=[1,1,1]),n==null&&(n="valid"),o==null&&(o=fn()),s==null&&(s="max"),r=Cv(r,o);let i,a=n==="same"?"same":"valid";return s==="max"?i=Gd(r,e,t,a):i=Dd(r,e,t,a),o==="channelsFirst"&&(i=He(i,[0,4,1,2,3])),i})}var Mv=class extends We{constructor(e){e.poolSize==null&&(e.poolSize=2);super(e);if(typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new O(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(or(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new O(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,hn(this.padding),this.inputSpec=[new Ft({ndim:3})]}computeOutputShape(e){e=Je(e);let t=Rn(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return G(()=>{this.invokeCallHook(e,t),e=gu(Oe(e),2);let n=this.poolingFunction(Oe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return dn(n,[2])})}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},bh=class extends Mv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return jt(s),hn(o),Ny(e,t,n,o,s,"max")}};bh.className="MaxPooling1D";re.registerClass(bh);var yh=class extends Mv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return jt(s),hn(o),Ny(e,t,n,o,s,"avg")}};yh.className="AveragePooling1D";re.registerClass(yh);var Fv=class extends We{constructor(e){e.poolSize==null&&(e.poolSize=[2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new O(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];or(this.poolSize,"poolSize"),or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,jt(this.dataFormat),hn(this.padding),this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){e=Je(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Rn(t,this.poolSize[0],this.padding,this.strides[0]),n=Rn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return G(()=>(this.invokeCallHook(e,t),this.poolingFunction(Oe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},xh=class extends Fv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return jt(s),hn(o),Ny(e,t,n,o,s,"max")}};xh.className="MaxPooling2D";re.registerClass(xh);var Th=class extends Fv{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return jt(s),hn(o),Ny(e,t,n,o,s,"avg")}};Th.className="AveragePooling2D";re.registerClass(Th);var Ev=class extends We{constructor(e){e.poolSize==null&&(e.poolSize=[2,2,2]);super(e);if(this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new O(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];or(this.poolSize,"poolSize"),or(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,jt(this.dataFormat),hn(this.padding),this.inputSpec=[new Ft({ndim:5})]}computeOutputShape(e){e=Je(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],n=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Rn(t,this.poolSize[0],this.padding,this.strides[0]),n=Rn(n,this.poolSize[1],this.padding,this.strides[1]),o=Rn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,n,o]:[e[0],t,n,o,e[4]]}call(e,t){return G(()=>(this.invokeCallHook(e,t),this.poolingFunction(Oe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},kh=class extends Ev{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return jt(s),hn(o),iF(e,t,n,o,s,"max")}};kh.className="MaxPooling3D";re.registerClass(kh);var Ih=class extends Ev{constructor(e){super(e)}poolingFunction(e,t,n,o,s){return jt(s),hn(o),iF(e,t,n,o,s,"avg")}};Ih.className="AveragePooling3D";re.registerClass(Ih);var Rv=class extends We{constructor(e){super(e);this.inputSpec=[new Ft({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new De}},Ch=class extends Rv{constructor(e){super(e||{})}call(e,t){return G(()=>{let n=Oe(e);return Rt(n,1)})}};Ch.className="GlobalAveragePooling1D";re.registerClass(Ch);var vh=class extends Rv{constructor(e){super(e||{})}call(e,t){return G(()=>{let n=Oe(e);return en(n,1)})}};vh.className="GlobalMaxPooling1D";re.registerClass(vh);var Lv=class extends We{constructor(e){super(e);this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,jt(this.dataFormat),this.inputSpec=[new Ft({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new De}getConfig(){let e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},Sh=class extends Lv{call(e,t){return G(()=>{let n=Oe(e);return this.dataFormat==="channelsLast"?Rt(n,[1,2]):Rt(n,[2,3])})}};Sh.className="GlobalAveragePooling2D";re.registerClass(Sh);var wh=class extends Lv{call(e,t){return G(()=>{let n=Oe(e);return this.dataFormat==="channelsLast"?en(n,[1,2]):en(n,[2,3])})}};wh.className="GlobalMaxPooling2D";re.registerClass(wh);var Bv=class extends We{constructor(e){super(e);this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){let e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,n={}){let o=t.layer,s=xn(o,n);delete t.layer;let i={layer:s};return Object.assign(i,t),new e(i)}},_h=class extends Bv{constructor(e){super(e);this.supportsMasking=!0}build(e){if(e=Je(e),e.length<3)throw new O(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];let t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Je(e);let t=[e[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),o=e[1];return[n[0],o].concat(n.slice(1))}call(e,t){return G(()=>(e=Oe(e),Nv((i,a)=>[Oe(this.layer.call(i,t)),[]],e,[],!1,null,null,!1,!0)[1]))}};_h.className="TimeDistributed";re.registerClass(_h);function FZ(r){di(fM,"BidirectionalMergeMode",r)}var EZ="concat",Ah=class extends Bv{constructor(e){super(e);let t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=xn(n),t.goBackwards=t.goBackwards!==!0;let o={};if(o.className=e.layer.getClassName(),o.config=t,this.backwardLayer=xn(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?EZ:e.mergeMode,FZ(this.mergeMode),e.weights)throw new De("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){let t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let n,o,s;return this.returnState&&(s=t.slice(1)),n=t[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,o=[n]):this.mergeMode==null?o=[n,n.slice()]:o=[n],this.returnState?this.mergeMode==null?o.concat(s).concat(s.slice()):[n].concat(s).concat(s.slice()):Pr(o)}apply(e,t){let n=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});let s=Av(e,n,o,this.numConstants);if(e=s.inputs,n=s.initialState,o=s.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(n==null||n.length===0)&&o==null)return super.apply(e,t);let i=[],a=[];if(n!=null){let l=n.length;if(l%2>0)throw new O("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);let p=n.map(c=>new Ft({shape:c.shape}));this.forwardLayer.stateSpec=p.slice(0,l/2),this.backwardLayer.stateSpec=p.slice(l/2),a.push(...p)}if(o!=null)throw new De("Support for constants in Bidirectional layers is not implemented yet.");let u=i[0]instanceof yn;for(let l of i)if(l instanceof yn!==u)throw new O("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let l=[e].concat(i),p=this.inputSpec.concat(a),c=this.inputSpec;this.inputSpec=p;let m=super.apply(l,t);return this.inputSpec=c,m}else return super.apply(e,t)}call(e,t){return G(()=>{let n=t.initialState,o,s;if(n==null)o=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{let u=n.slice(0,n.length/2),l=n.slice(n.length/2);o=this.forwardLayer.call(e,Object.assign(t,{initialState:u})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let i;this.returnState&&(Array.isArray(o)&&(i=o.slice(1).concat(s.slice(1))),o=o[0],s=s[0]),this.returnSequences&&(s=xr(s,1));let a;return this.mergeMode==="concat"?a=Zc([o,s]):this.mergeMode==="sum"?a=X(o,s):this.mergeMode==="ave"?a=R(.5,X(o,s)):this.mergeMode==="mul"?a=R(o,s):this.mergeMode==null&&(a=[o,s]),this.returnState?this.mergeMode==null?a.concat(i):[a].concat(i):a})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Pa(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Pa(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[t,t]:n=t:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let s=this.forwardLayer.states.map(i=>null);return Array.isArray(n)?n.concat(s).concat(s):[n].concat(s).concat(s)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){let e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){let n=xn(t.layer);if(delete t.layer,t.numConstants!=null)throw new De("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let o=t;return o.layer=n,new e(o)}};Ah.className="Bidirectional";re.registerClass(Ah);function RZ(r){return new fi(r)}function LZ(r){return new Mf(r)}function BZ(r){return new Nf(r)}function $Z(r){return new Df(r)}function OZ(r){return new Pf(r)}function zZ(r){return new Ef(r)}function GZ(r){return new Ff(r)}function UZ(r){return new Of(r)}function WZ(r){return new hm(r)}function KZ(r){return new Lf(r)}function VZ(r){return new gm(r)}function jZ(r){return new Bf(r)}function HZ(r){return new $f(r)}function qZ(r){return new zf(r)}function XZ(r){return new Gf(r)}function YZ(r){return new Uf(r)}function QZ(r){return new Yf(r)}function ZZ(r){return new qf(r)}function JZ(r){return new km(r)}function e9(r){return new Hf(r)}function t9(r){return new Xf(r)}function r9(r){return new Qf(r)}function n9(r){return new Zf(r)}function o9(r){return new Jf(r)}function s9(r){return new th(r)}function a9(r){return new rh(r)}function i9(r){return new oh(r)}function u9(r){return new ih(r)}function l9(r){return new sh(r)}function p9(r){return new ah(r)}function c9(r){return new nh(r)}function m9(r){return new lh(r)}function d9(r){return new fh(r)}function f9(r){return new hh(r)}function h9(r){return new gh(r)}function $v(r){return new yh(r)}function g9(r){return $v(r)}function b9(r){return $v(r)}function Ov(r){return new Th(r)}function y9(r){return Ov(r)}function x9(r){return Ov(r)}function zv(r){return new Ih(r)}function T9(r){return zv(r)}function k9(r){return zv(r)}function I9(r){return new Ch(r)}function C9(r){return new Sh(r)}function uF(r){return new vh(r)}function lF(r){return new wh(r)}function pF(r){return new bh(r)}function cF(r){return new xh(r)}function v9(r){return new kh(r)}function S9(r){return new Kf(r)}function w9(r){return new ym(r)}function _9(r){return new Vf(r)}function A9(r){return new cl(r)}function N9(r){return new Wf(r)}function D9(r){return new bm(r)}function P9(r){return new jf(r)}function M9(r){return new Tm(r)}function F9(r){return new Ks(r)}function E9(r){return new xm(r)}function R9(r){return new Ah(r)}function L9(r){return new _h(r)}var B9=uF,$9=lF,O9=pF,z9=cF;function G9(r){return new ph(r)}function U9(r){return new ch(r)}function W9(r){return new mh(r)}function K9(r){return new eh(r)}var dF={};Xe(dF,{MAPE:()=>tJ,MSE:()=>oJ,binaryAccuracy:()=>V9,binaryCrossentropy:()=>j9,categoricalAccuracy:()=>q9,categoricalCrossentropy:()=>X9,cosineProximity:()=>Z9,mape:()=>rJ,meanAbsoluteError:()=>J9,meanAbsolutePercentageError:()=>eJ,meanSquaredError:()=>nJ,mse:()=>sJ,precision:()=>Y9,recall:()=>Q9,sparseCategoricalAccuracy:()=>H9});function V9(r,e){return Cf(r,e)}function j9(r,e){return yy(r,e)}function H9(r,e){return xy(r,e)}function q9(r,e){return vf(r,e)}function X9(r,e){return Sf(r,e)}function Y9(r,e){return ZC(r,e)}function Q9(r,e){return RM(r,e)}function Z9(r,e){return kf(r,e)}function J9(r,e){return lm(r,e)}function eJ(r,e){return il(r,e)}function tJ(r,e){return il(r,e)}function rJ(r,e){return il(r,e)}function nJ(r,e){return gi(r,e)}function oJ(r,e){return gi(r,e)}function sJ(r,e){return gi(r,e)}var fF={};Xe(fF,{modelFromJSON:()=>eF});var hF={};Xe(hF,{l1:()=>iJ,l1l2:()=>aJ,l2:()=>uJ});function aJ(r){return new Tp(r)}function iJ(r){return rF(r)}function uJ(r){return nF(r)}var Gv=class extends al{constructor(){super(...arguments);this.model=null}setModel(e){if(!(e instanceof ts))throw new Error("model must be a LayersModel, not some other Container");this.model=e}};function Dy(r,e){return r<e}function gF(r,e){return r>e}var Uv=class extends Gv{constructor(e){super();if(e==null&&(e={}),e.restoreBestWeights)throw new De("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Dy:this.mode==="max"?this.monitorFunc=gF:this.monitor.indexOf("acc")!==-1?this.monitorFunc=gF:this.monitorFunc=Dy,this.monitorFunc===Dy&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Dy?1/0:-1/0}async onEpochEnd(e,t){await hi(t);let n=this.getMonitorValue(t);n!=null&&(this.monitorFunc(n-this.minDelta,this.best)?(this.best=n,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});let t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}};function lJ(r){return new Uv(r)}var pJ={earlyStopping:lJ};var cJ=$();cJ.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,r=>{r&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Vs=(Y=>(Y[Y.DT_INVALID=0]="DT_INVALID",Y[Y.DT_FLOAT=1]="DT_FLOAT",Y[Y.DT_DOUBLE=2]="DT_DOUBLE",Y[Y.DT_INT32=3]="DT_INT32",Y[Y.DT_UINT8=4]="DT_UINT8",Y[Y.DT_INT16=5]="DT_INT16",Y[Y.DT_INT8=6]="DT_INT8",Y[Y.DT_STRING=7]="DT_STRING",Y[Y.DT_COMPLEX64=8]="DT_COMPLEX64",Y[Y.DT_INT64=9]="DT_INT64",Y[Y.DT_BOOL=10]="DT_BOOL",Y[Y.DT_QINT8=11]="DT_QINT8",Y[Y.DT_QUINT8=12]="DT_QUINT8",Y[Y.DT_QINT32=13]="DT_QINT32",Y[Y.DT_BFLOAT16=14]="DT_BFLOAT16",Y[Y.DT_QINT16=15]="DT_QINT16",Y[Y.DT_QUINT16=16]="DT_QUINT16",Y[Y.DT_UINT16=17]="DT_UINT16",Y[Y.DT_COMPLEX128=18]="DT_COMPLEX128",Y[Y.DT_HALF=19]="DT_HALF",Y[Y.DT_RESOURCE=20]="DT_RESOURCE",Y[Y.DT_VARIANT=21]="DT_VARIANT",Y[Y.DT_UINT32=22]="DT_UINT32",Y[Y.DT_UINT64=23]="DT_UINT64",Y[Y.DT_FLOAT_REF=101]="DT_FLOAT_REF",Y[Y.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",Y[Y.DT_INT32_REF=103]="DT_INT32_REF",Y[Y.DT_UINT8_REF=104]="DT_UINT8_REF",Y[Y.DT_INT16_REF=105]="DT_INT16_REF",Y[Y.DT_INT8_REF=106]="DT_INT8_REF",Y[Y.DT_STRING_REF=107]="DT_STRING_REF",Y[Y.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",Y[Y.DT_INT64_REF=109]="DT_INT64_REF",Y[Y.DT_BOOL_REF=110]="DT_BOOL_REF",Y[Y.DT_QINT8_REF=111]="DT_QINT8_REF",Y[Y.DT_QUINT8_REF=112]="DT_QUINT8_REF",Y[Y.DT_QINT32_REF=113]="DT_QINT32_REF",Y[Y.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",Y[Y.DT_QINT16_REF=115]="DT_QINT16_REF",Y[Y.DT_QUINT16_REF=116]="DT_QUINT16_REF",Y[Y.DT_UINT16_REF=117]="DT_UINT16_REF",Y[Y.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",Y[Y.DT_HALF_REF=119]="DT_HALF_REF",Y[Y.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",Y[Y.DT_VARIANT_REF=121]="DT_VARIANT_REF",Y[Y.DT_UINT32_REF=122]="DT_UINT32_REF",Y[Y.DT_UINT64_REF=123]="DT_UINT64_REF",Y))(Vs||{}),bF;(e=>{let r;(s=>{s[s.LEGACY=0]="LEGACY",s[s.V1=1]="V1",s[s.V2=2]="V2"})(r=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))})(bF||(bF={}));var Wv={};function dJ(r,e){let t={tfOpName:r,category:"custom",inputs:[],attrs:[],customExecutor:e};Wv[r]=t}function Py(r){return Wv[r]}function fJ(r){delete Wv[r]}function S(r,e,t,n,o){let s=e.inputParams[r];if(s&&s.inputIndexStart!==void 0){let a=s.inputIndexStart,u=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return Cr(e.inputNames[s.inputIndexStart],t,n,o);if(s.type==="tensors")return e.inputNames.slice(a,u).map(m=>Cr(m,t,n,o));let l=Cr(e.inputNames.slice(a)[0],t,n,o),p=l.dataSync();return s.type==="number"?p[0]:b.toNestedArray(l.shape,p)}let i=e.attrParams[r];return i&&i.value}function Cr(r,e,t,n){let[o,s]=kn(r);if(n!=null){let a=n.getHashTableHandleByName(o);if(a!=null)return a}let i=t.currentContextIds.find(a=>!!e[My(o,a)]);return i!==void 0?e[My(o,i)][s]:void 0}function yF(r,e,t){return e[My(r,t.currentContextId)]}function js(r,e){let[t,n,o]=kn(r);return[My(t,e&&e.currentContextId),n,o]}function My(r,e){return e?`${r}-${e}`:r}function kn(r){let e=r.split(":");if(e.length===1)return[r,0,void 0];let t=e[0],n=e.length===3?e[1]:void 0,o=Number(e[e.length-1]);return[t,o,n]}function Nh(r,e,t){let n=S("pad",r,e,t);if(n==="explicit"){n=S("explicitPaddings",r,e,t);let o=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)o[s][0]=n[s*2],o[s][1]=n[s*2+1];return o}return n}function $a(r){return r.kept?r:Nn(r)}var Kv={};Xe(Kv,{json:()=>hJ});var hJ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Vv={};Xe(Vv,{json:()=>gJ});var gJ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var jv={};Xe(jv,{json:()=>bJ});var bJ=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var Hv={};Xe(Hv,{json:()=>yJ});var yJ=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var qv={};Xe(qv,{json:()=>xJ});var xJ=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var Xv={};Xe(Xv,{json:()=>TJ});var TJ=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var Yv={};Xe(Yv,{json:()=>kJ});var kJ=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var Qv={};Xe(Qv,{json:()=>IJ});var IJ=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var Zv={};Xe(Zv,{json:()=>CJ});var CJ=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var Jv={};Xe(Jv,{json:()=>vJ});var vJ=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var eS={};Xe(eS,{json:()=>SJ});var SJ=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var tS={};Xe(tS,{json:()=>wJ});var wJ=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var rS={};Xe(rS,{json:()=>_J});var _J=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var nS={};Xe(nS,{json:()=>AJ});var AJ=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var oS={};Xe(oS,{json:()=>NJ});var NJ=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var sS={};Xe(sS,{json:()=>DJ});var DJ=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var aS={};Xe(aS,{json:()=>PJ});var PJ=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var iS={};Xe(iS,{json:()=>MJ});var MJ=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var uS={};Xe(uS,{json:()=>FJ});var FJ=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var Fy=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){let e=[Kv,Vv,jv,Hv,qv,Xv,Yv,Qv,Zv,Jv,eS,tS,rS,nS,oS,sS,aS,iS,uS],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,o)=>(n[o.tfOpName]=o,n),{})}transformGraph(e,t={}){let n=e.node,o=[],s=[],i=[],a=n.reduce((h,g)=>(h[g.name]=this.mapNode(g),g.op.startsWith("Placeholder")?o.push(h[g.name]):g.op==="Const"?s.push(h[g.name]):(g.input==null||g.input.length===0)&&i.push(h[g.name]),h),{}),u=[],l=[],p={},c={};t!=null&&(p=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));let m=Object.keys(a);m.forEach(h=>{let g=a[h];g.inputNames.forEach((x,y)=>{let[T,,k]=js(x),C=a[T];if(C.outputs!=null){let A=C.outputs.indexOf(k);if(A!==-1){let M=`${T}:${A}`;g.inputNames[y]=M}}g.inputs.push(C),C.children.push(g)})}),Object.keys(c).length===0?m.forEach(h=>{let g=a[h];g.children.length===0&&l.push(g)}):Object.keys(c).forEach(h=>{let[g]=js(h),x=a[g];x!=null&&(x.signatureKey=c[h],l.push(x))}),Object.keys(p).length>0?Object.keys(p).forEach(h=>{let[g]=js(h),x=a[g];x&&(x.signatureKey=p[h],u.push(x))}):u=o;let d={};e.library!=null&&e.library.function!=null&&(d=e.library.function.reduce((h,g)=>(h[g.signature.name]=this.mapFunction(g),h),{}));let f={nodes:a,inputs:u,outputs:l,weights:s,placeholders:o,signature:t,functions:d};return i.length>0&&(f.initNodes=i),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){let t=Py(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});let n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(o=>o.startsWith("^")?o.substr(1):o),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((o,s)=>(o[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},o),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((o,s)=>{let i=s.type,a;switch(s.type){case"string":a=Ey(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Ey(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=Gy(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Gy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=Ly(e.attr,s.tfName,s.defaultValue||0),a===void 0&&!!s.tfDeprecatedName&&(a=Ly(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=zy(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=zy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=Ry(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Ry(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=Wy(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Wy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=Oy(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Oy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=Uy(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=Uy(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=By(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=By(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=$y(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=$y(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=TF(e.attr,s.tfName,s.defaultValue),a===void 0&&!!s.tfDeprecatedName&&(a=TF(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return o[s.name]={value:a,type:i},o},{})),n}mapFunction(e){let t=e.nodeDef,n=[],o=[],s={};t!=null&&(s=t.reduce((c,m)=>(c[m.name]=this.mapNode(m),m.op==="Const"&&o.push(c[m.name]),c),{}));let i=[],a=[];e.signature.inputArg.forEach(c=>{let[m]=js(c.name),d={name:m,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:lS(c.type),type:"dtype"}},children:[]};d.signatureKey=c.name,i.push(d),s[m]=d}),Object.keys(s).forEach(c=>{let m=s[c];m.inputNames.forEach((d,f)=>{let[h,,g]=js(d),x=s[h];if(x.outputs!=null){let y=x.outputs.indexOf(g);if(y!==-1){let T=`${h}:${y}`;m.inputNames[f]=T}}m.inputs.push(x),x.children.push(m)})});let l=e.ret;e.signature.outputArg.forEach(c=>{let[m,d]=js(l[c.name]),f=s[m];f!=null&&(f.defaultOutput=d,a.push(f))});let p=this.mapArgsToSignature(e);return{nodes:s,inputs:i,outputs:a,weights:o,placeholders:n,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function EJ(r){let e=$().global;if(typeof e.atob!="undefined")return e.atob(r);if(typeof Buffer!="undefined")return new Buffer(r,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function xF(r,e){let t=Array.isArray(r)?String.fromCharCode.apply(null,r):EJ(r);return e?t:t.toLowerCase()}function Ey(r,e,t,n=!1){let o=r[e];return o!=null?xF(o.s,n):t}function Ry(r,e,t){let n=r[e];return n?n.b:t}function Ly(r,e,t){let n=r[e]||{},o=n.i!=null?n.i:n.f!=null?n.f:t;return typeof o=="number"?o:parseInt(o,10)}function lS(r){switch(typeof r=="string"&&(r=Vs[r]),r){case Vs.DT_FLOAT:case Vs.DT_HALF:return"float32";case Vs.DT_INT32:case Vs.DT_INT64:case Vs.DT_INT8:case Vs.DT_UINT8:return"int32";case Vs.DT_BOOL:return"bool";case Vs.DT_DOUBLE:return"float32";case Vs.DT_STRING:return"string";default:return null}}function TF(r,e,t){let n=r[e];return n&&n.func?n.func.name:t}function By(r,e,t){let n=r[e];return n&&n.type?lS(n.type):t}function $y(r,e,t){let n=r[e];return n&&n.list&&n.list.type?n.list.type.map(o=>lS(o)):t}function kF(r){if(!r.unknownRank)return r.dim!=null?r.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Oy(r,e,t){let n=r[e];return n&&n.shape?kF(n.shape):t}function zy(r,e,t){let n=r[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(o=>typeof o=="number"?o:parseInt(o,10)):t}function Gy(r,e,t,n=!1){let o=r[e];return o&&o.list&&o.list.s?o.list.s.map(s=>xF(s,n)):t}function Uy(r,e,t){let n=r[e];return n&&n.list&&n.list.shape?n.list.shape.map(o=>kF(o)):t}function Wy(r,e,t){let n=r[e];return n&&n.list&&n.list.b?n.list.b:t}var pS=class{constructor(e,t,n){this.node=e;this.tensorMap=t;this.context=n;this.inputs=[];this.attrs={};this.inputs=e.inputNames.map(o=>this.getInput(o)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((o,s)=>(o[s]=this.getAttr(s),o),{}))}getInput(e){return Cr(e,this.tensorMap,this.context)}getAttr(e,t){let n=this.node.rawAttrs[e];if(n.tensor!=null)return Cr(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Ly(this.node.rawAttrs,e,t);if(n.s!=null)return Ey(this.node.rawAttrs,e,t);if(n.b!=null)return Ry(this.node.rawAttrs,e,t);if(n.shape!=null)return Oy(this.node.rawAttrs,e,t);if(n.type!=null)return By(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return zy(this.node.rawAttrs,e,t);if(n.list.s!=null)return Gy(this.node.rawAttrs,e,t);if(n.list.shape!=null)return Uy(this.node.rawAttrs,e,t);if(n.list.b!=null)return Wy(this.node.rawAttrs,e,t);if(n.list.type!=null)return $y(this.node.rawAttrs,e,t)}return t}};var IF=(r,e,t)=>{switch(r.op){case"BiasAdd":case"AddV2":case"Add":return[X(S("a",r,e,t),S("b",r,e,t))];case"AddN":return[AI(S("tensors",r,e,t))];case"FloorMod":case"Mod":return[cC(S("a",r,e,t),S("b",r,e,t))];case"Mul":return[R(S("a",r,e,t),S("b",r,e,t))];case"RealDiv":case"Div":return[ce(S("a",r,e,t),S("b",r,e,t))];case"DivNoNan":return[QI(S("a",r,e,t),S("b",r,e,t))];case"FloorDiv":return[Ad(S("a",r,e,t),S("b",r,e,t))];case"Sub":return[pe(S("a",r,e,t),S("b",r,e,t))];case"Minimum":return[cu(S("a",r,e,t),S("b",r,e,t))];case"Maximum":return[Qn(S("a",r,e,t),S("b",r,e,t))];case"Pow":return[Mn(S("a",r,e,t),S("b",r,e,t))];case"SquaredDifference":return[Jd(S("a",r,e,t),S("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var CF=(r,e,t)=>{switch(r.op){case"Abs":case"ComplexAbs":return[$t(S("x",r,e,t))];case"Acos":return[wI(S("x",r,e,t))];case"Acosh":return[_I(S("x",r,e,t))];case"Asin":return[DI(S("x",r,e,t))];case"Asinh":return[PI(S("x",r,e,t))];case"Atan":return[MI(S("x",r,e,t))];case"Atan2":return[FI(S("x",r,e,t),S("y",r,e,t))];case"Atanh":return[EI(S("x",r,e,t))];case"Ceil":return[UI(S("x",r,e,t))];case"Complex":return[Xn(S("real",r,e,t),S("imag",r,e,t))];case"Cos":return[Wl(S("x",r,e,t))];case"Cosh":return[Rd(S("x",r,e,t))];case"Elu":return[lu(S("x",r,e,t))];case"Erf":return[JI(S("x",r,e,t))];case"Exp":return[mr(S("x",r,e,t))];case"Expm1":return[eC(S("x",r,e,t))];case"Floor":return[pu(S("x",r,e,t))];case"Log":return[$r(S("x",r,e,t))];case"Log1p":return[jl(S("x",r,e,t))];case"Imag":return[Kl(S("x",r,e,t))];case"Neg":return[Ze(S("x",r,e,t))];case"Reciprocal":return[kC(S("x",r,e,t))];case"Real":return[tl(S("x",r,e,t))];case"Relu":return[qr(S("x",r,e,t))];case"Round":return[Vd(S("x",r,e,t))];case"Selu":return[Hd(S("x",r,e,t))];case"Sigmoid":return[cn(S("x",r,e,t))];case"Sin":return[qd(S("x",r,e,t))];case"Sign":return[vC(S("x",r,e,t))];case"Sinh":return[Xd(S("x",r,e,t))];case"Softplus":return[ui(S("x",r,e,t))];case"Sqrt":return[Lt(S("x",r,e,t))];case"Square":return[qe(S("x",r,e,t))];case"Tanh":return[iu(S("x",r,e,t))];case"Tan":return[wC(S("x",r,e,t))];case"ClipByValue":return[Br(S("x",r,e,t),S("clipValueMin",r,e,t),S("clipValueMax",r,e,t))];case"Relu6":return[Kd(S("x",r,e,t))];case"Rsqrt":return[jd(Cr(r.inputNames[0],e,t))];case"Prod":return[Ud(S("x",r,e,t),S("axes",r,e,t))];case"LeakyRelu":return[Vl(S("x",r,e,t),S("alpha",r,e,t))];case"Prelu":return[Yl(S("x",r,e,t),S("alpha",r,e,t))];case"IsNan":return[tC(Cr(r.inputNames[0],e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function Jn(r,e,t=""){if(!(typeof r=="number"||typeof e=="number")){b.assert(r.length===e.length,()=>t+` Shapes ${r} and ${e} must match`);for(let n=0;n<r.length;n++){let o=r[n],s=e[n];b.assert(o<0||s<0||o===s,()=>t+` Shapes ${r} and ${e} must match`)}}}function vF(r){return!(typeof r=="number"||r.some(e=>e<0))}function Im(r,e,t){let n=Ky(r,t),o=!vF(n);if(o&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(o&&e.forEach(s=>{n=Ky(s.shape,n)}),!vF(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function Ky(r,e){if(typeof r=="number")return e;if(typeof e=="number")return r;if(r.length!==e.length)throw new Error(`Incompatible ranks during merge: ${r} vs. ${e}`);let t=[];for(let n=0;n<r.length;++n){let o=r[n],s=e[n];if(o>=0&&s>=0&&o!==s)throw new Error(`Incompatible shape during merge: ${r} vs. ${e}`);t[n]=o>=0?o:s}return t}var cS=class{constructor(e,t,n,o,s,i,a){this.name=e;this.dtype=t;this.maxSize=n;this.elementShape=o;this.identicalElementShapes=s;this.dynamicSize=i;this.clearAfterRead=a;this.tensors=[];this.closed_=!1;this.idTensor=me(0),Vt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);let t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);let n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Jn(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,Vt(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,o)=>this.write(n,t[o]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let o=0;o<this.size();o++)e.push(o)}if(e.length===0)return Rr([],[0].concat(this.elementShape));let n=this.readMany(e);return Jn(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),fr(n,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Rr([],[0].concat(this.elementShape));let t=[];for(let o=0;o<this.size();o++)t.push(o);let n=this.readMany(t);return Jn(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),lt(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);let n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,Or(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0,o=e.map(u=>(n+=u,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);let s=n===0?0:t.size/n,i=[];G(()=>{t=L(t,[1,n,s]);for(let u=0;u<e.length;++u){let l=u===0?0:o[u-1],p=[0,l,0],c=[1,e[u],s];i[u]=L(ze(t,p,c),this.elementShape)}return i});let a=[];for(let u=0;u<e.length;u++)a[u]=u;this.writeMany(a,i)}};var Ip=class{constructor(e,t,n,o=-1){this.tensors=e;this.elementShape=t;this.elementDtype=n;e!=null&&e.forEach(s=>{if(n!==s.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${s.dtype}`);Jn(t,s.shape,"TensorList shape mismatch: "),Vt(s)}),this.idTensor=me(0),this.maxNumElements=o,Vt(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ip([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);Jn(e,this.elementShape,"TensorList shape mismatch: ");let o=Im(this.elementShape,this.tensors,e);return G(()=>{let s=this.tensors.map(i=>L(i,o));return fr(s,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");let n=Im(this.elementShape,this.tensors,e),o=this.tensors.pop();return Jn(o.shape,e,"TensorList shape mismatch: "),L(o,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Jn(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Vt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Jn(this.tensors[e].shape,t,"TensorList shape mismatch: ");let o=Im(this.elementShape,this.tensors,t);return L(this.tensors[e],o)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Jn(this.elementShape,t.shape,"TensorList shape mismatch: "),Vt(t),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Jn(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());let o=Im(this.elementShape,this.tensors,n);return e.length===0?Rr([],[0].concat(o)):G(()=>{let s=e.map(i=>L(this.tensors[i],o));return fr(s,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Jn(this.elementShape,t,"TensorList shape mismatch: ");let n=Im(this.elementShape,this.tensors,t);return this.size()===0?Rr([],[0].concat(n)):G(()=>{let o=this.tensors.map(s=>L(s,n));return lt(o,0)})}};function SF(r,e,t){let n=r.dtype;if(r.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${r.shape}`);if(r.dtype!==t)throw new Error(`Invalid data types; op elements ${r.dtype}, but list elements ${t}`);let o=r.shape.slice(1);Jn(o,e,"TensorList shape mismatch: ");let s=Or(r);return new Ip(s,e,n)}function wF(r,e,t){return new Ip([],r,e,t)}function _F(r,e,t,n){if(e.length!==r.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${r.shape[0]}`);let o=Math.max(...e);if(n!=null&&n!==-1&&o>=n)throw new Error(`Max index must be < array size (${o}  vs. ${n})`);let s=new Ip([],t,r.dtype,n),i=Or(r,0);return e.forEach((a,u)=>{s.setItem(a,i[u])}),s}function AF(r,e,t){let n=0,o=e.map(p=>(n+=p,n));if(n!==r.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${r.shape}`);let s=r.shape.slice(1),i=Ky(s,t),a=n===0?0:r.size/n,u=G(()=>{let p=[];r=L(r,[1,n,a]);for(let c=0;c<e.length;++c){let m=c===0?0:o[c-1],d=[0,m,0],f=[1,e[c],a];p[c]=L(ze(r,d,f),i)}return r.dispose(),p}),l=new Ip([],t,r.dtype,e.length);for(let p=0;p<u.length;p++)l.setItem(p,u[p]);return l}var NF=async(r,e,t)=>{switch(r.op){case"If":case"StatelessIf":{let n=S("thenBranch",r,e,t),o=S("elseBranch",r,e,t),s=S("cond",r,e,t),i=S("args",r,e,t);return(await s.data())[0]?t.functionMap[n].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[o].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{let n=S("body",r,e,t),o=S("cond",r,e,t),s=S("args",r,e,t),i=await t.functionMap[o].executeFunctionAsync(s,t.tensorArrayMap,t.tensorListMap),a=s.map(p=>p.id),u=await i[0].data();i.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&p.dispose()});let l=s;for(;u[0];){let p=l;l=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);let c=l.map(d=>d.id);p.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&c.indexOf(d.id)===-1&&d.dispose()});let m=await t.functionMap[o].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await m[0].data(),m.forEach(d=>{!d.kept&&a.indexOf(d.id)===-1&&c.indexOf(d.id)===-1&&d.dispose()})}return l}case"LoopCond":{let n=S("pred",r,e,t);return[$a(n)]}case"Switch":{let n=S("pred",r,e,t),o=S("data",r,e,t);return o.kept||(o=$a(o)),(await n.data())[0]?[void 0,o]:[o,void 0]}case"Merge":{let n=r.inputNames.find(o=>Cr(o,e,t)!==void 0);if(n){let o=Cr(n,e,t);return[$a(o)]}return}case"Enter":{let n=S("frameName",r,e,t),o=S("tensor",r,e,t);return t.enterFrame(n),[$a(o)]}case"Exit":{let n=S("tensor",r,e,t);return t.exitFrame(),[$a(n)]}case"NextIteration":{let n=S("tensor",r,e,t);return t.nextIteration(),[$a(n)]}case"TensorArrayV3":{let n=S("size",r,e,t),o=S("dtype",r,e,t),s=S("elementShape",r,e,t),i=S("dynamicSize",r,e,t),a=S("clearAfterRead",r,e,t),u=S("identicalElementShapes",r,e,t),l=S("name",r,e,t),p=new cS(l,o,n,s,u,i,a);return t.addTensorArray(p),[p.idTensor,me(1)]}case"TensorArrayWriteV3":{let n=S("tensorArrayId",r,e,t),o=S("index",r,e,t),s=S("tensor",r,e,t),i=t.getTensorArray(n.id);return i.write(o,s),[i.idTensor]}case"TensorArrayReadV3":{let n=S("tensorArrayId",r,e,t),o=S("index",r,e,t);return[t.getTensorArray(n.id).read(o)]}case"TensorArrayGatherV3":{let n=S("tensorArrayId",r,e,t),o=S("indices",r,e,t),s=S("dtype",r,e,t);return[t.getTensorArray(n.id).gather(o,s)]}case"TensorArrayScatterV3":{let n=S("tensorArrayId",r,e,t),o=S("indices",r,e,t),s=S("tensor",r,e,t),i=t.getTensorArray(n.id);return i.scatter(o,s),[i.idTensor]}case"TensorArrayConcatV3":{let n=S("tensorArrayId",r,e,t),o=t.getTensorArray(n.id),s=S("dtype",r,e,t);return[o.concat(s)]}case"TensorArraySplitV3":{let n=S("tensorArrayId",r,e,t),o=S("tensor",r,e,t),s=S("lengths",r,e,t),i=t.getTensorArray(n.id);return i.split(s,o),[i.idTensor]}case"TensorArraySizeV3":{let n=S("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return[me(o.size(),"int32")]}case"TensorArrayCloseV3":{let n=S("tensorArrayId",r,e,t),o=t.getTensorArray(n.id);return o.clearAndClose(),[o.idTensor]}case"TensorListSetItem":{let n=S("tensorListId",r,e,t),o=S("index",r,e,t),s=S("tensor",r,e,t),i=t.getTensorList(n.id);return i.setItem(o,s),[i.idTensor]}case"TensorListGetItem":{let n=S("tensorListId",r,e,t),o=S("index",r,e,t),s=S("elementShape",r,e,t),i=S("elementDType",r,e,t);return[t.getTensorList(n.id).getItem(o,s,i)]}case"TensorListScatterV2":case"TensorListScatter":{let n=S("indices",r,e,t),o=S("tensor",r,e,t),s=S("elementShape",r,e,t),i=S("numElements",r,e,t),a=_F(o,n,s,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{let n=S("elementShape",r,e,t),o=S("elementDType",r,e,t),s;r.op==="TensorListReserve"?s="numElements":s="maxNumElements";let i=S(s,r,e,t),a=wF(n,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListGather":{let n=S("tensorListId",r,e,t),o=S("indices",r,e,t),s=S("elementShape",r,e,t),i=S("elementDType",r,e,t);return[t.getTensorList(n.id).gather(o,i,s)]}case"TensorListStack":{let n=S("tensorListId",r,e,t),o=S("elementShape",r,e,t),s=S("elementDType",r,e,t),i=S("numElements",r,e,t);return[t.getTensorList(n.id).stack(o,s,i)]}case"TensorListFromTensor":{let n=S("tensor",r,e,t),o=S("elementShape",r,e,t),s=S("elementDType",r,e,t),i=SF(n,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":{let n=S("tensorListId",r,e,t),o=t.getTensorList(n.id),s=S("dtype",r,e,t),i=S("elementShape",r,e,t);return[o.concat(s,i)]}case"TensorListPushBack":{let n=S("tensorListId",r,e,t),o=S("tensor",r,e,t),s=t.getTensorList(n.id);return s.pushBack(o),[s.idTensor]}case"TensorListPopBack":{let n=S("tensorListId",r,e,t),o=S("elementShape",r,e,t),s=S("elementDType",r,e,t);return[t.getTensorList(n.id).popBack(o,s)]}case"TensorListSplit":{let n=S("tensor",r,e,t),o=S("elementShape",r,e,t),s=S("lengths",r,e,t),i=AF(n,s,o);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};function DF(r,e,t){let[n,o]=S("fusedOps",r,e,t),s=n==="biasadd",i=!s,a=o==="prelu",u=n==="fusedbatchnorm",l=S("numArgs",r,e,t);if(s){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");let p=S("strides",r,e,t),c=Nh(r,e,t),m=S("dataFormat",r,e,t).toUpperCase(),d=S("dilations",r,e,t),[f,h]=S("args",r,e,t);i&&(h=f,f=void 0);let g=S("leakyreluAlpha",r,e,t);return{stride:p,pad:c,dataFormat:m,dilations:d,biasArg:f,preluArg:h,activationFunc:o,leakyreluAlpha:g}}var PF=(r,e,t)=>{switch(r.op){case"Conv1D":{let n=S("stride",r,e,t),o=S("pad",r,e,t),s=S("dataFormat",r,e,t).toUpperCase(),i=S("dilation",r,e,t);return[Md(S("x",r,e,t),S("filter",r,e,t),n,o,s,i)]}case"Conv2D":{let n=S("strides",r,e,t),o=Nh(r,e,t),s=S("dataFormat",r,e,t).toUpperCase(),i=S("dilations",r,e,t);return[Yn(S("x",r,e,t),S("filter",r,e,t),[n[1],n[2]],o,s,[i[1],i[2]])]}case"_FusedConv2D":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:p}=DF(r,e,t);return[Ls.conv2d({x:S("x",r,e,t),filter:S("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"FusedDepthwiseConv2dNative":{let{stride:n,pad:o,dataFormat:s,dilations:i,biasArg:a,preluArg:u,activationFunc:l,leakyreluAlpha:p}=DF(r,e,t);return[Ls.depthwiseConv2d({x:S("x",r,e,t),filter:S("filter",r,e,t),strides:[n[1],n[2]],pad:o,dataFormat:s,dilations:[i[1],i[2]],bias:a,activation:l,preluActivationWeights:u,leakyreluAlpha:p})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{let n=S("outputShape",r,e,t),o=S("strides",r,e,t),s=Nh(r,e,t);return[Fd(S("x",r,e,t),S("filter",r,e,t),n,[o[1],o[2]],s)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{let n=S("strides",r,e,t),o=Nh(r,e,t),s=S("dilations",r,e,t),i=S("dataFormat",r,e,t).toUpperCase();return[uu(S("input",r,e,t),S("filter",r,e,t),[n[1],n[2]],o,i,[s[1],s[2]])]}case"Conv3D":{let n=S("strides",r,e,t),o=S("pad",r,e,t),s=S("dataFormat",r,e,t).toUpperCase(),i=S("dilations",r,e,t);return[Ed(S("x",r,e,t),S("filter",r,e,t),[n[1],n[2],n[3]],o,s,[i[1],i[2],i[3]])]}case"AvgPool":{let n=S("strides",r,e,t),o=S("pad",r,e,t),s=S("kernelSize",r,e,t);return[zl(S("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPool":{let n=S("strides",r,e,t),o=S("pad",r,e,t),s=S("kernelSize",r,e,t);return[ql(S("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o)]}case"MaxPoolWithArgmax":{let n=S("strides",r,e,t),o=S("pad",r,e,t),s=S("kernelSize",r,e,t),i=S("includeBatchInIndex",r,e,t),{result:a,indexes:u}=lC(S("x",r,e,t),[s[1],s[2]],[n[1],n[2]],o,i);return[a,u]}case"AvgPool3D":{let n=S("strides",r,e,t),o=S("pad",r,e,t),s=S("kernelSize",r,e,t);return[Dd(S("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"MaxPool3D":{let n=S("strides",r,e,t),o=S("pad",r,e,t),s=S("kernelSize",r,e,t);return[Gd(S("x",r,e,t),[s[1],s[2],s[3]],[n[1],n[2],n[3]],o)]}case"Dilation2D":{let n=S("strides",r,e,t),o=S("pad",r,e,t),s=S("dilations",r,e,t),i=n[1],a=n[2],u=s[1],l=s[2];return[YI(S("x",r,e,t),S("filter",r,e,t),[i,a],o,[u,l],"NHWC")]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var MF=(r,e,t)=>{switch(r.op){case"Fill":{let n=S("shape",r,e,t),o=S("dtype",r,e,t),s=S("value",r,e,t);return[Aa(n,s,o)]}case"LinSpace":{let n=S("start",r,e,t),o=S("stop",r,e,t),s=S("num",r,e,t);return[rC(n,o,s)]}case"Multinomial":{let n=S("logits",r,e,t),o=S("numSamples",r,e,t),s=S("seed",r,e,t);return[mC(n,o,s)]}case"OneHot":{let n=S("indices",r,e,t),o=S("depth",r,e,t),s=S("onValue",r,e,t),i=S("offValue",r,e,t);return[ou(n,o,s,i)]}case"Ones":return[dr(S("shape",r,e,t),S("dtype",r,e,t))];case"OnesLike":return[Dr(S("x",r,e,t))];case"RandomUniform":return[Na(S("shape",r,e,t),S("minval",r,e,t),S("maxval",r,e,t),S("dtype",r,e,t))];case"Range":{let n=S("start",r,e,t),o=S("stop",r,e,t),s=S("step",r,e,t);return[mu(n,o,s,S("dtype",r,e,t))]}case"TruncatedNormal":{let n=S("shape",r,e,t),o=S("mean",r,e,t),s=S("stdDev",r,e,t),i=S("seed",r,e,t);return[tp(n,o,s,S("dtype",r,e,t),i)]}case"Zeros":return[xt(S("shape",r,e,t),S("dtype",r,e,t))];case"ZerosLike":return[Ne(S("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function mS(r,e,t){let n=S("boxes",r,e,t),o=S("scores",r,e,t),s=S("maxOutputSize",r,e,t),i=S("iouThreshold",r,e,t),a=S("scoreThreshold",r,e,t),u=S("softNmsSigma",r,e,t);return{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}var FF=async(r,e,t)=>{switch(r.op){case"NonMaxSuppressionV5":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}=mS(r,e,t),l=await Fn.nonMaxSuppressionWithScoreAsync(n,o,s,i,a,u);return[l.selectedIndices,l.selectedScores]}case"NonMaxSuppressionV4":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=mS(r,e,t),u=S("padToMaxOutputSize",r,e,t),l=await Fn.nonMaxSuppressionPaddedAsync(n,o,s,i,a,u);return[l.selectedIndices,l.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{let{boxes:n,scores:o,maxOutputSize:s,iouThreshold:i,scoreThreshold:a}=mS(r,e,t);return[await Fn.nonMaxSuppressionAsync(n,o,s,i,a)]}case"Where":{let n=J(S("condition",r,e,t),"bool"),o=[await ef(n)];return n.dispose(),o}case"ListDiff":return CC(S("x",r,e,t),S("y",r,e,t));default:throw TypeError(`Node type ${r.op} is not implemented`)}};var EF=(r,e,t)=>{switch(r.op){case"TopKV2":{let n=S("x",r,e,t),o=S("k",r,e,t),s=S("sorted",r,e,t),i=_C(n,o,s);return[i.values,i.indices]}case"Unique":{let n=S("x",r,e,t),o=Ob(n);return[o.values,o.indices]}case"UniqueV2":{let n=S("x",r,e,t),o=S("axis",r,e,t),s=Ob(n,o);return[s.values,s.indices]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var RF=(r,e,t)=>{switch(r.op){case"Const":return e[r.name];case"PlaceholderWithDefault":let n=S("default",r,e,t);return[Cr(r.name,e,t)||n];case"Placeholder":return[Cr(r.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{let l=S("x",r,e,t);return[$a(l)]}case"IdentityN":return S("x",r,e,t).map(l=>$a(l));case"Snapshot":let o=S("x",r,e,t);return[$a(o)];case"Shape":return[zt(S("x",r,e,t).shape,"int32")];case"ShapeN":return S("x",r,e,t).map(l=>zt(l.shape));case"Size":return[me(S("x",r,e,t).size,"int32")];case"Rank":return[me(S("x",r,e,t).rank,"int32")];case"NoOp":return[me(1)];case"Print":let s=S("x",r,e,t),i=S("data",r,e,t),a=S("message",r,e,t),u=S("summarize",r,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let l=0;l<i.length;l++)console.log(Array.prototype.slice.call(i[l].dataSync()).slice(0,u));return[s];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var dS=class{constructor(e,t){this.keyDType=e;this.valueDType=t;this.handle=me(0),this.tensorMap=new Map,Vt(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return me(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return this.tensorMap.forEach(o=>o.dispose()),this.tensorMap.clear(),G(()=>{let o=Or(t),s=n.length,i=o.length;b.assert(s===i,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${i} elements.`);for(let a=0;a<s;a++){let u=n[a],l=o[a];Vt(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);let n=await e.data();return G(()=>{let o=[];for(let s=0;s<n.length;s++){let i=n[s],a=this.findWithDefault(i,t);o.push(a)}return fr(o)})}findWithDefault(e,t){let n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}};var LF=async(r,e,t,n)=>{switch(r.op){case"HashTable":case"HashTableV2":{let o=S("keyDType",r,e,t),s=S("valueDType",r,e,t),i=new dS(o,s);return n.addHashTable(r.name,i),[i.handle]}case"LookupTableImport":case"LookupTableImportV2":{let o=S("tableHandle",r,e,t,n),s=S("keys",r,e,t),i=S("values",r,e,t);return[await n.getHashTableById(o.id).import(s,i)]}case"LookupTableFind":case"LookupTableFindV2":{let o=S("tableHandle",r,e,t,n),s=S("keys",r,e,t),i=S("defaultValue",r,e,t);return[await n.getHashTableById(o.id).find(s,i)]}case"LookupTableSize":case"LookupTableSizeV2":{let o=S("tableHandle",r,e,t,n);return[n.getHashTableById(o.id).tensorSize()]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var BF=(r,e,t)=>{switch(r.op){case"ResizeBilinear":{let n=S("images",r,e,t),o=S("size",r,e,t),s=S("alignCorners",r,e,t),i=S("halfPixelCenters",r,e,t);return[Fn.resizeBilinear(n,[o[0],o[1]],s,i)]}case"ResizeNearestNeighbor":{let n=S("images",r,e,t),o=S("size",r,e,t),s=S("alignCorners",r,e,t),i=S("halfPixelCenters",r,e,t);return[Fn.resizeNearestNeighbor(n,[o[0],o[1]],s,i)]}case"CropAndResize":{let n=S("image",r,e,t),o=S("boxes",r,e,t),s=S("boxInd",r,e,t),i=S("cropSize",r,e,t),a=S("method",r,e,t),u=S("extrapolationValue",r,e,t);return[Fn.cropAndResize(n,o,s,i,a,u)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var $F=(r,e,t)=>{switch(r.op){case"Equal":return[Vr(S("a",r,e,t),S("b",r,e,t))];case"NotEqual":return[li(S("a",r,e,t),S("b",r,e,t))];case"Greater":return[nr(S("a",r,e,t),S("b",r,e,t))];case"GreaterEqual":return[Qo(S("a",r,e,t),S("b",r,e,t))];case"Less":return[Bd(S("a",r,e,t),S("b",r,e,t))];case"LessEqual":return[Zo(S("a",r,e,t),S("b",r,e,t))];case"LogicalAnd":return[Hr(S("a",r,e,t),S("b",r,e,t))];case"LogicalNot":return[Hl(S("a",r,e,t))];case"LogicalOr":return[zd(S("a",r,e,t),S("b",r,e,t))];case"Select":case"SelectV2":return[Ot(S("condition",r,e,t),S("a",r,e,t),S("b",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var OF=(r,e,t)=>{switch(r.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ve(S("a",r,e,t),S("b",r,e,t),S("transposeA",r,e,t),S("transposeB",r,e,t))];case"Einsum":return[ZI(S("equation",r,e,t),...S("tensors",r,e,t))];case"Transpose":return[He(S("x",r,e,t),S("perm",r,e,t))];case"_FusedMatMul":let[n,o]=S("fusedOps",r,e,t),s=n==="biasadd",i=o==="prelu",a=S("numArgs",r,e,t),u=S("leakyreluAlpha",r,e,t);if(s){if(i&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}let[l,p]=S("args",r,e,t);return[Ls.matMul({a:S("a",r,e,t),b:S("b",r,e,t),transposeA:S("transposeA",r,e,t),transposeB:S("transposeB",r,e,t),bias:l,activation:o,preluActivationWeights:p,leakyreluAlpha:u})];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var zF=(r,e,t)=>{switch(r.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[ai(S("x",r,e,t),S("mean",r,e,t),S("variance",r,e,t),S("offset",r,e,t),S("scale",r,e,t),S("epsilon",r,e,t))];case"FusedBatchNormV3":return[ai(S("x",r,e,t),S("mean",r,e,t),S("variance",r,e,t),S("offset",r,e,t),S("scale",r,e,t),S("epsilon",r,e,t))];case"LRN":return[nC(S("x",r,e,t),S("radius",r,e,t),S("bias",r,e,t),S("alpha",r,e,t),S("beta",r,e,t))];case"Softmax":return[Zl(S("x",r,e,t))];case"LogSoftmax":return[$d(S("x",r,e,t))];case"SparseToDense":return[Ub(S("sparseIndices",r,e,t),S("outputShape",r,e,t),S("sparseValues",r,e,t),S("defaultValue",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var GF=(r,e,t)=>{switch(r.op){case"Max":{let i=S("axis",r,e,t),a=S("keepDims",r,e,t);return[en(S("x",r,e,t),i,a)]}case"Mean":{let i=S("axis",r,e,t),a=S("keepDims",r,e,t);return[Rt(S("x",r,e,t),i,a)]}case"Min":{let i=S("axis",r,e,t),a=S("keepDims",r,e,t);return[Kc(S("x",r,e,t),i,a)]}case"Sum":{let i=S("axis",r,e,t),a=S("keepDims",r,e,t);return[he(S("x",r,e,t),i,a)]}case"All":{let i=S("axis",r,e,t),a=S("keepDims",r,e,t);return[Nd(S("x",r,e,t),i,a)]}case"Any":{let i=S("axis",r,e,t),a=S("keepDims",r,e,t);return[zc(S("x",r,e,t),i,a)]}case"ArgMax":{let i=S("axis",r,e,t);return[au(S("x",r,e,t),i)]}case"ArgMin":{let i=S("axis",r,e,t);return[NI(S("x",r,e,t),i)]}case"Prod":{let i=S("axis",r,e,t),a=S("keepDims",r,e,t);return[Ud(S("x",r,e,t),i,a)]}case"Cumsum":{let i=S("axis",r,e,t),a=S("exclusive",r,e,t),u=S("reverse",r,e,t);return[Ld(S("x",r,e,t),i,a,u)]}case"Bincount":let n=S("x",r,e,t),o=S("weights",r,e,t),s=S("size",r,e,t);return[Pd(n,o,s)];case"DenseBincount":{let i=S("x",r,e,t),a=S("weights",r,e,t),u=S("size",r,e,t),l=S("binaryOutput",r,e,t);return[qI(i,a,u,l)]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var UF=(r,e,t)=>{switch(r.op){case"ConcatV2":case"Concat":{let n=S("n",r,e,t),o=S("axis",r,e,t),s=S("tensors",r,e,t);return s=s.slice(0,n),[lt(s,o)]}case"Gather":{let n=S("x",r,e,t),o=S("indices",r,e,t);return[ii(n,J(o,"int32"),0)]}case"GatherV2":{let n=S("axis",r,e,t),o=S("batchDims",r,e,t),s=S("x",r,e,t),i=S("indices",r,e,t);return[ii(s,J(i,"int32"),n,o)]}case"Reverse":{let n=S("dims",r,e,t),o=[];for(let i=0;i<n.length;i++)n[i]&&o.push(i);let s=S("x",r,e,t);return[xr(s,o)]}case"ReverseV2":{let n=S("axis",r,e,t),o=S("x",r,e,t);return[xr(o,n)]}case"Slice":{let n=S("begin",r,e,t),o=S("size",r,e,t);return[ze(S("x",r,e,t),n,o)]}case"StridedSlice":{let n=S("begin",r,e,t),o=S("end",r,e,t),s=S("strides",r,e,t),i=S("beginMask",r,e,t),a=S("endMask",r,e,t),u=S("ellipsisMask",r,e,t),l=S("newAxisMask",r,e,t),p=S("shrinkAxisMask",r,e,t),c=S("x",r,e,t);return[SC(c,n,o,s,i,a,u,l,p)]}case"Pack":return G(()=>{let n=S("axis",r,e,t),o=S("tensors",r,e,t),s=o[0].shape,i=dn(o[0]).shape,a=o.map(u=>{let l=b.arraysEqual(u.shape,s);if(!l&&!b.arraysEqual(dn(u).shape,i))throw new Error("the input tensors shape does not match");return l?u:L(u,s)});return[fr(a,n)]});case"Unpack":{let n=S("axis",r,e,t),o=S("tensor",r,e,t);return Or(o,n)}case"Tile":{let n=S("reps",r,e,t);return[jr(S("x",r,e,t),n)]}case"Split":case"SplitV":{let n=S("axis",r,e,t),o=S("numOrSizeSplits",r,e,t),s=S("x",r,e,t);return Ir(s,o,n)}case"ScatterNd":{let n=S("indices",r,e,t),o=S("values",r,e,t),s=S("shape",r,e,t);return[f2(n,o,s)]}case"GatherNd":{let n=S("x",r,e,t),o=S("indices",r,e,t);return[g2(n,o)]}case"SparseToDense":{let n=S("sparseIndices",r,e,t),o=S("outputShape",r,e,t),s=S("sparseValues",r,e,t),i=S("defaultValue",r,e,t);return[Ub(n,s,o,s.dtype===i.dtype?i:J(i,s.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};var WF=(r,e,t)=>{switch(r.op){case"SparseFillEmptyRows":{let{outputIndices:n,outputValues:o,emptyRowIndicator:s,reverseIndexMap:i}=tf.sparseFillEmptyRows(S("indices",r,e,t),S("values",r,e,t),S("denseShape",r,e,t),S("defaultValue",r,e,t));return[n,o,s,i]}case"SparseReshape":{let{outputIndices:n,outputShape:o}=tf.sparseReshape(S("inputIndices",r,e,t),S("inputShape",r,e,t),S("newShape",r,e,t));return[n,o]}case"SparseSegmentMean":return[tf.sparseSegmentMean(S("data",r,e,t),S("indices",r,e,t),S("segmentIds",r,e,t))];case"SparseSegmentSum":return[tf.sparseSegmentSum(S("data",r,e,t),S("indices",r,e,t),S("segmentIds",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var KF=(r,e,t)=>{switch(r.op){case"FFT":return[Jl(S("x",r,e,t))];case"IFFT":return[rl(S("x",r,e,t))];case"RFFT":return[ep(S("x",r,e,t))];case"IRFFT":return[Zd(S("x",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var VF=(r,e,t)=>{switch(r.op){case"StringNGrams":{let{nGrams:n,nGramsSplits:o}=Qb.stringNGrams(S("data",r,e,t),S("dataSplits",r,e,t),S("separator",r,e,t),S("nGramWidths",r,e,t),S("leftPad",r,e,t),S("rightPad",r,e,t),S("padWidth",r,e,t),S("preserveShortSequences",r,e,t));return[n,o]}case"StringSplit":{let{indices:n,values:o,shape:s}=Qb.stringSplit(S("input",r,e,t),S("delimiter",r,e,t),S("skipEmpty",r,e,t));return[n,o,s]}case"StringToHashBucketFast":return[Qb.stringToHashBucketFast(S("input",r,e,t),S("numBuckets",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};var jF=(r,e,t)=>{switch(r.op){case"Cast":return[J(S("x",r,e,t),S("dtype",r,e,t))];case"ExpandDims":{let n=S("axis",r,e,t);return[Nr(S("x",r,e,t),n)]}case"Squeeze":{let n=S("axis",r,e,t);return[dn(S("x",r,e,t),n)]}case"Reshape":return[L(S("x",r,e,t),S("shape",r,e,t))];case"MirrorPad":return[pC(S("x",r,e,t),S("padding",r,e,t),S("mode",r,e,t))];case"PadV2":case"Pad":return[Pn(S("x",r,e,t),S("padding",r,e,t),S("constantValue",r,e,t))];case"SpaceToBatchND":{let n=S("blockShape",r,e,t),o=S("paddings",r,e,t);return[Xl(S("x",r,e,t),n,o)]}case"BatchToSpaceND":{let n=S("blockShape",r,e,t),o=S("crops",r,e,t);return[Gl(S("x",r,e,t),n,o)]}case"DepthToSpace":{let n=S("blockSize",r,e,t),o=S("dataFormat",r,e,t).toUpperCase();return[XI(S("x",r,e,t),n,o)]}case"BroadcastTo":return[Ul(S("x",r,e,t),S("shape",r,e,t))];case"BroadcastArgs":return[GI(S("s0",r,e,t),S("s1",r,e,t))];default:throw TypeError(`Node type ${r.op} is not implemented`)}};function fS(r,e,t,n){let o=((s,i,a)=>{switch(s.category){case"arithmetic":return G(()=>IF(s,i,a));case"basic_math":return G(()=>CF(s,i,a));case"control":return NF(s,i,a);case"convolution":return G(()=>PF(s,i,a));case"creation":return G(()=>MF(s,i,a));case"dynamic":return FF(s,i,a);case"evaluation":return G(()=>EF(s,i,a));case"image":return G(()=>BF(s,i,a));case"graph":return G(()=>RF(s,i,a));case"logical":return G(()=>$F(s,i,a));case"matrices":return G(()=>OF(s,i,a));case"normalization":return G(()=>zF(s,i,a));case"reduction":return G(()=>GF(s,i,a));case"slice_join":return G(()=>UF(s,i,a));case"sparse":return G(()=>WF(s,i,a));case"spectral":return G(()=>KF(s,i,a));case"string":return G(()=>VF(s,i,a));case"transformation":return G(()=>jF(s,i,a));case"hash_table":return LF(s,i,a,n);case"custom":let u=Py(s.op);if(u&&u.customExecutor)return u.customExecutor(new pS(s,i,a));throw TypeError(`Custom op ${s.op} is not registered.`);default:throw TypeError(`Unknown op '${s.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(r,e,t);return b.isPromise(o)?o.then(s=>[].concat(s)):[].concat(o)}var Vy=class{constructor(e={},t={},n={},o={}){this.weightMap=e;this.tensorArrayMap=t;this.tensorListMap=n;this.functionMap=o;this.rootContext={id:0,frameName:"",iterationId:0};this.contexts=[this.rootContext];this.lastId=0;this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){let e=[];for(let t=0;t<this.contexts.length-1;t++){let n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;let e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(let t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(let t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}};function hS(r,e,t,n){let o=new Set,s=[],i=null,a=null,u=new Set,l=Object.keys(r).map(m=>kn(m)[0]),p=[];n!=null&&(p=n.map(m=>kn(m.name)[0]));let c=[...e];for(;c.length>0;){let m=c.pop();if((gS(m)||nee(m)||oee(m))&&i==null&&(i=m,a=i.children.map(d=>d.name).filter(d=>o.has(d))),o.add(m.name),t[m.name]==null&&l.indexOf(m.name)===-1&&p.indexOf(m.name)===-1){if(m.inputs.length===0){s.push(m.name);continue}m.inputs.forEach(d=>{u.has(d.name)||(u.add(d.name),c.push(d))})}}return{inputs:r,outputs:e,usedNodes:o,missingInputs:s,dynamicNode:i,syncInputs:a}}function HF(r,e,t){let{usedNodes:n,inputs:o}=t,s=[],i=Object.keys(o).map(p=>kn(p)[0]).map(p=>r.nodes[p]),a=r.initNodes;i.forEach(p=>{n.has(p.name)&&s.push(p)}),r.weights.forEach(p=>{n.has(p.name)&&s.push(p)}),a!=null&&a.forEach(p=>{n.has(p.name)&&s.push(p)});let u=new Set,l=[];for(;s.length>0;){let p=s.pop();u.add(p.name),e[p.name]||l.push(p),p.children.forEach(c=>{!u.has(c.name)&&n.has(c.name)&&c.inputs.every(m=>u.has(m.name))&&s.push(c)})}return l}var eee=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],tee=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],ree=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function gS(r){return eee.indexOf(r.op)>=0}function nee(r){return tee.indexOf(r.op)>=0}function oee(r){return ree.indexOf(r.op)>=0}var Cm=class{constructor(e,t){this.graph=e;this.parent=t;this.compiledMap=new Map;this._weightMap={};this.SEPERATOR=",";this._functions={};this._functionExecutorMap={};this.intermediateTensors={};this.keepTensorForDebug=!1;this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new Cm(e.functions[n],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){let t=Object.keys(e).map(n=>e[n].map(o=>o.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{let t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){let n=e.map(s=>s.name).sort(),o=t.map(s=>s.name).sort();return n.join(this.SEPERATOR)+"--"+o.join(this.SEPERATOR)}compile(e,t){let n=hS(e,t,this.weightMap,this._initNodes),{missingInputs:o,dynamicNode:s,syncInputs:i}=n;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(o.length>0){let a=t.map(l=>l.name),u=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${u}]. Missing the following inputs: [${o}]`)}return HF(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);let n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);let o=n.map(c=>this.graph.nodes[kn(c)[0]]),s=t.map(c=>kn(c)[0]),i=s.map(c=>this.graph.nodes[c]);this.resetIntermediateTensors(),i.length===0&&(i=this._outputs);let a=this.getCompilationKey(o,i),u=this.compiledMap.get(a);u==null&&(u=this.compile(e,i),this.compiledMap.set(a,u));let l={},p={};return G(()=>{let c=new Vy(this.weightMap,l,p,this.functionExecutorMap),m={...this.weightMap};Object.keys(e).forEach(h=>{let[g,x]=kn(h),y=[];y[x]=e[h],m[g]=y});let d=this.getFrozenTensorIds(m),f={};for(let h=0;h<u.length;h++){let g=u[h];if(!m[g.name]){let x=fS(g,m,c,this._resourceManager);if(b.isPromise(x))throw new Error(`The execution of the op '${g.op}' returned a promise. Please use model.executeAsync() instead.`);m[g.name]=x,this.checkTensorForDisposal(g.name,g,m,c,d,s,f)}}return this.parent==null&&c.dispose(d),t.map(h=>Cr(h,m,c))})}getFrozenTensorIds(e){let t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(o=>o.id)));return new Set(t)}checkTensorForDisposal(e,t,n,o,s,i,a){t.category==="control"||i.indexOf(e)!==-1||(n[e].forEach(u=>{u!=null&&(a[u.id]=(a[u.id]||0)+t.children.length)}),t.inputs.forEach(u=>{if(u.category!=="control"){let l=yF(u.name,n,o);l!=null&&l.forEach(p=>{if(p&&!p.kept&&!s.has(p.id)){let c=a[p.id];if(c===1){if(!this.keepTensorForDebug)p.dispose();else{let[m,d]=js(t.name,o);this.intermediateTensors[m]?this.intermediateTensors[m][d]=p:(this.intermediateTensors[m]=[],this.intermediateTensors[m][d]=p)}delete a[p.id]}else c!=null&&a[p.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(n=>{n&&!n.kept&&!n.isDisposed&&!this.keepIds.has(n.id)&&n.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(let e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,n=!1,o={},s={}){n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=$().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){console.warn(p.message)}this.resetIntermediateTensors();let i=new Vy(this.weightMap,o,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,i,t,n);let a=t.map(p=>Cr(p,this.tensorsMap,i)),u=a.map(p=>p.id),l=Object.keys(e).map(p=>e[p].id);return this.keepIds=new Set([...u,...l,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&i.dispose(this.keepIds),a}async executeFunctionAsync(e,t,n){let o=e.reduce((s,i,a)=>(s[this.inputs[a].name]=i,s),{});return this._executeAsync(o,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,o){let s=Object.keys(e),i=s.map(T=>this.graph.nodes[kn(T)[0]]),a=n.map(T=>kn(T)[0]),u=a.map(T=>this.graph.nodes[T]);u.length===0&&(u=this._outputs);let{usedNodes:l,missingInputs:p,dynamicNode:c,syncInputs:m}=hS(e,u,this.weightMap,this._initNodes),d=[...i,...this.graph.weights,...this._initNodes||[]].map(T=>({node:T,contexts:t.currentContext})),f={...this.weightMap};Object.keys(e).forEach(T=>{let[k,C]=kn(T),A=[];A[C]=e[T],f[k]=A});let h={},g=this.getFrozenTensorIds(f),x={};for(;d.length>0;){let T=this.processStack(i,d,t,f,x,g,a,h,l);await Promise.all(T)}c==null&&!o&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");let y=u.filter(T=>!gS(T)&&!Cr(T.name,f,t)).map(T=>T.name);if(y.length>0){let T="";throw c!=null&&(T=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${m}]`),new Error(`Cannot compute the outputs [${y}] from the provided inputs [${s}]. Consider providing the following inputs: [${p}]. ${T}`)}return f}processStack(e,t,n,o,s,i,a,u,l){let p=[];for(;t.length>0;){let c=t.pop();n.currentContext=c.contexts;let m="";if(c.node.op==="Enter"&&S("isConstant",c.node,o,n)&&([m]=js(c.node.name,n)),o[c.node.name]==null){let d=fS(c.node,o,n,this._resourceManager);m||([m]=js(c.node.name,n));let f=n.currentContext;b.isPromise(d)?p.push(d.then(h=>(o[m]=h,n.currentContext=f,this.checkTensorForDisposal(m,c.node,o,n,i,a,u),this.processChildNodes(c.node,t,n,o,s,l),h))):(o[m]=d,this.checkTensorForDisposal(m,c.node,o,n,i,a,u),this.processChildNodes(c.node,t,n,o,s,l))}else this.processChildNodes(c.node,t,n,o,s,l)}return p}processChildNodes(e,t,n,o,s,i){e.children.forEach(a=>{let[u]=js(a.name,n);s[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!Cr(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:a})):a.inputNames.every(l=>!!Cr(l,o,n))&&(s[u]=!0,t.push({contexts:n.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{let n=e[t],[o]=kn(t),s=this.graph.nodes[o];if(s.attrParams.shape&&s.attrParams.shape.value){let i=s.attrParams.shape.value,a=i.length===n.shape.length&&n.shape.every((u,l)=>i[l]===-1||i[l]===u);b.assert(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${i}], but was [${n.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&b.assert(n.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){let t={};for(let n in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[n]!=null){let o=this._signature.inputs[n];t[o.name]=e[n]}else t[n]=e[n];return t}checkInputs(e){let t=Object.keys(e).filter(n=>{let[o]=kn(n);return this.graph.nodes[o]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{let[n]=kn(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}};var bS=class{constructor(e={},t={}){this.hashTableNameToHandle=e;this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(let e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(let e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}};var see="?tfjs-format=file",aee="model.json",yS=class{constructor(e,t={}){this.modelUrl=e;this.loadOptions=t;this.version="n/a";t==null&&(this.loadOptions={}),this.resourceManager=new bS}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){let e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=Kr.browserHTTPRequest(e,this.loadOptions);else{let t=Kr.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(Kr.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;let t=this.artifacts.modelTopology,n;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?n=this.artifacts.userDefinedMetadata.signature:n=this.artifacts.signature,this.signature=n,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;let o=Kr.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Cm(Fy.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(o),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){let s=Fy.Instance.transformGraph(e.modelInitializer);this.initializer=new Cm(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){let n=Kr.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Ye)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,n,o)=>(t[n]=e[o],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);let n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}};async function iee(r,e={}){if(r==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&r.load==null&&(r.endsWith("/")||(r=r+"/"),r=`${r}${aee}${see}`);let t=new yS(r,e);return await t.load(),t}var uee="0.0.0";var DE={};Xe(DE,{CSVDataset:()=>Eh,Dataset:()=>bi,FileDataSource:()=>zh,TextLineDataset:()=>Mh,URLDataSource:()=>Gh,array:()=>hE,csv:()=>vE,func:()=>SE,generator:()=>wE,microphone:()=>AE,version_data:()=>NE,webcam:()=>_E,zip:()=>gE});var fE=wl(Wd());var JF=wl(Wd());function qF(r,e){return jy(r,e)}function jy(r,e,t=new Map,n=new Set){if(r==null)return null;if(typeof Blob=="function"&&r instanceof Blob)return r.slice();if(n.has(r))throw new Error("Circular references are not supported.");if(t.has(r))return t.get(r);let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(dl(r)){let s=Array.isArray(r)?[]:{};n.add(r);for(let i in r){let a=r[i],u=jy(a,e,t,n);s[i]=u}return n.delete(r),r.__proto__&&(s.__proto__=r.__proto__),s}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return t.set(r,o.value),o.value}function XF(r,e=TS){return YF(r,e)}function YF(r,e,t=new Set){let n=r[0];if(t.has(n))throw new Error("Circular references are not supported.");let o=e(r);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(dl(n)){let s=Array.isArray(n)?[]:{};t.add(n);for(let i in n){let a=r.map(l=>l[i]),u=YF(a,e,t);s[i]=u}return t.delete(n),s}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return o.value}function TS(r){return r===null?null:dl(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}async function Hy(r,e){let t=new Map;jy(r,e,t);for(let o of Array.from(t.keys())){let s=t.get(o);if(b.isPromise(s)){let i=await s;t.set(o,i)}}return jy(r,e,t)}function dl(r){let e=!1;if($().get("IS_BROWSER"))e=r instanceof TextDecoder;else{let{StringDecoder:t}=xS();e=r instanceof t}return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Ye)&&!(r instanceof Promise)&&!e)}function QF(r){return r==null||lee(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Ye||b.isTypedArray(r)}function lee(r){return r===null||typeof r!="object"&&typeof r!="function"}function ZF(r){return qF(r,pee)}function pee(r){return r instanceof Ye?{value:r.clone(),recurse:!1}:dl(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var Dh=class{constructor(e){this.capacity=e;this.begin=0;this.end=0;if(e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(let t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}};var kS=class extends Dh{constructor(){super(kS.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){let e=this.capacity*2,t=new Array(e),n=this.length();for(let o=0;o<n;o++)t[o]=this.get(this.wrap(this.begin+o));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}},qy=kS;qy.INITIAL_CAPACITY=32;function IS(r){return new rE(r)}function Ph(r){return new nE(r)}function eE(r,e){return new vS(r,e)}function tE(r,e=Xy.FAIL){return new mE(r,e)}var ur=class{async toArray(){let e=[],t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){let e=this.prefetch(100),t=[],n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new pE(this,e)}filter(e){return new uE(this,e)}map(e){return new lE(this,e)}mapAsync(e){return new CS(this,e)}serialMapAsync(e){return new CS(this,e).serial()}flatmap(e){return new cE(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new iE(this,e,t)}columnMajorBatch(e,t=!0,n=TS){return this.rowMajorBatch(e,t).map(s=>XF(s,n))}concatenate(e,t){return new vS(IS([this,e]),t)}take(e){return e<0||e==null?this:new aE(this,e)}skip(e){return e<0||e==null?this:new sE(this,e)}prefetch(e){return new SS(this,e)}shuffle(e,t){return new dE(this,e,t)}serial(){return new oE(this)}},rE=class extends ur{constructor(e){super();this.items=e;this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let e=this.items[this.trav];return this.trav++,{value:ZF(e),done:!1}}},nE=class extends ur{constructor(e){super();this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}},oE=class extends ur{constructor(e){super();this.upstream=e;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},sE=class extends ur{constructor(e,t){super();this.upstream=e;this.maxCount=t;this.count=0;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let e=await this.upstream.next();if(e.done)return e;Fe(e.value)}return this.upstream.next()}},aE=class extends ur{constructor(e,t){super();this.upstream=e;this.maxCount=t;this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},iE=class extends ur{constructor(e,t,n=!0){super();this.upstream=e;this.batchSize=t;this.enableSmallLastBatch=n;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let e=[];for(;e.length<this.batchSize;){let t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}},uE=class extends ur{constructor(e,t){super();this.upstream=e;this.predicate=t;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Fe(e.value)}}},lE=class extends ur{constructor(e,t){super();this.upstream=e;this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Es.getTensorsInContainer(e.value),n=this.transform(e.value),o=Es.getTensorsInContainer(n);for(let s of t)Es.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},pE=class extends ur{constructor(e,t){super();this.upstream=e;this.handler=t;this.count=0;this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}},CS=class extends ur{constructor(e,t){super();this.upstream=e;this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let e=await this.upstream.next();if(e.done)return{value:null,done:!0};let t=Es.getTensorsInContainer(e.value),n=await this.transform(e.value),o=Es.getTensorsInContainer(n);for(let s of t)Es.isTensorInList(s,o)||s.dispose();return{value:n,done:!1}}},vm=class extends ur{constructor(){super();this.outputQueue=new qy,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},cE=class extends vm{constructor(e,t){super();this.upstream=e;this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let e=await this.upstream.next();if(e.done)return!1;let t=Es.getTensorsInContainer(e.value),n=this.transform(e.value),o=Es.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let s of t)Es.isTensorInList(s,o)||s.dispose();return!0}},vS=class extends ur{constructor(e,t){super();this.baseErrorHandler=t;this.lastRead=null;this.iterator=null;this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}},Xy=(n=>(n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST",n))(Xy||{}),mE=class extends ur{constructor(e,t=0){super();this.iterators=e;this.mismatchMode=t;this.count=0;this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,n=0;function o(i){return i instanceof ur?{value:i.next().then(u=>(t++,u.done&&n++,u.value)),recurse:!1}:{value:null,recurse:!0}}let s=await Hy(this.iterators,o);if(t===n)return{value:null,done:!0};if(n>0)switch(this.mismatchMode){case 0:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case 1:return{value:null,done:!0};case 2:default:}return this.count++,{value:s,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}},SS=class extends ur{constructor(e,t){super();this.upstream=e;this.bufferSize=t;this.buffer=new Dh(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}},dE=class extends SS{constructor(e,t,n){super(e,t);this.upstream=e;this.windowSize=t;this.upstreamExhausted=!1;this.random=JF.alea(n||b.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}};var bi=class{constructor(){this.size=null}batch(e,t=!0){let n=this;b.assert(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let o;return this.size===1/0||this.size==null?o=this.size:t?o=Math.ceil(this.size/e):o=Math.floor(this.size/e),Ln(async()=>(await n.iterator()).columnMajorBatch(e,t,cee),o)}concatenate(e){let t=this,n;return this.size===1/0||e.size===1/0?n=1/0:this.size!=null&&e.size!=null?n=this.size+e.size:n=null,Ln(async()=>(await t.iterator()).concatenate(await e.iterator()),n)}filter(e){let t=this,n;return this.size===1/0?n=1/0:n=null,Ln(async()=>(await t.iterator()).filter(o=>G(()=>e(o))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){let t=this;return Ln(async()=>(await t.iterator()).map(n=>G(()=>e(n))),this.size)}mapAsync(e){let t=this;return Ln(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let t=this;return Ln(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){let t=this,n;return this.size!=null&&e>0?n=this.size*e:e===0?n=0:this.size!=null&&(e===void 0||e<0)?n=1/0:n=null,Ln(async()=>{let o=Ph(async()=>({value:await t.iterator(),done:!1}));return eE(o.take(e))},n)}skip(e){let t=this,n;return this.size!=null&&e>=0&&this.size>=e?n=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?n=0:n=null,Ln(async()=>(await t.iterator()).skip(e),n)}shuffle(e,t,n=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let o=this,s=fE.alea(t||b.now().toString());return Ln(async()=>{let i=s.int32();return n&&(i+=s.int32()),(await o.iterator()).shuffle(e,i.toString())},this.size)}take(e){let t=this,n;return this.size!=null&&this.size>e?n=e:this.size!=null&&this.size<=e?n=this.size:n=null,Ln(async()=>(await t.iterator()).take(e),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};bi.MAX_BUFFER_SIZE=1e4;function Ln(r,e=null){return new class extends bi{constructor(){super(...arguments);this.size=e}async iterator(){return r()}}}function hE(r){return Ln(async()=>IS(r),r.length)}function gE(r){if(!dl(r))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(r))for(let t=0;t<r.length;t++)e=e==null?r[t].size:Math.min(e,r[t].size);else if(r instanceof Object)for(let t in r)e=e==null?r[t].size:Math.min(e,r[t].size);return Ln(async()=>{let t=await Hy(r,n=>{if(n instanceof bi)return{value:n.iterator(),recurse:!1};if(dl(n))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return tE(t,Xy.SHORTEST)},e)}function cee(r){if(r===null)return null;let e=r[0];return QF(e)?{value:mee(r),recurse:!1}:{value:null,recurse:!0}}function mee(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Ye?fr(r):Rr(r)}var Mh=class extends bi{constructor(e){super();this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(o=>(o.endsWith("\r")&&(o=o.slice(0,-1)),o))}};var Yy='"',Fh=Symbol("out"),bE=Symbol("field"),Qy=Symbol("quote"),wS=Symbol("quoteafterquote"),yE=Symbol("quoteinquote"),Eh=class extends bi{constructor(e,t){super();this.input=e;this.hasHeader=!0;this.fullColumnNames=null;this.columnNamesValidated=!1;this.columnConfigs=null;this.configuredColumnsOnly=!1;this.delimiter=",";this.delimWhitespace=!1;this.base=new Mh(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(b.assert(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){let e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&b.assert(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);let t=this.fullColumnNames.reduce((o,s)=>(o[s]=o[s]+1||1,o),{}),n=Object.keys(t).filter(o=>t[o]>1);if(b.assert(n.length===0,()=>"Duplicate column names found: "+n.toString()),this.columnConfigs){for(let o of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(o)===-1)throw new Error('The key "'+o+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){let t=await(await this.base.iterator()).next();if(t.done)throw new Error("No data was found for CSV parsing.");let n=t.value;return this.parseRow(n,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){let t=this.parseRow(e),n={},o={};for(let s=0;s<this.fullColumnNames.length;s++){let i=this.fullColumnNames[s],a=this.columnConfigs?this.columnConfigs[i]:null;if(!(this.configuredColumnsOnly&&!a)){let u=t[s],l=null;if(u==="")if(a&&a.default!==void 0)l=a.default;else{if(a&&(a.required||a.isLabel))throw new Error(`Required column ${i} is empty in this line: ${e}`);l=void 0}else{let p=Number(u);if(isNaN(p))a&&a.dtype==="bool"?l=this.getBoolean(u):l=u;else if(!a||!a.dtype)l=p;else switch(a.dtype){case"float32":l=p;break;case"int32":l=Math.floor(p);break;case"bool":l=this.getBoolean(u);break;default:l=p}}a&&a.isLabel?o[i]=l:n[i]=l}}return Object.keys(o).length===0?n:{xs:n,ys:o}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){let n=[],o=0,s=e.length,i=Fh;for(let a=0;a<s;a++)switch(i){case Fh:switch(e.charAt(a)){case Yy:o=a+1,i=Qy;break;case this.delimiter:if(o=a+1,this.delimiter===" "&&this.delimWhitespace)break;n.push(""),i=Fh;break;default:i=bE,o=a;break}break;case bE:switch(e.charAt(a)){case this.delimiter:n.push(e.substring(o,a)),i=Fh,o=a+1;break;default:}break;case Qy:switch(e.charAt(a)){case Yy:i=wS;break;default:}break;case wS:switch(e.charAt(a)){case this.delimiter:n.push(e.substring(o,a-1)),i=Fh,o=a+1;break;case Yy:i=Qy;break;default:i=yE;break}break;case yE:switch(e.charAt(a)){case Yy:i=Qy;break;default:}break;default:}if(i===wS?n.push(e.substring(o,s-1)):n.push(e.substring(o)),t&&n.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${n}`);return n}};var Rh=class extends ur{constructor(e){super();this.microphoneConfig=e;this.isClosed=!1;this.fftSize=e.fftSize||1024;let t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if($().get("IS_NODE"))throw new Error("microphone API is only supported in browser environment.");let t=new Rh(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(n){throw new Error(`Error thrown while initializing video stream: ${n.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");let e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);let t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t,n=await this.getAudioData();if(this.includeSpectrogram){let o=this.flattenQueue(n.freqDataQueue);e=this.getTensorFromAudioDataArray(o,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){let o=this.flattenQueue(n.timeDataQueue);t=this.getTensorFromAudioDataArray(o,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){let e=[],t=[],n=0;return new Promise(o=>{let s=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&o({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++n===this.numFrames&&(clearInterval(s),o({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){let t=e[0].length,n=new Float32Array(e.length*t);return e.forEach((o,s)=>n.set(o,s*t)),n}getTensorFromAudioDataArray(e,t){let n=new Float32Array(b.sizeFromShape(t));return n.set(e,n.length-e.length),Rr(n,t)}};var Lh=class extends ur{constructor(e,t){super();this.webcamVideoElement=e;this.webcamConfig=t;this.isClosed=!0;this.resize=!1;if(this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=zt([0],"int32"),this.webcamConfig.centerCrop){let n=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,o=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,s=(1-n)/2,i=(1-o)/2,a=s+n,u=o+i;this.cropBox=pi([i,s,u,a],[1,4])}else this.cropBox=pi([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if($().get("IS_NODE"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}let n=new Lh(e,t);return await n.start(),n}async start(){this.webcamConfig.facingMode&&b.assert(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=wb.fromPixels(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return G(()=>{let t=Nr(J(e,"float32"),0),n;n=Fn.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");let o=n.shape;return L(n,o.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(t=>t.stop());try{this.webcamVideoElement.srcObject=null}catch(t){console.log(t),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}};var Bh=class{};var Zy=class extends ur{split(e){return new xE(this,e)}},xE=class extends Zy{constructor(e,t){super();this.upstream=e;this.impl=new TE(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},TE=class extends vm{constructor(e,t){super();this.upstream=e;this.separator=t;this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){let e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);let t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(let n of t.slice(0,-1))this.outputQueue.push(n);return this.carryover=t[t.length-1],!0}};var _S=class extends ur{decodeUTF8(){return new kE(this)}},kE=class extends Zy{constructor(e){super();this.upstream=e;this.impl=new IE(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}},IE=class extends vm{constructor(e){super();this.upstream=e;if($().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{let{StringDecoder:t}=xS();this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){let e=await this.upstream.next(),t;if(e.done)return!1;t=e.value;let n;return $().get("IS_BROWSER")?n=this.decoder.decode(t,{stream:!0}):n=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(n),!0}};var $h=class extends _S{constructor(e,t={}){super();this.file=e;this.options=t;b.assert(e instanceof Uint8Array||($().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((t,n)=>{let o=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)t(new Uint8Array(this.file.slice(this.offset,o)));else{let s=new FileReader;s.onload=a=>{let u=s.result;if(u instanceof ArrayBuffer&&(u=new Uint8Array(u)),!(u instanceof Uint8Array))return n(new TypeError("FileReader returned unknown type."));t(u)},s.onabort=a=>n(new Error("Aborted")),s.onerror=a=>n(new Error(a.type));let i=this.file.slice(this.offset,o);s.readAsArrayBuffer(i)}this.offset=o}),done:!1}}};async function CE(r,e={},t){let n,o;typeof r=="string"?n=r:(n=r.url,o=dee(r));let s=await(t||b.fetch)(n,o);if(s.ok){let i=new Uint8Array(await s.arrayBuffer());return new $h(i,e)}else throw new Error(s.statusText)}var dee=r=>({method:r.method,headers:r.headers,body:r.body,mode:r.mode,credentials:r.credentials,cache:r.cache,redirect:r.redirect,referrer:r.referrer,integrity:r.integrity});function Jy(r){return typeof r=="string"&&r.substr(0,7)==="file://"}var zh=class extends Bh{constructor(e,t={}){super();this.input=e;this.options=t}async iterator(){if(Jy(this.input)&&$().get("IS_NODE")){let e=Oh();this.input=e.readFileSync(this.input.substr(7))}return new $h(this.input,this.options)}};var Gh=class extends Bh{constructor(e,t={}){super();this.url=e;this.fileOptions=t}async iterator(){return Jy(this.url)?new zh(this.url,this.fileOptions).iterator():CE(this.url,this.fileOptions)}};function vE(r,e={}){return new Eh(new Gh(r),e)}function SE(r){let e=Ph(r);return Ln(async()=>e)}function wE(r){return Ln(async()=>{let e=await r();return Ph(()=>e.next())})}async function _E(r,e){return Lh.create(r,e)}async function AE(r){return Rh.create(r)}var NE="0.0.0";function ne(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&b.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}var fee=Tr.whereImpl,AS=class extends ps{constructor(){super();this.blockSize=48;this.firstUse=!0;this.data=new qa(this,qo())}nextDataId(){return AS.nextDataId++}write(e,t,n){this.firstUse&&(this.firstUse=!1,$().get("IS_NODE")&&I.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let o={id:this.nextDataId()};return this.data.set(o,{values:e,dtype:n,refCount:1}),o}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&b.isString(n[0])){let s=n.map(i=>b.encodeString(i));o=this.write(s,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){let t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){let t=this.data.get(e);t.refCount--}}move(e,t,n,o,s){this.data.set(e,{values:t,dtype:o,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){let{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){let o=this.readSync(n.real.dataId),s=this.readSync(n.imag.dataId);return I.mergeRealAndImagArrays(o,s)}return this.data.get(e).values}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>b.decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}makeOutput(e,t,n){let o=this.write(e,t,n);return qo().makeTensorFromDataId(o,t,n,this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;let{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){let t=b.now();return e(),{kernelMs:b.now()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){ne([e],"where");let t=this.readSync(e.dataId);return fee(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}},Uh=AS;Uh.nextDataId=0;var Dm={};Xe(Dm,{addImpl:()=>DS,bincountImpl:()=>_m,bincountReduceImpl:()=>ex,ceilImpl:()=>PS,concatImpl:()=>Cp,equalImpl:()=>MS,expImpl:()=>ES,expm1Impl:()=>LS,floorImpl:()=>BS,gatherNdImpl:()=>tx,gatherV2Impl:()=>rx,greaterEqualImpl:()=>OS,greaterImpl:()=>$S,lessEqualImpl:()=>GS,lessImpl:()=>zS,linSpaceImpl:()=>nx,logImpl:()=>US,maxImpl:()=>ox,maximumImpl:()=>WS,minimumImpl:()=>KS,multiplyImpl:()=>Wh,negImpl:()=>VS,notEqualImpl:()=>jS,prodImpl:()=>HS,rangeImpl:()=>Sp,rsqrtImpl:()=>qS,sigmoidImpl:()=>tR,simpleAbsImpl:()=>NS,sliceImpl:()=>wp,sparseFillEmptyRowsImpl:()=>sx,sparseReshapeImpl:()=>ax,sparseSegmentReductionImpl:()=>Nm,sqrtImpl:()=>oR,squaredDifferenceImpl:()=>YS,stridedSliceImpl:()=>ix,stringNGramsImpl:()=>ux,stringSplitImpl:()=>lx,stringToHashBucketFastImpl:()=>px,subImpl:()=>QS,tileImpl:()=>cx,topKImpl:()=>mx,transposeImpl:()=>Am,uniqueImpl:()=>dx});function NS(r){let e=new Float32Array(r.length);for(let t=0;t<r.length;++t)e[t]=Math.abs(r[t]);return e}var hee=r=>{let{x:e}=r.inputs,t=r.backend;ne(e,"abs");let n=new Float32Array(b.sizeFromShape(e.shape)),o=t.data.get(e.dataId).values;return n=NS(o),t.makeOutput(n,e.shape,e.dtype)},PE={kernelName:ms,backendName:"cpu",kernelFunc:hee};function tt(r){return(e,t,n,o,s)=>{let i=I.assertAndGetBroadcastShape(e,t),a=i.length,u=b.computeStrides(i),l=b.sizeFromShape(i),p=b.getTypedArrayFromDType(s,l),c=e.length,m=t.length,d=b.computeStrides(e),f=b.computeStrides(t),h=I.getBroadcastDims(e,i),g=I.getBroadcastDims(t,i);if(h.length+g.length===0)for(let x=0;x<p.length;++x)p[x]=r(n[x%n.length],o[x%o.length]);else for(let x=0;x<p.length;++x){let y=b.indexToLoc(x,a,u),T=y.slice(-c);h.forEach(M=>T[M]=0);let k=b.locToIndex(T,c,d),C=y.slice(-m);g.forEach(M=>C[M]=0);let A=b.locToIndex(C,m,f);p[x]=r(n[k],o[A])}return[p,i]}}function vr(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,a=t.makeTensorInfo(n.shape,"complex64"),u=t.data.get(a.dataId);return u.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",s),imag:t.makeTensorInfo(o.shape,"float32",i)},a}var ME={kernelName:Ru,backendName:"cpu",kernelFunc:vr};function Sm(r,e,t="float32"){if(t==="complex64"){let o=Sm(r,e,"float32"),s=Sm(r,e,"float32");return vr({inputs:{real:o,imag:s},backend:r})}let n=b.makeZerosTypedArray(b.sizeFromShape(e),t);return r.makeTensorInfo(e,t,n)}function Qr(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var FE={kernelName:jn,backendName:"cpu",kernelFunc:Qr};function Hs(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.real,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var EE={kernelName:Wu,backendName:"cpu",kernelFunc:Hs};function qs(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Qr({inputs:{x:o},backend:t});let i=Sm(t,o.shape,o.dtype),a=qs({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=vr({inputs:{real:a,imag:i},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=Hs({inputs:{input:o},backend:t}),a=qs({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(i),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=Qr({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32"){let i=t.data.get(o.dataId).values,a=Int32Array.from(i);return t.makeTensorInfo(o.shape,"int32",a)}if(s==="bool"){let i=t.data.get(o.dataId).values,a=b.toTypedArray([0],o.dtype),[u,l]=tt((p,c)=>p!==c?1:0)(o.shape,[],i,a,"bool");return t.makeTensorInfo(l,"bool",u)}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var RE={kernelName:Kn,backendName:"cpu",kernelFunc:qs};function it(r,e,t,n){return t==null?({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;ne([i,a],r);let l=u.data.get(i.dataId).values,p=u.data.get(a.dataId).values,c=i.dtype==="string"?I.fromUint8ToStringArray(l):l,m=i.dtype==="string"?I.fromUint8ToStringArray(p):p,d=n||i.dtype,[f,h]=e(i.shape,a.shape,c,m,d);return u.makeTensorInfo(h,d,f)}:({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(i.dtype==="complex64"||a.dtype==="complex64"){let l=qs({inputs:{x:i},backend:u,attrs:{dtype:"complex64"}}),p=u.data.get(l.dataId),c=p.complexTensorInfos.real,m=p.complexTensorInfos.imag,d=u.data.get(c.dataId).values,f=u.data.get(m.dataId).values,h=qs({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),g=u.data.get(h.dataId),x=g.complexTensorInfos.real,y=g.complexTensorInfos.imag,T=u.data.get(x.dataId).values,k=u.data.get(y.dataId).values,[C,A,M]=t(i.shape,a.shape,d,f,T,k),P=u.makeTensorInfo(M,"float32",C),F=u.makeTensorInfo(M,"float32",A),B=vr({inputs:{real:P,imag:F},backend:u});return u.disposeIntermediateTensorInfo(l),u.disposeIntermediateTensorInfo(h),u.disposeIntermediateTensorInfo(P),u.disposeIntermediateTensorInfo(F),B}else{let l=u.data.get(i.dataId).values,p=u.data.get(a.dataId).values,c=n||i.dtype,[m,d]=e(i.shape,a.shape,l,p,c);return u.makeTensorInfo(d,c,m)}}}function wm(r){return(e,t,n,o,s,i)=>{let a=I.assertAndGetBroadcastShape(e,t),u=b.sizeFromShape(a),l=a.length,p=b.computeStrides(a),c=b.getTypedArrayFromDType("float32",u),m=b.getTypedArrayFromDType("float32",u),d=I.getBroadcastDims(e,a),f=I.getBroadcastDims(t,a),h=I.mergeRealAndImagArrays(n,o),g=I.mergeRealAndImagArrays(s,i),x=e.length,y=b.computeStrides(e),T=t.length,k=b.computeStrides(t);if(d.length+f.length===0)for(let C=0;C<c.length;C++){let A=C%h.length,M=C%g.length,P=r(h[A*2],h[A*2+1],g[M*2],g[M*2+1]);c[C]=P.real,m[C]=P.imag}else for(let C=0;C<c.length;C++){let A=b.indexToLoc(C,l,p),M=A.slice(-x);d.forEach(W=>M[W]=0);let P=b.locToIndex(M,x,y),F=A.slice(-T);f.forEach(W=>F[W]=0);let B=b.locToIndex(F,T,k),U=r(h[P*2],h[P*2+1],g[B*2],g[B*2+1]);c[C]=U.real,m[C]=U.imag}return[c,m,a]}}var DS=tt((r,e)=>r+e),gee=wm((r,e,t,n)=>({real:r+t,imag:e+n})),xu=it(_n,DS,gee),LE={kernelName:_n,backendName:"cpu",kernelFunc:xu};function _m(r,e,t,n,o){let s=b.sizeFromShape(n),i=b.makeZerosTypedArray(o,t);for(let a=0;a<r.length;a++){let u=r[a];if(u<0)throw new Error("Input x must be non-negative!");u>=o||(s>0?i[u]+=e[a]:i[u]+=1)}return i}function ex(r,e,t,n=!1){let o=r.shape[0],s=r.shape[1],i=Ce([o,t],e.dtype);for(let a=0;a<o;a++)for(let u=0;u<s;u++){let l=r.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(n?i.set(1,a,l):e.size>0?i.set(i.get(a,l)+e.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}function In(r){return(e,t,n)=>{let o=b.getTypedArrayFromDType(t,e.length);for(let s=0;s<e.length;++s)o[s]=r(e[s],n);return o}}function Ee(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(ne(i,r),i.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=b.sizeFromShape(i.shape),p=t||i.dtype,c=b.getArrayFromDType(p,l);for(let m=0;m<l;++m)c[m]=e(u[m],o);return a.makeTensorInfo(i.shape,p,c)}}function Xs(r,e,t){return({inputs:n,attrs:o,backend:s})=>{let{x:i}=n;if(ne(i,r),i.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");let a=s,u=a.data.get(i.dataId).values,l=t||i.dtype,p=e(u,l,o);return a.makeTensorInfo(i.shape,l,p)}}var PS=In(r=>Math.ceil(r)),bee=Xs(uo,PS),BE={kernelName:uo,backendName:"cpu",kernelFunc:bee};function Cp(r,e,t,n){let o=b.getArrayFromDType(t,b.sizeFromShape(e));if(n&&t!=="string"){let s=0;r.forEach(i=>{let a=b.sizeFromShape(i.shape);o.set(i.vals,s),s+=a})}else{let s=0;r.forEach(i=>{let a=t==="string"?I.fromUint8ToStringArray(i.vals):i.vals,u=0;for(let l=0;l<i.shape[0];++l){let p=l*e[1]+s;for(let c=0;c<i.shape[1];++c)o[p+c]=a[u++]}s+=i.shape[1]})}return o}var MS=tt((r,e)=>r===e?1:0),FS=it(oa,MS,null,"bool"),$E={kernelName:oa,backendName:"cpu",kernelFunc:FS};var ES=In(r=>Math.exp(r)),RS=Xs(bo,ES,"float32"),OE={kernelName:bo,backendName:"cpu",kernelFunc:RS};var LS=In(r=>Math.expm1(r)),yee=Xs(sa,LS),zE={kernelName:sa,backendName:"cpu",kernelFunc:yee};var BS=In(r=>Math.floor(r)),xee=Xs(yo,BS),GE={kernelName:yo,backendName:"cpu",kernelFunc:xee};function tx(r,e,t,n,o,s,i,a,u){let l=Ce([n,s],t);for(let p=0;p<n;p++){let c=[],m=0;for(let d=0;d<o;d++){let f=r[p*o+d];m+=f*i[d],c.push(f)}if(m<0||m>=u/s)throw new Error(`Invalid indices: ${c} does not index into ${a}`);for(let d=0;d<s;d++)l.values[p*s+d]=e.get(...e.indexToLoc(m*s+d))}return l}function rx(r,e,t){let n=Ce(t,r.dtype);for(let o=0;o<n.size;++o){let i=n.indexToLoc(o).slice(),a=i[0],u=i[2],l=e.locToIndex([a,u]);i[2]=e.values[l];let p=r.locToIndex(i);n.values[o]=r.values[p]}return n}var $S=tt((r,e)=>r>e?1:0),Tee=it(ua,$S,null,"bool"),UE={kernelName:ua,backendName:"cpu",kernelFunc:Tee};var OS=tt((r,e)=>r>=e?1:0),kee=it(ko,OS,null,"bool"),WE={kernelName:ko,backendName:"cpu",kernelFunc:kee};var zS=tt((r,e)=>r<e?1:0),Iee=it(la,zS,null,"bool"),KE={kernelName:la,backendName:"cpu",kernelFunc:Iee};var GS=tt((r,e)=>r<=e?1:0),Cee=it(pa,GS,null,"bool"),VE={kernelName:pa,backendName:"cpu",kernelFunc:Cee};function nx(r,e,t){let n=(e-r)/(t-1),o=b.makeZerosTypedArray(t,"float32");o[0]=r;for(let s=1;s<o.length;s++)o[s]=o[s-1]+n;return o}var US=In(r=>Math.log(r)),vee=Xs(Co,US),jE={kernelName:Co,backendName:"cpu",kernelFunc:vee};function ox(r,e,t,n){let o=b.getTypedArrayFromDType(n,b.sizeFromShape(t));for(let s=0;s<o.length;++s){let i=s*e,a=r[i];for(let u=0;u<e;++u){let l=r[i+u];(Number.isNaN(l)||l>a)&&(a=l)}o[s]=a}return o}var WS=tt((r,e)=>Math.max(r,e)),See=it(So,WS),HE={kernelName:So,backendName:"cpu",kernelFunc:See};var KS=tt((r,e)=>Math.min(r,e)),wee=it(No,KS),qE={kernelName:No,backendName:"cpu",kernelFunc:wee};var Wh=tt((r,e)=>r*e),_ee=wm((r,e,t,n)=>({real:r*t-e*n,imag:r*n+e*t})),vp=it(Po,Wh,_ee),XE={kernelName:Po,backendName:"cpu",kernelFunc:vp};function VS(r,e,t){let n=b.createScalarValue(-1,t);return Wh([],e,n,r,t)}function Aee(r){let{inputs:e,backend:t}=r,{x:n}=e;ne(n,"neg");let o=t.data.get(n.dataId).values,[s,i]=VS(o,n.shape,n.dtype);return t.makeTensorInfo(i,n.dtype,s)}var YE={kernelName:bs,backendName:"cpu",kernelFunc:Aee};var jS=tt((r,e)=>r!==e?1:0),Nee=it(ma,jS,null,"bool"),QE={kernelName:ma,backendName:"cpu",kernelFunc:Nee};function Am(r,e,t,n,o){let s=e.length,i=b.sizeFromShape(e),a=b.computeStrides(e),u=b.computeStrides(o),l=b.getTypedArrayFromDType(t,b.sizeFromShape(o));for(let p=0;p<i;++p){let c=b.indexToLoc(p,s,a),m=new Array(c.length);for(let f=0;f<m.length;f++)m[f]=c[n[f]];let d=b.locToIndex(m,s,u);l[d]=r[p]}return l}function lr(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{perm:s}=t;ne(o,"transpose");let i=o.shape.length,a=new Array(i);for(let c=0;c<a.length;c++)a[c]=o.shape[s[c]];let u=n.data.get(o.dataId).values,l=Am(u,o.shape,o.dtype,s,a);return{dataId:n.write(l,a,o.dtype),shape:a,dtype:o.dtype}}var ZE={kernelName:Ho,backendName:"cpu",kernelFunc:lr};function HS(r,e,t,n){let[o,s]=I.computeOutAndReduceShapes(r,n),i=Kt(e,"int32"),a=b.makeZerosTypedArray(b.sizeFromShape(o),i),u=b.sizeFromShape(s);for(let l=0;l<a.length;++l){let p=l*u,c=1;for(let m=0;m<u;++m)c*=t[p+m];a[l]=c}return{outVals:a,outShape:o,outDtype:i}}function Dee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;ne(o,"prod");let a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=I.getAxesPermutation(u,a),p=u,c=o,m=[];l!=null&&(c=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),m.push(c),p=I.getInnerMostAxes(p.length,a));let d=t.data.get(c.dataId).values,{outVals:f,outShape:h,outDtype:g}=HS(c.shape,c.dtype,d,p),x=h;return i&&(x=I.expandShapeToKeepDim(h,u)),m.forEach(y=>t.disposeIntermediateTensorInfo(y)),t.makeTensorInfo(x,g,f)}var JE={kernelName:ga,backendName:"cpu",kernelFunc:Dee};function Sp(r,e,t,n){let o=r===e,s=r<e&&t<0,i=e<r&&t>1;if(o||s||i)return b.makeZerosTypedArray(0,n);let a=Math.abs(Math.ceil((e-r)/t)),u=b.makeZerosTypedArray(a,n);e<r&&t===1&&(t=-1),u[0]=r;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}var qS=In(r=>1/Math.sqrt(r)),Pee=Xs($o,qS),eR={kernelName:$o,backendName:"cpu",kernelFunc:Pee};var tR=In(r=>1/(1+Math.exp(-r))),XS=Ee(zo,r=>1/(1+Math.exp(-r))),rR={kernelName:zo,backendName:"cpu",kernelFunc:XS};function wp(r,e,t,n,o){let s=Tt.isSliceContinous(n,e,t),i=b.sizeFromShape(t),a=b.computeStrides(n);if(s){let c=Tt.computeFlatOffset(e,a);return o==="string"?r.slice(c,c+i):r.subarray(c,c+i)}let u=o==="string"?I.fromUint8ToStringArray(r):r,l=Ce(n,o,u),p=Ce(t,o);for(let c=0;c<p.size;++c){let m=p.indexToLoc(c),d=m.map((f,h)=>f+e[h]);p.set(l.get(...d),...m)}return o==="string"?I.fromStringArrayToUint8(p.values):p.values}function Ys(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:i}=n;ne(o,"slice");let[a,u]=Tt.parseSliceParams(o,s,i);Tt.assertParamsValid(o,a,u);let l=t.data.get(o.dataId).values,p=wp(l,a,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,p)}var nR={kernelName:Is,backendName:"cpu",kernelFunc:Ys};function sx(r,e,t,n,o,s,i){let a=e[0],u=s[0],l=new Array(u),p=new Array(a),c=e[1];if(u===0){if(a!==0)throw new Error(I.getSparseFillEmptyRowsIndicesDenseShapeMismatch(a));let g=b.getArrayFromDType(t,0),x=b.getArrayFromDType(o,0);return[g,[0,c],x,l,p]}let m=!0,d=0,f=new Array(u).fill(0);for(let g=0;g<a;++g){let x=r[g*c];if(x<0)throw new Error(I.getSparseFillEmptyRowsNegativeIndexErrorMessage(g,x));if(x>=u)throw new Error(I.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(g,x,u));++f[x],m=m&&x>=d,d=x}let h=!0;for(let g=0;g<u;++g){let x=f[g]===0;l[g]=x,h=h&&!x,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(h&&m){let g=r,x=n;for(let y=0;y<a;++y)p[y]=y;return[g,[a,c],x,l,p]}else{let g=f[u-1],x=b.getArrayFromDType(t,g*c),y=b.getArrayFromDType(o,g),T=new Array(u).fill(0);for(let k=0;k<a;++k){let C=r[k*c],A=T[C],M=(C===0?0:f[C-1])+A;T[C]++;for(let P=0;P<c;++P)x[M*c+P]=r[k*c+P];y[M]=n[k],p[k]=M}for(let k=0;k<u;++k)if(T[k]===0){let A=k===0?0:f[k-1];x[A*c+0]=k;for(let M=1;M<c;++M)x[A*c+M]=0;y[A]=i}return[x,[g,c],y,l,p]}}function ax(r,e,t,n,o){let s=b.sizeFromShape(n),i=e[0],a=o.length,u=[],l=1,p=-1;for(let g=0;g<a;++g){let x=o[g];if(x===-1){if(p!==-1)throw new Error(I.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(p,g));p=g,u.push(1)}else{if(x<0)throw new Error(I.getSparseReshapeNegativeOutputDimErrorMessage(g,x));l*=x,u.push(x)}}if(p!==-1){if(l<=0)throw new Error(I.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());let g=Math.trunc(s/l);if(l*g!==s)throw new Error(I.getSparseReshapeInputOutputMultipleErrorMessage(n,u));u[p]=g}if(b.sizeFromShape(u)!==s)throw new Error(I.getSparseReshapeInputOutputMismatchErrorMessage(n,u));let m=n.length,d=[];if(m>0){d[m-1]=1;for(let g=m-2;g>=0;--g)d[g]=d[g+1]*n[g+1]}let f=[];if(a>0){f[a-1]=1;for(let g=a-2;g>=0;--g)f[g]=f[g+1]*u[g+1]}let h=b.getArrayFromDType(t,i*a);for(let g=0;g<i;++g){let x=0;for(let y=0;y<m;++y)x+=r[g*m+y]*d[y];for(let y=0;y<a;++y)h[g*a+y]=Math.trunc(x/f[y]),x%=f[y]}return[h,[i,a],u]}function Nm(r,e,t,n,o,s=!1,i=0){let a=n.length,u=[e[0],r.length/e[0]],l=u[1],c=a>0?o[a-1]+1:0;if(c<0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=e.slice();m[0]=c;let d=m.reduce((T,k)=>T*k,1),f=b.getArrayFromDType(t,d);if(a===0)return c>0&&f.fill(i),[f,m];if(c<=0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let h=0,g=1,x=0,y=o[h];for(;;){let T=0;if(g<a){if(T=o[g],y===T){++g;continue}if(y>=T)throw new Error(I.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(y<0||y>=c)throw new Error(I.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(y,c));y>x&&f.fill(i,x*l,y*l);for(let k=h;k<g;++k){let C=n[k];if(C<0||C>=u[0])throw new Error(I.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(k,n[k],u[0]));for(let A=0;A<l;A++)f[y*l+A]+=r[C*l+A]}if(s)for(let k=0;k<l;k++)f[y*l+k]/=g-h;if(h=g,++g,x=y+1,y=T,g>a)break}return x<c&&f.fill(i,x*l,c*l),[f,m]}var oR=In(r=>Math.sqrt(r)),Mee=Ee(Go,r=>Math.sqrt(r)),sR={kernelName:Go,backendName:"cpu",kernelFunc:Mee};var YS=tt((r,e)=>{let t=r-e;return t*t}),Fee=it(Ko,YS),aR={kernelName:Ko,backendName:"cpu",kernelFunc:Fee};function ix(r,e,t,n){let o=Ce(r,e.dtype);for(let s=0;s<o.size;s++){let i=o.indexToLoc(s),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*t[u]+n[u];o.set(e.get(...a),...i)}return o}var iR=class{constructor(e,t,n,o,s,i){this.separator=b.encodeString(e),this.nGramWidths=t,this.leftPad=b.encodeString(n),this.rightPad=b.encodeString(o),this.padWidth=s,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){let n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,o,s,i){for(let a=0;a<s;++a){let u=this.getPadWidth(i),l=Math.max(0,u-a),p=Math.max(0,u-(s-(a+1))),c=i-(l+p),m=t+(l>0?0:a-u),d=0;d+=l*this.leftPad.length;for(let y=0;y<c;++y)d+=e[m+y].length;d+=p*this.rightPad.length,d+=(l+p+c-1)*this.separator.length,n[o+a]=new Uint8Array(d);let h=n[o+a],g=0,x=y=>y.forEach(T=>h[g++]=T);for(let y=0;y<l;++y)x(this.leftPad),x(this.separator);for(let y=0;y<c-1;++y)x(e[m+y]),x(this.separator);if(c>0){x(e[m+c-1]);for(let y=0;y<p;++y)x(this.separator),x(this.rightPad)}else{for(let y=0;y<p-1;++y)x(this.rightPad),x(this.separator);x(this.rightPad)}}}compute(e,t){let n=e.length,o=t.length;if(o>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<o;++l){let p=t[l]>=u;if(p=p&&t[l]<=n,!p)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${n}]`);u=t[l]}if(u!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${u}`)}let s=o-1,i=b.getArrayFromDType("int32",o);if(n===0||o===0){let u=new Array(n);for(let l=0;l<=s;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=s;++u){let l=t[u]-t[u-1],p=0;this.nGramWidths.forEach(c=>{p+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&p===0&&(p=1),i[u]=i[u-1]+p}let a=new Array(i[s]);for(let u=0;u<s;++u){let l=t[u],p=i[u];if(this.nGramWidths.forEach(c=>{let m=t[u+1]-t[u],d=this.getNumNGrams(m,c);this.createNGrams(e,l,a,p,d,c),p+=d}),this.preserveShort&&p===i[u]){let c=t[u+1]-t[u];if(c===0)continue;let m=c+2*this.padWidth,d=1;this.createNGrams(e,l,a,p,d,m)}}return[a,i]}};function ux(r,e,t,n,o,s,i,a){return new iR(t,n,o,s,i,a).compute(r,e)}function Eee(r,e,t,n){if(!r.length)return;if(e.length===0){for(let s=0;s<r.length;++s)n.push(r.subarray(s,s+1));return}if(e.length===1){let s=e[0],i=r.indexOf(s);for(;i!==-1;){let a=r.subarray(0,i);(!t||a.length!==0)&&n.push(a),r=r.subarray(i+1),i=r.indexOf(s)}(!t||r.length!==0)&&n.push(r);return}let o=0;for(let s=0;s<r.length+1;s++)if(s===r.length||e.indexOf(r[s])!==-1){let i=r.subarray(o,s);(!t||i.length!==0)&&n.push(i),o=s+1}}function lx(r,e,t){let n=r.length,o=[],s=0,i=0,a=new Array(n);for(let m=0;m<n;++m){let d=o.length;Eee(r[m],e,t,o);let f=o.length-d;a[m]=f,s+=f,i=Math.max(i,f)}let u=b.getArrayFromDType("int32",s*2),l=new Array(s),p=[n,i],c=0;for(let m=0;m<n;++m)for(let d=0;d<a[m];++d)u[c*2]=m,u[c*2+1]=d,l[c]=o[c],++c;return[u,l,p]}function px(r,e){let t=b.getArrayFromDType("int32",r.length);for(let n=0;n<r.length;++n)t[n]=b.fingerPrint64(r[n]).modulo(e).getLowBitsUnsigned();return t}var QS=tt((r,e)=>r-e),Ree=wm((r,e,t,n)=>({real:r-t,imag:e-n})),Kh=it(Vo,QS,Ree),uR={kernelName:Vo,backendName:"cpu",kernelFunc:Kh};function cx(r,e){let t=new Array(r.rank);for(let o=0;o<t.length;o++)t[o]=r.shape[o]*e[o];let n=Ce(t,r.dtype);for(let o=0;o<n.values.length;++o){let s=n.indexToLoc(o),i=new Array(r.rank);for(let u=0;u<i.length;u++)i[u]=s[u]%r.shape[u];let a=r.locToIndex(i);n.values[o]=r.values[a]}return n}var Vh=(r,e)=>{let t=e.value-r.value;return t===0?r.index-e.index:t};function lR(r,e,t=0,n=r.length-1){for(;n>t;){if(n-t>600){let a=n-t+1,u=e-t+1,l=Math.log(a),p=.5*Math.exp(2*l/3),c=.5*Math.sqrt(l*p*(a-p)/a)*Math.sign(u-a/2),m=Math.max(t,Math.floor(e-u*p/a+c)),d=Math.min(n,Math.floor(e+(a-u)*p/a+c));lR(r,e,m,d)}let o=r[e],s=t,i=n;for(b.swap(r,t,e),Vh(r[n],o)>0&&b.swap(r,t,n);s<i;){for(b.swap(r,s,i),s++,i--;Vh(r[s],o)<0;)s=s+1;for(;Vh(r[i],o)>0;)i=i-1}Vh(r[t],o)===0?b.swap(r,t,i):(i=i+1,b.swap(r,i,n)),i<=e&&(t=i+1),e<=i&&(n=i-1)}}function mx(r,e,t,n,o){let s=e[e.length-1],[i,a]=[r.length/s,s],u=b.getTypedArrayFromDType(t,i*n),l=b.getTypedArrayFromDType("int32",i*n);for(let c=0;c<i;c++){let m=c*a,d=r.subarray(m,m+a),f=new Array(d.length);d.forEach((y,T)=>f[T]={value:y,index:T}),n<f.length&&(lR(f,n),f=f.slice(0,n)),o&&f.sort(Vh);let h=c*n,g=u.subarray(h,h+n),x=l.subarray(h,h+n);for(let y=0;y<n;y++)g[y]=f[y].value,x[y]=f[y].index}let p=e.slice();return p[p.length-1]=n,[Ce(p,t,u),Ce(p,"int32",l)]}function dx(r,e,t,n){let o=b.parseAxisParam(e,t)[0],s=[1,t[0],1];for(let f=0;f<o;f++)s[0]*=t[f];s[1]=t[o];for(let f=o+1;f<t.length;f++)s[2]*=t[f];let i={},a=new Int32Array(t[o]),u=new yt(s,n,r),l=[],p=s[0]===1&&s[2]===1;for(let f=0;f<t[o];f++){let h;if(p)h=r[f].toString();else{let g=[];for(let x=0;x<s[0];x++)for(let y=0;y<s[2];y++)g.push(u.get(x,f,y));h=g.join(",")}if(i[h]!==void 0)a[f]=i[h];else{let g=Object.keys(i).length;i[h]=g,a[f]=g,l.push(f)}}let c=s.slice();c[1]=Object.keys(i).length;let m=new yt(c,n);l.forEach((f,h)=>{for(let g=0;g<s[0];g++)for(let x=0;x<s[2];x++)m.set(u.get(g,f,x),g,h,x)});let d=t.slice();return d[o]=c[1],{outputValues:m.values,outputShape:d,indices:a}}var Lee="0.0.0";el("cpu",()=>new Uh,1);var ZS=Ee(go,r=>r>=0?r:Math.exp(r)-1),pR={kernelName:go,backendName:"cpu",kernelFunc:ZS};function JS(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n;ne([o],"leakyRelu");let i=b.sizeFromShape(o.shape),a=t.data.get(o.dataId).values,u=b.getTypedArrayFromDType("float32",i);for(let l=0;l<a.length;l++)u[l]=a[l]<0?s*a[l]:a[l];return t.makeTensorInfo(o.shape,"float32",u)}var cR={kernelName:Io,backendName:"cpu",kernelFunc:JS};var Bee=tt((r,e)=>r<0?e*r:r);function ew(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e;ne([n,o],"prelu");let s=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,[a,u]=Bee(n.shape,o.shape,s,i,"float32");return t.makeTensorInfo(u,"float32",a)}var mR={kernelName:Eo,backendName:"cpu",kernelFunc:ew};var tw=Ee(Ro,r=>Math.max(0,r)),dR={kernelName:Ro,backendName:"cpu",kernelFunc:tw};var rw=Ee(Bo,r=>Math.min(Math.max(0,r),6)),fR={kernelName:Bo,backendName:"cpu",kernelFunc:rw};function Pm(r,e,t,n,o){if(t==="linear")return Qr({inputs:{x:e},backend:r});if(t==="relu")return tw({inputs:{x:e},backend:r});if(t==="elu")return ZS({inputs:{x:e},backend:r});if(t==="relu6")return rw({inputs:{x:e},backend:r});if(t==="prelu")return ew({inputs:{x:e,alpha:n},backend:r});if(t==="leakyrelu")return JS({inputs:{x:e},backend:r,attrs:{alpha:o}});if(t==="sigmoid")return XS({inputs:{x:e},backend:r});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}function ot(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,i=b.sizeFromShape(o.shape),a=b.inferFromImplicitShape(s,i),u=b.sizeFromShape(a);b.assert(i===u,()=>`The new shape (${a}) has ${u} elements and the old shape (${o.shape}) has ${i} elements. The new shape and old shape must have the same number of elements.`),t.incRef(o.dataId);let l=t.data.get(o.dataId);if(l.complexTensorInfos!=null){let p=l.complexTensorInfos.real,c=l.complexTensorInfos.imag;p.shape=a,c.shape=a}return{dataId:o.dataId,shape:a,dtype:o.dtype}}var hR={kernelName:Ts,backendName:"cpu",kernelFunc:ot};function nw(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:i,transposeB:a}=n;ne([o,s],"matMul");let u=o.shape.length,l=s.shape.length,p=i?o.shape[u-2]:o.shape[u-1],c=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],d=a?s.shape[l-2]:s.shape[l-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=b.sizeFromShape(f),x=b.sizeFromShape(h),T=Ar.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,d]);b.assert(p===c,()=>`Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let k=i?[g,p,m]:[g,m,p],C=a?[x,d,c]:[x,c,d],A=ot({inputs:{x:o},backend:t,attrs:{shape:k}}),M=ot({inputs:{x:s},backend:t,attrs:{shape:C}}),P=i?A.shape[1]:A.shape[2],F=i?A.shape[2]:A.shape[1],B=a?M.shape[1]:M.shape[2],U=Math.max(g,x),W=t.data.get(A.dataId).values,K=t.data.get(M.dataId).values,j=b.computeStrides(A.shape),V=b.computeStrides(M.shape),[q,ee,Z]=i?[j[0],1,j[1]]:[j[0],j[1],1],[te,oe,ie]=a?[1,V[1],V[0]]:[V[1],1,V[0]],se=F*B,ue=Ce([U,F,B],A.dtype),ye=ue.values,fe=t.blockSize;for(let Te=0;Te<U;Te++)for(let we=0;we<F;we+=fe)for(let Re=0;Re<B;Re+=fe)for(let Le=0;Le<P;Le+=fe){let Ue=Math.min(we+fe,F),Y=Math.min(Re+fe,B),gt=Math.min(Le+fe,P);for(let It=we;It<Ue;It++)for(let Nt=Re;Nt<Y;Nt++){let Gt=0;for(let ft=Le;ft<gt;ft++){let at=Math.min(Te,g-1)*q,Ut=Math.min(Te,x-1)*ie,On=W[at+It*ee+ft*Z],pr=K[ft*te+Nt*oe+Ut];Gt+=On*pr}ye[Te*se+(It*B+Nt)]+=Gt}}return t.disposeIntermediateTensorInfo(A),t.disposeIntermediateTensorInfo(M),t.makeTensorInfo(T,ue.dtype,ue.values)}var gR={kernelName:io,backendName:"cpu",kernelFunc:nw};function $ee(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n,m,d,f,h=[];m=nw({inputs:{a:o,b:s},attrs:{transposeA:u,transposeB:l},backend:t}),i&&(d=xu({inputs:{a:m,b:i},backend:t}),h.push(m),m=d),p&&(f=Pm(t,m,p,a,c),h.push(m),m=f);for(let x of h)t.disposeIntermediateTensorInfo(x);return m}var bR={kernelName:As,backendName:"cpu",kernelFunc:$ee};var Oee=Ee(Di,r=>Math.acos(r)),yR={kernelName:Di,backendName:"cpu",kernelFunc:Oee};var zee=Ee(Pi,r=>Math.acosh(r)),xR={kernelName:Pi,backendName:"cpu",kernelFunc:zee};function Gee(r){let{inputs:e,backend:t}=r,n=e;ne(e,"addN");let o=n.map(a=>t.data.get(a.dataId).values),s=Ce(n[0].shape,n[0].dtype),i=s.values;for(let a=0;a<n.length;a++){let u=o[a];for(let l=0;l<i.length;l++)i[l]+=u[l]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}var TR={kernelName:oo,backendName:"cpu",kernelFunc:Gee};function Uee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;ne(o,"all");let a=b.parseAxisParam(s,o.shape),u=a,l=I.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),u=I.getInnerMostAxes(u.length,o.shape.length)),I.assertAxesAreInnerMostDims("all",u,p.shape.length);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),d=b.sizeFromShape(m),f=b.makeZerosTypedArray(b.sizeFromShape(c),p.dtype),h=t.data.get(p.dataId).values;for(let x=0;x<f.length;++x){let y=x*d,T=h[y];for(let k=0;k<d;++k){let C=h[y+k];T=T&&C}f[x]=T}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(c,p.dtype,f);if(i){let x=I.expandShapeToKeepDim(c,a),y=ot({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),y}return g}var kR={kernelName:Mi,backendName:"cpu",kernelFunc:Uee};function Wee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;ne(o,"any");let a=b.parseAxisParam(s,o.shape),u=a,l=I.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),u=I.getInnerMostAxes(u.length,o.shape.length)),I.assertAxesAreInnerMostDims("any",u,p.shape.length);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),d=b.sizeFromShape(m),f=b.makeZerosTypedArray(b.sizeFromShape(c),p.dtype),h=t.data.get(p.dataId).values;for(let x=0;x<f.length;++x){let y=x*d,T=h[y];for(let k=0;k<d;++k){let C=h[y+k];T=T||C}f[x]=T}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(c,p.dtype,f);if(i){let x=I.expandShapeToKeepDim(c,a),y=ot({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),y}return g}var IR={kernelName:Fi,backendName:"cpu",kernelFunc:Wee};function Kee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;ne(o,"argMax");let i=b.parseAxisParam(s,o.shape),a=I.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=lr({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=I.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],I.assertAxesAreInnerMostDims("argMax",i,u.shape.length);let[p,c]=I.computeOutAndReduceShapes(u.shape,i),m=b.sizeFromShape(p),d=b.makeZerosTypedArray(m,"int32"),f=b.sizeFromShape(c),h=t.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let x=g*f,y=h[x],T=0;for(let k=0;k<f;++k){let C=h[x+k];C>y&&(y=C,T=k)}d[g]=T}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",d)}var CR={kernelName:so,backendName:"cpu",kernelFunc:Kee};function Vee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n;ne(o,"argMin");let i=b.parseAxisParam(s,o.shape),a=I.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=lr({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=I.getInnerMostAxes(i.length,u.shape.length)),i=[i[0]],I.assertAxesAreInnerMostDims("argMin",i,u.shape.length);let[p,c]=I.computeOutAndReduceShapes(u.shape,i),m=b.sizeFromShape(p),d=b.makeZerosTypedArray(m,"int32"),f=b.sizeFromShape(c),h=t.data.get(u.dataId).values;for(let g=0;g<d.length;++g){let x=g*f,y=h[x],T=0;for(let k=0;k<f;++k){let C=h[x+k];C<y&&(y=C,T=k)}d[g]=T}return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),t.makeTensorInfo(p,"int32",d)}var vR={kernelName:Qa,backendName:"cpu",kernelFunc:Vee};var jee=Ee(Ei,r=>Math.asin(r)),SR={kernelName:Ei,backendName:"cpu",kernelFunc:jee};var Hee=Ee(Ri,r=>Math.asinh(r)),wR={kernelName:Ri,backendName:"cpu",kernelFunc:Hee};var qee=Ee(Li,r=>Math.atan(r)),_R={kernelName:Li,backendName:"cpu",kernelFunc:qee};var Xee=tt((r,e)=>Math.atan2(r,e)),Yee=it($i,Xee),AR={kernelName:$i,backendName:"cpu",kernelFunc:Yee};var Qee=Ee(Bi,r=>Math.atanh(r)),NR={kernelName:Bi,backendName:"cpu",kernelFunc:Qee};function Mm(r,e,t,n,o,s){let i=o.strideHeight,a=o.strideWidth,u=o.dilationHeight,l=o.dilationWidth,p=o.effectiveFilterHeight,c=o.effectiveFilterWidth,m=o.padInfo.top,d=o.padInfo.left,f=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,h=Ce(o.outShape,t),g=h.values,x=o.outShape[1]*o.outShape[2]*o.outShape[3],y=o.outShape[2]*o.outShape[3],T=o.outShape[3];for(let k=0;k<o.batchSize;++k){let C=k*x,A=k*n[0];for(let M=0;M<o.inChannels;++M)for(let P=0;P<o.outHeight;++P){let F=P*i-m,B=Math.max(0,F),U=Math.min(o.inHeight,p+F),W=C+P*y;for(let K=0;K<o.outWidth;++K){let j=K*a-d,V=Math.max(0,j),q=Math.min(o.inWidth,c+j),ee=f,Z=0,te=0;for(let ie=B;ie<U;ie+=u){let se=A+ie*n[1];for(let ue=V;ue<q;ue+=l){let ye=se+ue*n[2],fe=r[ye+M];s==="max"&&fe>ee?ee=fe:s==="avg"&&(Z+=fe,te++)}if(isNaN(ee))break}let oe=W+K*T+M;g[oe]=s==="avg"?Z/te:ee}}}return h}function fx(r,e,t,n,o=!1,s=!1){let i=Ce(n.outShape,"int32"),a=n.strideHeight,u=n.strideWidth,l=n.dilationHeight,p=n.dilationWidth,c=n.effectiveFilterHeight,m=n.effectiveFilterWidth,d=n.padInfo.top,f=n.padInfo.left,h=Ce(e,t,r);for(let g=0;g<n.batchSize;++g)for(let x=0;x<n.inChannels;++x)for(let y=0;y<n.outHeight;++y){let T=y*a-d,k=T;for(;k<0;)k+=l;let C=Math.min(n.inHeight,c+T);for(let A=0;A<n.outWidth;++A){let M=A*u-f,P=M;for(;P<0;)P+=p;let F=Math.min(n.inWidth,m+M),B=Number.NEGATIVE_INFINITY,U=-1;for(let W=k;W<C;W+=l){let K=W-T;for(let j=P;j<F;j+=p){let V=j-M,q=h.get(g,W,j,x);q>B&&(B=q,o?U=s?((g*n.inHeight+W)*n.inWidth+j)*n.inChannels+x:(W*n.inWidth+j)*n.inChannels+x:U=K*m+V)}}i.set(U,g,y,A,x)}}return i}function hx(r,e,t,n,o,s){let i=o.strideDepth,a=o.strideHeight,u=o.strideWidth,l=o.dilationDepth,p=o.dilationHeight,c=o.dilationWidth,m=o.effectiveFilterDepth,d=o.effectiveFilterHeight,f=o.effectiveFilterWidth,h=o.padInfo.front,g=o.padInfo.top,x=o.padInfo.left,y=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,T=Ce(o.outShape,t),k=T.values,C=o.outShape[1]*o.outShape[2]*o.outShape[3]*o.outShape[4],A=o.outShape[2]*o.outShape[3]*o.outShape[4],M=o.outShape[3]*o.outShape[4],P=o.outShape[4];for(let F=0;F<o.batchSize;++F){let B=F*C,U=F*n[0];for(let W=0;W<o.inChannels;++W)for(let K=0;K<o.outDepth;++K){let j=K*i-h,V=j;for(;V<0;)V+=l;let q=Math.min(o.inDepth,m+j),ee=B+K*A;for(let Z=0;Z<o.outHeight;++Z){let te=Z*a-g,oe=te;for(;oe<0;)oe+=p;let ie=Math.min(o.inHeight,d+te),se=ee+Z*M;for(let ue=0;ue<o.outWidth;++ue){let ye=ue*u-x,fe=ye;for(;fe<0;)fe+=c;let Te=Math.min(o.inWidth,f+ye),we=se+ue*P,Re=y,Le=0,Ue=0;for(let gt=V;gt<q;gt+=l){let It=U+gt*n[1];for(let Nt=oe;Nt<ie;Nt+=p){let Gt=It+Nt*n[2];for(let ft=fe;ft<Te;ft+=c){let at=Gt+ft*n[3],Ut=r[at+W];if(s==="max"&&Ut>Re?Re=Ut:s==="avg"&&(Le+=Ut,Ue++),isNaN(Re))break}if(isNaN(Re))break}if(isNaN(Re))break}let Y=we+W;k[Y]=s==="avg"?Le/Ue:Re}}}}return T}function DR(r,e){let t=Ce(e.outShape,"int32"),n=e.strideDepth,o=e.strideHeight,s=e.strideWidth,i=e.dilationDepth,a=e.dilationHeight,u=e.dilationWidth,l=e.effectiveFilterDepth,p=e.effectiveFilterHeight,c=e.effectiveFilterWidth,m=e.padInfo.front,d=e.padInfo.top,f=e.padInfo.left;for(let h=0;h<e.batchSize;++h)for(let g=0;g<e.inChannels;++g)for(let x=0;x<e.outDepth;++x){let y=x*n-m,T=y;for(;T<0;)T+=i;let k=Math.min(e.inDepth,l+y);for(let C=0;C<e.outHeight;++C){let A=C*o-d,M=A;for(;M<0;)M+=a;let P=Math.min(e.inHeight,p+A);for(let F=0;F<e.outWidth;++F){let B=F*s-f,U=B;for(;U<0;)U+=u;let W=Math.min(e.inWidth,c+B),K=Number.NEGATIVE_INFINITY,j=-1;for(let V=T;V<k;V+=i){let q=V-y;for(let ee=M;ee<P;ee+=a){let Z=ee-A;for(let te=U;te<W;te+=u){let oe=te-B,ie=r.get(h,V,ee,te,g);ie>=K&&(K=ie,j=q*p*c+Z*p+oe)}}}t.set(j,h,x,C,F,g)}}}return t}function Zee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;ne(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,i,l,a,u),c;if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))c=Qr({inputs:{x:o},backend:t});else{let m=t.data.get(o.dataId).values,d=b.computeStrides(o.shape),f=Mm(m,o.shape,o.dtype,d,p,"avg");c=t.makeTensorInfo(p.outShape,o.dtype,f.values)}return c}var PR={kernelName:ao,backendName:"cpu",kernelFunc:Zee};function Jee(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;ne(o,"avgPool3d");let p=I.computePool3DInfo(o.shape,s,i,1,a,u,l),c=t.data.get(o.dataId).values,m=hx(c,o.shape,o.dtype,b.computeStrides(o.shape),p,"avg");return t.makeTensorInfo(m.shape,"float32",m.values)}var MR={kernelName:Eu,backendName:"cpu",kernelFunc:Jee};function ete(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;ne([o,s],"avgPool3DGrad");let p=I.computePool3DInfo(s.shape,i,a,1,u,l),c=p.strideDepth,m=p.strideHeight,d=p.strideWidth,f=p.filterDepth,h=p.filterHeight,g=p.filterWidth,x=p.dilationDepth,y=p.dilationHeight,T=p.dilationWidth,k=p.effectiveFilterDepth,C=p.effectiveFilterHeight,A=p.effectiveFilterWidth,M=k-1-p.padInfo.front,P=A-1-p.padInfo.left,F=C-1-p.padInfo.top,B=Ce(s.shape,"float32"),U=1/(f*h*g),W=t.bufferSync(o);for(let K=0;K<p.batchSize;++K)for(let j=0;j<p.inChannels;++j)for(let V=0;V<p.inDepth;++V)for(let q=0;q<p.inHeight;++q)for(let ee=0;ee<p.inWidth;++ee){let Z=V-M,te=q-F,oe=ee-P,ie=0;for(let se=0;se<k;se+=x){let ue=(Z+se)/c;if(!(ue<0||ue>=p.outDepth||Math.floor(ue)!==ue))for(let ye=0;ye<C;ye+=y){let fe=(te+ye)/m;if(!(fe<0||fe>=p.outHeight||Math.floor(fe)!==fe))for(let Te=0;Te<A;Te+=T){let we=(oe+Te)/d;if(we<0||we>=p.outWidth||Math.floor(we)!==we)continue;ie+=W.get(K,ue,fe,we,j)}}}B.set(ie*U,K,V,q,ee,j)}return t.makeTensorInfo(B.shape,B.dtype,B.values)}var FR={kernelName:ac,backendName:"cpu",kernelFunc:ete};function tte(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,i=s;ne([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,p=I.computePool2DInfo(i.shape,a,u,1,l),c=p.strideHeight,m=p.strideWidth,d=p.filterHeight,f=p.filterWidth,h=p.dilationHeight,g=p.dilationWidth,x=p.effectiveFilterHeight,y=p.effectiveFilterWidth,T=y-1-p.padInfo.left,k=x-1-p.padInfo.top,C=Ce(i.shape,"float32"),A=1/(d*f),M=t.data.get(o.dataId).values,P=Ce(o.shape,"float32",M);for(let F=0;F<p.batchSize;++F)for(let B=0;B<p.inChannels;++B)for(let U=0;U<p.inHeight;++U)for(let W=0;W<p.inWidth;++W){let K=U-k,j=W-T,V=0;for(let q=0;q<x;q+=h){let ee=(K+q)/c;if(!(ee<0||ee>=p.outHeight||Math.floor(ee)!==ee))for(let Z=0;Z<y;Z+=g){let te=(j+Z)/m;if(te<0||te>=p.outWidth||Math.floor(te)!==te)continue;V+=P.get(F,ee,te,B)}}C.set(V*A,F,U,W,B)}return t.makeTensorInfo(C.shape,C.dtype,C.values)}var ER={kernelName:sc,backendName:"cpu",kernelFunc:tte};function rte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,scale:s,offset:i,mean:a,variance:u}=e;b.assert(a.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||a.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(s==null||a.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),ne([o,a,u,s,i],"batchNorm");let{varianceEpsilon:l}=n;l==null&&(l=.001);let p=t.data.get(o.dataId).values,c=t.data.get(a.dataId).values,m=t.data.get(u.dataId).values,d=s?t.data.get(s.dataId).values:new Float32Array([1]),f=i?t.data.get(i.dataId).values:new Float32Array([0]),h=new Float32Array(p.length),g=f.length,x=d.length,y=m.length,T=c.length,k=0,C=0,A=0,M=0;for(let P=0;P<p.length;++P)h[P]=f[k++]+(p[P]-c[C++])*d[A++]/Math.sqrt(m[M++]+l),k>=g&&(k=0),C>=T&&(C=0),A>=x&&(A=0),M>=y&&(M=0);return t.makeTensorInfo(o.shape,o.dtype,h)}var RR={kernelName:To,backendName:"cpu",kernelFunc:rte};function nte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:i}=n;ne([o],"batchToSpaceND");let a=s.reduce((x,y)=>x*y),u=I.getReshaped(o.shape,s,a),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,a),c=I.getSliceBeginCoords(i,s.length),m=I.getSliceSize(p,i,s.length),d=ot({inputs:{x:o},backend:t,attrs:{shape:u}}),f=lr({inputs:{x:d},backend:t,attrs:{perm:l}}),h=ot({inputs:{x:f},backend:t,attrs:{shape:p}}),g=Ys({inputs:{x:h},backend:t,attrs:{begin:c,size:m}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var LR={kernelName:ds,backendName:"cpu",kernelFunc:nte};function ote(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:i}=n,a=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,l=_m(a,u,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}var BR={kernelName:ic,backendName:"cpu",kernelFunc:ote};function ste(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.data.get(n.dataId).values,i=t.data.get(o.dataId).values,a=I.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var $R={kernelName:uc,backendName:"cpu",kernelFunc:ste};var ate=Ee(Vn,(r,e)=>{let t=e;return r>t.clipValueMax?t.clipValueMax:r<t.clipValueMin?t.clipValueMin:r}),OR={kernelName:Vn,backendName:"cpu",kernelFunc:ate};var ite=r=>{let{x:e}=r.inputs,t=r.backend,n=new Float32Array(b.sizeFromShape(e.shape)),o=t.data.get(e.dataId),s=o.complexTensorInfos.real,i=o.complexTensorInfos.imag,a=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values;for(let l=0;l<a.length;l++){let p=a[l],c=u[l];n[l]=Math.hypot(p,c)}return t.makeOutput(n,e.shape,"float32")},zR={kernelName:Lu,backendName:"cpu",kernelFunc:ite};function yi(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.data.get(n.dataId).complexTensorInfos.imag,s=t.data.get(o.dataId).values;return t.makeTensorInfo(o.shape,o.dtype,s)}var GR={kernelName:zu,backendName:"cpu",kernelFunc:yi};function fl(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,e[0].shape)[0],i=I.computeOutShape(e.map(h=>h.shape),s);if(b.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let a=e.filter(h=>b.sizeFromShape(h.shape)>0);if(a.length===1)return Qr({inputs:{x:a[0]},backend:t});let u=a.map(h=>h.shape);if(I.assertParamsConsistent(u,s),a[0].dtype==="complex64"){let h=a.map(k=>Hs({inputs:{input:k},backend:t})),g=a.map(k=>yi({inputs:{input:k},backend:t})),x=fl({inputs:h,backend:t,attrs:{axis:s}}),y=fl({inputs:g,backend:t,attrs:{axis:s}}),T=vr({inputs:{real:x,imag:y},backend:t});return h.forEach(k=>t.disposeIntermediateTensorInfo(k)),g.forEach(k=>t.disposeIntermediateTensorInfo(k)),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(y),T}let l=a.map(h=>{let g=b.sizeFromShape(h.shape.slice(s));return ot({inputs:{x:h},backend:t,attrs:{shape:[-1,g]}})}),p=l.map(h=>({vals:t.data.get(h.dataId).values,shape:h.shape}));i=I.computeOutShape(l.map(h=>h.shape),1);let c=l[0].shape[0]===1,m=Cp(p,i,e[0].dtype,c),d=I.computeOutShape(a.map(h=>h.shape),s),f=t.makeTensorInfo(d,e[0].dtype,m);return l.forEach(h=>t.disposeIntermediateTensorInfo(h)),f}var UR={kernelName:fs,backendName:"cpu",kernelFunc:fl};function ow(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:p}=n;ne([o,s],"conv2d");let c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,s.shape,i,l,a,p,!1,c),d=m.filterHeight,f=m.filterWidth,h=m.dilationHeight,g=m.dilationWidth,x=m.padInfo.left,y=m.padInfo.top,T=m.dataFormat==="channelsLast",k=new yt(m.outShape,o.dtype),C=b.computeStrides(o.shape),A=b.computeStrides(s.shape),M=C[0],P=T?C[1]:C[2],F=T?C[2]:1,B=T?1:C[1],U=k.strides[0],W=T?k.strides[1]:k.strides[2],K=T?k.strides[2]:1,j=T?1:k.strides[1],V=t.data.get(o.dataId).values,q=t.data.get(s.dataId).values,ee=k.values;for(let Z=0;Z<m.batchSize;++Z){let te=Z*M,oe=Z*U;for(let ie=0;ie<m.outHeight;++ie){let se=oe+ie*W,ue=ie*m.strideHeight-y;for(let ye=0;ye<d;++ye){let fe=ue+ye*h;if(fe<0||fe>=m.inHeight)continue;let Te=ye*A[0],we=te+fe*P;for(let Re=0;Re<m.outWidth;++Re){let Le=se+Re*K,Ue=Re*m.strideWidth-x;for(let Y=0;Y<f;++Y){let gt=Ue+Y*g;if(gt<0||gt>=m.inWidth)continue;let It=Te+Y*A[1],Nt=we+gt*F,Gt=It;for(let ft=0;ft<m.inChannels;++ft){let at=V[Nt+ft*B];for(let Ut=0;Ut<m.outChannels;++Ut)ee[Le+Ut*j]+=at*q[Gt+Ut];Gt+=m.outChannels}}}}}}return t.makeTensorInfo(k.shape,k.dtype,ee)}var WR={kernelName:lo,backendName:"cpu",kernelFunc:ow};function ute(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:p}=n;ne([o,s],"conv2dBackpropFilter");let c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,p,i,1,a,l,!1,c),{strideHeight:d,strideWidth:f,filterHeight:h,filterWidth:g}=m,x=m.dataFormat==="channelsLast",y=new yt(m.filterShape,"float32"),T=m.padInfo.left,k=m.padInfo.top,C=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,M=new yt(o.shape,o.dtype,C),P=new yt(s.shape,s.dtype,A);for(let F=0;F<h;++F){let B=Math.max(0,Math.ceil((k-F)/d)),U=Math.min(m.outHeight,(m.inHeight+k-F)/d);for(let W=0;W<g;++W){let K=Math.max(0,Math.ceil((T-W)/f)),j=Math.min(m.outWidth,(m.inWidth+T-W)/f);for(let V=0;V<m.inChannels;++V)for(let q=0;q<m.outChannels;++q){let ee=0;for(let Z=0;Z<m.batchSize;++Z)for(let te=B;te<U;++te){let oe=F+te*d-k;for(let ie=K;ie<j;++ie){let se=W+ie*f-T;x?ee+=M.get(Z,oe,se,V)*P.get(Z,te,ie,q):ee+=M.get(Z,V,oe,se)*P.get(Z,q,te,ie)}}y.set(ee,F,W,V,q)}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}var KR={kernelName:lc,backendName:"cpu",kernelFunc:ute};function lte(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:p}=n;ne([o,s],"conv2dBackpropInput");let c=b.computeStrides(s.shape),m=b.computeStrides(o.shape),d=I.convertConv2DDataFormat(l),f=I.computeConv2DInfo(i,s.shape,a,1,u,p,!1,d),h=new yt(f.inShape,"float32"),g=h.values,x=t.data.get(o.dataId).values,y=t.data.get(s.dataId).values,[T,k,C]=c,{batchSize:A,filterHeight:M,filterWidth:P,inChannels:F,inHeight:B,inWidth:U,outChannels:W,outHeight:K,outWidth:j,strideHeight:V,strideWidth:q}=f;d=f.dataFormat;let ee=M-1-f.padInfo.top,Z=P-1-f.padInfo.left,te=d==="channelsLast",oe=h.strides[0],ie=te?h.strides[1]:h.strides[2],se=te?h.strides[2]:1,ue=te?1:h.strides[1],ye=m[0],fe=te?m[1]:m[2],Te=te?m[2]:1,we=te?1:m[1];for(let Re=0;Re<A;++Re)for(let Le=0;Le<F;++Le)for(let Ue=0;Ue<B;++Ue){let Y=Ue-ee,gt=Math.max(0,Math.ceil(Y/V)),It=Math.min(K,(M+Y)/V);for(let Nt=0;Nt<U;++Nt){let Gt=Nt-Z,ft=Math.max(0,Math.ceil(Gt/q)),at=Math.min(j,(P+Gt)/q),Ut=0;for(let pr=gt;pr<It;++pr){let ss=pr*V-Y;for(let zr=ft;zr<at;++zr){let as=zr*q-Gt,vn=ye*Re+fe*pr+Te*zr,zn=T*(M-1-ss)+k*(P-1-as)+C*Le;for(let Gr=0;Gr<W;++Gr){let ro=x[vn+we*Gr],br=y[zn+Gr];Ut+=ro*br}}}let On=oe*Re+ie*Ue+se*Nt+ue*Le;g[On]=Ut}}return t.makeTensorInfo(h.shape,h.dtype,h.values)}var VR={kernelName:po,backendName:"cpu",kernelFunc:lte};function pte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u}=n;ne([o,s],"conv3d");let l=I.computeConv3DInfo(o.shape,s.shape,i,u,a),{filterDepth:p,filterHeight:c,filterWidth:m,dilationDepth:d,dilationHeight:f,dilationWidth:h,padInfo:g}=l,x=g.front,y=g.left,T=g.top,k=new yt(l.outShape,o.dtype),C=t.data.get(o.dataId).values,A=t.data.get(s.dataId).values,M=k.values,P=b.computeStrides(o.shape),F=b.computeStrides(s.shape);for(let B=0;B<l.batchSize;++B){let U=B*P[0],W=B*k.strides[0];for(let K=0;K<l.outDepth;++K){let j=W+K*k.strides[1],V=K*l.strideDepth-x;for(let q=0;q<p;++q){let ee=V+q*d;if(ee<0||ee>=l.inDepth)continue;let Z=q*F[0],te=U+ee*P[1];for(let oe=0;oe<l.outHeight;++oe){let ie=j+oe*k.strides[2],se=oe*l.strideHeight-T;for(let ue=0;ue<c;++ue){let ye=se+ue*f;if(ye<0||ye>=l.inHeight)continue;let fe=Z+ue*F[1],Te=te+ye*P[2];for(let we=0;we<l.outWidth;++we){let Re=ie+we*l.outChannels,Le=we*l.strideWidth-y;for(let Ue=0;Ue<m;++Ue){let Y=Le+Ue*h;if(Y<0||Y>=l.inWidth)continue;let gt=fe+Ue*F[2],It=Te+Y*l.inChannels,Nt=gt;for(let Gt=0;Gt<l.inChannels;++Gt){let ft=C[It+Gt];for(let at=0;at<l.outChannels;++at)M[Re+at]+=ft*A[Nt+at];Nt+=l.outChannels}}}}}}}}return t.makeTensorInfo(k.shape,k.dtype,k.values)}var jR={kernelName:Bu,backendName:"cpu",kernelFunc:pte};function cte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,pad:a,filterShape:u}=n;ne([o,s],"conv3dBackpropFilterV2");let l=b.computeStrides(o.shape),p=b.computeStrides(s.shape),c=I.computeConv3DInfo(o.shape,u,i,1,a),m=c.strideDepth,d=c.strideHeight,f=c.strideWidth,h=c.filterDepth,g=c.filterHeight,x=c.filterWidth,y=new yt(c.filterShape,"float32"),T=y.values,[k,C,A,M]=y.strides,P=t.data.get(s.dataId).values,[F,B,U,W]=p,K=t.data.get(o.dataId).values,[j,V,q,ee]=l,Z=c.padInfo.front,te=c.padInfo.left,oe=c.padInfo.top;for(let ie=0;ie<h;++ie){let se=Math.max(0,Math.ceil((Z-ie)/m)),ue=Math.min(c.outDepth,(c.inDepth+Z-ie)/m),ye=ie*k;for(let fe=0;fe<g;++fe){let Te=Math.max(0,Math.ceil((oe-fe)/d)),we=Math.min(c.outHeight,(c.inHeight+oe-fe)/d),Re=fe*C+ye;for(let Le=0;Le<x;++Le){let Ue=Math.max(0,Math.ceil((te-Le)/f)),Y=Math.min(c.outWidth,(c.inWidth+te-Le)/f),gt=Le*A+Re;for(let It=0;It<c.inChannels;++It){let Nt=It*M+gt;for(let Gt=0;Gt<c.outChannels;++Gt){let ft=0;for(let at=0;at<c.batchSize;++at){let Ut=at*j,On=at*F;for(let pr=se;pr<ue;++pr){let zr=(ie+pr*m-Z)*V+Ut,as=pr*B+On;for(let vn=Te;vn<we;++vn){let Gr=(fe+vn*d-oe)*q+zr,ro=vn*U+as;for(let br=Ue;br<Y;++br){let us=(Le+br*f-te)*ee+Gr,kl=br*W+ro;ft+=K[us+It]*P[kl+Gt]}}}}T[Nt+Gt]=ft}}}}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}var HR={kernelName:pc,backendName:"cpu",kernelFunc:cte};function mte(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:i,strides:a,inputShape:u}=n;ne([o],"conv3dBackpropInputV2");let l=b.computeStrides(o.shape),p=b.computeStrides(s.shape),c=I.computeConv3DInfo(u,s.shape,a,1,i),m=new yt(c.inShape,"float32"),d=m.values,[f,h,g,x]=m.strides,y=t.data.get(o.dataId).values,[T,k,C,A]=l,M=t.data.get(s.dataId).values,[P,F,B,U]=p,{batchSize:W,filterDepth:K,filterHeight:j,filterWidth:V,inChannels:q,inDepth:ee,inHeight:Z,inWidth:te,outChannels:oe,outDepth:ie,outHeight:se,outWidth:ue,strideDepth:ye,strideHeight:fe,strideWidth:Te}=c,we=K-1-c.padInfo.front,Re=j-1-c.padInfo.top,Le=V-1-c.padInfo.left;for(let Ue=0;Ue<W;++Ue)for(let Y=0;Y<q;++Y)for(let gt=0;gt<ee;++gt){let It=gt-we,Nt=Math.max(0,Math.ceil(It/ye)),Gt=Math.min(ie,(K+It)/ye);for(let ft=0;ft<Z;++ft){let at=ft-Re,Ut=Math.max(0,Math.ceil(at/fe)),On=Math.min(se,(j+at)/fe);for(let pr=0;pr<te;++pr){let ss=pr-Le,zr=Math.max(0,Math.ceil(ss/Te)),as=Math.min(ue,(V+ss)/Te),vn=0;for(let zn=Nt;zn<Gt;++zn){let Gr=zn*ye-It;for(let ro=Ut;ro<On;++ro){let br=ro*fe-at;for(let is=zr;is<as;++is){let us=is*Te-ss,kl=T*Ue+k*zn+C*ro+A*is,Zm=P*(K-1-Gr)+F*(j-1-br)+B*(V-1-us)+U*Y;for(let Gn=0;Gn<oe;++Gn){let Kp=y[kl+Gn],Jm=M[Zm+Gn];vn+=Kp*Jm}}}}d[f*Ue+h*gt+g*ft+x*pr+Y]=vn}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}var qR={kernelName:cc,backendName:"cpu",kernelFunc:mte};var dte=Ee(co,r=>Math.cos(r)),XR={kernelName:co,backendName:"cpu",kernelFunc:dte};var fte=Ee(mo,r=>Math.cosh(r)),YR={kernelName:mo,backendName:"cpu",kernelFunc:fte};function hte(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=n,[p,c,m,d]=o.shape,f=s.shape[0],[h,g]=a,x=Ce([f,h,g,d],"float32"),y=t.data.get(s.dataId).values,T=t.data.get(i.dataId).values,k=t.data.get(o.dataId).values,C=b.computeStrides(o.shape),A=b.computeStrides(x.shape);for(let M=0;M<f;M++){let P=M*4,F=y[P],B=y[P+1],U=y[P+2],W=y[P+3],K=T[M];if(K>=p)continue;let j=h>1?(U-F)*(c-1)/(h-1):0,V=g>1?(W-B)*(m-1)/(g-1):0;for(let q=0;q<h;q++){let ee=h>1?F*(c-1)+q*j:.5*(F+U)*(c-1);if(ee<0||ee>c-1){for(let Z=0;Z<g;Z++)for(let te=0;te<d;te++){let oe=te+Z*A[2]+q*A[1]+M*A[0];x.values[oe]=l}continue}if(u==="bilinear"){let Z=Math.floor(ee),te=Math.ceil(ee),oe=ee-Z;for(let ie=0;ie<g;ie++){let se=g>1?B*(m-1)+ie*V:.5*(B+W)*(m-1);if(se<0||se>m-1){for(let Te=0;Te<d;Te++){let we=Te+ie*A[2]+q*A[1]+M*A[0];x.values[we]=l}continue}let ue=Math.floor(se),ye=Math.ceil(se),fe=se-ue;for(let Te=0;Te<d;Te++){let we=Te+ue*C[2]+Z*C[1]+K*C[0],Re=k[we];we=Te+ye*C[2]+Z*C[1]+K*C[0];let Le=k[we];we=Te+ue*C[2]+te*C[1]+K*C[0];let Ue=k[we];we=Te+ye*C[2]+te*C[1]+K*C[0];let Y=k[we],gt=Re+(Le-Re)*fe,It=Ue+(Y-Ue)*fe;we=Te+ie*A[2]+q*A[1]+M*A[0],x.values[we]=gt+(It-gt)*oe}}}else for(let Z=0;Z<g;++Z){let te=g>1?B*(m-1)+Z*V:.5*(B+W)*(m-1);if(te<0||te>m-1){for(let se=0;se<d;se++){let ue=se+Z*A[2]+q*A[1]+M*A[0];x.values[ue]=l}continue}let oe=Math.round(te),ie=Math.round(ee);for(let se=0;se<d;se++){let ue=se+oe*C[2]+ie*C[1]+K*C[0],ye=se+Z*A[2]+q*A[1]+M*A[0];x.values[ye]=k[ue]}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}var QR={kernelName:ra,backendName:"cpu",kernelFunc:hte};function gte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:i,reverse:a}=n;ne(o,"cumsum");let u=I.getAxesPermutation([s],o.shape.length),l=o;u!=null&&(l=lr({inputs:{x:o},backend:t,attrs:{perm:u}}));let p=I.getInnerMostAxes(1,o.shape.length)[0];if(p!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${p}`);let c=Kt(l.dtype,"int32"),m=b.makeZerosTypedArray(b.sizeFromShape(l.shape),c),d=t.data.get(l.dataId).values,f=l.shape[l.shape.length-1],h=a?(x,y)=>x+f-y-1:(x,y)=>x+y;for(let x=0;x<d.length;x+=f)for(let y=0;y<f;y++){let T=h(x,y);if(y===0)m[T]=i?0:d[T];else{let k=h(x,y-1);m[T]=i?d[k]+m[k]:d[T]+m[k]}}let g=t.makeTensorInfo(l.shape,c,m);if(u!=null){let x=I.getUndoAxesPermutation(u),y=lr({inputs:{x:g},backend:t,attrs:{perm:x}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(l),y}return g}var ZR={kernelName:ta,backendName:"cpu",kernelFunc:gte};function bte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=_m(u,l,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=ex(u,l,i,a);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var JR={kernelName:mc,backendName:"cpu",kernelFunc:bte};function yte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n;b.assert(i==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${i}`);let a=o.shape[0],u=o.shape[1],l=o.shape[2],p=o.shape[3],c=u*s,m=l*s,d=p/(s*s),f=t.data.get(o.dataId).values,h=new Float32Array(a*c*m*d),g=0;for(let x=0;x<a;++x)for(let y=0;y<c;++y){let T=Math.floor(y/s),k=y%s;for(let C=0;C<m;++C){let A=Math.floor(C/s),M=C%s,P=(k*s+M)*d;for(let F=0;F<d;++F){let U=F+P+p*(A+l*(T+u*x));h[g++]=f[U]}}}return t.makeTensorInfo([a,c,m,d],o.dtype,h)}var eL={kernelName:na,backendName:"cpu",kernelFunc:yte};function sw(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n;ne([o,s],"depthwiseConv2DNative");let p=b.computeStrides(o.shape),c=b.computeStrides(s.shape),m=u;m==null&&(m=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(i,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${m}'`);let d=I.computeConv2DInfo(o.shape,s.shape,i,m,a,l,!0),{filterHeight:f,filterWidth:h,dilationHeight:g,dilationWidth:x,padInfo:y}=d,T=y.left,k=y.top,C=d.outChannels/d.inChannels,A=new yt(d.outShape,o.dtype),M=t.data.get(o.dataId).values,P=t.data.get(s.dataId).values,F=A.values;for(let B=0;B<d.batchSize;++B){let U=B*p[0],W=B*A.strides[0];for(let K=0;K<d.outHeight;++K){let j=W+K*A.strides[1],V=K*d.strideHeight-k;for(let q=0;q<f;++q){let ee=V+q*g;if(ee<0||ee>=d.inHeight)continue;let Z=q*c[0],te=U+ee*p[1];for(let oe=0;oe<d.outWidth;++oe){let ie=j+oe*A.strides[2],se=oe*d.strideWidth-T;for(let ue=0;ue<h;++ue){let ye=se+ue*x;if(ye<0||ye>=d.inWidth)continue;let fe=Z+ue*c[1],Te=te+ye*d.inChannels,we=ie,Re=fe;for(let Le=0;Le<d.inChannels;++Le){let Ue=M[Te+Le];for(let Y=0;Y<C;++Y)F[we+Y]+=Ue*P[Re+Y];we+=C,Re+=C}}}}}}return t.makeTensorInfo(A.shape,A.dtype,A.values)}var tL={kernelName:fo,backendName:"cpu",kernelFunc:sw};function xte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:p}=n;ne([o,s],"depthwiseConv2dNativeBackpropFilter");let c=I.computeConv2DInfo(o.shape,p,i,a,u,l,!0),{strideHeight:m,strideWidth:d,filterHeight:f,filterWidth:h}=c,g=new yt(c.filterShape,"float32"),x=c.padInfo.left,y=c.padInfo.top,T=c.outChannels/c.inChannels,k=t.data.get(o.dataId).values,C=new yt(o.shape,o.dtype,k),A=t.data.get(s.dataId).values,M=new yt(s.shape,s.dtype,A);for(let P=0;P<f;++P){let F=Math.max(0,Math.ceil((y-P)/m)),B=Math.min(c.outHeight,(c.inHeight+y-P)/m);for(let U=0;U<h;++U){let W=Math.max(0,Math.ceil((x-U)/d)),K=Math.min(c.outWidth,(c.inWidth+x-U)/d);for(let j=0;j<c.outChannels;++j){let V=Math.trunc(j/T),q=j%T,ee=0;for(let Z=0;Z<c.batchSize;++Z)for(let te=F;te<B;++te){let oe=P+te*m-y;for(let ie=W;ie<K;++ie){let se=U+ie*d-x;ee+=C.get(Z,oe,se,V)*M.get(Z,te,ie,j)}}g.set(ee,P,U,V,q)}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}var rL={kernelName:dc,backendName:"cpu",kernelFunc:xte};function Tte(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:p}=n;ne([o,s],"depthwiseConv2DNativeBackpropInput");let c=b.computeStrides(o.shape),m=b.computeStrides(s.shape),d=I.computeConv2DInfo(p,s.shape,i,a,u,l,!0),f=new yt(d.inShape,"float32"),h=f.values,[g,x,y]=f.strides,T=t.data.get(o.dataId).values,[k,C,A]=c,M=t.data.get(s.dataId).values,[P,F,B]=m,{batchSize:U,filterHeight:W,filterWidth:K,inChannels:j,inHeight:V,inWidth:q,outChannels:ee,outHeight:Z,outWidth:te,strideHeight:oe,strideWidth:ie}=d,se=W-1-d.padInfo.top,ue=K-1-d.padInfo.left,ye=ee/j;for(let fe=0;fe<U;++fe)for(let Te=0;Te<j;++Te)for(let we=0;we<V;++we){let Re=we-se,Le=Math.max(0,Math.ceil(Re/oe)),Ue=Math.min(Z,(W+Re)/oe);for(let Y=0;Y<q;++Y){let gt=Y-ue,It=Math.max(0,Math.ceil(gt/ie)),Nt=Math.min(te,(K+gt)/ie),Gt=0;for(let ft=Le;ft<Ue;++ft){let at=ft*oe-Re;for(let Ut=It;Ut<Nt;++Ut){let On=Ut*ie-gt,pr=k*fe+C*ft+A*Ut,ss=P*(W-1-at)+F*(K-1-On)+B*Te;for(let zr=0;zr<ye;++zr){let as=Te*ye+zr,vn=T[pr+as],zn=M[ss+zr];Gt+=vn*zn}}}h[g*fe+x*we+y*Y+Te]=Gt}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}var nL={kernelName:fc,backendName:"cpu",kernelFunc:Tte};function kte(r){let{inputs:e,backend:t}=r,{x:n}=e,o=b.sizeFromShape(n.shape),s=t.data.get(n.dataId).values,i=Ce([o,o],n.dtype),a=i.values;for(let l=0;l<s.length;l++)a[l*o+l]=s[l];let u=[...n.shape,...n.shape];return t.makeTensorInfo(u,i.dtype,i.values)}var oL={kernelName:hc,backendName:"cpu",kernelFunc:kte};var sL={kernelName:$u,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o}=r,{strides:s,pad:i,dilations:a}=t,u=e,l=u.data.get(n.dataId).values,p=n.shape.length,c=u.data.get(o.dataId).values,m=o.shape.length,{batchSize:d,inHeight:f,inWidth:h,inChannels:g,outHeight:x,outWidth:y,padInfo:T,strideHeight:k,strideWidth:C,filterHeight:A,filterWidth:M,dilationHeight:P,dilationWidth:F,outShape:B}=I.computeDilation2DInfo(n.shape,o.shape,s,i,"NHWC",a),U=b.sizeFromShape(B),W=B.length,K=b.getArrayFromDType(n.dtype,U);for(let V=0;V<d;++V)for(let q=0;q<x;++q){let ee=q*k-T.top;for(let Z=0;Z<y;++Z){let te=Z*C-T.left;for(let oe=0;oe<g;++oe){let ie=Number.MIN_SAFE_INTEGER;for(let ue=0;ue<A;++ue){let ye=ee+ue*P;if(ye>=0&&ye<f)for(let fe=0;fe<M;++fe){let Te=te+fe*F;if(Te>=0&&Te<h){let we=b.locToIndex([V,ye,Te,oe],p,b.computeStrides(n.shape)),Re=b.locToIndex([ue,fe,oe],m,b.computeStrides(o.shape)),Le=l[we]+c[Re];Le>ie&&(ie=Le)}}}let se=b.locToIndex([V,q,Z,oe],W,b.computeStrides(B));K[se]=ie}}}return{dataId:u.write(b.toTypedArray(K,n.dtype),B,n.dtype),shape:B,dtype:n.dtype}}};var aL={kernelName:gd,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=t,l=e,p=b.toNestedArray(n.shape,l.data.get(n.dataId).values),c=b.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:x,padInfo:y,strideHeight:T,strideWidth:k,filterHeight:C,filterWidth:A,dilationHeight:M,dilationWidth:P,outShape:F}=I.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);b.assert(s.rank===F.length,()=>`Error in ${gd}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let B=b.toNestedArray(F,l.data.get(s.dataId).values),U=b.makeZerosNestedTypedArray(o.shape,o.dtype);for(let K=0;K<m;++K)for(let j=0;j<g;++j){let V=j*T-y.top;for(let q=0;q<x;++q){let ee=q*k-y.left;for(let Z=0;Z<h;++Z){let te=Number.MIN_SAFE_INTEGER,oe=0,ie=0;for(let se=0;se<C;++se){let ue=V+se*M;if(ue>=0&&ue<d)for(let ye=0;ye<A;++ye){let fe=ee+ye*P;if(fe>=0&&fe<f){let Te=p[K][ue][fe][Z]+c[se][ye][Z];Te>te&&(te=Te,oe=se,ie=ye)}}}U[oe][ie][Z]+=B[K][j][q][Z]}}}return{dataId:l.write(b.toTypedArray(U,n.dtype),o.shape,o.dtype),shape:o.shape,dtype:o.dtype}}};var iL={kernelName:hd,backendName:"cpu",kernelFunc:({inputs:r,backend:e,attrs:t})=>{let{x:n,filter:o,dy:s}=r,{strides:i,pad:a,dilations:u}=t,l=e,p=b.toNestedArray(n.shape,l.data.get(n.dataId).values),c=b.toNestedArray(o.shape,l.data.get(o.dataId).values),{batchSize:m,inHeight:d,inWidth:f,inChannels:h,outHeight:g,outWidth:x,padInfo:y,strideHeight:T,strideWidth:k,filterHeight:C,filterWidth:A,dilationHeight:M,dilationWidth:P,outShape:F}=I.computeDilation2DInfo(n.shape,o.shape,i,a,"NHWC",u);b.assert(s.rank===F.length,()=>`Error in ${hd}, dy must have the same rank as output ${F.length}, but got ${s.rank}`);let B=b.toNestedArray(F,l.data.get(s.dataId).values),U=b.makeZerosNestedTypedArray(n.shape,n.dtype);for(let K=0;K<m;++K)for(let j=0;j<g;++j){let V=j*T-y.top;for(let q=0;q<x;++q){let ee=q*k-y.left;for(let Z=0;Z<h;++Z){let te=Number.MIN_SAFE_INTEGER,oe=V<0?0:V,ie=ee<0?0:ee;for(let se=0;se<C;++se){let ue=V+se*M;if(ue>=0&&ue<d)for(let ye=0;ye<A;++ye){let fe=ee+ye*P;if(fe>=0&&fe<f){let Te=p[K][ue][fe][Z]+c[se][ye][Z];Te>te&&(te=Te,oe=ue,ie=fe)}}}U[K][oe][ie][Z]+=B[K][j][q][Z]}}}return{dataId:l.write(b.toTypedArray(U,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function Tu(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;ne(o,"sum");let a;o.dtype==="bool"?a=qs({inputs:{x:o},backend:t,attrs:{dtype:"int32"}}):a=Qr({inputs:{x:o},backend:t});let u=a.shape.length,l=b.parseAxisParam(s,a.shape),p=I.getAxesPermutation(l,u),c=l,m=a;p!=null&&(m=lr({inputs:{x:a},backend:t,attrs:{perm:p}}),c=I.getInnerMostAxes(c.length,u)),I.assertAxesAreInnerMostDims("sum",c,m.shape.length);let[d,f]=I.computeOutAndReduceShapes(m.shape,c),h=I.upcastType(m.dtype,"int32"),g=Sm(t,d,h),x=b.sizeFromShape(f),y=t.data.get(g.dataId).values,T=t.data.get(m.dataId).values;for(let k=0;k<y.length;++k){let C=k*x,A=0;for(let M=0;M<x;++M)A+=T[C+M];y[k]=A}if(i){let k=I.expandShapeToKeepDim(g.shape,l),C=g;g=ot({inputs:{x:g},backend:t,attrs:{shape:k}}),t.disposeIntermediateTensorInfo(C)}return t.disposeIntermediateTensorInfo(a),p!=null&&t.disposeIntermediateTensorInfo(m),g}var uL={kernelName:Uo,backendName:"cpu",kernelFunc:Tu};function Ite(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:i,summedDims:a,idDims:u}=I.decodeEinsumEquation(o,s.length);I.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:p}=I.getEinsumComputePath(a,u),c=p.length,m=null,d=i.length,f=[];for(let h=0;h<c;++h){for(let g of p[h]){let{permutationIndices:x,expandDims:y}=I.getEinsumPermutation(d,u[g]),T;I.isIdentityPermutation(x)?T=s[g]:(T=lr({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),f.push(T));let k=T.shape.slice();for(let C=0;C<y.length;++C)k.splice(y[C],0,1);b.arraysEqual(T.shape,k)||(T=ot({inputs:{x:T},backend:t,attrs:{shape:k}}),f.push(T)),m===null?m=T:(m=vp({inputs:{a:T,b:m},backend:t}),f.push(m))}h<c-1&&(l[h]>=0&&(m=Tu({inputs:{x:m},backend:t,attrs:{axis:l[h]-(i.length-d),keepDims:!1}}),f.push(m)),d--)}for(let h of f)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var lL={kernelName:Ou,backendName:"cpu",kernelFunc:Ite};function Cte(r){let{inputs:e,backend:t}=r,{dy:n,y:o}=e;ne([n,o],"eluGrad");let s=new Float32Array(b.sizeFromShape(o.shape)),i=t.data.get(o.dataId).values,a=t.data.get(n.dataId).values;for(let u=0;u<i.length;++u){let l=i[u];l>=1?s[u]=a[u]:s[u]=a[u]*(l+1)}return t.makeTensorInfo(o.shape,"float32",s)}var pL={kernelName:gc,backendName:"cpu",kernelFunc:Cte};var vte=I.ERF_P,Ste=I.ERF_A1,wte=I.ERF_A2,_te=I.ERF_A3,Ate=I.ERF_A4,Nte=I.ERF_A5,Dte=Ee(Oi,r=>{let e=Math.sign(r),t=Math.abs(r),n=1/(1+vte*t);return e*(1-((((Nte*n+Ate)*n+_te)*n+wte)*n+Ste)*n*Math.exp(-t*t))}),cL={kernelName:Oi,backendName:"cpu",kernelFunc:Dte};function Fm(r){let{inputs:e,backend:t,attrs:n}=r,{input:o}=e,{dim:s}=n,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(b.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),ot({inputs:{x:o},backend:t,attrs:{shape:a}})}var mL={kernelName:hs,backendName:"cpu",kernelFunc:Fm};var Pte=tt((r,e)=>r/e),jh=it(ho,Pte),Hh={kernelName:ho,backendName:"cpu",kernelFunc:jh};function gx(r,e,t){let n=r.shape,o=n[0],s=n[1],i=t.data.get(r.dataId),a=i.complexTensorInfos.real,u=i.complexTensorInfos.imag,l=[o,s],p=b.sizeFromShape(l),c=b.getTypedArrayFromDType("float32",p),m=b.getTypedArrayFromDType("float32",p);for(let g=0;g<o;g++){let x=Ys({inputs:{x:a},backend:t,attrs:{begin:[g,0],size:[1,s]}}),y=Ys({inputs:{x:u},backend:t,attrs:{begin:[g,0],size:[1,s]}}),T=vr({inputs:{real:x,imag:y},backend:t}),{real:k,imag:C}=Mte(T,e,t),A=I.mergeRealAndImagArrays(k,C);for(let M=0;M<s;M++){let P=I.getComplexWithIndex(A,M);c[g*s+M]=P.real,m[g*s+M]=P.imag}t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(T)}let d=t.makeTensorInfo(l,"float32",c),f=t.makeTensorInfo(l,"float32",m),h=vr({inputs:{real:d,imag:f},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),h}function Mte(r,e,t){let n=b.sizeFromShape(r.shape),o=t.data.get(r.dataId),s=t.data.get(o.complexTensorInfos.real.dataId).values,i=t.data.get(o.complexTensorInfos.imag.dataId).values;if(Fte(n)){let a=aw(s,i,n,e,t),u=[r.shape[0],r.shape[1]];if(e){let l=t.makeTensorInfo(u,"float32",a.real),p=t.makeTensorInfo(u,"float32",a.imag),c=t.makeTensorInfo([],"float32",b.createScalarValue(n,"float32")),m=Qr({inputs:{x:c},backend:t}),d=Hh.kernelFunc({inputs:{a:l,b:c},backend:t}),f=Hh.kernelFunc({inputs:{a:p,b:m},backend:t}),h=t.data.get(d.dataId).values,g=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),{real:h,imag:g}}return a}else{let a=I.mergeRealAndImagArrays(s,i),u=Ete(a,n,e);return I.splitRealAndImagArrays(u)}}function Fte(r){return(r&r-1)==0}function aw(r,e,t,n,o){if(t===1)return{real:r,imag:e};let s=I.mergeRealAndImagArrays(r,e),i=t/2,a=I.complexWithEvenIndex(s),u=a.real,l=a.imag,p=[u.length],c=o.makeTensorInfo(p,"float32",u),m=o.makeTensorInfo(p,"float32",l),d=vr({inputs:{real:c,imag:m},backend:o}),f=I.complexWithOddIndex(s),h=f.real,g=f.imag,x=[h.length],y=o.makeTensorInfo(x,"float32",h),T=o.makeTensorInfo(x,"float32",g),k=vr({inputs:{real:y,imag:T},backend:o}),C=aw(u,l,i,n,o),A=C.real,M=C.imag,P=[A.length],F=o.makeTensorInfo(P,"float32",A),B=o.makeTensorInfo(P,"float32",M),U=vr({inputs:{real:F,imag:B},backend:o}),W=aw(h,g,i,n,o),K=W.real,j=W.imag,V=[K.length],q=o.makeTensorInfo(V,"float32",K),ee=o.makeTensorInfo(V,"float32",j),Z=vr({inputs:{real:q,imag:ee},backend:o}),te=I.exponents(t,n),oe=[te.real.length],ie=o.makeTensorInfo(oe,"float32",te.real),se=o.makeTensorInfo(oe,"float32",te.imag),ue=vr({inputs:{real:ie,imag:se},backend:o}),ye=vp({inputs:{a:ue,b:Z},backend:o}),fe=xu({inputs:{a:U,b:ye},backend:o}),Te=Kh({inputs:{a:U,b:ye},backend:o}),we=Hs({inputs:{input:fe},backend:o}),Re=Hs({inputs:{input:Te},backend:o}),Le=yi({inputs:{input:fe},backend:o}),Ue=yi({inputs:{input:Te},backend:o}),Y=fl({inputs:[we,Re],backend:o,attrs:{axis:0}}),gt=fl({inputs:[Le,Ue],backend:o,attrs:{axis:0}}),It=o.data.get(Y.dataId).values,Nt=o.data.get(gt.dataId).values;return o.disposeIntermediateTensorInfo(c),o.disposeIntermediateTensorInfo(m),o.disposeIntermediateTensorInfo(d),o.disposeIntermediateTensorInfo(y),o.disposeIntermediateTensorInfo(T),o.disposeIntermediateTensorInfo(k),o.disposeIntermediateTensorInfo(F),o.disposeIntermediateTensorInfo(B),o.disposeIntermediateTensorInfo(U),o.disposeIntermediateTensorInfo(q),o.disposeIntermediateTensorInfo(ee),o.disposeIntermediateTensorInfo(Z),o.disposeIntermediateTensorInfo(ie),o.disposeIntermediateTensorInfo(se),o.disposeIntermediateTensorInfo(ue),o.disposeIntermediateTensorInfo(ye),o.disposeIntermediateTensorInfo(fe),o.disposeIntermediateTensorInfo(Te),o.disposeIntermediateTensorInfo(we),o.disposeIntermediateTensorInfo(Le),o.disposeIntermediateTensorInfo(Re),o.disposeIntermediateTensorInfo(Ue),o.disposeIntermediateTensorInfo(Y),o.disposeIntermediateTensorInfo(gt),{real:It,imag:Nt}}function Ete(r,e,t){let n=new Float32Array(e*2);for(let o=0;o<e;o++){let s=0,i=0;for(let a=0;a<e;a++){let u=I.exponent(o*a,e,t),l=I.getComplexWithIndex(r,a);s+=l.real*u.real-l.imag*u.imag,i+=l.real*u.imag+l.imag*u.real}t&&(s/=e,i/=e),I.assignToTypedArray(n,s,i,o)}return n}function Rte(r){let{inputs:e,backend:t}=r,{input:n}=e,o=b.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=ot({inputs:{x:n},backend:t,attrs:{shape:[i,s]}}),u=gx(a,!1,t),l=ot({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),l}var dL={kernelName:bc,backendName:"cpu",kernelFunc:Rte};function qh(r){let{backend:e,attrs:t}=r,{shape:n,value:o,dtype:s}=t,i=s||b.inferDtype(o),a=b.getArrayFromDType(i,b.sizeFromShape(n));return Lte(a,o,i),e.makeTensorInfo(n,i,a)}var fL={kernelName:Za,backendName:"cpu",kernelFunc:qh};function Lte(r,e,t){r.fill(e)}var hL={kernelName:aa,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,o=t,s=b.getTypedArrayFromDType(n.dtype,b.sizeFromShape(n.shape)),[i,a,u,l]=n.shape,p=o.data.get(n.dataId).values;for(let m=0;m<i;m++){let d=m*u*a*l;for(let f=0;f<a;f++){let h=f*(u*l);for(let g=0;g<u;g++){let x=g*l;for(let y=0;y<l;y++){let T=Math.round(u-g-1),k=d+h+x+y,C=p[k];if(T>=0&&T<u){let A=T*l,M=d+h+A+y;C=p[M]}s[k]=C}}}}return{dataId:o.write(s,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Bte=tt((r,e)=>Math.floor(r/e)),$te=it(xo,Bte,null,"int32"),gL={kernelName:xo,backendName:"cpu",kernelFunc:$te};function Ote(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:d,leakyreluAlpha:f}=n,h=ow({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m}});if(i){let g=h;h=xu({inputs:{a:h,b:i},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){let g=h;h=Pm(t,h,d,a,f),t.disposeIntermediateTensorInfo(g)}return h}var bL={kernelName:Ns,backendName:"cpu",kernelFunc:Ote};function zte(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:d,leakyreluAlpha:f}=n,h=sw({inputs:{x:o,filter:s},backend:t,attrs:{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m}});if(i){let g=h;h=xu({inputs:{a:h,b:i},backend:t}),t.disposeIntermediateTensorInfo(g)}if(d){let g=h;h=Pm(t,h,d,a,f),t.disposeIntermediateTensorInfo(g)}return h}var yL={kernelName:Ds,backendName:"cpu",kernelFunc:zte};function Gte(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=b.sizeFromShape(n.shape),i=o.shape,a=i[i.length-1],[u,l,p,c]=I.prepareAndValidate(n,o);if(l===0)return t.makeTensorInfo(u,n.dtype,[]);let m=t.data.get(o.dataId).values,d=t.bufferSync(n),f=tx(m,d,n.dtype,l,a,p,c,n.shape,s);return t.makeTensorInfo(u,n.dtype,f.values)}var xL={kernelName:ia,backendName:"cpu",kernelFunc:Gte};function Ute(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n;ne([o,s],"gatherV2");let u=b.parseAxisParam(i,o.shape)[0],l=t.data.get(s.dataId).values,p=o.shape[u];for(let k=0;k<l.length;++k){let C=l[k];b.assert(C<=p-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${p-1}]`)}let c=a;a==null&&(c=0);let m=b.sizeFromShape(s.shape),d=I.segment_util.collectGatherOpShapeInfo(o,s,u,c),f=ot({inputs:{x:o},backend:t,attrs:{shape:[d.batchSize,d.outerSize,d.dimSize,d.sliceSize]}}),h=ot({inputs:{x:s},backend:t,attrs:{shape:[d.batchSize,m/d.batchSize]}}),g=[d.batchSize,d.outerSize,m/d.batchSize,d.sliceSize],x=t.bufferSync(h),y=t.bufferSync(f),T=rx(y,x,g);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),t.makeTensorInfo(d.outputShape,T.dtype,T.values)}var TL={kernelName:gs,backendName:"cpu",kernelFunc:Ute};function Wte(r){let{inputs:e,backend:t}=r,{input:n}=e,o=b.sizeFromShape(n.shape),s=n.shape[n.shape.length-1],i=o/s,a=ot({inputs:{x:n},backend:t,attrs:{shape:[i,s]}}),u=gx(a,!0,t),l=ot({inputs:{x:u},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(u),l}var kL={kernelName:yc,backendName:"cpu",kernelFunc:Wte};var Kte=Ee(zi,r=>Number.isFinite(r)?1:0,"bool"),IL={kernelName:zi,backendName:"cpu",kernelFunc:Kte};var Vte=Ee(Gi,r=>Math.abs(r)===1/0?1:0,"bool"),CL={kernelName:Gi,backendName:"cpu",kernelFunc:Vte};var jte=Ee(Ui,r=>Number.isNaN(r)?1:0,"bool"),vL={kernelName:Ui,backendName:"cpu",kernelFunc:jte};function Hte(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,i=nx(n,o,s);return e.makeTensorInfo([i.length],"float32",i)}var SL={kernelName:xc,backendName:"cpu",kernelFunc:Hte};var qte=Ee(Wi,r=>Math.log1p(r)),wL={kernelName:Wi,backendName:"cpu",kernelFunc:qte};var Xte=tt((r,e)=>r&&e),Yte=it(ca,Xte,null,"bool"),_L={kernelName:ca,backendName:"cpu",kernelFunc:Yte};var Qte=Ee(Ki,r=>r?0:1,"bool"),AL={kernelName:Ki,backendName:"cpu",kernelFunc:Qte};var Zte=tt((r,e)=>r||e),Jte=it(Nl,Zte,null,"bool"),NL={kernelName:Nl,backendName:"cpu",kernelFunc:Jte};function ere(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:i,alpha:a,beta:u}=n;ne(o,"LRN");let l=o.shape[3],p=l-1,c=t.data.get(o.dataId).values,m=b.sizeFromShape(o.shape),d=new Float32Array(m);function f(h){let g=h%l,x=h-g+Math.max(0,g-s),y=h-g+Math.min(g+s,p),T=0;for(;x<=y;x++){let k=c[x];T+=k*k}return T}for(let h=0;h<m;h++){let g=f(h),x=c[h]*Math.pow(i+a*g,-u);d[h]=x}return t.makeTensorInfo(o.shape,o.dtype,d)}var DL={kernelName:Gu,backendName:"cpu",kernelFunc:ere};function tre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:p}=n;ne(i,"LRNGrad");let c=b.sizeFromShape(i.shape),m=i.shape[3],d=t.data.get(i.dataId).values,f=t.data.get(o.dataId).values,h=t.data.get(s.dataId).values,g=new Float32Array(c),x=c;for(let y=0;y<x;y++){let T=y%m,k=y-T+Math.max(0,T-a),C=y-T+Math.min(m,T+a+1),A=0;for(let M=k;M<C;M++)A+=Math.pow(f[M],2);A=l*A+u;for(let M=k;M<C;M++){let P=-2*l*p*f[M]*h[y]/A;y===M&&(P+=Math.pow(A,-p)),P*=d[y],g[M]+=P}}return t.makeTensorInfo(i.shape,o.dtype,g)}var PL={kernelName:Tc,backendName:"cpu",kernelFunc:tre};function iw(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:i}=n,a=t,u=o.shape,l=u.length,p=b.parseAxisParam(s,u),c=p,m=I.getAxesPermutation(c,l),d=a.data.get(o.dataId).values;if(m!=null){let k=new Array(l);for(let C=0;C<k.length;C++)k[C]=u[m[C]];d=Am(d,u,o.dtype,m,k),c=I.getInnerMostAxes(c.length,l),u=k}ne(o,"max"),I.assertAxesAreInnerMostDims("max",c,l);let[f,h]=I.computeOutAndReduceShapes(u,c),g=b.sizeFromShape(h),x=ox(d,g,f,o.dtype),y=a.write(x,f,o.dtype),T=f;return i&&(T=I.expandShapeToKeepDim(f,p)),{dataId:y,shape:T,dtype:o.dtype}}var ML={kernelName:vo,backendName:"cpu",kernelFunc:iw};function rre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;ne(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,i,l,a,u),c;if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))c=Qr({inputs:{x:o},backend:t});else{let m=t.data.get(o.dataId).values,d=b.computeStrides(o.shape),f=Mm(m,o.shape,o.dtype,d,p,"max");c=t.makeTensorInfo(p.outShape,o.dtype,f.values)}return c}var FL={kernelName:wo,backendName:"cpu",kernelFunc:rre};function nre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n;ne(o,"maxPool3d");let p=I.computePool3DInfo(o.shape,s,i,1,a,u,l),c=t.data.get(o.dataId).values,m=hx(c,o.shape,o.dtype,b.computeStrides(o.shape),p,"max");return t.makeTensorInfo(m.shape,"float32",m.values)}var EL={kernelName:Uu,backendName:"cpu",kernelFunc:nre};function ore(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=n;ne([o,s],"maxPool3DGrad");let p=I.computePool3DInfo(s.shape,i,a,1,u,l),c=t.bufferSync(s),m=DR(c,p),d=p.strideDepth,f=p.strideHeight,h=p.strideWidth,g=p.dilationDepth,x=p.dilationHeight,y=p.dilationWidth,T=p.effectiveFilterDepth,k=p.effectiveFilterHeight,C=p.effectiveFilterWidth,A=T-1-p.padInfo.front,M=C-1-p.padInfo.left,P=k-1-p.padInfo.top,F=Ce(s.shape,"float32"),B=t.bufferSync(o);for(let U=0;U<p.batchSize;++U)for(let W=0;W<p.inChannels;++W)for(let K=0;K<p.inDepth;++K)for(let j=0;j<p.inHeight;++j)for(let V=0;V<p.inWidth;++V){let q=K-A,ee=j-P,Z=V-M,te=0;for(let oe=0;oe<T;oe+=g){let ie=(q+oe)/d;if(!(ie<0||ie>=p.outDepth||Math.floor(ie)!==ie))for(let se=0;se<k;se+=x){let ue=(ee+se)/f;if(!(ue<0||ue>=p.outHeight||Math.floor(ue)!==ue))for(let ye=0;ye<C;ye+=y){let fe=(Z+ye)/h;if(fe<0||fe>=p.outWidth||Math.floor(fe)!==fe)continue;let Te=T*k*C-1-m.get(U,ie,ue,fe,W),we=oe*k*C+se*C+ye,Re=Te===we?1:0;if(Re===0)continue;te+=B.get(U,ie,ue,fe,W)*Re}}}F.set(te,U,K,j,V,W)}return t.makeTensorInfo(F.shape,F.dtype,F.values)}var RL={kernelName:Ic,backendName:"cpu",kernelFunc:ore};function sre(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:i}=e,a=s;ne([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:c}=n,m=I.computePool2DInfo(a.shape,u,l,1,p,c),d=t.data.get(a.dataId).values,f=Ce(m.outShape,a.dtype,fx(d,a.shape,a.dtype,m).values),h=m.strideHeight,g=m.strideWidth,x=m.dilationHeight,y=m.dilationWidth,T=m.effectiveFilterHeight,k=m.effectiveFilterWidth,C=k-1-m.padInfo.left,A=T-1-m.padInfo.top,M=Ce(a.shape,"float32"),P=t.data.get(o.dataId).values,F=Ce(o.shape,"float32",P);for(let B=0;B<m.batchSize;++B)for(let U=0;U<m.inChannels;++U)for(let W=0;W<m.inHeight;++W)for(let K=0;K<m.inWidth;++K){let j=W-A,V=K-C,q=0;for(let ee=0;ee<T;ee+=x){let Z=(j+ee)/h;if(!(Z<0||Z>=m.outHeight||Math.floor(Z)!==Z))for(let te=0;te<k;te+=y){let oe=(V+te)/g;if(oe<0||oe>=m.outWidth||Math.floor(oe)!==oe)continue;let ie=T*k-1-f.get(B,Z,oe,U),se=ee*k+te,ue=ie===se?1:0;if(ue===0)continue;q+=F.get(B,Z,oe,U)*ue}}M.set(q,B,W,K,U)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}var LL={kernelName:kc,backendName:"cpu",kernelFunc:sre};function BL(r,e,t,n,o){let s=b.computeStrides(e),i=Mm(r,e,t,s,o,"max"),a=fx(r,e,t,o,!0,n);return[i.values,a.values]}var $L={kernelName:Cc,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=e,u=t;ne(n,"MaxPoolWithArgmax");let l=u.data.get(n.dataId).values,p=I.computePool2DInfo(n.shape,o,s,[1,1],i),[c,m]=BL(l,n.shape,n.dtype,a,p),d=u.write(c,p.outShape,n.dtype),f=u.write(m,p.outShape,n.dtype);return[{dataId:d,shape:p.outShape,dtype:n.dtype},{dataId:f,shape:p.outShape,dtype:"int32"}]}};function are(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=b.parseAxisParam(s,o.shape),l=I.computeOutAndReduceShapes(o.shape,a)[1],p=b.sizeFromShape(l),c=[],m=t.makeTensorInfo([],"float32",new Float32Array([p]));c.push(m);let d=qs({inputs:{x:o},backend:t,attrs:{dtype:"float32"}});c.push(d);let f=jh({inputs:{a:d,b:m},backend:t});c.push(f);let h=Tu({inputs:{x:f},backend:t,attrs:{axis:s,keepDims:i}});return c.forEach(g=>t.disposeIntermediateTensorInfo(g)),h}var OL={kernelName:_o,backendName:"cpu",kernelFunc:are};function ire(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;ne(o,"min");let a=b.parseAxisParam(s,o.shape),u=a,l=I.getAxesPermutation(u,o.shape.length),p=o;l!=null&&(p=lr({inputs:{x:o},backend:t,attrs:{perm:l}}),u=I.getInnerMostAxes(u.length,o.shape.length)),I.assertAxesAreInnerMostDims("min",u,p.shape.length);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),d=b.sizeFromShape(m),f=b.makeZerosTypedArray(b.sizeFromShape(c),p.dtype),h=t.data.get(p.dataId).values;for(let x=0;x<f.length;++x){let y=x*d,T=h[y];for(let k=0;k<d;++k){let C=h[y+k];(Number.isNaN(C)||C<T)&&(T=C)}f[x]=T}l!=null&&t.disposeIntermediateTensorInfo(p);let g=t.makeTensorInfo(c,p.dtype,f);if(i){let x=I.expandShapeToKeepDim(c,a),y=ot({inputs:{x:g},backend:t,attrs:{shape:x}});return t.disposeIntermediateTensorInfo(g),y}return g}var zL={kernelName:Ao,backendName:"cpu",kernelFunc:ire};function ure(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,mode:i}=n;ne(o,"mirrorPad");let a=s.map((T,k)=>T[0]+o.shape[k]+T[1]),u=s.map(T=>T[0]),l=s.map((T,k)=>T[0]+o.shape[k]),p=i==="reflect"?0:1,c=t.data.get(o.dataId).values,m=o.shape.length,d=b.computeStrides(o.shape),f=b.sizeFromShape(a),h=a.length,g=b.computeStrides(a),x=b.getTypedArrayFromDType(o.dtype,f);for(let T=0;T<f;T++){let k=b.indexToLoc(T,h,g);for(let A=0;A<h;A++)k[A]<u[A]?k[A]=u[A]*2-k[A]-p:k[A]>=l[A]&&(k[A]=(l[A]-1)*2-k[A]+p);k=k.map((A,M)=>A-u[M]);let C=b.locToIndex(k,m,d);x[T]=c[C]}return{dataId:t.write(x,a,o.dtype),shape:a,dtype:o.dtype}}var GL={kernelName:Do,backendName:"cpu",kernelFunc:ure};var lre=tt((r,e)=>{let t=r%e;return r<0&&e<0||r>=0&&e>=0?t:(t+e)%e}),pre=it(Vi,lre),UL={kernelName:Vi,backendName:"cpu",kernelFunc:pre};var KL=wl(Wd());function uw(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,i=o.shape.length,a=s;if(a===-1&&(a=i-1),a!==i-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${i} and dim was ${a}`);let u=b.parseAxisParam([a],o.shape),l=iw({inputs:{x:o},backend:t,attrs:{reductionIndices:u,keepDims:!1}}),p=I.expandShapeToKeepDim(l.shape,u),c=ot({inputs:{x:l},backend:t,attrs:{shape:p}}),m=Kh({inputs:{a:o,b:c},backend:t}),d=RS({inputs:{x:m},backend:t}),f=Tu({inputs:{x:d},backend:t,attrs:{axis:u,keepDims:!1}}),h=ot({inputs:{x:f},backend:t,attrs:{shape:p}}),g=jh({inputs:{a:d,b:h},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(h),g}var WL={kernelName:Wo,backendName:"cpu",kernelFunc:uw};function cre(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:i,normalized:a}=n;ne(o,"multinomial");let u=a?o:uw({inputs:{logits:o},backend:t,attrs:{dim:-1}}),l=u.shape[0],p=u.shape[1],c=t.data.get(u.dataId).values,m=[l,s],d=b.makeZerosTypedArray(b.sizeFromShape(m),"int32");for(let f=0;f<l;++f){let h=f*p,g=new Float32Array(p-1);g[0]=c[h];for(let T=1;T<g.length;++T)g[T]=g[T-1]+c[h+T];let x=KL.alea(i.toString()),y=f*s;for(let T=0;T<s;++T){let k=x();d[y+T]=g.length;for(let C=0;C<g.length;C++)if(k<g[C]){d[y+T]=C;break}}}return a||t.disposeIntermediateTensorInfo(u),t.makeTensorInfo(m,"int32",d)}var VL={kernelName:vc,backendName:"cpu",kernelFunc:cre};var mre=Tr.nonMaxSuppressionV3Impl;function dre(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n;ne(o,"NonMaxSuppression");let l=t.data.get(o.dataId).values,p=t.data.get(s.dataId).values,{selectedIndices:c}=mre(l,p,i,a,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}var jL={kernelName:da,backendName:"cpu",kernelFunc:dre};var fre=Tr.nonMaxSuppressionV4Impl;function hre(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n;ne(o,"NonMaxSuppressionPadded");let p=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,{selectedIndices:m,validOutputs:d}=fre(p,c,i,a,u,l);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}var HL={kernelName:ji,backendName:"cpu",kernelFunc:hre};var gre=Tr.nonMaxSuppressionV5Impl;function bre(r){let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n;ne(o,"NonMaxSuppressionWithScore");let p=t.data.get(o.dataId).values,c=t.data.get(s.dataId).values,m=i,d=a,f=u,h=l,{selectedIndices:g,selectedScores:x}=gre(p,c,m,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var qL={kernelName:fa,backendName:"cpu",kernelFunc:bre};function yre(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:i,offValue:a}=n;ne(o,"oneHot");let u=b.sizeFromShape(o.shape),l=new Float32Array(u*s);l.fill(a);let p=t.data.get(o.dataId).values;for(let c=0;c<u;++c)p[c]>=0&&p[c]<s&&(l[c*s+p[c]]=i);return t.makeTensorInfo([...o.shape,s],"int32",l)}var XL={kernelName:ha,backendName:"cpu",kernelFunc:yre};function Xh(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Hs({inputs:{input:n},backend:t}),s=Xh({inputs:{x:o},backend:t}),i=yi({inputs:{input:n},backend:t}),a=Xh({inputs:{x:i},backend:t}),u=vr({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return qh({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var YL={kernelName:ws,backendName:"cpu",kernelFunc:Xh};function QL(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let o=Hs({inputs:{input:n},backend:t}),s=QL({inputs:{x:o},backend:t}),i=yi({inputs:{input:n},backend:t}),a=Xh({inputs:{x:i},backend:t}),u=vr({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return qh({backend:t,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var ZL={kernelName:ys,backendName:"cpu",kernelFunc:QL};function lw(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return Fm({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=e.map(p=>{let c=Fm({inputs:{input:p},backend:t,attrs:{dim:o}});return a.push(c),c}),l=fl({inputs:u,backend:t,attrs:{axis:o}});return a.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var JL={kernelName:xs,backendName:"cpu",kernelFunc:lw};function xre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:i}=n;ne(o,"pad");let a=s.map((y,T)=>y[0]+o.shape[T]+y[1]),u=s.map(y=>y[0]),l=t.data.get(o.dataId).values,p=b.sizeFromShape(o.shape),c=o.shape.length,m=b.computeStrides(o.shape),d=b.sizeFromShape(a),f=a.length,h=b.computeStrides(a),g=b.getTypedArrayFromDType(o.dtype,d);i!==0&&g.fill(i);for(let y=0;y<p;y++){let k=b.indexToLoc(y,c,m).map((A,M)=>A+u[M]),C=b.locToIndex(k,f,h);g[C]=l[y]}return{dataId:t.write(g,a,o.dtype),shape:a,dtype:o.dtype}}var bx={kernelName:Mo,backendName:"cpu",kernelFunc:xre};var Tre=tt((r,e)=>Math.pow(r,e)),kre=it(Fo,Tre),eB={kernelName:Fo,backendName:"cpu",kernelFunc:kre};function Ire(r){let{backend:e,attrs:t}=r,{start:n,stop:o,dtype:s,step:i}=t,a=Sp(n,o,i,s);return e.makeTensorInfo([a.length],s,a)}var tB={kernelName:Ja,backendName:"cpu",kernelFunc:Ire};var Cre=Ee(Hi,r=>1/r),rB={kernelName:Hi,backendName:"cpu",kernelFunc:Cre};function vre(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n;ne(o,"resizeBilinear");let u=b.computeStrides(o.shape),[l,p]=a,[c,m,d,f]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(b.sizeFromShape([c,l,p,f])),x=[s&&l>1?m-1:m,s&&p>1?d-1:d],y=[s&&l>1?l-1:l,s&&p>1?p-1:p],T=0,k=x[0]/y[0],C=x[1]/y[1];for(let A=0;A<c;A++)for(let M=0;M<l;M++){let P;i?P=k*(M+.5)-.5:P=k*M;let F=Math.max(0,Math.floor(P)),B=P-F,U=Math.min(m-1,Math.ceil(P)),W=A*u[0]+F*u[1],K=A*u[0]+U*u[1];for(let j=0;j<p;j++){let V;i?V=C*(j+.5)-.5:V=C*j;let q=Math.max(0,Math.floor(V)),ee=V-q,Z=Math.min(d-1,Math.ceil(V)),te=W+q*u[2],oe=K+q*u[2],ie=W+Z*u[2],se=K+Z*u[2];for(let ue=0;ue<f;ue++){let ye=h[te+ue],fe=h[oe+ue],Te=h[ie+ue],we=h[se+ue],Re=ye+(Te-ye)*ee,Le=fe+(we-fe)*ee,Ue=Re+(Le-Re)*B;g[T++]=Ue}}}return t.makeTensorInfo([c,l,p,f],"float32",g)}var nB={kernelName:Lo,backendName:"cpu",kernelFunc:vre};function Sre(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:i}=n;ne([s,o],"resizeBilinearGrad");let a=b.computeStrides(o.shape),[u,l,p,c]=o.shape,[,m,d]=s.shape,f=new Float32Array(u*l*p*c),h=[i&&m>1?l-1:l,i&&d>1?p-1:p],g=[i&&m>1?m-1:m,i&&d>1?d-1:d],x=h[0]/g[0],y=h[1]/g[1],T=t.data.get(s.dataId).values,k=0;for(let C=0;C<u;C++){let A=C*a[0];for(let M=0;M<m;M++){let P=M*x,F=Math.floor(P),B=Math.min(Math.ceil(P),l-1),U=A+F*a[1],W=A+B*a[1],K=P-F,j=1-K;for(let V=0;V<d;V++){let q=V*y,ee=Math.floor(q),Z=Math.min(Math.ceil(q),p-1),te=q-ee,oe=1-te,ie=U+ee*a[2],se=U+Z*a[2],ue=W+ee*a[2],ye=W+Z*a[2],fe=j*oe,Te=j*te,we=K*oe,Re=K*te;for(let Le=0;Le<c;Le++){let Ue=T[k++];f[ie+Le]+=Ue*fe,f[se+Le]+=Ue*Te,f[ue+Le]+=Ue*we,f[ye+Le]+=Ue*Re}}}}return t.makeTensorInfo([u,p,l,c],"float32",f)}var oB={kernelName:wc,backendName:"cpu",kernelFunc:Sre};function wre(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n;ne(o,"resizeNearestNeighbor");let u=b.computeStrides(o.shape),[l,p]=a,[c,m,d,f]=o.shape,h=t.data.get(o.dataId).values,g=new Float32Array(c*l*p*f),x=[s&&l>1?m-1:m,s&&p>1?d-1:d],y=[s&&l>1?l-1:l,s&&p>1?p-1:p],T=x[0]/y[0],k=x[1]/y[1],C=0;for(let A=0;A<c;A++){let M=A*u[0];for(let P=0;P<l;P++){let F=i?T*(P+.5):T*P,B=Math.min(m-1,s?Math.round(F):Math.floor(F));i&&(B=Math.max(0,B));let U=M+B*u[1];for(let W=0;W<p;W++){let K=i?k*(W+.5):k*W,j=Math.min(d-1,s?Math.round(K):Math.floor(K));i&&(j=Math.max(0,j));let V=U+j*u[2];for(let q=0;q<f;q++){let ee=h[V+q];g[C++]=ee}}}}return t.makeTensorInfo([c,l,p,f],o.dtype,g)}var sB={kernelName:ei,backendName:"cpu",kernelFunc:wre};function _re(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:i}=n;ne([s,o],"resizeNearestNeighborGrad");let a=b.computeStrides(o.shape),u=b.computeStrides(s.shape),[l,p,c,m]=o.shape,[,d,f]=s.shape,h=new Float32Array(l*p*c*m),g=t.data.get(s.dataId).values,x=[i&&d>1?p-1:p,i&&f>1?c-1:c],y=[i&&d>1?d-1:d,i&&f>1?f-1:f],T=x[0]/y[0],k=x[1]/y[1],C=1/T,A=1/k,M=Math.ceil(C)*2+2,P=Math.ceil(A)*2+2;for(let F=0;F<l;F++){let B=F*a[0];for(let U=0;U<p;U++){let W=B+U*a[1],K=Math.floor(U*C),j=Math.floor(K-M/2);for(let V=0;V<c;V++){let q=W+V*a[2],ee=Math.floor(V*A),Z=Math.floor(ee-P/2);for(let te=0;te<m;te++){let oe=0;for(let ie=0;ie<M;ie++){let se=ie+j;if(se<0||se>=d)continue;let ue=B+se*u[1],ye=se*T,fe=Math.min(p-1,i?Math.round(ye):Math.floor(ye));if(U===fe)for(let Te=0;Te<P;Te++){let we=Te+Z;if(we<0||we>=f)continue;let Re=ue+we*u[2],Le=we*k,Ue=Math.min(c-1,i?Math.round(Le):Math.floor(Le));V===Ue&&(oe+=g[Re+te])}}h[q+te]=oe}}}}return t.makeTensorInfo(o.shape,o.dtype,h)}var aB={kernelName:Sc,backendName:"cpu",kernelFunc:_re};function Are(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n;ne(o,"reverse");let i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return Qr({inputs:{x:o},backend:t});let u=new yt(o.shape,o.dtype),l=t.bufferSync(o);for(let p=0;p<u.size;p++){let c=u.indexToLoc(p),m=c.slice();a.forEach(d=>m[d]=o.shape[d]-1-m[d]),u.set(l.get(...m),...c)}return t.makeTensorInfo(u.shape,u.dtype,u.values)}var iB={kernelName:ba,backendName:"cpu",kernelFunc:Are};var uB={kernelName:Sa,backendName:"cpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=e,a=t,u=b.getTypedArrayFromDType(n.dtype,b.sizeFromShape(n.shape)),[l,p,c,m]=n.shape,[d,f]=I.getImageCenter(i,p,c),h=255,g=Math.sin(o),x=Math.cos(o),y=a.data.get(n.dataId).values;for(let k=0;k<l;k++){let C=k*c*p*m;for(let A=0;A<p;A++){let M=A*(c*m);for(let P=0;P<c;P++){let F=P*m;for(let B=0;B<m;B++){let U=[l,A,P,B],W=U[2],K=U[1],j=(W-d)*x-(K-f)*g,V=(W-d)*g+(K-f)*x;j=Math.round(j+d),V=Math.round(V+f);let q=s;if(typeof s!="number"&&(B===3?q=h:q=s[B]),j>=0&&j<c&&V>=0&&V<p){let Z=V*(c*m),te=j*m,oe=C+Z+te+B;q=y[oe]}let ee=C+M+F+B;u[ee]=q}}}}return{dataId:a.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var Nre=Ee(ya,r=>{let e=Math.floor(r);return r-e<.5?Math.floor(r):r-e>.5?Math.ceil(r):e%2==0?e:e+1}),lB={kernelName:ya,backendName:"cpu",kernelFunc:Nre};function yx(r,e,t,n,o,s,i,a,u,l){let p=[n/o,o],c=r.values,m=e.values;if(n===0)return Ce(t,e.dtype);let d=Ce(p,e.dtype);d.values.fill(u);for(let f=0;f<s;f++){let h=[],g=0;for(let x=0;x<i;x++){let y=c[f*i+x];h.push(y),g+=y*a[x]}if(g<0||g>=n/o)throw new Error(`Invalid indices: ${h} does not index into ${t}`);for(let x=0;x<o;x++)l?d.values[g*o+x]+=m[f*o+x]:d.values[g*o+x]=e.rank===0?m[0]:m[f*o+x]}return d}function Dre(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:p,outputSize:c}=I.calculateShapes(s,o,i),m=!0,d=t.bufferSync(o),f=t.bufferSync(s),h=yx(d,f,i,c,l,u,a,p,0,m);return t.makeTensorInfo(i,h.dtype,h.values)}var pB={kernelName:xa,backendName:"cpu",kernelFunc:Dre};function Pre(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e;ne([n,o,s],"select");let i=n.shape.length,a=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=Kt(o.dtype,s.dtype),c=b.makeZerosTypedArray(b.sizeFromShape(o.shape),p),m=0,d=i===0||i>1||o.shape.length===1?1:b.sizeFromShape(o.shape.slice(1));for(let f=0;f<a.length;f++)for(let h=0;h<d;h++)a[f]===1?c[m++]=u[f]:c[m++]=l[f];return t.makeTensorInfo(o.shape,p,c)}var cB={kernelName:ks,backendName:"cpu",kernelFunc:Pre};var Mre=I.SELU_SCALEALPHA,Fre=I.SELU_SCALE,Ere=Ee(qi,r=>r>=0?Fre*r:Mre*(Math.exp(r)-1)),mB={kernelName:qi,backendName:"cpu",kernelFunc:Ere};var Rre=Ee(Xi,r=>r<0?-1:r>0?1:0),dB={kernelName:Xi,backendName:"cpu",kernelFunc:Rre};var Lre=Ee(Oo,r=>Math.sin(r)),fB={kernelName:Oo,backendName:"cpu",kernelFunc:Lre};var Bre=Ee(Ta,r=>Math.sinh(r)),hB={kernelName:Ta,backendName:"cpu",kernelFunc:Bre};var $re=11920928955078125e-23,gB=Math.log($re)+2,Ore=Ee(Yi,r=>{let e=r>-gB,t=r<gB,n=Math.exp(r),o;return t?o=n:e?o=r:o=Math.log(1+n),o}),bB={kernelName:Yi,backendName:"cpu",kernelFunc:Ore};function zre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:i}=n;ne([o],"spaceToBatchND");let a=b.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let A=1+s.length;A<o.shape.length;++A)u.push([0,0]);let l=bx.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=I.getReshaped(l.shape,s,a,!1),c=I.getPermuted(p.length,s.length,!1),m=I.getReshapedPermuted(l.shape,s,a,!1),h=ot({inputs:{x:l},backend:t,attrs:{shape:p}}),y=lr({inputs:{x:h},backend:t,attrs:{perm:c}}),C=ot({inputs:{x:y},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(y),C}var yB={kernelName:Cs,backendName:"cpu",kernelFunc:zre};function Gre(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.data.get(n.dataId).values,u=t.data.get(o.dataId).values,l=t.data.get(s.dataId).values,p=t.data.get(i.dataId).values[0],[c,m,d,f,h]=sx(a,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(m,n.dtype,c),t.makeTensorInfo([m[0]],o.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var xB={kernelName:Ku,backendName:"cpu",kernelFunc:Gre};function Ure(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.data.get(o.dataId).values),a=t.data.get(n.dataId).values,u=Array.from(t.data.get(s.dataId).values),[l,p,c]=ax(a,n.shape,n.dtype,i,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var TB={kernelName:Qi,backendName:"cpu",kernelFunc:Ure};function Wre(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=Nm(i,n.shape,n.dtype,a,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var kB={kernelName:Vu,backendName:"cpu",kernelFunc:Wre};function Kre(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(o.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");let i=t.data.get(n.dataId).values,a=t.data.get(o.dataId).values,u=t.data.get(s.dataId).values,[l,p]=Nm(i,n.shape,n.dtype,a,u);return t.makeTensorInfo(p,n.dtype,l)}var IB={kernelName:ju,backendName:"cpu",kernelFunc:Kre};function Vre(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=n,{sliceRank:u,numUpdates:l,sliceSize:p,strides:c,outputSize:m}=I.calculateShapes(s,o,a),d=!1,f=t.bufferSync(o),h=t.bufferSync(s),g=t.data.get(i.dataId).values[0],x=yx(f,h,a,m,p,l,u,c,g,d);return t.makeTensorInfo(a,x.dtype,x.values)}var CB={kernelName:Hu,backendName:"cpu",kernelFunc:Vre};function jre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:i}=n,a=b.parseAxisParam(i,o.shape)[0],u=I.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(c=>{let m=[...p];m[a]=c;let d=Ys({inputs:{x:o},backend:t,attrs:{begin:l,size:m}});return l[a]+=c,d})}var vB={kernelName:vs,backendName:"cpu",kernelFunc:jre};var SB={kernelName:ti,backendName:"cpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e;ne(t,"square");let o=n.data.get(t.dataId).values,s=new Float32Array(o.length);for(let a=0;a<o.length;++a){let u=o[a];s[a]=u*u}return{dataId:n.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};var Hre=Ee(_s,(r,e)=>{let t=e;return isNaN(r)?NaN:r>0?1:t.alpha}),wB={kernelName:_s,backendName:"cpu",kernelFunc:Hre};function qre(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n;ne(o,"stridedSlice");let{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:y,end:T,strides:k}=Tt.sliceInfo(o.shape,s,i,a,u,l,p,c,m),C;if(h)C=ot({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||x){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=Tt.computeOutShape(y,T,k),M=Ys({inputs:{x:o},backend:t,attrs:{begin:y,size:A}});C=ot({inputs:{x:M},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(M)}else{let A=t.bufferSync(o),M=ix(d,A,k,y);C=t.makeTensorInfo(f,M.dtype,M.values)}return C}var _B={kernelName:ka,backendName:"cpu",kernelFunc:qre};function Xre(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:c}=e,m=t.data.get(p.dataId).values,d=t.data.get(c.dataId).values,[f,h]=ux(m,d,o,s,i,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(c.shape,"int32",h)]}var AB={kernelName:qu,backendName:"cpu",kernelFunc:Xre};function Yre(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.data.get(s.dataId).values,u=t.data.get(i.dataId).values[0],[l,p,c]=lx(a,u,o),m=p.length;return[t.makeTensorInfo([m,2],"int32",l),t.makeTensorInfo([m],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(c))]}var NB={kernelName:_c,backendName:"cpu",kernelFunc:Yre};function Qre(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.data.get(s.dataId).values,a=px(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var DB={kernelName:Ac,backendName:"cpu",kernelFunc:Qre};var Zre=Ee(Ia,r=>Math.tan(r)),PB={kernelName:Ia,backendName:"cpu",kernelFunc:Zre};var Jre=Ee(jo,r=>Math.tanh(r)),MB={kernelName:jo,backendName:"cpu",kernelFunc:Jre};function ene(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;ne(o,"tile");let i=cx(t.bufferSync(o),s);return t.makeTensorInfo(i.shape,i.dtype,i.values)}var FB={kernelName:An,backendName:"cpu",kernelFunc:ene};function tne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:i}=n;ne(o,"topk");let a=t.data.get(o.dataId).values,[u,l]=mx(a,o.shape,o.dtype,s,i);return[t.makeTensorInfo(u.shape,u.dtype,u.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}var EB={kernelName:Ca,backendName:"cpu",kernelFunc:tne};function rne(r){let{inputs:e,attrs:t,backend:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=t,[p,c,m,d]=o.shape,[f,h]=l??[c,m],g=[p,f,h,d],x=b.computeStrides(o.shape),y=x[0],T=x[1],k=x[2],C=b.getTypedArrayFromDType(o.dtype,b.sizeFromShape(g));C.fill(u);let A=n.data.get(o.dataId).values,M=n.data.get(s.dataId).values;for(let F=0;F<p;++F){let B=s.shape[0]===1?M:M.subarray(F*8,F*8+8);for(let U=0;U<f;++U)for(let W=0;W<h;++W)for(let K=0;K<d;++K){let j,V=B[6]*W+B[7]*U+1;if(V===0)continue;let q=(B[0]*W+B[1]*U+B[2])/V,ee=(B[3]*W+B[4]*U+B[5])/V,Z=LB(q,m,a),te=LB(ee,c,a);switch(i){case"nearest":j=ine(A,c,m,y,T,k,F,te,Z,K,u);break;case"bilinear":j=une(A,c,m,y,T,k,F,te,Z,K,u);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${i}`)}let oe=F*y+U*T+W*k+K;C[oe]=j}return n.makeTensorInfo(g,o.dtype,C)}return{dataId:n.write(C,g,o.dtype),shape:o.shape,dtype:o.dtype}}var RB={kernelName:va,backendName:"cpu",kernelFunc:rne};function LB(r,e,t){switch(t){case"reflect":return nne(r,e);case"wrap":return one(r,e);case"nearest":return ane(r,e);case"constant":default:return sne(r,e)}}function nne(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{let n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return b.clamp(0,t,e-1)}function one(r,e){let t=r;if(t<0)if(e<=1)t=0;else{let n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{let n=e-1;t-=e*Math.trunc(t/n)}return b.clamp(0,t,e-1)}function sne(r,e){return r}function ane(r,e){return b.clamp(0,r,e-1)}function Yh(r,e,t,n,o,s,i,a,u,l,p){let c=i*n+a*o+u*s+l;return 0<=a&&a<e&&0<=u&&u<t?r[c]:p}function ine(r,e,t,n,o,s,i,a,u,l,p){let c=Math.round(a),m=Math.round(u);return Yh(r,e,t,n,o,s,i,c,m,l,p)}function une(r,e,t,n,o,s,i,a,u,l,p){let c=Math.floor(a),m=Math.floor(u),d=c+1,f=m+1,h=(f-u)*Yh(r,e,t,n,o,s,i,c,m,l,p)+(u-m)*Yh(r,e,t,n,o,s,i,c,f,l,p),g=(f-u)*Yh(r,e,t,n,o,s,i,d,m,l,p)+(u-m)*Yh(r,e,t,n,o,s,i,d,f,l,p);return(d-a)*h+(a-c)*g}function lne(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;ne(s,"unique");let i=n.data.get(s.dataId).values,{outputValues:a,outputShape:u,indices:l}=dx(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var BB={kernelName:Nc,backendName:"cpu",kernelFunc:lne};function pne(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape.length,a=o.shape[s],u=new Array(i-1),l=0;for(let d=0;d<i;d++)d!==s&&(u[l++]=o.shape[d]);let p=new Array(i).fill(0),c=o.shape.slice();c[s]=1;let m=new Array(a);for(let d=0;d<m.length;d++){p[s]=d;let f=Ys({inputs:{x:o},backend:t,attrs:{begin:p,size:c}});m[d]=ot({inputs:{x:f},backend:t,attrs:{shape:u}}),t.disposeIntermediateTensorInfo(f)}return m}var $B={kernelName:Ss,backendName:"cpu",kernelFunc:pne};function cne(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:i}=n;ne(o,"unsortedSegmentSum");let a=o.shape.length,u=s.shape.length,l=[],p=[],c=a-u,m=s;for(let f=0;f<c;++f){let h=Fm({inputs:{input:m},backend:t,attrs:{dim:f+1}});m=h,p.push(h)}for(let f=0;f<i;++f){let h=b.createScalarValue(f,"int32"),g=t.makeTensorInfo([],"int32",h),x=FS({inputs:{a:g,b:m},backend:t}),y=qs({inputs:{x},backend:t,attrs:{dtype:"float32"}}),T=vp({inputs:{a:y,b:o},backend:t}),k=Tu({inputs:{x:T},backend:t,attrs:{axis:0,keepDims:!1}});l.push(k),p.push(g),p.push(x),p.push(y),p.push(T),p.push(k)}let d=lw({inputs:l,backend:t,attrs:{axis:0}});return p.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}var OB={kernelName:Xu,backendName:"cpu",kernelFunc:cne};var mne=[bR,PE,yR,xR,LE,TR,kR,IR,CR,vR,SR,wR,_R,AR,NR,PR,MR,FR,ER,gR,RR,LR,BR,$R,RE,BE,OR,ME,zR,UR,KR,VR,WR,HR,qR,jR,XR,YR,QR,ZR,JR,eL,tL,rL,nL,oL,sL,iL,aL,Hh,lL,pR,pL,$E,cL,OE,mL,zE,dL,fL,hL,GE,gL,bL,yL,xL,TL,UE,WE,FE,kL,GR,IL,CL,vL,cR,KE,VE,SL,jE,wL,_L,AL,NL,DL,PL,HE,FL,EL,RL,LL,$L,ML,OL,zL,qE,GL,UL,VL,XE,YE,jL,HL,qL,QE,XL,ZL,JL,bx,eB,mR,JE,tB,EE,rB,dR,fR,hR,nB,oB,sB,aB,iB,uB,lB,eR,pB,cB,mB,rR,dB,fB,hB,nR,WL,bB,yB,xB,TB,kB,IB,CB,vB,sR,SB,aR,wB,_B,AB,NB,DB,uR,uL,PB,MB,FB,EB,ZE,RB,BB,$B,OB,YL];for(let r of mne)Zi(r);var Lm={};Xe(Lm,{assertNotComplex:()=>Oa,bindCanvasToFramebuffer:()=>Ine,bindColorTextureToFramebuffer:()=>eg,bindTextureToProgramUniformSampler:()=>Sw,bindTextureUnit:()=>WB,bindVertexBufferToProgramAttribute:()=>xx,callAndCheck:()=>Se,canBeRepresented:()=>dw,createFragmentShader:()=>hw,createFramebuffer:()=>Iw,createProgram:()=>gw,createStaticIndexBuffer:()=>xw,createStaticVertexBuffer:()=>yw,createTexture:()=>Tw,createVertexShader:()=>fw,getBatchDim:()=>Iu,getExtensionOrThrow:()=>Em,getFramebufferErrorMessage:()=>KB,getMaxTexturesInShader:()=>Aw,getNumChannels:()=>Tne,getProgramUniformLocation:()=>vw,getProgramUniformLocationOrThrow:()=>Cw,getRowsCols:()=>Cu,getShapeAs3D:()=>tg,getTextureShapeFromLogicalShape:()=>ww,getWebGLDisjointQueryTimerVersion:()=>Nw,getWebGLErrorMessage:()=>UB,getWebGLMaxTextureSize:()=>_w,hasExtension:()=>eo,isCapableOfRenderingToFloatTexture:()=>Dw,isDownloadFloatTextureEnabled:()=>Pw,isReshapeFree:()=>hl,isWebGLFenceEnabled:()=>Fw,isWebGLVersionEnabled:()=>vx,linkProgram:()=>bw,resetMaxTextureSize:()=>Cne,resetMaxTexturesInShader:()=>vne,unbindColorTextureFromFramebuffer:()=>Tx,unbindTextureUnit:()=>kne,validateFramebuffer:()=>Rm,validateProgram:()=>Jh,validateTextureSize:()=>kw});var _p={},pw={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function cw(r,e){_p[r]=e}function rs(r){if(!(r in _p)){let t=fne(r);if(t!==null)_p[r]=t;else return console.log("Could not get context for WebGL version",r),null}let e=_p[r];return e==null||e.isContextLost()?(delete _p[r],rs(r)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),_p[r])}function dne(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function fne(r){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let e=dne(r);return e.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete _p[r]},!1),r===1?e.getContext("webgl",pw)||e.getContext("experimental-webgl",pw):e.getContext("webgl2",pw)}var Ap=(t=>(t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH",t))(Ap||{}),sn=(o=>(o[o.RENDER=0]="RENDER",o[o.UPLOAD=1]="UPLOAD",o[o.PIXELS=2]="PIXELS",o[o.DOWNLOAD=3]="DOWNLOAD",o))(sn||{}),Zr=(s=>(s[s.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",s[s.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",s[s.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",s[s.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",s[s.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16",s))(Zr||{});function Np(r,e){return[e,r]}function zB(r,e){return r*e}function Qh(r){let e=b.sizeFromShape(r),t=Math.ceil(e/4);return b.sizeToSquarishShape(t)}function xi(r,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(r/2))]}function GB(r,e){let[t,n]=xi(r,e);return t*n*4}function Zh(r,e){let t=r,n,o,s,i,a,u,l,p,c,m;return $().getNumber("WEBGL_VERSION")===2?(n=t.R32F,o=t.R16F,s=t.RGBA16F,i=t.RGBA32F,a=t.RED,l=4,p=1,c=t.HALF_FLOAT,m=t.FLOAT,u=t.RGBA8):(n=r.RGBA,o=r.RGBA,s=r.RGBA,i=t.RGBA,a=r.RGBA,l=4,p=4,c=e!=null?e.HALF_FLOAT_OES:null,m=r.FLOAT,u=r.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:o,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:i,textureFormatFloat:a,downloadTextureFormat:u,downloadUnpackNumChannels:l,defaultNumChannels:p,textureTypeHalfFloat:c,textureTypeFloat:m}}function Se(r,e){let t=e();return $().getBool("DEBUG")&&hne(r),t}function hne(r){let e=r.getError();if(e!==r.NO_ERROR)throw new Error("WebGL Error: "+UB(r,e))}var gne=596e-10,bne=65504;function dw(r){return!!($().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||gne<Math.abs(r)&&Math.abs(r)<bne)}function UB(r,e){switch(e){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Em(r,e){return ku(r,()=>r.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function fw(r,e){let t=ku(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Se(r,()=>r.shaderSource(t,e)),Se(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function hw(r,e){let t=ku(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Se(r,()=>r.shaderSource(t,e)),Se(r,()=>r.compileShader(t)),r.getShaderParameter(t,r.COMPILE_STATUS)===!1)throw xne(e,r.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}var yne=/ERROR: [0-9]+:([0-9]+):/g;function xne(r,e){let t=yne.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(r);return}let n=+t[1],o=r.split(`
`),s=o.length.toString().length+2,i=o.map((c,m)=>b.rightPad((m+1).toString(),s)+c),a=0;for(let c=0;c<i.length;c++)a=Math.max(i[c].length,a);let u=i.slice(0,n-1),l=i.slice(n-1,n),p=i.slice(n);console.log(u.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${b.rightPad(l[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(p.join(`
`))}function gw(r){return ku(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function bw(r,e){if(Se(r,()=>r.linkProgram(e)),r.getProgramParameter(e,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function Jh(r,e){if(Se(r,()=>r.validateProgram(e)),r.getProgramParameter(e,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function yw(r,e){let t=ku(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Se(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),Se(r,()=>r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function xw(r,e){let t=ku(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return Se(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,t)),Se(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,e,r.STATIC_DRAW)),t}function Tne(){return $().getNumber("WEBGL_VERSION")===2?1:4}function Tw(r){return ku(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function kw(r,e){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||e<=0){let n=`[${r}x${e}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>t||e>t){let n=`[${r}x${e}]`,o=`[${t}x${t}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+o+".")}}function Iw(r){return ku(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function xx(r,e,t,n,o,s,i){let a=r.getAttribLocation(e,t);return a===-1?!1:(Se(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),Se(r,()=>r.vertexAttribPointer(a,o,r.FLOAT,!1,s,i)),Se(r,()=>r.enableVertexAttribArray(a)),!0)}function WB(r,e,t){VB(r,t),Se(r,()=>r.activeTexture(r.TEXTURE0+t)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,e))}function kne(r,e){VB(r,e),Se(r,()=>r.activeTexture(r.TEXTURE0+e)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function Cw(r,e,t){return ku(r,()=>r.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function vw(r,e,t){return r.getUniformLocation(e,t)}function Sw(r,e,t,n){Se(r,()=>WB(r,e,n)),Se(r,()=>r.uniform1i(t,n))}function Ine(r){Se(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,null)),Se(r,()=>r.viewport(0,0,r.canvas.width,r.canvas.height)),Se(r,()=>r.scissor(0,0,r.canvas.width,r.canvas.height))}function eg(r,e,t){Se(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),Se(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0))}function Tx(r,e){Se(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),Se(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function Rm(r){let e=r.checkFramebufferStatus(r.FRAMEBUFFER);if(e!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+KB(r,e))}function KB(r,e){switch(e){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function ku(r,e,t){let n=Se(r,()=>e());if(n==null)throw new Error(t);return n}function VB(r,e){let t=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+r.TEXTURE0;if(n<r.TEXTURE0||n>t){let o=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${o}.`)}}function Iu(r,e=2){return b.sizeFromShape(r.slice(0,r.length-e))}function Cu(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function tg(r){let e=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(e=[Iu(r),...Cu(r)]),e}function ww(r,e=!1){let t=$().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,r=r.map((o,s)=>s>=r.length-2?b.nearestLargerEven(r[s]):r[s]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=b.squeezeShape(r).newShape);let n=b.sizeFromShape(r);if(r.length<=1&&n<=t)return[1,n];if(r.length===2&&r[0]<=t&&r[1]<=t)return r;if(r.length===3&&r[0]*r[1]<=t&&r[2]<=t)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=t&&r[1]*r[2]<=t)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=t&&r[3]<=t)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=t&&r[1]*r[2]*r[3]<=t)return[r[0],r[1]*r[2]*r[3]];if(e){let o=Iu(r),s=2,i=2;return r.length&&([s,i]=Cu(r)),n=o*(s/2)*(i/2),b.sizeToSquarishShape(n).map(a=>a*2)}return b.sizeToSquarishShape(n)}function kx(r){return r%2==0}function hl(r,e){if(r=r.slice(-2),e=e.slice(-2),b.arraysEqual(r,e)||!r.length||!e.length||r[0]===0||r[1]===0||e[0]===0||e[1]===0)return!0;if(r.length!==e.length){let t=r.slice(-1)[0],n=e.slice(-1)[0];if(t===n||kx(t)&&kx(n)&&(r[0]===1||e[0]===1))return!0}return r[1]===e[1]&&kx(r[0])&&kx(e[0])}var Ix,Cx;function _w(r){if(Ix==null){let e=rs(r);Ix=e.getParameter(e.MAX_TEXTURE_SIZE)}return Ix}function Cne(){Ix=null}function vne(){Cx=null}function Aw(r){if(Cx==null){let e=rs(r);Cx=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Cx)}function Nw(r){if(r===0)return 0;let e,t=rs(r);return eo(t,"EXT_disjoint_timer_query_webgl2")&&r===2?e=2:eo(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function eo(r,e){return r.getExtension(e)!=null}function vx(r){try{if(rs(r)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function Dw(r){if(r===0)return!1;let e=rs(r);if(r===1){if(!eo(e,"OES_texture_float"))return!1}else if(!eo(e,"EXT_color_buffer_float"))return!1;return Mw(e)}function Pw(r){if(r===0)return!1;let e=rs(r);if(r===1){if(!eo(e,"OES_texture_float")||!eo(e,"WEBGL_color_buffer_float"))return!1}else{if(eo(e,"EXT_color_buffer_float"))return Mw(e);let n="EXT_color_buffer_half_float";if(eo(e,n)){let o=e.getExtension(n);return Sne(e,o)}return!1}return Mw(e)}function Mw(r){let e=Zh(r),t=r.createTexture();r.bindTexture(r.TEXTURE_2D,t);let n=1,o=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatFloat,n,o,0,e.textureFormatFloat,e.textureTypeFloat,null);let s=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,s),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0);let i=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(t),r.deleteFramebuffer(s),i}function Sne(r,e){let t=Zh(r,e),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let o=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatHalfFloat,o,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);let i=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,i),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(i),a}function Fw(r){return r!==2?!1:rs(r).fenceSync!=null}function Oa(r,e){Array.isArray(r)||(r=[r]),r.forEach(t=>{t!=null&&b.assert(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}var $e=$();$e.registerFlag("HAS_WEBGL",()=>$e.getNumber("WEBGL_VERSION")>0);$e.registerFlag("WEBGL_VERSION",()=>vx(2)?2:vx(1)?1:0);$e.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);$e.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>$e.get("WEBGL_VERSION")===2);$e.registerFlag("WEBGL_CPU_FORWARD",()=>!0);$e.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);$e.registerFlag("WEBGL_PACK",()=>$e.getBool("HAS_WEBGL"));$e.registerFlag("WEBGL_PACK_NORMALIZATION",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_PACK_CLIP",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_PACK_REDUCE",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_LAZILY_UNPACK",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_CONV_IM2COL",()=>$e.getBool("WEBGL_PACK"));$e.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>_w($e.getNumber("WEBGL_VERSION")));$e.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Aw($e.getNumber("WEBGL_VERSION")));$e.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=$e.getNumber("WEBGL_VERSION");return r===0?0:Nw(r)});$e.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>$e.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!oi.isMobile());$e.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Dw($e.getNumber("WEBGL_VERSION")));$e.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>$e.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:$e.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));$e.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>Pw($e.getNumber("WEBGL_VERSION")));$e.registerFlag("WEBGL_FENCE_API_ENABLED",()=>Fw($e.getNumber("WEBGL_VERSION")));$e.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>$e.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);$e.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});$e.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>oi.isMobile()?1:-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${r}.`)});$e.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);$e.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);$e.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);$e.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);function Qt(){let r,e,t,n,o,s,i,a,u,l;return $().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",e="in",t="out",n="in",o="texture",s="outputColor",i="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",e="attribute",t="varying",n="varying",o="texture2D",s="gl_FragColor",i="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:e,varyingVs:t,varyingFs:n,texture2D:o,output:s,defineOutput:i,defineSpecialNaN:a,defineSpecialInf:u,defineRound:l}}function za(r,e,t="index"){let n=b.computeStrides(e);return n.map((o,s)=>{let i=`int ${r[s]} = ${t} / ${o}`,a=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * ${o}`:`index -= ${r[s]} * ${o}`;return`${i}; ${a};`}).join("")}function Dp(r,e,t="index"){let n=b.computeStrides(e);return n.map((o,s)=>{let i=`int ${r[s]} = ${t} / outShapeStrides[${s}]`,a=s===n.length-1?`int ${r[s+1]} = ${t} - ${r[s]} * outShapeStrides[${s}]`:`index -= ${r[s]} * outShapeStrides[${s}]`;return`${i}; ${a};`}).join("")}function wne(r,e){let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function jB(r,e,t="index"){let n=r.map((s,i)=>i),o=wne(n,e);return o.map((s,i)=>{let a=`int ${r[i]} = ${t} / ${o[i]}`,u=i===o.length-1?`int ${r[i+1]} = ${t} - ${r[i]} * ${o[i]}`:`index -= ${r[i]} * ${o[i]}`;return`${a}; ${u};`}).join("")}function Bm(r){let e=b.computeStrides(r).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function $m(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}var Sx=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var{getBroadcastDims:HB}=I;function qB(r,e,t){let n=[];if(r.forEach(d=>{let f=b.sizeFromShape(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?n.push(`uniform float ${d.name}${f>1?`[${f}]`:""};`):(n.push(`uniform sampler2D ${d.name};`),n.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){let{uniformShape:h}=wx(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(h.length){case 1:n.push(`uniform int ${d.name}Shape;`);break;case 2:n.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:n.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:n.push(`uniform ivec4 ${d.name}Shape;`);break;default:break}n.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break;default:break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{n.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});let o=n.join(`
`),s=r.map(d=>_ne(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),i=e.texShape,a=Qt(),u=Dne(a),l,p,c=Fne(a);return e.isPacked?(l=Ane(e.logicalShape,i,t.enableShapeUniforms),p=Mne(a)):(l=Nne(e.logicalShape,i,t.enableShapeUniforms),p=Pne(a)),t.packedInputs&&(c+=Bne),[c,u,p,o,l,s,t.userCode].join(`
`)}function zm(r,e=!1){let t=r.shapeInfo.logicalShape;switch(t.length){case 0:return Xne(r,e);case 1:return Qne(r,e);case 2:return Jne(r,e);case 3:return toe(r,e);case 4:return noe(r,e);case 5:return ooe(r);case 6:return soe(r);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function XB(r,e){switch(r.shapeInfo.logicalShape.length){case 0:return qne(r);case 1:return Yne(r,e);case 2:return Zne(r,e);case 3:return eoe(r,e);default:return roe(r,e)}}function _ne(r,e,t=!1,n){let o="";t?o+=XB(r,n):o+=zm(r,n);let s=r.shapeInfo.logicalShape,i=e.logicalShape;return s.length<=i.length&&(t?o+=aoe(r,e):o+=ioe(r,e)),o}function Ane(r,e,t){switch(r.length){case 0:return YB();case 1:return $ne(r,e,t);case 2:return jne(r,e,t);case 3:return zne(r,e,t);default:return Une(r,e,t)}}function Nne(r,e,t){switch(r.length){case 0:return YB();case 1:return One(r,e,t);case 2:return Hne(r,e,t);case 3:return Gne(r,e,t);case 4:return Wne(r,e,t);case 5:return Kne(r,e);case 6:return Vne(r,e);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function Dne(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function Pne(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function Mne(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function Fne(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${Ene}
    ${Rne}
    ${Lne}
  `}var Ene=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Rne=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Lne=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,Bne=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function YB(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function $ne(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${n[1]}.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${n[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      return 2 * (resTexRC.x * ${n[1]} + resTexRC.y);
    }
  `}function One(r,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function zne(r,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[2]/2),s=o*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec3(b, r, c);
    }
  `}function Gne(r,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Dp(["r","c","d"],r)}
    return ivec3(r, c, d);
  }
`;let n=za(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec3(r, c, d);
    }
  `}function Une(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],o=Math.ceil(r[r.length-1]/2),s=o*Math.ceil(r[r.length-2]/2),i=s,a="",u="b, r, c";for(let l=2;l<r.length-1;l++)i*=r[r.length-l-1],a=`
      int b${l} = index / ${i};
      index -= b${l} * ${i};
    `+a,u=`b${l}, `+u;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));
      int index = resTexRC.x * ${n[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec${r.length}(${u});
    }
  `}function Wne(r,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Dp(["r","c","d","d2"],r)}
      return ivec4(r, c, d, d2);
    }
  `;let n=za(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${n}
      return ivec4(r, c, d, d2);
    }
  `}function Kne(r,e){let t=za(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Vne(r,e){let t=za(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function jne(r,e,t){let n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(b.arraysEqual(r,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${n[0]}, ${n[1]}));
      }
    `;let o=Math.ceil(r[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${n[0]}, ${n[1]}));

      int index = resTexRC.x * ${n[1]} + resTexRC.y;
      int r = 2 * (index / ${o});
      int c = imod(index, ${o}) * 2;

      return ivec2(r, c);
    }
  `}function Hne(r,e,t){return b.arraysEqual(r,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:r[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Pp(r){return`offset${r}`}function qne(r){let e=r.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=Qt();return`
    vec4 ${t}() {
      return ${n.texture2D}(${e}, halfCR);
    }
  `}function Xne(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`float ${n}() {return ${t};}`;let[o,s]=r.shapeInfo.texShape;if(o===1&&s===1)return`
      float ${n}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let i=Pp(t);if(e)return`
    float ${n}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${i});
      return sampleTexture(${t}, uv);
    }
  `;let[a,u]=r.shapeInfo.texShape;return`
    float ${n}() {
      vec2 uv = uvFromFlat(${a}, ${u}, ${i});
      return sampleTexture(${t}, uv);
    }
  `}function Yne(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=r.shapeInfo.texShape,s=Qt();if(e)return`
    vec4 ${n}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;let i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)];return`
    vec4 ${n}(int index) {
      vec2 uv = packedUVfrom1D(
        ${i[0]}, ${i[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function Qne(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`
      float ${n}(int index) {
        ${Gm(r)}
      }
    `;let o=r.shapeInfo.texShape,s=o[0],i=o[1];if(i===1&&s===1)return`
      float ${n}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Pp(t);return i===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${n}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${i}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${n}(int index) {
      vec2 uv = uvFromFlat(${s}, ${i}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function Zne(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=s[0],a=s[1],u=Qt();if(s!=null&&b.arraysEqual(t,s))return e?`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);

        return ${u.texture2D}(${n}, uv);
      }
    `:`
      vec4 ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${i}.0);

        return ${u.texture2D}(${n}, uv);
      }
    `;if(e)return`
    vec4 ${o}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `;let l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(t[1]/2);return`
    vec4 ${o}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p}, ${l[0]}, ${l[1]}, row, col);
      return ${u.texture2D}(${n}, uv);
    }
  `}function Jne(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape;if(s!=null&&b.arraysEqual(t,s)){if(e)return`
      float ${o}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `;let m=s[0],d=s[1];return`
    float ${o}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${m}.0);
      return sampleTexture(${n}, uv);
    }
  `}let{newShape:i,keptDims:a}=b.squeezeShape(t),u=i;if(u.length<t.length){let m=Um(r,u),d=["row","col"];return`
      ${zm(m,e)}
      float ${o}(int row, int col) {
        return ${o}(${Wm(d,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Gm(r)}
      }
    `;let l=s[0],p=s[1],c=Pp(n);return p===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${n}, uv);
    }
  `:l===1?e?`
      float ${o}(int row, int col) {
        float index = dot(vec3(row, col, ${c}), vec3(${n}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col) {
      float index = dot(vec3(row, col, ${c}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
      return sampleTexture(${n}, uv);
    }
  `:e?`
      float ${o}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${n}Shape[1] + col + ${c};
        vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
        return sampleTexture(${n}, uv);
      }
    `:`
  float ${o}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${c};
    vec2 uv = uvFromFlat(${l}, ${p}, index);
    return sampleTexture(${n}, uv);
  }
`}function eoe(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=r.shapeInfo.texShape,i=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let m=t.slice(1),d=[1,2],f=Um(r,m),h=["b","row","col"];return`
        ${XB(f,e)}
        vec4 ${o}(int b, int row, int col) {
          return ${o}(${Wm(h,d)});
        }
      `}let a=Qt();if(e)return`
    vec4 ${o}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${n}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `;let u=i[0],l=i[1],p=Math.ceil(t[2]/2),c=p*Math.ceil(t[1]/2);return`
    vec4 ${o}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${u}, ${l}, ${c}, ${p}, b, row, col);
      return ${a.texture2D}(${n}, uv);
    }
  `}function toe(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[1]*t[2],i=t[2],{newShape:a,keptDims:u}=b.squeezeShape(t),l=a;if(l.length<t.length){let h=Um(r,l),g=["row","col","depth"];return`
        ${zm(h,e)}
        float ${o}(int row, int col, int depth) {
          return ${o}(${Wm(g,u)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${i}, 1)));
        ${Gm(r)}
      }
    `;let p=r.shapeInfo.texShape,c=p[0],m=p[1],d=r.shapeInfo.flatOffset;if(m===s&&d==null)return e?`
      float ${o}(int row, int col, int depth) {
        int stride1 = ${n}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
        float ${o}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${i}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${c}.0);
          return sampleTexture(${n}, uv);
        }
      `;if(m===i&&d==null)return e?`
      float ${o}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${n}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
    float ${o}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${c}.0);
      return sampleTexture(${n}, uv);
    }
  `;let f=Pp(n);return e?`
    float ${o}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${n}Shape[1] * ${n}Shape[2];
      int stride1 = ${n}Shape[2];
      int index = row * ${s} + col * ${i} + depth + ${f};
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index);
      return sampleTexture(${n}, uv);
    }
    `:`
      float ${o}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${i} + depth + ${f};
        vec2 uv = uvFromFlat(${c}, ${m}, index);
        return sampleTexture(${n}, uv);
      }
  `}function roe(r,e){let t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=Qt();if(e)return`
    vec4 ${n}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${o.texture2D}(${t}, uv);
    }
  `;let s=r.shapeInfo.logicalShape,i=s.length,a=r.shapeInfo.texShape,u=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],l=u[0],p=u[1],c=Math.ceil(s[i-1]/2),m=c*Math.ceil(s[i-2]/2),d="int b, int row, int col",f=`b * ${m} + (row / 2) * ${c} + (col / 2)`;for(let h=2;h<i-1;h++)d=`int b${h}, `+d,m*=s[i-h-1],f=`b${h} * ${m} + `+f;return`
    vec4 ${n}(${d}) {
      int index = ${f};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});
      return ${o.texture2D}(${t}, uv);
    }
  `}function noe(r,e){let t=r.shapeInfo.logicalShape,n=r.name,o="get"+n.charAt(0).toUpperCase()+n.slice(1),s=t[3],i=t[2]*s,a=t[1]*i,{newShape:u,keptDims:l}=b.squeezeShape(t);if(u.length<t.length){let y=Um(r,u),T=["row","col","depth","depth2"];return`
      ${zm(y,e)}
      float ${o}(int row, int col, int depth, int depth2) {
        return ${o}(${Wm(T,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${o}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${i}, ${s}, 1)));
        ${Gm(r)}
      }
    `;let p=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,m=c[0],d=c[1],f=`int stride2 = ${n}Shape[3];`,h=`int stride1 = ${n}Shape[2] * stride2;`,g=`int stride0 = ${n}Shape[1] * stride1;`;if(d===a&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        ${f}
        ${h}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${i}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(d===s&&p==null)return e?`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n}Shape[1] * ${n}Shape[2], ${n}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${n}TexShape[1], ${n}TexShape[0]);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${o}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${m}.0);
        return sampleTexture(${n}, uv);
      }
    `;let x=Pp(n);return e?`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${h}
      ${g}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${x});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${o}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${d}, index + ${x});
      return sampleTexture(${n}, uv);
    }
  `}function ooe(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),o=e[4],s=e[3]*o,i=e[2]*s,a=e[1]*i,{newShape:u,keptDims:l}=b.squeezeShape(e);if(u.length<e.length){let h=Um(r,u),g=["row","col","depth","depth2","depth3"];return`
      ${zm(h)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Wm(g,l)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${i}, ${s}, ${o})) +
          depth3;
        ${Gm(r)}
      }
    `;let p=r.shapeInfo.flatOffset,c=r.shapeInfo.texShape,m=c[0],d=c[1];if(d===a&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${i}, ${s}, ${o}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(d===o&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${m}.0);
        return sampleTexture(${t}, uv);
      }
    `;let f=Pp(t);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${i} + depth * ${s} +
          depth2 * ${o} + depth3 + ${f};
      vec2 uv = uvFromFlat(${m}, ${d}, index);
      return sampleTexture(${t}, uv);
    }
  `}function soe(r){let e=r.shapeInfo.logicalShape,t=r.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:o,keptDims:s}=b.squeezeShape(e);if(o.length<e.length){let g=Um(r,o),x=["row","col","depth","depth2","depth3","depth4"];return`
      ${zm(g)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Wm(x,s)});
      }
    `}let i=e[5],a=e[4]*i,u=e[3]*a,l=e[2]*u,p=e[1]*l;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${p}, ${l}, ${u}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${i}, 1)));
        ${Gm(r)}
      }
    `;let c=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,d=m[0],f=m[1];if(f===p&&c==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${u}, ${a}, ${i})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===i&&c==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;let h=Pp(t);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${p} + col * ${l} + depth * ${u} +
          depth2 * ${a} + depth3 * ${i} + depth4 + ${h};
      vec2 uv = uvFromFlat(${d}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Gm(r){let e=r.name,t=b.sizeFromShape(r.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function aoe(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=r.shapeInfo.logicalShape.length,i=e.logicalShape.length,a=HB(r.shapeInfo.logicalShape,e.logicalShape),u=je(i),l=i-s,p,c=["x","y","z","w","u","v"];s===0?p="":i<2&&a.length>=1?p="coords = 0;":p=a.map(y=>`coords.${c[y+l]} = 0;`).join(`
`);let m="";i<2&&s>0?m="coords":m=r.shapeInfo.logicalShape.map((y,T)=>`coords.${c[T+l]}`).join(", ");let d="return outputValue;",h=b.sizeFromShape(r.shapeInfo.logicalShape)===1,x=b.sizeFromShape(e.logicalShape)===1;if(s===1&&!h&&!x)d=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(h&&!x)i===1?d=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:d=`
        return vec4(outputValue.x);
      `;else if(a.length){let y=s-2,T=s-1;a.indexOf(y)>-1&&a.indexOf(T)>-1?d="return vec4(outputValue.x);":a.indexOf(y)>-1?d="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(T)>-1&&(d="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${o}() {
      ${u} coords = getOutputCoords();
      ${p}
      vec4 outputValue = get${n}(${m});
      ${d}
    }
  `}function ioe(r,e){let t=r.name,n=t.charAt(0).toUpperCase()+t.slice(1),o="get"+n+"AtOutCoords",s=e.texShape,i=r.shapeInfo.texShape,a=r.shapeInfo.logicalShape.length,u=e.logicalShape.length;if(!r.shapeInfo.isUniform&&a===u&&r.shapeInfo.flatOffset==null&&b.arraysEqual(i,s))return`
      float ${o}() {
        return sampleTexture(${t}, resultUV);
      }
    `;let l=je(u),p=HB(r.shapeInfo.logicalShape,e.logicalShape),c=u-a,m,d=["x","y","z","w","u","v"];a===0?m="":u<2&&p.length>=1?m="coords = 0;":m=p.map(h=>`coords.${d[h+c]} = 0;`).join(`
`);let f="";return u<2&&a>0?f="coords":f=r.shapeInfo.logicalShape.map((h,g)=>`coords.${d[g+c]}`).join(", "),`
    float ${o}() {
      ${l} coords = getOutputCoords();
      ${m}
      return get${n}(${f});
    }
  `}function je(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function wx(r,e,t){let{newShape:n,keptDims:o}=b.squeezeShape(e),s=e.length,i=r&&s===3&&e[0]===1,a=i?e.slice(1):n,u=!r&&s>1&&!b.arraysEqual(e,t)&&n.length<s||i;return{useSqueezeShape:u,uniformShape:u?a:e,keptDims:o}}function Um(r,e){let t=JSON.parse(JSON.stringify(r));return t.shapeInfo.logicalShape=e,t}function Wm(r,e){return e.map(t=>r[t]).join(", ")}function QB(r,e,t,n){let o=t.map((k,C)=>{let A={logicalShape:k.shape,texShape:k.isUniform?null:k.texData.texShape,isUniform:k.isUniform,isPacked:k.isUniform?!1:k.texData.isPacked,flatOffset:null};return k.texData!=null&&k.texData.slice!=null&&k.texData.slice.flatOffset>0&&(A.flatOffset=k.texData.slice.flatOffset),{name:e.variableNames[C],shapeInfo:A}}),s=o.map(k=>k.shapeInfo),i={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},a=qB(o,i,e),u=hw(r.gl,a),l=r.createProgram(u),p=null,c=r.getUniformLocation(l,"NAN",!1);$().getNumber("WEBGL_VERSION")===1&&(p=r.getUniformLocation(l,"INFINITY",!1));let m=!1,d={},f={},h={};for(let k=0;k<e.variableNames.length;k++){let C=e.variableNames[k];d[C]=r.getUniformLocation(l,C,m),d[`offset${C}`]=r.getUniformLocation(l,`offset${C}`,m),e.enableShapeUniforms&&(f[`${C}Shape`]=r.getUniformLocation(l,`${C}Shape`,m),h[`${C}TexShape`]=r.getUniformLocation(l,`${C}TexShape`,m))}let g,x,y;e.enableShapeUniforms&&(g=r.getUniformLocation(l,"outShape",m),y=r.getUniformLocation(l,"outShapeStrides",m),x=r.getUniformLocation(l,"outTexShape",m));let T=[];return e.customUniforms&&e.customUniforms.forEach((k,C)=>{T[C]=r.getUniformLocation(l,k.name,m)}),{program:e,fragmentShader:u,source:a,webGLProgram:l,uniformLocations:d,customUniformLocations:T,inShapeInfos:s,outShapeInfo:i,infLoc:p,nanLoc:c,inShapesLocations:f,inTexShapesLocations:h,outShapeLocation:g,outShapeStridesLocation:y,outTexShapeLocation:x}}function ZB(r,e){if(r.length!==e.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${e.length} inputs`);r.forEach((t,n)=>{let o=t.logicalShape,s=e[n],i=s.shape;if(!b.arraysEqual(o,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${o} and ${i} must match`);if(t.isUniform&&s.isUniform)return;let a=t.texShape,u=s.isUniform?null:s.texData.texShape;if(!b.arraysEqual(a,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${u} must match`)})}function JB(r,e,t,n,o){e.program.enableShapeUniforms||(ZB(e.inShapeInfos,t),ZB([e.outShapeInfo],[n]));let s=n.texData.texture,i=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(s,i[0],i[1]):r.setOutputMatrixTexture(s,i[0],i[1]),r.setProgram(e.webGLProgram),$().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&r.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&r.gl.uniform1f(e.nanLoc,NaN),t.forEach((u,l)=>{let p=e.program.variableNames[l],c=e.uniformLocations[p],m=e.uniformLocations[`offset${p}`],d=e.inShapesLocations[`${p}Shape`],f=e.inTexShapesLocations[`${p}TexShape`];if(d){let{uniformShape:h}=wx(e.program.packedInputs,u.shape,u.texData.texShape);switch(h.length){case 1:r.gl.uniform1iv(d,new Int32Array(h));break;case 2:r.gl.uniform2iv(d,new Int32Array(h));break;case 3:r.gl.uniform3iv(d,new Int32Array(h));break;case 4:r.gl.uniform4iv(d,new Int32Array(h));break;default:break}}if(f&&r.gl.uniform2i(f,u.texData.texShape[0],u.texData.texShape[1]),c!=null){if(u.isUniform){if(b.sizeFromShape(u.shape)<2)r.gl.uniform1f(c,u.uniformValues[0]);else{let h=u.uniformValues;h instanceof Float32Array||(h=new Float32Array(h)),r.gl.uniform1fv(c,h)}return}u.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,u.texData.slice.flatOffset),r.setInputMatrixTexture(u.texData.texture,c,l)}});let a=e.outShapeLocation;if(a)switch(n.shape.length){case 1:r.gl.uniform1iv(a,new Int32Array(n.shape));break;case 2:r.gl.uniform2iv(a,new Int32Array(n.shape));break;case 3:r.gl.uniform3iv(a,new Int32Array(n.shape));break;case 4:r.gl.uniform4iv(a,new Int32Array(n.shape));break;default:break}if(e.outShapeStridesLocation){let u=b.computeStrides(n.shape);switch(n.shape.length){case 2:r.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(u));break;case 3:r.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(u));break;case 4:r.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(u));break;default:break}}e.outTexShapeLocation&&r.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&o&&e.program.customUniforms.forEach((u,l)=>{let p=e.customUniformLocations[l],c=o[l];if(u.type==="float")r.gl.uniform1fv(p,c);else if(u.type==="vec2")r.gl.uniform2fv(p,c);else if(u.type==="vec3")r.gl.uniform3fv(p,c);else if(u.type==="vec4")r.gl.uniform4fv(p,c);else if(u.type==="int")r.gl.uniform1iv(p,c);else if(u.type==="ivec2")r.gl.uniform2iv(p,c);else if(u.type==="ivec3")r.gl.uniform3iv(p,c);else if(u.type==="ivec4")r.gl.uniform4iv(p,c);else throw Error(`uniform type ${u.type} is not supported yet.`)}),r.executeProgram()}function e$(r,e,t){let n="";e.concat(t).forEach(i=>{let a=i.texData!=null&&i.texData.slice!=null&&i.texData.slice.flatOffset>0;if(r.enableShapeUniforms&&!i.isUniform){let u=i.texData.texShape,{useSqueezeShape:l,uniformShape:p,keptDims:c}=wx(r.packedInputs,i.shape,u),m="",d="",f="";if(p.length===1&&r.packedInputs){let C=[Math.ceil(u[0]/2),Math.ceil(u[1]/2)];m=`${C[0]>1}_${C[1]>1}`}else if(p.length===2&&!r.packedInputs)d=`${p[0]>1}_${p[1]>1}`;else if(p.length>2&&!r.packedInputs){let C=b.computeStrides(p);f=`${C[0]===u[1]}_${C[C.length-1]===u[1]}`}let h=i.shape.length,g=p.length===2&&b.arraysEqual(i.shape,u),x=b.sizeFromShape(i.shape)===1,y=I.getBroadcastDims(i.shape,t.shape),T=!r.packedInputs&&h===t.shape.length&&b.arraysEqual(u,t.texData.texShape),k=r.packedInputs||p.length>2?"":`${u[0]>1}_${u[1]>1}`;n+=`${h}_${T}_${l?c:""}_${p.length}_${x}_${y}_${g}_${m}_${d}_${f}_${k}_${a}`}else{let u=i.isUniform?"uniform":i.texData.texShape;n+=`${i.shape}_${u}_${a}`}});let o=r.userCode,s=r.constructor.name;return s+="_"+n+"_"+o+`${$().getNumber("WEBGL_VERSION")}`,s}function Bt(r){return $().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&r<=4}var Ew=class{constructor(e){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.outPackingScheme=Ap.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Qt();this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Dp(["r","c","d"],e):za(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}};var Rw=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outPackingScheme=Ap.DENSE;this.customUniforms=[{name:"texShape",type:"ivec2"}];let t=Qt();this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Dp(["r","c","d"],e):za(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}};var Lw=class{constructor(e){this.variableNames=["A"];this.outTexUsage=sn.DOWNLOAD;let t=Qt();this.outputShape=e,this.userCode=`
      ${Sx}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}};var Bw=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outTexUsage=sn.DOWNLOAD;let t=Qt();this.outputShape=e,this.userCode=`
      ${Sx}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}};var $w=class{constructor(e,t=!1){this.variableNames=["A"];this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Qt();this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length);let o="result";t&&(o="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?$m():Bm(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${n.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${n.output} = vec4(${o}, 0., 0., 0.);
      }
    `}};var Ow=class{constructor(e,t=!1){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;this.customUniforms=[{name:"texShape",type:"ivec2"}];let n=Qt();this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length);let o="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let a=0;a<=1;a++){let u=i*2+a;o+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${i};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${n.texture2D}(A, uv);

            if (offset == 0) {
              result[${u}] = values[0];
            } else if (offset == 1) {
              result[${u}] = values[1];
            } else if (offset == 2) {
              result[${u}] = values[2];
            } else {
              result[${u}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?$m():Bm(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${o}

          ${n.output} = ${s};
        }
    `}};var r_={};Xe(r_,{bindVertexProgramAttributeStreams:()=>qw,createBufferFromOutputTexture:()=>Qw,createFloat16MatrixTexture:()=>Kw,createFloat16PackedMatrixTexture:()=>Hw,createFloat32MatrixTexture:()=>Ww,createIndexBuffer:()=>Uw,createPackedMatrixTexture:()=>jw,createUnsignedBytesMatrixTexture:()=>Vw,createVertexBuffer:()=>Gw,createVertexShader:()=>zw,downloadByteEncodedFloatMatrixFromOutputTexture:()=>Jw,downloadFloat32MatrixFromBuffer:()=>Zw,downloadMatrixFromPackedOutputTexture:()=>t_,downloadPackedMatrixFromBuffer:()=>e_,getInternalFormatForFloat16MatrixTexture:()=>Ax,getInternalFormatForFloat16PackedMatrixTexture:()=>Px,getInternalFormatForFloat32MatrixTexture:()=>_x,getInternalFormatForPackedMatrixTexture:()=>Dx,getInternalFormatForUnsignedBytesMatrixTexture:()=>Nx,uploadDenseMatrixToTexture:()=>Xw,uploadPixelDataToTexture:()=>Yw});function zw(r){let e=Qt(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return fw(r,t)}function Gw(r){let e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return yw(r,e)}function Uw(r){let e=new Uint16Array([0,1,2,2,1,3]);return xw(r,e)}function rg(r,e,t,n,o,s){kw(e,t);let i=Tw(r),a=r.TEXTURE_2D;return Se(r,()=>r.bindTexture(a,i)),Se(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),Se(r,()=>r.texParameteri(a,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),Se(r,()=>r.texParameteri(a,r.TEXTURE_MIN_FILTER,r.NEAREST)),Se(r,()=>r.texParameteri(a,r.TEXTURE_MAG_FILTER,r.NEAREST)),$().getNumber("WEBGL_VERSION")===1?Se(r,()=>r.texImage2D(a,0,n,e,t,0,o,s,null)):Se(r,()=>r.texStorage2D(a,1,n,e,t)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null)),i}function _x(r){return r.internalFormatFloat}function Ww(r,e,t,n){let[o,s]=Np(e,t);return rg(r,o,s,_x(n),n.textureFormatFloat,r.FLOAT)}function Ax(r){return r.internalFormatHalfFloat}function Kw(r,e,t,n){let[o,s]=Np(e,t);return rg(r,o,s,Ax(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function Nx(r){return r.downloadTextureFormat}function Vw(r,e,t,n){let[o,s]=Np(e,t);return rg(r,o,s,Nx(n),r.RGBA,r.UNSIGNED_BYTE)}function Dx(r){return r.internalFormatPackedFloat}function jw(r,e,t,n){let[o,s]=xi(e,t);return rg(r,o,s,Dx(n),r.RGBA,r.FLOAT)}function Px(r){return r.internalFormatPackedHalfFloat}function Hw(r,e,t,n){let[o,s]=xi(e,t);return rg(r,o,s,Px(n),r.RGBA,n.textureTypeHalfFloat)}function qw(r,e,t){let n=0,o=3*4,s=3*4+2*4;return Se(r,()=>r.bindBuffer(r.ARRAY_BUFFER,t)),xx(r,e,"clipSpacePos",t,3,s,n)&&xx(r,e,"uv",t,2,s,o)}function Xw(r,e,t,n,o,s){Se(r,()=>r.bindTexture(r.TEXTURE_2D,e));let i,a,u;o instanceof Uint8Array?(i=new Uint8Array(t*n*4),a=r.UNSIGNED_BYTE,u=r.RGBA):(i=new Float32Array(t*n*4),a=r.FLOAT,u=s.internalFormatPackedFloat),i.set(o),$().getNumber("WEBGL_VERSION")===2?Se(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t,n,r.RGBA,a,i)):Se(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,t,n,0,r.RGBA,a,i)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function Yw(r,e,t){Se(r,()=>r.bindTexture(r.TEXTURE_2D,e)),t.data instanceof Uint8Array?$().getNumber("WEBGL_VERSION")===2?(Se(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,t.width,t.height,r.RGBA,r.UNSIGNED_BYTE,t.data)),r.flush()):Se(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t.width,t.height,0,r.RGBA,r.UNSIGNED_BYTE,t.data)):$().getNumber("WEBGL_VERSION")===2?(Se(r,()=>r.texSubImage2D(r.TEXTURE_2D,0,0,0,r.RGBA,r.UNSIGNED_BYTE,t)),r.flush()):Se(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,t)),Se(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function Qw(r,e,t,n){let o=r.createBuffer();Se(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,o));let a=4*4*e*t;return Se(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,a,r.STREAM_READ)),Se(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,0)),Se(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),o}function Zw(r,e,t){let n=r,o=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,o),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),o}function Jw(r,e,t,n){let[o,s]=Np(e,t),i=4,a=new Uint8Array(zB(e*t,i));return Se(r,()=>r.readPixels(0,0,o,s,n.downloadTextureFormat,r.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function e_(r,e,t,n,o,s,i,a){let u=r,l=new Float32Array(GB(s,i));return u.bindBuffer(u.PIXEL_PACK_BUFFER,e),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,l),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),l}function t_(r,e,t){let n=new Float32Array(e*t*4);return Se(r,()=>r.readPixels(0,0,t,e,r.RGBA,r.FLOAT,n)),n}var Mx=class{constructor(e){this.outputTexture=null;this.program=null;this.disposed=!1;this.vertexAttrsAreBound=!1;this.itemsToPoll=[];let t=$().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,cw(t,e)):this.gl=rs(t);let n="WEBGL_color_buffer_float",o="EXT_color_buffer_half_float";if($().getNumber("WEBGL_VERSION")===1){let s="OES_texture_float",i="OES_texture_half_float";if(this.textureFloatExtension=Em(this.gl,s),eo(this.gl,i))this.textureHalfFloatExtension=Em(this.gl,i);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),eo(this.gl,o))this.colorBufferHalfFloatExtension=Em(this.gl,o);else if($().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",eo(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(eo(this.gl,o))this.colorBufferHalfFloatExtension=this.gl.getExtension(o);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=Gw(this.gl),this.indexBuffer=Uw(this.gl),this.framebuffer=Iw(this.gl),this.textureConfig=Zh(this.gl,this.textureHalfFloatExtension)}get debug(){return $().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let e=this.gl;Se(e,()=>e.finish()),Se(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Se(e,()=>e.deleteFramebuffer(this.framebuffer)),Se(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Se(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Se(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Ww(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),Kw(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Vw(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Yw(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,o){this.throwIfDisposed(),Xw(this.gl,e,t,n,o,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Hw(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),jw(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(Tx(this.gl,this.framebuffer),this.outputTexture=null),Se(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>Jw(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,o,s,i){return e_(this.gl,e,t,n,o,s,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Zw(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);let o=Qw(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),o}createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if($().getBool("WEBGL_FENCE_API_ENABLED")){let o=e,s=o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{let i=o.clientWaitSync(s,0,0);return i===o.ALREADY_SIGNALED||i===o.CONDITION_SATISFIED},t=s}else $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>t_(this.gl,t,n))}createProgram(e){this.throwIfDisposed();let t=this.gl;this.vertexShader==null&&(this.vertexShader=zw(t));let n=gw(t);return Se(t,()=>t.attachShader(n,this.vertexShader)),Se(t,()=>t.attachShader(n,e)),bw(t,n),this.debug&&Jh(t,n),this.vertexAttrsAreBound||(this.setProgram(n),this.vertexAttrsAreBound=qw(t,this.program,this.vertexBuffer)),n}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&Se(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&Jh(this.gl,this.program),Se(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?Cw(this.gl,e,t):vw(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Se(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),Sw(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();let[o,s]=xi(t,n);this.setOutputMatrixTextureDriver(e,o,s)}setOutputMatrixWriteRegion(e,t,n,o){this.setOutputMatrixWriteRegionDriver(n,e,o,t)}setOutputPackedMatrixWriteRegion(e,t,n,o){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&Jh(this.gl,this.program),Rm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let e=this.gl;this.debug&&this.debugValidate(),Se(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Se(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Em(this.gl,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.createQuery();return n.beginQuery(o.TIME_ELAPSED_EXT,s),s}let e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}let e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await b.repeatedTry(()=>this.disposed||this.isQueryAvailable(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,$().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){let n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){let n=this.gl,o=this.getQueryTimerExtensionWebGL2(),s=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(o.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),o=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),o&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){let e=poe(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){let{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&b.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),eg(this.gl,e,this.framebuffer),this.debug&&Rm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(eg(this.gl,this.outputTexture,this.framebuffer),this.debug&&Rm(this.gl)):Tx(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);let n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();let o=this.gl;eg(o,e,this.framebuffer),this.debug&&Rm(o),this.outputTexture=e,Se(o,()=>o.viewport(0,0,t,n)),Se(o,()=>o.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,o){this.throwIfDisposed(),Se(this.gl,()=>this.gl.scissor(e,t,n,o))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function poe(r){let e=0;for(;e<r.length&&r[e]();++e);return e-1}var{addImpl:t$,bincountImpl:Fx,bincountReduceImpl:r$,ceilImpl:n$,concatImpl:o$,equalImpl:s$,expImpl:a$,expm1Impl:i$,floorImpl:u$,gatherNdImpl:l$,gatherV2Impl:p$,greaterImpl:c$,greaterEqualImpl:m$,lessImpl:d$,lessEqualImpl:f$,linSpaceImpl:h$,logImpl:g$,maxImpl:b$,maximumImpl:y$,minimumImpl:x$,multiplyImpl:T$,negImpl:k$,notEqualImpl:I$,prodImpl:C$,rangeImpl:v$,rsqrtImpl:S$,sigmoidImpl:w$,simpleAbsImpl:Ex,sliceImpl:_$,sparseFillEmptyRowsImpl:A$,sparseReshapeImpl:N$,sparseSegmentReductionImpl:Rx,sqrtImpl:D$,stridedSliceImpl:P$,stringNGramsImpl:M$,stringSplitImpl:F$,stringToHashBucketFastImpl:E$,subImpl:R$,tileImpl:L$,topKImpl:B$,transposeImpl:Mp,uniqueImpl:$$}=Dm;function n_(r,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${r}.${t}`)}function sr(r,e){return e===1?[r]:n_(r,e)}function O$(r,e){if(r===1)return"rc";let t="";for(let n=0;n<r;n++)t+=e[n],n<r-1&&(t+=",");return t}var o_=class{constructor(e){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;if(this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Bt(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let t=sr("rc",this.rank),n=je(this.rank),o=this.getOutOfBoundsCondition(t),s=this.getSetup(t),i=this.getOutput(t);this.userCode=`
        void main() {
          ${n} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${i}));
          }
        }
      `}}getSourceCoordsArr(e){let t=[];for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){let s=`${n===0?"r":"rp1"}, ${o===0?"c":"cp1"}`;for(let i=2;i<this.rank;i++)s=`${e[e.length-1-i]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";let t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],o=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${n};
      bool rEdge = rp1 >= ${o};
    `}getOutput(e){let t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc),
              rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1),
              0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}};var ng=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"inputShape",type:"ivec3"}];this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length);let n="";for(let o=0;o<4;o++){let s="thisRC = rc;";o%2==1&&(s+="thisRC.z += 1;"),o>1&&(s+="thisRC.y += 1;"),n+=`
        ${s}
        ${o>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${o}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${o>0?"}":""}
      `}this.userCode=`
      ${coe(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?$m():Bm(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${n}

        setOutput(result);
      }
    `}};function coe(r,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?jB(["r","c","d"],"inputShape"):za(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var s_=class{constructor(e){this.gpgpu=e;this.numUsedTextures=0;this.numFreeTextures=0;this._numBytesAllocated=0;this._numBytesFree=0;this.freeTextures={};this.logEnabled=!1;this.usedTextures={}}acquireTexture(e,t,n){let o=G$(t,n),s=U$(e,o,n);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);let i=z$(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();let u=this.freeTextures[s].shift();return this.usedTextures[s].push(u),u}let a;return o===Zr.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):o===Zr.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):o===Zr.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):o===Zr.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):o===Zr.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,n,o){if(this.freeTextures==null)return;let s=G$(n,o),i=U$(t,s,o);i in this.freeTextures||(this.freeTextures[i]=[]);let a=z$(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,o),u=$().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;let l=this.usedTextures[i],p=l.indexOf(e);if(p<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l.splice(p,1),this.log()}log(){if(!this.logEnabled)return;let e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);let t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(let e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function moe(r,e){let t=r;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===r.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function z$(r,e,t,n,o){let s=doe(e,n),i;if(o){let[u,l]=xi(r[0],r[1]);i=u*l}else{let[u,l]=Np(r[0],r[1]);i=u*l}let a=moe(t,s);return i*a}function doe(r,e){switch(r){case Zr.PACKED_2X2_FLOAT32:return Dx(e);case Zr.PACKED_2X2_FLOAT16:return Px(e);case Zr.UNPACKED_FLOAT32:return _x(e);case Zr.UNPACKED_FLOAT16:return Ax(e);case Zr.PACKED_4X1_UNSIGNED_BYTE:return Nx(e);default:throw new Error(`Unknown physical texture type ${r}`)}}function foe(r){return $().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Zr.PACKED_2X2_FLOAT32:Zr.UNPACKED_FLOAT32:r?Zr.PACKED_2X2_FLOAT16:Zr.UNPACKED_FLOAT16}function G$(r,e){if(r===sn.UPLOAD)return Zr.PACKED_2X2_FLOAT32;if(r===sn.RENDER||r==null)return foe(e);if(r===sn.DOWNLOAD||r===sn.PIXELS)return Zr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function U$(r,e,t){return`${r[0]}_${r[1]}_${e}_${t}`}var Bn=class{constructor(e,t){this.variableNames=["A"];this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Mr="if (isnan(x)) return x;",W$="return x;",a_="return abs(x);";var K$="return (x >= 0.0) ? x : (exp(x) - 1.0);",V$=Mr+`
  return (x < 0.0) ? 0.0 : x;
`,j$=Mr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,og="return x;",H$="return 1.0 / (1.0 + exp(-1.0 * x));";var X$="return x;",Y$=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Q$=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Z$=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,J$="return 1.0 / (1.0 + exp(-1.0 * x));",Ga=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var i_=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!1;this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length);let t=e.length,n=sr("rc",t),o=je(t),s=O$(t,n),i=n.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`
      void main() {
        ${o} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}};var goe=Tr.whereImpl,boe=1e-7,yoe=1e-4,Lx={};function xoe(r){return r in Lx||(Lx[r]={}),Lx[r]}var Toe=$().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),koe=600;function Ioe(){return $().global.screen==null?1024:$().global.screen.height*$().global.screen.width*window.devicePixelRatio*koe/1024/1024}var u_=class extends ps{constructor(e){super();this.pendingRead=new WeakMap;this.pendingDisposal=new WeakSet;this.dataRefCount=new WeakMap;this.numBytesInGPU=0;this.uploadWaitMs=0;this.downloadWaitMs=0;this.lastGlFlushTime=0;this.warnedAboutMemory=!1;this.pendingDeletes=0;this.disposed=!1;if(!$().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){let t=rs($().getNumber("WEBGL_VERSION"));this.binaryCache=xoe($().getNumber("WEBGL_VERSION")),this.gpgpu=new Mx(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new s_(this.gpgpu),this.numMBBeforeWarning=Ioe(),this.texData=new qa(this,qo())}nextDataId(){return u_.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,n){if(($().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||$().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()};return this.texData.set(o,{shape:t,dtype:n,values:e,usage:sn.UPLOAD,refCount:1}),o}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){let t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){let t=this.texData.get(e);t.refCount--}}move(e,t,n,o,s){if($().getBool("DEBUG")&&this.checkNumericalProblems(t),o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:o,values:t,usage:sn.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){let t=this.texData.get(e),{values:n,dtype:o,complexTensorInfos:s,slice:i,shape:a,isPacked:u}=t;if(i!=null){let m;u?m=new Ga(a,og):m=new Bn(a,og);let d=this.runWebGLProgram(m,[{dataId:e,shape:a,dtype:o}],o),f=this.readSync(d.dataId);return this.disposeIntermediateTensorInfo(d),f}if(n!=null)return this.convertAndCacheOnCPU(e);if(o==="string")return n;let l=this.activeTimers!=null,p;l&&(p=b.now());let c;if(o==="complex64"){let m=this.readSync(s.real.dataId),d=this.readSync(s.imag.dataId);c=I.mergeRealAndImagArrays(m,d)}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=b.now()-p),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){let f=this.pendingRead.get(e);return new Promise(h=>f.push(h))}let t=this.texData.get(e),{values:n,shape:o,slice:s,dtype:i,complexTensorInfos:a,isPacked:u}=t;if(s!=null){let f;u?f=new Ga(o,og):f=new Bn(o,og);let h=this.runWebGLProgram(f,[{dataId:e,shape:o,dtype:i}],i),g=this.read(h.dataId);return this.disposeIntermediateTensorInfo(h),g}if(n!=null)return this.convertAndCacheOnCPU(e);if($().getBool("DEBUG")&&!$().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&$().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,p;if(i!=="complex64"&&$().get("WEBGL_BUFFER_SUPPORTED")){p=this.decode(e);let f=this.texData.get(p.dataId);l=this.gpgpu.createBufferFromTexture(f.texture,...Qh(o))}this.pendingRead.set(e,[]),i!=="complex64"&&await this.gpgpu.createAndWaitForFence();let c;if(i==="complex64"){let f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),h=f[0],g=f[1];c=I.mergeRealAndImagArrays(h,g)}else if(l==null)c=this.getValuesFromTexture(e);else{let f=b.sizeFromShape(o);c=this.gpgpu.downloadFloat32MatrixFromBuffer(l,f)}if(p!=null&&this.disposeIntermediateTensorInfo(p),l!=null){let f=this.gpgpu.gl;Se(f,()=>f.deleteBuffer(l))}let m=this.convertAndCacheOnCPU(e,c),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach(f=>f(m)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&qo().removeDataId(e,this),this.pendingDeletes--),m}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>b.decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){let n=e[t];if(!dw(n))throw $().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(e){let{shape:t,dtype:n,isPacked:o}=this.texData.get(e),s=b.sizeFromShape(t);if($().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let m=this.decode(e),d=this.texData.get(m.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(d.texture,...Qh(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(m),f}let i=$().getBool("WEBGL_PACK")&&o===!0,a=i?tg(t):t,u=i?new Bw(a):new Lw(a),l=this.runWebGLProgram(u,[{shape:a,dtype:n,dataId:e}],"float32"),p=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(p.texture,p.texShape[0],p.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=b.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),i=b.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(s);a.kernelMs=b.sum(u),a.getExtraProfileInfo=()=>u.map((l,p)=>({name:i[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:b.now(),endMs:null}}endTimer(e){return $().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=b.now(),e)}async getQueryTime(e){if($().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);let t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);let{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){let{texture:t,dtype:n,texShape:o,usage:s,isPacked:i,slice:a}=this.texData.get(e),u=a&&a.origDataId||e,l=this.dataRefCount.get(u);l>1?this.dataRefCount.set(u,l-1):(this.dataRefCount.delete(u),t!=null&&(this.numBytesInGPU-=this.computeBytes(o,n),this.textureManager.releaseTexture(t,o,s,i)));let p=this.texData.get(e);p.texture=null,p.texShape=null,p.isPacked=!1,p.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Toe){return $().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&b.sizeFromShape(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){I.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let t=e.dataSync();return goe(e.shape,t)}packedUnaryOp(e,t,n){let o=new Ga(e.shape,t),s=this.compileAndRun(o,[e],n);return qo().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){let o=Ex(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,o)}if($().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,a_,e.dtype);let t=new Bn(e.shape,a_),n=this.compileAndRun(t,[e]);return qo().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&b.isString(n[0])){let s=n.map(i=>b.encodeString(i));o=this.write(s,e,t)}else o=this.write(n,e,t);return this.texData.get(o).usage=null,{dataId:o,shape:e,dtype:t}}makeOutput(e,t,n){let{dataId:o}=this.makeTensorInfo(e,t,n);return qo().makeTensorFromDataId(o,e,t,this)}unpackTensor(e){let t=new i_(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){let t=new o_(e.shape),n=!0;return this.runWebGLProgram(t,[e],e.dtype,null,n)}packedReshape(e,t){let n=[Iu(e.shape),...Cu(e.shape)],o={dtype:e.dtype,shape:n,dataId:e.dataId},s=[Iu(t),...Cu(t)],i=new ng(s,n),a=!0,u=[n],l=this.runWebGLProgram(i,[o],e.dtype,u,a);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e){let t=this.texData.get(e),{isPacked:n,shape:o,dtype:s}=t,i=tg(o),a,u=Qh(i);n?a=new Rw(i):a=new Ew(i);let l=!0,p=[u],c=this.runWebGLProgram(a,[{shape:i,dtype:s,dataId:e}],s,p,l);return{dtype:s,shape:o,dataId:c.dataId}}runWebGLProgram(e,t,n,o,s=!1){let i=this.makeTensorInfo(e.outputShape,n),a=this.texData.get(i.dataId);if(e.packedOutput&&(a.isPacked=!0),e.outPackingScheme===Ap.DENSE){let g=Qh(e.outputShape);a.texShape=g.map(x=>x*2)}if(e.outTexUsage!=null&&(a.usage=e.outTexUsage),b.sizeFromShape(i.shape)===0)return a.values=b.getTypedArrayFromDType(i.dtype,0),i;let u=[],l=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(g.dataId);if(x.texture==null){if(!e.packedInputs&&b.sizeFromShape(g.shape)<=$().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!x.isPacked!=!!e.packedInputs)g=x.isPacked?this.unpackTensor(g):this.packTensor(g),u.push(g),x=this.texData.get(g.dataId);else if(x.isPacked&&!hl(x.shape,g.shape)){let y=g,T=g.shape;g.shape=x.shape,g=this.packedReshape(g,T),u.push(g),x=this.texData.get(g.dataId),y.shape=T}return{shape:g.shape,texData:x,isUniform:!1}});this.uploadToGPU(i.dataId);let p={shape:i.shape,texData:a,isUniform:!1},c=e$(e,l,p),m=this.getAndSaveBinary(c,()=>QB(this.gpgpu,e,l,p)),d=this.activeTimers!=null,f;d&&(f=this.startTimer()),JB(this.gpgpu,m,l,p,o),u.forEach(g=>this.disposeIntermediateTensorInfo(g)),d&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));let h=$().get("WEBGL_FLUSH_THRESHOLD");if(h>0){let g=b.now();g-this.lastGlFlushTime>h&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!$().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&s===!1){let g=this.unpackTensor(i);return this.disposeIntermediateTensorInfo(i),g}return i}compileAndRun(e,t,n,o,s=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,o,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||($().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=G(()=>{if(!$().get("WEBGL_RENDER_FLOAT32_ENABLED")){let e=$().getBool("DEBUG");$().set("DEBUG",!1);let t=this.abs(me(1e-8)).dataSync()[0];if($().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?boe:yoe}uploadToGPU(e){let t=this.texData.get(e),{shape:n,dtype:o,values:s,texture:i,usage:a,isPacked:u}=t;if(i!=null)return;let l=this.activeTimers!=null,p;l&&(p=b.now());let c=t.texShape;if(c==null&&(c=ww(n,u),t.texShape=c),s!=null){let m=tg(n),d,f=c[1],h=c[0],g=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(u||!g)&&([f,h]=xi(c[0],c[1])),u?d=new Ow(m,g):d=new $w(m,g);let x=g?[h,f]:c,y=this.makeTensorInfo(x,o),T=this.texData.get(y.dataId);g?T.usage=sn.PIXELS:T.usage=sn.UPLOAD,T.texShape=x,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(y.dataId),f,h,s);let k=[[h,f]],C=!0,A=this.runWebGLProgram(d,[y],o,k,C),M=this.texData.get(A.dataId);t.texture=M.texture,t.texShape=M.texShape,t.isPacked=M.isPacked,t.usage=M.usage,this.disposeIntermediateTensorInfo(y),this.texData.delete(A.dataId),t.values=null,l&&(this.uploadWaitMs+=b.now()-p)}else{let m=this.acquireTexture(c,a,o,u);t.texture=m}}convertAndCacheOnCPU(e,t){let n=this.texData.get(e),{dtype:o}=n;return this.releaseGPUData(e),t!=null&&(n.values=Coe(t,o)),n.values}acquireTexture(e,t,n,o){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,o)}computeBytes(e,t){return e[0]*e[1]*b.bytesPerElement(t)}},sg=u_;sg.nextDataId=0;function Coe(r,e){if(e==="float32"||e==="complex64")return r;if(e==="int32"||e==="bool"){let t=e==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<t.length;++n)t[n]=Math.round(r[n]);return t}else throw new Error(`Unknown dtype ${e}`)}var voe="0.0.0";function eO(){$().set("WEBGL_FORCE_F16_TEXTURES",!0)}oi.isBrowser()&&el("webgl",()=>new sg,2);var Yjt={forceHalfFloat:eO};var Bx=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var Qs=class{constructor(e,t,n){this.variableNames=["A","B"];this.outputShape=I.assertAndGetBroadcastShape(t,n),this.enableShapeUniforms=Bt(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var gl=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Ua=class{constructor(e,t,n,o=!1){this.variableNames=["A","B"];this.supportsBroadcasting=!0;this.packedInputs=!0;this.packedOutput=!0;this.outputShape=I.assertAndGetBroadcastShape(t,n);let s=this.outputShape.length;this.enableShapeUniforms=Bt(s);let i="";if(o)if(s===0||b.sizeFromShape(this.outputShape)===1)i=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(i=`
          ${je(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?i+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:i+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=sr("coords",s);this.enableShapeUniforms?i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:i+=`
            bool nextRowOutOfBounds =
              (${u[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${u[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${i}

        setOutput(result);
      }
    `}};function ar(r){let{inputs:e,backend:t}=r,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var tO={kernelName:jn,backendName:"webgl",kernelFunc:ar};function $n(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),i=t.texData.get(s.dataId),a=ar({inputs:{x:n},backend:t}),u=ar({inputs:{x:o},backend:t});return i.complexTensorInfos={real:a,imag:u},s}var rO={kernelName:Ru,backendName:"webgl",kernelFunc:$n};var l_="return (a < 0.) ? b * a : a;",p_=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Soe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,i=t.makeTensorInfo([],"float32",b.createScalarValue(s,"float32")),a=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ua(p_,o.shape,i.shape):new Qs(l_,o.shape,i.shape),u=t.runWebGLProgram(a,[o,i],"float32");return t.disposeIntermediateTensorInfo(i),u}var nO={kernelName:Io,backendName:"webgl",kernelFunc:Soe};var c_="return (a < 0.) ? b * a : a;",m_=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function woe(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ua(m_,n.shape,o.shape):new Qs(c_,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],"float32")}var oO={kernelName:Eo,backendName:"webgl",kernelFunc:woe};var $x="if (isnan(x)) return x;",sO=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,aO=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function _e({opSnippet:r,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:o,backend:s})=>{let{x:i}=o,a=s,u=n||i.dtype;if(a.shouldExecuteOnCPU([i])&&t!=null){let c=a.texData.get(i.dataId),m=t(c.values,u);return a.makeTensorInfo(i.shape,u,m)}let l=$().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null,p;return l?p=new Ga(i.shape,e):p=new Bn(i.shape,r),a.runWebGLProgram(p,[i],u)}}function ct({opSnippet:r,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:o,dtype:s}){return({inputs:i,backend:a})=>{let{a:u,b:l}=i,p=a;if(n&&u.dtype==="complex64"){let f=p.texData.get(u.dataId),h=p.texData.get(l.dataId),[g,x]=[[f.complexTensorInfos.real,h.complexTensorInfos.real],[f.complexTensorInfos.imag,h.complexTensorInfos.imag]].map(T=>{let[k,C]=T,A={dataId:k.dataId,dtype:k.dtype,shape:u.shape},M={dataId:C.dataId,dtype:C.dtype,shape:l.shape},P=new Qs(r,u.shape,l.shape);return p.runWebGLProgram(P,[A,M],Kt(k.dtype,C.dtype))}),y=$n({inputs:{real:g,imag:x},backend:p});return p.disposeIntermediateTensorInfo(g),p.disposeIntermediateTensorInfo(x),y}let c=s||Kt(u.dtype,l.dtype);if((u.dtype==="string"||l.dtype==="string"||p.shouldExecuteOnCPU([u,l]))&&o!=null){let f=p.texData.get(u.dataId).values,h=p.texData.get(l.dataId).values,g=u.dtype==="string"?I.fromUint8ToStringArray(f):f,x=u.dtype==="string"?I.fromUint8ToStringArray(h):h,[y,T]=o(u.shape,l.shape,g,x,c),k=p.makeTensorInfo(T,c),C=p.texData.get(k.dataId);return C.values=y,k}let m=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null,d;return m?d=new Ua(e,u.shape,l.shape,t):d=new Qs(r,u.shape,l.shape),p.runWebGLProgram(d,[u,l],c)}}function bl(r,e=!1){if(r==="linear")return e?X$:W$;if(r==="relu")return e?Q$:V$;if(r==="elu")return e?Y$:K$;if(r==="relu6")return e?Z$:j$;if(r==="prelu")return e?m_:c_;if(r==="leakyrelu")return e?p_:l_;if(r==="sigmoid")return e?J$:H$;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var ag=class{constructor(e,t,n,o=!1,s=!1,i=!1,a=null,u=!1,l=!1){this.variableNames=["matrixA","matrixB"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=n,this.enableShapeUniforms=Bt(this.outputShape.length);let p=o?e[1]:e[2],c=Math.ceil(p/2),m=o?"i * 2, rc.y":"rc.y, i * 2",d=s?"rc.z, i * 2":"i * 2, rc.z",f=o?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],h=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],g="",x="";a&&(u?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:l?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:g=`vec4 activation(vec4 x) {
          ${a}
        }`,x="result = activation(result);");let y=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let T="rc.x",k="rc.x";e[0]<t[0]?T=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(k=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${g}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${c}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${c}; i++) {
          int batchA = ${T};
          int batchB = ${k};
          vec4 a = getMatrixA(batchA, ${m});
          vec4 b = getMatrixB(batchB, ${d});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${h[0]});
          result += (${f[1]} * ${h[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${y}

        ${x}

        setOutput(result);
      }
    `}};var d_={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},Ox=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.outputShape=I.assertAndGetBroadcastShape(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var iO="return a * b;";function ig(r){let{inputs:e,backend:t}=r,{a:n,b:o}=e,s=I.upcastType(n.dtype,o.dtype);if(n.dtype==="complex64"){let a=t.texData.get(n.dataId),u=t.texData.get(o.dataId),l=new Ox(d_.REAL,n.shape,o.shape),p=new Ox(d_.IMAG,n.shape,o.shape),c=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:n.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:o.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:o.shape}],m=t.runWebGLProgram(l,c,"float32"),d=t.runWebGLProgram(p,c,"float32"),f=$n({inputs:{real:m,imag:d},backend:t});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d),f}if(t.shouldExecuteOnCPU([n,o])){let a=t.texData.get(n.dataId),u=t.texData.get(o.dataId),[l,p]=T$(n.shape,o.shape,a.values,u.values,s),c=t.makeTensorInfo(p,s),m=t.texData.get(c.dataId);return m.values=l,c}let i;return $().getBool("WEBGL_PACK_BINARY_OPERATIONS")?i=new Ua(iO,n.shape,o.shape):i=new Qs(iO,n.shape,o.shape),t.runWebGLProgram(i,[n,o],s)}var uO={kernelName:Po,backendName:"webgl",kernelFunc:ig};function lO(r,e,t){let n=[Iu(r.shape),...Cu(r.shape)],o={dtype:r.dtype,shape:n,dataId:r.dataId},s=[Iu(e),...Cu(e)],i=new ng(s,n),a=!0,u=[n],l=t.runWebGLProgram(i,[o],r.dtype,u,a);return{dataId:l.dataId,shape:e,dtype:l.dtype}}function le(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{shape:s}=n,i=t,a=b.sizeFromShape(o.shape),u=b.inferFromImplicitShape(s,a),l=b.sizeFromShape(u);b.assert(a===l,()=>`The new shape (${u}) has ${l} elements and the old shape (${o.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);let p=i.texData.get(o.dataId);return p.isPacked&&!hl(o.shape,u)&&!(p.texture!==null&&hl(p.shape,u))?lO(o,u,i):(i.incRef(o.dataId),{dataId:o.dataId,shape:u,dtype:o.dtype})}var pO={kernelName:Ts,backendName:"webgl",kernelFunc:le};var zx=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a=Math.floor(n/4)*4,u=n%4,l="sumValue += dot(values, ones);";if(t!=null){let c=1/t;l=`sumValue += dot(values * ${b.isInt(c)?c.toPrecision(2):c}, ones);`}let p="";s%n>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${a};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}};var f_=class{constructor(e,t){this.variableNames=["x"];let{windowSize:n,batchSize:o,inSize:s,outSize:i}=e;this.outputShape=[o,i];let a="0.0",u="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",u="min"):t==="max"&&(a="-1.0 / 1e-20",u="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");let p=Math.floor(n/4)*4,c=n%4,m=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${u}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,d="vec4";t==="all"?(a="1.0",m=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,d="bvec4"):t==="any"&&(a="0.0",m=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,d="bvec4");let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${m}
        }

        int inIdx = inOffset + ${p};
        if (${c===1}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${c===2}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${m}
        } else if (${c===3}) {
          ${d} values = ${d}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function Aoe(r){let e=[];for(;e.length===0||e[e.length-1].outSize!==1;){let t=e.length?e[e.length-1].outSize:r[1],n=I.computeOptimalWindowSize(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function to(r,e,t,n){let o=Aoe(r.shape),s=r;for(let i=0;i<o.length;i++){let{inSize:a,windowSize:u,outSize:l}=o[i],p,c;t==="mean"?p=i===0?new zx({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},a):new zx({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l}):p=new f_({windowSize:u,inSize:a,batchSize:r.shape[0],outSize:l},t),c=s,s=n.runWebGLProgram(p,[s],e),c.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(c)}return s}var h_=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;let o=je(this.rank),s=Noe(t);this.userCode=`
    void main() {
      ${o} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}};function Noe(r){let e=r.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let o=0;o<r.length;o++)n[r[o]]=t[o];return n.join()}var g_=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;let n=new Array(e.length);for(let p=0;p<n.length;p++)n[p]=e[t[p]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let o=je(this.rank),s=n_("rc",this.rank),i=new Array(this.rank);for(let p=0;p<t.length;p++)i[t[p]]=s[p];let a=`vec2(${i.slice(-2).join()})`,u=`++${s[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`
    void main() {
      ${o} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${u}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${l};
        if(${u}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}};function yl(r,e,t){let n=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new g_(r.shape,e):new h_(r.shape,e);return t.runWebGLProgram(n,[r],r.dtype)}function cO(r,e,t,n){let o=e,s=r.shape.length,i=b.parseAxisParam(o,r.shape),a=i,u=I.getAxesPermutation(a,s),l=u!=null,p=r;l&&(p=yl(r,u,n),a=I.getInnerMostAxes(a.length,s)),I.assertAxesAreInnerMostDims("sum",a,s);let[c,m]=I.computeOutAndReduceShapes(p.shape,a),d=c;t&&(d=I.expandShapeToKeepDim(c,i));let f=b.sizeFromShape(m),g=b.sizeFromShape(r.shape)/f,x=le({inputs:{x:p},attrs:{shape:[g,f]},backend:n}),y=Ji(r.dtype),T=to(x,y,"sum",n),k=le({inputs:{x:T},attrs:{shape:d},backend:n});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(T),l&&n.disposeIntermediateTensorInfo(p),k}function Fp(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;return cO(o,s,i,t)}var mO={kernelName:Uo,backendName:"webgl",kernelFunc:Fp};function Ht(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,i=t,a=o.shape.length,u=new Array(a);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];let l;if(i.shouldExecuteOnCPU([o])){let c=i.texData.get(o.dataId).values,m=Mp(c,o.shape,o.dtype,s,u);l=i.makeTensorInfo(u,o.dtype);let d=i.texData.get(l.dataId);d.values=m}else l=yl(o,s,i);return l}var dO={kernelName:Ho,backendName:"webgl",kernelFunc:Ht};var b_=1e3;function Ep({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,c=t?r.shape[l-2]:r.shape[l-1],m=n?e.shape[p-1]:e.shape[p-2],d=t?r.shape[l-1]:r.shape[l-2],f=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),x=b.sizeFromShape(h),y=b.sizeFromShape(g),k=Ar.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);b.assert(c===m,()=>`Error in matMul: inner shapes (${c}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let C=t?[x,c,d]:[x,d,c],A=n?[y,f,m]:[y,m,f],M=le({inputs:{x:r},backend:o,attrs:{shape:C}}),P=le({inputs:{x:e},backend:o,attrs:{shape:A}}),F=[M,P],B=Math.max(x,y),U=t?M.shape[1]:M.shape[2],W=s!=null,K=i!=null,j=u==="leakyrelu",V=u!=null?bl(u,!0):null,q=W||K||j||V!=null,ee;if((d===1||f===1)&&U>b_&&q===!1){let te=M,oe=P;t&&(te=Ht({inputs:{x:M},backend:o,attrs:{perm:[0,2,1]}}),F.push(te)),n&&(oe=Ht({inputs:{x:P},backend:o,attrs:{perm:[0,2,1]}}),F.push(oe));let ie=f!==1,se=f===1,ue=te;ie&&(ue=le({inputs:{x:te},backend:o,attrs:{shape:[B,U,1]}}),F.push(ue));let ye=f===1?2:1,fe=oe;se&&(fe=le({inputs:{x:oe},backend:o,attrs:{shape:[B,1,U]}}),F.push(fe));let Te=ig({inputs:{a:ue,b:fe},backend:o});ee=Fp({inputs:{x:Te},backend:o,attrs:{axis:ye,keepDims:!0}}),F.push(Te)}else{let te=Kt(r.dtype,e.dtype),oe=new ag(C,A,[B,d,f],t,n,W,V,K,j),ie=[M,P];if(s!=null&&ie.push(s),K&&ie.push(i),j){let se=o.makeTensorInfo([],"float32",b.createScalarValue(a,"float32"));ie.push(se),F.push(se)}ee=o.runWebGLProgram(oe,ie,te)}let Z=le({inputs:{x:ee},backend:o,attrs:{shape:k}});F.push(ee);for(let te of F)o.disposeIntermediateTensorInfo(te);return Z}function Doe(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n;return Ep({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:c,activation:p})}var fO={kernelName:As,backendName:"webgl",kernelFunc:Doe};var hO="return abs(x);";function Poe(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let s=t.texData.get(n.dataId),i=Ex(s.values);return t.makeTensorInfo(n.shape,n.dtype,i)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Ga(n.shape,hO):o=new Bn(n.shape,hO),t.runWebGLProgram(o,[n],n.dtype)}var gO={kernelName:ms,backendName:"webgl",kernelFunc:Poe};var Moe=Mr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,Foe=_e({opSnippet:Moe}),bO={kernelName:Di,backendName:"webgl",kernelFunc:Foe};var Eoe=Mr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Roe=_e({opSnippet:Eoe}),yO={kernelName:Pi,backendName:"webgl",kernelFunc:Roe};var xO="return a + b;",Loe=ct({opSnippet:xO,packedOpSnippet:xO,supportsComplex:!0,cpuKernelImpl:t$}),TO={kernelName:_n,backendName:"webgl",kernelFunc:Loe};var y_=class{constructor(e,t){this.outputShape=[];this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`float v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${o};
        setOutput(result);
      }
    `}};var x_=class{constructor(e,t){this.outputShape=[];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=e,this.variableNames=t.map((s,i)=>`T${i}`);let n=[];this.variableNames.forEach(s=>{n.push(`vec4 v${s} = get${s}AtOutCoords();`)});let o=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${o};
        setOutput(result);
      }
    `}};function Gx(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return ar({inputs:{x:n[0]},backend:t});if(n.length>$().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),l=Gx({inputs:n.slice(0,u),backend:t}),p=Gx({inputs:n.slice(u),backend:t});return Gx({inputs:[l,p],backend:t})}let o=n.map(u=>u.dtype).reduce((u,l)=>Kt(u,l)),s=n.map(u=>u.shape),a=$().getBool("WEBGL_PACK")?new x_(n[0].shape,s):new y_(n[0].shape,s);return t.runWebGLProgram(a,n,o)}var kO={kernelName:oo,backendName:"webgl",kernelFunc:Gx};function Boe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,a),c=o;p!=null&&(c=Ht({inputs:{x:o},backend:t,attrs:{perm:p}}),l=I.getInnerMostAxes(l.length,a)),I.assertAxesAreInnerMostDims("all",l,a);let[m,d]=I.computeOutAndReduceShapes(c.shape,l),f=b.sizeFromShape(d),h=le({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}}),g=to(h,h.dtype,"all",t),x;if(i){let y=I.expandShapeToKeepDim(m,u);x=le({inputs:{x:g},backend:t,attrs:{shape:y}})}else x=le({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(c),x}var IO={kernelName:Mi,backendName:"webgl",kernelFunc:Boe};function $oe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,a),c=o;p!=null&&(c=Ht({inputs:{x:o},backend:t,attrs:{perm:p}}),l=I.getInnerMostAxes(l.length,a)),I.assertAxesAreInnerMostDims("any",l,a);let[m,d]=I.computeOutAndReduceShapes(c.shape,l),f=b.sizeFromShape(d),h=le({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}}),g=to(h,h.dtype,"any",t),x;if(i){let y=I.expandShapeToKeepDim(m,u);x=le({inputs:{x:g},backend:t,attrs:{shape:y}})}else x=le({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(c),x}var CO={kernelName:Fi,backendName:"webgl",kernelFunc:$oe};var T_=class{constructor(e,t,n){this.variableNames=["A"];let{windowSize:o,batchSize:s,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[s,i];let a=t==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${o};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${o}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var k_=class{constructor(e,t,n,o){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;b.assert(e.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let s=e[e.length-1],i=Math.ceil(s/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),o||this.variableNames.push("bestIndicesA");let a=this.outputShape,u=a.length,l=je(u),p=sr("coords",u),c,m;if(i===1){m=u+1;let P=je(m);c=`
        ${P} sourceLocR = ${P}(${p.join()}, 0);
        ++${p[u-1]};
        ${P} sourceLocG = ${P}(${p.join()}, 0);
        ++${p[u-2]};
        ${P} sourceLocA = ${P}(${p.join()}, 0);
        --${p[u-1]};
        ${P} sourceLocB = ${P}(${p.join()}, 0);
        --${p[u-2]};`}else m=u,c=`
        ${l} sourceLocR = coords;
        ++${p[u-1]};
        ${l} sourceLocG = coords;
        ++${p[u-2]};
        ${l} sourceLocA = coords;
        --${p[u-1]};
        ${l} sourceLocB = coords;
        --${p[u-2]};`;let d=["x","y","z","w","u","v"].slice(0,m),f="."+d[m-1],h=d.map(P=>"int "+P),g=sr("sourceLocR",m-1).concat("inIdx.r"),x=sr("sourceLocG",m-1).concat("inIdx.g"),y=sr("sourceLocB",m-1).concat("inIdx.b"),T=sr("sourceLocA",m-1).concat("inIdx.a"),k=n==="max"?"greaterThan":"lessThan",C=o?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${T.join()})));`,A=`vec4(
            getAChannel(${g.join()}),
            hasNextCol ? getAChannel(${x.join()}) : 0.,
            hasNextRow ? getAChannel(${y.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${T.join()}) : 0.)`,M=o?"":`
      float getBestIndicesAChannel(${h.join()}) {
        return getChannel(getBestIndicesA(${d.join()}),
                                          vec2(${d.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${h.join()}) {
        return getChannel(getA(${d.join()}),
                               vec2(${d.slice(-2).join()}));
      }
      ${M}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${p[u-1]} < ${a[u-1]-1};
        bool hasNextRow = ${p[u-2]} < ${a[u-2]-1};
        ${c}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${A};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${A};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${k}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function vO(r,e,t,n=null){let o=e.shape[0],s=e.shape[1];n!=null&&(o=n.shape[0],s=n.shape[1]);let i=I.computeOptimalWindowSize(s),a={windowSize:i,inSize:s,batchSize:o,outSize:Math.ceil(s/i)},u=new T_(a,t,n==null),l=[e];n!=null&&l.push(n);let p=r.runWebGLProgram(u,l,"int32");if(p.shape[1]===1)return p;let c=vO(r,e,t,p);return r.disposeIntermediateTensorInfo(p),c}function SO(r,e,t,n=null){let o=n!=null?n.shape:e.shape,s=o[o.length-1],i=I.computeOptimalWindowSize(s),a=new k_(o,i,t,n==null),u=n==null?[e]:[e,n],l=r.runWebGLProgram(a,u,"int32");if(l.shape.length===e.shape.length){let p=SO(r,e,t,l);return r.disposeIntermediateTensorInfo(l),p}return l}function Ux(r,e,t,n){let o=[t];if(I.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.shape.length),!$().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){let s=[],i=r.texData.get(e.dataId),a=i!==null&&i.isPacked,u=e;a&&(u=r.unpackTensor(e),s.push(u));let[l,p]=I.computeOutAndReduceShapes(u.shape,o),c=b.sizeFromShape(p),m=le({inputs:{x:u},backend:r,attrs:{shape:[-1,c]}});s.push(m);let d=vO(r,m,n);s.push(d);let f=le({inputs:{x:d},backend:r,attrs:{shape:l}});return s.forEach(h=>r.disposeIntermediateTensorInfo(h)),f}return SO(r,e,n)}function Ooe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=I.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ht({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=I.getInnerMostAxes(i.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let p=Ux(t,u,i[0],"max");return l.forEach(c=>t.disposeIntermediateTensorInfo(c)),p}var wO={kernelName:so,backendName:"webgl",kernelFunc:Ooe};function zoe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=I.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=Ht({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=I.getInnerMostAxes(i.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let p=Ux(t,u,i[0],"min");return l.forEach(c=>t.disposeIntermediateTensorInfo(c)),p}var _O={kernelName:Qa,backendName:"webgl",kernelFunc:zoe};var Goe=Mr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Uoe=_e({opSnippet:Goe}),AO={kernelName:Ei,backendName:"webgl",kernelFunc:Uoe};var Woe=Mr+"return log(x + sqrt(x * x + 1.0));",Koe=_e({opSnippet:Woe}),NO={kernelName:Ri,backendName:"webgl",kernelFunc:Koe};var Voe=Mr+`
  return atan(x);
`,joe=_e({opSnippet:Voe}),DO={kernelName:Li,backendName:"webgl",kernelFunc:joe};var Hoe=sO+`
  return atan(a, b);
`,qoe=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+aO+`
  return result;
`,Xoe=ct({opSnippet:Hoe,packedOpSnippet:qoe}),PO={kernelName:$i,backendName:"webgl",kernelFunc:Xoe};var Yoe=Mr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,Qoe=_e({opSnippet:Yoe}),MO={kernelName:Bi,backendName:"webgl",kernelFunc:Qoe};var Ti=class{constructor(e,t,n,o=!1,s=!1){this.variableNames=["x"];if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideHeight,u=e.strideWidth,l=e.dilationHeight,p=e.dilationWidth,c=e.effectiveFilterHeight,m=e.effectiveFilterWidth,d=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;let h=t==="avg",g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,x=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`,y="0.0";if(h||(y="-1.0 / 1e-20"),n){let P=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${u});
        const ivec2 pads = ivec2(${d}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${c};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${m};
                wC += ${p}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${P} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${o?s?g:x:`wR * ${m} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let T="max",k=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(k="avgValue / count");let C=Math.floor(i/4)*4,A=i%4,M=`
      if (${h}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${T}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${u});
      const ivec2 pads = ivec2(${d}, ${f});
      const float initializationValue = ${y};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${y});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${c};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${p};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              getValue(batch, xR, xC + 3 * ${p}, d)
            );

            ${M}
          }

          int xC = xCCorner + ${C};
          if (${A===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${M}
          } else if (${A===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              initializationValue,
              initializationValue
            );

            ${M}
          } else if (${A===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${p}, d),
              getValue(batch, xR, xC + 2 * ${p}, d),
              initializationValue
            );

            ${M}
          }
        }
        setOutput(${k});
      }
    `}},Rp=class{constructor(e,t,n,o=!1,s=!1){this.variableNames=["x"];if(t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let i=e.filterWidth,a=e.strideDepth,u=e.strideHeight,l=e.strideWidth,p=e.dilationDepth,c=e.dilationHeight,m=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,h=e.effectiveFilterWidth,g=e.padInfo.front,x=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;let T=t==="avg",k="0.0";if(T||(k="-1.0 / 1e-20"),n){let B=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${u}, ${l});
        const ivec3 pads = ivec3(${g}, ${x}, ${y});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${d};
              wD += ${p}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${c}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${h};
                  wC += ${m}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${B} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${o?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${h} +
                      wR * ${h} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let C="max",A=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(A="avgValue / count");let M=Math.floor(i/4)*4,P=i%4,F=`
      if (${T}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${u}, ${l});
      const ivec3 pads = ivec3(${g}, ${x}, ${y});
      const float initializationValue = ${k};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${k});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${p}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${M}; wC += 4) {
              int xC = xCCorner + wC * ${m};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                getValue(batch, xD, xR, xC + 3 * ${m}, ch)
              );

              ${F}
            }

            int xC = xCCorner + ${M};
            if (${P===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${P===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                initializationValue,
                initializationValue
              );

              ${F}
            } else if (${P===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${m}, ch),
                getValue(batch, xD, xR, xC + 2 * ${m}, ch),
                initializationValue
              );

              ${F}
            }
          }
          setOutput(${A});
        }
      }
    `}};function Zoe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;Oa(o,"avgPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(i,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,i,l,a,u);if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))return ar({inputs:{x:o},backend:t});let c=new Ti(p,"avg",!1);return t.runWebGLProgram(c,[o],"float32")}var FO={kernelName:ao,backendName:"webgl",kernelFunc:Zoe};function Joe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:u,dataFormat:l}=n,p=[1,1,1],c=I.computePool3DInfo(o.shape,s,i,p,a,u,l),m=new Rp(c,"avg",!1);return t.runWebGLProgram(m,[o],"float32")}var EO={kernelName:Eu,backendName:"webgl",kernelFunc:Joe};var I_=class{constructor(e){this.variableNames=["dy"];this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterHeight,l=e.effectiveFilterWidth,p=u-1-e.padInfo.top,c=l-1-e.padInfo.left,m=1/(t*n);this.userCode=`
      const ivec2 pads = ivec2(${p}, ${c});
      const float avgMultiplier = float(${m});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},C_=class{constructor(e){this.variableNames=["dy"];this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,c=e.effectiveFilterDepth,m=e.effectiveFilterHeight,d=e.effectiveFilterWidth,f=c-1-e.padInfo.front,h=m-1-e.padInfo.top,g=d-1-e.padInfo.left,x=1/(t*n*o);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${h}, ${g});
      const float avgMultiplier = float(${x});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${m};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${d};
                wC += ${p}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function ese(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:p}=n,c=[1,1,1],m=I.computePool3DInfo(i.shape,a,u,c,l,p),d=new C_(m);return t.runWebGLProgram(d,[o],i.dtype)}var RO={kernelName:ac,backendName:"webgl",kernelFunc:ese};function tse(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,i=s;Oa([o,s],"avgPoolGrad");let{filterSize:a,strides:u,pad:l}=n,p=I.computePool2DInfo(i.shape,a,u,1,l),c=new I_(p);return t.runWebGLProgram(c,[o],i.dtype)}var LO={kernelName:sc,backendName:"webgl",kernelFunc:tse};function rse(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:i,transposeB:a}=n;return Ep({a:o,b:s,transposeA:i,transposeB:a,backend:t})}var BO={kernelName:io,backendName:"webgl",kernelFunc:rse};var v_=class{constructor(e,t,n,o,s,i){this.outputShape=[];this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,n);let a="0.0";o!=null&&(I.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="1.0";s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${i}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var S_=class{constructor(e,t,n,o,s,i){this.packedInputs=!0;this.packedOutput=!0;this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,n);let a="vec4(0.0)";o!=null&&(I.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let u="vec4(1.0)";s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${i}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var nse=({inputs:r,backend:e,attrs:t})=>{let{x:n,mean:o,variance:s,offset:i,scale:a}=r;b.assert(o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),b.assert(i==null||o.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),b.assert(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=t;u==null&&(u=.001);let l=[n,o,s],p=null;i!=null&&(p=i.shape,l.push(i));let c=null;a!=null&&(c=a.shape,l.push(a));let m=$().getBool("WEBGL_PACK_NORMALIZATION")?new S_(n.shape,o.shape,s.shape,p,c,u):new v_(n.shape,o.shape,s.shape,p,c,u);return e.runWebGLProgram(m,l,l[0].dtype)},$O={kernelName:To,backendName:"webgl",kernelFunc:nse};var w_=class{constructor(e){this.variableNames=["source"];this.outputShape=e,this.rank=e.length;let t=je(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let n=ose(this.rank),o,s=e.map((i,a)=>`sourceLoc.${__[a]} = start[${a}] + coords.${__[a]};`);o=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${o}
        setOutput(getSource(${n}));
      }
    `}},__=["x","y","z","w","u","v"];function ose(r){if(r===1)return"sourceLoc";if(r<=6)return __.slice(0,r).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var A_=class{constructor(e){this.variableNames=["source"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];let t=je(this.rank),n=sr("coords",this.rank),o=sr("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${o.slice(-2).join()})`,i=`getChannel(getSource(${o.join()}), ${s})`,a=`
      result.x = ${i};
      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
        ++${o[this.rank-1]};
        result.y = ${i};
        --${o[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {
        ++${o[this.rank-2]};
        result.z = ${i};
        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {
          ++${o[this.rank-1]};
          result.w = ${i};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((p,c)=>`start[${c}]`).join()});`:e.map((p,c)=>`${o[c]} = ${n[c]} + start[${c}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${a}
        ${u}
        setOutput(result);
      }
    `}};function sse(r,e,t,n){let o=n.texData.get(r.dataId),s=n.makeTensorInfo(t,r.dtype),i=n.texData.get(s.dataId);Object.assign(i,o),i.refCount=1,i.shape=t,i.dtype=r.dtype;let a=Tt.computeFlatOffset(e,b.computeStrides(r.shape));o.slice&&(a+=o.slice.flatOffset),i.slice={flatOffset:a,origDataId:o.slice&&o.slice.origDataId||r.dataId};let u=n.dataRefCount.get(i.slice.origDataId)||1;return n.dataRefCount.set(i.slice.origDataId,u+1),s}function Wa(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:i}=n,[a,u]=Tt.parseSliceParams(o,s,i);if(Tt.assertParamsValid(o,a,u),b.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);if(t.shouldExecuteOnCPU([o])||o.dtype==="string"){let c=t.texData.get(o.dataId),m=_$(c.values,a,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,m)}let{isPacked:l}=t.texData.get(o.dataId),p=Tt.isSliceContinous(o.shape,a,u);if(l||!p){let c=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new A_(u):new w_(u),m=[a];return t.runWebGLProgram(c,[o],o.dtype,m)}return t.uploadToGPU(o.dataId),sse(o,a,u,t)}var OO={kernelName:Is,backendName:"webgl",kernelFunc:Wa};var ase=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:i}=n;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((y,T)=>y*T),u=I.getReshaped(o.shape,s,a),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,a),c=I.getSliceBeginCoords(i,s.length),m=I.getSliceSize(p,i,s.length),d=[],f=le({inputs:{x:o},backend:t,attrs:{shape:u}}),h=Ht({inputs:{x:f},backend:t,attrs:{perm:l}}),g=le({inputs:{x:h},backend:t,attrs:{shape:p}}),x=Wa({inputs:{x:g},backend:t,attrs:{begin:c,size:m}});return d.push(f),d.push(h),d.push(g),d.forEach(y=>t.disposeIntermediateTensorInfo(y)),x},zO={kernelName:ds,backendName:"webgl",kernelFunc:ase};function ise(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:i}=n,a=t.readSync(o.dataId),u=t.readSync(s.dataId),l=Fx(a,u,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,l)}var GO={kernelName:ic,backendName:"webgl",kernelFunc:ise};function use(r){let{inputs:e,backend:t}=r,{s0:n,s1:o}=e,s=t.readSync(n.dataId),i=t.readSync(o.dataId),a=I.assertAndGetBroadcastShape(Array.from(s),Array.from(i));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}var UO={kernelName:uc,backendName:"webgl",kernelFunc:use};var lse="return float(a != b);",N_=ct({opSnippet:lse,cpuKernelImpl:I$,dtype:"bool"}),WO={kernelName:ma,backendName:"webgl",kernelFunc:N_};function vu(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ar({inputs:{x:o.complexTensorInfos.real},backend:t})}var KO={kernelName:Wu,backendName:"webgl",kernelFunc:vu};var pse="return float(int(x));";function VO(r,e){let t=new Bn(r.shape,pse),n=e.runWebGLProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function D_(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return ar({inputs:{x:o},backend:t});let i=xt(o.shape),a=D_({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=$n({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeIntermediateTensorInfo(a),u}if(o.dtype==="complex64"){let i=vu({inputs:{input:o},backend:t}),a=D_({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(i),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=ar({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32")return VO(o,t);if(s==="bool"){let i=t.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),u=N_({inputs:{a:o,b:i},backend:t});return t.disposeIntermediateTensorInfo(i),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var jO={kernelName:Kn,backendName:"webgl",kernelFunc:D_};var HO="return ceil(x);",cse=_e({opSnippet:HO,packedOpSnippet:HO,cpuKernelImpl:n$}),qO={kernelName:uo,backendName:"webgl",kernelFunc:cse};var P_=class{constructor(e){this.variableNames=["A"];this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}};var M_=class{constructor(e){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}];this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}};function mse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:i}=n,a;$().getBool("WEBGL_PACK_CLIP")?a=new M_(o.shape):a=new P_(o.shape);let u=[[s],[i]];return t.runWebGLProgram(a,[o],o.dtype,u)}var XO={kernelName:Vn,backendName:"webgl",kernelFunc:mse};var F_=class{constructor(e){this.variableNames=["real","imag"];this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function YO(r,e){return{dataId:e.dataId,dtype:e.dtype,shape:r.shape}}function dse(r){let{inputs:e,backend:t}=r,{x:n}=e,o=t.texData.get(n.dataId),s=new F_(n.shape),i=[YO(n,o.complexTensorInfos.real),YO(n,o.complexTensorInfos.imag)];return t.runWebGLProgram(s,i,i[0].dtype)}var QO={kernelName:Lu,backendName:"webgl",kernelFunc:dse};var E_=class{constructor(e){this.outputShape=[];this.outputShape=I.computeOutShape(e,1),this.variableNames=e.map((i,a)=>`T${a}`);let t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];let n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){let a=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${a}));`)}let o=t.length,s=t[t.length-1];n.push(`else setOutput(getT${o}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var R_=class{constructor(e,t){this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];this.outputShape=I.computeOutShape(e,t);let n=this.outputShape,o=n.length,s=je(o),i=sr("coords",o),a=["x","y","z","w","u","v"].slice(0,o);this.variableNames=e.map((h,g)=>`T${g}`);let u=new Array(e.length-1);u[0]=e[0][t];for(let h=1;h<u.length;h++)u[h]=u[h-1]+e[h][t];let l=a[t],p=a.slice(-2),c=a.join(),m=`if (${l} < ${u[0]}) {
        return getChannel(
            getT0(${c}), vec2(${p.join()}));
        }`;for(let h=1;h<u.length;h++){let g=u[h-1];m+=`
        if (${l} < ${u[h]}  && ${l} >= ${u[h-1]}) {
          return getChannel(
            getT${h}(${Wx(a,l,g)}),
            vec2(${Wx(p,l,g)}));
        }`}let d=u.length,f=u[u.length-1];m+=`
        return getChannel(
          getT${d}(${Wx(a,l,f)}),
          vec2(${Wx(p,l,f)}));`,this.userCode=`
      float getValue(${a.map(h=>"int "+h)}) {
        ${m}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${i}), 0., 0., 0.);

        ${i[o-1]} = ${i[o-1]} + 1;
        if (${i[o-1]} < ${n[o-1]}) {
          result.g = getValue(${i});
        }

        ${i[o-2]} = ${i[o-2]} + 1;
        if (${i[o-2]} < ${n[o-2]}) {
          result.a = getValue(${i});
        }

        ${i[o-1]} = ${i[o-1]} - 1;
        if (${i[o-2]} < ${n[o-2]} &&
            ${i[o-1]} < ${n[o-1]}) {
          result.b = getValue(${i});
        }
        setOutput(result);
      }
    `}};function Wx(r,e,t){let n=r.indexOf(e);return r.map((s,i)=>i===n?`${s} - ${t}`:s).join()}function Lp(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.texData.get(n.dataId);return ar({inputs:{x:o.complexTensorInfos.imag},backend:t})}var ZO={kernelName:zu,backendName:"webgl",kernelFunc:Lp};function Bp(r,e,t){let n=r[0].dtype;if(n==="complex64"){let p=r.map(h=>vu({inputs:{input:h},backend:t})),c=r.map(h=>Lp({inputs:{input:h},backend:t})),m=Bp(p,e,t),d=Bp(c,e,t),f=$n({inputs:{real:m,imag:d},backend:t});return p.forEach(h=>t.disposeIntermediateTensorInfo(h)),c.forEach(h=>t.disposeIntermediateTensorInfo(h)),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d),f}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let p=r.map(x=>{let y=b.sizeFromShape(x.shape.slice(e));return le({inputs:{x},backend:t,attrs:{shape:[-1,y]}})}),c=p.map(x=>({vals:t.readSync(x.dataId),shape:x.shape})),m=I.computeOutShape(p.map(x=>x.shape),1),d=p[0].shape[0]===1,f=o$(c,m,n,d),h=I.computeOutShape(r.map(x=>x.shape),e),g=t.makeTensorInfo(h,n,f);return p.forEach(x=>t.disposeIntermediateTensorInfo(x)),g}if(r.length>$().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let p=Math.floor(r.length/2),c=Bp(r.slice(0,p),e,t),m=Bp(r.slice(p),e,t),d=Bp([c,m],e,t);return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),d}if($().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let p=new R_(r.map(c=>c.shape),e);return t.runWebGLProgram(p,r,n)}let{tensors2D:s,outShape:i}=fse(r,e,t),a=new E_(s.map(p=>p.shape)),u=t.runWebGLProgram(a,s,n);s.forEach(p=>t.disposeIntermediateTensorInfo(p));let l=le({inputs:{x:u},attrs:{shape:i},backend:t});return t.disposeIntermediateTensorInfo(u),l}function fse(r,e,t){let n=I.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>le({inputs:{x:s},attrs:{shape:[-1,b.sizeFromShape(s.shape.slice(e))]},backend:t})),outShape:n}}function L_(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,e[0].shape)[0],i=I.computeOutShape(e.map(l=>l.shape),s);if(b.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let a=e.filter(l=>b.sizeFromShape(l.shape)>0);if(a.length===1)return ar({inputs:{x:a[0]},backend:t});let u=a.map(l=>l.shape);return I.assertParamsConsistent(u,s),Bp(a,s,t)}var JO={kernelName:fs,backendName:"webgl",kernelFunc:L_};var ug=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.outputShape=e.outShape;let i=e.padInfo.top,a=e.padInfo.left,u=e.strideHeight,l=e.strideWidth,p=e.dilationHeight,c=e.dilationWidth,m=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4,g=e.dataFormat==="channelsLast",x=g?1:2,y=g?2:3,T=g?3:1,k="",C="";n&&(o?k=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?k=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:k=`
          float activation(float x) {
            ${n}
          }
        `,C="result = activation(result);");let A=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${k}

      const ivec2 strides = ivec2(${u}, ${l});
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${T}];

        ivec2 xRCCorner =
            ivec2(coords[${x}], coords[${y}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${m}; wR++) {
          int xR = xRCorner + wR * ${p};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${d}; wC++) {
            int xC = xCCorner + wC * ${c};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${g}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${h===1}) {

              if (${g}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${h===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${g}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${h===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${g}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${A}
        ${C}
        setOutput(result);
      }
    `}},B_=class{constructor(e){this.variableNames=["x","W"];this.outputShape=e.outShape;let t=e.padInfo.front,n=e.padInfo.top,o=e.padInfo.left,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=e.dilationDepth,l=e.dilationHeight,p=e.dilationWidth,c=e.filterDepth,m=e.filterHeight,d=e.filterWidth,f=Math.floor(e.inChannels/4)*4,h=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${i}, ${a});
      const ivec3 pads = ivec3(${t}, ${n}, ${o});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${c}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${m}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d}; wC++) {
              int xC = xCCorner + wC * ${p};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${h===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${h===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${h===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var $_=class{constructor(e,t){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}];this.outputShape=e,this.enableShapeUniforms=Bt(this.outputShape.length);let{dataFormat:n}=t,o=Qt(),s=n==="channelsLast",i=s?0:1,a=s?1:2,u=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`,l="";for(let p=0;p<=1;p++)for(let c=0;c<=1;c++)l+=`
          blockIndex = rc.y + ${c};
          pos = rc.x + ${p};

          ${u}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${i}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${p*2+c}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${p*2+c}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${o.output} = result;
      }
    `}};function Kx({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=n.texData.get(r.dataId),p=t.inChannels,c=u[0]*u[1]*u[2],m=t.outChannels,d=t.dataFormat==="channelsLast",f=!1,h=!1,g,x=[];if(!((c===1||m===1)&&p>b_)&&l.isPacked&&d&&l.texture!=null&&u[2]%2!=0&&b.arraysEqual(l.shape.slice(-3),u.slice(-3))){let k=u[0]*u[1]*(u[2]+1),C={dataId:r.dataId,shape:[1,k,t.inChannels],dtype:r.dtype},A=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,b.assert(hl(l.shape,C.shape),()=>`packed reshape ${l.shape} to ${C.shape} isn't free`);let M=le({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});x.push(M);let P=Ep({a:C,b:M,backend:n,transposeA:f,transposeB:h,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),F=n.texData.get(P.dataId);b.assert(F.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=A,F.shape=t.outShape,g=ar({inputs:{x:P},backend:n}),g.shape=t.outShape,x.push(P)}else{let k=d?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],C=le({inputs:{x:r},backend:n,attrs:{shape:[1,k,t.inChannels]}}),A=le({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),M=Ep({a:C,b:A,transposeA:f,transposeB:h,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i});g=le({inputs:{x:M},backend:n,attrs:{shape:t.outShape}}),x.push(C),x.push(A),x.push(M)}for(let k of x)n.disposeIntermediateTensorInfo(k);return g}function Vx({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:p,outWidth:c,outHeight:m,dataFormat:d}=t,f=d==="channelsLast",h=u*l*p,g=m*c,x=[h,g],y=!0,T=!1,k=[],C=le({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),A=le({inputs:{x:e},backend:n,attrs:{shape:[1,h,b.sizeFromShape(e.shape)/h]}});k.push(C),k.push(A);let M=new $_(x,t),P=[C.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],F=n.runWebGLProgram(M,[C],"float32",P),B=le({inputs:{x:F},backend:n,attrs:{shape:[1,x[0],x[1]]}});k.push(F),k.push(B);let U=o!=null,W=s!=null,K=a==="leakyrelu",j=a?bl(a,!0):null,V=new ag(B.shape,A.shape,[1,g,t.outChannels],y,T,U,j,W,K),q=[B,A];if(o&&q.push(o),W&&q.push(s),K){let oe=n.makeTensorInfo([],"float32",b.createScalarValue(i,"float32"));q.push(oe),k.push(oe)}let ee=n.runWebGLProgram(V,q,"float32"),Z=f?[1,m,c,t.outChannels]:[1,t.outChannels,m,c],te=le({inputs:{x:ee},backend:n,attrs:{shape:Z}});k.push(ee);for(let oe of k)n.disposeIntermediateTensorInfo(oe);return te}function hse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:p}=n,c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,s.shape,i,l,a,p,!1,c),d;if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))d=Kx({x:o,filter:s,convInfo:m,backend:t});else if($().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)d=Vx({x:o,filter:s,convInfo:m,backend:t});else{let h=new ug(m);d=t.runWebGLProgram(h,[o,s],"float32")}let f=le({inputs:{x:d},backend:t,attrs:{shape:m.outShape}});return t.disposeIntermediateTensorInfo(d),f}var ez={kernelName:lo,backendName:"webgl",kernelFunc:hse};var O_=class{constructor(e){this.variableNames=["x","dy"];this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${i}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},z_=class{constructor(e){this.variableNames=["dy","W"];this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,u=n-1-e.padInfo.left,l=i?1:2,p=i?2:3,c=i?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${c}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${p}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${i}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},G_=class{constructor(e){this.variableNames=["x","dy"];this.outputShape=e.filterShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${i};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${o} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},U_=class{constructor(e){this.variableNames=["dy","W"];this.outputShape=e.inShape;let t=e.filterDepth,n=e.filterHeight,o=e.filterWidth,s=e.strideDepth,i=e.strideHeight,a=e.strideWidth,u=t-1-e.padInfo.front,l=n-1-e.padInfo.top,p=o-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${l}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${i}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${o}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${o} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function gse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:p}=n,c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,p,i,1,a,l,!1,c),d=new O_(m);return t.runWebGLProgram(d,[o,s],"float32")}var tz={kernelName:lc,backendName:"webgl",kernelFunc:gse};function bse(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:p}=n,c=I.convertConv2DDataFormat(l),m=I.computeConv2DInfo(i,s.shape,a,1,u,p,!1,c),d=new z_(m);return t.runWebGLProgram(d,[o,s],"float32")}var rz={kernelName:po,backendName:"webgl",kernelFunc:bse};function yse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u}=n,l=I.computeConv3DInfo(o.shape,s.shape,i,u,a),p=new B_(l);return t.runWebGLProgram(p,[o,s],"float32")}var nz={kernelName:Bu,backendName:"webgl",kernelFunc:yse};function xse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,pad:a,filterShape:u}=n,l=I.computeConv3DInfo(o.shape,u,i,1,a),p=new G_(l);return t.runWebGLProgram(p,[o,s],"float32")}var oz={kernelName:pc,backendName:"webgl",kernelFunc:xse};function Tse(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{pad:i,strides:a,inputShape:u}=n,l=I.computeConv3DInfo(u,s.shape,a,1,i),p=new U_(l);return t.runWebGLProgram(p,[o,s],"float32")}var sz={kernelName:cc,backendName:"webgl",kernelFunc:Tse};var kse=$x+`
  return cos(x);
`,Ise=_e({opSnippet:kse}),az={kernelName:co,backendName:"webgl",kernelFunc:Ise};var Cse=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,vse=_e({opSnippet:Cse}),iz={kernelName:mo,backendName:"webgl",kernelFunc:vse};var W_=class{constructor(e,t,n,o,s){this.variableNames=["Image","Boxes","BoxInd"];this.outputShape=[];let[i,a,u,l]=e,[p]=t,[c,m]=n;this.outputShape=[p,c,m,l];let d=o==="bilinear"?1:0,[f,h]=[`${a-1}.0`,`${u-1}.0`],[g,x,y]=c>1?[`${(a-1)/(c-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[T,k,C]=m>1?[`${(u-1)/(m-1)}`,"(x2-x1) * width_ratio",`x1*${h} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${h}`];this.userCode=`
      const float height_ratio = float(${g});
      const float width_ratio = float(${T});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${i}) {
          return;
        }

        float height_scale = ${x};
        float width_scale = ${k};

        float in_y = ${y};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${h} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${d} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var Sse=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=n,p=new W_(o.shape,s.shape,a,u,l);return t.runWebGLProgram(p,[o,s,i],"float32")},uz={kernelName:ra,backendName:"webgl",kernelFunc:Sse};var jx=class{constructor(e,t,n){this.variableNames=["x"];this.customUniforms=[{name:"index",type:"float"}];this.outputShape=e;let o=e.length,s=t?"0.0":`getX(${lz(o,"coords")})`,i=e[e.length-1],a="",u="";t?(a=n?`end != ${i-1}`:"end != 0",u=n?"end + 1":"end - 1"):(a=n?`end + pow2 < ${i}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${je(o)} coords = getOutputCoords();
        int end = ${pz(o,"coords")};
        float val = ${s};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${u};
          ${pz(o,"coords")} = idx;
          val += getX(${lz(o,"coords")});
        }
        setOutput(val);
      }
    `}};function lz(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.x, ${e}.y`;if(r===3)return`${e}.x, ${e}.y, ${e}.z`;if(r===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function pz(r,e){if(r===1)return`${e}`;if(r===2)return`${e}.y`;if(r===3)return`${e}.z`;if(r===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function wse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length,l=I.getAxesPermutation([s],u),p=o;l!=null&&(p=Ht({inputs:{x:o},backend:t,attrs:{perm:l}}));let c=I.getInnerMostAxes(1,u)[0];if(c!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${o.shape.length-1} but got axis=${s}`);let m=p.shape[c],d=ar({inputs:{x:p},backend:t});for(let f=0;f<=Math.ceil(Math.log2(m))-1;f++){let h=new jx(p.shape,!1,a),g=[[f]],x=d;d=t.runWebGLProgram(h,[d],d.dtype,g),t.disposeIntermediateTensorInfo(x)}if(i){let f=new jx(p.shape,i,a),h=d;d=t.runWebGLProgram(f,[d],d.dtype),t.disposeIntermediateTensorInfo(h)}if(l!=null){let f=I.getUndoAxesPermutation(l),h=Ht({inputs:{x:d},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),h}return d}var cz={kernelName:ta,backendName:"webgl",kernelFunc:wse};function _se(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,weights:s}=e,{size:i,binaryOutput:a}=n;if(o.shape.length===1){let u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=Fx(u,l,s.dtype,s.shape,i);return t.makeTensorInfo([i],s.dtype,p)}else if(o.shape.length===2){let u=t.bufferSync(o),l=t.bufferSync(s),p=r$(u,l,i,a);return t.makeTensorInfo(p.shape,s.dtype,p.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${o.shape.length}.`)}var mz={kernelName:mc,backendName:"webgl",kernelFunc:_se};var K_=class{constructor(e,t,n){this.variableNames=["x"];this.outputShape=[];this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Ase(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],p=i==="NHWC"?o.shape[3]:o.shape[1],c=u*s,m=l*s,d=p/(s*s),f=i==="NHWC"?[a,c,m,d]:[a,d,c,m],h=new K_(f,s,i);return t.runWebGLProgram(h,[o],o.dtype)}var dz={kernelName:na,backendName:"webgl",kernelFunc:Ase};var lg=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=e.outShape,this.enableShapeUniforms=Bt(this.outputShape.length);let i=e.filterHeight,a=e.filterWidth,u=e.outChannels/e.inChannels,l="",p="";n&&(o?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:l=`
          float activation(float x) {
            ${n}
          }
        `,p="result = activation(result);");let c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${u};
        int q = d2 - d1 * ${u};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${i}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${c}
        ${p}
        setOutput(result);
      }
    `}};var pg=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}];this.outputShape=e.outShape,this.enableShapeUniforms=Bt(this.outputShape.length);let i=e.outChannels/e.inChannels,a=e.padInfo.left,u=e.strideWidth,l=e.dilationWidth,p=e.filterHeight,c=e.filterWidth,m=c,d=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let x=0;x<c;x++)d+=`
          vec4 xTexelC${x*2};
          int xTexelC${x*2}Ready;
          vec4 xTexelC${x*2+1};
          int xTexelC${x*2+1}Ready;
          vec4 xC${x};`;d+=`
    for (int r = 0; r < ${p}; r++) {
      `;for(let x=0;x<c;x++)d+=`
          xTexelC${x*2} = vec4(0.0);
          xTexelC${x*2}Ready = 0;
          xTexelC${x*2+1} = vec4(0.0);
          xTexelC${x*2+1}Ready = 0;
          xC${x} = vec4(0.0);`;d+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let x=0;x<(m+1)/2;x++){let y=x*2;if(d+=`
          xC = xCCorner + ${y*l};
          `,u===1){if(y<c&&(a%2==1?(d+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }
              `,l===1&&y>0?d+=`
                xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                `:d+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                  } else {
                    xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                  }
                  `):d+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xC${y} = xTexelC${y};
                `,y+1<c)){let T=a%2==0?b.nearestLargerEven(l):l;l%2==0&&a%2==1||l%2!=0&&a%2!=1?(d+=`
                  xCOffset = xC + imod(pads[1], 2) + ${T};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                    xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${y+1}.zw = vec2(0.0);
                    }
                    xTexelC${y+1}Ready = 1;
                  }
                  `,l>1&&(d+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                      xTexelC${y} = getX(batch, xR, xCOffset, d1);
                      xTexelC${y}Ready = 1;
                    }
                    `),d+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                  `):T===1?d+=`
                    xC${y+1} = xTexelC${y};
                    `:d+=`
                    xCOffset = xC + ${T};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                      xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${y+1}.zw = vec2(0.0);
                      }
                      xTexelC${y+1}Ready = 1;
                    }

                    xC${y+1} = xTexelC${y+1};
                    `}}else y<c&&(a%2==1?(d+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.0);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
              `,y+1<c&&(d+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                `)):(d+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                  xTexelC${y} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${y}.zw = vec2(0.0);
                  }
                  xTexelC${y}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                  xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${y+1}.zw = vec2(0.);
                  }
                  xTexelC${y+1}Ready = 1;
                }

                xC${y} = vec4(
                  xTexelC${y}.xy, xTexelC${y+1}.xy);
              `,y+1<c&&(d+=`
                  xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                `)));y<c&&(d+=`
            wTexel = getW(r, ${y}, d1, q);
            dotProd += xC${y} * vec4(wTexel.xz, wTexel.xz);
          `,y+1<c&&(d+=`
              wTexel = getW(r, ${y+1}, d1, q);
              dotProd += xC${y+1} * vec4(wTexel.xz, wTexel.xz);
            `))}d+=`
    }
  `,d+=`
      }
    `;let f="",h="";n&&(o?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:s?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:f=`vec4 activation(vec4 x) {
          ${n}
        }`,h="result = activation(result);");let g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${i};
        int q = d2 - d1 * ${i};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${d}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${g}
        ${h}
        setOutput(result);
      }
    `}};function Nse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,p=u;p==null&&(p=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(i,p),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${i} and dilations '${p}'`);let c=I.computeConv2DInfo(o.shape,s.shape,i,p,a,l,!0),m;$().getBool("WEBGL_PACK_DEPTHWISECONV")&&c.strideWidth<=2&&c.outChannels/c.inChannels==1?m=new pg(c):m=new lg(c);let d=[[c.padInfo.top,c.padInfo.left],[c.strideHeight,c.strideWidth],[c.dilationHeight,c.dilationWidth],[c.inHeight,c.inWidth]];return t.runWebGLProgram(m,[o,s],"float32",d)}var fz={kernelName:fo,backendName:"webgl",kernelFunc:Nse};var V_=class{constructor(e){this.variableNames=["x","dy"];this.outputShape=e.filterShape;let t=e.strideHeight,n=e.strideWidth,o=e.padInfo.top,s=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${i} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${o};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},j_=class{constructor(e){this.variableNames=["dy","W"];this.outputShape=e.inShape;let t=e.filterHeight,n=e.filterWidth,o=e.strideHeight,s=e.strideWidth,i=t-1-e.padInfo.top,a=n-1-e.padInfo.left,u=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${o}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Dse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,dy:s}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:p}=n,c=I.computeConv2DInfo(o.shape,p,i,a,u,l,!0),m=new V_(c);return t.runWebGLProgram(m,[o,s],"float32")}var hz={kernelName:dc,backendName:"webgl",kernelFunc:Dse};function Pse(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:p}=n,c=I.computeConv2DInfo(p,s.shape,i,a,u,l,!0),m=new j_(c);return t.runWebGLProgram(m,[o,s],"float32")}var gz={kernelName:fc,backendName:"webgl",kernelFunc:Pse};var H_=class{constructor(e){this.variableNames=["X"];this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function Mse(r){let{inputs:e,backend:t}=r,{x:n}=e,o=[...n.shape,...n.shape],s=b.sizeFromShape(n.shape),i=le({inputs:{x:n},backend:t,attrs:{shape:[s]}}),a=new H_(s),u=t.runWebGLProgram(a,[i],i.dtype),l=le({inputs:{x:u},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(u),l}var bz={kernelName:hc,backendName:"webgl",kernelFunc:Mse};var q_=class{constructor(e){this.variableNames=["x","W"];this.outputShape=e.outShape;let{inHeight:t,inWidth:n,padInfo:o,strideHeight:s,strideWidth:i,filterHeight:a,filterWidth:u,dilationHeight:l,dilationWidth:p}=e,{top:c,left:m}=o;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${i});
      const ivec2 pads = ivec2(${c}, ${m});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${p};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function Fse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u}=n,l=I.computeDilation2DInfo(o.shape,s.shape,i,a,"NHWC",u),p,c=new q_(l);p=t.runWebGLProgram(c,[o,s],"float32");let m=le({inputs:{x:p},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(p),m}var yz={kernelName:$u,backendName:"webgl",kernelFunc:Fse};function Ese(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:i,summedDims:a,idDims:u}=I.decodeEinsumEquation(o,s.length);I.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:p}=I.getEinsumComputePath(a,u),c=p.length,m=null,d=i.length,f=[];for(let h=0;h<c;++h){for(let g of p[h]){let{permutationIndices:x,expandDims:y}=I.getEinsumPermutation(d,u[g]),T;I.isIdentityPermutation(x)?T=s[g]:(T=Ht({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),f.push(T));let k=T.shape.slice();for(let C=0;C<y.length;++C)k.splice(y[C],0,1);b.arraysEqual(T.shape,k)||(T=le({inputs:{x:T},backend:t,attrs:{shape:k}}),f.push(T)),m===null?m=T:(m=ig({inputs:{a:T,b:m},backend:t}),f.push(m))}h<c-1&&(l[h]>=0&&(m=Fp({inputs:{x:m},backend:t,attrs:{axis:l[h]-(i.length-d),keepDims:!1}}),f.push(m)),d--)}for(let h of f)h!==m&&t.disposeIntermediateTensorInfo(h);return m}var xz={kernelName:Ou,backendName:"webgl",kernelFunc:Ese};var Rse="return (x >= 0.0) ? x : (exp(x) - 1.0);",Lse=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Bse=_e({opSnippet:Rse,packedOpSnippet:Lse}),Tz={kernelName:go,backendName:"webgl",kernelFunc:Bse};var $se="return (b >= 1.0) ? a : a * (b + 1.0);",Ose=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,zse=r=>{let{inputs:e,backend:t}=r,{dy:n,y:o}=e,s=$().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ua(Ose,n.shape,o.shape):new Qs($se,n.shape,o.shape);return t.runWebGLProgram(s,[n,o],n.dtype)},kz={kernelName:gc,backendName:"webgl",kernelFunc:zse};var Gse=`
  return vec4(equal(a, b));
`,Use="return float(a == b);",Wse=ct({opSnippet:Use,packedOpSnippet:Gse,dtype:"bool",cpuKernelImpl:s$}),Iz={kernelName:oa,backendName:"webgl",kernelFunc:Wse};var Kse=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${I.ERF_P};
  float a1 = ${I.ERF_A1};
  float a2 = ${I.ERF_A2};
  float a3 = ${I.ERF_A3};
  float a4 = ${I.ERF_A4};
  float a5 = ${I.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Vse=_e({opSnippet:Kse}),Cz={kernelName:Oi,backendName:"webgl",kernelFunc:Vse};var vz="return exp(x);",X_=_e({opSnippet:vz,packedOpSnippet:vz,cpuKernelImpl:a$,dtype:"float32"}),Sz={kernelName:bo,backendName:"webgl",kernelFunc:X_};function Hx(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(b.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),le({inputs:{x:s},backend:n,attrs:{shape:a}})}var wz={kernelName:hs,backendName:"webgl",kernelFunc:Hx};var _z="return exp(x) - 1.0;",jse=_e({opSnippet:_z,packedOpSnippet:_z,cpuKernelImpl:i$}),Az={kernelName:sa,backendName:"webgl",kernelFunc:jse};var qx=class{constructor(e,t,n){this.variableNames=["real","imag"];let o=t[1];this.outputShape=t;let s=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${o}.0`:"1.0",a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${o});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${o}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${i};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function Xx(r,e,t){let n=t.texData.get(r.dataId),o=b.sizeFromShape(r.shape),s=r.shape[r.shape.length-1],i=o/s,a=le({inputs:{x:r},backend:t,attrs:{shape:[i,s]}}),u=a.shape,l=new qx("real",u,e),p=new qx("imag",u,e),c=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],m=t.runWebGLProgram(l,c,"float32"),d=t.runWebGLProgram(p,c,"float32"),f=$n({inputs:{real:m,imag:d},backend:t});t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d);let h=le({inputs:{x:f},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),h}function Hse(r){let{inputs:e,backend:t}=r,{input:n}=e;return Xx(n,!1,t)}var Nz={kernelName:bc,backendName:"webgl",kernelFunc:Hse};var Y_=class{constructor(e,t){this.outputShape=[];this.customUniforms=[{name:"value",type:"float"}];this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}};function Su(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||b.inferDtype(o),s==="string"){let i=b.getArrayFromDType(s,b.sizeFromShape(n));return i.fill(o),e.makeTensorInfo(n,s,i)}else{let i=new Y_(n,o),a=[[o]];return e.runWebGLProgram(i,[],s,a)}}var Dz={kernelName:Za,backendName:"webgl",kernelFunc:Su};var Q_=class{constructor(e){this.variableNames=["Image"];this.outputShape=[];let t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var Pz={kernelName:aa,backendName:"webgl",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new Q_(t.shape);return n.runWebGLProgram(o,[t],t.dtype)}};var Mz="return floor(x);",qse=_e({opSnippet:Mz,packedOpSnippet:Mz,cpuKernelImpl:u$}),Fz={kernelName:yo,backendName:"webgl",kernelFunc:qse};var Xse=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Yse=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,Qse=ct({opSnippet:Xse,packedOpSnippet:Yse,dtype:"int32"}),Ez={kernelName:xo,backendName:"webgl",kernelFunc:Qse};var Z_=class{constructor(e){this.variableNames=["A"];let t=Qt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${o}.0, ${n}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var J_=class{constructor(e){this.variableNames=["A"];this.packedInputs=!1;this.packedOutput=!0;let t=Qt(),[n,o]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${o}.0, ${n}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}};var Rz={kernelName:Dl,backendName:"webgl",kernelFunc:Zse},Km;function Zse(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n,i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,[u,l]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],p=[l,u],c=[l,u,s];(a||i)&&(Km==null&&(Km=document.createElement("canvas").getContext("2d")),Km.canvas.width=u,Km.canvas.height=l,Km.drawImage(o,0,0,u,l),o=Km.canvas);let m=t.makeTensorInfo(p,"int32");t.texData.get(m.dataId).usage=sn.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(m.dataId),o);let d=$().getBool("WEBGL_PACK")?new J_(c):new Z_(c),f=t.runWebGLProgram(d,[m],"int32");return t.disposeData(m.dataId),f}function Jse(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:d,leakyreluAlpha:f}=n,h=I.convertConv2DDataFormat(p),g=I.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!1,h),x,y=[];if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))x=Kx({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:f});else if($().getBool("WEBGL_CONV_IM2COL")&&o.shape[0]===1)x=Vx({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:f});else{let k=i!=null,C=a!=null,A=d==="leakyrelu",M=d?bl(d,!1):null,P=new ug(g,k,M,C,A),F=[o,s];if(i&&F.push(i),a&&F.push(a),A){let B=t.makeTensorInfo([],"float32",b.createScalarValue(f,"float32"));F.push(B),y.push(B)}x=t.runWebGLProgram(P,F,"float32")}let T=le({inputs:{x},backend:t,attrs:{shape:g.outShape}});return y.push(x),y.forEach(k=>t.disposeIntermediateTensorInfo(k)),T}var Lz={kernelName:Ns,backendName:"webgl",kernelFunc:Jse};function eae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:c,activation:m,leakyreluAlpha:d}=n,f=[],h=p;h==null&&(h=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(u,h),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${h}'`);let g=I.computeConv2DInfo(o.shape,s.shape,u,h,l,c,!0),x=$().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels==1,y=m?bl(m,x):null,T=[o,s],k=i!=null,C=a!=null,A=m==="leakyrelu";if(k&&T.push(i),C&&T.push(a),A){let B=t.makeTensorInfo([],"float32",b.createScalarValue(d,"float32"));T.push(B),f.push(B)}let M;x?M=new pg(g,k,y,C,A):M=new lg(g,k,y,C,A);let P=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],F=t.runWebGLProgram(M,T,"float32",P);return f.forEach(B=>t.disposeIntermediateTensorInfo(B)),F}var Bz={kernelName:Ds,backendName:"webgl",kernelFunc:eae};var eA=class{constructor(e,t,n){this.sliceDim=e;this.strides=t;this.variableNames=["x","indices"];this.outputShape=n;let o=je(t.length),s=je(n.length),i=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${o} strides = ${o}(${this.strides});
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${i};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function tae(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,i=s[s.length-1],a=b.sizeFromShape(n.shape),[u,l,p,c]=I.prepareAndValidate(n,o),m=le({inputs:{x:o},backend:t,attrs:{shape:[l,i]}}),d=le({inputs:{x:n},backend:t,attrs:{shape:[b.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let x=t.readSync(o.dataId),y=t.bufferSync(n),T=l$(x,y,n.dtype,l,i,p,c,n.shape,a);return t.makeTensorInfo(u,n.dtype,T.values)}let f=new eA(i,c,[l,p]),h=t.runWebGLProgram(f,[d,m],d.dtype),g=le({inputs:{x:h},backend:t,attrs:{shape:u}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),g}var $z={kernelName:ia,backendName:"webgl",kernelFunc:tae};var tA=class{constructor(e,t){this.variableNames=["A","indices"];this.outputShape=t,this.rank=t.length;let n=je(this.rank),o=rae(e,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function rae(r,e){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push("int(getIndices(resRC.x, resRC.z))"):n.push(`${t[o]}`);return n.join()}function rA(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n,u=b.parseAxisParam(i,o.shape)[0],l=t.readSync(s.dataId),p=o.shape[u];for(let k=0;k<l.length;++k){let C=l[k];b.assert(C<=p-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${p-1}]`)}let c=I.segment_util.collectGatherOpShapeInfo(o,s,u,a),m=b.sizeFromShape(s.shape),d=[],f=le({inputs:{x:o},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),h=le({inputs:{x:s},backend:t,attrs:{shape:[c.batchSize,m/c.batchSize]}});d.push(f),d.push(h);let g=[c.batchSize,c.outerSize,m/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([o,s])||o.dtype==="string"){let k=t.bufferSync(h),C=t.bufferSync(f),A=p$(C,k,g);return d.forEach(M=>t.disposeIntermediateTensorInfo(M)),t.makeTensorInfo(c.outputShape,A.dtype,A.values)}let x=new tA(f.shape,g),y=t.runWebGLProgram(x,[f,h],f.dtype);d.push(y);let T=le({inputs:{x:y},backend:t,attrs:{shape:c.outputShape}});return d.forEach(k=>t.disposeIntermediateTensorInfo(k)),T}var Oz={kernelName:gs,backendName:"webgl",kernelFunc:rA};var nae="return float(a > b);",oae=`
  return vec4(greaterThan(a, b));
`,sae=ct({opSnippet:nae,packedOpSnippet:oae,cpuKernelImpl:c$,dtype:"bool"}),zz={kernelName:ua,backendName:"webgl",kernelFunc:sae};var aae="return float(a >= b);",iae=`
  return vec4(greaterThanEqual(a, b));
`,uae=ct({opSnippet:aae,packedOpSnippet:iae,dtype:"bool",cpuKernelImpl:m$}),Gz={kernelName:ko,backendName:"webgl",kernelFunc:uae};function lae(r){let{inputs:e,backend:t}=r,{input:n}=e;return Xx(n,!0,t)}var Uz={kernelName:yc,backendName:"webgl",kernelFunc:lae};var pae="return float(!isnan(x) && !isinf(x));",cae=_e({opSnippet:pae,dtype:"bool"}),Wz={kernelName:zi,backendName:"webgl",kernelFunc:cae};var mae="return float(isinf(x));",dae=_e({opSnippet:mae,dtype:"bool"}),Kz={kernelName:Gi,backendName:"webgl",kernelFunc:dae};var fae="return float(isnan(x));",hae=_e({opSnippet:fae,dtype:"bool"}),Vz={kernelName:Ui,backendName:"webgl",kernelFunc:hae};var gae="return float(a < b);",bae=`
  return vec4(lessThan(a, b));
`,yae=ct({opSnippet:gae,packedOpSnippet:bae,cpuKernelImpl:d$,dtype:"bool"}),jz={kernelName:la,backendName:"webgl",kernelFunc:yae};var xae="return float(a <= b);",Tae=`
  return vec4(lessThanEqual(a, b));
`,kae=ct({opSnippet:xae,packedOpSnippet:Tae,cpuKernelImpl:f$,dtype:"bool"}),Hz={kernelName:pa,backendName:"webgl",kernelFunc:kae};function Iae(r){let{backend:e,attrs:t}=r,{start:n,stop:o,num:s}=t,i=h$(n,o,s);return e.makeTensorInfo([i.length],"float32",i)}var qz={kernelName:xc,backendName:"webgl",kernelFunc:Iae};var Cae=`if (x < 0.0) return NAN;
  return log(x);`,vae=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,Sae=_e({opSnippet:Cae,packedOpSnippet:vae,cpuKernelImpl:g$}),Xz={kernelName:Co,backendName:"webgl",kernelFunc:Sae};var wae="return log(1.0 + x);",_ae=_e({opSnippet:wae}),Yz={kernelName:Wi,backendName:"webgl",kernelFunc:_ae};var Aae="return float(a >= 1.0 && b >= 1.0);",Nae=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,Dae=ct({opSnippet:Aae,packedOpSnippet:Nae,dtype:"bool"}),Qz={kernelName:ca,backendName:"webgl",kernelFunc:Dae};var Pae="return float(!(x >= 1.0));",Mae=_e({opSnippet:Pae}),Zz={kernelName:Ki,backendName:"webgl",kernelFunc:Mae};var Fae="return float(a >= 1.0 || b >= 1.0);",Eae=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Rae=ct({opSnippet:Fae,packedOpSnippet:Eae,dtype:"bool"}),Jz={kernelName:Nl,backendName:"webgl",kernelFunc:Rae};var nA=class{constructor(e,t,n,o,s){this.variableNames=["x"];this.outputShape=[];let i=t,a=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${i}; j <= ${i}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var oA=class{constructor(e,t,n,o,s){this.variableNames=["x"];this.outputShape=[];this.packedInputs=!0;this.packedOutput=!0;let i=t,a=e[3]-1;this.outputShape=e;let u,l=`float(${n}) + float(${o}) * sum`;s===.5?u=`inversesqrt(${l})`:s===1?u=`1.0/(${l})`:u=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${i};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${i}; j <= ${i}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var Lae=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{depthRadius:s,bias:i,alpha:a,beta:u}=n,l=$().getBool("WEBGL_PACK_NORMALIZATION")?new oA(o.shape,s,i,a,u):new nA(o.shape,s,i,a,u);return t.runWebGLProgram(l,[o],o.dtype)},e3={kernelName:Gu,backendName:"webgl",kernelFunc:Lae};var sA=class{constructor(e,t,n,o,s){this.variableNames=["inputImage","outputImage","dy"];this.outputShape=[];this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=o,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${o}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${o})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var Bae=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o,y:s,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:p}=n,c=new sA(o.shape,a,u,l,p);return t.runWebGLProgram(c,[o,s,i],o.dtype)},t3={kernelName:Tc,backendName:"webgl",kernelFunc:Bae};function r3(r,e,t,n){let o=b.sizeFromShape(e),i=b.sizeFromShape(r.shape)/o,a=le({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=to(a,r.dtype,"max",n),l=le({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}function aA(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,a),c=p!=null,m=t.shouldExecuteOnCPU([o]),d=o;if(c){if(m){let T=t.texData.get(d.dataId).values,k=new Array(a);for(let M=0;M<k.length;M++)k[M]=o.shape[p[M]];let C=Mp(T,o.shape,o.dtype,p,k);d=t.makeTensorInfo(k,o.dtype);let A=t.texData.get(d.dataId);A.values=C}else d=yl(o,p,t);l=I.getInnerMostAxes(l.length,a)}I.assertAxesAreInnerMostDims("max",l,a);let[f,h]=I.computeOutAndReduceShapes(d.shape,l),g=f;i&&(g=I.expandShapeToKeepDim(f,u));let x;if(m){let T=t.texData.get(d.dataId).values,k=b$(T,b.sizeFromShape(h),g,o.dtype);x=t.makeTensorInfo(g,o.dtype);let C=t.texData.get(x.dataId);C.values=k}else x=r3(d,h,g,t);return c&&t.disposeIntermediateTensorInfo(d),x}var n3={kernelName:vo,backendName:"webgl",kernelFunc:aA};var $ae=Bx+`
  return max(a, b);
`,Oae=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+gl+`
  return result;
`,zae=ct({opSnippet:$ae,packedOpSnippet:Oae,cpuKernelImpl:y$}),o3={kernelName:So,backendName:"webgl",kernelFunc:zae};function Gae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e;Oa(o,"maxPool");let{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1;b.assert(I.eitherStridesOrDilationsAreOne(i,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${l}'`);let p=I.computePool2DInfo(o.shape,s,i,l,a,u);if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))return ar({inputs:{x:o},backend:t});let c=new Ti(p,"max",!1);return t.runWebGLProgram(c,[o],o.dtype)}var s3={kernelName:wo,backendName:"webgl",kernelFunc:Gae};function Uae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=n,p=[1,1,1],c=I.computePool3DInfo(o.shape,s,i,p,a,l,u),m=new Rp(c,"max",!1);return t.runWebGLProgram(m,[o],o.dtype)}var a3={kernelName:Uu,backendName:"webgl",kernelFunc:Uae};var iA=class{constructor(e){this.variableNames=["dy","maxPos"];this.outputShape=e.inShape;let t=e.strideHeight,n=e.strideWidth,o=e.dilationHeight,s=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=s-1-e.padInfo.top,u=i-1-e.padInfo.left,l=s*i-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${i}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${i} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},uA=class{constructor(e){this.variableNames=["dy","maxPos"];this.outputShape=e.inShape;let t=e.strideDepth,n=e.strideHeight,o=e.strideWidth,s=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,u=e.effectiveFilterDepth,l=e.effectiveFilterHeight,p=e.effectiveFilterWidth,c=u-1-e.padInfo.front,m=l-1-e.padInfo.top,d=p-1-e.padInfo.left,f=u*l*p-1;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${m}, ${d});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${i}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${p} +
                  wR * ${p} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Wae(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s}=e,i=s,{filterSize:a,strides:u,pad:l,dimRoundingMode:p}=n,c=[1,1,1],m=I.computePool3DInfo(i.shape,a,u,c,l,p),d=new Rp(m,"max",!0),f=t.runWebGLProgram(d,[i],i.dtype),h=new uA(m),g=t.runWebGLProgram(h,[o,f],i.dtype);return t.disposeIntermediateTensorInfo(f),g}var i3={kernelName:Ic,backendName:"webgl",kernelFunc:Wae};function Kae(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,input:s,output:i}=e,a=s;Oa([s,i],"maxPoolGrad");let{filterSize:u,strides:l,pad:p,dimRoundingMode:c}=n,m=I.computePool2DInfo(a.shape,u,l,1,p,c),d=!0,f=new Ti(m,"max",d),h=t.runWebGLProgram(f,[a],a.dtype),g=new iA(m),x=t.runWebGLProgram(g,[o,h],a.dtype);return t.disposeIntermediateTensorInfo(h),x}var u3={kernelName:kc,backendName:"webgl",kernelFunc:Kae};function l3(r,e,t,n){let o=new Ti(t,"max",!1),s=n.runWebGLProgram(o,[r],"float32");o=new Ti(t,"max",!0,!0,e);let i=n.runWebGLProgram(o,[r],"float32");return[s,i]}var p3={kernelName:Cc,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{filterSize:o,strides:s,pad:i,includeBatchInIndex:a}=e,u=t;b.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let l=[1,1];b.assert(I.eitherStridesOrDilationsAreOne(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);let p=I.computePool2DInfo(n.shape,o,s,l,i),[c,m]=l3(n,a,p,u);return[c,m]}};function c3(r,e,t,n){let o=b.sizeFromShape(e),i=b.sizeFromShape(r.shape)/o,a=le({inputs:{x:r},attrs:{shape:[i,o]},backend:n}),u=to(a,"float32","mean",n),l=le({inputs:{x:u},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(u),l}var m3={kernelName:_o,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{keepDims:o,axis:s}=e,i=t,a=n.shape.length,u=b.parseAxisParam(s,n.shape),l=u,p=I.getAxesPermutation(l,a),c=p!=null,m=i.shouldExecuteOnCPU([n]),d=[],f=n;if(c){if(m){let k=i.texData.get(f.dataId).values,C=new Array(a);for(let P=0;P<C.length;P++)C[P]=n.shape[p[P]];let A=Mp(k,n.shape,n.dtype,p,C);f=i.makeTensorInfo(C,n.dtype);let M=i.texData.get(f.dataId);M.values=A}else f=yl(n,p,i);d.push(f),l=I.getInnerMostAxes(l.length,a)}I.assertAxesAreInnerMostDims("sum",l,a);let[h,g]=I.computeOutAndReduceShapes(f.shape,l),x=h;o&&(x=I.expandShapeToKeepDim(h,u));let y=c3(f,g,x,i);for(let T of d)i.disposeIntermediateTensorInfo(T);return y}};function Vae(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=b.parseAxisParam(s,o.shape),l=u,p=I.getAxesPermutation(l,a),c=o;p!=null&&(c=Ht({inputs:{x:o},backend:t,attrs:{perm:p}}),l=I.getInnerMostAxes(l.length,o.shape.length)),I.assertAxesAreInnerMostDims("min",l,a);let[m,d]=I.computeOutAndReduceShapes(c.shape,l),f=b.sizeFromShape(d),h=le({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}}),g=to(h,h.dtype,"min",t),x;if(i){let y=I.expandShapeToKeepDim(m,u);x=le({inputs:{x:g},backend:t,attrs:{shape:y}})}else x=le({inputs:{x:g},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),p!=null&&t.disposeIntermediateTensorInfo(c),x}var d3={kernelName:Ao,backendName:"webgl",kernelFunc:Vae};var jae=Bx+`
  return min(a, b);
`,Hae=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+gl+`
  return result;
`,qae=ct({opSnippet:jae,packedOpSnippet:Hae,cpuKernelImpl:x$}),f3={kernelName:No,backendName:"webgl",kernelFunc:qae};var lA=class{constructor(e,t,n){this.variableNames=["x"];this.outputShape=t.map((p,c)=>p[0]+e[c]+p[1]);let o=e.length,s=je(o),i=t.map(p=>p[0]).join(","),a=t.map((p,c)=>p[0]+e[c]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o),l=n==="reflect"?0:1;if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${o}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var pA=class{constructor(e,t,n){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=t.map((f,h)=>f[0]+e[h]+f[1]);let o=e.length,s=je(o),i=t.map(f=>f[0]).join(","),a=t.map((f,h)=>f[0]+e[h]).join(","),u=sr("rc",o),l=sr("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,c=o===1?"source":`vec2(${l.slice(-2).join()})`,m=n==="reflect"?0:1,d="";if(o===1){let f=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${m};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${m};
        }
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${u[o-1]} += 1;
        if(${p}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
      `}else{let f=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${m}) +
                gte * ((end - 1) * 2 - source + ${m});
        source -= start;
      `;d=`
        ${s} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${l.join()}), ${c});
        ${u[o-1]} += 1;
        if(${p}) {
          ${f}
          result[1] = getChannel(getX(${l.join()}), ${c});
        }
        rc = outputLoc;
        ${u[o-2]} += 1;
        if(${u[o-2]} < ${this.outputShape[o-2]}) {
          ${f}
          result[2] = getChannel(getX(${l.join()}), ${c});
          ${u[o-1]} += 1;
          if(${p}) {
            ${f}
            result[3] = getChannel(getX(${l.join()}), ${c});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${d}
        setOutput(result);
      }
    `}};var Xae=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{paddings:o,mode:s}=t,i=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pA(n.shape,o,s):new lA(n.shape,o,s);return e.runWebGLProgram(i,[n],n.dtype)},h3={kernelName:Do,backendName:"webgl",kernelFunc:Xae};var Yae=`if (b == 0.0) return NAN;
  return mod(a, b);`,Qae=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+gl+`
  return result;
`,Zae=ct({opSnippet:Yae,packedOpSnippet:Qae}),g3={kernelName:Vi,backendName:"webgl",kernelFunc:Zae};var cA=class{constructor(e,t,n){this.variableNames=["probs"];this.customUniforms=[{name:"seed",type:"float"}];this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}};var Jae=`
if (a == b) {
  return 1.0;
};
return a / b;`,eie=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,mA=ct({opSnippet:Jae,packedOpSnippet:eie,checkOutOfBounds:!0}),b3={kernelName:ho,backendName:"webgl",kernelFunc:mA};var y3="return a - b;",dA=ct({opSnippet:y3,packedOpSnippet:y3,supportsComplex:!0,cpuKernelImpl:R$}),x3={kernelName:Vo,backendName:"webgl",kernelFunc:dA};function fA(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,i=b.parseAxisParam([s],o.shape),a=aA({inputs:{x:o},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),u=I.expandShapeToKeepDim(a.shape,i),l=le({inputs:{x:a},backend:t,attrs:{shape:u}}),p=dA({inputs:{a:o,b:l},backend:t}),c=X_({inputs:{x:p},backend:t}),m=Fp({inputs:{x:c},backend:t,attrs:{axis:i,keepDims:!1}}),d=le({inputs:{x:m},backend:t,attrs:{shape:u}}),f=mA({inputs:{a:c,b:d},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(d),f}var T3={kernelName:Wo,backendName:"webgl",kernelFunc:fA};function tie(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{numSamples:s,seed:i,normalized:a}=n,u=a?o:fA({inputs:{logits:o},backend:t,attrs:{dim:o.shape.length-1}}),l=u.shape[0],p=u.shape[1],c=new cA(l,p,s),m=[[i]],d=t.runWebGLProgram(c,[u],"int32",m);return a||t.disposeIntermediateTensorInfo(u),d}var k3={kernelName:vc,backendName:"webgl",kernelFunc:tie};var I3="return -x;";function rie(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.texData.get(n.dataId),[i,a]=k$(s.values,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,i)}let o;return $().getBool("WEBGL_PACK_UNARY_OPERATIONS")?o=new Ga(n.shape,I3):o=new Bn(n.shape,I3),t.runWebGLProgram(o,[n],n.dtype)}var C3={kernelName:bs,backendName:"webgl",kernelFunc:rie};var nie=Tr.nonMaxSuppressionV3Impl;function oie(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:c}=nie(l,p,i,a,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}var v3={kernelName:da,backendName:"webgl",kernelFunc:oie};var sie=Tr.nonMaxSuppressionV4Impl;function aie(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,padToMaxOutputSize:l}=n,p=t.readSync(o.dataId),c=t.readSync(s.dataId),{selectedIndices:m,validOutputs:d}=sie(p,c,i,a,u,l);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([],"int32",new Int32Array([d]))]}var S3={kernelName:ji,backendName:"webgl",kernelFunc:aie};var iie=Tr.nonMaxSuppressionV5Impl;function uie(r){I.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),c=t.readSync(s.dataId),m=i,d=a,f=u,h=l,{selectedIndices:g,selectedScores:x}=iie(p,c,m,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var w3={kernelName:fa,backendName:"webgl",kernelFunc:uie};var hA=class{constructor(e,t,n,o){this.variableNames=["indices"];this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${o}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var lie=r=>{let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:i,offValue:a}=n,u=b.sizeFromShape(o.shape),l=new hA(u,s,i,a),p=le({inputs:{x:o},backend:t,attrs:{shape:[u]}}),c=t.runWebGLProgram(l,[p],o.dtype);t.disposeIntermediateTensorInfo(p);let m=[...o.shape,s],d=le({inputs:{x:c},backend:t,attrs:{shape:m}});return t.disposeIntermediateTensorInfo(c),d},_3={kernelName:ha,backendName:"webgl",kernelFunc:lie};function cg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=vu({inputs:{input:n},backend:t}),s=cg({inputs:{x:o},backend:t}),i=Lp({inputs:{input:n},backend:t}),a=cg({inputs:{x:i},backend:t}),u=$n({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Su({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var A3={kernelName:ws,backendName:"webgl",kernelFunc:cg};function N3(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=vu({inputs:{input:n},backend:t}),s=N3({inputs:{x:o},backend:t}),i=Lp({inputs:{input:n},backend:t}),a=cg({inputs:{x:i},backend:t}),u=$n({inputs:{real:s,imag:a},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(a),u}else return Su({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var D3={kernelName:ys,backendName:"webgl",kernelFunc:N3};function pie(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return Hx({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=e.map(p=>{let c=Hx({inputs:{input:p},backend:t,attrs:{dim:o}});return a.push(c),c}),l=L_({inputs:u,backend:t,attrs:{axis:o}});return a.forEach(p=>t.disposeIntermediateTensorInfo(p)),l}var P3={kernelName:xs,backendName:"webgl",kernelFunc:pie};var gA=class{constructor(e,t,n){this.variableNames=["x"];this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map((l,p)=>l[0]+e[p]+l[1]);let o=e.length,s=je(o),i=t.map(l=>l[0]).join(","),a=t.map((l,p)=>l[0]+e[p]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,o);if(o===1){this.userCode=`
        int start = ${i};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${i});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var bA=class{constructor(e,t,n){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;this.customUniforms=[{name:"value",type:"float"}];this.outputShape=t.map((h,g)=>h[0]+e[g]+h[1]);let o=e.length,s=je(o),i=t.map(h=>h[0]).join(","),a=t.map((h,g)=>h[0]+e[g]).join(","),u=sr("rc",o),l=sr("source",o),p=`${u[o-1]} < ${this.outputShape[o-1]}`,c=o===1?"source":`vec2(${l.slice(-2).join()})`,m=[`${s} rc = outputLoc;`,`${u[o-1]} += 1;
       if(${p}) {
      `,o===1?"":`}
       rc = outputLoc;
       ${u[o-2]} += 1;
       if(${u[o-2]} < ${this.outputShape[o-2]}) {`,o===1?"":`  ${u[o-1]} += 1;
         if(${p}) {`],d=o===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",f="";for(let h=0,g=o===1?2:4;h<g;h++)f+=`
        ${m[h]}
        if (${d}) {
          result[${h}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${h}] = getChannel(getX(${l.join()}), ${c});
        }
      `;f+=o===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${i});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}};var yA=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:i}=n;if(b.sizeFromShape(o.shape)===0){let l=s.map((p,c)=>p[0]+o.shape[c]+p[1]);return Su({backend:t,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new bA(o.shape,s,i):new gA(o.shape,s,i),u=[[i]];return t.runWebGLProgram(a,[o],o.dtype,u)},M3={kernelName:Mo,backendName:"webgl",kernelFunc:yA};var cie=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,mie=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+gl+`
  return result;
`,die=ct({opSnippet:cie,packedOpSnippet:mie}),F3={kernelName:Fo,backendName:"webgl",kernelFunc:die};function fie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n,a=o.shape.length,u=[],l=b.parseAxisParam(s,o.shape),p=l,c=I.getAxesPermutation(p,a),m=o;c!=null&&(m=Ht({inputs:{x:o},backend:t,attrs:{perm:c}}),p=I.getInnerMostAxes(p.length,a),u.push(m)),I.assertAxesAreInnerMostDims("prod",p,a);let d;if(t.shouldExecuteOnCPU([m])){let f=t.texData.get(m.dataId).values,{outVals:h,outShape:g,outDtype:x}=C$(m.shape,m.dtype,f,p);d=t.makeTensorInfo(g,x,h)}else{let[f,h]=I.computeOutAndReduceShapes(m.shape,p),g=b.sizeFromShape(h),x=le({inputs:{x:m},backend:t,attrs:{shape:[-1,g]}}),y=Ji(o.dtype),T=to(x,y,"prod",t);d=le({inputs:{x:T},backend:t,attrs:{shape:f}}),u.push(x),u.push(T)}if(i){u.push(d);let f=I.expandShapeToKeepDim(d.shape,l);d=le({inputs:{x:d},backend:t,attrs:{shape:f}})}return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),d}var E3={kernelName:ga,backendName:"webgl",kernelFunc:fie};var xA=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:i}=t,a=v$(n,o,s,i);return e.makeTensorInfo([a.length],i,a)},R3={kernelName:Ja,backendName:"webgl",kernelFunc:xA};var hie="return 1.0 / x;",gie=_e({opSnippet:hie}),L3={kernelName:Hi,backendName:"webgl",kernelFunc:gie};var bie=Mr+`
  return (x < 0.0) ? 0.0 : x;
`,yie=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xie=_e({opSnippet:bie,packedOpSnippet:yie}),B3={kernelName:Ro,backendName:"webgl",kernelFunc:xie};var Tie=Mr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,kie=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Iie=_e({opSnippet:Tie,packedOpSnippet:kie}),$3={kernelName:Bo,backendName:"webgl",kernelFunc:Iie};var TA=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let p=[o&&t>1?a-1:a,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":m="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/c[0]},
          ${p[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var kA=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let p=[o&&t>1?a-1:a,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m;s?m="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":m="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/c[0]},
          ${p[1]/c[1]},
          ${p[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${m};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function Cie(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,p=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new kA(o.shape,u,l,s,i):new TA(o.shape,u,l,s,i);return t.runWebGLProgram(p,[o],"float32")}var O3={kernelName:Lo,backendName:"webgl",kernelFunc:Cie};var IA=class{constructor(e,t,n){this.variableNames=["dy"];this.outputShape=[];this.outputShape=t;let[,o,s]=t,[,i,a]=e,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],p=u[0]/l[0],c=u[1]/l[1],m=1/p,d=1/c,f=Math.ceil(m)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${c});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${o-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function vie(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:i}=n,a=new IA(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var z3={kernelName:wc,backendName:"webgl",kernelFunc:vie};var CA=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let p=[o&&t>1?a-1:a,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m=o?"0.5":"0.0",d;s?d="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${p[0]/c[0]},
          ${p[1]/c[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};var vA=class{constructor(e,t,n,o,s){this.variableNames=["A"];this.packedInputs=!0;this.packedOutput=!0;this.outputShape=[];let[i,a,u,l]=e;this.outputShape=[i,t,n,l];let p=[o&&t>1?a-1:a,o&&n>1?u-1:u],c=[o&&t>1?t-1:t,o&&n>1?n-1:n],m=o?"0.5":"0.0",d;s?d="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${p[0]/c[0]},
          ${p[1]/c[1]},
          ${p[1]/c[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${m})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${n-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}};function Sie(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,p=$().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new vA(o.shape,u,l,s,i):new CA(o.shape,u,l,s,i);return t.runWebGLProgram(p,[o],o.dtype)}var G3={kernelName:ei,backendName:"webgl",kernelFunc:Sie};var SA=class{constructor(e,t,n){this.variableNames=["dy"];this.outputShape=[];this.outputShape=t;let[,o,s]=t,[,i,a]=e,u=[n&&i>1?o-1:o,n&&a>1?s-1:s],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],p=u[0]/l[0],c=u[1]/l[1],m=1/p,d=1/c,f=Math.ceil(m)*2+2,h=Math.ceil(d)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${p});
        const float widthScale = float(${c});

        const float invHeightScale = float(${m});
        const float invWidthScale = float(${d});

        const int winHeight = int(${f});
        const int winWidth = int(${h});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${i}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function wie(r){let{inputs:e,backend:t,attrs:n}=r,{images:o,dy:s}=e,{alignCorners:i}=n,a=new SA(s.shape,o.shape,i);return t.runWebGLProgram(a,[s],s.dtype)}var U3={kernelName:Sc,backendName:"webgl",kernelFunc:wie};var wA=class{constructor(e,t){this.variableNames=["x"];let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}let o=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,u)=>o(u)).join(","),i=je(n);this.userCode=`
      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}};var _A=class{constructor(e,t){this.variableNames=["x"];this.packedInputs=!0;this.packedOutput=!0;let n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;let o=sr("rc",n),s=`${o[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${o[n-2]} + 1 < ${this.outputShape[n-2]}`,a=je(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(o.slice())};
          if(${s}){
            result.g = ${l(o.slice())};
          }
          if(${i}) {
            result.b = ${p(o.slice())};
            if(${s}) {
              result.a = ${c(o.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(f){return m(f)}function l(f){return f[n-1]="("+f[n-1]+" + 1)",m(f)}function p(f){return f[n-2]="("+f[n-2]+" + 1)",m(f)}function c(f){return f[n-1]="("+f[n-1]+" + 1)",f[n-2]="("+f[n-2]+" + 1)",m(f)}function m(f){let h=e.map((y,T)=>d(T,f)),g=h.join(","),x=h.slice(-2).join(",");return`getChannel(getX(${g}), vec2(${x}))`}function d(f,h){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${h[f]} - 1`:`${h[f]}`}}};function _ie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,i=o.shape.length,a=b.parseAxisParam(s,o.shape);if(i===0)return ar({inputs:{x:o},backend:t});let u=$().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new _A(o.shape,a):new wA(o.shape,a);return t.runWebGLProgram(u,[o],o.dtype)}var W3={kernelName:ba,backendName:"webgl",kernelFunc:_ie};var AA=class{constructor(e,t){this.variableNames=["Image"];this.outputShape=[];this.customUniforms=[{name:"params",type:"vec4"}];let n=e[1],o=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${o} && coordY >= 0 && coordY < ${n}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var K3={kernelName:Sa,backendName:"webgl",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=e,a=t,u=new AA(n.shape,s),[l,p]=I.getImageCenter(i,n.shape[1],n.shape[2]),c=[[l,p,Math.sin(o),Math.cos(o)]];return a.runWebGLProgram(u,[n],n.dtype,c)}};var Aie=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Nie=_e({opSnippet:Aie}),V3={kernelName:ya,backendName:"webgl",kernelFunc:Nie};var Die="return inversesqrt(x);",Pie=_e({opSnippet:Die,cpuKernelImpl:S$}),j3={kernelName:$o,backendName:"webgl",kernelFunc:Pie};var mg=class{constructor(e,t,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"];this.outputShape=i;let u=je(s.length),l=je(i.length),p="";n===1?p="i":n===2&&(p="i, j");let c=`getIndices(${p})`,m="";o===1?m="i":o===2&&(m="i, coords[1]");let d=`getUpdates(${m})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${s});

        void main() {
          ${l} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${c});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${d};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function Mie(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:p,outputSize:c}=I.calculateShapes(s,o,i),m=[c/l,l];if(c===0)return t.makeTensorInfo(i,o.dtype);let d=le({inputs:{x:o},backend:t,attrs:{shape:[u,a]}}),f=le({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=t.makeTensorInfo([],"float32",new Float32Array([0])),g=new mg(u,a,d.shape.length,f.shape.length,p,m),x=t.runWebGLProgram(g,[f,d,h],f.dtype),y=le({inputs:{x},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(h),y}var H3={kernelName:xa,backendName:"webgl",kernelFunc:Mie};var NA=class{constructor(e,t,n){this.variableNames=["c","a","b"];this.outputShape=t;let o,s;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)s="resRC",o="resRC";else{let a=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],l=[];for(let p=0;p<t.length;p++)l.push(`${a[p]}`),p<e&&u.push(`${a[p]}`);o=u.join(),s=l.join()}let i=je(n);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        float cVal = getC(${o});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}};function Fie(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,i=new NA(n.shape.length,o.shape,o.shape.length);return t.runWebGLProgram(i,[n,o,s],Kt(o.dtype,s.dtype))}var q3={kernelName:ks,backendName:"webgl",kernelFunc:Fie};var Eie=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${I.SELU_SCALEALPHA};
  float scale = ${I.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Rie=_e({opSnippet:Eie}),X3={kernelName:qi,backendName:"webgl",kernelFunc:Rie};var Y3="return 1.0 / (1.0 + exp(-1.0 * x));",Lie=_e({opSnippet:Y3,packedOpSnippet:Y3,cpuKernelImpl:w$}),Q3={kernelName:zo,backendName:"webgl",kernelFunc:Lie};var Bie=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,$ie=_e({opSnippet:Bie}),Z3={kernelName:Xi,backendName:"webgl",kernelFunc:$ie};var Oie=$x+`
  return sin(x);
`,zie=_e({opSnippet:Oie}),J3={kernelName:Oo,backendName:"webgl",kernelFunc:zie};var Gie=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Uie=_e({opSnippet:Gie}),eG={kernelName:Ta,backendName:"webgl",kernelFunc:Uie};var Wie=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,Kie=_e({opSnippet:Wie}),tG={kernelName:Yi,backendName:"webgl",kernelFunc:Kie};var Vie=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:i}=n;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let a=s.reduce((x,y)=>x*y),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<o.shape.length;++x)u.push([0,0]);let l=[],p=yA({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),c=I.getReshaped(p.shape,s,a,!1),m=I.getPermuted(c.length,s.length,!1),d=I.getReshapedPermuted(p.shape,s,a,!1),f=le({inputs:{x:p},backend:t,attrs:{shape:c}}),h=Ht({inputs:{x:f},backend:t,attrs:{perm:m}}),g=le({inputs:{x:h},backend:t,attrs:{shape:d}});return l.push(p),l.push(f),l.push(h),l.forEach(x=>t.disposeIntermediateTensorInfo(x)),g},rG={kernelName:Cs,backendName:"webgl",kernelFunc:Vie};function jie(r){let{inputs:e,backend:t}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(n.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${n.shape}`);if(o.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${o.shape}`);if(i.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${i.shape}`);let a=t.readSync(n.dataId),u=t.readSync(o.dataId),l=t.readSync(s.dataId),p=t.readSync(i.dataId)[0],[c,m,d,f,h]=A$(a,n.shape,n.dtype,u,o.dtype,l,p);return[t.makeTensorInfo(m,n.dtype,c),t.makeTensorInfo([m[0]],o.dtype,d),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(g=>Number(g)))),t.makeTensorInfo([h.length],n.dtype,new Int32Array(h))]}var nG={kernelName:Ku,backendName:"webgl",kernelFunc:jie};function Hie(r){let{inputs:e,backend:t}=r,{inputIndices:n,inputShape:o,newShape:s}=e;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=Array.from(t.readSync(o.dataId)),a=t.readSync(n.dataId),u=Array.from(t.readSync(s.dataId)),[l,p,c]=N$(a,n.shape,n.dtype,i,u);return[t.makeTensorInfo(p,n.dtype,l),t.makeTensorInfo([c.length],s.dtype,new Int32Array(c))]}var oG={kernelName:Qi,backendName:"webgl",kernelFunc:Hie};function qie(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);let i=t.readSync(n.dataId),a=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=Rx(i,n.shape,n.dtype,a,u,!0);return t.makeTensorInfo(p,n.dtype,l)}var sG={kernelName:Vu,backendName:"webgl",kernelFunc:qie};function Xie(r){let{inputs:e,backend:t}=r,{data:n,indices:o,segmentIds:s}=e;if(n.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(o.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${o.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);let i=t.readSync(n.dataId),a=t.readSync(o.dataId),u=t.readSync(s.dataId),[l,p]=Rx(i,n.shape,n.dtype,a,u);return t.makeTensorInfo(p,n.dtype,l)}var aG={kernelName:ju,backendName:"webgl",kernelFunc:Xie};function Yie(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=n,{sliceRank:u,numUpdates:l,strides:p,outputSize:c}=I.calculateShapes(s,o,a),m=!1,d=new mg(l,u,o.shape.length,s.shape.length,p,[c,1],m),f=t.runWebGLProgram(d,[s,o,i],s.dtype),h=le({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(f),h}var iG={kernelName:Hu,backendName:"webgl",kernelFunc:Yie};function Qie(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:i}=n,a=b.parseAxisParam(i,o.shape)[0],u=I.prepareSplitSize(o,s,a),l=o.shape.length,p=new Array(l).fill(0),c=o.shape.slice();return u.map(m=>{let d=[...c];d[a]=m;let f=Wa({inputs:{x:o},backend:t,attrs:{begin:p,size:d}});return p[a]+=m,f})}var uG={kernelName:vs,backendName:"webgl",kernelFunc:Qie};var lG="return sqrt(x);",Zie=_e({opSnippet:lG,packedOpSnippet:lG,cpuKernelImpl:D$}),pG={kernelName:Go,backendName:"webgl",kernelFunc:Zie};var Jie="return x * x;",eue=_e({opSnippet:Jie}),cG={kernelName:ti,backendName:"webgl",kernelFunc:eue};var mG="return (a - b) * (a - b);",tue=ct({opSnippet:mG,packedOpSnippet:mG}),dG={kernelName:Ko,backendName:"webgl",kernelFunc:tue};function rue({inputs:r,attrs:e,backend:t}){let{x:n}=r,o=Mr+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new Bn(n.shape,o);return t.runWebGLProgram(s,[n],n.dtype)}var fG={kernelName:_s,backendName:"webgl",kernelFunc:rue};var DA=class{constructor(e,t,n){this.variableNames=["x"];this.outputShape=n;let o=n.length,s=je(n.length),i=je(n.length),a="";if(o===1)a="coords * strides + begin";else{let u=0;a=n.map((l,p)=>(u++,n.length===1?`coords * strides[${p}] + begin[${p}]`:`coords[${u-1}] * strides[${p}] + begin[${p}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${i} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}};function nue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:y,end:T,strides:k}=Tt.sliceInfo(o.shape,s,i,a,u,l,p,c,m),C;if(h)C=le({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||x){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let M=Tt.computeOutShape(y,T,k),P=Wa({inputs:{x:o},backend:t,attrs:{begin:y,size:M}});C=le({inputs:{x:P},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(P)}else if(t.shouldExecuteOnCPU([o])){let P=t.readSync(o.dataId),F=Ce(o.shape,o.dtype,P),B=P$(d,F,k,y);C=t.makeTensorInfo(f,o.dtype,B.values)}else{let P=new DA(y,k,d);C=t.runWebGLProgram(P,[o],o.dtype)}let A=le({inputs:{x:C},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(C),A}var hG={kernelName:ka,backendName:"webgl",kernelFunc:nue};function oue(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:c}=e,m=t.readSync(p.dataId),d=t.readSync(c.dataId),[f,h]=M$(m,d,o,s,i,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(c.shape,"int32",h)]}var gG={kernelName:qu,backendName:"webgl",kernelFunc:oue};function sue(r){let{inputs:e,backend:t,attrs:n}=r,{skipEmpty:o}=n,{input:s,delimiter:i}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(i.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${i.shape}`);let a=t.readSync(s.dataId),u=t.readSync(i.dataId)[0],[l,p,c]=F$(a,u,o),m=p.length;return[t.makeTensorInfo([m,2],"int32",l),t.makeTensorInfo([m],"string",p),t.makeTensorInfo([2],"int32",new Int32Array(c))]}var bG={kernelName:_c,backendName:"webgl",kernelFunc:sue};function aue(r){let{inputs:e,backend:t,attrs:n}=r,{numBuckets:o}=n,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(o<=0)throw new Error("Number of buckets must be at least 1");let i=t.readSync(s.dataId),a=E$(i,o);return t.makeTensorInfo(s.shape,"int32",a)}var yG={kernelName:Ac,backendName:"webgl",kernelFunc:aue};var iue="return tan(x);",uue=_e({opSnippet:iue}),xG={kernelName:Ia,backendName:"webgl",kernelFunc:uue};var lue=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,pue=_e({opSnippet:lue}),TG={kernelName:jo,backendName:"webgl",kernelFunc:pue};var PA=class{constructor(e,t){this.variableNames=["A"];let n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;let o=je(this.rank),s=cue(e);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function cue(r){let e=r.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${r[0]})`;let t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let o=0;o<r.length;o++)n.push(`imod(${t[o]}, ${r[o]})`);return n.join()}function MA(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(o.dtype==="string"||o.shape.length>5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>b.decodeString(m)):u,p=Ce(o.shape,o.dtype,l),c=L$(p,s);return t.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new PA(o.shape,s);return t.runWebGLProgram(i,[o],o.dtype)}var kG={kernelName:An,backendName:"webgl",kernelFunc:MA};var FA=class{constructor(e){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}];this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}},EA=class{constructor(e){this.variableNames=["x","indices"];this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}];this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}};function $p(r,e){e!==null&&r.disposeIntermediateTensorInfo(e)}function IG(r){let e=1;for(;e<r;)e*=2;return e}function mue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:i}=n,a=$().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),u=$().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=o.shape,p=l[l.length-1];if(t.shouldExecuteOnCPU([o])||p<a||s>u){let B=t.readSync(o.dataId),[U,W]=B$(B,l,o.dtype,s,i);return[t.makeTensorInfo(U.shape,U.dtype,U.values),t.makeTensorInfo(W.shape,W.dtype,W.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,o.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(p===1)return[o,Su({attrs:{shape:l,dtype:"int32",value:0},backend:t})];let c=t.texData.get(o.dataId),m=c!==null&&c.isPacked,d=m?t.unpackTensor(o):o,h=b.sizeFromShape(l)/p,g=le({inputs:{x:d},attrs:{shape:[h,p]},backend:t});m&&$p(t,d);let x=IG(s),y=IG(p),T=null,k=()=>T===null?[g,g]:[g,T],C=(B,U,W)=>{let K=k(),j=new FA(W),q=[[p],[T===null?1:0],[Number.NEGATIVE_INFINITY],[B],[U]],ee=T;T=t.runWebGLProgram(j,K,"int32",q),$p(t,ee)};for(let B=1;B<x;B*=2){let U=B*2;for(let W=B;W>=1;W/=2)C(U,W,[h,y])}for(let B=y;B>x;B/=2){let U=k(),W=new EA([h,B/2]),j=[[p],[T===null?1:0],[x]],V=T;T=t.runWebGLProgram(W,U,"int32",j),$p(t,V);let q=x/2,ee=q*2;for(let Z=q;Z>=1;Z/=2)C(ee,Z,T.shape)}let A=T;T=Wa({inputs:{x:T},backend:t,attrs:{begin:0,size:[h,s]}}),$p(t,A);let M=rA({inputs:{x:g,indices:T},backend:t,attrs:{axis:1,batchDims:1}});$p(t,g);let P=l.slice(0,-1);P.push(s),A=T,T=le({inputs:{x:T},attrs:{shape:P},backend:t}),$p(t,A);let F=M;return M=le({inputs:{x:M},attrs:{shape:P},backend:t}),$p(t,F),[M,T]}var CG={kernelName:Ca,backendName:"webgl",kernelFunc:mue};var RA=class{constructor(e,t,n,o,s,i){this.variableNames=["Image","Transforms"];this.outputShape=i;let a=n==="nearest"?1:2,u;switch(o){case"constant":u=1;break;case"reflect":u=2;break;case"wrap":u=3;break;case"nearest":u=4;break;default:u=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${u} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${u} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}};function due(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[p,c,m,d]=o.shape,[f,h]=l??[c,m],g=[p,f,h,d],x=new RA(c,m,i,a,u,g);return t.runWebGLProgram(x,[o,s],"float32")}var vG={kernelName:va,backendName:"webgl",kernelFunc:due};function fue(r){let{inputs:e,attrs:t,backend:n}=r,{axis:o}=t,{x:s}=e;Oa(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let i=n.readSync(s.dataId),{outputValues:a,outputShape:u,indices:l}=$$(i,o,s.shape,s.dtype);return[n.makeTensorInfo(u,s.dtype,a),n.makeTensorInfo([l.length],"int32",l)]}var SG={kernelName:Nc,backendName:"webgl",kernelFunc:fue};function hue(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),p=0;for(let h=0;h<a;h++)h!==s&&(l[p++]=i.shape[h]);let c=[],m=new Array(a).fill(0),d=i.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){m[s]=h;let g=Wa({inputs:{x:i},backend:t,attrs:{begin:m,size:d}}),x=le({inputs:{x:g},backend:t,attrs:{shape:l}});f[h]=x,c.push(g)}return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),f}var wG={kernelName:Ss,backendName:"webgl",kernelFunc:hue};var LA=class{constructor(e,t){this.variableNames=["x","segmentIds"];let n=e.windowSize,o=e.batchSize,s=e.inSize,i=e.numSegments,a=i*Math.ceil(s/n);this.outputShape=[o,a];let u="0.0",l="sumValue",p=Math.floor(n/4)*4,c=n%4,m=`
        sumValue += dot(values, segFilter);
    `,d="";s%n>0&&(d=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let f="";s%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${d}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${i})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${i})));

        float sumValue = 0.0;

        for (int i = 0; i < ${p}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${m}
        }

        int inIdx = inOffset + ${p};
        if (${c===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${m}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${m}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${m}
        }
        setOutput(${l});
      }
    `}};function gue(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,segmentIds:s}=e,{numSegments:i}=n,a=o.shape.length,u=[],l=0,p=I.getAxesPermutation([l],a),c=o;p!=null&&(c=Ht({inputs:{x:o},backend:t,attrs:{perm:p}}),u.push(c),l=I.getInnerMostAxes(1,a)[0]);let m=I.segment_util.computeOutShape(c.shape,l,i),d=b.sizeFromShape([c.shape[l]]),f=le({inputs:{x:c},backend:t,attrs:{shape:[-1,d]}});u.push(f);let h=Ji(o.dtype),g=(k,C,A,M,P)=>{let F=k.shape[0],B=k.shape[1],U=I.segment_util.segOpComputeOptimalWindowSize(B,P),W={windowSize:U,inSize:B,batchSize:F,numSegments:P},K=new LA(W,C),j=t.compileAndRun(K,[k,A],M);if(u.push(j),j.shape[1]===P)return j;let V=xA({backend:t,attrs:{start:0,stop:P,step:1,dtype:"float32"}}),q=MA({inputs:{x:V},backend:t,attrs:{reps:[B/U]}});return u.push(V),u.push(q),g(j,C,q,M,P)},x=g(f,"unsortedSegmentSum",s,h,i),y=le({inputs:{x},backend:t,attrs:{shape:m}}),T=y;if(p!=null){u.push(y);let k=I.getUndoAxesPermutation(p);T=Ht({inputs:{x:T},backend:t,attrs:{perm:k}})}return u.forEach(k=>t.disposeIntermediateTensorInfo(k)),T}var _G={kernelName:Xu,backendName:"webgl",kernelFunc:gue};var bue=[e3,t3,fO,gO,bO,yO,TO,kO,IO,CO,wO,_O,AO,NO,PO,DO,MO,EO,FO,RO,LO,BO,$O,zO,GO,UO,jO,qO,XO,QO,rO,JO,tz,rz,ez,oz,sz,nz,az,iz,uz,cz,mz,dz,hz,gz,fz,bz,yz,xz,Tz,kz,Iz,Cz,Sz,wz,Az,Nz,Dz,Pz,Fz,Ez,Rz,Lz,Bz,$z,Oz,zz,Gz,tO,Uz,ZO,Wz,Kz,Vz,nO,jz,Hz,qz,Yz,Xz,Qz,Zz,Jz,n3,a3,s3,i3,u3,p3,o3,m3,d3,f3,h3,g3,k3,uO,C3,v3,S3,w3,WO,_3,D3,P3,M3,F3,oO,E3,R3,KO,b3,L3,$3,B3,pO,O3,z3,G3,U3,W3,K3,V3,j3,H3,q3,X3,Q3,Z3,J3,eG,OO,T3,tG,rG,nG,oG,sG,aG,iG,uG,pG,cG,dG,fG,hG,gG,bG,yG,x3,mO,xG,TG,kG,CG,vG,dO,SG,wG,_G,A3];for(let r of bue)Zi(r);var ki=$();ki.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);ki.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);ki.registerFlag("WEBGPU_MATMUL_WORK_PER_THREAD",()=>4);ki.registerFlag("WEBGPU_USE_NAIVE_CONV2D",()=>!1);ki.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!1);ki.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);ki.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);ki.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);ki.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);ki.registerFlag("WEBGPU_USE_IMPORT",()=>!1);function AG(r,e){if(Math.max(...r)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");let t=r.length,n=r.map(s=>`${e}[${s}]`),o=new Array(t-1);o[t-2]=n[t-1];for(let s=t-3;s>=0;--s)o[s]=`(${o[s+1]} * ${n[s+1]})`;return o}function Zt(r){if(r<=1)return"i32";if(r===2)return"vec2<i32>";if(r===3)return"vec3<i32>";if(r===4)return"vec4<i32>";throw Error(`GPU for rank ${r} is not yet supported`)}function Yx(r,e){return r==="float32"?e?"vec4<f32>":"f32":r==="int32"||r==="bool"?e?"vec4<i32>":"i32":r}function Vm(){return`
  [[stage(compute), workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)]]
`}function dg(){return`
  ${Vm()}
  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,
          [[builtin(global_invocation_id)]] globalId : vec3<u32>,
          [[builtin(num_workgroups)]] numWorkgroups: vec3<u32>)
`}function Ii(){return`
  ${Vm()}
  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,
          [[builtin(global_invocation_id)]] globalId : vec3<u32>)
`}function ve(){return`
    ${dg()} {
      let index = getGlobalIndex(globalId, localId, numWorkgroups);
`}function NG(r,e,t,n=!1){let o=`
    let workGroupSizeX = ${t.workGroupSize[0]}u;
    let workGroupSizeY = ${t.workGroupSize[1]}u;
    let workGroupSizeZ = ${t.workGroupSize[2]}u;`;if(n===!0){let d=MG(e.shape),f=`
      struct Matrix0 {
        numbers: array<${Yx(e.dtype,t.isVec4)}>;
      };
      struct Uniform {
        size            : i32;
        numChannels     : i32;
        outShapeStrides : vec2<i32>;
        dispatchSize    : vec3<u32>;
      };

      [[group(0), binding(0)]] var<storage, write> result : Matrix0;
      [[group(0), binding(2)]] var<uniform> uniforms: Uniform;
    `;return[DG,f,o,PG,d,t.getUserCode()].join(`
`)}let s=[],i="struct Uniforms { NAN : f32; ";t.variableNames.forEach((d,f)=>{i+=`${d.charAt(0).toLowerCase()+d.slice(1)}Shape : ${Zt(r[f].shape.length)}; `}),i+=`outShape : ${Zt(e.shape.length)} ; `;let a=e.shape.length-1;i+=`
       outShapeStrides: ${Zt(a)}; `,t.size&&(i+="size : i32; "),t.uniforms&&(i+=t.uniforms),i+="};",s.push(i),t.atomic?s.push(`
    struct Matrix0 {
        numbers: array<atomic<i32>>;
    };

    [[group(0), binding(0)]] var<storage, read_write> result : Matrix0;
  `):s.push(`
    struct Matrix0 {
        numbers: array<${Yx(e.dtype,t.isVec4)}>;
    };

    [[group(0), binding(0)]] var<storage, write> result : Matrix0;
  `),t.variableNames.forEach((d,f)=>{s.push(`
    struct Matrix${1+f} {
      numbers: array<${Yx(r[f].dtype,t.isVec4)}>;
    };
    [[group(0), binding(${1+f})]] var<storage, read> ${d} : Matrix${1+f};
    `)}),i!==""&&s.push(`
    [[group(0), binding(${1+t.variableNames.length})]] var<uniform> uniforms : Uniforms;
    `),s.push(o);let[u,l]=Cue(e.shape,t.dispatchLayout),p=MG(e.shape),c=[DG,s.join(`
`),PG,p,u,yue(e.shape.length)];if(t.atomic||c.push(xue(e.shape,e.dtype,t.isVec4)),l===e.shape.length){let d=r.map(f=>Tue(f,e.shape,t.isVec4,t.dispatchLayout.x.length===e.shape.length)).join(`
`);c.push(d)}return c.push(t.getUserCode()),c.join(`
`)}var DG=`
  fn idiv(a: i32, b: i32, sign: f32) -> i32 {
    var res: i32 = a / b;
    let mod: i32 = a % b;
    if (sign < 0. && mod != 0) {
      res = res - 1;
    }
    return res;
  }

  fn isNanCustom(val : f32) -> bool {
    if (val > 0.0) {
      return false;
    }
    if (val < 0.0) {
      return false;
    }
    if (val == 0.0) {
      return false;
    }
    return true;
  }

  fn isNanCustomVec4(val : vec4<f32>) -> vec4<bool> {
    return vec4<bool>(isNanCustom(val[0]), isNanCustom(val[1]), isNanCustom(val[2]), isNanCustom(val[3]));
  }

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) &&
        all(coord < shape);
  }

  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) &&
        all(coord < shape);
  }
  `,PG=`
  fn getFlatIndex1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }

  fn getFlatIndex2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }

  fn getFlatIndex3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }

  fn getFlatIndex4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }

  // Only used when the y/z dimension of workgroup size is 1.
  fn getGlobalIndex(globalId : vec3<u32>, localId : vec3<u32>, numWorkgroups: vec3<u32>) -> i32 {
    if (numWorkgroups.y == 1u && numWorkgroups.z == 1u) {
      return i32(globalId.x);
    }

    let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +
        localId.y * workGroupSizeX + localId.x;
    let workGroupID = (globalId - localId)/vec3<u32>(
        workGroupSizeX, workGroupSizeY, workGroupSizeZ);

    return i32((workGroupID.z * numWorkgroups.x * numWorkgroups.y +
      workGroupID.y * numWorkgroups.x + workGroupID.x) *
      (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +
      localInvocationIndex);
  }
`;function yue(r){let e="";switch(r){case 0:case 1:e+=`
        fn getOutputFlatIndex(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputFlatIndex(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputFlatIndex(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputFlatIndex(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;default:b.assert(!1,()=>`Unsupported ${r}D shape`);break}return e}function xue(r,e,t){let n=r.length,o=Yx(e,t),s;if(t?s=`fn setOutputFlat(flatIndex : i32, value : vec4<f32>) {
      result.numbers[flatIndex] = ${o}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : vec4<i32>) {
      result.numbers[flatIndex] = ${o}(value);
    }`:s=`fn setOutputFlat(flatIndex : i32, value : f32) {
      result.numbers[flatIndex] = ${o}(value);
    }
    fn setOutputFlatI32(flatIndex : i32, value : i32) {
      result.numbers[flatIndex] = ${o}(value);
    }`,n>=2){let i=["d0","d1","d2","d3"].slice(0,n),a=Zt(n);t?s+=`
      fn setOutput(${i.map(u=>`${u} : i32`).join(", ")}, value : vec4<f32>) {
        let flatIndex = getOutputFlatIndex(${a}(${i.join(", ")}));
        setOutputFlat(flatIndex / 4, value);
      }
      fn setOutputI32(${i.map(u=>`${u} : i32`).join(", ")}, value : vec4<i32>) {
        let flatIndex = getOutputFlatIndex(${a}(${i.join(", ")}));
        setOutputFlatI32(flatIndex / 4, value);
      }
    `:s+=`
      fn setOutput(${i.map(u=>`${u} : i32`).join(", ")}, value : f32) {
        let flatIndex = getOutputFlatIndex(${a}(${i.join(", ")}));
        setOutputFlat(flatIndex, value);
      }
      fn setOutputI32(${i.map(u=>`${u} : i32`).join(", ")}, value : i32) {
        let flatIndex = getOutputFlatIndex(${a}(${i.join(", ")}));
        setOutputFlatI32(flatIndex, value);
      }
    `}return s}function Tue(r,e,t,n){let o=kue(r,t);return r.shape.length<=e.length&&(o+=Iue(r,e,t,n)),o}function kue(r,e){let t=r.name,n=r.shape.length,o=Zt(n),s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=["d0","d1","d2","d3"].slice(0,n),a=i.map(p=>`${p} : i32`).join(", ");if(n<1)return e?`
        fn ${s}() -> vec4<f32> {
          return vec4<f32>(${t}.numbers[0]);
        }
      `:`
      fn ${s}() ->f32 {
        return f32(${t}.numbers[0]);
      }
    `;let u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`,l=`${n}D`;return n===0&&(l="1D"),e?`
      fn ${s}(${a}) -> vec4<f32> {
        return vec4<f32>(${t}.numbers[getFlatIndex${l}(${o}(${i.join(",")}),
          ${u}) / 4]);
      }
      `:`
    fn ${s}(${a}) -> f32 {
      return f32(${t}.numbers[getFlatIndex${l}(${o}(${i.join(",")}),
        ${u})]);
    }
   `}function Iue(r,e,t,n){let o=r.name,s=o.charAt(0).toUpperCase()+o.slice(1),i="get"+s+"AtOutCoords",a=r.shape.length,u=e.length,l=Zt(u);if(b.arraysEqual(r.shape,e)&&n)return t?`
        fn ${i}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {
          return vec4<f32>(${o}.numbers[globalIndex]);
        }

        fn ${i}ByCoords(coords : ${l}) -> vec4<f32> {
          return vec4<f32>(${o}.numbers[${u>1?"getOutputFlatIndex(coords)":"coords"} / 4]);
        }
        `:`
      fn ${i}ByGlobalIndex(globalIndex : i32) -> f32 {
        return f32(${o}.numbers[globalIndex]);
      }

      fn ${i}ByCoords(coords : ${l}) -> f32 {
        return f32(${o}.numbers[${u>1?"getOutputFlatIndex(coords)":"coords"}]);
      }
      `;let p=I.getBroadcastDims(r.shape,e),c=u-a,m="";if(a===0)return t?`
      fn ${i}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {
        return get${s}();
      }

      fn ${i}ByCoords(coords : ${l}) -> vec4<f32> {
        return get${s}();
      }
    `:`
      fn ${i}ByGlobalIndex(globalIndex : i32) -> f32{
        return get${s}();
      }

      fn ${i}ByCoords(coords : ${l}) -> f32{
        return get${s}();
      }
    `;u<2&&p.length>=1?m="coords = 0;":m=p.map(g=>`coords[${g+c}] = 0;`).join(`
`);let d="";if(u<2&&a>0)d="coords";else if(u>1){let g=Zt(a),x=r.shape.map((y,T)=>`coords[${T+c}]`).join(", ");d=`${g}(${x})`}else d="coords";let f=`uniforms.${o.charAt(0).toLowerCase()+o.slice(1)}Shape`,h=`${a}D`;return t?`
      fn ${i}ByGlobalIndex(globalIndex : i32) -> vec4<f32> {
        var coords = getCoordsFromFlatIndex(globalIndex);
        ${m}
        return ${o}.numbers[getFlatIndex${h}(${d}, ${f}) / 4];
      }

      fn ${i}ByCoords(coordsIn : ${l}) -> vec4<f32> {
        var coords = coordsIn;
        ${m}
        return ${o}.numbers[getFlatIndex${h}(${d}, ${f}) / 4];
      }
    `:`
    fn ${i}ByGlobalIndex(globalIndex : i32) -> f32 {
      var coords = getCoordsFromFlatIndex(globalIndex);
      ${m}
      return f32(${o}.numbers[getFlatIndex${h}(${d}, ${f})]);
    }

    fn ${i}ByCoords(coordsIn : ${l}) -> f32 {
      var coords = coordsIn;
      ${m}
      return f32(${o}.numbers[getFlatIndex${h}(${d}, ${f})]);
    }
  `}function Cue(r,e){let{x:t,y:n=[],z:o=[]}=e,s=r.length;if(t.length===s)return[`fn getOutputCoordsWithFlatDispatchLayout(globalId : vec3<u32>, localId : vec3<u32>, numWorkgroups: vec3<u32>) -> ${Zt(s)}{
      let globalIndex = getGlobalIndex(globalId, localId, numWorkgroups);
      return getCoordsFromFlatIndex(globalIndex);
    }
    `,s];let i="",a=[t,n,o],u=0;for(let m=0;m<a.length;m++){let d=a[m];if(d.length!==0)if(u+=d.length,d.length===1)i+=`let d${d[0]} = i32(globalId[${m}]);`;else{let f=AG(d,"uniforms.outShape");i+=`var index${m} = i32(globalId[${m}]);`;for(let h=0;h<f.length;h++)i+=`let d${d[h]} = index${m} / ${f[h]};`,h===f.length-1?i+=`let d${d[h+1]} = index${m} - d${d[h]} * ${f[h]};`:i+=`index${m} = index${m} - d${d[h]} * ${f[h]};`}}let l=[];for(let m=0;m<u;m++)l.push(`d${m}`);let p=Zt(u),c=`fn getOutputCoordsWithNonFlatDispatchLayout(globalId : vec3<u32>) -> ${p} {
    ${i}
  `;return l.length===0?c+=`return ${p}(0); }`:c+=`return ${p}(${l.join(",")}); }`,[c,u]}function MG(r){let e=r.length;if(e<=1)return"fn getCoordsFromFlatIndex(index : i32) -> i32 { return index; }";let t=b.computeStrides(r),n=Zt(e),o=[];for(let i=0;i<e;i++)o.push(`d${i}`);if(t.length===1)return`    fn getCoordsFromFlatIndex(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;
      return vec2<i32>(d0, d1);
    }`;let s="var index2 = index;"+t.map((i,a)=>{let u=`let ${o[a]} = index2 / uniforms.outShapeStrides[${a}]`,l=a===t.length-1?`let ${o[a+1]} = index2 - ${o[a]} * uniforms.outShapeStrides[${a}]`:`index2 = index2 - ${o[a]} * uniforms.outShapeStrides[${a}]`;return`${u}; ${l};`}).join("");return`
    fn getCoordsFromFlatIndex(index : i32) -> ${n} {
      ${s}
      return ${n}(${o.join(",")});
    }
  `}var Zx={};Xe(Zx,{ArrayBufferToTypedArray:()=>BA,GPUBytesPerElement:()=>Qx,computeDispatch:()=>de,computeWorkGroupSizeForConv2d:()=>fg,computeWorkGroupSizeForMatMul:()=>hg,computeWorkPerThreadForConv2d:()=>gg,flatDispatchLayout:()=>Ie,isWebGPUSupported:()=>bg,tilesFitEvenlyIntoShape:()=>ns});var Op=65535;var zp=r=>{let e=1;for(let t=0;t<r.length;t++)e*=r[t];return e};function ns(r,e){if(r.length!==e.length)throw new Error(`Cannot compute whether rank ${r.length} tiles fit evenly into rank ${e.length} shape - ranks must match.`);return e.every((t,n)=>t%r[n]==0)}function de(r,e,t=[1,1,1],n=[1,1,1]){let[o,s,i]=[Math.ceil(zp(r.x.map(u=>e[u]))/(t[0]*n[0])),r.y?Math.ceil(zp(r.y.map(u=>e[u]))/(t[1]*n[1])):1,r.z?Math.ceil(zp(r.z.map(u=>e[u]))/(t[2]*n[2])):1];if(o<=Op&&s<=Op&&i<=Op)return[o,s,i];b.assert(o>Op&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let a=Math.ceil(Math.sqrt(o));return a>Op?(a=Math.ceil(Math.cbrt(o)),b.assert(a<=Op,()=>"Total dispatch size exceeds WebGPU maximum."),[a,a,a]):[a,a,1]}function fg(r,e){let t=zp(r.x.map(o=>e[o])),n=zp(r.y.map(o=>e[o]));return t<=4?[4,16,1]:n<=4?[16,4,1]:[16,16,1]}function hg(r,e,t){return r===1?[32,1,1]:t===1?[1,32,1]:[8,8,1]}function gg(r,e){let t=zp(r.x.map(o=>e[o])),n=zp(r.y.map(o=>e[o]));return t<=4?[1,2,1]:n<=4?[2,1,1]:[2,2,1]}function Ie(r){return{x:r.map((e,t)=>t)}}function Qx(r){if(r==="float32"||r==="int32"||r==="bool"||r==="string")return 4;if(r==="complex64")return 8;throw new Error(`Unknown dtype ${r}`)}function BA(r,e){if(e==="float32")return new Float32Array(r);if(e==="int32")return new Int32Array(r);if(e==="bool"||e==="string"){let t=new Int32Array(r),n=new ArrayBuffer(t.length),o=new Uint8Array(n);for(let s=0;s<t.length;s++)o[s]=t[s];return o}else throw new Error(`Unknown dtype ${e}`)}function bg(){return!!navigator.gpu}var st=(T=>(T[T.MUL=0]="MUL",T[T.ADD=1]="ADD",T[T.SUB=2]="SUB",T[T.DIV=3]="DIV",T[T.EQUAL=4]="EQUAL",T[T.GREATER=5]="GREATER",T[T.GREATER_EQUAL=6]="GREATER_EQUAL",T[T.LESS=7]="LESS",T[T.LESS_EQUAL=8]="LESS_EQUAL",T[T.LOGICAL_AND=9]="LOGICAL_AND",T[T.NOT_EQUAL=10]="NOT_EQUAL",T[T.SQUARED_DIFFERENCE=11]="SQUARED_DIFFERENCE",T[T.INT_DIV=12]="INT_DIV",T[T.POW=13]="POW",T[T.PRELU=14]="PRELU",T[T.MAX=15]="MAX",T[T.MIN=16]="MIN",T[T.COMPLEX_MULTIPLY_REAL=17]="COMPLEX_MULTIPLY_REAL",T[T.COMPLEX_MULTIPLY_IMAG=18]="COMPLEX_MULTIPLY_IMAG",T))(st||{}),Sue="return a + b;",wue="return areal * breal - aimag * bimag;",_ue="return areal * bimag + aimag * breal;",Aue="return a / b;",Nue="return a * b;",Due="return (a - b) * (a - b);",Pue="return a - b;",Mue="return f32(a == b);",Fue="return vec4<f32>(a == b);",Eue="return f32(a > b);",Rue="return vec4<f32>(a > b);",Lue="return f32(a >= b);",Bue="return vec4<f32>(a >= b);",$ue="return f32(a < b);",Oue="return vec4<f32>(a < b);",zue="return f32(a <= b);",Gue="return vec4<f32>(a <= b);",Uue="return f32(f32(a) >= 1.0 && f32(b) >= 1.0);",Wue=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,Kue=`
  if (isNanCustom(a)) { return a; }
  if (isNanCustom(b)) { return b; }
  `,FG=`
  if (isNaN.r) {
    resultTemp.r = uniforms.NAN;
  }
  if (isNaN.g) {
    resultTemp.g = uniforms.NAN;
  }
  if (isNaN.b) {
    resultTemp.b = uniforms.NAN;
  }
  if (isNaN.a) {
    resultTemp.a = uniforms.NAN;
  }
  `,Vue=`
  let s = sign(a) * sign(b);
  let ia = i32(round(a));
  let ib = i32(round(b));
  return f32(idiv(ia, ib, s));
  `,jue=`
  let ia = vec4<i32>(round(a));
  let ib = vec4<i32>(round(b));
  let cond = ib != vec4<i32>(0);
  var resultTemp = vec4<i32>(0);
  let s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    resultTemp[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    resultTemp[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    resultTemp[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    resultTemp[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4<f32>(resultTemp);
  `,Hue="return f32(a != b);",que="return vec4<f32>(a != b);",Xue=`
  if(a < 0.0 && floor(b) < b) {
    return uniforms.NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  if (round(abs(b) % 2.0) != 1.0) {
    return pow(abs(a), b);
  }
  return sign(a) * pow(abs(a), b);
  `,Yue=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = a < vec4<f32>(0.0) & floor(b) < b;
  ${FG}
  return resultTemp;
  `,Que="if (a < 0.0) { return b * a; }  return a;",Zue=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
  `;function EG(r,e){let t=e?FG:Kue;return e?`
    var resultTemp = vec4<f32>(${r}(a, b));
    let isNaN = isNanCustomVec4(a) | isNanCustomVec4(b);
    `+t+`
    return resultTemp;
  `:t+`
    return ${r}(a, b);
  `}function Ci(r,e){switch(r){case 0:return Nue;case 1:return Sue;case 2:return Pue;case 3:return Aue;case 4:return e?Fue:Mue;case 5:return e?Rue:Eue;case 6:return e?Bue:Lue;case 7:return e?Oue:$ue;case 8:return e?Gue:zue;case 9:return e?Wue:Uue;case 10:return e?que:Hue;case 11:return Due;case 12:return e?jue:Vue;case 14:return e?Zue:Que;case 15:return EG("max",e);case 16:return EG("min",e);case 13:return e?Yue:Xue;case 17:return wue;case 18:return _ue;default:throw new Error(`BinaryType ${r} is not implemented!`)}}var Ke=(P=>(P[P.ABS=0]="ABS",P[P.CEIL=1]="CEIL",P[P.COS=2]="COS",P[P.COSH=3]="COSH",P[P.ELU=4]="ELU",P[P.EXP=5]="EXP",P[P.EXPM1=6]="EXPM1",P[P.FLOOR=7]="FLOOR",P[P.LINEAR=8]="LINEAR",P[P.LOG=9]="LOG",P[P.LOGICAL_NOT=10]="LOGICAL_NOT",P[P.NEG=11]="NEG",P[P.PRELU=12]="PRELU",P[P.RELU=13]="RELU",P[P.RELU6=14]="RELU6",P[P.LEAKYRELU=15]="LEAKYRELU",P[P.RSQRT=16]="RSQRT",P[P.SIN=17]="SIN",P[P.SINH=18]="SINH",P[P.SIGMOID=19]="SIGMOID",P[P.SQRT=20]="SQRT",P[P.SQUARE=21]="SQUARE",P[P.TANH=22]="TANH",P[P.TO_INT=23]="TO_INT",P))(Ke||{}),Jue="return abs(a);",ele="return ceil(a);",tle="return cos(a);",rle=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,nle="return exp(a) - 1.0;",ole="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",sle=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,ale="return exp(a);",ile="return floor(a);",ule="return a;",lle=`if (a < 0.0) { return 1.0/0.0; }
  return log(a);`,ple="return f32(!(a >= 1.0));",cle="return -a;",mle="return (a < 0.0) ? b * a : a;",dle="if (a < 0.0) { return uniforms.alpha * a; } return a;",fle="return max(a, 0.0);",hle="return clamp(a, 0.0, 6.0);",gle="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",ble=`
  var resFloat = a * vec4<f32>(a >= vec4<f32>(0.0));
  let isNaN = isNanCustomVec4(a);

  if (isNaN.r) {
    resFloat.r = a.r;
  }
  if (isNaN.g) {
    resFloat.g = a.g;
  }
  if (isNaN.b) {
    resFloat.b = a.b;
  }
  if (isNaN.a) {
    resFloat.a = a.a;
  }
  return resFloat;
`,yle="return 1.0/sqrt(a);",xle="return 1.0 / (1.0 + exp(-1.0 * a));",Tle="return sin(a);",kle=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,Ile="return sqrt(a);",Cle="return a * a;",vle=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,Sle="return f32(i32((a)));";function xl(r,e){switch(r){case 0:return Jue;case 2:return tle;case 3:return rle;case 1:return ele;case 4:return e?sle:ole;case 5:return ale;case 6:return nle;case 7:return ile;case 8:return ule;case 9:return lle;case 10:return ple;case 11:return cle;case 12:return mle;case 15:return dle;case 13:return e?ble:fle;case 14:return e?gle:hle;case 16:return yle;case 19:return xle;case 17:return Tle;case 18:return kle;case 20:return Ile;case 21:return Cle;case 22:return vle;case 23:return Sle;default:throw new Error(`BinaryType ${r} is not implemented!`)}}function Jr(r,e=!1){if(r===null)return null;if(r==="linear")return xl(Ke.LINEAR);if(r==="relu")return xl(Ke.RELU,e);if(r==="elu")return xl(Ke.ELU,e);if(r==="relu6")return xl(Ke.RELU6,e);if(r==="prelu")return Ci(st.PRELU,e);if(r==="sigmoid")return xl(Ke.SIGMOID);throw new Error(`Activation ${r} has not been implemented for the WebGPU backend.`)}function $A(r,e){let t={RowPerThread:r[1],ColPerThread:r[0],TileAOuter:e[1]*r[1],TileBOuter:e[0]*r[0],TileInner:e[0]*r[0]};return`
  var<workgroup> mm_Asub : array<array<vec4<f32>, ${t.TileInner/t.ColPerThread}>, ${t.TileAOuter}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${t.TileBOuter/t.ColPerThread}>, ${t.TileInner}>;

  let RowPerThread = ${t.RowPerThread};
  let ColPerThread = ${t.ColPerThread}; // only support ColPerThread = 4
  let TileAOuter = ${t.TileAOuter};
  let TileBOuter = ${t.TileBOuter};
  let TileInner = ${t.TileInner};

  ${Ii()} {

    let tileRow = i32(localId.y) * RowPerThread;
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * RowPerThread;
    let globalCol = i32(globalId.x);
    let numTiles = (uniforms.dimInner - 1) / TileInner + 1;

    var acc: array<vec4<f32>, ${t.RowPerThread}>;
    var ACached : vec4<f32>;
    var BCached : array<vec4<f32>, 4>;

    // Loop over shared dimension.
    var globalColA = tileCol;
    let RowPerThreadB = TileInner / ${e[1]};
    let tileRowB = i32(localId.y) * RowPerThreadB;
    for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);
        }
        globalColA = globalColA + TileInner / ColPerThread;

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileInner / ColPerThread; k = k + 1) {
            BCached[0] = mm_Bsub[k * ColPerThread][tileCol];
            BCached[1] = mm_Bsub[k * ColPerThread + 1][tileCol];
            BCached[2] = mm_Bsub[k * ColPerThread + 2][tileCol];
            BCached[3] = mm_Bsub[k * ColPerThread + 3][tileCol];

            for (var i = 0; i < RowPerThread; i = i + 1) {
                ACached = mm_Asub[tileRow + i][k];
                acc[i] = BCached[0] * ACached.x + acc[i];
                acc[i] = BCached[1] * ACached.y + acc[i];
                acc[i] = BCached[2] * ACached.z + acc[i];
                acc[i] = BCached[3] * ACached.w + acc[i];
            }
        }

        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < RowPerThread; innerRow = innerRow + 1) {
        mm_write(globalRow + innerRow,
                 globalCol,
                 acc[innerRow], globalId);
    }
}`}function wle(r){return`
  var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;
  let tileSize = ${r[0]*4};
  ${Ii()} {
    let tileCol = i32(localId.x);
    let globalCol = i32(globalId.x);
    let globalRow = i32(globalId.y);

    let numTiles = (uniforms.dimInner - 1) / tileSize + 1;

    // Without this initialization strange values show up in acc.
    var acc = vec4<f32>(0.0);

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      let colA = t * tileSize / 4 + tileCol;
      mm_Asub[tileCol] = mm_readA(globalRow, colA, globalId);

      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileSize / 4; k = k + 1) {
        let rowB = t * tileSize + k * 4;
        let BCached0 = mm_readB(rowB, globalCol, globalId);
        let BCached1 = mm_readB(rowB + 1, globalCol, globalId);
        let BCached2 = mm_readB(rowB + 2, globalCol, globalId);
        let BCached3 = mm_readB(rowB + 3, globalCol, globalId);

        let ACached = mm_Asub[k];
        acc = acc + BCached0 * ACached.x;
        acc = acc + BCached1 * ACached.y;
        acc = acc + BCached2 * ACached.z;
        acc = acc + BCached3 * ACached.w;
      }

      workgroupBarrier();
    }

    if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
      mm_write(globalRow, globalCol, acc, globalId);
    }
  }
`}var OA=class{constructor(e,t,n,o=null,s=null,i=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.workGroupSize=[16,16,1];this.isVec4=!0;this.vecSize=4;this.outputShape=t,this.workGroupSize=hg(t[1],e[2],t[2]),this.dispatchLayout={x:[2],y:[1],z:[0]},t[1]===1&&(n=1),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.vecSize,n,1]);let a=o!=null,u=i!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.addBias=a,this.activation=s,this.hasPreluActivationWeights=u,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`matMulPackedVec4_${n}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(){let e=this.aShape[2],t=this.outputShape[2],n=[this.outputShape[0],e,t],o=this.workGroupSize[1]*this.workPerThread,s=this.workGroupSize[0]*this.vecSize,i=s,a=[o,i],u=[i,s];return[ns(a,this.aShape.slice(1)),ns(u,n.slice(1))]}getUserCode(){let e=this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col]":`if (coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
            return A.numbers[batch * batchASize + row * uniforms.dimInner / 4 + col];
        }
        return vec4<f32>(0.0)`,t=this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col]":`if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4 + col];
        }
        return vec4<f32>(0.0)`,n="",o="";if(this.activation){let a=Jr(this.activation,this.isVec4);this.hasPreluActivationWeights?n=`fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${a}
                }`:n=`
            fn activation(a : vec4<f32>, outCoord : vec3<i32>) -> vec4<f32> {
              ${a}
            }`,o="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}
      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${e};
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> vec4<f32> {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / ${this.vecSize};
        let batch = i32(globalId.z);
        ${t};
      }

      fn mm_write(row : i32, col : i32, valueIn : vec4<f32>, globalId : vec3<u32>) {
        if (row < uniforms.aShape[1] && col * 4 < uniforms.bShape[2])
        {
          var value = valueIn;
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col * 4);
          ${s}
          ${o}
          setOutput(outCoord[0], outCoord[1], outCoord[2], value);
        }
      }
      ${this.outputShape[1]>1?$A([this.vecSize,this.workPerThread,1],this.workGroupSize):wle(this.workGroupSize)}

    `}};function yg(r,e){let t=e[1]*r[1],n=e[0]*r[0],o=t>n?t:n;return`
    var<workgroup> mm_Asub : array<array<f32, ${o}>, ${t}>;
    var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${o}>;
    ${Ii()} {
      let tileRow = i32(localId.y) * ${r[1]};
      let tileCol = i32(localId.x) * ${r[0]};

      let globalRow = i32(globalId.y) * ${r[1]};
      let globalCol = i32(globalId.x) * ${r[0]};

      let numTiles = (uniforms.dimInner - 1) / ${o} + 1;

      var acc : array<array<f32, ${r[0]}>, ${r[1]}>;
      var ACached : f32;
      var BCached : array<f32, ${r[0]}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {
          acc[innerRow][innerCol] = 0.0;
        }
      }

      let ColPerThreadA = ${o} / ${e[0]};
      let tileColA = i32(localId.x) * ColPerThreadA;
      let RowPerThreadB = ${o} / ${e[1]};
      let tileRowB = i32(localId.y) * RowPerThreadB;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ColPerThreadA; innerCol = innerCol + 1) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileColA + innerCol;

            mm_Asub[inputRow][inputCol] = mm_readA(
                globalRow + innerRow,
                t * ${o} + inputCol, globalId);
          }
        }
        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < RowPerThreadB; innerRow = innerRow + 1) {
          for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol + innerCol;

            mm_Bsub[inputRow][inputCol] = mm_readB(
              t * ${o} + inputRow,
              globalCol + innerCol, globalId);
          }
        }

        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${o}; k = k + 1) {
          for (var inner = 0; inner < ${r[0]}; inner = inner + 1) {
            BCached[inner] = mm_Bsub[k][tileCol + inner];
          }

          for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
            ACached = mm_Asub[tileRow + innerRow][k];
            for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {
              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
            }
          }
        }

        workgroupBarrier();
      }

      for (var innerRow = 0; innerRow < ${r[1]}; innerRow = innerRow + 1) {
        for (var innerCol = 0; innerCol < ${r[0]}; innerCol = innerCol + 1) {

          if ((globalCol + innerCol) < uniforms.dimBOuter &&
              (globalRow + innerRow) < uniforms.dimAOuter) {
            mm_write(globalRow + innerRow,
                     globalCol + innerCol,
                     acc[innerRow][innerCol], globalId);
          }
        }
      }
    }
  `}function _le(r){return`
    let TileSize = ${r[0]*4};
    var<workgroup> mm_Asub : array<vec4<f32>, ${r[0]}>;

    ${Ii()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / TileSize + 1;

      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t = t + 1) {
        // Load one tile of A into local memory.
        let colA = t * TileSize + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),
                                mm_readA(globalRow, colA + 1, globalId),
                                mm_readA(globalRow, colA + 2, globalId),
                                mm_readA(globalRow, colA + 3, globalId));
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < TileSize / 4; k = k + 1) {
          let rowB = t * TileSize + k * 4;
          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),
                              mm_readB(rowB + 1, globalCol, globalId),
                              mm_readB(rowB + 2, globalCol, globalId),
                              mm_readB(rowB + 3, globalCol, globalId));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {
        mm_write(globalRow, globalCol, acc, globalId);
      }
    }
  `}var xg=class{constructor(e,t,n,o=!1,s=!1,i=null,a=null,u=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.workGroupSize=[16,16,1];this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};let l=o?e[1]:e[2];this.workGroupSize=hg(t[1],l,t[2]),(t[1]===1||t[2]===1)&&(n=1),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]),b.arraysEqual(this.dispatch,[1,1,1])&&(n=1,this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[n,n,1]));let p=i!=null,c=u!=null;p&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.workPerThread=n,this.aShape=e,this.transposeA=o,this.transposeB=s,this.addBias=p,this.activation=a,this.hasPreluActivationWeights=c;let m=this.outputShape[2],d=this.transposeB?[this.outputShape[0],m,l]:[this.outputShape[0],l,m];[this.fitA,this.fitB]=this.getShapeFit(d),this.shaderKey=`matMulPacked_${this.workPerThread}_${o}_${s}_${this.activation}_${this.fitA}_${this.fitB}_${this.outputShape[1]>1}`}getShapeFit(e){let t=this.workGroupSize[1]*this.workPerThread,n=this.workGroupSize[0]*this.workPerThread,o=t>n?t:n;this.outputShape[1]===1&&(o*=4),b.assert(o%this.workGroupSize[0]==0&&o%this.workGroupSize[1]==0,()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y");let s=[t,o],i=[o,n];return[ns(s,this.aShape.slice(1)),ns(i,e.slice(1))]}getUserCode(){let e;this.transposeA===!1?e=this.fitA?"return A.numbers[batch * batchASize + row * uniforms.dimInner + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
           }
           return 0.0;`:e=this.fitA?"return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
             return A.numbers[batch* batchASize + col * uniforms.dimAOuter + row];
           }
           return 0.0;`;let t;this.transposeB===!1?t=this.fitB?"return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
           }
           return 0.0;`:t=this.fitB?"return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
             return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];
           }
           return 0.0;`;let n="",o="";if(this.activation){let a=Jr(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${a}
            }`:n=`
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${a}
              }
            `,o="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }

      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }

      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        var value = valueIn;
        let batch = i32(globalId.z);
        let outCoord = vec3<i32>(batch, row, col);
        ${s}
        ${o}
        setOutput(batch, row, col, value);
      }
      ${this.outputShape[1]>1?yg([this.workPerThread,this.workPerThread,1],this.workGroupSize):_le(this.workGroupSize)}
    `}};function Ale(){return`
    var<workgroup> sumValues : array<f32, workGroupSizeX>;
    ${Ii()} {
      let coords = getOutputCoordsWithNonFlatDispatchLayout(globalId);
      let batch = coords[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + i32(workGroupSizeX)) {
        let dataA = mm_readA(batch, row, k);
        let dataB = mm_readB(batch, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = workGroupSizeX / 2u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}var zA=class{constructor(e,t=!1,n=!1,o=null,s=null,i=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.workGroupSize=[256,1,1];this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize);let a=o!=null,u=i!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=a,this.activation=s,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){let e;this.transposeA===!1?e="return A.numbers[batch * batchASize + row * uniforms.dimInner + col];":e="return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];";let t;this.transposeB===!1?t="return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];":t="return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];";let n="",o="";if(this.activation){let a=Jr(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${a}
            }`:n=`
              fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
                ${a}
              }
            `,o="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(batch: i32, row : i32, col : i32) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        ${e}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> f32 {
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : f32) {
        var value = valueIn;
        let outCoord = vec3<i32>(batch, row, col);
        ${s}
        ${o}
        setOutput(batch, row, col, value);
      }
      ${Ale()}
    `}};function Nle(r){let e=r[1]/2,t=r[0],n=e>t?e:t;return`
  var<workgroup> mm_Asub1 : array<array<f32, ${n}>, ${e}>;
  var<workgroup> mm_Bsub1 : array<array<f32, ${t}>, ${n}>;
  var<workgroup> mm_Asub2 : array<array<f32, ${n}>, ${e}>;
  var<workgroup> mm_Bsub2 : array<array<f32, ${t}>, ${n}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Introduces two shared memory buffers, some logical threads could handle
  // arithmetic operations and others handle IO operations between barrier api,
  // makes ALUs and load/store units work simultaneously, could improves
  // the performance.
  ${Ii()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${n} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = tileRow;
    for (var t = 0; t < numTiles; t = t + 1) {
      if (t == 0) {
        if (tileRow < ${e}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${n};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${n};
        }
      } else {
        if (tileRow < ${e}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub1[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${n};
          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${n};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${n}; k = k + 1) {
            let subRow = tileRow - ${e};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub2[subRow][k] * mm_Bsub2[k][tileCol];
          }
        }
      }
      workgroupBarrier();
      if (t != 0) {
        t = t + 1;
      }

      if (t < numTiles) {
        if (tileRow < ${e}) {
          // Load one tile of A and B into local memory.
          // globalRow is always greater than or equal tileRow.
          mm_Asub2[tileRow][tileCol] =
              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA, globalId);
          globalColA = globalColA + ${n};
          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);
          globalRowB = globalRowB + ${n};
        } else {
          // Compute acc values for a single thread.
          for (var k = 0; k < ${n}; k = k + 1) {
            let subRow = tileRow - ${e};
            if (subRow < 0) {
              continue;
            }
            acc = acc + mm_Asub1[subRow][k] * mm_Bsub1[k][tileCol];
          }
        }
      }
      workgroupBarrier();
    }
    let writeCol = (globalRow - tileRow) / 2 + tileRow - ${e};
    if (tileRow >= ${e} && writeCol >= 0) {
      mm_write(writeCol, globalCol, acc, globalId);
    }
  }
  `}var GA=class{constructor(e,t,n,o=null,s=null,i=null){this.variableNames=["A","B"];this.uniforms="dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.workGroupSize=[8,16,1];b.assert(e[1]<=16||t[2]<=16,()=>"This program can be only used when A width or B Height are small"),this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workGroupSize[0]),Math.ceil(n[1]*2/this.workGroupSize[1]),n[0]];let a=o!=null;a&&this.variableNames.push("bias");let u=i!=null;u&&this.variableNames.push("preluActivationWeights"),this.addBias=a,this.activation=s,this.hasPreluActivationWeights=u,this.shaderKey=`matMulSmallOutputSize_${this.activation}`}getUserCode(){let e=`if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimInner))) {
          return A.numbers[batch * batchASize + row * uniforms.dimInner + col];
        }
        return 0.0;`,t=`if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];
         }
         return 0.0;`,n="",o="";if(this.activation){let a=Jr(this.activation,!1);this.hasPreluActivationWeights?n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
            ${a}
            }`:n=`fn activation(a : f32, outCoord : vec3<i32>) -> f32 {
            ${a}
        }`,o="value = activation(value, outCoord);"}let s=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${n}

      fn mm_readA(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];
        let batch = i32(globalId.z);
        ${e}
      }
      fn mm_readB(row : i32, col : i32,  globalId : vec3<u32>) -> f32 {
        let batch = i32(globalId.z);
        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];
        ${t}
      }
      fn mm_write(row : i32, col : i32, valueIn : f32, globalId : vec3<u32>) {
        if (coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimAOuter, uniforms.dimBOuter))) {
          let batch = i32(globalId.z);
          let outCoord = vec3<i32>(batch, row, col);
          var value = valueIn;
          ${s}
          ${o}
          setOutput(batch, row, col, value);
        }
      }
      ${Nle(this.workGroupSize)}
    `}};function Be(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=b.sizeFromShape(n.shape),i=b.inferFromImplicitShape(o,s),a=b.sizeFromShape(i);return b.assert(s===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${n.shape}) has ${s} elements. The new shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var RG={kernelName:Ts,backendName:"webgpu",kernelFunc:Be};function jm({a:r,b:e,transposeA:t,transposeB:n,backend:o,bias:s=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){let l=r.shape.length,p=e.shape.length,c=t?r.shape[l-2]:r.shape[l-1],m=n?e.shape[p-1]:e.shape[p-2],d=t?r.shape[l-1]:r.shape[l-2],f=n?e.shape[p-2]:e.shape[p-1],h=r.shape.slice(0,-2),g=e.shape.slice(0,-2),x=b.sizeFromShape(h),y=b.sizeFromShape(g),k=Ar.assertAndGetBroadcastShape(r.shape.slice(0,-2),e.shape.slice(0,-2)).concat([d,f]);b.assert(c===m,()=>`Error in matMul: inner shapes (${c}) and (${m}) of Tensors with shapes ${r.shape} and ${e.shape} and transposeA=${t} and transposeB=${n} must match.`);let C=t?[x,c,d]:[x,d,c],A=n?[y,f,m]:[y,m,f],M=Be({inputs:{x:r},backend:o,attrs:{shape:C}}),P=Be({inputs:{x:e},backend:o,attrs:{shape:A}}),F=[M,P],B=Math.max(x,y),U=c%4==0&&f%4==0&&!t&&!n&&f>=32,W;d*f<=32?W=new zA([B,d,f],t,n,s,u,i):!t&&!n&&(d<=16&&(f<=512||m>=2*f)||f<=16&&(d<=512||c>=2*d))?W=new GA(C,A,[B,d,f],s,u,i):U?W=new OA(C,[B,d,f],$().get("WEBGPU_MATMUL_WORK_PER_THREAD"),s,u,i):W=new xg(C,[B,d,f],$().get("WEBGPU_MATMUL_WORK_PER_THREAD"),t,n,s,u,i);let K=[M,P];s&&K.push(s),i&&K.push(i);let j=[{type:"int32",data:[d]},{type:"int32",data:[f]},{type:"int32",data:[c]}],V=o.runWebGPUProgram(W,K,r.dtype,j),q=Be({inputs:{x:V},backend:o,attrs:{shape:k}});F.push(V);for(let ee of F)o.disposeData(ee.dataId);return q}function Dle(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n;return jm({a:o,b:s,transposeA:u,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:c,activation:p})}var LG={kernelName:As,backendName:"webgpu",kernelFunc:Dle};var Jx=class{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"];this.workGroupSize=[128,1,1];this.size=!0;this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${Ci(this.op,!1)}
      }

      ${ve()}
        if(index < uniforms.size) {
          let areal = getARealAtOutCoordsByGlobalIndex(index);
          let aimag = getAImagAtOutCoordsByGlobalIndex(index);
          let breal = getBRealAtOutCoordsByGlobalIndex(index);
          let bimag = getBImagAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}};var UA=class{constructor(e,t,n,o){this.variableNames=["A","B"];this.size=!0;let s=256;this.workGroupSize=[s,1,1],this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=Ie(this.outputShape),this.lastDimensionSize=o?n[0]:t[0],this.lastDimensionSize<256?this.workPerThread=1:this.lastDimensionSize<512?this.workPerThread=2:this.workPerThread=4,this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.useSharedMemoryWithB=o,this.op=e,this.shaderKey=`binaryShared_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`}getUserCode(){let e=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",t=this.useSharedMemoryWithB?`let a = getAAtOutCoordsByCoords(coords);
         let b = sharedBuf[${e}];`:`let a = sharedBuf[${e}];
         let b = getBAtOutCoordsByCoords(coords);`;return`
        fn binaryOperation(a : f32, b : f32) -> f32 {
          ${Ci(this.op,!1)}
        }
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${ve()}

          // Fill in the shared memory buffer. Here we need a loop to make sure
          // that all data in A|B are uploaded when |sharedMemorySize| is larger
          // than work group size.
          for(var localIndex = i32(localId.x); localIndex < ${this.lastDimensionSize}; localIndex = localIndex + ${this.workGroupSize[0]}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}.numbers[localIndex]);
          }
          workgroupBarrier();

          for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
            let flatIndex = index * ${this.workPerThread} + i;
            if(flatIndex < uniforms.size) {
              let coords = getCoordsFromFlatIndex(flatIndex);

              ${t}
              setOutputFlat(flatIndex, binaryOperation(a, b));
            }
          }
        }
        `}};var WA=class{constructor(e,t,n){this.variableNames=["A","B"];this.workPerThread=4;this.isVec4=!0;this.size=!0;let o=128;this.workGroupSize=[o,1,1],this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.op=e,this.shaderKey=`binaryVec4_${e}`}getUserCode(){return`
      fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
        ${Ci(this.op,this.isVec4)}
      }
      ${ve()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalIndex(index);
          let b = getBAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, binaryOperation(a, b));
        }
      }
    `}};var Tg=class{constructor(e,t,n){this.variableNames=["A","B"];this.size=!0;let o=128;this.workGroupSize=[o,1,1],this.outputShape=I.assertAndGetBroadcastShape(t,n),this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`binary_${e}`,this.op=e}getUserCode(){return`
      fn binaryOperation(a : f32, b : f32) -> f32 {
        ${Ci(this.op,!1)}
      }
      ${ve()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalIndex(index);
          let b = getBAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, binaryOperation(a, b));
        }
      }
      `}};function KA(r,e,t){if(b.arraysEqual(e,t)&&b.sizeFromShape(e)%4==0)return new WA(r,e,t);let o=e.length===1&&t.length>1&&e[0]<1024,s=t.length===1&&e.length>1&&t[0]<1024;return o||s?new UA(r,e,t,s):new Tg(r,e,t)}function Sr(r){let{inputs:e}=r,{x:t}=e;return r.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}var BG={kernelName:jn,backendName:"webgpu",kernelFunc:Sr};function Ka(r){let{inputs:e,backend:t}=r,{real:n,imag:o}=e,s=t.makeTensorInfo(n.shape,"complex64"),i=t.tensorMap.get(s.dataId),a=Sr({inputs:{x:n},backend:t}),u=Sr({inputs:{x:o},backend:t});return i.complexTensorInfos={real:a,imag:u},s}var $G={kernelName:Ru,backendName:"webgpu",kernelFunc:Ka};var Va=class{constructor(e,t){this.variableNames=["A"];this.size=!0;let n=128;this.workGroupSize=[n,1,1],this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.op=t,this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${xl(this.op,!1)}
      }
      ${ve()}
        if (index < uniforms.size) {
          let a = getAAtOutCoordsByGlobalIndex(index);
          setOutputFlat(index, unaryOperation(a));
        }
      }
      `}};function mt({opType:r,cpuKernelImpl:e,dtype:t}){return({inputs:n,backend:o})=>{let{x:s}=n,i=o,a=t||s.dtype;if(i.shouldExecuteOnCPU([s])&&e!=null){let l=i.tensorMap.get(s.dataId),p=e(l.values,a);return i.makeTensorInfo(s.shape,a,p)}let u=new Va(s.shape,r);return i.runWebGPUProgram(u,[s],a)}}function _t({opSnippet:r,cpuKernelImpl:e,supportsComplex:t=!1,dtype:n}){return({inputs:o,backend:s})=>{let{a:i,b:a}=o,u=s;if(t&&i.dtype==="complex64"){let c=u.tensorMap.get(i.dataId),m=u.tensorMap.get(a.dataId),d,f;if(r!==st.MUL)[d,f]=[[c.complexTensorInfos.real,m.complexTensorInfos.real],[c.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(g=>{let[x,y]=g,T={dataId:x.dataId,dtype:x.dtype,shape:i.shape},k={dataId:y.dataId,dtype:y.dtype,shape:a.shape},C=KA(r,i.shape,a.shape);return u.runWebGPUProgram(C,[T,k],Kt(x.dtype,y.dtype))});else{let g=new Jx(st.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),x=new Jx(st.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),y=[{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:m.complexTensorInfos.real.dataId,dtype:m.complexTensorInfos.real.dtype,shape:a.shape},{dataId:m.complexTensorInfos.imag.dataId,dtype:m.complexTensorInfos.imag.dtype,shape:a.shape}];d=u.runWebGPUProgram(g,y,"float32"),f=u.runWebGPUProgram(x,y,"float32")}let h=Ka({inputs:{real:d,imag:f},backend:u});return u.disposeData(d.dataId),u.disposeData(f.dataId),h}let l=n||Kt(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||u.shouldExecuteOnCPU([i,a]))&&e!=null){let c=u.tensorMap.get(i.dataId).values,m=u.tensorMap.get(a.dataId).values,d=i.dtype==="string"?I.fromUint8ToStringArray(c):c,f=i.dtype==="string"?I.fromUint8ToStringArray(m):m,[h,g]=e(i.shape,a.shape,d,f,l);return u.makeTensorInfo(g,l,h)}let p=KA(r,i.shape,a.shape);return u.runWebGPUProgram(p,[i,a],l)}}var{addImpl:OG,ceilImpl:zG,concatImpl:GG,equalImpl:UG,expImpl:WG,expm1Impl:KG,floorImpl:VG,gatherNdImpl:jG,gatherV2Impl:HG,greaterEqualImpl:qG,greaterImpl:XG,lessEqualImpl:YG,lessImpl:QG,logImpl:ZG,maxImpl:JG,maximumImpl:eU,minimumImpl:tU,multiplyImpl:rU,negImpl:nU,notEqualImpl:oU,prodImpl:sU,rangeImpl:aU,rsqrtImpl:iU,simpleAbsImpl:uU,sliceImpl:lU,stridedSliceImpl:pU,stringNGramsImpl:cU,subImpl:mU,tileImpl:dU,topKImpl:fU,transposeImpl:hU,uniqueImpl:tTr}=Dm;var Ple=mt({opType:Ke.ABS,cpuKernelImpl:uU}),gU={kernelName:ms,backendName:"webgpu",kernelFunc:Ple};var Mle=_t({opSnippet:st.ADD,cpuKernelImpl:OG,supportsComplex:!0}),bU={kernelName:_n,backendName:"webgpu",kernelFunc:Mle};var VA=class{constructor(e){this.workPerThread=4;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e[0],this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){let e=[];this.variableNames.forEach(o=>{e.push(`let v${o} = get${o}AtOutCoordsByCoords(coords);`)});let t=this.variableNames.map(o=>`v${o}`).join(" + ");return`
      ${ve()}
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputFlat(flatIndex, ${t});
          }
        }
      }
    `}};function Fle(r){let{inputs:e,backend:t}=r,n=e;if(n.length===1)return Sr({inputs:{x:n[0]},backend:t});let o=n.map(a=>a.dtype).reduce((a,u)=>Kt(a,u)),s=n.map(a=>a.shape),i=new VA(s);return t.runWebGPUProgram(i,n,o)}var yU={kernelName:oo,backendName:"webgpu",kernelFunc:Fle};var kg=class{constructor(e,t,n){this.workGroupSize=[64,1,1];this.variableNames=["x"];this.uniforms="axis : i32; infinityValue : f32;";this.size=!0;let o=[t];I.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),o,e.length),this.op=n==="min"?"<":">";let[s]=I.computeOutAndReduceShapes(e,o);this.outputShape=s.length===0?[1]:s,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,[1,1,1]),this.inputShape=e,this.shaderKey=`argMinMax${this.op}`}getUserCode(){let e=`
      var<workgroup> xBestIndices : array<i32, ${this.workGroupSize[0]}>;
      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
    `,t=(s,i)=>this.outputShape.length===1?s:`${s}[${i}]`,n=s=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape[${s}]`;return`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${e}

      // In order to get a flattened index into the input tensor, we need to
      // add back the index along the reduced dimension to |outputCoords|.
      // This function outputs the offset to the first value along
      // |axis| and the stride to get the next value of the input along |axis|.
      fn getInputCoordInfo(outputIndex : i32) -> vec2<i32>{
        let outputCoords = getCoordsFromFlatIndex(outputIndex);
        var i = ${this.outputShape.length-1};

        var stride = 1;
        var inputStride = 1;
        var offset = 0;

        for (var r = 1; r <= ${this.inputShape.length}; r = r + 1) {
          let length = ${n(`${this.inputShape.length} - r`)};
          if (${this.inputShape.length} - r == uniforms.axis) {
            inputStride = stride;
          } else {
            offset = offset + ${t("outputCoords","i")} * stride;
            i = i - 1;
          }
          stride = stride * length;
        }

        return vec2<i32>(offset, inputStride);
      }

      fn getInputIndex(coordInfo : vec2<i32>, index : i32) -> i32{
        return coordInfo[0] + coordInfo[1] * index;
      }

      ${ve()}
        let outputIndex = index / i32(workGroupSizeX);
        let coordInfo = getInputCoordInfo(outputIndex);
        let Length = ${n("uniforms.axis")};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;

        for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
            k = k + i32(workGroupSizeX)) {
          let candidate = f32(x.numbers[getInputIndex(coordInfo, k)]);
          if (!isNanCustom(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(Length), workGroupSizeX);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputFlatI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `}};var jA=class{constructor(e,t){this.variableNames=["A"];this.workGroupSize=[16,16,1];let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){return`
      let TILE_DIM = ${this.workGroupSize[0]};
      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0]+1}>, ${this.workGroupSize[0]}>;
      ${Vm()}
      fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,
              [[builtin(workgroup_id)]] workgroupId : vec3<u32>) {
        var x = i32(workgroupId.x) * TILE_DIM + i32(localId.x);
        var y = i32(workgroupId.y) * TILE_DIM + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] =
              A.numbers[y * width + x];
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * TILE_DIM + i32(localId.x);
        y = i32(workgroupId.x) * TILE_DIM + i32(localId.y);
        if (x < height && y < width) {
          setOutputFlat((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}};var HA=class{constructor(e,t){this.variableNames=["A"];this.workPerThread=4;this.workGroupSize=[64,1,1];this.size=!0;let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[t[o]];this.outputShape=n,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){let e=Zt(this.outputShape.length),t=Ele(this.newDim);return`
      ${ve()}

        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let resRC = getCoordsFromFlatIndex(flatIndex);
            setOutputFlat(flatIndex, A.numbers[getFlatIndex${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}};function Ele(r){let e=r.length;if(e>4)throw Error(`Transpose for rank ${e} is not yet supported`);let t=new Array(e);for(let n=0;n<r.length;n++)t[r[n]]=`resRC[${n}]`;return t.join()}function os(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{perm:s}=n,i=t,a=o.shape.length,u=new Array(a);for(let p=0;p<u.length;p++)u[p]=o.shape[s[p]];if(t.shouldExecuteOnCPU([o])){let c=i.tensorMap.get(o.dataId).values,m=hU(c,o.shape,o.dtype,s,u);return t.makeTensorInfo(u,o.dtype,m)}if(o.shape.length===2&&b.arraysEqual(s,[1,0])){let p=new jA(o.shape,s);return i.runWebGPUProgram(p,[o],o.dtype)}let l=new HA(o.shape,s);return i.runWebGPUProgram(l,[o],o.dtype)}var xU={kernelName:Ho,backendName:"webgpu",kernelFunc:os};function Rle(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=I.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=os({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=I.getInnerMostAxes(i.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMax",[i[0]],u.shape.length);let p=new kg(u.shape,i[0],"max"),c=[{type:"int32",data:[i[0]]},{type:"float32",data:[Number.NEGATIVE_INFINITY]}],m=t.runWebGPUProgram(p,[u],"int32",c);return l.forEach(d=>t.disposeData(d.dataId)),m}var TU={kernelName:so,backendName:"webgpu",kernelFunc:Rle};function Lle(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s}=n,i=b.parseAxisParam(s,o.shape),a=I.getAxesPermutation(i,o.shape.length),u=o,l=[];a!=null&&(u=os({inputs:{x:o},backend:t,attrs:{perm:a}}),l.push(u),i=I.getInnerMostAxes(i.length,u.shape.length)),I.assertAxesAreInnerMostDims("argMin",[i[0]],u.shape.length);let p=new kg(u.shape,i[0],"min"),c=[{type:"int32",data:[i[0]]},{type:"float32",data:[Number.POSITIVE_INFINITY]}],m=t.runWebGPUProgram(p,[u],"int32",c);return l.forEach(d=>t.disposeData(d.dataId)),m}var kU={kernelName:Qa,backendName:"webgpu",kernelFunc:Lle};var Ig=class{constructor(e,t){this.variableNames=["x"];this.uniforms="stride : vec2<i32>; pad : vec2<i32>; dilation : vec2<i32>; convDims : vec2<i32>; filterDims : vec2<i32>;";this.workGroupSize=[128,1,1];this.size=!0;this.outputShape=e.outShape,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`pool2D_${t}`,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";this.poolType==="avg"&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return this.poolType==="avg"&&(t="resultValue / count"),`
      ${ve()}
      if (index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};
          var count = 0.0;

          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, coords[3]);
              ${e}
            }
          }

          setOutputFlat(index, ${t});
        }
      }
    `}};var Cg=class{constructor(e){this.variableNames=["x"];this.uniforms="stride : vec2<i32>;";this.workGroupSize=[256,1,1];this.size=!0;this.outputShape=e.outShape,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${ve()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.stride;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputFlat(index, value);
        }
      }
    `}};function Ble(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1,p=I.computePool2DInfo(o.shape,s,i,l,a,u);if(p.filterWidth===1&&p.filterHeight===1&&b.arraysEqual(p.inShape,p.outShape))return Sr({inputs:{x:o},backend:t});let c,m=[{type:"int32",data:[p.strideHeight,p.strideWidth]}];return p.filterHeight===1&&p.filterWidth===1?c=new Cg(p):(c=new Ig(p,"avg"),m.push({type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]})),t.runWebGPUProgram(c,[o],o.dtype,m)}var IU={kernelName:ao,backendName:"webgpu",kernelFunc:Ble};function $le(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:i,transposeB:a}=n;return jm({a:o,b:s,transposeA:i,transposeB:a,backend:t})}var CU={kernelName:io,backendName:"webgpu",kernelFunc:$le};var qA=class{constructor(e,t){this.variableNames=["source"];this.workPerThread=1;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.rank=t.length,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Zt(e.length)}; `,this.shaderKey="slice"}getUserCode(){let e=Zt(this.rank),t=Ole(this.rank),n;return this.start.length===1?n=this.outputShape.map((s,i)=>"sourceLoc = uniforms.start + coords;"):n=this.outputShape.map((s,i)=>`sourceLoc.${XA[i]} = uniforms.start[${i}] + coords.${XA[i]};`),`
      ${ve()}
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromFlatIndex(index);
          ${n.join(`
`)}
          setOutputFlat(index, getSource(${t}));
        }
      }
    `}},XA=["x","y","z","w","u","v"];function Ole(r){if(r===1)return"sourceLoc";if(r<=6)return XA.slice(0,r).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}function ja(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,size:i}=n,[a,u]=Tt.parseSliceParams(o,s,i);if(Tt.assertParamsValid(o,a,u),t.shouldExecuteOnCPU([o])||o.dtype==="string"){let c=t.tensorMap.get(o.dataId),m=lU(c.values,a,u,o.shape,o.dtype);return t.makeTensorInfo(u,o.dtype,m)}if(b.sizeFromShape(u)===0)return t.makeTensorInfo(u,o.dtype,[]);let l=new qA(a,u),p=[{type:"int32",data:a}];return t.runWebGPUProgram(l,[o],o.dtype,p)}var vU={kernelName:Is,backendName:"webgpu",kernelFunc:ja};var zle=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:i}=n;b.assert(o.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");let a=s.reduce((y,T)=>y*T),u=I.getReshaped(o.shape,s,a),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,a),c=I.getSliceBeginCoords(i,s.length),m=I.getSliceSize(p,i,s.length),d=[],f=Be({inputs:{x:o},backend:t,attrs:{shape:u}}),h=os({inputs:{x:f},backend:t,attrs:{perm:l}}),g=Be({inputs:{x:h},backend:t,attrs:{shape:p}}),x=ja({inputs:{x:g},backend:t,attrs:{begin:c,size:m}});return d.push(f),d.push(h),d.push(g),d.forEach(y=>t.disposeData(y.dataId)),x},SU={kernelName:ds,backendName:"webgpu",kernelFunc:zle};var YA=_t({opSnippet:st.NOT_EQUAL,dtype:"bool",cpuKernelImpl:oU}),wU={kernelName:ma,backendName:"webgpu",kernelFunc:YA};function wu(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return Sr({inputs:{x:o.complexTensorInfos.real},backend:t})}var _U={kernelName:Wu,backendName:"webgpu",kernelFunc:wu};function AU(r,e){let t=new Va(r.shape,Ke.TO_INT),n=e.runWebGPUProgram(t,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function QA(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dtype:s}=n;if(s==="complex64"){if(o.dtype==="complex64")return Sr({inputs:{x:o},backend:t});let i=xt(o.shape),a=QA({inputs:{x:o},backend:t,attrs:{dtype:"float32"}}),u=Ka({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeData(a.dataId),u}if(o.dtype==="complex64"){let i=wu({inputs:{input:o},backend:t}),a=QA({inputs:{x:i},backend:t,attrs:{dtype:s}});return t.disposeData(i.dataId),a}if(!b.hasEncodingLoss(o.dtype,s)){let i=Sr({inputs:{x:o},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:s}}if(s==="int32")return AU(o,t);if(s==="bool"){let i=t.makeTensorInfo([],"bool",b.getTypedArrayFromDType("bool",1)),u=YA({inputs:{a:o,b:i},backend:t});return t.disposeData(i.dataId),u}throw new Error(`Error in Cast: failed to cast ${o.dtype} to ${s}`)}var NU={kernelName:Kn,backendName:"webgpu",kernelFunc:QA};var Gle=mt({opType:Ke.CEIL,cpuKernelImpl:zG}),DU={kernelName:uo,backendName:"webgpu",kernelFunc:Gle};var ZA=class{constructor(e){this.variableNames=["A"];this.uniforms="minVal : f32; maxVal : f32;";this.workPerThread=4;this.workGroupSize=[64,1,1];this.isVec4=!0;this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${ve()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalIndex(index);
          var clampedValue : vec4<f32>;
          for (var i = 0; i < 4; i = i + 1) {
            if (isNanCustom(value[i])) {
              clampedValue[i] = value[i];
            } else {
              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);
            }
          }

          setOutputFlat(index, clampedValue);
        }
      }
    `}};var JA=class{constructor(e){this.variableNames=["A"];this.uniforms="minVal : f32; maxVal : f32;";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${ve()}
        if(index < uniforms.size) {
          let value = getAAtOutCoordsByGlobalIndex(index);
          if (isNanCustom(value)) {
            setOutputFlat(index, value);
            return;
          }
          setOutputFlat(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}};function Ule(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:i}=n,a,u=[{type:"float32",data:[s]},{type:"float32",data:[i]}];return b.sizeFromShape(o.shape)%4==0?a=new ZA(o.shape):a=new JA(o.shape),t.runWebGPUProgram(a,[o],o.dtype,u)}var PU={kernelName:Vn,backendName:"webgpu",kernelFunc:Ule};var eN=class{constructor(e){this.uniforms="";this.workPerThread=4;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=I.computeOutShape(e,1),this.variableNames=e.map((t,n)=>`T${n}`),this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32;`;this.shaderKey="concat"}getUserCode(){let e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutput(coords.x, coords.y, getT0(yR, yC)); }");for(let s=1;s<this.offsetLength;s++)e.push(`elseif (yC < uniforms.offset${[s]}){ setOutput(coords.x, coords.y, getT${s}(yR, yC - uniforms.offset${s-1})); }`);let n=this.offsetLength,o=this.offsetLength-1;e.push(`else { setOutput(coords.x, coords.y, getT${n}(yR, yC - uniforms.offset${o})); }`)}else e.push("setOutput(coords.x, coords.y, getT0(yR, yC));");return`
      ${ve()}
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}};function Gp(r){let{inputs:e,backend:t}=r,{input:n}=e,o=t.tensorMap.get(n.dataId);return Sr({inputs:{x:o.complexTensorInfos.imag},backend:t})}var MU={kernelName:zu,backendName:"webgpu",kernelFunc:Gp};function eT(r,e,t){let n=r[0].dtype;if(n==="complex64"){let d=r.map(y=>wu({inputs:{input:y},backend:t})),f=r.map(y=>Gp({inputs:{input:y},backend:t})),h=eT(d,e,t),g=eT(f,e,t),x=Ka({inputs:{real:h,imag:g},backend:t});return d.forEach(y=>t.disposeData(y.dataId)),f.forEach(y=>t.disposeData(y.dataId)),t.disposeData(h.dataId),t.disposeData(g.dataId),x}let o=t.shouldExecuteOnCPU(r);if(n==="string"&&(o=!0),o){let d=r.map(k=>{let C=b.sizeFromShape(k.shape.slice(e));return Be({inputs:{x:k},backend:t,attrs:{shape:[-1,C]}})}),f=d.map(k=>({vals:t.readSync(k.dataId),shape:k.shape})),h=I.computeOutShape(d.map(k=>k.shape),1),g=d[0].shape[0]===1,x=GG(f,h,n,g),y=I.computeOutShape(r.map(k=>k.shape),e),T=t.makeTensorInfo(y,n,x);return d.forEach(k=>t.disposeData(k.dataId)),T}let{tensors2D:s,outShape:i}=Wle(r,e,t),a=s.map(d=>d.shape),u=new eN(a),l=[],p=new Array(a.length-1);if(p.length>0){p[0]=a[0][1],l.push({type:"int32",data:[p[0]]});for(let d=1;d<p.length;d++)p[d]=p[d-1]+a[d][1],l.push({type:"int32",data:[p[d]]})}let c=t.runWebGPUProgram(u,s,s[0].dtype,l);s.forEach(d=>t.disposeData(d.dataId));let m=Be({inputs:{x:c},backend:t,attrs:{shape:i}});return t.disposeData(c.dataId),m}function Wle(r,e,t){let n=I.computeOutShape(r.map(s=>s.shape),e);return{tensors2D:r.map(s=>Be({inputs:{x:s},backend:t,attrs:{shape:[b.sizeFromShape(s.shape.slice(0,e)),b.sizeFromShape(s.shape.slice(e))]}})),outShape:n}}function tN(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n,s=b.parseAxisParam(o,e[0].shape)[0],i=I.computeOutShape(e.map(l=>l.shape),s);if(b.sizeFromShape(i)===0)return t.makeTensorInfo(i,e[0].dtype,[]);let a=e.filter(l=>b.sizeFromShape(l.shape)>0);if(a.length===1)return Sr({inputs:{x:a[0]},backend:t});let u=a.map(l=>l.shape);return I.assertParamsConsistent(u,s),eT(a,s,t)}var FU={kernelName:fs,backendName:"webgpu",kernelFunc:tN};var rN=class{constructor(e,t){this.variableNames=["A"];this.uniforms=`pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; outWidth : i32; itemsPerBlockRow : i32;
      inChannels : i32;`;this.workPerThread=4;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?0:1,t=this.isChannelsLast?1:2;return`
    ${ve()}

      for(var i = 0; i<${this.workPerThread}; i = i + 1) {
        let flatIndex = index * ${this.workPerThread} + i;

        let rc = getCoordsFromFlatIndex(flatIndex);

        if(flatIndex < uniforms.size) {
          let blockIndex = rc[0];
          let pos = rc[1];

          let offsetY = blockIndex / uniforms.outWidth * uniforms.stride[1] - uniforms.pad[1];
          let d0 = offsetY + uniforms.dilation[1] * pos / uniforms.itemsPerBlockRow;
          var value = 0.0;
          if(d0 < uniforms.aShape[${e}] && d0 >= 0) {
            let offsetX = (blockIndex % uniforms.outWidth) * uniforms.stride[0] -
              uniforms.pad[0];
            let d1 = offsetX + uniforms.dilation[0] * ((pos %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
            let ch = pos % uniforms.inChannels;
            if(d1 < uniforms.aShape[${t}] && d1 >= 0) {
              value = getA(d0, d1, ch);
            }
          }
          setOutputFlat(flatIndex, value);
        }
      }
    }
  `}};function tT({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let u=r.shape,l=t.dataFormat==="channelsLast",p=!1,c=!1,m=l?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],d=Be({inputs:{x:r},backend:n,attrs:{shape:[1,m,t.inChannels]}}),f=Be({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),h=jm({a:d,b:f,transposeA:p,transposeB:c,backend:n,bias:o,activation:a,preluActivationWeights:s,leakyreluAlpha:i}),g=Be({inputs:{x:h},backend:n,attrs:{shape:t.outShape}});return n.disposeData(d.dataId),n.disposeData(f.dataId),n.disposeData(h.dataId),g}function EU({x:r,filter:e,convInfo:t,backend:n,bias:o=null,preluActivationWeights:s=null,leakyreluAlpha:i=0,activation:a=null}){let{filterWidth:u,filterHeight:l,inChannels:p,strideWidth:c,strideHeight:m,padInfo:d,outWidth:f,outHeight:h,dilationWidth:g,dilationHeight:x,dataFormat:y}=t,T=y==="channelsLast",k=u*l*p,C=h*f,A=[C,k],M=!1,P=!1,F=[],B=Be({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),U=Be({inputs:{x:e},backend:n,attrs:{shape:[1,k,-1]}});F.push(B),F.push(U);let W=new rN(A,T),K=[{type:"int32",data:[d.left,d.top]},{type:"int32",data:[c,m]},{type:"int32",data:[g,x]},{type:"int32",data:[f]},{type:"int32",data:[p*u]},{type:"int32",data:[p]}],j=n.runWebGPUProgram(W,[B],B.dtype,K),V=Be({inputs:{x:j},backend:n,attrs:{shape:[1,A[0],A[1]]}});F.push(j),F.push(V);let q=[1,A[0],A[1]],ee=new xg(q,[1,C,t.outChannels],$().get("WEBGPU_MATMUL_WORK_PER_THREAD"),M,P),Z=q[1],te=q[2],oe=t.outChannels,ie=[{type:"int32",data:[Z]},{type:"int32",data:[oe]},{type:"int32",data:[te]}],se=n.runWebGPUProgram(ee,[V,U],V.dtype,ie),ue=T?[1,h,f,t.outChannels]:[1,t.outChannels,h,f],ye=Be({inputs:{x:se},backend:n,attrs:{shape:ue}});F.push(se);for(let fe of F)n.disposeData(fe.dataId);return ye}var vg=class{constructor(e,t=!1,n=null,o=!1,s=!1){this.variableNames=["x","W"];this.uniforms=`filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      dimAOuter : i32; dimBOuter : i32; dimInner : i32;`;this.isVec4=!0;this.outputShape=e.outShape,b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=[8,8,1];let i=[4,4,1];this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,i),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,this.hasLeakyreluAlpha=s,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.hasLeakyreluAlpha&&this.variableNames.push("leakyreluAlpha"),[this.fitA,this.fitB]=this.getShapeFit(i),this.shaderKey=`conv2DMMVec4_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(e){let t=this.workGroupSize[1]*e[1],n=this.workGroupSize[0]*e[0],o=n,s=[t,o],i=[o,n],a=this.outputShape[1]*this.outputShape[2],u=this.outputShape[3],l=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[ns(s,[a,l]),ns(i,[l,u])]}getSampleAWithRemainder(e){return`let flatIndex${e} = getFlatIndex4D(coord, uniforms.xShape);
    let divBy4Remainder${e} = flatIndex${e} % 4;
    let divBy4Index${e} = flatIndex${e} / 4;
    let curData${e} = x.numbers[divBy4Index${e}];
    if (divBy4Remainder${e} == 0) {
      temp = curData${e};
    } else {
      // TODO: This could end up being a redundant load with another one in
      // the same shader invocation. Perhaps there's an opportunity for
      // optimization
      let nextData${e} = x.numbers[divBy4Index${e} + 1];
      if (divBy4Remainder${e} == 1) {
        temp = vec4<f32>(curData${e}.yzw, nextData${e}.x);
      } elseif (divBy4Remainder${e} == 2) {
        temp = vec4<f32>(curData${e}.zw, nextData${e}.xy);
      } elseif (divBy4Remainder${e} == 3) {
        temp = vec4<f32>(curData${e}.w, nextData${e}.xyz);
      }
    }
    `}getUserCode(){let t=$A([4,4,1],this.workGroupSize),s=`let outRow = r / uniforms.outShape[2];
        let outCol = r % uniforms.outShape[2];
        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);
        let WCol = c / uniforms.xShape[3] % uniforms.filterDims[1];
        let inChCoord = c % uniforms.xShape[3];
        var coord = vec4<i32>(
            batch,
            outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
            outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
            inChCoord);
        var resData = vec4<f32>(0.0);
        ${this.convInfo.inChannels%4===0?`// The bounds checking is always needed since we use it to pad zero for
          // the 'same' padding type.
          if (coordsInBounds4D(coord, uniforms.xShape)) {
            resData = x.numbers[getFlatIndex4D(coord, uniforms.xShape) / 4];
          } else {
            resData = vec4<f32>(0.0); }`:`var temp = vec4<f32>(0.0);
          ${this.getSampleAWithRemainder(1)}
          resData = temp;
          if (WCol == (uniforms.filterDims[1] - 1)) {
            coord = vec4<i32>(
              coord.x, coord.y + 1, coord.z + 1 - uniforms.filterDims[1], 0);
              ${this.getSampleAWithRemainder(2)}
            if (inChCoord == 0) {
              resData = vec4<f32>(resData.xyz, temp.x);
            } elseif (inChCoord == 1) {
              resData = vec4<f32>(resData.xy, temp.xy);
            } else {
              resData = vec4<f32>(resData.x, temp.xyz);
            }
          }
          `}
        return resData;`,i=this.fitA?`${s}`:`if (r < uniforms.dimAOuter && c < uniforms.dimInner) {
          ${s}
         }
         return vec4<f32>(0.0);
        `,a=this.fitB?"return W.numbers[row * uniforms.dimBOuter / 4 + col];":`if(coordsInBounds2D(vec2<i32>(row, col * 4), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter / 4 + col];
         }
         return vec4<f32>(0.0);
        `,u="",l="";if(this.activation){let m=Jr(this.activation,this.isVec4);if(this.hasPreluActivationWeights)u=`fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${m}
        }`;else{if(this.hasLeakyreluAlpha)throw u=`fn activation(a: vec4<f32>) -> vec4<f32> {
          let b = getLeakyreluAlphaAtOutCoords();
          ${m}
        }`,new Error("Leakyrelu is not supported.");u=`
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          ${m}
        }`}l="value = activation(value, outCoord);"}let p=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
        ${u}
        fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          let r = row;
          let c = col * 4;
          var batch = i32(globalId.z);
          ${i}
        }

        fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> vec4<f32> {
          ${a}
        }

        fn mm_write(row : i32, col : i32, valueInput : vec4<f32>, globalId : vec3<u32>) {
          var batch = i32(globalId.z);
          var value = valueInput;
          if (row < uniforms.dimAOuter && col * 4 < uniforms.dimBOuter)
          {
            let outCoord = vec4<i32>(
              batch,
              row / uniforms.outShape[2],
              row % uniforms.outShape[2],
              col * 4);
            ${p}
            ${l}
            setOutput(outCoord[0], outCoord[1], outCoord[2], outCoord[3],
              value);
          }
        }
        ${t}
      `}};var Sg=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.outputShape=e.outShape,b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=fg(this.dispatchLayout,this.outputShape),this.elementsPerThread=gg(this.dispatchLayout,this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,[this.fitA,this.fitB]=this.getShapeFit(),this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}_${this.fitA}_${this.fitB}`}getShapeFit(){let e=this.workGroupSize[1]*this.elementsPerThread[1],t=this.workGroupSize[0]*this.elementsPerThread[0],n=e>t?e:t;b.assert(n%this.workGroupSize[0]==0&&n%this.workGroupSize[1]==0,()=>"tileInner must be multiple of workgroupsize.x and workgroupsize.y");let o=[e,n],s=[n,t],i=this.outputShape[1]*this.outputShape[2],a=this.outputShape[3],u=this.convInfo.filterHeight*this.convInfo.filterWidth*this.convInfo.inChannels;return[ns(o,[i,u]),ns(s,[u,a])]}getUserCode(){let e=yg(this.elementsPerThread,this.workGroupSize),t=`
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.xShape[3]);
    let WCol = col / uniforms.xShape[3] % uniforms.filterDims[1];
    let coord = vec4<i32>(
        batch,
        outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0],
        outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1],
        col % uniforms.xShape[3]);
    // The bounds checking is always needed since we use it to pad zero for the
    // 'same' padding type.
    if(coordsInBounds4D(coord, uniforms.xShape)) {
      return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];
    }
    return 0.0;`,n=this.fitA?`${t}`:`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      ${t}
    }
    return 0.0;
    `,o=this.fitB?"return W.numbers[row * uniforms.dimBOuter + col];":`if(coordsInBounds2D(vec2<i32>(row, col), vec2<i32>(uniforms.dimInner, uniforms.dimBOuter))) {
           return W.numbers[row * uniforms.dimBOuter + col];
	 }
	 return 0.0;
	 `,s="",i="";if(this.activation){let l=Jr(this.activation,!1);this.hasPreluActivationWeights?s=`fn activation(a: f32, outCoord : vec4<i32>) -> f32 {
                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
                  ${l}
                }`:s=`
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
                    ${l}
                  }
                `,i="value = activation(value, outCoord);"}let a=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
    ${s}
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      ${n}
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      ${o}
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      ${a}
      ${i}
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }
    ${e}
  `}};var wg=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>; pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;";this.workGroupSize=[128,1,1];this.outputShape=e.outShape,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivationWeights=o,this.shaderKey=`conv2DNaive_${this.activation}`}getUserCode(){let e="",t="";if(this.activation){let s=Jr(this.activation);this.hasPreluActivationWeights?e=`fn activation(a : f32, outCoord : vec4<i32>) -> f32{
               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
               ${s}
             }`:e=`
                  fn activation(a : f32, outCoord : vec4<i32>) -> f32{
                    ${s}
                  }
                `,t="value = activation(value, outCoord);"}let n=this.addBias?"value = value + getBiasAtOutCoordsByCoords(outCoord);":"";return`
      ${e}
      fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32 {
        let coord = vec4<i32>(batch, row, col, chan);
        if(coordsInBounds4D(coord, uniforms.xShape)) {
          return getX(batch, row, col, chan);
        }
        return 0.0;
      }

      fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
        let coord = vec4<i32>(row, col, xChannel, outChannel);
        if(coordsInBounds4D(coord, uniforms.wShape)) {
          return getW(row, col, xChannel, outChannel);
        }
        return 0.0;
      }

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32, value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          ${n}
          ${t}
          setOutput(batch, row, col, chan, value);
        }
      }

      ${dg()} {
        let coords = getOutputCoordsWithFlatDispatchLayout(globalId, localId, numWorkgroups);
        let batch = coords[0];
        let outChannel = coords[3];

        var acc = 0.0;

        for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
          for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
            for (var xChannel = 0; xChannel < uniforms.xShape[3]; xChannel = xChannel + 1) {
              let coordRow = coords[1] * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];
              let coordCol = coords[2] * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];
              let v = readInp(batch, coordRow, coordCol, xChannel);
              let f = readFilt(row, col, xChannel, outChannel);
              acc = acc + v * f;
            }
          }
        }

        writeResult(batch, coords[1], coords[2], outChannel, acc);
      }
    `}};function Kle(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:p}=t,c=I.convertConv2DDataFormat(u),m=I.computeConv2DInfo(o.shape,s.shape,i,l,a,p,!1,c);if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))return tT({x:o,filter:s,convInfo:m,backend:n});if($().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")&&o.shape[0]===1)return EU({x:o,filter:s,convInfo:m,backend:n});let d,f=[m.padInfo.top,m.padInfo.left],h=[{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[...f]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.dilationHeight,m.dilationWidth]}],g=$().getBool("WEBGPU_USE_NAIVE_CONV2D");if(g?d=new wg(m):(m.inChannels%4==0||m.inChannels===3&&m.padInfo.type==="VALID")&&m.outChannels%4==0&&m.outChannels>=64?d=new vg(m):d=new Sg(m),!g){let x=m.outShape[1]*m.outShape[2],y=m.outShape[3],T=m.filterHeight*m.filterWidth*m.inShape[3];h.push({type:"int32",data:[x]},{type:"int32",data:[y]},{type:"int32",data:[T]})}return n.runWebGPUProgram(d,[o,s],o.dtype,h)}var RU={kernelName:lo,backendName:"webgpu",kernelFunc:Kle};var nN=class{constructor(e){this.variableNames=["x","W"];this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>; dimAOuter : i32; dimBOuter : i32; dimInner : i32;";this.outputShape=e.inShape,b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workGroupSize=fg(this.dispatchLayout,this.outputShape),this.elementsPerThread=gg(this.dispatchLayout,this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,this.elementsPerThread),this.shaderKey=`conv2DDerInputMM_${this.elementsPerThread}`}getUserCode(){return`
    fn mm_readA(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      var batch = i32(globalId.z);
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
      
    let outRow = row / uniforms.outShape[2];
    let outCol = row % uniforms.outShape[2];

    let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
    let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);
    let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);
    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
      return 0.0;
    }
    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
      return 0.0;
    }
    let coord = vec4<i32>(
        batch,
        i32(xR),
        i32(xC),
        col % uniforms.outBackprop[3]);
    return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];
    }
    return 0.0;
    }

    fn mm_readB(row : i32, col : i32, globalId : vec3<u32>) -> f32 {
      let coordX = uniforms.filterDims.x - 1 -
          row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let coordY = uniforms.filterDims.y - 1 -
          (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
          coordX >= 0 && coordY >= 0) {
        let coord = vec4<i32>(coordX, coordY, col,
            row % uniforms.outBackprop[3]);
        return W.numbers[getFlatIndex4D(coord, uniforms.wShape)];
      }
      return 0.0;
    }

    fn mm_write(row : i32, col : i32, valueInput : f32, globalId : vec3<u32>) {
      var batch = i32(globalId.z);
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;
    }

    ${yg(this.elementsPerThread,this.workGroupSize)}
  `}};var oN=class{constructor(e){this.variableNames=["dy","W"];this.uniforms="filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>;";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e.inShape,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerInput_${this.isChannelsLast}`}getUserCode(){let e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`
    ${ve()} {
      if(index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
        let batch = coords[0];
        let d1 = coords[${n}];

        let dyCorner = vec2<i32>(coords[${e}]), coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = dyR;

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = dyC;

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              if (${this.isChannelsLast}) {
                let xValue = getDy(batch, idyR, idyC, d2);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              } else {
                let xValue = getDy(batch, d2, idyR, idyC);
                let wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd = dotProd + xValue * wValue;
              }

            }
          }
        }
        setOutputFlat(index, dotProd);
      }
    }
  `}};function Vle(r){let{inputs:e,backend:t,attrs:n}=r,{dy:o,filter:s}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:p}=n,c=I.convertConv2DDataFormat(l),m=I.computeConv2DInfo(i,s.shape,a,1,u,p,!1,c),d=[{type:"int32",data:[m.filterHeight,m.filterWidth]},{type:"int32",data:[m.filterHeight-1-m.padInfo.top,m.filterWidth-1-m.padInfo.left]},{type:"int32",data:[m.strideHeight,m.strideWidth]},{type:"int32",data:[m.batchSize,m.outHeight,m.outWidth,m.outChannels]}],f;if($().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE"))f=new oN(m);else{f=new nN(m);let h=m.inShape[1]*m.inShape[2],g=m.inShape[3],x=m.filterHeight*m.filterWidth*m.outChannels;d.push({type:"uint32",data:[h]},{type:"uint32",data:[g]},{type:"uint32",data:[x]})}return t.runWebGPUProgram(f,[o,s],"float32",d)}var LU={kernelName:po,backendName:"webgpu",kernelFunc:Vle};var jle=mt({opType:Ke.COS}),BU={kernelName:co,backendName:"webgpu",kernelFunc:jle};var Hle=mt({opType:Ke.COSH}),$U={kernelName:mo,backendName:"webgpu",kernelFunc:Hle};var sN=class{constructor(e,t,n,o){this.variableNames=["Image","Boxes","BoxInd"];this.uniforms="extrapolationValue : f32;";this.workGroupSize=[64,1,1];this.size=!0;let[s]=t;this.outputShape=[s,n[0],n[1],e],this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.methodId=o==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){let[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,o,s]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
      ${ve()}
      if (index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
        let height_ratio = f32(${n});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${o};
        let width_scale = ${a};
        let in_y = ${s};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputFlat(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputFlat(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputFlat(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputFlat(index, newValue);
        }
      }
    }
    `}};var qle=r=>{let{inputs:e,backend:t,attrs:n}=r,{image:o,boxes:s,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=n,p=new sN(o.shape[3],s.shape,a,u),c=[{type:"float32",data:[l]}];return t.runWebGPUProgram(p,[o,s,i],"float32",c)},OU={kernelName:ra,backendName:"webgpu",kernelFunc:qle};var aN=class{constructor(e,t){this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.uniforms="blockSize : i32;";this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${ve()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputFlat(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function Xle(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],p=i==="NHWC"?o.shape[3]:o.shape[1],c=u*s,m=l*s,d=p/(s*s),f=i==="NHWC"?[a,c,m,d]:[a,d,c,m],h=[{type:"int32",data:[s]}],g=new aN(f,i);return t.runWebGPUProgram(g,[o],o.dtype,h)}var zU={kernelName:na,backendName:"webgpu",kernelFunc:Xle};var _g=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms="pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>; inDims : vec2<i32>;";this.workGroupSize=[4,4,4];this.isVec4=!0;this.outputShape=e.outShape,this.dispatchLayout={x:[0,1],y:[2],z:[3]},this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[1,4,4]),b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise3x3_${n}`}getUserCode(){let e="",t="";if(this.activation){let s=Jr(this.activation,this.isVec4);this.hasPreluActivation?e=`fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${s}
        }`:e=`
        fn activation(a : vec4<f32>, outCoord : vec4<i32>) -> vec4<f32> {
            ${s}
          }
        `,t="dotProd[i] = activation(dotProd[i], coords);"}let n=this.addBias?"dotProd[i] = dotProd[i] + getBiasAtOutCoordsByCoords(coords);":"";return`
      ${e}

      ${Vm()}
      fn main([[builtin(global_invocation_id)]] globalId: vec3<u32>) {
        let batch = 0;
        let r = i32(globalId.x);
        let c = i32(globalId.y) * 4;
        let d2 = i32(globalId.z) * 4;
        let xRCCorner = vec2<i32>(r, c) * uniforms.stride - uniforms.pad;
        let d1 = d2;
        let q = 0;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;

        var wVals : array<vec4<f32>, 9>;
        wVals[0] = getW(0, 0, d1, q);
        wVals[1] = getW(0, 1, d1, q);
        wVals[2] = getW(0, 2, d1, q);
        wVals[3] = getW(1, 0, d1, q);
        wVals[4] = getW(1, 1, d1, q);
        wVals[5] = getW(1, 2, d1, q);
        wVals[6] = getW(2, 0, d1, q);
        wVals[7] = getW(2, 1, d1, q);
        wVals[8] = getW(2, 2, d1, q);

        var xVals : array<array<vec4<f32>, 6>, 3>;
        for (var wR = 0; wR < 3; wR = wR + 1) {
          let xR = xRCorner + wR * uniforms.dilation[0];
          for (var wC = 0; wC < 6; wC = wC + 1) {
            let xC = xCCorner + wC * uniforms.dilation[1];
            if (xR < 0 || xR >= uniforms.inDims[0] || xC < 0 || xC >= uniforms.inDims[1]) {
              xVals[wR][wC] = vec4<f32>(0.0);
            } else {
              xVals[wR][wC] = getX(batch, xR, xC, d1);
            }
          }
        }

        var dotProd : array<vec4<f32>, 4>;
        dotProd[0] = vec4<f32>(0.0);
        dotProd[1] = vec4<f32>(0.0);
        dotProd[2] = vec4<f32>(0.0);
        dotProd[3] = vec4<f32>(0.0);

        for (var wR = 0; wR < 3; wR = wR + 1) {
          for (var wC = 0; wC < 3; wC = wC + 1) {
            let indexW = wR * 3 + wC;
            dotProd[0] = dotProd[0] + xVals[wR][0 + wC] * wVals[indexW];
            dotProd[1] = dotProd[1] + xVals[wR][1 + wC] * wVals[indexW];
            dotProd[2] = dotProd[2] + xVals[wR][2 + wC] * wVals[indexW];
            dotProd[3] = dotProd[3] + xVals[wR][3 + wC] * wVals[indexW];
          }
        }

        for (var i = 0; i < 4; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d2);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            ${n}
            ${t}
            setOutput(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
          }
        }
      }
    `}};var Ag=class{constructor(e,t=!1,n=null,o=!1){this.variableNames=["x","W"];this.uniforms=`pad : vec2<i32>; stride : vec2<i32>; dilation : vec2<i32>;
      inDims : vec2<i32>; filterHeight : i32; filterWidth : i32;
      channelMul : i32;`;this.workGroupSize=[256,1,1];this.outputShape=e.outShape,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),b.assert(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=o,this.shaderKey=`depthwise_${this.activation}`}getUserCode(){let e="",t="";if(this.activation){let s=Jr(this.activation,!1);this.hasPreluActivation?e=`fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);
          ${s}
        }`:e=`
          fn activation(a : f32, outCoord : vec4<i32>) -> f32 {
            ${s}
          }
        `,t="dotProd = activation(dotProd, coords);"}let n=this.addBias?"dotProd = dotProd + getBiasAtOutCoordsByCoords(coords);":"";return`
      ${e}

      fn writeResult(batch : i32, row : i32, col : i32, chan : i32,
          value : f32) {
        let coord = vec4<i32>(batch, row, col, chan);
        if (coordsInBounds4D(coord, uniforms.outShape)) {
          setOutput(batch, row, col, chan, value);
        }
      }

      ${dg()} {
        let coords = getOutputCoordsWithFlatDispatchLayout(globalId,
            localId, numWorkgroups);
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;
        let d2 = coords[3];
        let d1 = d2 / uniforms.channelMul;
        let q = d2 - d1 * uniforms.channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;
        let inputRowEnd = inputRowStart + uniforms.filterHeight *
            uniforms.dilation[0];
        let inputColEnd = inputColStart + uniforms.filterWidth *
            uniforms.dilation[1];

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;

        // Extract if checking out of for loop for performance.
        if (inputRowStart >= 0 && inputColStart >= 0 &&
          inputRowEnd < uniforms.inDims[0] &&
              inputColEnd < uniforms.inDims[1]) {
            // Here using a constant value |this.convInfo.filterHeight| instead
            // of uniform value is in order to loop unrolling.
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          } else {
            for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
              let xR = inputRowStart + wR * uniforms.dilation[0];

              if (xR < 0 || xR >= uniforms.inDims[0]) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                let xC = inputColStart + wC * uniforms.dilation[1];

                if (xC < 0 || xC >= uniforms.inDims[1]) {
                  continue;
                }

                let xVal = getX(batch, xR, xC, d1);
                let wVal = getW(wR, wC, d1, q);
                dotProd = dotProd + xVal * wVal;
              }
            }
          }

        ${n}
        ${t}
        writeResult(batch, coords[1], coords[2], d2, dotProd);
      }
    `}};function Yle(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s}=e,{strides:i,pad:a,dilations:u,dimRoundingMode:l}=n,p=u;p==null&&(p=[1,1]);let c=I.computeConv2DInfo(o.shape,s.shape,i,p,a,l,!0),m=[{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.dilationHeight,c.dilationWidth]},{type:"int32",data:[c.inHeight,c.inWidth]}],d;return c.batchSize===1&&c.inHeight===c.outHeight&&c.inWidth===c.outWidth&&c.strideHeight===1&&c.strideWidth===1&&c.filterHeight===c.filterWidth&&c.inChannels===c.outChannels&&c.filterHeight===3&&c.inChannels%4==0?d=new _g(c):(d=new Ag(c),m.push({type:"int32",data:[c.filterHeight]},{type:"int32",data:[c.filterWidth]},{type:"int32",data:[c.outChannels/c.inChannels]})),t.runWebGPUProgram(d,[o,s],o.dtype,m)}var GU={kernelName:fo,backendName:"webgpu",kernelFunc:Yle};var iN=_t({opSnippet:st.MUL,cpuKernelImpl:rU,supportsComplex:!0}),UU={kernelName:Po,backendName:"webgpu",kernelFunc:iN};var uN=class{constructor(e,t){this.workGroupSize=[64,1,1];this.variableNames=["x"];this.uniforms="reduceSize : i32;";this.size=!0;this.inputShape=[e.batchSize,e.inSize];let[n]=I.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=n.length===0?[1]:n,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isNanCustom(candidate)) {
          bestValue = uniforms.NAN;
         } elseif (!isNanCustom(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x.numbers[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"&&(e=" bestValue = bestValue * candidate; ",t="1.0");let n=this.reduceType==="mean"?"setOutputFlat(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputFlat(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromFlatIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${ve()}
         let outputIndex = index / i32(workGroupSizeX);
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), workGroupSizeX);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + i32(workGroupSizeX)) {
           let candidate = f32(x.numbers[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), workGroupSizeX);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${n}
        }
       }
     `}};function vi(r,e,t,n,o){let s=r.shape.length,i=[],a=b.parseAxisParam(e,r.shape),u=a,l=I.getAxesPermutation(u,s),p=r;l!=null&&(p=os({inputs:{x:r},attrs:{perm:l},backend:o}),u=I.getInnerMostAxes(u.length,s),i.push(p)),I.assertAxesAreInnerMostDims(n,u,s);let[c,m]=I.computeOutAndReduceShapes(p.shape,u),d=c;t&&(d=I.expandShapeToKeepDim(c,a));let f;if((n==="max"||n==="prod")&&o.shouldExecuteOnCPU([p])){let h=o.tensorMap.get(p.dataId).values;switch(n){case"max":let g=JG(h,b.sizeFromShape(m),d,r.dtype);f=o.makeTensorInfo(d,r.dtype,g);break;case"prod":let{outVals:x,outShape:y,outDtype:T}=sU(p.shape,p.dtype,h,u);f=o.makeTensorInfo(y,T,x);break;default:throw new Error(`${n} CPU implementation is not yet supported.`)}}else{let h=b.sizeFromShape(m),x=b.sizeFromShape(p.shape)/h,y={windowSize:h,inSize:h,batchSize:x,outSize:1},T=n==="mean"?"float32":Ji(r.dtype),k=[{type:"int32",data:[h]}],C=new uN(y,n),A=o.runWebGPUProgram(C,[p],T,k);i.push(A),f=Be({inputs:{x:A},attrs:{shape:d},backend:o})}return i.forEach(h=>o.disposeData(h.dataId)),f}function Ng(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;return vi(o,s,i,"sum",t)}var WU={kernelName:Uo,backendName:"webgpu",kernelFunc:Ng};function Qle(r){let{inputs:e,backend:t,attrs:n}=r,{equation:o}=n,s=e,{allDims:i,summedDims:a,idDims:u}=I.decodeEinsumEquation(o,s.length);I.checkEinsumDimSizes(i.length,u,s);let{path:l,steps:p}=I.getEinsumComputePath(a,u),c=p.length,m=null,d=i.length,f=[];for(let h=0;h<c;++h){for(let g of p[h]){let{permutationIndices:x,expandDims:y}=I.getEinsumPermutation(d,u[g]),T;I.isIdentityPermutation(x)?T=s[g]:(T=os({inputs:{x:s[g]},backend:t,attrs:{perm:x}}),f.push(T));let k=T.shape.slice();for(let C=0;C<y.length;++C)k.splice(y[C],0,1);b.arraysEqual(T.shape,k)||(T=Be({inputs:{x:T},backend:t,attrs:{shape:k}}),f.push(T)),m===null?m=T:(m=iN({inputs:{a:T,b:m},backend:t}),f.push(m))}h<c-1&&(l[h]>=0&&(m=Ng({inputs:{x:m},backend:t,attrs:{axis:l[h]-(i.length-d),keepDims:!1}}),f.push(m)),d--)}for(let h of f)h!==m&&t.disposeData(h.dataId);return m}var KU={kernelName:Ou,backendName:"webgpu",kernelFunc:Qle};var Zle=mt({opType:Ke.ELU}),VU={kernelName:go,backendName:"webgpu",kernelFunc:Zle};var Jle=_t({opSnippet:st.EQUAL,dtype:"bool",cpuKernelImpl:UG}),jU={kernelName:oa,backendName:"webgpu",kernelFunc:Jle};var lN=mt({opType:Ke.EXP,cpuKernelImpl:WG,dtype:"float32"}),HU={kernelName:bo,backendName:"webgpu",kernelFunc:lN};function rT(r){let{inputs:e,attrs:t,backend:n}=r,{dim:o}=t,{input:s}=e,i=s.shape.length,a=s.shape.slice(),u=o;return o<0&&(b.assert(-(i+1)<=o,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+o+1),a.splice(u,0,1),Be({inputs:{x:s},backend:n,attrs:{shape:a}})}var qU={kernelName:hs,backendName:"webgpu",kernelFunc:rT};var epe=mt({opType:Ke.EXPM1,cpuKernelImpl:KG}),XU={kernelName:sa,backendName:"webgpu",kernelFunc:epe};var pN=class{constructor(e){this.variableNames=[];this.outputShape=[];this.uniforms="value : f32;";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${ve()}
      if (index < uniforms.size) {
        setOutputFlat(index, uniforms.value);
      }
    }
  `}};function Ha(r){let{backend:e,attrs:t}=r,{shape:n,value:o}=t,{dtype:s}=t;if(s=s||b.inferDtype(o),s==="string"){let i=b.getArrayFromDType(s,b.sizeFromShape(n));return i.fill(o),e.makeTensorInfo(n,s,i)}else{let i=new pN(n),a=[{type:"float32",data:[o]}];return e.runWebGPUProgram(i,[],s,a)}}var YU={kernelName:Za,backendName:"webgpu",kernelFunc:Ha};var cN=class{constructor(e){this.outputShape=[];this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${ve()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputFlat(index, outputValue);
        }
      }
    `}};var QU={kernelName:aa,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{image:t}=r,n=e,o=new cN(t.shape);return n.runWebGPUProgram(o,[t],t.dtype)}};var tpe=mt({opType:Ke.FLOOR,cpuKernelImpl:VG}),ZU={kernelName:yo,backendName:"webgpu",kernelFunc:tpe};var rpe=_t({opSnippet:st.INT_DIV,dtype:"int32"}),JU={kernelName:xo,backendName:"webgpu",kernelFunc:rpe};var eW=(r,e,t,n,o)=>{let s=[n,...t];return o&&s.push(o),r.createBindGroup({layout:e,entries:s.map((i,a)=>({binding:a,resource:i}))})},nT=(r,e,t,n,o,s=!1)=>{let i={dtype:o.dtype,shape:o.shape},a=NG(n,i,e,s),u=r.createShaderModule({code:a,label:e.constructor.name});return r.createComputePipeline({layout:t,compute:{module:u,entryPoint:"main"},label:e.constructor.name})};function oT(r,e,t,n="",o=""){return r.shaderKey+"_"+(r.workGroupSize?r.workGroupSize.join(","):"")+e.map(i=>i.length).join(",")+t.join(",")+r.variableNames.join(",")+n+o}function mN(r){let{externalImage:e,backend:t,attrs:n,outShape:o,useImport:s}=r,{numChannels:i}=n,a=b.sizeFromShape(o),u=b.computeStrides(o),l=t.makeTensorInfo(o,"int32"),p=t.getFromPixelsProgram(s?"import":"copyExternal");p.updateOutputShape(o);let c=[l.shape],m=[l.dtype,s?"import":"copyExternal"],d=oT(p,c,m),f=p.getLayout(t.device),h=t.getAndSavePipeline(d,()=>nT(t.device,p,f.pipelineLayout,[],l,!0));p.setPipeline(h),s||t.queue.copyExternalImageToTexture({source:e,origin:{x:0,y:0}},{texture:p.makeInputTexture(t.device,o[1],o[0])},[o[1],o[0]]);let g=t.tensorMap.get(l.dataId);g.bufferInfo.buffer=t.acquireBuffer(g.bufferInfo.byteSize);let x=[a,i,...u,...p.dispatch];p.setUniform(t.device,x);let y;if(s){let T={source:e};y=t.device.importExternalTexture(T)}else y=p.inputTexture.createView();return t.runFromPixelsProgram(p,g.bufferInfo.buffer,f,y,l.dataId),l}var rW={kernelName:Dl,backendName:"webgpu",kernelFunc:npe},Hm;function npe(r){let{inputs:e,backend:t,attrs:n}=r,{pixels:o}=e,{numChannels:s}=n;if(o==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let i=typeof HTMLVideoElement!="undefined"&&o instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&o instanceof HTMLImageElement,u=typeof HTMLCanvasElement!="undefined"&&o instanceof HTMLCanvasElement||typeof OffscreenCanvas!="undefined"&&o instanceof OffscreenCanvas,l=typeof ImageBitmap!="undefined"&&o instanceof ImageBitmap,[p,c]=i?[o.videoWidth,o.videoHeight]:[o.width,o.height],m=[c,p,s];if($().getBool("WEBGPU_USE_IMPORT")&&i)return mN({externalImage:o,backend:t,attrs:n,outShape:m,useImport:!0});if((i||a)&&(Hm==null&&(Hm=document.createElement("canvas").getContext("2d")),Hm.canvas.width=p,Hm.canvas.height=c,Hm.drawImage(o,0,0,p,c),o=Hm.canvas),l||u||i||a)return mN({externalImage:o,backend:t,attrs:n,outShape:m,useImport:!1});let d=o.data,f=d;if(s!=null&&s!==4){f=new Uint8Array(o.width*o.height*s);let x=d.length,y=0;for(let T=0;T<x;T++)T%4<s&&(f[y++]=d[T])}let h=t.makeTensorInfo(m,"int32"),g=t.tensorMap.get(h.dataId);return g.values=new Int32Array(f),t.maybeReleaseBuffer(h.dataId),t.uploadToGPU(h.dataId),h}var dN=class{constructor(e,t,n,o,s){this.uniforms="varianceEpsilon : f32;";this.workGroupSize=[128,1,1];this.size=!0;this.variableNames=["x","mean","variance"],I.assertAndGetBroadcastShape(e,t),I.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),o!=null&&(I.assertAndGetBroadcastShape(e,o),this.variableNames.push("offset")),s!=null&&(I.assertAndGetBroadcastShape(e,s),this.variableNames.push("scale")),this.offsetShape=o,this.scaleShape=s,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetAtOutCoordsByGlobalIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleAtOutCoordsByGlobalIndex(index)"),`
      ${ve()}
        if (index < uniforms.size)
        {
          let xValue = getXAtOutCoordsByGlobalIndex(index);
          let meanValue = getMeanAtOutCoordsByGlobalIndex(index);
          let varianValue = getVarianceAtOutCoordsByGlobalIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputFlat(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}};var nW={kernelName:To,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n,scale:o,offset:s,mean:i,variance:a}=r,{varianceEpsilon:u}=e,l=t,p=[n,i,a],c=null;s!=null&&(c=s.shape,p.push(s));let m=null;o!=null&&(m=o.shape,p.push(o));let d=new dN(n.shape,i.shape,a.shape,c,m),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(d,p,n.dtype,f)}};function ope(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:p,dilations:c,dimRoundingMode:m,activation:d,leakyreluAlpha:f}=n,h=I.convertConv2DDataFormat(p),g=I.computeConv2DInfo(o.shape,s.shape,u,c,l,m,!1,h),x=i!=null,y=a!=null,T;if(g.filterHeight===1&&g.filterWidth===1&&g.dilationHeight===1&&g.dilationWidth===1&&g.strideHeight===1&&g.strideWidth===1&&(g.padInfo.type==="SAME"||g.padInfo.type==="VALID"))return tT({x:o,filter:s,convInfo:g,backend:t,bias:i,activation:d,preluActivationWeights:a,leakyreluAlpha:f});let k=$().getBool("WEBGPU_USE_NAIVE_CONV2D"),C=g.inChannels%4==0&&g.outChannels%4==0,A=[g.padInfo.top,g.padInfo.left],M=[{type:"int32",data:[g.filterHeight,g.filterWidth]},{type:"int32",data:[...A]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]}];if(k)T=new wg(g,x,d,y);else{C?T=new vg(g,x,d,y):T=new Sg(g,x,d,y);let F=g.outShape[1]*g.outShape[2],B=g.outShape[3],U=g.filterHeight*g.filterWidth*g.inShape[3];M.push({type:"int32",data:[F]},{type:"int32",data:[B]},{type:"int32",data:[U]})}let P=[o,s];return x&&P.push(i),y&&P.push(a),t.runWebGPUProgram(T,P,o.dtype,M)}var oW={kernelName:Ns,backendName:"webgpu",kernelFunc:ope};function spe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:p,dimRoundingMode:c,activation:m}=n,d=p;d==null&&(d=[1,1]),b.assert(I.eitherStridesOrDilationsAreOne(u,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${d}'`);let f=I.computeConv2DInfo(o.shape,s.shape,u,d,l,c,!0),h=[o,s],g=i!=null,x=a!=null;g&&h.push(i),x&&h.push(a);let y=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]},{type:"int32",data:[f.inHeight,f.inWidth]}],T;return f.batchSize===1&&f.inHeight===f.outHeight&&f.inWidth===f.outWidth&&f.strideHeight===1&&f.strideWidth===1&&f.filterHeight===f.filterWidth&&f.inChannels===f.outChannels&&f.filterHeight===3&&f.inChannels%4==0?T=new _g(f,g,m,x):(T=new Ag(f,g,m,x),y.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.outChannels/f.inChannels]})),t.runWebGPUProgram(T,h,"float32",y)}var sW={kernelName:Ds,backendName:"webgpu",kernelFunc:spe};var fN=class{constructor(e,t){this.variableNames=["A","indices"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32; strides : ${Zt(e)};`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
        ${ve()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputFlat(index, getA(flattenIndex, coords[1]));
        }
      }
      `}};function ape(r){let{inputs:e,backend:t}=r,{params:n,indices:o}=e,s=o.shape,i=s[s.length-1],a=b.sizeFromShape(n.shape),[u,l,p,c]=I.prepareAndValidate(n,o),m=Be({inputs:{x:o},backend:t,attrs:{shape:[l,i]}}),d=Be({inputs:{x:n},backend:t,attrs:{shape:[b.sizeFromShape(n.shape)/p,p]}});if(t.shouldExecuteOnCPU([n,o])||n.dtype==="string"){let y=t.readSync(o.dataId),T=t.bufferSync(n),k=jG(y,T,n.dtype,l,i,p,c,n.shape,a);return t.makeTensorInfo(u,n.dtype,k.values)}let f=new fN(i,[l,p]),h=[{type:"int32",data:[i]},{type:"int32",data:c}],g=t.runWebGPUProgram(f,[d,m],d.dtype,h),x=Be({inputs:{x:g},backend:t,attrs:{shape:u}});return t.disposeData(m.dataId),t.disposeData(d.dataId),t.disposeData(g.dataId),x}var aW={kernelName:ia,backendName:"webgpu",kernelFunc:ape};var hN=class{constructor(e,t){this.variableNames=["A","indices"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="gather"}getUserCode(){let e=ipe(this.aShape,"i32");return`
      ${ve()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromFlatIndex(index);
          setOutputFlat(index, getA(${e}));
        }
      }
    `}};function ipe(r,e="int"){let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r.length;o++)o===2?n.push(`${e}(getIndices(resRC.x, resRC.z))`):n.push(`${t[o]}`);return n.join()}function gN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o,indices:s}=e,{axis:i,batchDims:a}=n,u=b.parseAxisParam(i,o.shape)[0],l=I.segment_util.collectGatherOpShapeInfo(o,s,u,a),p=b.sizeFromShape(s.shape),c=[],m=Be({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),d=Be({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,p/l.batchSize]}});c.push(m),c.push(d);let f=[l.batchSize,l.outerSize,p/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([o,s])){let T=t.tensorMap.get(d.dataId).values,k=Ce(d.shape,d.dtype,T),A=t.tensorMap.get(m.dataId).values,M=Ce(m.shape,m.dtype,A),P=HG(M,k,f);return c.forEach(F=>t.disposeData(F.dataId)),t.makeTensorInfo(l.outputShape,P.dtype,P.values)}let h=new hN(m.shape,f),g=t.runWebGPUProgram(h,[m,d],m.dtype);c.push(g);let x=Be({inputs:{x:g},backend:t,attrs:{shape:l.outputShape}});return c.forEach(y=>t.disposeData(y.dataId)),x}var iW={kernelName:gs,backendName:"webgpu",kernelFunc:gN};var upe=_t({opSnippet:st.GREATER,cpuKernelImpl:XG,dtype:"bool"}),uW={kernelName:ua,backendName:"webgpu",kernelFunc:upe};var lpe=_t({opSnippet:st.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:qG}),lW={kernelName:ko,backendName:"webgpu",kernelFunc:lpe};var ppe=_t({opSnippet:st.LESS,dtype:"bool",cpuKernelImpl:QG}),pW={kernelName:la,backendName:"webgpu",kernelFunc:ppe};var cpe=_t({opSnippet:st.LESS_EQUAL,dtype:"bool",cpuKernelImpl:YG}),cW={kernelName:pa,backendName:"webgpu",kernelFunc:cpe};var mpe=mt({opType:Ke.LOG,cpuKernelImpl:ZG}),mW={kernelName:Co,backendName:"webgpu",kernelFunc:mpe};var dpe=_t({opSnippet:st.LOGICAL_AND,dtype:"bool"}),dW={kernelName:ca,backendName:"webgpu",kernelFunc:dpe};var fpe=mt({opType:Ke.LOGICAL_NOT}),fW={kernelName:Ki,backendName:"webgpu",kernelFunc:fpe};function bN(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reductionIndices:s,keepDims:i}=n;return vi(o,s,i,"max",t)}var hW={kernelName:vo,backendName:"webgpu",kernelFunc:bN};var hpe=_t({opSnippet:st.MAX,cpuKernelImpl:eU}),gW={kernelName:So,backendName:"webgpu",kernelFunc:hpe};function gpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{filterSize:s,strides:i,pad:a,dimRoundingMode:u}=n,l=1,p=I.computePool2DInfo(o.shape,s,i,l,a,u),c,m=[];if(p.filterHeight===1&&p.filterWidth===1){if(b.arraysEqual(p.inShape,p.outShape))return Sr({inputs:{x:o},backend:t});c=new Cg(p),m.push({type:"int32",data:[p.strideHeight,p.strideWidth]})}else c=new Ig(p,"max"),m.push({type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.inHeight,p.inWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]});return t.runWebGPUProgram(c,[o],o.dtype,m)}var bW={kernelName:wo,backendName:"webgpu",kernelFunc:gpe};function bpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{keepDims:s,axis:i}=n;return vi(o,i,s,"mean",t)}var yW={kernelName:_o,backendName:"webgpu",kernelFunc:bpe};function ype(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;return vi(o,s,i,"min",t)}var xW={kernelName:Ao,backendName:"webgpu",kernelFunc:ype};var xpe=_t({opSnippet:st.MIN,cpuKernelImpl:tU}),TW={kernelName:No,backendName:"webgpu",kernelFunc:xpe};var yN=class{constructor(e,t,n){this.uniforms="";this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t.map((o,s)=>o[0]+e[s]+o[1]),this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.xShape=e,t.map((o,s)=>{this.uniforms+=` pad${s} : vec2<i32>;`}),this.offset=n==="reflect"?0:1,this.shaderKey=`mirrorPad_${n}`}getUserCode(){let e=this.xShape.length,t=this.xShape.map((l,p)=>`uniforms.pad${p}[0]`).join(","),n=this.xShape.map((l,p)=>`uniforms.pad${p}[0] + uniforms.xShape${e>1?`[${p}]`:""}`).join(","),o=e===1?"start":"start[i]",s=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",a=Zt(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ve()}
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${n});
          var outC = getCoordsFromFlatIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${o}) {
              ${i} = ${o} * 2 - ${i} - ${this.offset};
            } elseif(${i} >= ${s}) {
              ${i} = (${s} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputFlat(index, getX(${u}));
        }
      }
    `}};var kW={kernelName:Do,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{x:n}=r,{paddings:o,mode:s}=e,i=t,a=o.map(p=>({type:"int32",data:[p[0],p[1]]})),u=new yN(n.shape,o,s);return i.runWebGPUProgram(u,[n],n.dtype,a)}};function Tpe(r){let{inputs:e,backend:t}=r,{x:n}=e;if(t.shouldExecuteOnCPU([n])){let s=t.tensorMap.get(n.dataId),[i,a]=nU(s.values,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,i)}let o=new Va(n.shape,Ke.NEG);return t.runWebGPUProgram(o,[n],n.dtype)}var IW={kernelName:bs,backendName:"webgpu",kernelFunc:Tpe};function kpe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=n,l=t.readSync(o.dataId),p=t.readSync(s.dataId),{selectedIndices:c}=Tr.nonMaxSuppressionV3Impl(l,p,i,a,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}var CW={kernelName:da,backendName:"webgpu",kernelFunc:kpe};function Ipe(r){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:e,backend:t,attrs:n}=r,{boxes:o,scores:s}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=n,p=t.readSync(o.dataId),c=t.readSync(s.dataId),m=i,d=a,f=u,h=l,{selectedIndices:g,selectedScores:x}=Tr.nonMaxSuppressionV5Impl(p,c,m,d,f,h);return[t.makeTensorInfo([g.length],"int32",new Int32Array(g)),t.makeTensorInfo([x.length],"float32",new Float32Array(x))]}var vW={kernelName:fa,backendName:"webgpu",kernelFunc:Ipe};function Dg(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="complex64"){let o=wu({inputs:{input:n},backend:t}),s=Dg({inputs:{x:o},backend:t}),i=Gp({inputs:{input:n},backend:t}),a=Dg({inputs:{x:i},backend:t}),u=Ka({inputs:{real:s,imag:a},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),u}else return Ha({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}var SW={kernelName:ws,backendName:"webgpu",kernelFunc:Dg};function wW(r){let{inputs:e,backend:t}=r,{x:n}=e;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let o=wu({inputs:{input:n},backend:t}),s=wW({inputs:{x:o},backend:t}),i=Gp({inputs:{input:n},backend:t}),a=Dg({inputs:{x:i},backend:t}),u=Ka({inputs:{real:s,imag:a},backend:t});return t.disposeData(o.dataId),t.disposeData(s.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),u}else return Ha({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:t})}var _W={kernelName:ys,backendName:"webgpu",kernelFunc:wW};function Cpe(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return rT({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=e.map(p=>{let c=rT({inputs:{input:p},backend:t,attrs:{dim:o}});return a.push(c),c}),l=tN({inputs:u,backend:t,attrs:{axis:o}});return a.forEach(p=>t.disposeData(p.dataId)),l}var AW={kernelName:xs,backendName:"webgpu",kernelFunc:Cpe};var xN=class{constructor(e,t){this.variableNames=["x"];this.uniforms="constantValue : f32;";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t.map((n,o)=>n[0]+e[o]+n[1]),this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),t.map((n,o)=>{this.uniforms+=` pad${o} : vec2<i32>;`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){let e=this.xShape.length,t=Zt(e),n=this.xShape.map((c,m)=>`uniforms.pad${m}[0]`).join(","),o=this.xShape.map((c,m)=>`uniforms.pad${m}[0] + uniforms.xShape${e>1?`[${m}]`:""}`).join(","),s=e>1?`${t}(${n})`:`${n}`,i=e>1?`${t}(${o})`:`${o}`,a=e>1?"any(outC < start)":"outC < start",u=e>1?"any(outC >= end)":"outC >= end",l=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${ve()}
        if (index < uniforms.size) {
          let start = ${s};
          let end = ${i};
          let outC = getCoordsFromFlatIndex(index);

          if (${a} || ${u}) {
            setOutputFlat(index, uniforms.constantValue);
          } else {
            let coords = outC - start;
            setOutputFlat(index, getX(${l}));
          }
        }
      }
    `}};var TN=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{paddings:s,constantValue:i}=n;if(s.every(l=>b.arraysEqual(l,[0,0])))return Sr({inputs:{x:o},backend:t});if(b.sizeFromShape(o.shape)===0){let l=s.map((p,c)=>p[0]+o.shape[c]+p[1]);return Ha({backend:t,attrs:{shape:l,value:i,dtype:o.dtype}})}let a=[{type:"float32",data:[i]}];s.map(l=>a.push({type:"int32",data:[l[0],l[1]]}));let u=new xN(o.shape,s);return t.runWebGPUProgram(u,[o],o.dtype,a)},NW={kernelName:Mo,backendName:"webgpu",kernelFunc:TN};var vpe=_t({opSnippet:st.POW}),DW={kernelName:Fo,backendName:"webgpu",kernelFunc:vpe};function Spe(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=new Tg(st.PRELU,n.shape,o.shape);return t.runWebGPUProgram(s,[n,o],"float32")}var PW={kernelName:Eo,backendName:"webgpu",kernelFunc:Spe};function wpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,keepDims:i}=n;return vi(o,s,i,"prod",t)}var MW={kernelName:ga,backendName:"webgpu",kernelFunc:wpe};var _pe=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:i}=t,a=aU(n,o,s,i);return e.makeTensorInfo([a.length],i,a)},FW={kernelName:Ja,backendName:"webgpu",kernelFunc:_pe};var kN=_t({opSnippet:st.DIV}),EW={kernelName:ho,backendName:"webgpu",kernelFunc:kN};var Ape=mt({opType:Ke.RELU}),RW={kernelName:Ro,backendName:"webgpu",kernelFunc:Ape};var Npe=mt({opType:Ke.RELU6}),LW={kernelName:Bo,backendName:"webgpu",kernelFunc:Npe};function Dpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{alpha:s}=n,i=[{type:"float32",data:[s]}],a=new Va(o.shape,Ke.LEAKYRELU);return a.uniforms="alpha : f32;",t.runWebGPUProgram(a,[o],"float32",i)}var BW={kernelName:Io,backendName:"webgpu",kernelFunc:Dpe};var IN=class{constructor(e,t,n){this.variableNames=["x"];this.uniforms="adjustHeightWidth : vec2<f32>; halfPixelCenters : f32;";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${ve()}
        if (index < uniforms.size) {
        let coords = getCoordsFromFlatIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputFlat(index, newValue);
        }
      }
    `}};function Ppe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,size:i,halfPixelCenters:a}=n,[u,l]=i,p=s&&u>1?1:0,c=s&&l>1?1:0,d=[{type:"float32",data:[p,c]},{type:"float32",data:[a?.5:0]}],f=new IN(o.shape,u,l);return t.runWebGPUProgram(f,[o],"float32",d)}var $W={kernelName:Lo,backendName:"webgpu",kernelFunc:Ppe};var CN=class{constructor(e,t,n,o){this.variableNames=["x"];this.uniforms="adjustHeightWidth : vec2<f32>; roundBase : f32;";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.halfPixelCenters=o,this.shaderKey=`resizeNearest_${o}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${ve()}
        if (index < uniforms.size) {
          let coords = getCoordsFromFlatIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputFlat(index, newValue);
        }
      }
    `}};function Mpe(r){let{inputs:e,backend:t,attrs:n}=r,{images:o}=e,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,p=s&&u>1?1:0,c=s&&l>1?1:0,d=[{type:"float32",data:[p,c]},{type:"float32",data:[s?.5:0]}],f=new CN(o.shape,u,l,i);return t.runWebGPUProgram(f,[o],o.dtype,d)}var OW={kernelName:ei,backendName:"webgpu",kernelFunc:Mpe};var vN=class{constructor(e,t){this.outputShape=[];this.variableNames=["x"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`centerX : f32; centerY : f32; sinRadians : f32;
          cosRadians : f32;`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32;",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>;",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${ve()}

          if (index < uniforms.size) {
            let coords = getCoordsFromFlatIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputFlat(index, outputValue);
          }
        }
      `}};var zW={kernelName:Sa,backendName:"webgpu",kernelFunc:({inputs:r,attrs:e,backend:t})=>{let{image:n}=r,{radians:o,fillValue:s,center:i}=e,a=t,u=new vN(n.shape,s),[l,p]=I.getImageCenter(i,n.shape[1],n.shape[2]),c=[{type:"float32",data:[l]},{type:"float32",data:[p]},{type:"float32",data:[Math.sin(o)]},{type:"float32",data:[Math.cos(o)]}];return typeof s=="number"?c.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):c.push({type:"float32",data:s}),a.runWebGPUProgram(u,[n],n.dtype,c)}};var Fpe=mt({opType:Ke.RSQRT,cpuKernelImpl:iU}),GW={kernelName:$o,backendName:"webgpu",kernelFunc:Fpe};var SN=class{constructor(e,t,n,o,s,i,a){this.variableNames=["updates","indices"];this.workGroupSize=[64,1,1];this.atomic=!0;this.outputShape=i,this.type=a,this.dispatchLayout=Ie(e),this.dispatch=de(this.dispatchLayout,e,this.workGroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${o}_${this.sliceDimGreaterThanOne}_${a}`;let u=Zt(s.length);this.uniforms=`sliceDim : i32; strides: ${u}; size: i32;`,this.updatesRank=o,this.indicesRank=n}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");let t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides",o="",s="",i="";this.updatesRank===1?(o="coords[0]",s="flattenedIndex",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.updatesRank===2&&(o="coords[0], coords[1]",s="vec2<i32>(flattenedIndex, coords[1])",i=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        let d0 = index / uniforms.updatesShape[1];
        let d1 = index - d0 * uniforms.updatesShape[1];
        return vec2<i32>(d0, d1);
      }
      `);let a=`getUpdates(${o})`,u=this.type==="int32"?"atomicAdd(&(result.numbers[flatIndex]), i32(updateValue));":`
     var assumed = atomicLoad(&(result.numbers[flatIndex]));
     var success = 0;
     for (; success == 0;) {
       let new = bitcast<f32>(assumed) + updateValue;
       let newI32 = bitcast<i32>(new);
       let resValue = atomicCompareExchangeWeak(&(result.numbers[flatIndex]), assumed, newI32);
       assumed = resValue[0];
       success = resValue[1];
     }
     `;return`
    ${i}

      ${ve()}

        if (index < uniforms.size) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${n};
          }
          let updateValue = ${a};
          let flatIndex = getOutputFlatIndex(${s});

         ${u}
        }
      }`}};function Epe(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o,updates:s}=e,{shape:i}=n,{sliceRank:a,numUpdates:u,sliceSize:l,strides:p,outputSize:c}=I.calculateShapes(s,o,i),m=[c/l,l];if(c===0)return t.makeTensorInfo(i,o.dtype);let d=Be({inputs:{x:o},backend:t,attrs:{shape:[u,a]}}),f=Be({inputs:{x:s},backend:t,attrs:{shape:[u,l]}}),h=f.dtype,g=Ha({backend:t,attrs:{shape:m,value:0,dtype:h}}),x=b.sizeFromShape(f.shape),y=[{type:"int32",data:[a]},{type:"int32",data:p},{type:"int32",data:[x]}],T=new SN(f.shape,a,d.shape.length,f.shape.length,p,m,h),k=t.runWebGPUProgram(T,[f,d],h,y,g),C=Be({inputs:{x:k},backend:t,attrs:{shape:i}});return t.disposeData(d.dataId),t.disposeData(f.dataId),t.disposeData(k.dataId),C}var UW={kernelName:xa,backendName:"webgpu",kernelFunc:Epe};var wN=class{constructor(e,t,n){this.variableNames=["c","a","b"];this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=t,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{let o=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${o[a]}`),a<this.cRank&&s.push(`${o[a]}`);e=s.join(),t=i.join()}return`
      ${ve()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromFlatIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputFlat(index, getA(${t}));
          } else {
            setOutputFlat(index, getB(${t}));
          }
        }
      }
    `}};function Rpe(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,i=new wN(n.shape.length,o.shape,o.shape.length);return t.runWebGPUProgram(i,[n,o,s],Kt(o.dtype,s.dtype))}var WW={kernelName:ks,backendName:"webgpu",kernelFunc:Rpe};var Lpe=mt({opType:Ke.SIGMOID}),KW={kernelName:zo,backendName:"webgpu",kernelFunc:Lpe};var Bpe=mt({opType:Ke.SIN}),VW={kernelName:Oo,backendName:"webgpu",kernelFunc:Bpe};var $pe=mt({opType:Ke.SINH}),jW={kernelName:Ta,backendName:"webgpu",kernelFunc:$pe};var _N=_t({opSnippet:st.SUB,cpuKernelImpl:mU,supportsComplex:!0}),HW={kernelName:Vo,backendName:"webgpu",kernelFunc:_N};function Ope(r){let{inputs:e,backend:t,attrs:n}=r,{logits:o}=e,{dim:s}=n,i=b.parseAxisParam([s],o.shape),a=bN({inputs:{x:o},backend:t,attrs:{reductionIndices:i,keepDims:!1}}),u=I.expandShapeToKeepDim(a.shape,i),l=Be({inputs:{x:a},backend:t,attrs:{shape:u}}),p=_N({inputs:{a:o,b:l},backend:t}),c=lN({inputs:{x:p},backend:t}),m=Ng({inputs:{x:c},backend:t,attrs:{axis:i,keepDims:!1}}),d=Be({inputs:{x:m},backend:t,attrs:{shape:u}}),f=kN({inputs:{a:c,b:d},backend:t});return t.disposeData(a.dataId),t.disposeData(l.dataId),t.disposeData(p.dataId),t.disposeData(c.dataId),t.disposeData(m.dataId),t.disposeData(d.dataId),f}var qW={kernelName:Wo,backendName:"webgpu",kernelFunc:Ope};var zpe=r=>{let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:i}=n;b.assert(o.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");let a=s.reduce((x,y)=>x*y),u=[[0,0]];u.push(...i);for(let x=1+s.length;x<o.shape.length;++x)u.push([0,0]);let l=[],p=TN({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),c=I.getReshaped(p.shape,s,a,!1),m=I.getPermuted(c.length,s.length,!1),d=I.getReshapedPermuted(p.shape,s,a,!1),f=Be({inputs:{x:p},backend:t,attrs:{shape:c}}),h=os({inputs:{x:f},backend:t,attrs:{perm:m}}),g=Be({inputs:{x:h},backend:t,attrs:{shape:d}});return l.push(p),l.push(f),l.push(h),l.forEach(x=>t.disposeData(x.dataId)),g},XW={kernelName:Cs,backendName:"webgpu",kernelFunc:zpe};var AN=class{constructor(e,t,n,o,s,i,a=!0){this.variableNames=["updates","indices","defaultValue"];this.workGroupSize=[64,1,1];this.workPerThread=4;this.size=!0;this.outputShape=i,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let u=t>1;this.shaderKey=`scatter_${n}_${o}_${u}`;let l=Zt(s.length);this.uniforms=`updateSize : i32; sliceDim : i32; strides: ${l};`;let p="";n===1?p="i":n===2&&(p="i, j"),this.indicesSnippet=`getIndices(${p})`;let c="";o===1?c="i":o===2&&(c="i, coords[1]"),this.updatesSnippet=`getUpdates(${c})`,this.strideString=u?"uniforms.strides[j]":"uniforms.strides"}getUserCode(){return`
      ${ve()}

        let globalIndex = index * ${this.workPerThread};
        if (globalIndex < uniforms.size) {
          var sum = vec4<f32>(0.0);
          var found = vec4<bool>(false);
          for (var i = 0; i < uniforms.updateSize; i = i + 1) {
            var flattenedIndex = 0;
            for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
              let indexInside = i32(round(${this.indicesSnippet}));
              flattenedIndex = flattenedIndex + indexInside * ${this.strideString};
            }
            for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
              let curIndex = globalIndex + innerIndex;
              let coords = getCoordsFromFlatIndex(curIndex);
              if (flattenedIndex == coords[0]) {
                sum[innerIndex] = sum[innerIndex] + ${this.updatesSnippet};
                found[innerIndex] = true;
              }
            }
          }
          for (var innerIndex = 0; innerIndex < ${this.workPerThread}; innerIndex = innerIndex + 1) {
            let curIndex = globalIndex + innerIndex;
            if (curIndex < uniforms.size)
            {
              setOutputFlat(curIndex, mix(getDefaultValue(), sum[innerIndex], f32(found[innerIndex])));
            }
          }
        }
      }`}};function Gpe(r){let{inputs:e,backend:t,attrs:n}=r,{sparseIndices:o,sparseValues:s,defaultValue:i}=e,{outputShape:a}=n,{sliceRank:u,numUpdates:l,strides:p,outputSize:c}=I.calculateShapes(s,o,a),m=!1,d=[{type:"int32",data:[l]},{type:"int32",data:[u]},{type:"int32",data:p}],f=new AN(l,u,o.shape.length,s.shape.length,p,[c,1],m),h=t.runWebGPUProgram(f,[s,o,i],s.dtype,d),g=Be({inputs:{x:h},backend:t,attrs:{shape:a}});return t.disposeData(h.dataId),g}var YW={kernelName:Hu,backendName:"webgpu",kernelFunc:Gpe};function Upe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:i}=n,a=b.parseAxisParam(i,o.shape)[0],u=I.prepareSplitSize(o,s,a),l=o.shape.length,p=new Array(l).fill(0),c=o.shape.slice();return u.map(m=>{let d=[...c];d[a]=m;let f=ja({inputs:{x:o},backend:t,attrs:{begin:p,size:d}});return p[a]+=m,f})}var QW={kernelName:vs,backendName:"webgpu",kernelFunc:Upe};var Wpe=mt({opType:Ke.SQRT}),ZW={kernelName:Go,backendName:"webgpu",kernelFunc:Wpe};var JW={kernelName:ti,backendName:"webgpu",kernelFunc:({inputs:r,backend:e})=>{let{x:t}=r,n=e,o=new Va(t.shape,Ke.SQUARE);return n.runWebGPUProgram(o,[t],t.dtype)}};var Kpe=_t({opSnippet:st.SQUARED_DIFFERENCE}),eK={kernelName:Ko,backendName:"webgpu",kernelFunc:Kpe};var NN=class{constructor(e){this.variableNames=["x"];this.workPerThread=1;this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]);let t=Zt(this.outputShape.length);this.uniforms=`begin : ${t};  strides : ${t}; `,this.shaderKey="stridedSlice"}getUserCode(){let e=this.outputShape.length,t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let o=0;t=this.outputShape.map((s,i)=>(o++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${o-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${ve()}
         if (index < uniforms.size) {
           let coords = getCoordsFromFlatIndex(index);
           setOutputFlat(index, getX(${t}));
         }
       }
     `}};function Vpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:y,end:T,strides:k}=Tt.sliceInfo(o.shape,s,i,a,u,l,p,c,m),C;if(h)C=Be({inputs:{x:o},backend:t,attrs:{shape:f}});else if(g||x){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=Tt.computeOutShape(y,T,k),M=ja({inputs:{x:o},backend:t,attrs:{begin:y,size:A}});C=Be({inputs:{x:M},backend:t,attrs:{shape:f}}),t.disposeData(M.dataId)}else if(t.shouldExecuteOnCPU([o])){let M=t.readSync(o.dataId),P=Ce(o.shape,o.dtype,M),F=pU(d,P,k,y);C=t.makeTensorInfo(f,o.dtype,F.values)}else{let M=new NN(d),P=[{type:"int32",data:y},{type:"int32",data:k}],F=t.runWebGPUProgram(M,[o],o.dtype,P);C=Be({inputs:{x:F},backend:t,attrs:{shape:f}}),t.disposeData(F.dataId)}return C}var tK={kernelName:ka,backendName:"webgpu",kernelFunc:Vpe};function jpe(r){let{inputs:e,backend:t,attrs:n}=r,{separator:o,nGramWidths:s,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=n,{data:p,dataSplits:c}=e,m=t.readSync(p.dataId),d=t.readSync(c.dataId),[f,h]=cU(m,d,o,s,i,a,u,l);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(c.shape,"int32",h)]}var rK={kernelName:qu,backendName:"webgpu",kernelFunc:jpe};var Hpe=mt({opType:Ke.TANH}),nK={kernelName:jo,backendName:"webgpu",kernelFunc:Hpe};var DN=class{constructor(e,t){this.variableNames=["A"];this.workGroupSize=[64,1,1];this.size=!0;let n=new Array(e.length);for(let o=0;o<n.length;o++)n[o]=e[o]*t[o];this.outputShape=n,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){let e=qpe(this.rank,"uniforms.");return`
      ${ve()}
        if (index < uniforms.size) {
          let resRC = getCoordsFromFlatIndex(index);
          setOutputFlat(index, getA(${e}));
        }
      }
    `}};function qpe(r,e=""){if(r>=5)throw Error(`Tile for rank ${r} is not yet supported`);if(r===1)return`(resRC % ${e}aShape)`;let t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let o=0;o<r;o++)n.push(`(${t[o]} % ${e}aShape[${o}])`);return n.join()}function Xpe(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{reps:s}=n;if(t.shouldExecuteOnCPU([o])||o.dtype==="string"||o.shape.length>=5){let u=t.readSync(o.dataId),l=o.dtype==="string"?u.map(m=>b.decodeString(m)):u,p=Ce(o.shape,o.dtype,l),c=dU(p,s);return t.makeTensorInfo(c.shape,c.dtype,c.values)}let i=new DN(o.shape,s);return t.runWebGPUProgram(i,[o],o.dtype)}var oK={kernelName:An,backendName:"webgpu",kernelFunc:Xpe};var PN=class{constructor(e){this.variableNames=["x","indices"];this.workGroupSize=[256,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms=`inputSize : i32; firstPass : i32; negativeInf : f32;
        dir : i32; inc : i32;`,this.shaderKey="swap"}getUserCode(){return`
        ${ve()}
          if (index < uniforms.size) {
            let outC = getCoordsFromFlatIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputFlat(index, f32(i0));
            } else {
              setOutputFlat(index, f32(i1));
            }
          }
        }
      `}},MN=class{constructor(e){this.variableNames=["x","indices"];this.workGroupSize=[256,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.uniforms="inputSize : i32; firstPass : i32; k : i32;",this.shaderKey="merge"}getUserCode(){return`
        ${ve()}
          if (index < uniforms.size) {
            let outC = getCoordsFromFlatIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputFlat(index, f32(i0));
            } else {
              setOutputFlat(index, f32(i1));
            }
          }
        }
      `}};function qm(r,e){e!==null&&r.disposeData(e.dataId)}function sK(r){let e=1;for(;e<r;)e*=2;return e}function Ype(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{k:s,sorted:i}=n,a=o.shape,u=a[a.length-1];if(t.shouldExecuteOnCPU([o])){let C=t.readSync(o.dataId),[A,M]=fU(C,a,o.dtype,s,i);return[t.makeTensorInfo(A.shape,A.dtype,A.values),t.makeTensorInfo(M.shape,M.dtype,M.values)]}if(s===0)return a[a.length-1]=0,[t.makeTensorInfo(a,o.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(u===1)return[o,Ha({attrs:{shape:a,dtype:"int32",value:0},backend:t})];let p=b.sizeFromShape(a)/u,c=Be({inputs:{x:o},attrs:{shape:[p,u]},backend:t}),m=sK(s),d=sK(u),f=null,h=()=>f===null?[c,c]:[c,f],g=(C,A,M)=>{let P=h(),F=new PN(M),U=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[C]},{type:"int32",data:[A]}],W=f;f=t.runWebGPUProgram(F,P,"int32",U),qm(t,W)};for(let C=1;C<m;C*=2){let A=C*2;for(let M=C;M>=1;M/=2)g(A,M,[p,d])}for(let C=d;C>m;C/=2){let A=h(),M=new MN([p,C/2]),F=[{type:"int32",data:[u]},{type:"int32",data:[f===null?1:0]},{type:"int32",data:[m]}],B=f;f=t.runWebGPUProgram(M,A,"int32",F),qm(t,B);let U=m/2,W=U*2;for(let K=U;K>=1;K/=2)g(W,K,f.shape)}let x=f;f=ja({inputs:{x:f},backend:t,attrs:{begin:0,size:[p,s]}}),qm(t,x);let y=gN({inputs:{x:c,indices:f},backend:t,attrs:{axis:1,batchDims:1}});qm(t,c);let T=a.slice(0,-1);T.push(s),x=f,f=Be({inputs:{x:f},attrs:{shape:T},backend:t}),qm(t,x);let k=y;return y=Be({inputs:{x:y},attrs:{shape:T},backend:t}),qm(t,k),[y,f]}var aK={kernelName:Ca,backendName:"webgpu",kernelFunc:Ype};var FN=class{constructor(e){this.variableNames=["Image","Transforms"];this.uniforms="interpolationModeId : i32; fillModeId : i32; fillValue : f32;";this.workGroupSize=[64,1,1];this.size=!0;this.outputShape=e,this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } elseif (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } elseif (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${ve()}
            if (index < uniforms.size) {
              let coords = getCoordsFromFlatIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputFlat(index, outputValue);
            }
          }
        `}};function Qpe(r){let{inputs:e,backend:t,attrs:n}=r,{image:o,transforms:s}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[p,c,m,d]=o.shape,[f,h]=l??[c,m],g=[p,f,h,d],x=new FN(g),y=i==="nearest"?1:2,T;switch(a){case"constant":T=1;break;case"reflect":T=2;break;case"wrap":T=3;break;case"nearest":T=4;break;default:T=1;break}let k=[{type:"int32",data:[y]},{type:"int32",data:[T]},{type:"float32",data:[u]}];return t.runWebGPUProgram(x,[o,s],"float32",k)}var iK={kernelName:va,backendName:"webgpu",kernelFunc:Qpe};function Zpe(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o,a=i.shape.length,u=o.shape[s],l=new Array(a-1),p=0;for(let h=0;h<a;h++)h!==s&&(l[p++]=i.shape[h]);let c=[],m=new Array(a).fill(0),d=i.shape.slice();d[s]=1;let f=new Array(u);for(let h=0;h<f.length;h++){m[s]=h;let g=ja({inputs:{x:i},backend:t,attrs:{begin:m,size:d}}),x=Be({inputs:{x:g},backend:t,attrs:{shape:l}});f[h]=x,c.push(g)}return c.forEach(h=>t.disposeData(h.dataId)),f}var uK={kernelName:Ss,backendName:"webgpu",kernelFunc:Zpe};var Jpe=[LG,gU,bU,yU,TU,kU,IU,CU,SU,NU,DU,PU,$G,FU,RU,LU,BU,$U,OU,zU,GU,KU,VU,jU,qU,HU,XU,YU,QU,rW,ZU,JU,nW,oW,sW,aW,iW,uW,lW,BG,MU,pW,cW,mW,dW,fW,hW,gW,bW,yW,xW,TW,kW,UU,IW,CW,vW,wU,_W,AW,NW,PW,MW,DW,FW,_U,EW,RW,LW,BW,RG,$W,OW,zW,GW,UW,WW,KW,VW,jW,vU,tK,rK,qW,XW,QW,YW,ZW,JW,eK,HW,WU,nK,oK,aK,iK,xU,uK,SW];for(let r of Jpe)Zi(r);var EN=class{constructor(e){this.device=e;this.numUsedBuffers=0;this.numFreeBuffers=0;this.freeBuffers=new Map;this.usedBuffers=new Map;this.numBytesUsed=0;this.numBytesAllocated=0}acquireBuffer(e,t){let n=lK(e,t);if(this.freeBuffers.has(n)||this.freeBuffers.set(n,[]),this.usedBuffers.has(n)||this.usedBuffers.set(n,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(n).length>0){this.numFreeBuffers--;let s=this.freeBuffers.get(n).shift();return this.usedBuffers.get(n).push(s),s}this.numBytesAllocated+=e;let o=this.device.createBuffer({size:e,usage:t});return this.usedBuffers.get(n).push(o),o}releaseBuffer(e,t,n){if(this.freeBuffers==null)return;let o=lK(t,n);this.freeBuffers.has(o)||this.freeBuffers.set(o,[]),this.freeBuffers.get(o).push(e),this.numFreeBuffers++,this.numUsedBuffers--;let s=this.usedBuffers.get(o),i=s.indexOf(e);if(i<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");s.splice(i,1),this.numBytesUsed-=t}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}reset(){this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}dispose(){this.freeBuffers==null&&this.usedBuffers==null||(this.freeBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(n=>{n.destroy()})}),this.freeBuffers=null,this.usedBuffers=null,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0)}};function lK(r,e){return`${r}_${e}`}var Pg=class{constructor(){this.outputShape=[0];this.variableNames=[];this.workGroupSize=[256,1,1];this.lastUniformData=[];this.inputTexture=null;this.layout=null;this.lastPixelSize={width:0,height:0};this.disposed=!1;this.shaderKey="fromPixels",this.useImport=!1}updateOutputShape(e){b.arraysEqual(this.outputShape,e)||(this.outputShape=e,this.workPerThread=e[2],this.dispatchLayout=Ie(this.outputShape),this.dispatch=de(this.dispatchLayout,this.outputShape,this.workGroupSize,[this.workPerThread,1,1]))}makeFromPixelsSource(){let e=this.useImport?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      [[binding(1), group(0)]] var src: ${this.useImport?"texture_external":"texture_2d<f32>"};

      ${ve()}
        let flatIndexBase = index * uniforms.numChannels;
        for (var i = 0; i < uniforms.numChannels; i = i + 1) {
          let flatIndex = flatIndexBase + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromFlatIndex(flatIndexBase);
            let values = ${e};
            result.numbers[flatIndex] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}getUserCode(){return this.makeFromPixelsSource()}setPipeline(e){this.pipeline=e}setUniform(e,t){if(!this.uniform){let n=e.createBuffer({size:t.length*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});this.uniform=n}!t||t.length===this.lastUniformData.length&&t.every((n,o)=>n===this.lastUniformData[o])||(e.queue.writeBuffer(this.uniform,0,new Uint32Array(t)),this.lastUniformData=t)}makeInputTexture(e,t,n){return(!this.inputTexture||this.lastPixelSize.width!==t||this.lastPixelSize.height!==n)&&(this.inputTexture&&this.inputTexture.destroy(),this.inputTexture=e.createTexture({size:[t,n],format:"rgba8unorm",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),this.lastPixelSize.width=t,this.lastPixelSize.height=n),this.inputTexture}dispose(){this.disposed||(this.uniform&&this.uniform.destroy(),this.inputTexture&&this.inputTexture.destroy(),this.disposed=!0)}getLayout(e){return this.layout===null&&(this.layout=this.createTextureLayout(e)),this.layout}createTextureLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,texture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});let n=e.createBindGroupLayout({entries:t}),o=e.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:o}}};var RN=class extends Pg{constructor(){super(...arguments);this.layout=null;this.useImport=!0}getUserCode(){return this.makeFromPixelsSource()}getLayout(e){return this.layout===null&&(this.layout=this.createTextureImportLayout(e)),this.layout}createTextureImportLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}}),t.push({binding:1,visibility:GPUShaderStage.COMPUTE,externalTexture:{}}),t.push({binding:2,visibility:GPUShaderStage.COMPUTE,buffer:{}});let n=e.createBindGroupLayout({entries:t}),o=e.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:o}}};var ece=$().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),LN=class extends ps{constructor(e,t=!1){super();this.commandQueueOwnedIds=new WeakSet;this.tensorDisposalQueue=[];this.uniformDisposalQueue=[];this.disposed=!1;this.uploadWaitMs=0;this.downloadWaitMs=0;this.dispatchNumberInEncoder=0;if(!bg())throw new Error("WebGPU is not supported on this device");this.layoutCache={},this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=t,this.bufferManager=new EN(this.device),this.tensorMap=new qa(this,qo()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),$().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return LN.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}flushDisposalQueue(){this.tensorDisposalQueue.forEach(e=>{this.maybeReleaseBuffer(e),this.tensorMap.delete(e)}),this.uniformDisposalQueue.forEach(e=>this.bufferManager.releaseBuffer(e.buffer,e.byteSize,e.usage)),this.tensorDisposalQueue=[],this.uniformDisposalQueue=[]}disposeData(e,t=!1){if(this.tensorMap.has(e)){let n=this.tensorMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDisposalQueue.push(e),!1;this.maybeReleaseBuffer(e);let{complexTensorInfos:o}=this.tensorMap.get(e);o!=null&&(this.disposeData(o.real.dataId,!0),this.disposeData(o.imag.dataId,!0)),this.tensorMap.delete(e)}return!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}getBufferManager(){return this.bufferManager}acquireBuffer(e,t=this.defaultGpuBufferUsage()){return this.bufferManager.acquireBuffer(e,t)}maybeReleaseBuffer(e){let t=this.tensorMap.get(e);t!=null&&t.bufferInfo.buffer!=null&&(this.bufferManager.releaseBuffer(t.bufferInfo.buffer,t.bufferInfo.byteSize,t.bufferInfo.usage),t.bufferInfo.buffer=null)}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){let t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){let t=this.tensorMap.get(e);t.refCount--}}write(e,t,n){if(n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let o={id:this.nextDataId()},s=b.sizeFromShape(t)*Qx(n);return n==="bool"&&e instanceof Uint8Array&&(e=Int32Array.from(e)),this.tensorMap.set(o,{dtype:n,values:e,bufferInfo:{byteSize:s,usage:this.defaultGpuBufferUsage()},refCount:1}),o}move(e,t,n,o,s){if(o==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let i=b.sizeFromShape(n)*Qx(o);this.tensorMap.set(e,{dtype:o,values:t,bufferInfo:{byteSize:i,usage:this.defaultGpuBufferUsage()},refCount:s})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.flushDisposalQueue()}getBuffer(e){return this.uploadToGPU(e),this.tensorMap.get(e).bufferInfo.buffer}getFromPixelsProgram(e){switch(e){case"copyExternal":return this.fromPixelProgram||(this.fromPixelProgram=new Pg),this.fromPixelProgram;case"import":return this.fromPixelImportProgram||(this.fromPixelImportProgram=new RN),this.fromPixelImportProgram;default:b.assert(!1,()=>"Unsupported fromPixels shape");return}}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.endPass(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e){if(e.values!=null)return e.values;let t=this.acquireBuffer(e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e.bufferInfo.buffer,0,t,0,e.bufferInfo.byteSize),this.submitQueue(),await t.mapAsync(GPUMapMode.READ);let n=t.getMappedRange().slice(0);return t.unmap(),t!=null&&this.bufferManager.releaseBuffer(t,e.bufferInfo.byteSize,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),$().getBool("WEBGPU_USE_PROFILE_TOOL")&&(b.assert(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),n}convertAndCacheOnCPU(e,t){let n=this.tensorMap.get(e);return this.maybeReleaseBuffer(e),n.values=t,n.values}readSync(e){let t=this.tensorMap.get(e),{values:n}=t;if(n==null)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);let t=this.tensorMap.get(e),{values:n}=t;if(n!=null)return this.convertAndCacheOnCPU(e,n);let o;if(t.dtype==="complex64"){let s=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),i=s[0],a=s[1];o=I.mergeRealAndImagArrays(i,a)}else{let s=await this.getBufferData(t);o=BA(s,t.dtype)}return this.convertAndCacheOnCPU(e,o),o}bufferSync(e){let t=this.readSync(e.dataId),n=t;if(e.dtype==="string")try{n=t.map(o=>b.decodeString(o))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ce(e.shape,e.dtype,n)}async time(e){let t=this.activeTimers,n=[],o=!1;this.programTimersStack==null?(this.programTimersStack=n,o=!0):this.activeTimers.push(n),this.activeTimers=n,e();let s=b.flatten(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=b.flatten(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,o&&(this.programTimersStack=null);let a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(s);return a.kernelMs=b.sum(u),a.getExtraProfileInfo=()=>u.map((l,p)=>({name:i[p],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}getAndSavePipeline(e,t){return e in this.pipelineCache||(this.pipelineCache[e]=t()),this.pipelineCache[e]}makeTensorInfo(e,t,n){let o;if(t==="string"&&n!=null&&n.length>0&&b.isString(n[0])){let s=n.map(i=>b.encodeString(i));o=this.write(s,e,t)}else o=this.write(n,e,t);return{dataId:o,shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;let t=this.tensorMap.get(e.dataId);return{offset:0,size:t.bufferInfo.byteSize,buffer:t.bufferInfo.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){let t=this.tensorMap.get(e);t.bufferInfo.buffer==null&&(t.bufferInfo.buffer=this.acquireBuffer(t.bufferInfo.byteSize),t.values&&this.queue.writeBuffer(t.bufferInfo.buffer,0,t.values))}makeUniformsDataView(e){let t=this.acquireBuffer(e.byteLength,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(t,0,e),{offset:0,size:e.byteLength,buffer:t}}arrayToDataView(e,t){let n=4,o=new DataView(new ArrayBuffer(t*n)),s=0;return e.forEach(i=>{let a=i.data;if(i.type!=="int32"&&i.type!=="float32"&&i.type!=="uint32")throw new Error(`${i.type} not supported!`);i.type==="int32"?a.forEach(u=>{o.setInt32(s*n,u,!0),s++}):i.type==="uint32"?a.forEach(u=>{o.setUint32(s*n,u,!0),s++}):a.forEach(u=>{o.setFloat32(s*n,u,!0),s++})}),o}computePadding(e){let t=0,n=0,o=0,s=[];return e.forEach((i,a)=>{i.data.length===0&&(i.data=[1]);let u;switch(i.data.length){case 0:u=1;break;case 1:u=1;break;case 2:u=2;break;case 3:u=4;break;case 4:u=4;break;default:b.assert(!1,()=>`Unsupported ${i.data.length}D shape`)}n=Math.ceil(t/u)*u-t;for(let l=0;l<n;++l)s.push({type:i.type,data:[0]}),o++;s.push({type:i.type,data:i.data}),o=o+i.data.length,t+=i.data.length+n}),this.arrayToDataView(s,o)}createLayout(e){let t=[];t.push({binding:0,visibility:GPUShaderStage.COMPUTE,buffer:{type:"storage"}});for(let s=0;s<e;s++)t.push({binding:s+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}});t.push({binding:e+1,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}});let n=this.device.createBindGroupLayout({entries:t}),o=this.device.createPipelineLayout({bindGroupLayouts:[n]});return{bindGroupLayout:n,pipelineLayout:o}}getCachedOrCreateLayout(e){return e in this.layoutCache||(this.layoutCache[e]=this.createLayout(e)),this.layoutCache[e]}runWebGPUProgram(e,t,n,o,s){if(!s){if(s=this.makeTensorInfo(e.outputShape,n),b.sizeFromShape(s.shape)===0){let F=this.tensorMap.get(s.dataId);return F.values=b.getTypedArrayFromDType(s.dtype,0),s}this.uploadToGPU(s.dataId)}let i=[{type:"float32",data:[NaN]}],a=t.concat(s).map(F=>F.shape),u="int32";a.map(F=>{i.push({type:u,data:F})});let l=b.computeStrides(s.shape);if(i.push({type:u,data:l}),e.size){let F=b.sizeFromShape(e.outputShape);i.push({type:u,data:[e.isVec4?F/4:F]})}o&&(i=[...i,...o]);let p=null,c=this.computePadding(i),m=c.byteLength;p=this.makeUniformsDataView(c);let d=t.map((F,B)=>{if(F.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(F.dataId),{dtype:this.tensorMap.get(F.dataId).dtype,shape:F.shape,name:e.variableNames[B]}}),f=d.map(F=>F.dtype).concat(s.dtype),h=d.map(F=>I.getBroadcastDims(F.shape,s.shape)),g=d.map(F=>b.arraysEqual(F.shape,s.shape)).join("_"),x=h.map(F=>F.join("_")).join(";"),y=oT(e,a,f,x,g),{bindGroupLayout:T,pipelineLayout:k}=this.getCachedOrCreateLayout(e.variableNames.length),C=this.getAndSavePipeline(y,()=>nT(this.device,e,k,d,s)),A=this.activeTimers!=null,M=eW(this.device,T,t.map(F=>this.tensorToBinding(F)),this.tensorToBinding(s),p);this.ensureCommandEncoderReady();let P=this.getComputePass();if(A&&this.supportTimeQuery&&P.writeTimestamp(this.querySet,0),P.setPipeline(C),P.setBindGroup(0,M),P.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),A&&this.supportTimeQuery&&P.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach(F=>{this.commandQueueOwnedIds.add(F.dataId)}),this.commandQueueOwnedIds.add(s.dataId),p){let F={byteSize:m,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:p.buffer};this.uniformDisposalQueue.push(F)}return $().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),A&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}runFromPixelsProgram(e,t,n,o,s){let i=this.device.createBindGroup({layout:n.bindGroupLayout,entries:[{binding:0,resource:{buffer:t}},{binding:1,resource:o},{binding:2,resource:{buffer:e.uniform}}]});this.ensureCommandEncoderReady();let a=this.getComputePass(),u=this.activeTimers!=null;u&&this.supportTimeQuery&&a.writeTimestamp(this.querySet,0),a.setPipeline(e.pipeline),a.setBindGroup(0,i),a.dispatch(e.dispatch[0],e.dispatch[1],e.dispatch[2]),u&&this.supportTimeQuery&&a.writeTimestamp(this.querySet,1),this.commandQueueOwnedIds.add(s),this.submitQueue(),u&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)})}async getTimeFromQuerySet(e){let t=this.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);let o=new BigUint64Array(n.getMappedRange()),s=Number(o[1]-o[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),s/1e6}shouldExecuteOnCPU(e,t=ece){return $().getBool("WEBGPU_CPU_FORWARD")&&e.every(n=>this.tensorMap.get(n.dataId).bufferInfo.buffer==null&&b.sizeFromShape(n.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDisposalQueue.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.fromPixelProgram&&this.fromPixelProgram.dispose(),this.fromPixelImportProgram&&this.fromPixelImportProgram.dispose(),this.disposed=!0)}},Xm=LN;Xm.nextDataId=0;var pK={};Xe(pK,{WebGPUBackend:()=>Xm,webgpu_util:()=>Zx});oi.isBrowser()&&bg()&&el("webgpu",async()=>{$().set("CHECK_COMPUTATION_FOR_ERRORS",!1);let r={powerPreference:$().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(r),t={},n=e.features.has("timestamp-query");n?t={requiredFeatures:["timestamp-query"]}:console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Or zero will shown for the kernel time when profiling mode isenabled. Using performance.now is not workable for webgpu sinceit doesn't support synchronously to read data from GPU.");let o=await e.requestDevice(t);return new Xm(o,n)},3);var et=(s=>(s[s.float32=0]="float32",s[s.int32=1]="int32",s[s.bool=2]="bool",s[s.string=3]="string",s[s.complex64=4]="complex64",s))(et||{}),Up=(a=>(a[a.linear=0]="linear",a[a.relu=1]="relu",a[a.relu6=2]="relu6",a[a.prelu=3]="prelu",a[a.leakyrelu=4]="leakyrelu",a[a.sigmoid=5]="sigmoid",a[a.elu=6]="elu",a))(Up||{});var cK;function tce(r){cK=r.wasm.cwrap(As,null,["number","array","number","number","array","number","number","number","number","number","number","number","number"])}function rce(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s,bias:i,preluActivationWeights:a}=e;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("_FusedMatMul for non non-float32 tensors not yet supported.");let{transposeA:u,transposeB:l,activation:p,leakyreluAlpha:c}=n,m=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(s.dataId).id,f=0;if(i!=null){let P=t.dataIdMap.get(i.dataId);if(P.shape.length!==1)throw new Error(`_FusedMatMul only supports rank-1 bias but got rank ${P.shape.length}.`);f=P.id}let h=a==null?0:t.dataIdMap.get(a.dataId).id,g=Up[p];if(g==null)throw new Error(`${p} activation not yet supported for FusedConv2D in the wasm backend.`);let x=u?o.shape[2]:o.shape[1],y=l?s.shape[1]:s.shape[2],T=Ar.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)),k=t.makeOutput([...T,x,y],o.dtype),C=t.dataIdMap.get(k.dataId).id,A=new Uint8Array(new Int32Array(o.shape).buffer),M=new Uint8Array(new Int32Array(s.shape).buffer);return cK(m,A,o.shape.length,d,M,s.shape.length,u,l,g,f,h,c||0,C),k}var mK={kernelName:As,backendName:"wasm",setupFunc:tce,kernelFunc:rce};function dt(r,e){let t;function n(s){t=s.wasm.cwrap(r,null,["number","number","number"])}function o(s){let{backend:i,inputs:{x:a}}=s,u=i.dataIdMap.get(a.dataId).id,l=i.makeOutput(a.shape,e||a.dtype),p=i.dataIdMap.get(l.dataId).id;return b.sizeFromShape(l.shape)===0||t(u,et[a.dtype],p),l}return{kernelName:r,backendName:"wasm",setupFunc:n,kernelFunc:o}}var dK=dt(ms);function At(r,e,t){let n;function o(i){n=i.wasm.cwrap(r,null,["number","array","number","number","array","number","number","number"])}function s(i){let{backend:a,inputs:u}=i,{a:l,b:p}=u,c=a.dataIdMap.get(l.dataId).id,m=a.dataIdMap.get(p.dataId).id,d=t??l.dtype,f=I.assertAndGetBroadcastShape(l.shape,p.shape),h=a.makeOutput(f,d);if(b.sizeFromShape(f)===0)return h;let g=new Uint8Array(new Int32Array(l.shape).buffer),x=new Uint8Array(new Int32Array(p.shape).buffer),y=a.dataIdMap.get(h.dataId).id;return(()=>n(c,g,l.shape.length,m,x,p.shape.length,et[l.dtype],y))(),h}return{kernelName:r,backendName:"wasm",setupFunc:o,kernelFunc:s}}var nce=!0,fK=At(_n,nce);var hK;function oce(r){hK=r.wasm.cwrap(oo,null,["array","number","number","number"])}function sce(r){let{inputs:e,backend:t}=r,n=t.makeOutput(e[0].shape,e[0].dtype);if(b.sizeFromShape(n.shape)===0)return n;let o=e.map(a=>t.dataIdMap.get(a.dataId).id),s=new Uint8Array(new Int32Array(o).buffer),i=t.dataIdMap.get(n.dataId).id;return hK(s,o.length,et[n.dtype],i),n}var gK={kernelName:oo,backendName:"wasm",setupFunc:oce,kernelFunc:sce};function Wp(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype),o=t.typedArrayFromHeap(e);return t.typedArrayFromHeap(n).set(o),n}var bK={kernelName:jn,backendName:"wasm",kernelFunc:Wp};var yK;function ace(r){yK=r.wasm.cwrap(Ho,null,["number","array","number","number","number","array","number"])}function Si(r){let{inputs:e,backend:t,attrs:n}=r,[o,s]=uce(e.x.shape,n.perm),i=!0;for(let f=0;f<s.length;f++)s[f]!==f&&(i=!1);let a=ice(e.x.shape,n.perm),u={dataId:e.x.dataId,shape:o,dtype:e.x.dtype};if(i){let f=Wp({inputs:e,backend:t});return f.shape=a,f}let l=t.makeOutput(a,u.dtype),p=t.dataIdMap.get(u.dataId).id,c=t.dataIdMap.get(l.dataId).id,m=new Uint8Array(new Int32Array(s).buffer),d=new Uint8Array(new Int32Array(u.shape).buffer);return yK(p,d,u.shape.length,et[u.dtype],c,m,s.length),l}function ice(r,e){let t=new Array(r.length);for(let n=0;n<t.length;n++)t[n]=r[e[n]];return t}function uce(r,e){let t=[],n=[];for(let o=0;o<r.length;++o)r[o]!==1&&t.push(r[o]),r[e[o]]!==1&&n.push(e[o]);for(let o=0;o<n.length;++o){let s=-1;for(let i=0;i<n.length;++i)n[i]>=o&&(s===-1||n[s]>n[i])&&(s=i);n[s]=o}return[t,n]}var xK={kernelName:Ho,backendName:"wasm",kernelFunc:Si,setupFunc:ace};function Cn(r,e,t){let n=r.shape,o=r.shape.length,s=b.parseAxisParam(e,n),i=s,a=I.getAxesPermutation(i,o),u=null,l=!1;if(a!=null){let p=new Array(o);for(let d=0;d<p.length;d++)p[d]=n[a[d]];i=I.getInnerMostAxes(i.length,o),u=Si({inputs:{x:r},attrs:{perm:a},backend:t});let c=t.dataIdMap.get(r.dataId).id;t.dataIdMap.get(u.dataId).id!==c&&(l=!0)}return{transposed:u,originalAxes:s,axes:i,inputWasTransposed:l}}var TK;function lce(r){TK=r.wasm.cwrap(Mi,null,["number, number, number"])}function pce(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,u=e.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:d}=Cn(i,o,e);if(d){let T=e.dataIdMap.get(p.dataId).id;l=p,u=T}let f=l.shape.length;I.assertAxesAreInnerMostDims("all",c,f);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),x=b.sizeFromShape(g),y=e.makeOutput(h,i.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(y.dataId).id;TK(u,x,T)}if(d&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(y.shape,m);y.shape=T}return y}var kK={kernelName:Mi,backendName:"wasm",setupFunc:lce,kernelFunc:pce};var IK;function cce(r){IK=r.wasm.cwrap(Fi,null,["number, number, number"])}function mce(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,u=e.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:d}=Cn(i,o,e);if(d){let T=e.dataIdMap.get(p.dataId).id;l=p,u=T}let f=l.shape.length;I.assertAxesAreInnerMostDims("any",c,f);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),x=b.sizeFromShape(g),y=e.makeOutput(h,i.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(y.dataId).id;IK(u,x,T)}if(d&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(y.shape,m);y.shape=T}return y}var CK={kernelName:Fi,backendName:"wasm",setupFunc:cce,kernelFunc:mce};var vK;function dce(r){vK=r.wasm.cwrap(so,null,["number","number","number","number","number"])}function fce(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o}=n,{x:s}=t,i=e.dataIdMap.get(s.dataId).id,a=i,u=s,{transposed:l,axes:p,inputWasTransposed:c}=Cn(s,o,e);if(c){let x=e.dataIdMap.get(l.dataId).id;x!==i&&(u=l,a=x)}let m=u.shape.slice(0,-1),d=e.makeOutput(m,"int32"),f=e.dataIdMap.get(d.dataId).id,h=b.sizeFromShape(d.shape),g=u.shape[p[0]];return vK(a,et[u.dtype],h,g,f),c&&e.disposeData(l.dataId),d}var SK={kernelName:so,backendName:"wasm",kernelFunc:fce,setupFunc:dce};var wK;function hce(r){wK=r.wasm.cwrap(ao,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function gce(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id,{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=t,p=I.computePool2DInfo(o.shape,i,a,1,u,l),c=p.filterHeight,m=p.filterWidth,d=p.padInfo.top,f=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,x=p.strideHeight,y=p.strideWidth,T=p.inChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);if(p.dilationWidth!==1||p.dilationHeight!==1)throw new Error(`was backend only supports average pooling with dilation = [1, 1], got [${p.dilationHeight}, ${p.dilationWidth}].`);let k=n.makeOutput(p.outShape,"float32"),C=n.dataIdMap.get(k.dataId).id;return wK(s,o.shape[0],o.shape[1],o.shape[2],c,m,d,f,h,g,x,y,T,C),k}var _K={kernelName:ao,backendName:"wasm",setupFunc:hce,kernelFunc:gce};function gr(r){let{inputs:e,attrs:t}=r,{x:n}=e,{shape:o}=t,s=b.sizeFromShape(n.shape),i=b.inferFromImplicitShape(o,s);return b.assert(s===b.sizeFromShape(i),()=>`new shape: ${i}, old shape: ${n.shape}. New shape and old shape must have the same number of elements.`),r.backend.incRef(n.dataId),{dataId:n.dataId,shape:i,dtype:n.dtype}}var AK={kernelName:Ts,backendName:"wasm",kernelFunc:gr};var NK;function bce(r){NK=r.wasm.cwrap(io,null,["number","array","number","number","array","number","number","number","number"])}function yce(r){let{inputs:e,backend:t,attrs:n}=r,{a:o,b:s}=e,{transposeA:i,transposeB:a}=n;if(o.dtype!=="float32"||s.dtype!=="float32")throw new Error("BatchMatMul for non non-float32 tensors not yet supported.");let u=o.shape.length,l=s.shape.length,p=i?o.shape[u-2]:o.shape[u-1],c=a?s.shape[l-1]:s.shape[l-2],m=i?o.shape[u-1]:o.shape[u-2],d=a?s.shape[l-2]:s.shape[l-1],f=o.shape.slice(0,-2),h=s.shape.slice(0,-2),g=b.sizeFromShape(f),x=b.sizeFromShape(h),T=Ar.assertAndGetBroadcastShape(o.shape.slice(0,-2),s.shape.slice(0,-2)).concat([m,d]);b.assert(p===c,()=>`Error in matMul: inner shapes (${p}) and (${c}) of Tensors with shapes ${o.shape} and ${s.shape} and transposeA=${i} and transposeB=${a} must match.`);let k=i?[g,p,m]:[g,m,p],C=a?[x,d,c]:[x,c,d],A=gr({inputs:{x:o},backend:t,attrs:{shape:k}}),M=gr({inputs:{x:s},backend:t,attrs:{shape:C}}),P=t.dataIdMap.get(A.dataId).id,F=t.dataIdMap.get(M.dataId).id,B=i?A.shape[2]:A.shape[1],U=a?M.shape[1]:M.shape[2],W=Math.max(g,x),K=t.makeOutput([W,B,U],A.dtype),j=t.dataIdMap.get(K.dataId).id,V=new Uint8Array(new Int32Array(A.shape).buffer),q=new Uint8Array(new Int32Array(M.shape).buffer);return NK(P,V,A.shape.length,F,q,M.shape.length,i,a,j),t.disposeData(A.dataId),t.disposeData(M.dataId),K.shape=T,K}var DK={kernelName:io,backendName:"wasm",setupFunc:bce,kernelFunc:yce};function Zs(r){let{inputs:{x:e},attrs:{begin:t,size:n},backend:o}=r,[s,i]=Tt.parseSliceParams(e,t,n),a=Tt.isSliceContinous(e.shape,s,i),u=o.readSync(e.dataId),l=o.makeOutput(i,e.dtype),p=b.computeStrides(e.shape),c=o.dataIdMap.get(l.dataId);if(a){let f=Tt.computeFlatOffset(s,p);return e.dtype==="string"?c.stringBytes=u.slice(f,f+b.sizeFromShape(i)):o.typedArrayFromHeap(l).set(u.subarray(f,f+b.sizeFromShape(i))),l}if(e.dtype==="string"){let f=wp(u,s,i,e.shape,e.dtype);return c.stringBytes=f,l}let m=o.typedArrayFromHeap(l),d=e.shape.length;if(d===2)xce(u,p[0],m,s,i);else if(d===3)Tce(u,p[0],p[1],m,s,i);else if(d===4)kce(u,p[0],p[1],p[2],m,s,i);else{let f=wp(u,s,i,e.shape,e.dtype);m.set(f)}return l}function xce(r,e,t,n,o){let s=0,i=n[0],a=n[1],u=i+o[0];for(let l=i;l<u;l++){let p=l*e+a;t.set(r.subarray(p,p+o[1]),s),s+=o[1]}}function Tce(r,e,t,n,o,s){let i=0,a=o[0],u=o[1],l=o[2],p=a+s[0],c=u+s[1];for(let m=a;m<p;m++)for(let d=u;d<c;d++){let f=m*e+d*t+l;n.set(r.subarray(f,f+s[2]),i),i+=s[2]}}function kce(r,e,t,n,o,s,i){let a=0,u=s[0],l=s[1],p=s[2],c=u+i[0],m=l+i[1],d=p+i[2],f=s[3];for(let h=u;h<c;h++)for(let g=l;g<m;g++)for(let x=p;x<d;x++){let y=h*e+g*t+x*n+f;o.set(r.subarray(y,y+i[3]),a),a+=i[3]}}var PK={kernelName:Is,backendName:"wasm",kernelFunc:Zs};function Ice(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,crops:i}=n,a=s.reduce((x,y)=>x*y),u=I.getReshaped(o.shape,s,a),l=I.getPermuted(u.length,s.length),p=I.getReshapedPermuted(o.shape,s,a),c=I.getSliceBeginCoords(i,s.length),m=I.getSliceSize(p,i,s.length),d=gr({inputs:{x:o},backend:t,attrs:{shape:u}}),f=Si({inputs:{x:d},backend:t,attrs:{perm:l}}),h=gr({inputs:{x:f},backend:t,attrs:{shape:p}}),g=Zs({inputs:{x:h},backend:t,attrs:{begin:c,size:m}});return t.disposeData(d.dataId),t.disposeData(f.dataId),t.disposeData(d.dataId),g}var MK={kernelName:ds,backendName:"wasm",kernelFunc:Ice};function _u(r){let{inputs:{x:e},attrs:{dtype:t},backend:n}=r,o=n.makeOutput(e.shape,t),s=n.typedArrayFromHeap(e);return n.typedArrayFromHeap(o).set(s),o}var FK={kernelName:Kn,backendName:"wasm",kernelFunc:_u};var EK=dt(uo);var RK;function Cce(r){RK=r.wasm.cwrap(Vn,null,["number","number","number","number"])}function vce(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{clipValueMin:s,clipValueMax:i}=n,a=t.dataIdMap.get(o.dataId).id,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(u.dataId).id;return RK(a,s,i,l),u}var LK={kernelName:Vn,backendName:"wasm",setupFunc:Cce,kernelFunc:vce};function BN(r){let{inputs:e,backend:t}=r,n=b.parseAxisParam(r.attrs.axis,e[0].shape)[0],o=I.computeOutShape(e.map(d=>d.shape),n),s=e.filter(d=>b.sizeFromShape(d.shape)>0);if(s.length===1)return Wp({inputs:{x:s[0]},backend:t});let i=t.makeOutput(o,e[0].dtype);if(b.sizeFromShape(o)===0)return i;let a=s.map(d=>d.shape);if(I.assertParamsConsistent(a,n),s[0].dtype==="string"){let d=s.map(T=>{let k=b.sizeFromShape(T.shape.slice(n));return gr({inputs:{x:T},backend:t,attrs:{shape:[-1,k]}})}),f=d.map(T=>({vals:t.readSync(T.dataId),shape:T.shape}));o=I.computeOutShape(d.map(T=>T.shape),1);let h=d[0].shape[0]===1,g=Cp(f,o,e[0].dtype,h),x=I.computeOutShape(s.map(T=>T.shape),n);i.shape=x;let y=t.dataIdMap.get(i.dataId);return y.stringBytes=I.fromStringArrayToUint8(g),d.forEach(T=>t.disposeData(T.dataId)),i}let u=b.sizeFromShape(s[0].shape.slice(0,n)),l=0,p=s.map(d=>{let f=b.sizeFromShape(d.shape.slice(n));return l+=f,f}),c=s.map(d=>t.typedArrayFromHeap(d)),m=t.typedArrayFromHeap(i);for(let d=0;d<u;d++){let f=d*l;for(let h=0;h<c.length;h++){let g=p[h],x=d*g,y=c[h].subarray(x,x+g);m.set(y,f),f+=g}}return i}var BK={kernelName:fs,backendName:"wasm",kernelFunc:BN};var $K;function Sce(r){$K=r.wasm.cwrap(lo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function wce(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:c,dataFormat:m}=t,d=I.convertConv2DDataFormat(m),f=I.computeConv2DInfo(o.shape,s.shape,u,l,p,c,!1,d),h=f.filterHeight,g=f.filterWidth,x=f.padInfo.top,y=f.padInfo.right,T=f.padInfo.bottom,k=f.padInfo.left,C=f.dilationHeight,A=f.dilationWidth,M=f.strideHeight,P=f.strideWidth,F=f.inChannels,B=f.outChannels,U=f.padInfo.type==="SAME"?1:0;if(f.dataFormat!=="channelsLast")throw new Error(`wasm backend Conv2D does not support dataFormat:'${f.dataFormat}'. Please use 'channelsLast'.`);let W=n.makeOutput(f.outShape,"float32"),K=n.dataIdMap.get(W.dataId).id;return $K(i,o.shape[0],o.shape[1],o.shape[2],a,h,g,x,y,T,k,U,C,A,M,P,F,B,K),W}var OK={kernelName:lo,backendName:"wasm",setupFunc:Sce,kernelFunc:wce};var zK;function _ce(r){zK=r.wasm.cwrap(po,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Ace(r){let{backend:e,inputs:t,attrs:n}=r,{dy:o,filter:s}=t,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,inputShape:p}=n,c=1,m=I.convertConv2DDataFormat(u),d=I.computeConv2DInfo(p,s.shape,i,c,a,l,!1,m),{batchSize:f,filterHeight:h,filterWidth:g,inChannels:x,inHeight:y,inWidth:T,outChannels:k,outHeight:C,outWidth:A,strideHeight:M,strideWidth:P}=d,F=h-1-d.padInfo.top,B=g-1-d.padInfo.left,U=d.dataFormat==="channelsLast",W=b.computeStrides(d.inShape),K=b.computeStrides(o.shape),[j,V,q]=b.computeStrides(s.shape),ee=W[0],Z=U?W[1]:W[2],te=U?W[2]:1,oe=U?1:W[1],ie=K[0],se=U?K[1]:K[2],ue=U?K[2]:1,ye=U?1:K[1],fe=e.makeOutput(d.inShape,"float32"),Te=e.dataIdMap.get(fe.dataId).id,we=e.dataIdMap.get(o.dataId).id,Re=e.dataIdMap.get(s.dataId).id;return zK(we,Re,f,h,g,y,T,x,C,A,k,M,P,F,B,j,V,q,ee,Z,te,oe,ie,se,ue,ye,Te),fe}var GK={kernelName:po,backendName:"wasm",setupFunc:_ce,kernelFunc:Ace};var UK=dt(co);var WK=dt(mo);var KK=(t=>(t[t.bilinear=0]="bilinear",t[t.nearest=1]="nearest",t))(KK||{}),VK;function Nce(r){VK=r.wasm.cwrap(ra,null,["number","number","number","number","array","number","number","number","number","number"])}function Dce(r){let{backend:e,inputs:t,attrs:n}=r,{method:o,extrapolationValue:s,cropSize:i}=n,{image:a,boxes:u,boxInd:l}=t,p=u.shape[0],[c,m]=i,d=[p,c,m,a.shape[3]],f=e.dataIdMap.get(a.dataId),h;a.dtype!=="float32"&&(h=_u({backend:e,inputs:{x:a},attrs:{dtype:"float32"}}),f=e.dataIdMap.get(h.dataId));let g=f.id,x=e.dataIdMap.get(u.dataId).id,y=e.dataIdMap.get(l.dataId).id,T=e.makeOutput(d,"float32"),k=e.dataIdMap.get(T.dataId).id,C=new Uint8Array(new Int32Array(a.shape).buffer);return VK(g,x,y,p,C,c,m,KK[o],s,k),h!=null&&e.disposeData(h.dataId),T}var jK={kernelName:ra,backendName:"wasm",setupFunc:Nce,kernelFunc:Dce};var HK;function Pce(r){HK=r.wasm.cwrap(ta,null,["number","number","number","number","number","number"])}function Mce(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{axis:s,exclusive:i,reverse:a}=n,u=o.shape.length;b.assert(o.dtype==="float32"||o.dtype==="int32",()=>`cumsum does not support ${o.dtype} tensors in the WASM backend`);let l=I.getAxesPermutation([s],u),p=o;l!==null&&(p=Si({inputs:{x:o},attrs:{perm:l},backend:t}));let c=I.getInnerMostAxes(1,u)[0];I.assertAxesAreInnerMostDims("cumsum",[c],u);let m=t.makeOutput(p.shape,p.dtype),d=p.shape[c],f=t.dataIdMap.get(p.dataId).id,h=t.dataIdMap.get(m.dataId).id;HK(f,i?1:0,a?1:0,d,h,et[o.dtype]);let g=m;if(l!==null){let x=I.getUndoAxesPermutation(l);g=Si({inputs:{x:m},attrs:{perm:x},backend:t}),t.disposeData(p.dataId),t.disposeData(m.dataId)}return g}var qK={kernelName:ta,backendName:"wasm",setupFunc:Pce,kernelFunc:Mce};var XK;function Fce(r){XK=r.wasm.cwrap(na,null,["number","number","number","array","number","array","array","number","number"])}function Ece(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{blockSize:s,dataFormat:i}=n,a=o.shape[0],u=i==="NHWC"?o.shape[1]:o.shape[2],l=i==="NHWC"?o.shape[2]:o.shape[3],p=i==="NHWC"?o.shape[3]:o.shape[1],c=u*s,m=l*s,d=p/(s*s),f=i==="NHWC"?[a,c,m,d]:[a,d,c,m],h=e.makeOutput(f,"float32"),x=e.dataIdMap.get(o.dataId).id,y=new Uint8Array(new Int32Array(b.computeStrides(o.shape)).buffer),T=new Uint8Array(new Int32Array(f).buffer),k=new Uint8Array(new Int32Array(b.computeStrides(f)).buffer),C=e.dataIdMap.get(h.dataId).id;return XK(x,s,i==="NHWC"?1:0,y,o.shape.length-1,T,k,f.length,C),h}var YK={kernelName:na,backendName:"wasm",setupFunc:Fce,kernelFunc:Ece};var QK;function Rce(r){QK=r.wasm.cwrap(fo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Lce(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s}=e,i=n.dataIdMap.get(o.dataId).id,a=n.dataIdMap.get(s.dataId).id,{strides:u,dilations:l,pad:p,dimRoundingMode:c}=t,m=l??[1,1],d=I.computeConv2DInfo(o.shape,s.shape,u,m,p,c,!0),f=d.filterHeight,h=d.filterWidth,g=d.padInfo.top,x=d.padInfo.right,y=d.padInfo.bottom,T=d.padInfo.left,k=d.dilationHeight,C=d.dilationWidth,A=d.strideHeight,M=d.strideWidth,P=d.inChannels,F=d.outChannels,B=d.padInfo.type==="SAME"?1:0;if(d.dataFormat!=="channelsLast")throw new Error(`wasm backend DepthwiseConv2dNative does not support dataFormat:'${d.dataFormat}'. Please use 'channelsLast'.`);let U=n.makeOutput(d.outShape,"float32"),W=n.dataIdMap.get(U.dataId).id;return QK(i,o.shape[0],o.shape[1],o.shape[2],a,f,h,g,x,y,T,B,k,C,A,M,P,F,W),U}var ZK={kernelName:fo,backendName:"wasm",setupFunc:Rce,kernelFunc:Lce};var JK=dt(go);var Bce=!1,eV=At(oa,Bce,"bool");var tV=dt(bo,"float32");function sT(r){let{inputs:e,attrs:t,backend:n}=r,{input:o}=e,{dim:s}=t,i=o.shape.length,a=o.shape.slice(),u=s;return s<0&&(b.assert(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),gr({inputs:{x:o},backend:n,attrs:{shape:a}})}var rV={kernelName:hs,backendName:"wasm",kernelFunc:sT};function $N(r){let{attrs:{shape:e,value:t,dtype:n},backend:o}=r,s=o.makeOutput(e,n);return o.typedArrayFromHeap(s).fill(t),s}var nV={kernelName:Za,backendName:"wasm",kernelFunc:$N};var oV;function $ce(r){oV=r.wasm.cwrap(aa,null,["number","number","number","number","number","number"])}function Oce(r){let{inputs:e,backend:t}=r,{image:n}=e,o=t.makeOutput(n.shape,n.dtype),s=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,[a,u,l,p]=n.shape;return oV(s,a,u,l,p,i),o}var sV={kernelName:aa,backendName:"wasm",kernelFunc:Oce,setupFunc:$ce};var aV=dt(yo);var zce=!1,iV=At(xo,zce);var uV;function Gce(r){uV=r.wasm.cwrap(To,null,["number","number","number","number","number","number","number"])}function Uce(r){let{backend:e,inputs:t,attrs:n}=r,{varianceEpsilon:o}=n,{x:s,mean:i,variance:a,offset:u,scale:l}=t,p=e.dataIdMap.get(s.dataId).id,c=e.dataIdMap.get(i.dataId).id,m=e.dataIdMap.get(a.dataId).id,d=u!=null?e.dataIdMap.get(u.dataId).id:0,f=l!=null?e.dataIdMap.get(l.dataId).id:0,h=e.makeOutput(s.shape,s.dtype);if(b.sizeFromShape(s.shape)===0)return h;let g=e.dataIdMap.get(h.dataId).id;return uV(p,c,m,d,f,o,g),h}var lV={kernelName:To,backendName:"wasm",setupFunc:Gce,kernelFunc:Uce};var pV;function Wce(r){pV=r.wasm.cwrap(Ns,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function Kce(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:p,dataFormat:c,dimRoundingMode:m,activation:d,leakyreluAlpha:f}=t,h=I.computeConv2DInfo(o.shape,s.shape,u,p,l,m),g=Up[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedConv2D in the wasm backend.`);let x=n.dataIdMap.get(o.dataId).id,y=n.dataIdMap.get(s.dataId).id,T=h.outChannels,k=0;if(i!=null){let ue=n.dataIdMap.get(i.dataId);if(ue.shape.length!==1)throw new Error(`FusedConv2D only supports rank-1 bias but got rank ${ue.shape.length}.`);if(ue.shape[0]!==T)throw new Error(`FusedConv2D bias shape (${ue.shape}) does not match the number of output channels (${T})`);k=ue.id}let C=h.filterHeight,A=h.filterWidth,M=h.padInfo.top,P=h.padInfo.right,F=h.padInfo.bottom,B=h.padInfo.left,U=h.dilationHeight,W=h.dilationWidth,K=h.strideHeight,j=h.strideWidth,V=h.inChannels,q=h.padInfo.type==="SAME"?1:0,ee=h.batchSize,Z=h.inHeight,te=h.inWidth;if(c!=="NHWC")throw new Error(`wasm backend FusedConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let oe=n.makeOutput(h.outShape,"float32"),ie=n.dataIdMap.get(oe.dataId).id,se=a==null?0:n.dataIdMap.get(a.dataId).id;return pV(x,ee,Z,te,y,C,A,k,M,P,F,B,q,U,W,K,j,V,T,g,se,f||0,ie),oe}var cV={kernelName:Ns,backendName:"wasm",setupFunc:Wce,kernelFunc:Kce};var mV;function Vce(r){mV=r.wasm.cwrap(Ds,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function jce(r){let{inputs:e,attrs:t,backend:n}=r,{x:o,filter:s,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:p,dataFormat:c,dimRoundingMode:m,activation:d,leakyreluAlpha:f}=t,h=I.computeConv2DInfo(o.shape,s.shape,u,p,l,m,!0),g=Up[d];if(g==null)throw new Error(`${d} activation not yet supported for FusedDepthwiseConv2D in the wasm backend.`);let x=n.dataIdMap.get(o.dataId).id,y=n.dataIdMap.get(s.dataId).id,T=h.outChannels,k=0;if(i!=null){let ue=n.dataIdMap.get(i.dataId);if(ue.shape.length!==1)throw new Error(`FusedDepthwiseConv2D only supports rank-1 bias but got rank ${ue.shape.length}.`);if(ue.shape[0]!==T)throw new Error(`FusedDepthwiseConv2D bias shape (${ue.shape}) does not match the number of output channels (${T})`);k=ue.id}let C=h.filterHeight,A=h.filterWidth,M=h.padInfo.top,P=h.padInfo.right,F=h.padInfo.bottom,B=h.padInfo.left,U=h.dilationHeight,W=h.dilationWidth,K=h.strideHeight,j=h.strideWidth,V=h.inChannels,q=h.padInfo.type==="SAME"?1:0,ee=h.batchSize,Z=h.inHeight,te=h.inWidth;if(c!=="NHWC")throw new Error(`wasm backend FusedDepthwiseConv2D does not support dataFormat:'${c}'. Please use 'NHWC'.`);let oe=n.makeOutput(h.outShape,"float32"),ie=n.dataIdMap.get(oe.dataId).id,se=a==null?0:n.dataIdMap.get(a.dataId).id;return mV(x,ee,Z,te,y,C,A,k,M,P,F,B,q,U,W,K,j,V,T,g,se,f||0,ie),oe}var dV={kernelName:Ds,backendName:"wasm",setupFunc:Vce,kernelFunc:jce};var fV;function Hce(r){fV=r.wasm.cwrap(ia,null,["number","number","number","number","number","number","array","number"])}function qce(r){let{backend:e,inputs:t}=r,{params:n,indices:o}=t,[s,i,a,u]=_b.prepareAndValidate(n,o),l=e.makeOutput(s,n.dtype);if(i===0)return l;let p=o.shape,c=p[p.length-1],d=e.dataIdMap.get(n.dataId).id,h=e.dataIdMap.get(o.dataId).id,g=new Uint8Array(new Int32Array(u).buffer),x=e.dataIdMap.get(l.dataId).id;return fV(d,et[n.dtype],h,i,c,a,g,x),l}var hV={kernelName:ia,backendName:"wasm",setupFunc:Hce,kernelFunc:qce};var gV;function Xce(r){gV=r.wasm.cwrap("Gather",null,["number","number","array","number","number","number","array","number"])}function Yce(r){let{backend:e,inputs:t,attrs:n}=r,{x:o,indices:s}=t,{axis:i,batchDims:a}=n,u=b.parseAxisParam(i,o.shape)[0],l=e.readSync(s.dataId),p=o.shape[u];for(let F=0;F<l.length;++F){let B=l[F];b.assert(B<=p-1&&B>=0,()=>`GatherV2: the index value ${B} is not in [0, ${p-1}]`)}let c=I.segment_util.collectGatherOpShapeInfo(o,s,u,a),m=gr({inputs:{x:o},attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]},backend:e}),d=b.sizeFromShape(s.shape),f=gr({inputs:{x:s},attrs:{shape:[c.batchSize,d/c.batchSize]},backend:e}),h=[c.batchSize,c.outerSize,d/c.batchSize,c.sliceSize],g=e.makeOutput(h,o.dtype);if(b.sizeFromShape(o.shape)===0)return g;let x=m.shape.length-1,T=e.dataIdMap.get(m.dataId).id,C=e.dataIdMap.get(f.dataId).id,A=e.dataIdMap.get(g.dataId).id,M=new Uint8Array(new Int32Array(b.computeStrides(m.shape)).buffer),P=new Uint8Array(new Int32Array(b.computeStrides(h)).buffer);return gV(T,et[o.dtype],M,x,C,c.batchSize,P,A),e.disposeData(m.dataId),e.disposeData(f.dataId),g.shape=c.outputShape,g}var bV={kernelName:gs,backendName:"wasm",setupFunc:Xce,kernelFunc:Yce};var Qce=!1,yV=At(ua,Qce,"bool");var Zce=!1,xV=At(ko,Zce,"bool");var TV;function Jce(r){TV=r.wasm.cwrap(Io,null,["number","number","number","number"])}function eme(r){let{inputs:{x:e},attrs:{alpha:t},backend:n}=r,o=n.dataIdMap.get(e.dataId).id,s=n.makeOutput(e.shape,"float32");if(b.sizeFromShape(e.shape)!==0){let i=n.dataIdMap.get(s.dataId).id;TV(o,et[e.dtype],t,i)}return s}var kV={kernelName:Io,backendName:"wasm",setupFunc:Jce,kernelFunc:eme};var tme=!1,IV=At(la,tme,"bool");var rme=!1,CV=At(pa,rme,"bool");var vV=dt(Co);var nme=!1,SV=At(ca,nme,"bool");var wV;function ome(r){wV=r.wasm.cwrap(vo,null,["number","number","number","number"])}function sme(r){let{backend:e,inputs:t,attrs:n}=r,{reductionIndices:o,keepDims:s}=n,{x:i}=t,u=e.dataIdMap.get(i.dataId).id,l=i,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:d}=Cn(i,o,e);if(d){let T=e.dataIdMap.get(p.dataId).id;l=p,u=T}let f=l.shape.length;I.assertAxesAreInnerMostDims("max",c,f);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),x=b.sizeFromShape(g),y=e.makeOutput(h,i.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(y.dataId).id;wV(u,et[i.dtype],x,T)}if(d&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(y.shape,m);y.shape=T}return y}var _V={kernelName:vo,backendName:"wasm",setupFunc:ome,kernelFunc:sme};var ame=!1,AV=At(So,ame);var NV;function ime(r){NV=r.wasm.cwrap(wo,null,["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"])}function ume(r){let{inputs:e,attrs:t,backend:n}=r,o=e.x,s=n.dataIdMap.get(o.dataId).id;b.assert(o.dtype==="float32",()=>`Error in MaxPool: only float32 input is supported. Got ${o.dtype}.`);let{filterSize:i,strides:a,pad:u,dimRoundingMode:l}=t,p=I.computePool2DInfo(o.shape,i,a,1,u,l),c=p.filterHeight,m=p.filterWidth,d=p.padInfo.top,f=p.padInfo.right,h=p.padInfo.bottom,g=p.padInfo.left,x=p.dilationHeight,y=p.dilationWidth,T=p.strideHeight,k=p.strideWidth,C=p.inChannels,A=p.outChannels;if(p.dataFormat!=="channelsLast")throw new Error(`wasm backend does not support dataFormat:'${p.dataFormat}'. Please use 'channelsLast'.`);let M=n.makeOutput(p.outShape,"float32"),P=n.dataIdMap.get(M.dataId).id;return NV(s,o.shape[0],o.shape[1],o.shape[2],c,m,d,f,h,g,x,y,T,k,C,A,P),M}var DV={kernelName:wo,backendName:"wasm",setupFunc:ime,kernelFunc:ume};var PV;function lme(r){PV=r.wasm.cwrap(_o,null,["number, number, number"])}function pme(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:d}=Cn(i,o,e),f=c;if(d){let k=e.dataIdMap.get(p.dataId).id;k!==a&&(l=p,u=k,f=I.getInnerMostAxes(f.length,l.shape.length))}I.assertAxesAreInnerMostDims("mean",f,l.shape.length);let[h,g]=I.computeOutAndReduceShapes(l.shape,f),x=b.sizeFromShape(g),y=l;l.dtype!=="float32"&&(y=_u({backend:e,inputs:{x:l},attrs:{dtype:"float32"}}),u=e.dataIdMap.get(y.dataId).id);let T=e.makeOutput(h,"float32");if(b.sizeFromShape(l.shape)!==0){let k=e.dataIdMap.get(T.dataId).id;PV(u,x,k)}if(d&&e.disposeData(p.dataId),s){let k=I.expandShapeToKeepDim(T.shape,m);T.shape=k}return l.dtype!=="float32"&&e.disposeData(y.dataId),T}var MV={kernelName:_o,backendName:"wasm",setupFunc:lme,kernelFunc:pme};var FV;function cme(r){FV=r.wasm.cwrap(Ao,null,["number","number","number","number"])}function mme(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:d}=Cn(i,o,e);if(d){let T=e.dataIdMap.get(p.dataId).id;T!==a&&(l=p,u=T)}let f=l.shape.length;I.assertAxesAreInnerMostDims("min",c,f);let[h,g]=I.computeOutAndReduceShapes(l.shape,c),x=b.sizeFromShape(g),y=e.makeOutput(h,l.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(y.dataId).id;FV(u,et[i.dtype],x,T)}if(d&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(y.shape,m);y.shape=T}return y}var EV={kernelName:Ao,backendName:"wasm",setupFunc:cme,kernelFunc:mme};var dme=!1,RV=At(No,dme);var LV=(t=>(t[t.reflect=0]="reflect",t[t.symmetric=1]="symmetric",t))(LV||{}),BV;function fme(r){BV=r.wasm.cwrap(Do,null,["number","array","number","number","array","array","number","number"])}function hme(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,mode:o}}=r,s=n.map((f,h)=>f[0]+e.shape[h]+f[1]),i=t.dataIdMap.get(e.dataId).id,a=t.makeOutput(s,e.dtype),u=t.dataIdMap.get(a.dataId).id,l=new Uint8Array(new Int32Array(e.shape).buffer),p=n.map(f=>f[0]),c=n.map(f=>f[1]),m=new Uint8Array(new Int32Array(p).buffer),d=new Uint8Array(new Int32Array(c).buffer);return BV(i,l,e.shape.length,et[e.dtype],m,d,LV[o],u),a}var $V={kernelName:Do,backendName:"wasm",kernelFunc:hme,setupFunc:fme};var gme=!0,OV=At(Po,gme);var zV=dt(bs);function Ym(r,e){let t=new Int32Array(r.wasm.HEAPU8.buffer,e,4),n=t[0],o=t[1],s=t[2],i=t[3];return r.wasm._free(e),{pSelectedIndices:n,selectedSize:o,pSelectedScores:s,pValidOutputs:i}}var GV;function bme(r){GV=r.wasm.cwrap(da,"number",["number","number","number","number","number"])}function yme(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i}=n,{boxes:a,scores:u}=t,l=e.dataIdMap.get(a.dataId).id,p=e.dataIdMap.get(u.dataId).id,c=GV(l,p,s,o,i),{pSelectedIndices:m,selectedSize:d,pSelectedScores:f,pValidOutputs:h}=Ym(e,c);return e.wasm._free(f),e.wasm._free(h),e.makeOutput([d],"int32",m)}var UV={kernelName:da,backendName:"wasm",setupFunc:bme,kernelFunc:yme};var WV;function xme(r){WV=r.wasm.cwrap(ji,"number",["number","number","number","number","number","bool"])}function Tme(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,padToMaxOutputSize:a}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,c=e.dataIdMap.get(l.dataId).id,m=WV(p,c,s,o,i,a),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Ym(e,m);e.wasm._free(h);let x=e.makeOutput([f],"int32",d),y=e.makeOutput([],"int32",g);return[x,y]}var KV={kernelName:ji,backendName:"wasm",setupFunc:xme,kernelFunc:Tme};var VV;function kme(r){VV=r.wasm.cwrap(fa,"number",["number","number","number","number","number","number"])}function Ime(r){let{backend:e,inputs:t,attrs:n}=r,{iouThreshold:o,maxOutputSize:s,scoreThreshold:i,softNmsSigma:a}=n,{boxes:u,scores:l}=t,p=e.dataIdMap.get(u.dataId).id,c=e.dataIdMap.get(l.dataId).id,m=VV(p,c,s,o,i,a),{pSelectedIndices:d,selectedSize:f,pSelectedScores:h,pValidOutputs:g}=Ym(e,m);e.wasm._free(g);let x=e.makeOutput([f],"int32",d),y=e.makeOutput([f],"float32",h);return[x,y]}var jV={kernelName:fa,backendName:"wasm",setupFunc:kme,kernelFunc:Ime};var Cme=!1,HV=At(ma,Cme,"bool");var qV;function vme(r){qV=r.wasm.cwrap(ha,null,["number","number","number","number","number"])}function Sme(r){let{inputs:e,backend:t,attrs:n}=r,{indices:o}=e,{depth:s,onValue:i,offValue:a}=n,u=t.makeOutput([...o.shape,s],"int32"),l=t.dataIdMap.get(u.dataId).id,c=t.dataIdMap.get(o.dataId).id;return qV(c,s,i,a,l),u}var XV={kernelName:ha,backendName:"wasm",setupFunc:vme,kernelFunc:Sme};function wme(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(1),n}var YV={kernelName:ys,backendName:"wasm",kernelFunc:wme};function _me(r){let{inputs:e,backend:t,attrs:n}=r,{axis:o}=n;if(e.length===1)return sT({inputs:{input:e[0]},backend:t,attrs:{dim:o}});let s=e[0].shape,i=e[0].dtype;e.forEach(p=>{b.assertShapesMatch(s,p.shape,"All tensors passed to stack must have matching shapes"),b.assert(i===p.dtype,()=>"All tensors passed to stack must have matching dtypes")});let a=[],u=e.map(p=>{let c=sT({inputs:{input:p},backend:t,attrs:{dim:o}});return a.push(c),c}),l=BN({inputs:u,backend:t,attrs:{axis:o}});return a.forEach(p=>t.disposeData(p.dataId)),l}var QV={kernelName:xs,backendName:"wasm",kernelFunc:_me};var ZV;function Ame(r){ZV=r.wasm.cwrap(Mo,null,["number","array","number","number","array","array","number","number"])}function Nme(r){let{inputs:{x:e},backend:t,attrs:{paddings:n,constantValue:o}}=r,s=n.map((h,g)=>h[0]+e.shape[g]+h[1]);if(b.sizeFromShape(e.shape)===0)return $N({backend:t,attrs:{shape:s,value:o,dtype:e.dtype}});let i=t.dataIdMap.get(e.dataId).id,a=t.makeOutput(s,e.dtype),l=t.dataIdMap.get(a.dataId).id,p=new Uint8Array(new Int32Array(e.shape).buffer),c=n.map(h=>h[0]),m=n.map(h=>h[1]),d=new Uint8Array(new Int32Array(c).buffer),f=new Uint8Array(new Int32Array(m).buffer);return ZV(i,p,e.shape.length,et[e.dtype],d,f,o,l),a}var aT={kernelName:Mo,backendName:"wasm",kernelFunc:Nme,setupFunc:Ame};var Dme=!1,JV=At(Fo,Dme);var e4;function Pme(r){e4=r.wasm.cwrap(Eo,null,["number","number","number"])}function Mme(r){let{inputs:e,backend:t}=r,{x:n,alpha:o}=e,s=t.dataIdMap.get(n.dataId).id,i=t.dataIdMap.get(o.dataId).id,a=s,u=n,l=u;u.dtype!=="float32"&&(l=_u({backend:t,inputs:{x:n},attrs:{dtype:"float32"}}),a=t.dataIdMap.get(l.dataId).id);let p=t.makeOutput(n.shape,"float32"),c=t.dataIdMap.get(p.dataId).id;return e4(a,i,c),u.dtype!=="float32"&&t.disposeData(l.dataId),p}var t4={kernelName:Eo,backendName:"wasm",setupFunc:Pme,kernelFunc:Mme};var r4;function Fme(r){r4=r.wasm.cwrap(ga,null,["number","number","number","number"])}function Eme(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:d}=Cn(i,o,e),f=c;if(d){let T=e.dataIdMap.get(p.dataId).id;T!==a&&(l=p,u=T,f=I.getInnerMostAxes(f.length,l.shape.length))}I.assertAxesAreInnerMostDims("prod",f,l.shape.length);let[h,g]=I.computeOutAndReduceShapes(l.shape,f),x=b.sizeFromShape(g),y=e.makeOutput(h,l.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(y.dataId).id;r4(u,x,et[y.dtype],T)}if(d&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(y.shape,m);y.shape=T}return y}var n4={kernelName:ga,backendName:"wasm",setupFunc:Fme,kernelFunc:Eme};var Rme=r=>{let{backend:e,attrs:t}=r,{start:n,stop:o,step:s,dtype:i}=t,a=Sp(n,o,s,i),u=e.makeOutput([a.length],i);return e.typedArrayFromHeap(u).set(a),u},o4={kernelName:Ja,backendName:"wasm",kernelFunc:Rme};var Lme=!0,s4=At(ho,Lme);var a4=dt(Ro);var i4=dt(Bo);var u4;function Bme(r){u4=r.wasm.cwrap(Lo,null,["number","number","number","number","number","number","number","number","number","number"])}function $me(r){let{backend:e,inputs:t,attrs:n}=r,{images:o}=t,{alignCorners:s,halfPixelCenters:i,size:a}=n,[u,l]=a,[p,c,m,d]=o.shape,f=[p,u,l,d],h=e.dataIdMap.get(o.dataId),g;h.dtype!=="float32"&&(g=_u({backend:e,inputs:{x:o},attrs:{dtype:"float32"}}),h=e.dataIdMap.get(g.dataId));let x=h.id,y=e.makeOutput(f,"float32");if(b.sizeFromShape(o.shape)===0)return y;let T=e.dataIdMap.get(y.dataId).id;return u4(x,p,c,m,d,u,l,s?1:0,i?1:0,T),g!=null&&e.disposeData(g.dataId),y}var l4={kernelName:Lo,backendName:"wasm",setupFunc:Bme,kernelFunc:$me};var p4;function Ome(r){p4=r.wasm.cwrap(ba,null,["number","array","number","array","number","number"])}function zme(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{dims:s}=n,i=b.parseAxisParam(s,o.shape);if(o.shape.length===0)return Wp({inputs:{x:o},backend:t});let a=t.makeOutput(o.shape,o.dtype),u=t.dataIdMap.get(o.dataId).id,l=t.dataIdMap.get(a.dataId).id,p=new Uint8Array(new Int32Array(i).buffer),c=new Uint8Array(new Int32Array(o.shape).buffer);p4(u,p,i.length,c,o.shape.length,l);let m=gr({inputs:{x:a},attrs:{shape:o.shape},backend:t});return t.disposeData(a.dataId),m}var c4={kernelName:ba,backendName:"wasm",kernelFunc:zme,setupFunc:Ome};var m4;function Gme(r){m4=r.wasm.cwrap(Sa,null,["number","number","number","number","number","number","number","number","array","number","number"])}function Ume(r){let{inputs:e,backend:t,attrs:n}=r,{image:o}=e,{radians:s,fillValue:i,center:a}=n,u=t.makeOutput(o.shape,o.dtype),l=t.dataIdMap.get(o.dataId).id,p=t.dataIdMap.get(u.dataId).id,[c,m,d,f]=o.shape,[h,g]=I.getImageCenter(a,m,d),x=i===0,y=255,T=typeof i=="number"?[i,i,i,x?0:y]:[...i,y],k=new Uint8Array(new Int32Array(T).buffer);return m4(l,c,m,d,f,s,h,g,k,T.length,p),u}var d4={kernelName:Sa,backendName:"wasm",kernelFunc:Ume,setupFunc:Gme};var f4=dt(ya);var h4=dt($o);var g4;function Wme(r){g4=r.wasm.cwrap(xa,null,["number","number","number","number","number","number","array","number","number"])}function Kme(r){let{backend:e,inputs:t,attrs:n}=r,{indices:o,updates:s}=t,{shape:i}=n,a=e.makeOutput(i,s.dtype);if(b.sizeFromShape(i)===0)return a;let{sliceRank:u,numUpdates:l,sliceSize:p,strides:c,outputSize:m}=wd.calculateShapes(s,o,i),f=e.dataIdMap.get(o.dataId).id,g=e.dataIdMap.get(s.dataId).id,x=new Uint8Array(new Int32Array(c).buffer),y=e.dataIdMap.get(a.dataId).id;return g4(f,g,et[s.dtype],u,l,p,x,m,y),a}var b4={kernelName:xa,backendName:"wasm",setupFunc:Wme,kernelFunc:Kme};var y4;function Vme(r){y4=r.wasm.cwrap("SelectV2",null,["number","number","number","number","number"])}function jme(r){let{inputs:e,backend:t}=r,{condition:n,t:o,e:s}=e,i=t.dataIdMap.get(n.dataId).id,a=t.dataIdMap.get(o.dataId).id,u=t.dataIdMap.get(s.dataId).id,l=t.makeOutput(o.shape,o.dtype),p=t.dataIdMap.get(l.dataId).id,c=n.shape.length,m=o.shape.length,d=c===0||c>1||m===1?1:b.sizeFromShape(o.shape.slice(1));return y4(i,a,u,d,p),l}var x4={kernelName:ks,backendName:"wasm",kernelFunc:jme,setupFunc:Vme};var T4;function Hme(r){T4=r.wasm.cwrap(zo,null,["number","number"])}function qme(r){let{backend:e,inputs:{x:t}}=r,n=e.dataIdMap.get(t.dataId).id,o=e.makeOutput(t.shape,t.dtype),s=e.dataIdMap.get(o.dataId).id;return b.sizeFromShape(o.shape)===0||T4(n,s),o}var k4={kernelName:"Sigmoid",backendName:"wasm",setupFunc:Hme,kernelFunc:qme};var I4=dt(Oo);var C4;function Xme(r){C4=r.wasm.cwrap(Wo,null,["number","number","number","number"])}function Yme(r){let{backend:e,inputs:{logits:t},attrs:{dim:n}}=r,o=e.dataIdMap.get(t.dataId).id,s=e.makeOutput(t.shape,t.dtype),i=e.dataIdMap.get(s.dataId).id,a=t.shape[n],u=b.sizeFromShape(t.shape)/a;return b.sizeFromShape(s.shape)===0||C4(o,i,a,u),s}var v4={kernelName:Wo,backendName:"wasm",setupFunc:Xme,kernelFunc:Yme};function Qme(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,{blockShape:s,paddings:i}=n,a=b.sizeFromShape(s),u=[[0,0]];u.push(...i);for(let A=1+s.length;A<o.shape.length;++A)u.push([0,0]);let l=aT.kernelFunc({inputs:{x:o},backend:t,attrs:{paddings:u,constantValue:0}}),p=I.getReshaped(l.shape,s,a,!1),c=I.getPermuted(p.length,s.length,!1),m=I.getReshapedPermuted(l.shape,s,a,!1),h=gr({inputs:{x:l},backend:t,attrs:{shape:p}}),y=Si({inputs:{x:h},backend:t,attrs:{perm:c}}),C=gr({inputs:{x:y},backend:t,attrs:{shape:m}});return t.disposeData(l.dataId),t.disposeData(h.dataId),t.disposeData(y.dataId),C}var S4={kernelName:Cs,backendName:"wasm",kernelFunc:Qme};var w4;function Zme(r){w4=r.wasm.cwrap("SparseFillEmptyRows","number",["number","number","number","number","number","number","number","number","number","number","number","number"])}function Jme(r){let{backend:e,inputs:t}=r,{indices:n,values:o,denseShape:s,defaultValue:i}=t,a=n.shape[0],u=n.shape[1],l=e.readSync(s.dataId)[0],p=[a+l,u],c=e.dataIdMap.get(n.dataId).id,m=e.dataIdMap.get(o.dataId).id,d=e.dataIdMap.get(i.dataId).id,f=e.makeOutput(p,n.dtype),h=e.dataIdMap.get(f.dataId).id,g=e.makeOutput(p.slice(0,1),o.dtype),x=e.dataIdMap.get(g.dataId).id,y=e.makeOutput([l],"bool"),T=e.dataIdMap.get(y.dataId).id,k=e.makeOutput([a],n.dtype),C=e.dataIdMap.get(k.dataId).id,A=e.makeOutput([4],"int32"),M=e.dataIdMap.get(A.dataId).id,P=w4(c,m,et[o.dtype],a,l,u,d,h,x,T,C,M),F=e.readSync(A.dataId),B;switch(F[0]){case 1:{B=I.getSparseFillEmptyRowsIndicesDenseShapeMismatch(F[1]);break}case 2:{B=I.getSparseFillEmptyRowsNegativeIndexErrorMessage(F[1],F[2]);break}case 3:B=I.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(F[1],F[2],F[3]);break;default:B=""}if(e.disposeData(A.dataId),B)throw e.disposeData(f.dataId),e.disposeData(g.dataId),e.disposeData(y.dataId),e.disposeData(k.dataId),new Error(B);let U=f,W=g;return P!==p[0]&&(U=Zs({inputs:{x:f},attrs:{begin:0,size:[P,u]},backend:e}),W=Zs({inputs:{x:g},attrs:{begin:0,size:P},backend:e}),e.disposeData(f.dataId),e.disposeData(g.dataId)),[U,W,y,k]}var _4={kernelName:Ku,backendName:"wasm",setupFunc:Zme,kernelFunc:Jme};var A4;function ede(r){A4=r.wasm.cwrap(Qi,null,["number","number","number","number","number","number","number"])}function tde(r){let{backend:e,inputs:t}=r,{inputIndices:n,inputShape:o,newShape:s}=t;if(n.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${n.shape}`);if(o.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${o.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);let i=e.dataIdMap.get(n.dataId).id,a=e.dataIdMap.get(o.dataId).id,u=e.dataIdMap.get(s.dataId).id,l=n.shape[0],p=b.sizeFromShape(s.shape),c=e.makeOutput([l,p],n.dtype),m=e.dataIdMap.get(c.dataId).id,d=e.makeOutput([p],s.dtype),f=e.dataIdMap.get(d.dataId).id,h=e.makeOutput([3],"int32"),g=e.dataIdMap.get(h.dataId).id;A4(i,a,u,l,m,f,g);let x=e.readSync(h.dataId),y;switch(x[0]){case 0:{y=I.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(x[1],x[2]);break}case 1:{y=I.getSparseReshapeNegativeOutputDimErrorMessage(x[1],x[2]);break}case 2:y=I.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage();break;case 3:{let T=Array.from(e.readSync(o.dataId)),k=Array.from(e.readSync(d.dataId));y=I.getSparseReshapeInputOutputMultipleErrorMessage(T,k);break}case 4:{let T=Array.from(e.readSync(o.dataId)),k=Array.from(e.readSync(d.dataId));y=I.getSparseReshapeInputOutputMismatchErrorMessage(T,k);break}default:y=""}if(e.disposeData(h.dataId),y)throw e.disposeData(c.dataId),e.disposeData(d.dataId),new Error(y);return[c,d]}var N4={kernelName:Qi,backendName:"wasm",setupFunc:ede,kernelFunc:tde};var D4;function iT(r){D4=r.wasm.cwrap("SparseSegmentReduction",null,["number","number","number","number","number","number","number","number","number"])}function uT(r,e){let{backend:t,inputs:n}=r,{data:o,indices:s,segmentIds:i}=n,a=s.shape[0],u=t.readSync(i.dataId,a-1,a)[0],p=a>0?u+1:0;if(p<0)throw new Error(I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let c=o.shape.slice();c[0]=p;let m=t.dataIdMap.get(o.dataId).id,d=t.dataIdMap.get(s.dataId).id,f=t.dataIdMap.get(i.dataId).id,h=t.makeOutput(c,o.dtype),g=t.dataIdMap.get(h.dataId).id,x=t.makeOutput([4],"int32"),y=t.dataIdMap.get(x.dataId).id;D4(m,et[o.dtype],o.shape[0],d,f,g,y,e,0);let T=t.readSync(x.dataId),k;switch(T[0]){case 0:{k=I.getSparseSegmentReductionNegativeSegmentIdsErrorMessage();break}case 1:{k=I.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage();break}case 2:k=I.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(T[1],T[2]);break;case 3:k=I.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(T[1],T[2],T[3]);break;default:k=""}if(t.disposeData(x.dataId),k)throw t.disposeData(h.dataId),new Error(k);return h}function rde(r){return uT(r,!0)}var P4={kernelName:Vu,backendName:"wasm",setupFunc:iT,kernelFunc:rde};function nde(r){return uT(r,!1)}var M4={kernelName:ju,backendName:"wasm",setupFunc:iT,kernelFunc:nde};function ode(r){let{inputs:e,attrs:t,backend:n}=r,{x:o}=e,{numOrSizeSplits:s,axis:i}=t,a=b.parseAxisParam(i,o.shape)[0],u=I.prepareSplitSize(o,s,a),l=new Array(o.shape.length).fill(0),p=o.shape.slice();return u.map(c=>{let m=[...p];m[a]=c;let d=Zs({inputs:{x:o},attrs:{begin:l,size:m},backend:n});return l[a]+=c,d})}var F4={kernelName:vs,backendName:"wasm",kernelFunc:ode};var E4=dt(Go);var R4=dt(ti);var sde=!0,L4=At(Ko,sde);var B4;function ade(r){B4=r.wasm.cwrap(_s,null,["number","number","number","number"])}function ide(r){let{backend:e,inputs:t,attrs:n}=r,{alpha:o}=n,{x:s}=t,i=e.dataIdMap.get(s.dataId).id,a=e.makeOutput(s.shape,s.dtype),u=e.dataIdMap.get(a.dataId).id;return B4(i,o,et[s.dtype],u),a}var $4={kernelName:_s,backendName:"wasm",setupFunc:ade,kernelFunc:ide};var O4;function ude(r){O4=r.wasm.cwrap(ka,null,["number","array","number","array","array","array","array","array","number","number"])}function lde(r){let{backend:e,inputs:t,attrs:n}=r,{x:o}=t,{begin:s,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:p,newAxisMask:c,shrinkAxisMask:m}=n,{finalShapeSparse:d,finalShape:f,isIdentity:h,sliceDim0:g,isSimpleSlice:x,begin:y,end:T,strides:k}=Tt.sliceInfo(o.shape,s,i,a,u,l,p,c,m),C;if(h)C=gr({inputs:{x:o},backend:e,attrs:{shape:f}});else if(g||x){b.assert(o.shape.length>=1,()=>`Input must have rank at least 1, got: ${o.shape.length}`);let A=Tt.computeOutShape(y,T,k),M=Zs({inputs:{x:o},backend:e,attrs:{begin:y,size:A}});C=gr({inputs:{x:M},backend:e,attrs:{shape:f}}),e.disposeData(M.dataId)}else{let A=e.makeOutput(d,"float32"),M=e.dataIdMap.get(o.dataId).id,P=new Uint8Array(new Int32Array(b.computeStrides(o.shape)).buffer),F=new Uint8Array(new Int32Array(y).buffer),B=new Uint8Array(new Int32Array(T).buffer),U=new Uint8Array(new Int32Array(k).buffer),W=new Uint8Array(new Int32Array(d).buffer),K=new Uint8Array(new Int32Array(b.computeStrides(d)).buffer),j=e.dataIdMap.get(A.dataId).id;O4(M,P,o.shape.length,F,B,U,W,K,d.length,j),C=gr({inputs:{x:A},backend:e,attrs:{shape:f}}),e.disposeData(A.dataId)}return C}var z4={kernelName:ka,backendName:"wasm",setupFunc:ude,kernelFunc:lde};var pde=!0,G4=At(Vo,pde);var U4;function cde(r){U4=r.wasm.cwrap(Uo,null,["number","number","number","number"])}function mde(r){let{backend:e,inputs:t,attrs:n}=r,{axis:o,keepDims:s}=n,{x:i}=t,a=e.dataIdMap.get(i.dataId).id,u=a,l=i,{transposed:p,axes:c,originalAxes:m,inputWasTransposed:d}=Cn(i,o,e),f=c;if(d){let T=e.dataIdMap.get(p.dataId).id;T!==a&&(l=p,u=T,f=I.getInnerMostAxes(f.length,l.shape.length))}I.assertAxesAreInnerMostDims("sum",f,l.shape.length);let[h,g]=I.computeOutAndReduceShapes(l.shape,f),x=b.sizeFromShape(g),y=e.makeOutput(h,l.dtype);if(b.sizeFromShape(l.shape)!==0){let T=e.dataIdMap.get(y.dataId).id;U4(u,x,et[y.dtype],T)}if(d&&e.disposeData(p.dataId),s){let T=I.expandShapeToKeepDim(y.shape,m);y.shape=T}return y}var W4={kernelName:Uo,backendName:"wasm",setupFunc:cde,kernelFunc:mde};var K4=dt(Ia);var V4=dt(jo);var j4;function dde(r){j4=r.wasm.cwrap(An,null,["number","array","number","array","number","number"])}function fde(r){let{inputs:e,backend:t,attrs:n}=r,{x:o}=e,s=t.dataIdMap.get(o.dataId).id,{reps:i}=n,a=new Array(o.shape.length);for(let m=0;m<a.length;m++)a[m]=o.shape[m]*i[m];let u=new Uint8Array(new Int32Array(o.shape).buffer),l=new Uint8Array(new Int32Array(a).buffer),p=t.makeOutput(a,o.dtype),c=t.dataIdMap.get(p.dataId).id;return j4(s,u,o.shape.length,l,a.length,et[p.dtype],c),p}var H4={kernelName:An,backendName:"wasm",setupFunc:dde,kernelFunc:fde};var q4;function hde(r){q4=r.wasm.cwrap(Ca,null,["number","array","number","number","number","bool","number","number"])}var gde=({inputs:r,backend:e,attrs:t})=>{let{x:n}=r,{k:o,sorted:s}=t,i=e.dataIdMap.get(n.dataId).id,a=new Uint8Array(new Int32Array(n.shape).buffer),u=n.shape.slice();u[u.length-1]=o;let l=e.makeOutput(u,n.dtype),p=e.dataIdMap.get(l.dataId).id,c=e.makeOutput(u,"int32"),m=e.dataIdMap.get(c.dataId).id;return q4(i,a,n.shape.length,et[n.dtype],o,s,p,m),[l,c]},X4={kernelName:Ca,backendName:"wasm",setupFunc:hde,kernelFunc:gde};var Y4;function bde(r){Y4=r.wasm.cwrap(va,null,["number","number","bool","number","number","number","number","number","number","array","number","number","number","number","number"])}function yde(r){let{backend:e,inputs:t,attrs:n}=r,{image:o,transforms:s}=t,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=n,[p,c,m,d]=o.shape,[f,h]=l??[c,m],g=[p,f,h,d],x=new Uint8Array(new Int32Array(b.computeStrides(o.shape)).buffer),y=e.makeOutput(g,o.dtype),T=e.dataIdMap.get(y.dataId).id,C=e.dataIdMap.get(o.dataId).id,M=e.dataIdMap.get(s.dataId).id,P=i==="nearest"?1:2,F;switch(a){case"constant":F=1;break;case"reflect":F=2;break;case"wrap":F=3;break;case"nearest":F=4;break;default:F=1;break}return Y4(C,M,s.shape[0]>1,p,f,h,d,m,c,x,o.shape.length-1,P,F,u,T),y}var Q4={kernelName:va,backendName:"wasm",setupFunc:bde,kernelFunc:yde};function xde(r){let{inputs:e,backend:t,attrs:n}=r,{value:o}=e,{axis:s}=n;s<0&&(s+=o.shape.length);let i=o.shape[s],a=o.shape.length,u=new Array(a-1),l=0;for(let d=0;d<a;d++)d!==s&&(u[l++]=o.shape[d]);let p=new Array(i),c=new Array(a).fill(0),m=o.shape.slice();m[s]=1;for(let d=0;d<p.length;d++)c[s]=d,p[d]=Zs({inputs:{x:o},attrs:{begin:c,size:m},backend:t});return p.map(({dataId:d,dtype:f})=>({dataId:d,dtype:f,shape:u}))}var Z4={kernelName:Ss,backendName:"wasm",kernelFunc:xde};function Tde(r){let{inputs:{x:e},backend:t}=r,n=t.makeOutput(e.shape,e.dtype);return t.typedArrayFromHeap(n).fill(0),n}var J4={kernelName:ws,backendName:"wasm",kernelFunc:Tde};var kde=[dK,fK,gK,kK,CK,SK,_K,DK,MK,FK,EK,LK,BK,OK,GK,UK,WK,jK,qK,YK,ZK,JK,eV,tV,rV,nV,sV,aV,iV,mK,lV,cV,dV,hV,bV,yV,xV,bK,kV,IV,CV,vV,SV,_V,AV,DV,MV,EV,RV,$V,OV,zV,UV,KV,jV,HV,XV,YV,QV,aT,JV,t4,n4,o4,s4,a4,i4,AK,l4,c4,d4,h4,f4,b4,x4,k4,I4,PK,v4,S4,_4,N4,P4,M4,F4,E4,R4,L4,$4,z4,G4,W4,K4,V4,H4,X4,Q4,xK,Z4,J4];for(let r of kde)Zi(r);var ON=$();ON.registerFlag("WASM_HAS_SIMD_SUPPORT",async()=>WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11])));ON.registerFlag("WASM_HAS_MULTITHREAD_SUPPORT",async()=>{if(ON.get("IS_NODE"))return!1;try{return new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}});var KN=wl(nj());var oj='var Module={};function threadPrintErr(){var text=Array.prototype.slice.call(arguments).join(" ");console.error(text)}function threadAlert(){var text=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:text,threadId:Module["_pthread_self"]()})}var err=threadPrintErr;this.alert=threadAlert;Module["instantiateWasm"]=function(info,receiveInstance){var instance=new WebAssembly.Instance(Module["wasmModule"],info);Module["wasmModule"]=null;receiveInstance(instance);return instance.exports};function moduleLoaded(){}this.onmessage=function(e){try{if(e.data.cmd==="load"){Module["wasmModule"]=e.data.wasmModule;Module["wasmMemory"]=e.data.wasmMemory;Module["buffer"]=Module["wasmMemory"].buffer;Module["ENVIRONMENT_IS_PTHREAD"]=true;if(typeof e.data.urlOrBlob==="string"){importScripts(e.data.urlOrBlob)}else{var objectUrl=URL.createObjectURL(e.data.urlOrBlob);importScripts(objectUrl);URL.revokeObjectURL(objectUrl)}WasmBackendModuleThreadedSimd(Module).then(function(instance){Module=instance;moduleLoaded()})}else if(e.data.cmd==="objectTransfer"){Module["PThread"].receiveObjectTransfer(e.data)}else if(e.data.cmd==="run"){Module["__performance_now_clock_drift"]=performance.now()-e.data.time;Module["__emscripten_thread_init"](e.data.threadInfoStruct,0,0);var max=e.data.stackBase;var top=e.data.stackBase+e.data.stackSize;Module["establishStackSpace"](top,max);Module["_emscripten_tls_init"]();Module["PThread"].receiveObjectTransfer(e.data);Module["PThread"].setThreadStatus(Module["_pthread_self"](),1);try{var result=Module["invokeEntryPoint"](e.data.start_routine,e.data.arg);if(!Module["getNoExitRuntime"]())Module["PThread"].threadExit(result)}catch(ex){if(ex==="Canceled!"){Module["PThread"].threadCancel()}else if(ex!="unwind"){if(ex instanceof Module["ExitStatus"]){if(Module["getNoExitRuntime"]()){}else{Module["PThread"].threadExit(ex.status)}}else{Module["PThread"].threadExit(-2);throw ex}}}}else if(e.data.cmd==="cancel"){if(Module["_pthread_self"]()){Module["PThread"].threadCancel()}}else if(e.data.target==="setimmediate"){}else if(e.data.cmd==="processThreadQueue"){if(Module["_pthread_self"]()){Module["_emscripten_current_thread_process_queued_calls"]()}}else{err("worker.js received unknown command "+e.data.cmd);err(e.data)}}catch(ex){err("worker.js onmessage() captured an uncaught exception: "+ex);if(ex&&ex.stack)err(ex.stack);throw ex}};if(typeof process==="object"&&typeof process.versions==="object"&&typeof process.versions.node==="string"){self={location:{href:__filename}};var onmessage=this.onmessage;var nodeWorkerThreads=require("worker_threads");global.Worker=nodeWorkerThreads.Worker;var parentPort=nodeWorkerThreads.parentPort;parentPort.on("message",function(data){onmessage({data:data})});var nodeFS=require("fs");var nodeRead=function(filename){return nodeFS.readFileSync(filename,"utf8")};function globalEval(x){global.require=require;global.Module=Module;eval.call(null,x)}importScripts=function(f){globalEval(nodeRead(f))};postMessage=function(msg){parentPort.postMessage(msg)};if(typeof performance==="undefined"){performance={now:function(){return Date.now()}}}}';var aj=wl(sj());var cT=class extends ps{constructor(e){super();this.wasm=e;this.dataIdNextNumber=1;this.wasm.tfjs.initWithThreadsCount(lj),jN=this.wasm.tfjs.getThreadsCount(),this.dataIdMap=new qa(this,qo())}write(e,t,n){let o={id:this.dataIdNextNumber++};return this.move(o,e,t,n,1),o}numDataIds(){return this.dataIdMap.numDataIds()}async time(e){let t=b.now();return e(),{kernelMs:b.now()-t}}move(e,t,n,o,s){let i=this.dataIdNextNumber++;if(o==="string"){let p=t;this.dataIdMap.set(e,{id:i,stringBytes:p,shape:n,dtype:o,memoryOffset:null,refCount:s});return}let a=b.sizeFromShape(n),u=a*b.bytesPerElement(o),l=this.wasm._malloc(u);this.dataIdMap.set(e,{id:i,memoryOffset:l,shape:n,dtype:o,refCount:s}),this.wasm.tfjs.registerTensor(i,a,l),t!=null&&this.wasm.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),l)}async read(e){return this.readSync(e)}readSync(e,t,n){let{memoryOffset:o,dtype:s,shape:i,stringBytes:a}=this.dataIdMap.get(e);if(s==="string")return(t==null||t===0)&&(n==null||n>=a.length)?a:a.slice(t,n);t=t||0,n=n||b.sizeFromShape(i);let u=b.bytesPerElement(s),l=this.wasm.HEAPU8.slice(o+t*u,o+n*u);return Cde(l.buffer,s)}disposeData(e,t=!1){if(this.dataIdMap.has(e)){let n=this.dataIdMap.get(e);if(n.refCount--,!t&&n.refCount>0)return!1;this.wasm._free(n.memoryOffset),this.wasm.tfjs.disposeData(n.id),this.dataIdMap.delete(e)}return!0}refCount(e){return this.dataIdMap.has(e)?this.dataIdMap.get(e).refCount:0}incRef(e){let t=this.dataIdMap.get(e);t!=null&&t.refCount++}floatPrecision(){return 32}getMemoryOffset(e){return this.dataIdMap.get(e).memoryOffset}dispose(){this.wasm.tfjs.dispose(),"PThread"in this.wasm&&this.wasm.PThread.terminateAllThreads(),this.wasm=null}memory(){return{unreliable:!1}}makeOutput(e,t,n){let o;if(n==null)o=this.write(null,e,t);else{let s=this.dataIdNextNumber++;o={id:s},this.dataIdMap.set(o,{id:s,memoryOffset:n,shape:e,dtype:t,refCount:1});let i=b.sizeFromShape(e);this.wasm.tfjs.registerTensor(s,i,n)}return{dataId:o,shape:e,dtype:t}}typedArrayFromHeap({shape:e,dtype:t,dataId:n}){let o=this.wasm.HEAPU8.buffer,{memoryOffset:s}=this.dataIdMap.get(n),i=b.sizeFromShape(e);switch(t){case"float32":return new Float32Array(o,s,i);case"int32":return new Int32Array(o,s,i);case"bool":return new Uint8Array(o,s,i);default:throw new Error(`Unknown dtype ${t}`)}}};function Ide(r){return(e,t)=>(b.fetch(r,{credentials:"same-origin"}).then(n=>{n.ok||e.env.a(`failed to load wasm binary file at '${r}'`),n.arrayBuffer().then(o=>{WebAssembly.instantiate(o,e).then(s=>{t(s.instance,s.module)})})}),{})}function ij(r,e,t){if(mT!=null)return mT;let n="tfjs-backend-wasm.wasm";return r&&e?n="tfjs-backend-wasm-threaded-simd.wasm":r&&(n="tfjs-backend-wasm-simd.wasm"),Fg!=null&&Fg[n]!=null?Fg[n]:t+n}async function uj(){let[r,e]=await Promise.all([$().getAsync("WASM_HAS_SIMD_SUPPORT"),$().getAsync("WASM_HAS_MULTITHREAD_SUPPORT")]);return new Promise((t,n)=>{let o={};o.locateFile=(a,u)=>{if(a.endsWith(".worker.js")){let l=oj,p=new Blob([l],{type:"application/javascript"});return URL.createObjectURL(p)}return a.endsWith(".wasm")?ij(r,e,Mg??u):u+a},VN&&(o.instantiateWasm=Ide(ij(r,e,Mg??"")));let s=!1;o.onAbort=()=>{if(s||Eg)return;Eg=!0,n({message:"Make sure the server can serve the `.wasm` file relative to the bundled js file. For more details see https://github.com/tensorflow/tfjs/blob/master/tfjs-backend-wasm/README.md#using-bundlers"})};let i;e&&r&&mT==null?(o.mainScriptUrlOrBlob=new Blob(["var WasmBackendModuleThreadedSimd = "+KN.default.toString()],{type:"text/javascript"}),i=(0,KN.default)(o)):i=(0,aj.default)(o),i.then(a=>{s=!0,Eg=!1;let u=null;a.tfjs={init:a.cwrap("init",null,[]),initWithThreadsCount:a.cwrap("init_with_threads_count",null,["number"]),getThreadsCount:a.cwrap("get_threads_count","number",[]),registerTensor:a.cwrap("register_tensor",null,["number","number","number"]),disposeData:a.cwrap("dispose_data",u,["number"]),dispose:a.cwrap("dispose",u,[])},t({wasm:a})})})}function Cde(r,e){switch(e){case"float32":return new Float32Array(r);case"int32":return new Int32Array(r);case"bool":return new Uint8Array(r);default:throw new Error(`Unknown dtype ${e}`)}}var vde=["tfjs-backend-wasm.wasm","tfjs-backend-wasm-simd.wasm","tfjs-backend-wasm-threaded-simd.wasm"],mT=null,Mg=null,Fg={},Eg=!1,VN=!1;function Sde(r,e=!1){if(SI("setWasmPath has been deprecated in favor of setWasmPaths and will be removed in a future release."),Eg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPath()` before you call `tf.setBackend()` or `tf.ready()`");mT=r,VN=e}function wde(r,e=!1){if(Eg)throw new Error("The WASM backend was already initialized. Make sure you call `setWasmPaths()` before you call `tf.setBackend()` or `tf.ready()`");if(typeof r=="string")Mg=r;else{Fg=r;let t=vde.filter(n=>Fg[n]==null);if(t.length>0)throw new Error(`There were no entries found for the following binaries: ${t.join(",")}. Please either call setWasmPaths with a map providing a path for each binary, or with a string indicating the directory where all the binaries can be found.`)}VN=e}var lj=-1,jN=-1;function _de(r){lj=r}function Ade(){if(jN===-1)throw new Error("WASM backend not initialized.");return jN}var Nde="0.0.0";var Dde=2;el("wasm",async()=>{let{wasm:r}=await uj();return new cT(r)},Dde);var Tl="3.12.0-20211214",Yqr={tfjs:Tl,"tfjs-core":Tl,"tfjs-data":Tl,"tfjs-layers":Tl,"tfjs-converter":Tl,"tfjs-backend-cpu":Tl,"tfjs-backend-webgl":Tl,"tfjs-backend-wasm":Tl};export{ms as Abs,Di as Acos,Pi as Acosh,ap as AdadeltaOptimizer,ip as AdagradOptimizer,up as AdamOptimizer,lp as AdamaxOptimizer,_n as Add,oo as AddN,Mi as All,Fi as Any,so as ArgMax,Qa as ArgMin,Ei as Asin,Ri as Asinh,Li as Atan,$i as Atan2,Bi as Atanh,ao as AvgPool,Eu as AvgPool3D,ac as AvgPool3DGrad,sc as AvgPoolGrad,cT as BackendWasm,io as BatchMatMul,ds as BatchToSpaceND,ic as Bincount,uc as BroadcastArgs,dD as BroadcastTo,Gv as Callback,XC as CallbackList,Kn as Cast,uo as Ceil,Vn as ClipByValue,Ru as Complex,Lu as ComplexAbs,fs as Concat,lo as Conv2D,lc as Conv2DBackpropFilter,po as Conv2DBackpropInput,Bu as Conv3D,pc as Conv3DBackpropFilterV2,cc as Conv3DBackpropInputV2,co as Cos,mo as Cosh,ra as CropAndResize,ta as Cumsum,QC as CustomCallback,qa as DataStorage,mc as DenseBincount,na as DepthToSpace,fo as DepthwiseConv2dNative,dc as DepthwiseConv2dNativeBackpropFilter,fc as DepthwiseConv2dNativeBackpropInput,hc as Diag,$u as Dilation2D,gd as Dilation2DBackpropFilter,hd as Dilation2DBackpropInput,Kk as ENV,Uv as EarlyStopping,Ou as Einsum,go as Elu,gc as EluGrad,pb as Environment,oa as Equal,Oi as Erf,bo as Exp,hs as ExpandDims,sa as Expm1,bc as FFT,Za as Fill,aa as FlipLeftRight,yo as Floor,xo as FloorDiv,Dl as FromPixels,To as FusedBatchNorm,Ns as FusedConv2D,Ds as FusedDepthwiseConv2D,Mx as GPGPUContext,ia as GatherNd,gs as GatherV2,yS as GraphModel,ua as Greater,ko as GreaterEqual,YC as History,yc as IFFT,jn as Identity,zu as Imag,Ft as InputSpec,zi as IsFinite,Gi as IsInf,Ui as IsNan,ps as KernelBackend,Gu as LRN,Tc as LRNGrad,my as LayerVariable,ts as LayersModel,Io as LeakyRelu,la as Less,pa as LessEqual,xc as LinSpace,Co as Log,Wi as Log1p,fD as LogSoftmax,ca as LogicalAnd,Ki as LogicalNot,Nl as LogicalOr,Uh as MathBackendCPU,sg as MathBackendWebGL,vo as Max,wo as MaxPool,Uu as MaxPool3D,Ic as MaxPool3DGrad,kc as MaxPoolGrad,Cc as MaxPoolWithArgmax,So as Maximum,_o as Mean,Ao as Min,No as Minimum,Do as MirrorPad,Vi as Mod,pp as MomentumOptimizer,vc as Multinomial,Po as Multiply,bs as Neg,da as NonMaxSuppressionV3,ji as NonMaxSuppressionV4,fa as NonMaxSuppressionV5,ma as NotEqual,qD as OP_SCOPE_SUFFIX,ha as OneHot,ys as OnesLike,tn as Optimizer,ci as OptimizerConstructors,xs as Pack,Mo as PadV2,Lde as Pool,Fo as Pow,Eo as Prelu,ga as Prod,cp as RMSPropOptimizer,Ks as RNN,Ja as Range,zD as Rank,Wu as Real,ho as RealDiv,Hi as Reciprocal,ir as Reduction,Ro as Relu,Bo as Relu6,Ts as Reshape,Lo as ResizeBilinear,wc as ResizeBilinearGrad,ei as ResizeNearestNeighbor,Sc as ResizeNearestNeighborGrad,ba as Reverse,Sa as RotateWithOffset,ya as Round,$o as Rsqrt,fu as SGDOptimizer,xa as ScatterNd,ks as Select,qi as Selu,dm as Sequential,zo as Sigmoid,Xi as Sign,Oo as Sin,Ta as Sinh,Is as Slice,Wo as Softmax,Yi as Softplus,Cs as SpaceToBatchND,Ku as SparseFillEmptyRows,Qi as SparseReshape,Vu as SparseSegmentMean,ju as SparseSegmentSum,Hu as SparseToDense,vs as SplitV,Go as Sqrt,ti as Square,Ko as SquaredDifference,_s as Step,ka as StridedSlice,qu as StringNGrams,_c as StringSplit,Ac as StringToHashBucketFast,Vo as Sub,Uo as Sum,yn as SymbolicTensor,Ia as Tan,jo as Tanh,Ye as Tensor,yt as TensorBuffer,An as Tile,Ca as TopK,va as Transform,Ho as Transpose,Nc as Unique,Ss as Unpack,Xu as UnsortedSegmentSum,Zu as Variable,ws as ZerosLike,As as _FusedMatMul,$t as abs,wI as acos,_I as acosh,X as add,AI as addN,Nd as all,zc as any,au as argMax,NI as argMin,DI as asin,PI as asinh,MI as atan,FI as atan2,EI as atanh,zl as avgPool,Dd as avgPool3d,j0 as backend,I as backend_util,F6 as basicLSTMCell,ai as batchNorm,$I as batchNorm2d,OI as batchNorm3d,zI as batchNorm4d,Gl as batchToSpaceND,Pd as bincount,NLe as booleanMaskAsync,GI as broadcastArgs,Ul as broadcastTo,Ar as broadcast_util,wb as browser,Ce as buffer,pJ as callbacks,J as cast,UI as ceil,Br as clipByValue,Nn as clone,Xn as complex,lt as concat,WI as concat1d,KI as concat2d,VI as concat3d,jI as concat4d,lM as constraints,Md as conv1d,Yn as conv2d,Fd as conv2dTranspose,Ed as conv3d,HI as conv3dTranspose,Wde as copyRegisteredKernels,Wl as cos,Rd as cosh,Wb as cosineWindow,Ld as cumsum,mn as customGrad,DE as data,qI as denseBincount,SI as deprecationWarn,XI as depthToSpace,uu as depthwiseConv2d,fJ as deregisterOp,oi as device_util,u5 as diag,YI as dilation2d,Iye as disableDeprecationWarnings,Fe as dispose,Cye as disposeVariables,ce as div,QI as divNoNan,h5 as dot,y2 as dropout,ZI as einsum,lu as elu,kye as enableDebugMode,Tye as enableProdMode,x2 as enclosingPowerOfTwo,qo as engine,$ as env,Vr as equal,JI as erf,mr as exp,Nr as expandDims,eC as expm1,Wc as eye,Jl as fft,Aa as fill,Nye as findBackend,Dye as findBackendFactory,pu as floor,Ad as floorDiv,eO as forceHalfFloat,Ls as fused,ii as gather,g2 as gatherND,_b as gather_util,_ye as getBackend,Hk as getGradient,yd as getKernel,cb as getKernelsForBackend,Ade as getThreadsCount,r_ as gpgpu_util,z5 as grad,G5 as grads,nr as greater,Qo as greaterEqual,rl as ifft,Kl as imag,Fn as image,BBe as inTopKAsync,NM as initializers,av as input,Kr as io,Zd as irfft,D5 as isFinite,M5 as isInf,tC as isNaN,Vt as keep,Tr as kernel_impls,mF as layers,Vl as leakyRelu,Bd as less,Zo as lessEqual,a1 as linalg,rC as linspace,iee as loadGraphModel,IZ as loadLayersModel,nC as localResponseNormalization,$r as log,jl as log1p,H5 as logSigmoid,$d as logSoftmax,uC as logSumExp,Hr as logicalAnd,Hl as logicalNot,zd as logicalOr,s8 as logicalXor,eVe as losses,Ve as matMul,A0 as math,en as max,ql as maxPool,Gd as maxPool3d,lC as maxPoolWithArgmax,Qn as maximum,Rt as mean,_d as memory,c8 as meshgrid,dF as metrics,Kc as min,cu as minimum,pC as mirrorPad,cC as mod,TZ as model,fF as models,Vc as moments,JLe as movingAverage,R as mul,x8 as multiRNNCell,mC as multinomial,Ze as neg,PC as nextFrame,Gb as norm,li as notEqual,ou as oneHot,dr as ones,Dr as onesLike,_ as op,v8 as outerProduct,Pn as pad,_8 as pad1d,N8 as pad2d,P8 as pad3d,F8 as pad4d,$8 as pool,Mn as pow,Yl as prelu,hI as print,Ud as prod,vye as profile,W8 as rand,Q8 as randomGamma,Bb as randomNormal,Na as randomUniform,mu as range,wye as ready,tl as real,kC as reciprocal,el as registerBackend,CZ as registerCallbackConstructor,gD as registerGradient,Zi as registerKernel,dJ as registerOp,hF as regularizers,qr as relu,Kd as relu6,Aye as removeBackend,L as reshape,xr as reverse,aX as reverse1d,uX as reverse2d,pX as reverse3d,mX as reverse4d,ep as rfft,Vd as round,jd as rsqrt,me as scalar,f2 as scatterND,wd as scatter_util,Hd as selu,IC as separableConv2d,kZ as sequential,re as serialization,t6 as setBackend,Pye as setPlatform,_de as setThreadsCount,Sde as setWasmPath,wde as setWasmPaths,cw as setWebGLContext,CC as setdiff1dAsync,Dm as shared,cn as sigmoid,vC as sign,_Ke as signal,qd as sin,Xd as sinh,ze as slice,Yd as slice1d,$b as slice2d,Qd as slice3d,Hc as slice4d,Tt as slice_util,Zl as softmax,ui as softplus,Xl as spaceToBatchND,tf as sparse,Ub as sparseToDense,IKe as spectral,Ir as split,Lt as sqrt,qe as square,Jd as squaredDifference,dn as squeeze,fr as stack,du as step,SC as stridedSlice,Qb as string,pe as sub,he as sum,Ji as sumOutType,wC as tan,iu as tanh,Rr as tensor,zt as tensor1d,pi as tensor2d,xI as tensor3d,$X as tensor4d,OX as tensor5d,zX as tensor6d,Es as tensor_util,V0 as test_util,G as tidy,jr as tile,Sye as time,_C as topk,mp as train,He as transpose,tp as truncatedNormal,Ob as unique,Ude as unregisterGradient,Gde as unregisterKernel,AC as unsortedSegmentSum,Or as unstack,Kt as upcastType,b as util,U5 as valueAndGrad,W5 as valueAndGrads,NC as variable,Fb as variableGrads,Yqr as version,uee as version_converter,e6 as version_core,Lee as version_cpu,_f as version_layers,Nde as version_wasm,voe as version_webgl,Yjt as webgl,Lm as webgl_util,pK as webgpu,Ot as where,ef as whereAsync,xt as zeros,Ne as zerosLike};
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
* @license
* Copyright 2018 Google LLC. All Rights Reserved.
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
* =============================================================================
*/
/** @license See the LICENSE file. */
//# sourceMappingURL=tfjs.min.esm.js.map
