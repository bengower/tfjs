{
  "version": 3,
  "sources": ["../src/node_modules/long/src/long.js", "../src/node_modules/node-fetch/browser.js", "(disabled):util", "../src/tfjs-core/src/backends/backend.ts", "../src/tfjs-core/src/util_base.ts", "../src/tfjs-core/src/log.ts", "../src/tfjs-core/src/environment.ts", "../src/tfjs-core/src/global_util.ts", "../src/tfjs-core/src/kernel_names.ts", "../src/tfjs-core/src/kernel_registry.ts", "../src/tfjs-core/src/util.ts", "../src/tfjs-core/src/hash_util.ts", "../src/tfjs-core/src/profiler.ts", "../src/tfjs-core/src/tape.ts", "../src/tfjs-core/src/tensor_format.ts", "../src/tfjs-core/src/tensor.ts", "../src/tfjs-core/src/types.ts", "../src/tfjs-core/src/tensor_util.ts", "../src/tfjs-core/src/engine.ts", "../src/tfjs-core/src/device_util.ts", "../src/tfjs-core/src/flags.ts", "../src/tfjs-core/src/tensor_util_env.ts", "../src/tfjs-core/src/ops/operation.ts", "../src/tfjs-core/src/ops/complex.ts", "../src/tfjs-core/src/ops/tensor_ops_util.ts", "../src/tfjs-core/src/ops/tensor.ts", "../src/tfjs-core/src/io/types.ts", "../src/tfjs-core/src/io/io_utils.ts", "../src/tfjs-core/src/io/router_registry.ts", "../src/tfjs-core/src/io/indexed_db.ts", "../src/tfjs-core/src/io/local_storage.ts", "../src/tfjs-core/src/io/model_management.ts", "../src/tfjs-core/src/platforms/platform_browser.ts", "../src/tfjs-core/src/platforms/platform_node.ts", "../src/tfjs-core/src/ops/buffer.ts", "../src/tfjs-core/src/ops/cast.ts", "../src/tfjs-core/src/ops/clone.ts", "../src/tfjs-core/src/ops/print.ts", "../src/tfjs-core/src/base_side_effects.ts", "../src/tfjs-core/src/io/browser_files.ts", "../src/tfjs-core/src/io/progress.ts", "../src/tfjs-core/src/io/weights_loader.ts", "../src/tfjs-core/src/io/http.ts", "../src/tfjs-core/src/io/passthrough.ts", "../src/tfjs-core/src/io/io.ts", "../src/tfjs-core/src/ops/mat_mul.ts", "../src/tfjs-core/src/ops/one_hot.ts", "../src/tfjs-core/src/ops/transpose.ts", "../src/tfjs-core/src/ops/confusion_matrix.ts", "../src/tfjs-core/src/math.ts", "../src/tfjs-core/src/ops/tensor3d.ts", "../src/tfjs-core/src/ops/browser.ts", "../src/tfjs-core/src/ops/gather_nd_util.ts", "../src/tfjs-core/src/ops/scatter_nd_util.ts", "../src/tfjs-core/src/ops/slice_util.ts", "../src/tfjs-core/src/serialization.ts", "../src/tfjs-core/src/test_util.ts", "../src/tfjs-core/src/version.ts", "../src/tfjs-core/src/model_types.ts", "../src/tfjs-core/src/globals.ts", "../src/tfjs-core/src/ops/add.ts", "../src/tfjs-core/src/ops/floorDiv.ts", "../src/tfjs-core/src/ops/div.ts", "../src/tfjs-core/src/ops/mul.ts", "../src/tfjs-core/src/ops/abs.ts", "../src/tfjs-core/src/ops/acos.ts", "../src/tfjs-core/src/ops/acosh.ts", "../src/tfjs-core/src/ops/add_n.ts", "../src/tfjs-core/src/ops/all.ts", "../src/tfjs-core/src/ops/any.ts", "../src/tfjs-core/src/ops/arg_max.ts", "../src/tfjs-core/src/ops/arg_min.ts", "../src/tfjs-core/src/ops/asin.ts", "../src/tfjs-core/src/ops/asinh.ts", "../src/tfjs-core/src/ops/atan.ts", "../src/tfjs-core/src/ops/atan2.ts", "../src/tfjs-core/src/ops/atanh.ts", "../src/tfjs-core/src/ops/conv_util.ts", "../src/tfjs-core/src/ops/reshape.ts", "../src/tfjs-core/src/ops/avg_pool.ts", "../src/tfjs-core/src/ops/avg_pool_3d.ts", "../src/tfjs-core/src/ops/concat.ts", "../src/tfjs-core/src/ops/sigmoid.ts", "../src/tfjs-core/src/ops/slice.ts", "../src/tfjs-core/src/ops/tanh.ts", "../src/tfjs-core/src/ops/basic_lstm_cell.ts", "../src/tfjs-core/src/ops/batch_to_space_nd.ts", "../src/tfjs-core/src/ops/batchnorm_util.ts", "../src/tfjs-core/src/ops/batchnorm.ts", "../src/tfjs-core/src/ops/batchnorm2d.ts", "../src/tfjs-core/src/ops/batchnorm3d.ts", "../src/tfjs-core/src/ops/batchnorm4d.ts", "../src/tfjs-core/src/ops/bincount.ts", "../src/tfjs-core/src/ops/broadcast_args.ts", "../src/tfjs-core/src/ops/broadcast_to.ts", "../src/tfjs-core/src/ops/ceil.ts", "../src/tfjs-core/src/ops/clip_by_value.ts", "../src/tfjs-core/src/ops/concat_1d.ts", "../src/tfjs-core/src/ops/concat_2d.ts", "../src/tfjs-core/src/ops/concat_3d.ts", "../src/tfjs-core/src/ops/concat_4d.ts", "../src/tfjs-core/src/ops/conv2d.ts", "../src/tfjs-core/src/ops/conv1d.ts", "../src/tfjs-core/src/ops/conv2d_backprop_input.ts", "../src/tfjs-core/src/ops/conv2d_transpose.ts", "../src/tfjs-core/src/ops/conv3d.ts", "../src/tfjs-core/src/ops/conv3d_backprop_input.ts", "../src/tfjs-core/src/ops/conv3d_transpose.ts", "../src/tfjs-core/src/ops/cos.ts", "../src/tfjs-core/src/ops/cosh.ts", "../src/tfjs-core/src/ops/cumsum.ts", "../src/tfjs-core/src/ops/dense_bincount.ts", "../src/tfjs-core/src/ops/depth_to_space.ts", "../src/tfjs-core/src/ops/depthwise_conv2d.ts", "../src/tfjs-core/src/ops/diag.ts", "../src/tfjs-core/src/ops/dilation2d.ts", "../src/tfjs-core/src/ops/broadcast_util.ts", "../src/tfjs-core/src/ops/equal.ts", "../src/tfjs-core/src/ops/where.ts", "../src/tfjs-core/src/ops/zeros_like.ts", "../src/tfjs-core/src/ops/div_no_nan.ts", "../src/tfjs-core/src/ops/dot.ts", "../src/tfjs-core/src/ops/einsum.ts", "../src/tfjs-core/src/ops/elu.ts", "../src/tfjs-core/src/ops/erf.ts", "../src/tfjs-core/src/ops/exp.ts", "../src/tfjs-core/src/ops/expand_dims.ts", "../src/tfjs-core/src/ops/expm1.ts", "../src/tfjs-core/src/ops/tile.ts", "../src/tfjs-core/src/ops/eye.ts", "../src/tfjs-core/src/ops/fill.ts", "../src/tfjs-core/src/ops/floor.ts", "../src/tfjs-core/src/ops/gather.ts", "../src/tfjs-core/src/ops/greater.ts", "../src/tfjs-core/src/ops/greater_equal.ts", "../src/tfjs-core/src/ops/imag.ts", "../src/tfjs-core/src/ops/is_finite.ts", "../src/tfjs-core/src/ops/is_inf.ts", "../src/tfjs-core/src/ops/is_nan.ts", "../src/tfjs-core/src/ops/leaky_relu.ts", "../src/tfjs-core/src/ops/less.ts", "../src/tfjs-core/src/ops/less_equal.ts", "../src/tfjs-core/src/ops/linspace.ts", "../src/tfjs-core/src/ops/local_response_normalization.ts", "../src/tfjs-core/src/ops/log.ts", "../src/tfjs-core/src/ops/log1p.ts", "../src/tfjs-core/src/gradients.ts", "../src/tfjs-core/src/ops/neg.ts", "../src/tfjs-core/src/ops/softplus.ts", "../src/tfjs-core/src/ops/log_sigmoid.ts", "../src/tfjs-core/src/ops/max.ts", "../src/tfjs-core/src/ops/sub.ts", "../src/tfjs-core/src/ops/sum.ts", "../src/tfjs-core/src/ops/log_softmax.ts", "../src/tfjs-core/src/ops/axis_util.ts", "../src/tfjs-core/src/ops/log_sum_exp.ts", "../src/tfjs-core/src/ops/logical_and.ts", "../src/tfjs-core/src/ops/logical_not.ts", "../src/tfjs-core/src/ops/logical_or.ts", "../src/tfjs-core/src/ops/logical_xor.ts", "../src/tfjs-core/src/ops/max_pool.ts", "../src/tfjs-core/src/ops/max_pool_3d.ts", "../src/tfjs-core/src/ops/max_pool_with_argmax.ts", "../src/tfjs-core/src/ops/maximum.ts", "../src/tfjs-core/src/ops/mean.ts", "../src/tfjs-core/src/ops/zeros.ts", "../src/tfjs-core/src/ops/ones.ts", "../src/tfjs-core/src/ops/meshgrid.ts", "../src/tfjs-core/src/ops/min.ts", "../src/tfjs-core/src/ops/minimum.ts", "../src/tfjs-core/src/ops/mirror_pad.ts", "../src/tfjs-core/src/ops/mod.ts", "../src/tfjs-core/src/ops/square.ts", "../src/tfjs-core/src/ops/moments.ts", "../src/tfjs-core/src/ops/multi_rnn_cell.ts", "../src/tfjs-core/src/ops/multinomial.ts", "../src/tfjs-core/src/ops/not_equal.ts", "../src/tfjs-core/src/ops/ones_like.ts", "../src/tfjs-core/src/ops/outer_product.ts", "../src/tfjs-core/src/ops/pad.ts", "../src/tfjs-core/src/ops/pad1d.ts", "../src/tfjs-core/src/ops/pad2d.ts", "../src/tfjs-core/src/ops/pad3d.ts", "../src/tfjs-core/src/ops/pad4d.ts", "../src/tfjs-core/src/ops/space_to_batch_nd.ts", "../src/tfjs-core/src/ops/pool.ts", "../src/tfjs-core/src/ops/pow.ts", "../src/tfjs-core/src/ops/prelu.ts", "../src/tfjs-core/src/ops/prod.ts", "../src/tfjs-core/src/ops/rand.ts", "../src/tfjs-core/src/ops/rand_util.ts", "../src/tfjs-core/src/ops/random_gamma.ts", "../src/tfjs-core/src/ops/random_normal.ts", "../src/tfjs-core/src/ops/random_uniform.ts", "../src/tfjs-core/src/ops/range.ts", "../src/tfjs-core/src/ops/real.ts", "../src/tfjs-core/src/ops/reciprocal.ts", "../src/tfjs-core/src/ops/relu.ts", "../src/tfjs-core/src/ops/relu6.ts", "../src/tfjs-core/src/ops/reverse.ts", "../src/tfjs-core/src/ops/reverse_1d.ts", "../src/tfjs-core/src/ops/reverse_2d.ts", "../src/tfjs-core/src/ops/reverse_3d.ts", "../src/tfjs-core/src/ops/reverse_4d.ts", "../src/tfjs-core/src/ops/round.ts", "../src/tfjs-core/src/ops/rsqrt.ts", "../src/tfjs-core/src/ops/scalar.ts", "../src/tfjs-core/src/ops/selu.ts", "../src/tfjs-core/src/ops/separable_conv2d.ts", "../src/tfjs-core/src/ops/setdiff1d_async.ts", "../src/tfjs-core/src/ops/sign.ts", "../src/tfjs-core/src/ops/sin.ts", "../src/tfjs-core/src/ops/sinh.ts", "../src/tfjs-core/src/ops/slice1d.ts", "../src/tfjs-core/src/ops/slice2d.ts", "../src/tfjs-core/src/ops/slice3d.ts", "../src/tfjs-core/src/ops/slice4d.ts", "../src/tfjs-core/src/ops/softmax.ts", "../src/tfjs-core/src/ops/spectral/fft.ts", "../src/tfjs-core/src/ops/spectral/ifft.ts", "../src/tfjs-core/src/ops/spectral/irfft.ts", "../src/tfjs-core/src/ops/split.ts", "../src/tfjs-core/src/ops/spectral/rfft.ts", "../src/tfjs-core/src/ops/sqrt.ts", "../src/tfjs-core/src/ops/squared_difference.ts", "../src/tfjs-core/src/ops/squeeze.ts", "../src/tfjs-core/src/ops/stack.ts", "../src/tfjs-core/src/ops/step.ts", "../src/tfjs-core/src/ops/strided_slice.ts", "../src/tfjs-core/src/ops/tan.ts", "../src/tfjs-core/src/ops/tensor1d.ts", "../src/tfjs-core/src/ops/tensor2d.ts", "../src/tfjs-core/src/ops/tensor4d.ts", "../src/tfjs-core/src/ops/tensor5d.ts", "../src/tfjs-core/src/ops/tensor6d.ts", "../src/tfjs-core/src/ops/topk.ts", "../src/tfjs-core/src/ops/truncated_normal.ts", "../src/tfjs-core/src/ops/unique.ts", "../src/tfjs-core/src/ops/unsorted_segment_sum.ts", "../src/tfjs-core/src/ops/unstack.ts", "../src/tfjs-core/src/ops/variable.ts", "../src/tfjs-core/src/backends/where_impl.ts", "../src/tfjs-core/src/ops/where_async.ts", "../src/tfjs-core/src/ops/boolean_mask.ts", "../src/tfjs-core/src/ops/norm.ts", "../src/tfjs-core/src/ops/moving_average.ts", "../src/tfjs-core/src/ops/scatter_nd.ts", "../src/tfjs-core/src/ops/sparse_to_dense_util.ts", "../src/tfjs-core/src/ops/sparse_to_dense.ts", "../src/tfjs-core/src/ops/gather_nd.ts", "../src/tfjs-core/src/ops/dropout_util.ts", "../src/tfjs-core/src/ops/dropout.ts", "../src/tfjs-core/src/ops/signal_ops_util.ts", "../src/tfjs-core/src/ops/in_top_k.ts", "../src/tfjs-core/src/ops/conv2d_backprop_filter.ts", "../src/tfjs-core/src/ops/fused_util.ts", "../src/tfjs-core/src/ops/fused/conv2d.ts", "../src/tfjs-core/src/ops/depthwise_conv2d_native_backprop_filter.ts", "../src/tfjs-core/src/ops/depthwise_conv2d_native_backprop_input.ts", "../src/tfjs-core/src/ops/fused/depthwise_conv2d.ts", "../src/tfjs-core/src/ops/fused/mat_mul.ts", "../src/tfjs-core/src/ops/fused_types.ts", "../src/tfjs-core/src/ops/fused_ops.ts", "../src/tfjs-core/src/ops/signal/hamming_window.ts", "../src/tfjs-core/src/ops/signal/hann_window.ts", "../src/tfjs-core/src/ops/signal/frame.ts", "../src/tfjs-core/src/ops/signal/stft.ts", "../src/tfjs-core/src/ops/image/crop_and_resize.ts", "../src/tfjs-core/src/ops/image/flip_left_right.ts", "../src/tfjs-core/src/ops/image/grayscale_to_rgb.ts", "../src/tfjs-core/src/ops/image/rotate_with_offset.ts", "../src/tfjs-core/src/ops/nonmax_util.ts", "../src/tfjs-core/src/ops/image/non_max_suppression.ts", "../src/tfjs-core/src/backends/non_max_suppression_util.ts", "../src/tfjs-core/src/backends/non_max_suppression_impl.ts", "../src/tfjs-core/src/ops/image/non_max_suppression_async.ts", "../src/tfjs-core/src/ops/image/non_max_suppression_with_score.ts", "../src/tfjs-core/src/ops/image/non_max_suppression_with_score_async.ts", "../src/tfjs-core/src/ops/image/non_max_suppression_padded.ts", "../src/tfjs-core/src/ops/image/non_max_suppression_padded_async.ts", "../src/tfjs-core/src/ops/image/resize_bilinear.ts", "../src/tfjs-core/src/ops/image/resize_nearest_neighbor.ts", "../src/tfjs-core/src/ops/image/threshold.ts", "../src/tfjs-core/src/ops/image/transform.ts", "../src/tfjs-core/src/ops/linalg/band_part.ts", "../src/tfjs-core/src/ops/linalg/gram_schmidt.ts", "../src/tfjs-core/src/ops/linalg/qr.ts", "../src/tfjs-core/src/ops/loss_ops_utils.ts", "../src/tfjs-core/src/ops/losses/compute_weighted_loss.ts", "../src/tfjs-core/src/ops/losses/absolute_difference.ts", "../src/tfjs-core/src/ops/losses/cosine_distance.ts", "../src/tfjs-core/src/ops/losses/hinge_loss.ts", "../src/tfjs-core/src/ops/losses/huber_loss.ts", "../src/tfjs-core/src/ops/losses/log_loss.ts", "../src/tfjs-core/src/ops/losses/mean_squared_error.ts", "../src/tfjs-core/src/ops/losses/sigmoid_cross_entropy.ts", "../src/tfjs-core/src/ops/losses/softmax_cross_entropy.ts", "../src/tfjs-core/src/ops/sparse/sparse_fill_empty_rows.ts", "../src/tfjs-core/src/ops/sparse/sparse_reshape.ts", "../src/tfjs-core/src/ops/sparse/sparse_segment_mean.ts", "../src/tfjs-core/src/ops/sparse/sparse_segment_sum.ts", "../src/tfjs-core/src/ops/string/string_n_grams.ts", "../src/tfjs-core/src/ops/string/string_split.ts", "../src/tfjs-core/src/ops/string/string_to_hash_bucket_fast.ts", "../src/tfjs-core/src/ops/ops.ts", "../src/tfjs-core/src/optimizers/optimizer.ts", "../src/tfjs-core/src/optimizers/adadelta_optimizer.ts", "../src/tfjs-core/src/optimizers/adagrad_optimizer.ts", "../src/tfjs-core/src/optimizers/adam_optimizer.ts", "../src/tfjs-core/src/optimizers/adamax_optimizer.ts", "../src/tfjs-core/src/optimizers/sgd_optimizer.ts", "../src/tfjs-core/src/optimizers/momentum_optimizer.ts", "../src/tfjs-core/src/optimizers/rmsprop_optimizer.ts", "../src/tfjs-core/src/tensor_types.ts", "../src/tfjs-core/src/optimizers/optimizer_constructors.ts", "../src/tfjs-core/src/train.ts", "../src/tfjs-core/src/platforms/platform.ts", "../src/tfjs-core/src/browser_util.ts", "../src/tfjs-core/src/backends/backend_util.ts", "../src/tfjs-core/src/ops/concat_util.ts", "../src/tfjs-core/src/ops/reduce_util.ts", "../src/tfjs-core/src/ops/rotate_util.ts", "../src/tfjs-core/src/ops/array_ops_util.ts", "../src/tfjs-core/src/ops/selu_util.ts", "../src/tfjs-core/src/ops/erf_util.ts", "../src/tfjs-core/src/backends/complex_util.ts", "../src/tfjs-core/src/backends/einsum_util.ts", "../src/tfjs-core/src/ops/split_util.ts", "../src/tfjs-core/src/ops/segment_util.ts", "../src/tfjs-core/src/backends/kernel_impls.ts", "../src/tfjs-core/src/base.ts", "../src/tfjs-core/src/index.ts", "../src/tfjs-backend-webgpu/src/flags_webgpu.ts", "../src/tfjs-backend-webgpu/src/shader_util.ts", "../src/tfjs-backend-webgpu/src/shader_preprocessor_wgsl.ts", "../src/tfjs-backend-webgpu/src/webgpu_util.ts", "../src/tfjs-backend-webgpu/src/constants.ts", "../src/tfjs-backend-webgpu/src/kernels/binary_op_util.ts", "../src/tfjs-backend-webgpu/src/kernels/unary_op_util.ts", "../src/tfjs-backend-webgpu/src/kernels/activation_util.ts", "../src/tfjs-backend-webgpu/src/glsl_version.ts", "../src/tfjs-backend-webgpu/src/shader_preprocessor.ts", "../src/tfjs-backend-webgpu/src/kernels/webgpu_program.ts", "../src/tfjs-backend-webgpu/src/kernels/matmul_packed_vec4_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/matmul_packed_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/matmul_small_output_size_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Reshape.ts", "../src/tfjs-backend-webgpu/src/kernels/BatchMatMul_impl.ts", "../src/tfjs-backend-webgpu/src/kernels/_FusedMatMul.ts", "../src/tfjs-backend-webgpu/src/kernels/binary_op_complex_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/binary_op_shared_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/binary_op_vec4_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/binary_op_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/binary_ops.ts", "../src/tfjs-backend-webgpu/src/kernels/Identity.ts", "../src/tfjs-backend-webgpu/src/kernels/Complex.ts", "../src/tfjs-backend-webgpu/src/kernels/unary_op_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernel_utils/kernel_funcs_utils.ts", "../src/tfjs-backend-cpu/src/shared.ts", "../src/tfjs-backend-cpu/src/cpu_util.ts", "../src/tfjs-backend-cpu/src/kernels/Abs.ts", "../src/tfjs-backend-cpu/src/utils/binary_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Complex.ts", "../src/tfjs-backend-cpu/src/utils/zeros_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Identity.ts", "../src/tfjs-backend-cpu/src/kernels/Real.ts", "../src/tfjs-backend-cpu/src/kernels/Cast.ts", "../src/tfjs-backend-cpu/src/utils/binary_utils.ts", "../src/tfjs-backend-cpu/src/kernels/Add.ts", "../src/tfjs-backend-cpu/src/kernels/Bincount_impl.ts", "../src/tfjs-backend-cpu/src/utils/unary_impl.ts", "../src/tfjs-backend-cpu/src/utils/unary_utils.ts", "../src/tfjs-backend-cpu/src/kernels/Ceil.ts", "../src/tfjs-backend-cpu/src/kernels/Concat_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Equal.ts", "../src/tfjs-backend-cpu/src/kernels/Exp.ts", "../src/tfjs-backend-cpu/src/kernels/Expm1.ts", "../src/tfjs-backend-cpu/src/kernels/Floor.ts", "../src/tfjs-backend-cpu/src/kernels/GatherNd_Impl.ts", "../src/tfjs-backend-cpu/src/kernels/GatherV2_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Greater.ts", "../src/tfjs-backend-cpu/src/kernels/GreaterEqual.ts", "../src/tfjs-backend-cpu/src/kernels/Less.ts", "../src/tfjs-backend-cpu/src/kernels/LessEqual.ts", "../src/tfjs-backend-cpu/src/kernels/LinSpace_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Log.ts", "../src/tfjs-backend-cpu/src/kernels/Max_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Maximum.ts", "../src/tfjs-backend-cpu/src/kernels/Minimum.ts", "../src/tfjs-backend-cpu/src/kernels/Multiply.ts", "../src/tfjs-backend-cpu/src/kernels/Neg.ts", "../src/tfjs-backend-cpu/src/kernels/NotEqual.ts", "../src/tfjs-backend-cpu/src/kernels/Transpose_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Transpose.ts", "../src/tfjs-backend-cpu/src/kernels/Prod.ts", "../src/tfjs-backend-cpu/src/kernels/Range_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Rsqrt.ts", "../src/tfjs-backend-cpu/src/kernels/Sigmoid.ts", "../src/tfjs-backend-cpu/src/kernels/Slice.ts", "../src/tfjs-backend-cpu/src/kernels/SparseFillEmptyRows_impl.ts", "../src/tfjs-backend-cpu/src/kernels/SparseReshape_impl.ts", "../src/tfjs-backend-cpu/src/kernels/SparseSegmentReduction_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Sqrt.ts", "../src/tfjs-backend-cpu/src/kernels/SquaredDifference.ts", "../src/tfjs-backend-cpu/src/kernels/StridedSlice_impl.ts", "../src/tfjs-backend-cpu/src/kernels/StringNGrams_impl.ts", "../src/tfjs-backend-cpu/src/kernels/StringSplit_impl.ts", "../src/tfjs-backend-cpu/src/kernels/StringToHashBucketFast_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Sub.ts", "../src/tfjs-backend-cpu/src/kernels/Tile_impl.ts", "../src/tfjs-backend-cpu/src/kernels/TopK_impl.ts", "../src/tfjs-backend-cpu/src/kernels/Unique_impl.ts", "../src/tfjs-backend-cpu/src/utils/binary_types.ts", "../src/tfjs-backend-webgpu/src/kernel_utils/shared.ts", "../src/tfjs-backend-webgpu/src/kernels/Abs.ts", "../src/tfjs-backend-webgpu/src/kernels/Add.ts", "../src/tfjs-backend-webgpu/src/kernels/addn_packed_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/AddN.ts", "../src/tfjs-backend-webgpu/src/kernels/argminmax_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/transpose_shared_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/transpose_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Transpose.ts", "../src/tfjs-backend-webgpu/src/kernels/ArgMax.ts", "../src/tfjs-backend-webgpu/src/kernels/ArgMin.ts", "../src/tfjs-backend-webgpu/src/kernels/pool2d_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/pool_filtersizeone_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/AvgPool.ts", "../src/tfjs-backend-webgpu/src/kernels/BatchMatMul.ts", "../src/tfjs-backend-webgpu/src/kernels/slice_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Slice.ts", "../src/tfjs-backend-webgpu/src/kernels/BatchToSpaceND.ts", "../src/tfjs-backend-webgpu/src/kernels/NotEqual.ts", "../src/tfjs-backend-webgpu/src/kernels/Real.ts", "../src/tfjs-backend-webgpu/src/kernel_utils/int.ts", "../src/tfjs-backend-webgpu/src/kernels/Cast.ts", "../src/tfjs-backend-webgpu/src/kernels/Ceil.ts", "../src/tfjs-backend-webgpu/src/kernels/clip_vec4_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/clip_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/ClipByValue.ts", "../src/tfjs-backend-webgpu/src/kernels/concat_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Imag.ts", "../src/tfjs-backend-webgpu/src/kernels/Concat_impl.ts", "../src/tfjs-backend-webgpu/src/kernels/Concat.ts", "../src/tfjs-backend-webgpu/src/kernels/im2col_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Conv2D_impl.ts", "../src/tfjs-backend-webgpu/src/kernels/conv2d_mm_vec4_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/conv2d_mm_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/conv2d_naive_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Conv2D.ts", "../src/tfjs-backend-webgpu/src/kernels/conv_backprop_mm_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/conv_backprop_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Conv2DBackpropInput.ts", "../src/tfjs-backend-webgpu/src/kernels/crop_and_resize_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/CropAndResize.ts", "../src/tfjs-backend-webgpu/src/kernels/depthwise_conv2d_3x3_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/depthwise_conv2d_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/DepthwiseConv2dNative.ts", "../src/tfjs-backend-webgpu/src/kernels/Multiply.ts", "../src/tfjs-backend-webgpu/src/kernels/reduce_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernel_utils/reduce.ts", "../src/tfjs-backend-webgpu/src/kernels/Sum.ts", "../src/tfjs-backend-webgpu/src/kernels/Einsum.ts", "../src/tfjs-backend-webgpu/src/kernels/Elu.ts", "../src/tfjs-backend-webgpu/src/kernels/Equal.ts", "../src/tfjs-backend-webgpu/src/kernels/Exp.ts", "../src/tfjs-backend-webgpu/src/kernels/ExpandDims.ts", "../src/tfjs-backend-webgpu/src/kernels/Expm1.ts", "../src/tfjs-backend-webgpu/src/kernels/fill_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Fill.ts", "../src/tfjs-backend-webgpu/src/kernels/Floor.ts", "../src/tfjs-backend-webgpu/src/kernels/FloorDiv.ts", "../src/tfjs-backend-webgpu/src/kernels/FromPixelsExternalImage.ts", "../src/tfjs-backend-webgpu/src/kernels/FromPixels.ts", "../src/tfjs-backend-webgpu/src/kernels/batchnorm_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/FusedBatchNorm.ts", "../src/tfjs-backend-webgpu/src/kernels/FusedConv2D.ts", "../src/tfjs-backend-webgpu/src/kernels/FusedDepthwiseConv2D.ts", "../src/tfjs-backend-webgpu/src/kernels/gather_nd_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/GatherNd.ts", "../src/tfjs-backend-webgpu/src/kernels/gather_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/GatherV2.ts", "../src/tfjs-backend-webgpu/src/kernels/Greater.ts", "../src/tfjs-backend-webgpu/src/kernels/GreaterEqual.ts", "../src/tfjs-backend-webgpu/src/kernels/Less.ts", "../src/tfjs-backend-webgpu/src/kernels/LessEqual.ts", "../src/tfjs-backend-webgpu/src/kernels/Log.ts", "../src/tfjs-backend-webgpu/src/kernels/LogicalAnd.ts", "../src/tfjs-backend-webgpu/src/kernels/Max.ts", "../src/tfjs-backend-webgpu/src/kernels/Maximum.ts", "../src/tfjs-backend-webgpu/src/kernels/MaxPool.ts", "../src/tfjs-backend-webgpu/src/kernels/Mean.ts", "../src/tfjs-backend-webgpu/src/kernels/Min.ts", "../src/tfjs-backend-webgpu/src/kernels/Minimum.ts", "../src/tfjs-backend-webgpu/src/kernels/mirror_pad_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/MirrorPad.ts", "../src/tfjs-backend-webgpu/src/kernels/Neg.ts", "../src/tfjs-backend-webgpu/src/kernels/NonMaxSuppressionV3.ts", "../src/tfjs-backend-webgpu/src/kernels/NonMaxSuppressionV5.ts", "../src/tfjs-backend-webgpu/src/kernels/ZerosLike.ts", "../src/tfjs-backend-webgpu/src/kernels/OnesLike.ts", "../src/tfjs-backend-webgpu/src/kernels/Pack.ts", "../src/tfjs-backend-webgpu/src/kernels/pad_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/PadV2.ts", "../src/tfjs-backend-webgpu/src/kernels/Pow.ts", "../src/tfjs-backend-webgpu/src/kernels/Prelu.ts", "../src/tfjs-backend-webgpu/src/kernels/Prod.ts", "../src/tfjs-backend-webgpu/src/kernels/Range.ts", "../src/tfjs-backend-webgpu/src/kernels/RealDiv.ts", "../src/tfjs-backend-webgpu/src/kernels/Relu.ts", "../src/tfjs-backend-webgpu/src/kernels/Relu6.ts", "../src/tfjs-backend-webgpu/src/kernels/resize_bilinear_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/ResizeBilinear.ts", "../src/tfjs-backend-webgpu/src/kernels/resize_nearest_neighbor_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/ResizeNearestNeighbor.ts", "../src/tfjs-backend-webgpu/src/kernels/Rsqrt.ts", "../src/tfjs-backend-webgpu/src/kernels/select_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Select.ts", "../src/tfjs-backend-webgpu/src/kernels/Sigmoid.ts", "../src/tfjs-backend-webgpu/src/kernels/Sub.ts", "../src/tfjs-backend-webgpu/src/kernels/Softmax.ts", "../src/tfjs-backend-webgpu/src/kernels/SpaceToBatchND.ts", "../src/tfjs-backend-webgpu/src/kernels/Sqrt.ts", "../src/tfjs-backend-webgpu/src/kernels/Square.ts", "../src/tfjs-backend-webgpu/src/kernels/SquaredDifference.ts", "../src/tfjs-backend-webgpu/src/kernels/strided_slice_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/StridedSlice.ts", "../src/tfjs-backend-webgpu/src/kernels/StringNGrams.ts", "../src/tfjs-backend-webgpu/src/kernels/Tanh.ts", "../src/tfjs-backend-webgpu/src/kernels/tile_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Tile.ts", "../src/tfjs-backend-webgpu/src/kernels/transform_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/Transform.ts", "../src/tfjs-backend-webgpu/src/kernels/Unpack.ts", "../src/tfjs-backend-webgpu/src/register_all_kernels.ts", "../node_modules/.pnpm/@webgpu+glslang@0.0.12/node_modules/@webgpu/glslang/dist/web-devel/glslang.onefile.js", "../src/tfjs-backend-webgpu/src/buffer_manager.ts", "../src/tfjs-backend-webgpu/src/kernels/FromPixels_utils/from_pixels_webgpu.ts", "../src/tfjs-backend-webgpu/src/kernels/FromPixels_utils/from_pixels_import_webgpu.ts", "../src/tfjs-backend-webgpu/src/backend_webgpu.ts", "../src/tfjs-backend-webgpu/src/webgpu.ts", "../src/tfjs-backend-webgpu/src/index.ts"],
  "sourcesContent": ["module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n", "", "", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Backend, DataId} from '../tensor';\nimport {BackendValues, DataType} from '../types';\n\nexport const EPSILON_FLOAT32 = 1e-7;\nexport const EPSILON_FLOAT16 = 1e-4;\n\n// Required information for all backends.\nexport interface BackendTimingInfo {\n  kernelMs: number|{error: string};\n  getExtraProfileInfo?(): string;  // a field for additional timing information\n                                   // e.g. packing / unpacking for WebGL backend\n}\n\nexport interface TensorStorage {\n  read(dataId: DataId): Promise<BackendValues>;\n  readSync(dataId: DataId): BackendValues;\n  disposeData(dataId: DataId, force?: boolean): boolean;\n  write(values: BackendValues, shape: number[], dtype: DataType): DataId;\n  move(\n      dataId: DataId, values: BackendValues, shape: number[], dtype: DataType,\n      refCount: number): void;\n  memory(): {unreliable: boolean;};  // Backend-specific information.\n  /** Returns number of data ids currently in the storage. */\n  numDataIds(): number;\n  refCount(dataId: DataId): number;\n}\n\n/** Convenient class for storing tensor-related data. */\nexport class DataStorage<T> {\n  private data = new WeakMap<DataId, T>();\n  private dataIdsCount = 0;\n\n  constructor(private backend: KernelBackend, private dataMover: DataMover) {}\n\n  get(dataId: DataId) {\n    if (!this.data.has(dataId)) {\n      this.dataMover.moveData(this.backend, dataId);\n    }\n    return this.data.get(dataId);\n  }\n\n  set(dataId: DataId, value: T): void {\n    this.dataIdsCount++;\n    this.data.set(dataId, value);\n  }\n\n  has(dataId: DataId): boolean {\n    return this.data.has(dataId);\n  }\n\n  delete(dataId: DataId): boolean {\n    this.dataIdsCount--;\n    return this.data.delete(dataId);\n  }\n\n  numDataIds(): number {\n    return this.dataIdsCount;\n  }\n}\n\nexport interface DataMover {\n  /**\n   * To be called by backends whenever they see a dataId that they don't own.\n   * Upon calling this method, the mover will fetch the tensor from another\n   * backend and register it with the current active backend.\n   */\n  moveData(backend: KernelBackend, dataId: DataId): void;\n}\n\nexport interface BackendTimer {\n  // check if backend timer is available\n  timerAvailable(): boolean;\n  time(f: () => void): Promise<BackendTimingInfo>;\n}\n\n/**\n * The interface that defines the kernels that should be implemented when\n * adding a new backend. New backends don't need to implement every one of the\n * methods, this can be done gradually (throw an error for unimplemented\n * methods).\n */\nexport class KernelBackend implements TensorStorage, Backend, BackendTimer {\n  refCount(dataId: DataId): number {\n    return notYetImplemented('refCount');\n  }\n  incRef(dataId: DataId): void {\n    return notYetImplemented('incRef');\n  }\n  timerAvailable(): boolean {\n    return true;\n  }\n  time(f: () => void): Promise<BackendTimingInfo> {\n    return notYetImplemented('time');\n  }\n  read(dataId: object): Promise<BackendValues> {\n    return notYetImplemented('read');\n  }\n  readSync(dataId: object): BackendValues {\n    return notYetImplemented('readSync');\n  }\n  numDataIds(): number {\n    return notYetImplemented('numDataIds');\n  }\n  disposeData(dataId: object, force?: boolean): boolean {\n    return notYetImplemented('disposeData');\n  }\n  write(values: BackendValues, shape: number[], dtype: DataType): DataId {\n    return notYetImplemented('write');\n  }\n  move(\n      dataId: DataId, values: BackendValues, shape: number[], dtype: DataType,\n      refCount: number): void {\n    return notYetImplemented('move');\n  }\n  memory(): {unreliable: boolean; reasons?: string[]} {\n    return notYetImplemented('memory');\n  }\n  /** Returns the highest precision for floats in bits (e.g. 16 or 32) */\n  floatPrecision(): 16|32 {\n    return notYetImplemented('floatPrecision');\n  }\n  /** Returns the smallest representable number.  */\n  epsilon(): number {\n    return this.floatPrecision() === 32 ? EPSILON_FLOAT32 : EPSILON_FLOAT16;\n  }\n  dispose(): void {\n    return notYetImplemented('dispose');\n  }\n}\n\nfunction notYetImplemented(kernelName: string): never {\n  throw new Error(\n      `'${kernelName}' not yet implemented or not found in the registry. ` +\n      `This kernel may not be supported by the tfjs backend you have chosen`);\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, DataTypeMap, FlatVector, NumericDataType, RecursiveArray, TensorLike, TypedArray} from './types';\n\n/**\n * Shuffles the array in-place using Fisher-Yates algorithm.\n *\n * ```js\n * const a = [1, 2, 3, 4, 5];\n * tf.util.shuffle(a);\n * console.log(a);\n * ```\n *\n * @param array The array to shuffle in-place.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\n// tslint:disable-next-line:no-any\nexport function shuffle(array: any[]|Uint32Array|Int32Array|\n                        Float32Array): void {\n  let counter = array.length;\n  let index = 0;\n  // While there are elements in the array\n  while (counter > 0) {\n    // Pick a random index\n    index = (Math.random() * counter) | 0;\n    // Decrease counter by 1\n    counter--;\n    // And swap the last element with it\n    swap(array, counter, index);\n  }\n}\n\n/**\n * Shuffles two arrays in-place the same way using Fisher-Yates algorithm.\n *\n * ```js\n * const a = [1,2,3,4,5];\n * const b = [11,22,33,44,55];\n * tf.util.shuffleCombo(a, b);\n * console.log(a, b);\n * ```\n *\n * @param array The first array to shuffle in-place.\n * @param array2 The second array to shuffle in-place with the same permutation\n *     as the first array.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function shuffleCombo(\n    // tslint:disable-next-line:no-any\n    array: any[]|Uint32Array|Int32Array|Float32Array,\n    // tslint:disable-next-line:no-any\n    array2: any[]|Uint32Array|Int32Array|Float32Array): void {\n  if (array.length !== array2.length) {\n    throw new Error(\n        `Array sizes must match to be shuffled together ` +\n        `First array length was ${array.length}` +\n        `Second array length was ${array2.length}`);\n  }\n  let counter = array.length;\n  let index = 0;\n  // While there are elements in the array\n  while (counter > 0) {\n    // Pick a random index\n    index = (Math.random() * counter) | 0;\n    // Decrease counter by 1\n    counter--;\n    // And swap the last element of each array with it\n    swap(array, counter, index);\n    swap(array2, counter, index);\n  }\n}\n\n/** Clamps a value to a specified range. */\nexport function clamp(min: number, x: number, max: number): number {\n  return Math.max(min, Math.min(x, max));\n}\n\nexport function nearestLargerEven(val: number): number {\n  return val % 2 === 0 ? val : val + 1;\n}\n\nexport function swap<T>(\n    object: {[index: number]: T}, left: number, right: number) {\n  const temp = object[left];\n  object[left] = object[right];\n  object[right] = temp;\n}\n\nexport function sum(arr: number[]): number {\n  let sum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    sum += arr[i];\n  }\n  return sum;\n}\n\n/**\n * Returns a sample from a uniform [a, b) distribution.\n *\n * @param a The minimum support (inclusive).\n * @param b The maximum support (exclusive).\n * @return A pseudorandom number on the half-open interval [a,b).\n */\nexport function randUniform(a: number, b: number) {\n  const r = Math.random();\n  return (b * r) + (1 - r) * a;\n}\n\n/** Returns the squared Euclidean distance between two vectors. */\nexport function distSquared(a: FlatVector, b: FlatVector): number {\n  let result = 0;\n  for (let i = 0; i < a.length; i++) {\n    const diff = Number(a[i]) - Number(b[i]);\n    result += diff * diff;\n  }\n  return result;\n}\n\n/**\n * Asserts that the expression is true. Otherwise throws an error with the\n * provided message.\n *\n * ```js\n * const x = 2;\n * tf.util.assert(x === 2, 'x is not 2');\n * ```\n *\n * @param expr The expression to assert (as a boolean).\n * @param msg A function that returns the message to report when throwing an\n *     error. We use a function for performance reasons.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function assert(expr: boolean, msg: () => string) {\n  if (!expr) {\n    throw new Error(typeof msg === 'string' ? msg : msg());\n  }\n}\n\nexport function assertShapesMatch(\n    shapeA: number[], shapeB: number[], errorMessagePrefix = ''): void {\n  assert(\n      arraysEqual(shapeA, shapeB),\n      () => errorMessagePrefix + ` Shapes ${shapeA} and ${shapeB} must match`);\n}\n\nexport function assertNonNull(a: TensorLike): void {\n  assert(\n      a != null,\n      () => `The input to the tensor constructor must be a non-null value.`);\n}\n\n// NOTE: We explicitly type out what T extends instead of any so that\n// util.flatten on a nested array of number doesn't try to infer T as a\n// number[][], causing us to explicitly type util.flatten<number>().\n/**\n *  Flattens an arbitrarily nested array.\n *\n * ```js\n * const a = [[1, 2], [3, 4], [5, [6, [7]]]];\n * const flat = tf.util.flatten(a);\n * console.log(flat);\n * ```\n *\n *  @param arr The nested array to flatten.\n *  @param result The destination array which holds the elements.\n *  @param skipTypedArray If true, avoids flattening the typed arrays. Defaults\n *      to false.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function\nflatten<T extends number|boolean|string|Promise<number>|TypedArray>(\n    arr: T|RecursiveArray<T>, result: T[] = [], skipTypedArray = false): T[] {\n  if (result == null) {\n    result = [];\n  }\n  if (Array.isArray(arr) || isTypedArray(arr) && !skipTypedArray) {\n    for (let i = 0; i < arr.length; ++i) {\n      flatten(arr[i], result, skipTypedArray);\n    }\n  } else {\n    result.push(arr as T);\n  }\n  return result;\n}\n\n/**\n * Returns the size (number of elements) of the tensor given its shape.\n *\n * ```js\n * const shape = [3, 4, 2];\n * const size = tf.util.sizeFromShape(shape);\n * console.log(size);\n * ```\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function sizeFromShape(shape: number[]): number {\n  if (shape.length === 0) {\n    // Scalar.\n    return 1;\n  }\n  let size = shape[0];\n  for (let i = 1; i < shape.length; i++) {\n    size *= shape[i];\n  }\n  return size;\n}\n\nexport function isScalarShape(shape: number[]): boolean {\n  return shape.length === 0;\n}\n\nexport function arraysEqual(n1: FlatVector, n2: FlatVector) {\n  if (n1 === n2) {\n    return true;\n  }\n  if (n1 == null || n2 == null) {\n    return false;\n  }\n\n  if (n1.length !== n2.length) {\n    return false;\n  }\n  for (let i = 0; i < n1.length; i++) {\n    if (n1[i] !== n2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function isInt(a: number): boolean {\n  return a % 1 === 0;\n}\n\nexport function tanh(x: number): number {\n  // tslint:disable-next-line:no-any\n  if ((Math as any).tanh != null) {\n    // tslint:disable-next-line:no-any\n    return (Math as any).tanh(x);\n  }\n  if (x === Infinity) {\n    return 1;\n  } else if (x === -Infinity) {\n    return -1;\n  } else {\n    const e2x = Math.exp(2 * x);\n    return (e2x - 1) / (e2x + 1);\n  }\n}\n\nexport function sizeToSquarishShape(size: number): [number, number] {\n  const width = Math.ceil(Math.sqrt(size));\n  return [width, Math.ceil(size / width)];\n}\n\n/**\n * Creates a new array with randomized indicies to a given quantity.\n *\n * ```js\n * const randomTen = tf.util.createShuffledIndices(10);\n * console.log(randomTen);\n * ```\n *\n * @param number Quantity of how many shuffled indicies to create.\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function createShuffledIndices(n: number): Uint32Array {\n  const shuffledIndices = new Uint32Array(n);\n  for (let i = 0; i < n; ++i) {\n    shuffledIndices[i] = i;\n  }\n  shuffle(shuffledIndices);\n  return shuffledIndices;\n}\n\nexport function rightPad(a: string, size: number): string {\n  if (size <= a.length) {\n    return a;\n  }\n  return a + ' '.repeat(size - a.length);\n}\n\nexport function repeatedTry(\n    checkFn: () => boolean, delayFn = (counter: number) => 0,\n    maxCounter?: number): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let tryCount = 0;\n\n    const tryFn = () => {\n      if (checkFn()) {\n        resolve();\n        return;\n      }\n\n      tryCount++;\n\n      const nextBackoff = delayFn(tryCount);\n\n      if (maxCounter != null && tryCount >= maxCounter) {\n        reject();\n        return;\n      }\n      setTimeout(tryFn, nextBackoff);\n    };\n\n    tryFn();\n  });\n}\n\n/**\n * Given the full size of the array and a shape that may contain -1 as the\n * implicit dimension, returns the inferred shape where -1 is replaced.\n * E.g. For shape=[2, -1, 3] and size=24, it will return [2, 4, 3].\n *\n * @param shape The shape, which may contain -1 in some dimension.\n * @param size The full size (number of elements) of the array.\n * @return The inferred shape where -1 is replaced with the inferred size.\n */\nexport function inferFromImplicitShape(\n    shape: number[], size: number): number[] {\n  let shapeProd = 1;\n  let implicitIdx = -1;\n\n  for (let i = 0; i < shape.length; ++i) {\n    if (shape[i] >= 0) {\n      shapeProd *= shape[i];\n    } else if (shape[i] === -1) {\n      if (implicitIdx !== -1) {\n        throw Error(\n            `Shapes can only have 1 implicit size. ` +\n            `Found -1 at dim ${implicitIdx} and dim ${i}`);\n      }\n      implicitIdx = i;\n    } else if (shape[i] < 0) {\n      throw Error(`Shapes can not be < 0. Found ${shape[i]} at dim ${i}`);\n    }\n  }\n\n  if (implicitIdx === -1) {\n    if (size > 0 && size !== shapeProd) {\n      throw Error(`Size(${size}) must match the product of shape ${shape}`);\n    }\n    return shape;\n  }\n\n  if (shapeProd === 0) {\n    throw Error(\n        `Cannot infer the missing size in [${shape}] when ` +\n        `there are 0 elements`);\n  }\n  if (size % shapeProd !== 0) {\n    throw Error(\n        `The implicit shape can't be a fractional number. ` +\n        `Got ${size} / ${shapeProd}`);\n  }\n\n  const newShape = shape.slice();\n  newShape[implicitIdx] = size / shapeProd;\n  return newShape;\n}\n\nexport function parseAxisParam(\n    axis: number|number[], shape: number[]): number[] {\n  const rank = shape.length;\n\n  // Normalize input\n  axis = axis == null ? shape.map((s, i) => i) : [].concat(axis);\n\n  // Check for valid range\n  assert(\n      axis.every(ax => ax >= -rank && ax < rank),\n      () =>\n          `All values in axis param must be in range [-${rank}, ${rank}) but ` +\n          `got axis ${axis}`);\n\n  // Check for only integers\n  assert(\n      axis.every(ax => isInt(ax)),\n      () => `All values in axis param must be integers but ` +\n          `got axis ${axis}`);\n\n  // Handle negative axis.\n  return axis.map(a => a < 0 ? rank + a : a);\n}\n\n/** Reduces the shape by removing all dimensions of shape 1. */\nexport function squeezeShape(shape: number[], axis?: number[]):\n    {newShape: number[], keptDims: number[]} {\n  const newShape: number[] = [];\n  const keptDims: number[] = [];\n  const isEmptyArray = axis != null && Array.isArray(axis) && axis.length === 0;\n  const axes = (axis == null || isEmptyArray) ?\n      null :\n      parseAxisParam(axis, shape).sort();\n  let j = 0;\n  for (let i = 0; i < shape.length; ++i) {\n    if (axes != null) {\n      if (axes[j] === i && shape[i] !== 1) {\n        throw new Error(\n            `Can't squeeze axis ${i} since its dim '${shape[i]}' is not 1`);\n      }\n      if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {\n        newShape.push(shape[i]);\n        keptDims.push(i);\n      }\n      if (axes[j] <= i) {\n        j++;\n      }\n    }\n    if (shape[i] !== 1) {\n      newShape.push(shape[i]);\n      keptDims.push(i);\n    }\n  }\n  return {newShape, keptDims};\n}\n\nexport function getTypedArrayFromDType<D extends NumericDataType>(\n    dtype: D, size: number): DataTypeMap[D] {\n  let values = null;\n  if (dtype == null || dtype === 'float32') {\n    values = new Float32Array(size);\n  } else if (dtype === 'int32') {\n    values = new Int32Array(size);\n  } else if (dtype === 'bool') {\n    values = new Uint8Array(size);\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n  return values as DataTypeMap[D];\n}\n\nexport function getArrayFromDType<D extends DataType>(\n    dtype: D, size: number): DataTypeMap[D] {\n  let values = null;\n  if (dtype == null || dtype === 'float32') {\n    values = new Float32Array(size);\n  } else if (dtype === 'int32') {\n    values = new Int32Array(size);\n  } else if (dtype === 'bool') {\n    values = new Uint8Array(size);\n  } else if (dtype === 'string') {\n    values = new Array<'string'>(size);\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n  return values as DataTypeMap[D];\n}\n\nexport function checkConversionForErrors<D extends DataType>(\n    vals: DataTypeMap[D]|number[], dtype: D): void {\n  for (let i = 0; i < vals.length; i++) {\n    const num = vals[i] as number;\n    if (isNaN(num) || !isFinite(num)) {\n      throw Error(`A tensor of type ${dtype} being uploaded contains ${num}.`);\n    }\n  }\n}\n\n/** Returns true if the dtype is valid. */\nexport function isValidDtype(dtype: DataType): boolean {\n  return dtype === 'bool' || dtype === 'complex64' || dtype === 'float32' ||\n      dtype === 'int32' || dtype === 'string';\n}\n\n/**\n * Returns true if the new type can't encode the old type without loss of\n * precision.\n */\nexport function hasEncodingLoss(oldType: DataType, newType: DataType): boolean {\n  if (newType === 'complex64') {\n    return false;\n  }\n  if (newType === 'float32' && oldType !== 'complex64') {\n    return false;\n  }\n  if (newType === 'int32' && oldType !== 'float32' && oldType !== 'complex64') {\n    return false;\n  }\n  if (newType === 'bool' && oldType === 'bool') {\n    return false;\n  }\n  return true;\n}\n\nexport function isTypedArray(a: {}): a is Float32Array|Int32Array|Uint8Array {\n  return a instanceof Float32Array || a instanceof Int32Array ||\n      a instanceof Uint8Array;\n}\n\nexport function bytesPerElement(dtype: DataType): number {\n  if (dtype === 'float32' || dtype === 'int32') {\n    return 4;\n  } else if (dtype === 'complex64') {\n    return 8;\n  } else if (dtype === 'bool') {\n    return 1;\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n\n/**\n * Returns the approximate number of bytes allocated in the string array - 2\n * bytes per character. Computing the exact bytes for a native string in JS is\n * not possible since it depends on the encoding of the html page that serves\n * the website.\n */\nexport function bytesFromStringArray(arr: Uint8Array[]): number {\n  if (arr == null) {\n    return 0;\n  }\n  let bytes = 0;\n  arr.forEach(x => bytes += x.length);\n  return bytes;\n}\n\n/** Returns true if the value is a string. */\nexport function isString(value: {}): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n\nexport function isBoolean(value: {}): boolean {\n  return typeof value === 'boolean';\n}\n\nexport function isNumber(value: {}): boolean {\n  return typeof value === 'number';\n}\n\nexport function inferDtype(values: TensorLike): DataType {\n  if (Array.isArray(values)) {\n    return inferDtype(values[0]);\n  }\n  if (values instanceof Float32Array) {\n    return 'float32';\n  } else if (values instanceof Int32Array || values instanceof Uint8Array) {\n    return 'int32';\n  } else if (isNumber(values)) {\n    return 'float32';\n  } else if (isString(values)) {\n    return 'string';\n  } else if (isBoolean(values)) {\n    return 'bool';\n  }\n  return 'float32';\n}\n\nexport function isFunction(f: Function) {\n  return !!(f && f.constructor && f.call && f.apply);\n}\n\nexport function nearestDivisor(size: number, start: number): number {\n  for (let i = start; i < size; ++i) {\n    if (size % i === 0) {\n      return i;\n    }\n  }\n  return size;\n}\n\nexport function computeStrides(shape: number[]): number[] {\n  const rank = shape.length;\n  if (rank < 2) {\n    return [];\n  }\n\n  // Last dimension has implicit stride of 1, thus having D-1 (instead of D)\n  // strides.\n  const strides = new Array(rank - 1);\n  strides[rank - 2] = shape[rank - 1];\n  for (let i = rank - 3; i >= 0; --i) {\n    strides[i] = strides[i + 1] * shape[i + 1];\n  }\n  return strides;\n}\n\nfunction createNestedArray(\n    offset: number, shape: number[], a: TypedArray, isComplex = false) {\n  const ret = new Array();\n  if (shape.length === 1) {\n    const d = shape[0] * (isComplex ? 2 : 1);\n    for (let i = 0; i < d; i++) {\n      ret[i] = a[offset + i];\n    }\n  } else {\n    const d = shape[0];\n    const rest = shape.slice(1);\n    const len = rest.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);\n    for (let i = 0; i < d; i++) {\n      ret[i] = createNestedArray(offset + i * len, rest, a, isComplex);\n    }\n  }\n  return ret;\n}\n\n// Provide a nested array of TypedArray in given shape.\nexport function toNestedArray(\n    shape: number[], a: TypedArray, isComplex = false) {\n  if (shape.length === 0) {\n    // Scalar type should return a single number.\n    return a[0];\n  }\n  const size = shape.reduce((acc, c) => acc * c) * (isComplex ? 2 : 1);\n  if (size === 0) {\n    // A tensor with shape zero should be turned into empty list.\n    return [];\n  }\n  if (size !== a.length) {\n    throw new Error(`[${shape}] does not match the input size ${a.length}${\n        isComplex ? ' for a complex tensor' : ''}.`);\n  }\n\n  return createNestedArray(0, shape, a, isComplex);\n}\n\nexport function makeOnesTypedArray<D extends DataType>(\n    size: number, dtype: D): DataTypeMap[D] {\n  const array = makeZerosTypedArray(size, dtype);\n  for (let i = 0; i < array.length; i++) {\n    array[i] = 1;\n  }\n  return array;\n}\n\nexport function makeZerosTypedArray<D extends DataType>(\n    size: number, dtype: D): DataTypeMap[D] {\n  if (dtype == null || dtype === 'float32' || dtype === 'complex64') {\n    return new Float32Array(size) as DataTypeMap[D];\n  } else if (dtype === 'int32') {\n    return new Int32Array(size) as DataTypeMap[D];\n  } else if (dtype === 'bool') {\n    return new Uint8Array(size) as DataTypeMap[D];\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n}\n\n/**\n * Make nested `TypedArray` filled with zeros.\n * @param shape The shape information for the nested array.\n * @param dtype dtype of the array element.\n */\nexport function makeZerosNestedTypedArray<D extends DataType>(\n    shape: number[], dtype: D) {\n  const size = shape.reduce((prev, curr) => prev * curr, 1);\n  if (dtype == null || dtype === 'float32') {\n    return toNestedArray(shape, new Float32Array(size));\n  } else if (dtype === 'int32') {\n    return toNestedArray(shape, new Int32Array(size));\n  } else if (dtype === 'bool') {\n    return toNestedArray(shape, new Uint8Array(size));\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n}\n\nexport function assertNonNegativeIntegerDimensions(shape: number[]) {\n  shape.forEach(dimSize => {\n    assert(\n        Number.isInteger(dimSize) && dimSize >= 0,\n        () =>\n            `Tensor must have a shape comprised of positive integers but got ` +\n            `shape [${shape}].`);\n  });\n}\n\n/**\n * Computes flat index for a given location (multidimentionsal index) in a\n * Tensor/multidimensional array.\n *\n * @param locs Location in the tensor.\n * @param rank Rank of the tensor.\n * @param strides Tensor strides.\n */\nexport function locToIndex(\n    locs: number[], rank: number, strides: number[]): number {\n  if (rank === 0) {\n    return 0;\n  } else if (rank === 1) {\n    return locs[0];\n  }\n  let index = locs[locs.length - 1];\n  for (let i = 0; i < locs.length - 1; ++i) {\n    index += strides[i] * locs[i];\n  }\n  return index;\n}\n\n/**\n * Computes the location (multidimensional index) in a tensor/multidimentional\n * array for a given flat index.\n *\n * @param index Index in flat array.\n * @param rank Rank of tensor.\n * @param strides Strides of tensor.\n */\nexport function indexToLoc(\n    index: number, rank: number, strides: number[]): number[] {\n  if (rank === 0) {\n    return [];\n  } else if (rank === 1) {\n    return [index];\n  }\n  const locs: number[] = new Array(rank);\n  for (let i = 0; i < locs.length - 1; ++i) {\n    locs[i] = Math.floor(index / strides[i]);\n    index -= locs[i] * strides[i];\n  }\n  locs[locs.length - 1] = index;\n  return locs;\n}\n\n/**\n * This method asserts whether an object is a Promise instance.\n * @param object\n */\n// tslint:disable-next-line: no-any\nexport function isPromise(object: any): object is Promise<unknown> {\n  //  We chose to not use 'obj instanceOf Promise' for two reasons:\n  //  1. It only reliably works for es6 Promise, not other Promise\n  //  implementations.\n  //  2. It doesn't work with framework that uses zone.js. zone.js monkey patch\n  //  the async calls, so it is possible the obj (patched) is comparing to a\n  //  pre-patched Promise.\n  return object && object.then && typeof object.then === 'function';\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from './environment';\n\nexport function warn(...msg: Array<{}>): void {\n  if (!(env().getBool('IS_TEST') || env().getBool('PROD'))) {\n    console.warn(...msg);\n  }\n}\n\nexport function log(...msg: Array<{}>): void {\n  if (!(env().getBool('IS_TEST') || env().getBool('PROD'))) {\n    console.log(...msg);\n  }\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Platform} from './platforms/platform';\nimport {isPromise} from './util_base';\nimport * as log from './log';\n\n// Expects flags from URL in the format ?tfjsflags=FLAG1:1,FLAG2:true.\nconst TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';\n\ntype FlagValue = number|boolean;\ntype FlagEvaluationFn = (() => FlagValue)|(() => Promise<FlagValue>);\nexport type Flags = {\n  [featureName: string]: FlagValue\n};\nexport type FlagRegistryEntry = {\n  evaluationFn: FlagEvaluationFn;\n  setHook?: (value: FlagValue) => void;\n};\n\n/**\n * The environment contains evaluated flags as well as the registered platform.\n * This is always used as a global singleton and can be retrieved with\n * `tf.env()`.\n *\n * @doc {heading: 'Environment'}\n */\nexport class Environment {\n  private flags: Flags = {};\n  private flagRegistry: {[flagName: string]: FlagRegistryEntry} = {};\n\n  private urlFlags: Flags = {};\n\n  platformName: string;\n  platform: Platform;\n\n  // Jasmine spies on this in 'environment_test.ts'\n  getQueryParams = getQueryParams;\n\n  // tslint:disable-next-line: no-any\n  constructor(public global: any) {\n    this.populateURLFlags();\n  }\n\n  setPlatform(platformName: string, platform: Platform) {\n    if (this.platform != null) {\n      log.warn(\n          `Platform ${this.platformName} has already been set. ` +\n          `Overwriting the platform with ${platform}.`);\n    }\n    this.platformName = platformName;\n    this.platform = platform;\n  }\n\n  registerFlag(\n      flagName: string, evaluationFn: FlagEvaluationFn,\n      setHook?: (value: FlagValue) => void) {\n    this.flagRegistry[flagName] = {evaluationFn, setHook};\n\n    // Override the flag value from the URL. This has to happen here because the\n    // environment is initialized before flags get registered.\n    if (this.urlFlags[flagName] != null) {\n      const flagValue = this.urlFlags[flagName];\n      log.warn(\n          `Setting feature override from URL ${flagName}: ${flagValue}.`);\n      this.set(flagName, flagValue);\n    }\n  }\n\n  async getAsync(flagName: string): Promise<FlagValue> {\n    if (flagName in this.flags) {\n      return this.flags[flagName];\n    }\n\n    this.flags[flagName] = await this.evaluateFlag(flagName);\n    return this.flags[flagName];\n  }\n\n  get(flagName: string): FlagValue {\n    if (flagName in this.flags) {\n      return this.flags[flagName];\n    }\n\n    const flagValue = this.evaluateFlag(flagName);\n    if (isPromise(flagValue)) {\n      throw new Error(\n          `Flag ${flagName} cannot be synchronously evaluated. ` +\n          `Please use getAsync() instead.`);\n    }\n\n    this.flags[flagName] = flagValue as number | boolean;\n\n    return this.flags[flagName];\n  }\n\n  getNumber(flagName: string): number {\n    return this.get(flagName) as number;\n  }\n\n  getBool(flagName: string): boolean {\n    return this.get(flagName) as boolean;\n  }\n\n  getFlags(): Flags {\n    return this.flags;\n  }\n  // For backwards compatibility.\n  get features(): Flags {\n    return this.flags;\n  }\n\n  set(flagName: string, value: FlagValue): void {\n    if (this.flagRegistry[flagName] == null) {\n      throw new Error(\n          `Cannot set flag ${flagName} as it has not been registered.`);\n    }\n    this.flags[flagName] = value;\n    if (this.flagRegistry[flagName].setHook != null) {\n      this.flagRegistry[flagName].setHook(value);\n    }\n  }\n\n  private evaluateFlag(flagName: string): FlagValue|Promise<FlagValue> {\n    if (this.flagRegistry[flagName] == null) {\n      throw new Error(\n          `Cannot evaluate flag '${flagName}': no evaluation function found.`);\n    }\n    return this.flagRegistry[flagName].evaluationFn();\n  }\n\n  setFlags(flags: Flags) {\n    this.flags = Object.assign({}, flags);\n  }\n\n  reset() {\n    this.flags = {};\n    this.urlFlags = {};\n    this.populateURLFlags();\n  }\n\n  private populateURLFlags(): void {\n    if (typeof this.global === 'undefined' ||\n        typeof this.global.location === 'undefined' ||\n        typeof this.global.location.search === 'undefined') {\n      return;\n    }\n\n    const urlParams = this.getQueryParams(this.global.location.search);\n    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {\n      const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');\n      keyValues.forEach(keyValue => {\n        const [key, value] = keyValue.split(':') as [string, string];\n        this.urlFlags[key] = parseValue(key, value);\n      });\n    }\n  }\n}\n\nexport function getQueryParams(queryString: string): {[key: string]: string} {\n  const params = {};\n  queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {\n    decodeParam(params, t[0], t[1]);\n    return t.join('=');\n  });\n  return params;\n}\n\nfunction decodeParam(\n    params: {[key: string]: string}, name: string, value?: string) {\n  params[decodeURIComponent(name)] = decodeURIComponent(value || '');\n}\n\nfunction parseValue(flagName: string, value: string): FlagValue {\n  value = value.toLowerCase();\n  if (value === 'true' || value === 'false') {\n    return value === 'true';\n  } else if (`${+ value}` === value) {\n    return +value;\n  }\n  throw new Error(\n      `Could not parse value flag value ${value} for flag ${flagName}.`);\n}\n\n/**\n * Returns the current environment (a global singleton).\n *\n * The environment object contains the evaluated feature values as well as the\n * active platform.\n *\n * @doc {heading: 'Environment'}\n */\nexport function env() {\n  return ENV;\n}\n\nexport let ENV: Environment = null;\nexport function setEnvironmentGlobal(environment: Environment) {\n  ENV = environment;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Note that the identifier globalNameSpace is scoped to this module, but will\n// always resolve to the same global object regardless of how the module is\n// resolved.\n// tslint:disable-next-line:no-any\nlet globalNameSpace: {_tfGlobals: Map<string, any>};\n// tslint:disable-next-line:no-any\nexport function getGlobalNamespace(): {_tfGlobals: Map<string, any>} {\n  if (globalNameSpace == null) {\n    // tslint:disable-next-line:no-any\n    let ns: any;\n    if (typeof (window) !== 'undefined') {\n      ns = window;\n    } else if (typeof (global) !== 'undefined') {\n      ns = global;\n    } else if (typeof (process) !== 'undefined') {\n      ns = process;\n    } else if (typeof (self) !== 'undefined') {\n      ns = self;\n    } else {\n      throw new Error('Could not find a global object');\n    }\n    globalNameSpace = ns;\n  }\n  return globalNameSpace;\n}\n\n// tslint:disable-next-line:no-any\nfunction getGlobalMap(): Map<string, any> {\n  const ns = getGlobalNamespace();\n  if (ns._tfGlobals == null) {\n    ns._tfGlobals = new Map();\n  }\n  return ns._tfGlobals;\n}\n\n/**\n * Returns a globally accessible 'singleton' object.\n *\n * @param key the name of the object\n * @param init a function to initialize to initialize this object\n *             the first time it is fetched.\n */\nexport function getGlobal<T>(key: string, init: () => T): T {\n  const globalMap = getGlobalMap();\n  if (globalMap.has(key)) {\n    return globalMap.get(key);\n  } else {\n    const singleton = init();\n    globalMap.set(key, singleton);\n    return globalMap.get(key);\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Allow UpperCamelCase variable names\n// tslint:disable: variable-name\n// Unfortunately just enabling PascalCase per file (tslint:enable:\n// allow-pascal-case) doesn't work.\nimport {NamedTensorInfoMap, TensorInfo} from './kernel_registry';\nimport {ExplicitPadding} from './ops/conv_util';\nimport {Activation} from './ops/fused_types';\nimport {DataType, PixelData} from './types';\n\nexport const Abs = 'Abs';\nexport type AbsInputs = UnaryInputs;\n\nexport const Acos = 'Acos';\nexport type AcosInputs = UnaryInputs;\n\nexport const Acosh = 'Acosh';\nexport type AcoshInputs = UnaryInputs;\n\nexport const Add = 'Add';\nexport type AddInputs = BinaryInputs;\n\nexport const AddN = 'AddN';\nexport type AddNInputs = TensorInfo[];\n\nexport const All = 'All';\nexport type AllInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface AllAttrs {\n  axis: number|number[];\n  keepDims: boolean;\n}\n\nexport const Any = 'Any';\nexport type AnyInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface AnyAttrs {\n  axis: number|number[];\n  keepDims: boolean;\n}\n\nexport const ArgMax = 'ArgMax';\nexport type ArgMaxInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface ArgMaxAttrs {\n  axis: number;\n}\n\nexport const ArgMin = 'ArgMin';\nexport type ArgMinInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface ArgMinAttrs {\n  axis: number;\n}\n\nexport const Asin = 'Asin';\nexport type AsinInputs = UnaryInputs;\n\nexport const Asinh = 'Asinh';\nexport type AsinhInputs = UnaryInputs;\n\nexport const Atan = 'Atan';\nexport type AtanInputs = UnaryInputs;\n\nexport const Atanh = 'Atanh';\nexport type AtanhInputs = UnaryInputs;\n\nexport const Atan2 = 'Atan2';\nexport type Atan2Inputs = BinaryInputs;\n\nexport const AvgPool = 'AvgPool';\nexport type AvgPoolInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface AvgPoolAttrs {\n  filterSize: [number, number]|number;\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const AvgPoolGrad = 'AvgPoolGrad';\nexport type AvgPoolGradInputs = Pick<NamedTensorInfoMap, 'dy'|'input'>;\nexport interface AvgPoolGradAttrs {\n  filterSize: [number, number]|number;\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n}\n\nexport const AvgPool3D = 'AvgPool3D';\nexport type AvgPool3DInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface AvgPool3DAttrs {\n  filterSize: [number, number, number]|number;\n  strides: [number, number, number]|number;\n  pad: 'valid'|'same'|number;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n  dataFormat: 'NDHWC'|'NCDHW';\n}\n\nexport const AvgPool3DGrad = 'AvgPool3DGrad';\nexport type AvgPool3DGradInputs = Pick<NamedTensorInfoMap, 'dy'|'input'>;\nexport interface AvgPool3DGradAttrs {\n  filterSize: [number, number, number]|number;\n  strides: [number, number, number]|number;\n  pad: 'valid'|'same'|number;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const BatchMatMul = 'BatchMatMul';\nexport type BatchMatMulInputs = Pick<NamedTensorInfoMap, 'a'|'b'>;\nexport interface BatchMatMulAttrs {\n  transposeA: boolean;\n  transposeB: boolean;\n}\n\nexport const BatchToSpaceND = 'BatchToSpaceND';\nexport type BatchToSpaceNDInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface BatchToSpaceNDAttrs {\n  blockShape: number[];\n  crops: number[][];\n}\n\nexport type BinaryInputs = Pick<NamedTensorInfoMap, 'a'|'b'>;\n\nexport const Bincount = 'Bincount';\nexport type BincountInputs = Pick<NamedTensorInfoMap, 'x'|'weights'>;\nexport interface BincountAttrs {\n  size: number;\n}\n\nexport const BroadcastTo = 'BroadcastTo';\nexport type BroadcastToInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface BroadCastToAttrs {\n  shape: number[];\n  inputShape: number[];  // for gradient\n}\n\nexport const BroadcastArgs = 'BroadcastArgs';\nexport type BroadcastArgsInputs = Pick<NamedTensorInfoMap, 's0'|'s1'>;\n\nexport const Cast = 'Cast';\nexport type CastInputs = UnaryInputs;\nexport interface CastAttrs {\n  dtype: DataType;\n}\n\nexport const Ceil = 'Ceil';\nexport type CeilInputs = UnaryInputs;\n\nexport const ClipByValue = 'ClipByValue';\nexport type ClipByValueInputs = UnaryInputs;\nexport interface ClipByValueAttrs {\n  clipValueMin: number;\n  clipValueMax: number;\n}\n\nexport const Complex = 'Complex';\nexport type ComplexInputs = Pick<NamedTensorInfoMap, 'real'|'imag'>;\n\nexport const ComplexAbs = 'ComplexAbs';\nexport type ComplexAbsInputs = UnaryInputs;\n\nexport const Concat = 'Concat';\nexport type ConcatInputs = TensorInfo[];\nexport interface ConcatAttrs {\n  axis: number;\n}\n\nexport const Conv2D = 'Conv2D';\nexport type Conv2DInputs = Pick<NamedTensorInfoMap, 'x'|'filter'>;\nexport interface Conv2DAttrs {\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dataFormat: 'NHWC'|'NCHW';\n  dilations: [number, number]|number;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const Conv2DBackpropFilter = 'Conv2DBackpropFilter';\nexport type Conv2DBackpropFilterInputs = Pick<NamedTensorInfoMap, 'x'|'dy'>;\nexport interface Conv2DBackpropFilterAttrs {\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dataFormat: 'NHWC'|'NCHW';\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n  filterShape: [number, number, number, number];\n}\n\nexport const Conv2DBackpropInput = 'Conv2DBackpropInput';\nexport type Conv2DBackpropInputInputs = Pick<NamedTensorInfoMap, 'dy'|'filter'>;\nexport interface Conv2DBackpropInputAttrs {\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dataFormat: 'NHWC'|'NCHW';\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n  inputShape: [number, number, number, number];\n}\n\nexport const Conv3D = 'Conv3D';\nexport type Conv3DInputs = Pick<NamedTensorInfoMap, 'x'|'filter'>;\nexport interface Conv3DAttrs {\n  strides: [number, number, number]|number;\n  pad: 'valid'|'same';\n  dataFormat: 'NDHWC'|'NCDHW';\n  dilations: [number, number, number]|number;\n}\n\nexport const Conv3DBackpropFilterV2 = 'Conv3DBackpropFilterV2';\nexport type Conv3DBackpropFilterV2Inputs = Pick<NamedTensorInfoMap, 'x'|'dy'>;\n\nexport interface Conv3DBackpropFilterV2Attrs {\n  strides: [number, number, number]|number;\n  pad: 'valid'|'same';\n  filterShape: [number, number, number, number, number];\n}\n\nexport const Conv3DBackpropInputV2 = 'Conv3DBackpropInputV2';\nexport type Conv3DBackpropInputV2Inputs =\n    Pick<NamedTensorInfoMap, 'dy'|'filter'>;\nexport interface Conv3DBackpropInputV2Attrs {\n  strides: [number, number, number]|number;\n  pad: 'valid'|'same';\n  inputShape: [number, number, number, number, number];\n}\n\nexport const Cos = 'Cos';\nexport type CosInputs = UnaryInputs;\n\nexport const Cosh = 'Cosh';\nexport type CoshInputs = UnaryInputs;\n\nexport const Cumsum = 'Cumsum';\nexport type CumsumInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface CumsumAttrs {\n  axis: number;\n  exclusive: boolean;\n  reverse: boolean;\n}\n\nexport const CropAndResize = 'CropAndResize';\nexport type CropAndResizeInputs =\n    Pick<NamedTensorInfoMap, 'image'|'boxes'|'boxInd'>;\nexport interface CropAndResizeAttrs {\n  cropSize: [number, number];\n  method: 'bilinear'|'nearest';\n  extrapolationValue: number;\n}\n\nexport const DenseBincount = 'DenseBincount';\nexport type DenseBincountInputs = Pick<NamedTensorInfoMap, 'x'|'weights'>;\nexport interface DenseBincountAttrs {\n  size: number;\n  binaryOutput?: boolean;\n}\n\nexport const DepthToSpace = 'DepthToSpace';\nexport type DepthToSpaceInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface DepthToSpaceAttrs {\n  blockSize: number;\n  dataFormat: 'NHWC'|'NCHW';\n}\n\nexport const DepthwiseConv2dNative = 'DepthwiseConv2dNative';\nexport type DepthwiseConv2dNativeInputs =\n    Pick<NamedTensorInfoMap, 'x'|'filter'>;\nexport interface DepthwiseConv2dNativeAttrs {\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dataFormat: 'NHWC'|'NCHW';\n  dilations: [number, number]|number;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const DepthwiseConv2dNativeBackpropFilter =\n    'DepthwiseConv2dNativeBackpropFilter';\nexport type DepthwiseConv2dNativeBackpropFilterInputs =\n    Pick<NamedTensorInfoMap, 'x'|'dy'>;\nexport interface DepthwiseConv2dNativeBackpropFilterAttrs {\n  strides: [number, number]|number;\n  dilations: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n  filterShape: [number, number, number, number];\n}\n\nexport const DepthwiseConv2dNativeBackpropInput =\n    'DepthwiseConv2dNativeBackpropInput';\nexport type DepthwiseConv2dNativeBackpropInputInputs =\n    Pick<NamedTensorInfoMap, 'dy'|'filter'>;\nexport interface DepthwiseConv2dNativeBackpropInputAttrs {\n  strides: [number, number]|number;\n  dilations: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n  inputShape: [number, number, number, number];\n}\n\nexport const Diag = 'Diag';\nexport type DiagInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const Dilation2D = 'Dilation2D';\nexport type Dilation2DInputs = Pick<NamedTensorInfoMap, 'x'|'filter'>;\nexport interface Dilation2DAttrs {\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number;\n  dilations: [number, number]|number;\n}\n\nexport const Dilation2DBackpropInput = 'Dilation2DBackpropInput';\nexport type Dilation2DBackpropInputInputs =\n    Pick<NamedTensorInfoMap, 'x'|'filter'|'dy'>;\n\nexport const Dilation2DBackpropFilter = 'Dilation2DBackpropFilter';\nexport type Dilation2DBackpropFilterInputs =\n    Pick<NamedTensorInfoMap, 'x'|'filter'|'dy'>;\n\nexport const RealDiv = 'RealDiv';\nexport type RealDivInputs = BinaryInputs;\n\nexport const Einsum = 'Einsum';\nexport type EinsumInputs = TensorInfo[];\nexport interface EinsumAttrs {\n  equation: string;\n}\n\nexport const Elu = 'Elu';\nexport type EluInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const EluGrad = 'EluGrad';\nexport type EluGradInputs = Pick<NamedTensorInfoMap, 'dy'|'y'>;\n\nexport const Erf = 'Erf';\nexport type ErfInputs = UnaryInputs;\n\nexport const Equal = 'Equal';\nexport type EqualInputs = BinaryInputs;\n\nexport const Exp = 'Exp';\nexport type ExpInputs = UnaryInputs;\n\nexport const ExpandDims = 'ExpandDims';\nexport type ExpandDimsInputs = Pick<NamedTensorInfoMap, 'input'>;\nexport interface ExpandDimsAttrs {\n  dim: number;\n}\n\nexport const Expm1 = 'Expm1';\nexport type Expm1Inputs = UnaryInputs;\n\nexport const FFT = 'FFT';\nexport type FFTInputs = Pick<NamedTensorInfoMap, 'input'>;\n\nexport const Fill = 'Fill';\nexport interface FillAttrs {\n  shape: number[];\n  value: number|string;\n  dtype: DataType;\n}\n\nexport const FlipLeftRight = 'FlipLeftRight';\nexport type FlipLeftRightInputs = Pick<NamedTensorInfoMap, 'image'>;\n\nexport const Floor = 'Floor';\nexport type FloorInputs = UnaryInputs;\n\nexport const FloorDiv = 'FloorDiv';\nexport type FloorDivInputs = BinaryInputs;\n\nexport const FusedBatchNorm = 'FusedBatchNorm';\nexport type FusedBatchNormInputs =\n    Pick<NamedTensorInfoMap, 'x'|'scale'|'offset'|'mean'|'variance'>;\nexport interface FusedBatchNormAttrs {\n  varianceEpsilon: number;\n}\n\nexport const GatherV2 = 'GatherV2';\nexport type GatherV2Inputs = Pick<NamedTensorInfoMap, 'x'|'indices'>;\nexport interface GatherV2Attrs {\n  axis: number;\n  batchDims: number;\n}\n\nexport const GatherNd = 'GatherNd';\nexport type GatherNdInputs = Pick<NamedTensorInfoMap, 'params'|'indices'>;\n\nexport const Greater = 'Greater';\nexport type GreaterInputs = BinaryInputs;\n\nexport const GreaterEqual = 'GreaterEqual';\nexport type GreaterEqualInputs = BinaryInputs;\n\nexport const Identity = 'Identity';\nexport type IdentityInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const IFFT = 'IFFT';\nexport type IFFTInputs = Pick<NamedTensorInfoMap, 'input'>;\n\nexport const Imag = 'Imag';\nexport type ImagInputs = Pick<NamedTensorInfoMap, 'input'>;\n\nexport const IsFinite = 'IsFinite';\nexport type IsFiniteInputs = UnaryInputs;\n\nexport const IsInf = 'IsInf';\nexport type IsInfInputs = UnaryInputs;\n\nexport const IsNan = 'IsNan';\nexport type IsNanInputs = UnaryInputs;\n\nexport const LeakyRelu = 'LeakyRelu';\nexport type LeakyReluInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface LeakyReluAttrs {\n  alpha: number;\n}\n\nexport const Less = 'Less';\nexport type LessInputs = BinaryInputs;\n\nexport const LessEqual = 'LessEqual';\nexport type LessEqualInputs = BinaryInputs;\n\nexport const LinSpace = 'LinSpace';\nexport interface LinSpaceAttrs {\n  start: number;\n  stop: number;\n  num: number;\n}\nexport const Log = 'Log';\nexport type LogInputs = UnaryInputs;\n\nexport const Log1p = 'Log1p';\nexport type Log1pInputs = UnaryInputs;\n\nexport const LogicalAnd = 'LogicalAnd';\nexport type LogicalAndInputs = BinaryInputs;\n\nexport const LogicalNot = 'LogicalNot';\nexport type LogicalNotInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const LogicalOr = 'LogicalOr';\nexport type LogicalOrInputs = BinaryInputs;\n\nexport const LogSoftmax = 'LogSoftmax';\nexport type LogSoftmaxInputs = Pick<NamedTensorInfoMap, 'logits'>;\nexport interface LogSoftmaxAttrs {\n  axis: number;\n}\n\nexport const LRN = 'LRN';\nexport type LRNInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface LRNAttrs {\n  depthRadius: number;\n  bias: number;\n  alpha: number;\n  beta: number;\n}\n\nexport const LRNGrad = 'LRNGrad';\nexport type LRNGradInputs = Pick<NamedTensorInfoMap, 'x'|'y'|'dy'>;\nexport interface LRNGradAttrs {\n  depthRadius: number;\n  bias: number;\n  alpha: number;\n  beta: number;\n}\n\nexport const Max = 'Max';\nexport type MaxInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface MaxAttrs {\n  reductionIndices: number|number[];\n  keepDims: boolean;\n}\n\nexport const Maximum = 'Maximum';\nexport type MaximumInputs = BinaryInputs;\n\nexport const MaxPool = 'MaxPool';\nexport type MaxPoolInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface MaxPoolAttrs {\n  filterSize: [number, number]|number;\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const MaxPoolGrad = 'MaxPoolGrad';\nexport type MaxPoolGradInputs = Pick<NamedTensorInfoMap, 'dy'|'input'|'output'>;\nexport interface MaxPoolGradAttrs {\n  filterSize: [number, number]|number;\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const MaxPool3D = 'MaxPool3D';\nexport type MaxPool3DInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface MaxPool3DAttrs {\n  filterSize: [number, number, number]|number;\n  strides: [number, number, number]|number;\n  pad: 'valid'|'same'|number;\n  dataFormat: 'NDHWC'|'NCDHW';\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const MaxPool3DGrad = 'MaxPool3DGrad';\nexport type MaxPool3DGradInputs =\n    Pick<NamedTensorInfoMap, 'dy'|'input'|'output'>;\nexport interface MaxPool3DGradAttrs {\n  filterSize: [number, number, number]|number;\n  strides: [number, number, number]|number;\n  pad: 'valid'|'same'|number;\n  dimRoundingMode?: 'floor'|'round'|'ceil';\n}\n\nexport const MaxPoolWithArgmax = 'MaxPoolWithArgmax';\nexport type MaxPoolWithArgmaxInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface MaxPoolWithArgmaxAttrs {\n  filterSize: [number, number]|number;\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number;\n  includeBatchInIndex: boolean;\n}\n\nexport const Mean = 'Mean';\nexport type MeanInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface MeanAttrs {\n  axis: number|number[];\n  keepDims: boolean;\n}\n\nexport const Min = 'Min';\nexport type MinInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface MinAttrs {\n  axis: number|number[];\n  keepDims: boolean;\n}\n\nexport const Minimum = 'Minimum';\nexport type MinimumInputs = BinaryInputs;\n\nexport const MirrorPad = 'MirrorPad';\nexport type MirrorPadInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface MirrorPadAttrs {\n  paddings: Array<[number, number]>;\n  mode: 'reflect'|'symmetric';\n}\n\nexport const Mod = 'Mod';\nexport type ModInputs = BinaryInputs;\n\nexport const Multinomial = 'Multinomial';\nexport type MultinomialInputs = Pick<NamedTensorInfoMap, 'logits'>;\nexport interface MultinomialAttrs {\n  numSamples: number;\n  seed: number;\n  normalized: boolean;\n}\n\nexport const Multiply = 'Multiply';\nexport type MultiplyInputs = BinaryInputs;\n\nexport const Neg = 'Neg';\nexport type NegInputs = UnaryInputs;\n\nexport const NotEqual = 'NotEqual';\nexport type NotEqualInputs = BinaryInputs;\n\nexport const NonMaxSuppressionV3 = 'NonMaxSuppressionV3';\nexport type NonMaxSuppressionV3Inputs =\n    Pick<NamedTensorInfoMap, 'boxes'|'scores'>;\nexport interface NonMaxSuppressionV3Attrs {\n  maxOutputSize: number;\n  iouThreshold: number;\n  scoreThreshold: number;\n}\n\nexport const NonMaxSuppressionV4 = 'NonMaxSuppressionV4';\nexport type NonMaxSuppressionV4Inputs =\n    Pick<NamedTensorInfoMap, 'boxes'|'scores'>;\nexport interface NonMaxSuppressionV4Attrs {\n  maxOutputSize: number;\n  iouThreshold: number;\n  scoreThreshold: number;\n  padToMaxOutputSize: boolean;\n}\n\nexport const NonMaxSuppressionV5 = 'NonMaxSuppressionV5';\nexport type NonMaxSuppressionV5Inputs =\n    Pick<NamedTensorInfoMap, 'boxes'|'scores'>;\nexport interface NonMaxSuppressionV5Attrs {\n  maxOutputSize: number;\n  iouThreshold: number;\n  scoreThreshold: number;\n  softNmsSigma: number;\n}\n\nexport const OnesLike = 'OnesLike';\nexport type OnesLikeInputs = UnaryInputs;\n\nexport const OneHot = 'OneHot';\nexport type OneHotInputs = Pick<NamedTensorInfoMap, 'indices'>;\nexport interface OneHotAttrs {\n  depth: number;\n  onValue: number;\n  offValue: number;\n}\n\nexport const Pack = 'Pack';\nexport type PackInputs = TensorInfo[];\nexport interface PackAttrs {\n  axis: number;\n}\n\nexport const PadV2 = 'PadV2';\nexport type PadV2Inputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface PadV2Attrs {\n  paddings: Array<[number, number]>;\n  constantValue: number;\n}\n\nexport const Pool = 'Pool';\nexport type PoolInputs = Pick<NamedTensorInfoMap, 'input'>;\n\nexport const Pow = 'Pow';\nexport type PowInputs = BinaryInputs;\n\nexport const Prelu = 'Prelu';\nexport type PreluInputs = Pick<NamedTensorInfoMap, 'x'|'alpha'>;\n\nexport const Prod = 'Prod';\nexport type ProdInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface ProdAttrs {\n  axis: number|number[];\n  keepDims: boolean;\n}\n\nexport const Range = 'Range';\nexport interface RangeAttrs {\n  start: number;\n  stop: number;\n  step: number;\n  dtype: 'float32'|'int32';\n}\n\nexport const Real = 'Real';\nexport type RealInputs = Pick<NamedTensorInfoMap, 'input'>;\n\nexport const Reciprocal = 'Reciprocal';\nexport type ReciprocalInputs = UnaryInputs;\n\nexport const Relu = 'Relu';\nexport type ReluInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const Reshape = 'Reshape';\nexport type ReshapeInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface ReshapeAttrs {\n  shape: number[];\n}\n\nexport const ResizeNearestNeighbor = 'ResizeNearestNeighbor';\nexport type ResizeNearestNeighborInputs = Pick<NamedTensorInfoMap, 'images'>;\nexport interface ResizeNearestNeighborAttrs {\n  alignCorners: boolean;\n  halfPixelCenters: boolean;\n  size: [number, number];\n}\n\nexport const ResizeNearestNeighborGrad = 'ResizeNearestNeighborGrad';\nexport type ResizeNearestNeighborGradInputs =\n    Pick<NamedTensorInfoMap, 'images'|'dy'>;\nexport type ResizeNearestNeighborGradAttrs = ResizeNearestNeighborAttrs;\n\nexport const ResizeBilinear = 'ResizeBilinear';\nexport type ResizeBilinearInputs = Pick<NamedTensorInfoMap, 'images'>;\nexport interface ResizeBilinearAttrs {\n  alignCorners: boolean;\n  halfPixelCenters: boolean;\n  size: [number, number];\n}\n\nexport const ResizeBilinearGrad = 'ResizeBilinearGrad';\nexport type ResizeBilinearGradInputs = Pick<NamedTensorInfoMap, 'images'|'dy'>;\nexport type ResizeBilinearGradAttrs = ResizeBilinearAttrs;\n\nexport const Relu6 = 'Relu6';\nexport type Relu6Inputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const Reverse = 'Reverse';\nexport type ReverseInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface ReverseAttrs {\n  dims: number|number[];\n}\n\nexport const Round = 'Round';\nexport type RoundInputs = UnaryInputs;\n\nexport const Rsqrt = 'Rsqrt';\nexport type RsqrtInputs = UnaryInputs;\n\nexport const ScatterNd = 'ScatterNd';\nexport type ScatterNdInputs = Pick<NamedTensorInfoMap, 'indices'|'updates'>;\nexport interface ScatterNdAttrs {\n  shape: number[];\n}\n\nexport const Select = 'Select';\nexport type SelectInputs = Pick<NamedTensorInfoMap, 'condition'|'t'|'e'>;\n\nexport const Selu = 'Selu';\nexport type SeluInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const Slice = 'Slice';\nexport type SliceInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface SliceAttrs {\n  begin: number|number[];\n  size: number|number[];\n}\nexport const Sin = 'Sin';\nexport type SinInputs = UnaryInputs;\n\nexport const Sinh = 'Sinh';\nexport type SinhInputs = UnaryInputs;\n\nexport const Sign = 'Sign';\nexport type SignInputs = UnaryInputs;\n\nexport const Sigmoid = 'Sigmoid';\nexport type SigmoidInputs = UnaryInputs;\n\nexport const Softplus = 'Softplus';\nexport type SoftplusInputs = UnaryInputs;\n\nexport const Sqrt = 'Sqrt';\nexport type SqrtInputs = UnaryInputs;\n\nexport const Sum = 'Sum';\nexport type SumInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface SumAttrs {\n  axis: number|number[];\n  keepDims: boolean;\n}\n\nexport const SpaceToBatchND = 'SpaceToBatchND';\nexport type SpaceToBatchNDInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface SpaceToBatchNDAttrs {\n  blockShape: number[];\n  paddings: number[][];\n}\n\nexport const SplitV = 'SplitV';\nexport type SplitVInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface SplitVAttrs {\n  numOrSizeSplits: number[]|number;\n  axis: number;\n}\n\nexport const Softmax = 'Softmax';\nexport type SoftmaxInputs = Pick<NamedTensorInfoMap, 'logits'>;\nexport interface SoftmaxAttrs {\n  dim: number;\n}\n\nexport const SparseFillEmptyRows = 'SparseFillEmptyRows';\nexport type SparseFillEmptyRowsInputs =\n    Pick<NamedTensorInfoMap, 'indices'|'values'|'denseShape'|'defaultValue'>;\n\nexport const SparseReshape = 'SparseReshape';\nexport type SparseReshapeInputs =\n    Pick<NamedTensorInfoMap, 'inputIndices'|'inputShape'|'newShape'>;\n\nexport const SparseSegmentMean = 'SparseSegmentMean';\nexport type SparseSegmentMeanInputs =\n    Pick<NamedTensorInfoMap, 'data'|'indices'|'segmentIds'>;\n\nexport const SparseSegmentSum = 'SparseSegmentSum';\nexport type SparseSegmentSumInputs =\n    Pick<NamedTensorInfoMap, 'data'|'indices'|'segmentIds'>;\n\nexport const SparseToDense = 'SparseToDense';\nexport type SparseToDenseInputs =\n    Pick<NamedTensorInfoMap, 'sparseIndices'|'sparseValues'|'defaultValue'>;\nexport interface SparseToDenseAttrs {\n  outputShape: number[];\n}\n\nexport const SquaredDifference = 'SquaredDifference';\nexport type SquaredDifferenceInputs = BinaryInputs;\n\nexport const Square = 'Square';\nexport type SquareInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const StridedSlice = 'StridedSlice';\nexport type StridedSliceInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface StridedSliceAttrs {\n  begin: number[];\n  end: number[];\n  strides: number[];\n  beginMask: number;\n  endMask: number;\n  ellipsisMask: number;\n  newAxisMask: number;\n  shrinkAxisMask: number;\n}\n\nexport const StringNGrams = 'StringNGrams';\nexport type StringNGramsInputs = Pick<NamedTensorInfoMap, 'data'|'dataSplits'>;\nexport interface StringNGramsAttrs {\n  separator: string;\n  nGramWidths: number[];\n  leftPad: string;\n  rightPad: string;\n  padWidth: number;\n  preserveShortSequences: boolean;\n}\n\nexport const StringSplit = 'StringSplit';\nexport type StringSplitInputs = Pick<NamedTensorInfoMap, 'input'|'delimiter'>;\nexport interface StringSplitAttrs {\n  skipEmpty: boolean;\n}\n\nexport const StringToHashBucketFast = 'StringToHashBucketFast';\nexport type StringToHashBucketFastInputs = Pick<NamedTensorInfoMap, 'input'>;\nexport interface StringToHashBucketFastAttrs {\n  numBuckets: number;\n}\n\nexport const Sub = 'Sub';\nexport type SubInputs = BinaryInputs;\n\nexport const Tan = 'Tan';\nexport type TanInputs = UnaryInputs;\n\nexport const Tanh = 'Tanh';\nexport type TanhInputs = UnaryInputs;\n\nexport const Tile = 'Tile';\nexport type TileInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface TileAttrs {\n  reps: number[];\n}\n\nexport const TopK = 'TopK';\nexport type TopKInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface TopKAttrs {\n  k: number;\n  sorted: boolean;\n}\n\nexport const Transform = 'Transform';\nexport type TransformInputs = Pick<NamedTensorInfoMap, 'image'|'transforms'>;\nexport interface TransformAttrs {\n  interpolation: 'nearest'|'bilinear';\n  fillMode: 'constant'|'reflect'|'wrap'|'nearest';\n  fillValue: number;\n  outputShape?: [number, number];\n}\n\nexport const Transpose = 'Transpose';\nexport type TransposeInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface TransposeAttrs {\n  perm: number[];\n}\n\nexport const Unique = 'Unique';\nexport type UniqueInputs = Pick<NamedTensorInfoMap, 'x'>;\nexport interface UniqueAttrs {\n  axis: number;\n}\n\nexport type UnaryInputs = Pick<NamedTensorInfoMap, 'x'>;\n\nexport const Unpack = 'Unpack';\nexport type UnpackInputs = Pick<NamedTensorInfoMap, 'value'>;\nexport interface UnpackAttrs {\n  axis: number;\n}\n\nexport const UnsortedSegmentSum = 'UnsortedSegmentSum';\nexport type UnsortedSegmentSumInputs =\n    Pick<NamedTensorInfoMap, 'x'|'segmentIds'>;\nexport interface UnsortedSegmentSumAttrs {\n  numSegments: number;\n}\n\nexport const ZerosLike = 'ZerosLike';\nexport type ZerosLikeInputs = UnaryInputs;\n\n/**\n * TensorFlow.js-only kernels\n */\nexport const Step = 'Step';\nexport type StepInputs = UnaryInputs;\nexport interface StepAttrs {\n  alpha: number;\n}\n\nexport const FromPixels = 'FromPixels';\nexport interface FromPixelsInputs {\n  pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      HTMLVideoElement|ImageBitmap;\n}\nexport interface FromPixelsAttrs {\n  numChannels: number;\n}\n\nexport const RotateWithOffset = 'RotateWithOffset';\nexport type RotateWithOffsetInputs = Pick<NamedTensorInfoMap, 'image'>;\nexport interface RotateWithOffsetAttrs {\n  radians: number;\n  fillValue: number|[number, number, number];\n  center: number|[number, number];\n}\n\nexport const _FusedMatMul = '_FusedMatMul';\n// tslint:disable-next-line: class-name\nexport interface _FusedMatMulInputs extends NamedTensorInfoMap {\n  a: TensorInfo;\n  b: TensorInfo;\n  bias?: TensorInfo;\n  preluActivationWeights?: TensorInfo;\n}\n// tslint:disable-next-line: class-name\nexport interface _FusedMatMulAttrs {\n  transposeA: boolean;\n  transposeB: boolean;\n  activation: Activation;\n  leakyreluAlpha?: number;\n}\n\nexport const FusedConv2D = 'FusedConv2D';\nexport interface FusedConv2DInputs extends NamedTensorInfoMap {\n  x: TensorInfo;\n  filter: TensorInfo;\n  bias?: TensorInfo;\n  preluActivationWeights?: TensorInfo;\n}\nexport interface FusedConv2DAttrs {\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dataFormat: 'NHWC'|'NCHW';\n  dilations: [number, number]|number;\n  dimRoundingMode: 'floor'|'round'|'ceil';\n  activation: Activation;\n  leakyreluAlpha?: number;\n}\n\nexport const FusedDepthwiseConv2D = 'FusedDepthwiseConv2D';\nexport interface FusedDepthwiseConv2DInputs extends NamedTensorInfoMap {\n  x: TensorInfo;\n  filter: TensorInfo;\n  bias?: TensorInfo;\n  preluActivationWeights?: TensorInfo;\n}\nexport interface FusedDepthwiseConv2DAttrs {\n  strides: [number, number]|number;\n  pad: 'valid'|'same'|number|ExplicitPadding;\n  dataFormat: 'NHWC'|'NCHW';\n  dilations: [number, number]|number;\n  dimRoundingMode: 'floor'|'round'|'ceil';\n  activation: Activation;\n  leakyreluAlpha?: number;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {env} from './environment';\nimport {getGlobal} from './global_util';\nimport * as log from './log';\nimport {NamedGradientMap} from './tape';\nimport {Tensor} from './tensor';\nimport {DataType, RecursiveArray} from './types';\n\nconst kernelRegistry =\n    getGlobal('kernelRegistry', () => new Map<string, KernelConfig>());\nconst gradRegistry =\n    getGlobal('gradRegistry', () => new Map<string, GradConfig>());\n\nexport type DataId = object;\n\ntype AttributeValue =\n    number|number[]|boolean|boolean[]|string|string[]|NamedAttrMap;\n\n/** These are extra non-tensor/primitive params passed to kernel functions. */\nexport type Attribute = AttributeValue|RecursiveArray<AttributeValue>;\n\n/** Specifies the code to run when executing a kernel. */\nexport type KernelFunc = (params: {\n  inputs: NamedTensorInfoMap,\n  backend: {},\n  attrs?: NamedAttrMap,\n}) => TensorInfo|TensorInfo[];\n\n/** The function to run when computing a gradient during backprop. */\nexport type GradFunc =\n    (dy: Tensor|Tensor[], saved: Tensor[], attrs: NamedAttrMap) =>\n        NamedGradientMap;\n\n/** Function that gets called after the backend initializes. */\nexport type KernelSetupFunc = (backend: {}) => void;\n/** Function that gets called right before the backend is disposed. */\nexport type KernelDisposeFunc = KernelSetupFunc;\n\n/** Config object for registering a kernel in the global registry. */\nexport interface KernelConfig {\n  kernelName: string;\n  backendName: string;\n  kernelFunc: KernelFunc;\n  setupFunc?: KernelSetupFunc;\n  disposeFunc?: KernelDisposeFunc;\n}\n\n/** Config object for registering a gradient in the global registry. */\nexport interface GradConfig {\n  kernelName: string;\n  inputsToSave?: string[];\n  // When saveAllInputs is true, all inputs will be saved. Only use this flag\n  // if inputs is an array of Tensors.\n  saveAllInputs?: boolean;\n  outputsToSave?: boolean[];\n  gradFunc: GradFunc;\n}\n\n/** Holds metadata for a given tensor. */\nexport interface TensorInfo {\n  dataId: DataId;\n  shape: number[];\n  dtype: DataType;\n}\n\nexport interface NamedTensorInfoMap {\n  [name: string]: TensorInfo|undefined;\n}\n\nexport interface NamedAttrMap {\n  [name: string]: Attribute;\n}\n\n/**\n * Returns the kernel function (code) associated with the provided names.\n *\n * @param kernelName The official name of the kernel.\n * @param backendName The official name of the backend.\n */\nexport function getKernel(\n    kernelName: string, backendName: string): KernelConfig {\n  const key = makeKey(kernelName, backendName);\n  return kernelRegistry.get(key);\n}\n\n/**\n * Returns the registered gradient info associated with the provided kernel.\n * @param kernelName The official TF kernel name.\n */\nexport function getGradient(kernelName: string): GradConfig {\n  return gradRegistry.get(kernelName);\n}\n\nexport function getKernelsForBackend(backendName: string): KernelConfig[] {\n  const it = kernelRegistry.entries();\n  const result: KernelConfig[] = [];\n\n  while (true) {\n    const {done, value} = it.next();\n    if (done) {\n      break;\n    }\n    const [key, config] = value;\n    const [backend, ] = key.split('_');\n    if (backend === backendName) {\n      result.push(config);\n    }\n  }\n  return result;\n}\n\n/**\n * Registers the function (forward pass) for the kernel in a global registry.\n *\n * @param config A config object with the following properties:\n * - `kernelName` The official name of the kernel.\n * - `backendName` The official name of the backend.\n * - `kernelFunc` The function to run during the forward pass of the kernel.\n * - `setupFunc` Optional. Gets called once, after the backend initializes.\n * - `disposeFunc` Optional. Gets called once, right before the backend is\n * disposed.\n */\nexport function registerKernel(config: KernelConfig) {\n  const {kernelName, backendName} = config;\n  const key = makeKey(kernelName, backendName);\n  if (kernelRegistry.has(key)) {\n    log.warn(\n        `The kernel '${kernelName}' for backend ` +\n        `'${backendName}' is already registered`);\n  }\n  kernelRegistry.set(key, config);\n}\n\n/**\n * Registers a gradient function for a given kernel in the global registry,\n * to be used during the back-propagation of that kernel.\n *\n * @param config An object with the following properties:\n * - `kernelName` The name of the kernel that the gradient function is for.\n * - `gradFunc` The function to run during back-propagation.\n */\nexport function registerGradient(config: GradConfig) {\n  const {kernelName} = config;\n\n  if (gradRegistry.has(kernelName)) {\n    // TODO (yassogba) after 3.0 assess whether we need to keep this gated\n    // to debug mode.\n    if (env().getBool('DEBUG')) {\n      log.warn(`Overriding the gradient for '${kernelName}'`);\n    }\n  }\n  gradRegistry.set(kernelName, config);\n}\n\n/**\n * Removes the kernel function from the registry.\n *\n * @param kernelName The official name of the kernel.\n * @param backendName The official name of the backend.\n *\n */\nexport function unregisterKernel(\n    kernelName: string, backendName: string): void {\n  const key = makeKey(kernelName, backendName);\n  if (!kernelRegistry.has(key)) {\n    throw new Error(\n        `The kernel '${kernelName}' for backend ` +\n        `'${backendName}' is not registered`);\n  }\n  kernelRegistry.delete(key);\n}\n\n/** Removes the registered gradient from the global registry. */\nexport function unregisterGradient(kernelName: string): void {\n  if (!gradRegistry.has(kernelName)) {\n    throw new Error(\n        `The gradient '${kernelName}' for backend is not registered`);\n  }\n  gradRegistry.delete(kernelName);\n}\n\n/**\n * Finds kernels that have already been registered to a backend and re-registers\n * them for a new backend. Useful for registering custom backends.\n * @param registeredBackendName Already registered backend.\n * @param newBackendName New backend.\n */\nexport function copyRegisteredKernels(\n    registeredBackendName: string, newBackendName: string): void {\n  const kernels = getKernelsForBackend(registeredBackendName);\n  kernels.forEach(kernelConfig => {\n    const newKernelConfig =\n        Object.assign({}, kernelConfig, {backendName: newBackendName});\n    registerKernel(newKernelConfig);\n  });\n}\n\nfunction makeKey(kernelName: string, backendName: string) {\n  return `${backendName}_${kernelName}`;\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from './environment';\nimport {BackendValues, DataType, TensorLike, TypedArray} from './types';\nimport * as base from './util_base';\nexport * from './util_base';\nexport * from './hash_util';\n\n/**\n * Create typed array for scalar value. Used for storing in `DataStorage`.\n */\nexport function createScalarValue(\n    value: DataType, dtype: DataType): BackendValues {\n  if (dtype === 'string') {\n    return encodeString(value);\n  }\n\n  return toTypedArray([value], dtype);\n}\n\nfunction noConversionNeeded(a: TensorLike, dtype: DataType): boolean {\n  return (a instanceof Float32Array && dtype === 'float32') ||\n      (a instanceof Int32Array && dtype === 'int32') ||\n      (a instanceof Uint8Array && dtype === 'bool');\n}\n\nexport function toTypedArray(a: TensorLike, dtype: DataType): TypedArray {\n  if (dtype === 'string') {\n    throw new Error('Cannot convert a string[] to a TypedArray');\n  }\n  if (Array.isArray(a)) {\n    a = base.flatten(a);\n  }\n\n  if (env().getBool('DEBUG')) {\n    base.checkConversionForErrors(a as number[], dtype);\n  }\n  if (noConversionNeeded(a, dtype)) {\n    return a as TypedArray;\n  }\n  if (dtype == null || dtype === 'float32' || dtype === 'complex64') {\n    return new Float32Array(a as number[]);\n  } else if (dtype === 'int32') {\n    return new Int32Array(a as number[]);\n  } else if (dtype === 'bool') {\n    const bool = new Uint8Array((a as number[]).length);\n    for (let i = 0; i < bool.length; ++i) {\n      if (Math.round((a as number[])[i]) !== 0) {\n        bool[i] = 1;\n      }\n    }\n    return bool;\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n}\n\n/**\n * Returns the current high-resolution time in milliseconds relative to an\n * arbitrary time in the past. It works across different platforms (node.js,\n * browsers).\n *\n * ```js\n * console.log(tf.util.now());\n * ```\n *\n * @doc {heading: 'Util', namespace: 'util'}\n */\nexport function now(): number {\n  return env().platform.now();\n}\n\n/**\n * Returns a platform-specific implementation of\n * [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n *\n * If `fetch` is defined on the global object (`window`, `process`, etc.),\n * `tf.util.fetch` returns that function.\n *\n * If not, `tf.util.fetch` returns a platform-specific solution.\n *\n * ```js\n * const resource = await tf.util.fetch('https://unpkg.com/@tensorflow/tfjs');\n * // handle response\n * ```\n *\n * @doc {heading: 'Util'}\n */\nexport function fetch(\n    path: string, requestInits?: RequestInit): Promise<Response> {\n  return env().platform.fetch(path, requestInits);\n}\n\n/**\n * Encodes the provided string into bytes using the provided encoding scheme.\n *\n * @param s The string to encode.\n * @param encoding The encoding scheme. Defaults to utf-8.\n *\n * @doc {heading: 'Util'}\n */\nexport function encodeString(s: string, encoding = 'utf-8'): Uint8Array {\n  encoding = encoding || 'utf-8';\n  return env().platform.encode(s, encoding);\n}\n\n/**\n * Decodes the provided bytes into a string using the provided encoding scheme.\n * @param bytes The bytes to decode.\n *\n * @param encoding The encoding scheme. Defaults to utf-8.\n *\n * @doc {heading: 'Util'}\n */\nexport function decodeString(bytes: Uint8Array, encoding = 'utf-8'): string {\n  encoding = encoding || 'utf-8';\n  return env().platform.decode(bytes, encoding);\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// Workaround for allowing cjs module to be included in bundle created by\n// rollup.\nimport * as LongExports from 'long';\n// tslint:disable-next-line\nconst Long: LongExports.LongConstructor =\n    // tslint:disable-next-line\n    (LongExports as any).default || LongExports;\n\nexport function hexToLong(hex: string): Long {\n  return Long.fromString(hex, true, 16);\n}\n\n// Some primes between 2^63 and 2^64 for various uses.\n// Hex 0xc3a5c85c97cb3127\nconst k0: Long = hexToLong('c3a5c85c97cb3127');\n// Hex 0xb492b66fbe98f273\nconst k1: Long = hexToLong('b492b66fbe98f273');\n// Hex 0x9ae16a3b2f90404f\nconst k2: Long = hexToLong('9ae16a3b2f90404f');\n\nfunction shiftMix(val: Long): Long {\n  return val.xor(val.shru(47));\n}\n\nfunction fetch(s: Uint8Array, offset: number, numBytes: number): Long {\n  const bytes = s.slice(offset, offset + numBytes);\n  return Long.fromBytes(Array.from(bytes), true, true);\n}\n\nfunction fetch64(s: Uint8Array, offset: number): Long {\n  return fetch(s, offset, 8);\n}\n\nfunction fetch32(s: Uint8Array, offset: number): Long {\n  return fetch(s, offset, 4);\n}\n\nfunction rotate64(val: Long, shift: number): Long {\n  // Avoid shifting by 64: doing so yields an undefined result.\n  return shift === 0 ? val : val.shru(shift).or(val.shl(64 - shift));\n}\n\nfunction hashLen16(u: Long, v: Long, mul = hexToLong('9ddfea08eb382d69')) {\n  // Murmur-inspired hashing.\n  let a = u.xor(v).mul(mul);\n  a = a.xor(a.shru(47));\n  let b = v.xor(a).mul(mul);\n  b = b.xor(b.shru(47));\n  b = b.mul(mul);\n  return b;\n}\n\n// Return a 16-byte hash for 48 bytes.  Quick and dirty.\n// Callers do best to use \"random-looking\" values for a and b.\nfunction weakHashLen32WithSeeds(\n    w: Long, x: Long, y: Long, z: Long, a: Long, b: Long) {\n  a = a.add(w);\n  b = rotate64(b.add(a).add(z), 21);\n  const c = a;\n  a = a.add(x);\n  a = a.add(y);\n  b = b.add(rotate64(a, 44));\n  return [a.add(z), b.add(c)];\n}\n\nfunction weakHashLen32WithSeedsStr(\n    s: Uint8Array, offset: number, a: Long, b: Long) {\n  return weakHashLen32WithSeeds(\n      fetch64(s, offset), fetch64(s, offset + 8), fetch64(s, offset + 16),\n      fetch64(s, offset + 24), a, b);\n}\n\nfunction hashLen0to16(s: Uint8Array, len = s.length): Long {\n  if (len >= 8) {\n    const mul = k2.add(len * 2);\n    const a = fetch64(s, 0).add(k2);\n    const b = fetch64(s, len - 8);\n    const c = rotate64(b, 37).mul(mul).add(a);\n    const d = rotate64(a, 25).add(b).mul(mul);\n    return hashLen16(c, d, mul);\n  }\n  if (len >= 4) {\n    const mul = k2.add(len * 2);\n    const a = fetch32(s, 0);\n    return hashLen16(a.shl(3).add(len), fetch32(s, len - 4), mul);\n  }\n  if (len > 0) {\n    const a = s[0];\n    const b = s[len >> 1];\n    const c = s[len - 1];\n    const y = a + (b << 8);\n    const z = len + (c << 2);\n    return shiftMix(k2.mul(y).xor(k0.mul(z))).mul(k2);\n  }\n  return k2;\n}\n\nfunction hashLen17to32(s: Uint8Array, len = s.length): Long {\n  const mul = k2.add(len * 2);\n  const a = fetch64(s, 0).mul(k1);\n  const b = fetch64(s, 8);\n  const c = fetch64(s, len - 8).mul(mul);\n  const d = fetch64(s, len - 16).mul(k2);\n  return hashLen16(\n      rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d),\n      a.add(rotate64(b.add(k2), 18)).add(c), mul);\n}\n\nfunction hashLen33to64(s: Uint8Array, len = s.length): Long {\n  const mul = k2.add(len * 2);\n  const a = fetch64(s, 0).mul(k2);\n  const b = fetch64(s, 8);\n  const c = fetch64(s, len - 8).mul(mul);\n  const d = fetch64(s, len - 16).mul(k2);\n  const y = rotate64(a.add(b), 43).add(rotate64(c, 30)).add(d);\n  const z = hashLen16(y, a.add(rotate64(b.add(k2), 18)).add(c), mul);\n  const e = fetch64(s, 16).mul(mul);\n  const f = fetch64(s, 24);\n  const g = y.add(fetch64(s, len - 32)).mul(mul);\n  const h = z.add(fetch64(s, len - 24)).mul(mul);\n  return hashLen16(\n      rotate64(e.add(f), 43).add(rotate64(g, 30)).add(h),\n      e.add(rotate64(f.add(a), 18)).add(g), mul);\n}\n\nexport function fingerPrint64(s: Uint8Array, len = s.length): Long {\n  const seed: Long = Long.fromNumber(81, true);\n  if (len <= 32) {\n    if (len <= 16) {\n      return hashLen0to16(s, len);\n    } else {\n      return hashLen17to32(s, len);\n    }\n  } else if (len <= 64) {\n    return hashLen33to64(s, len);\n  }\n\n  // For strings over 64 bytes we loop.  Internal state consists of\n  // 56 bytes: v, w, x, y, and z.\n  let x = seed;\n  let y = seed.mul(k1).add(113);\n\n  let z = shiftMix(y.mul(k2).add(113)).mul(k2);\n  let v = [Long.UZERO, Long.UZERO];\n  let w = [Long.UZERO, Long.UZERO];\n  x = x.mul(k2).add(fetch64(s, 0));\n\n  let offset = 0;\n  // Set end so that after the loop we have 1 to 64 bytes left to process.\n  const end = ((len - 1) >> 6) * 64;\n  const last64 = end + ((len - 1) & 63) - 63;\n\n  do {\n    x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(k1);\n    y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(k1);\n    x = x.xor(w[1]);\n    y = y.add(v[0]).add(fetch64(s, offset + 40));\n    z = rotate64(z.add(w[0]), 33).mul(k1);\n    v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(k1), x.add(w[0]));\n    w = weakHashLen32WithSeedsStr(\n        s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));\n\n    [z, x] = [x, z];\n    offset += 64;\n  } while (offset !== end);\n  const mul = k1.add(z.and(0xff).shl(1));\n  // Point to the last 64 bytes of input.\n  offset = last64;\n\n  w[0] = w[0].add((len - 1) & 63);\n  v[0] = v[0].add(w[0]);\n  w[0] = w[0].add(v[0]);\n\n  x = rotate64(x.add(y).add(v[0]).add(fetch64(s, offset + 8)), 37).mul(mul);\n  y = rotate64(y.add(v[1]).add(fetch64(s, offset + 48)), 42).mul(mul);\n  x = x.xor(w[1].mul(9));\n  y = y.add(v[0].mul(9).add(fetch64(s, offset + 40)));\n  z = rotate64(z.add(w[0]), 33).mul(mul);\n  v = weakHashLen32WithSeedsStr(s, offset, v[1].mul(mul), x.add(w[0]));\n  w = weakHashLen32WithSeedsStr(\n      s, offset + 32, z.add(w[1]), y.add(fetch64(s, offset + 16)));\n\n  [z, x] = [x, z];\n\n  return hashLen16(\n      hashLen16(v[0], w[0], mul).add(shiftMix(y).mul(k0)).add(z),\n      hashLen16(v[1], w[1], mul).add(x), mul);\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BackendTimer, BackendTimingInfo} from './backends/backend';\nimport {env} from './environment';\nimport {Tensor} from './tensor';\nimport {NamedTensorMap} from './tensor_types';\nimport {DataType, DataTypeMap, TypedArray} from './types';\nimport * as util from './util';\n\nexport type KernelProfile = {\n  kernelName: string,\n  outputs: Tensor[],\n  inputs: NamedTensorMap,\n  timeMs: Promise<number|{error: string}>,\n  extraInfo: Promise<string>\n};\n\nexport class Profiler {\n  constructor(private backendTimer: BackendTimer, private logger?: Logger) {\n    if (logger == null) {\n      this.logger = new Logger();\n    }\n  }\n\n  profileKernel(kernelName: string, inputs: NamedTensorMap, f: () => Tensor[]):\n      KernelProfile {\n    let outputs: Tensor[];\n    const holdResultWrapperFn = () => {\n      outputs = f();\n    };\n    let timer: Promise<BackendTimingInfo>;\n    const start = util.now();\n    if (this.backendTimer.timerAvailable()) {\n      timer = this.backendTimer.time(holdResultWrapperFn);\n    } else {\n      holdResultWrapperFn();\n      for (const output of outputs) {\n        output.dataSync();\n      }\n      timer = Promise.resolve({kernelMs: util.now() - start});\n    }\n    if (env().getBool('CHECK_COMPUTATION_FOR_ERRORS')) {\n      for (let i = 0; i < outputs.length; i++) {\n        const output = outputs[i];\n        // Dangling promise here because we don't want to propagate up\n        // asynchronicity.\n        output.data().then(tensorVals => {\n          checkComputationForErrors(tensorVals, output.dtype, kernelName);\n        });\n      }\n    }\n\n    const kernelProfile = {\n      kernelName,\n      outputs,\n      inputs,\n      timeMs: timer.then(timing => timing.kernelMs),\n      extraInfo: timer.then(\n          timing => timing.getExtraProfileInfo != null ?\n              timing.getExtraProfileInfo() :\n              '')\n    };\n    return kernelProfile;\n  }\n\n  logKernelProfile(kernelProfile: KernelProfile): void {\n    const {kernelName, outputs, timeMs, inputs, extraInfo} = kernelProfile;\n\n    outputs.forEach(result => {\n      Promise.all([result.data(), timeMs, extraInfo]).then(valueContainer => {\n        this.logger.logKernelProfile(\n            kernelName, result, valueContainer[0], valueContainer[1], inputs,\n            valueContainer[2]);\n      });\n    });\n  }\n}\n\nexport function checkComputationForErrors<D extends DataType>(\n    vals: DataTypeMap[D], dtype: D, kernelName: string): boolean {\n  if (dtype !== 'float32') {\n    // Only floating point computations will generate NaN values\n    return false;\n  }\n  for (let i = 0; i < vals.length; i++) {\n    const num = vals[i] as number;\n    if (isNaN(num) || !isFinite(num)) {\n      // Throwing custom exception so behavior is testable.\n      console.warn(`Found ${num} in the result of '${kernelName}'`);\n      return true;\n    }\n  }\n  return false;\n}\n\nexport class Logger {\n  logKernelProfile(\n      name: string, result: Tensor, vals: TypedArray,\n      timeMs: number|{error: string}, inputs: NamedTensorMap,\n      extraInfo?: string) {\n    const time = typeof timeMs === 'number' ? util.rightPad(`${timeMs}ms`, 9) :\n                                              timeMs['error'];\n    const paddedName = util.rightPad(name, 25);\n    const rank = result.rank;\n    const size = result.size;\n    const shape = util.rightPad(result.shape.toString(), 14);\n    let inputShapesDescription = '';\n\n    for (const name in inputs) {\n      const input = inputs[name];\n      if (input != null) {\n        // The input might be a non-tensor (e.g HTMLImageElement), in which case\n        // we claim the output shape as input shape.\n        const inputShape = input.shape || result.shape;\n        const inputRank = inputShape.length;\n        inputShapesDescription +=\n            `${name}: ${inputRank}D ${inputRank > 0 ? inputShape : ''} `;\n      }\n    }\n\n    console.log(\n        `%c${paddedName}\\t%c${time}\\t%c${rank}D ${shape}\\t%c${size}\\t%c${\n            inputShapesDescription}\\t%c${extraInfo}`,\n        'font-weight:bold', 'color:red', 'color:blue', 'color: orange',\n        'color: green', 'color: steelblue');\n  }\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from './tensor';\nimport {NamedTensorMap} from './tensor_types';\nimport * as util from './util';\n\nexport interface TapeNode {\n  id: number;\n  kernelName: string;\n  outputs: Tensor[];\n  inputs: NamedTensorMap;\n  // Optional params, defined only for ops with gradient impl.\n  gradient?: (dys: Tensor[]) => NamedGradientMap;\n  saved?: Tensor[];\n}\n\nexport type NamedGradientMap = {\n  [inputName: string]: () => Tensor;\n};\n\n/**\n * Computes a list of TapeNodes that connect x to y, filtering everything else\n * out and preserving the order of the original tape elements.\n *\n * @param tape The tape elements to filter.\n * @param xs The input Tensors.\n * @param y The output Tensor.\n */\nexport function getFilteredNodesXToY(\n    tape: TapeNode[], xs: Tensor[], y: Tensor): TapeNode[] {\n  // Forward pass to compute all the nodes and Tensors that are transitively a\n  // function of x.\n  const tensorsFromX: {[tensorId: number]: boolean} = {};\n  const nodesFromX: {[nodeId: number]: boolean} = {};\n  for (let i = 0; i < xs.length; i++) {\n    tensorsFromX[xs[i].id] = true;\n  }\n\n  for (let i = 0; i < tape.length; i++) {\n    const node = tape[i];\n    const nodeInputs = node.inputs;\n    for (const inputName in nodeInputs) {\n      const input = nodeInputs[inputName];\n\n      let anyInputFromX = false;\n      for (let j = 0; j < xs.length; j++) {\n        if (tensorsFromX[input.id]) {\n          node.outputs.forEach(output => tensorsFromX[output.id] = true);\n          anyInputFromX = true;\n          nodesFromX[node.id] = true;\n          break;\n        }\n      }\n\n      if (anyInputFromX) {\n        break;\n      }\n    }\n  }\n\n  // Backward pass to find all of the nodes and Tensors that lead to y.\n  const tensorsLeadToY: {[tensorId: number]: boolean} = {};\n  tensorsLeadToY[y.id] = true;\n  const nodesToY: {[nodeId: number]: boolean} = {};\n\n  for (let i = tape.length - 1; i >= 0; i--) {\n    const node = tape[i];\n    const nodeInputs = node.inputs;\n\n    // If any of the outputs lead to y, mark all of the inputs as leading to y.\n    for (let j = 0; j < node.outputs.length; j++) {\n      if (tensorsLeadToY[node.outputs[j].id]) {\n        for (const inputName in nodeInputs) {\n          tensorsLeadToY[nodeInputs[inputName].id] = true;\n          nodesToY[node.id] = true;\n        }\n        break;\n      }\n    }\n  }\n\n  // Return the paths that come from x and lead to y.\n  const filteredTape: TapeNode[] = [];\n  for (let i = 0; i < tape.length; i++) {\n    const node = tape[i];\n\n    if (nodesFromX[node.id] && nodesToY[node.id]) {\n      // Prune the inputs from the node that aren't a function of x.\n      const prunedInputs: {[inputName: string]: Tensor} = {};\n      for (const inputName in node.inputs) {\n        const nodeInput = node.inputs[inputName];\n        if (tensorsFromX[nodeInput.id]) {\n          prunedInputs[inputName] = nodeInput;\n        }\n      }\n\n      // Copy the node and overwrite inputsAndArgs to the pruned version.\n      const prunedNode = Object.assign({}, node);\n      prunedNode.inputs = prunedInputs;\n      prunedNode.outputs = node.outputs;\n\n      filteredTape.push(prunedNode);\n    }\n  }\n\n  return filteredTape;\n}\n\n/**\n * Backpropagate gradients through the filtered TapeNodes.\n *\n * @param tensorAccumulatedGradientMap A map of Tensor to its gradient. This map\n * is mutated by this method.\n * @param filteredTape The filtered TapeNodes to backprop through.\n */\nexport function backpropagateGradients(\n    tensorAccumulatedGradientMap: {[tensorId: number]: Tensor},\n    filteredTape: TapeNode[], tidy: (f: Function) => Tensor,\n    add: (a: Tensor, b: Tensor) => Tensor) {\n  // Walk the tape backward and keep a map of Tensor to its gradient.\n  for (let i = filteredTape.length - 1; i >= 0; i--) {\n    const node = filteredTape[i];\n\n    const dys: Tensor[] = [];\n    node.outputs.forEach(o => {\n      const gradTensor = tensorAccumulatedGradientMap[o.id];\n      if (gradTensor != null) {\n        dys.push(gradTensor);\n      } else {\n        // This particular output is not in the back-propagation subgraph, so it\n        // does not affect the final output, thus we put null for its dy.\n        dys.push(null);\n      }\n    });\n\n    if (node.gradient == null) {\n      throw new Error(\n          `Cannot compute gradient: gradient function not found ` +\n          `for ${node.kernelName}.`);\n    }\n\n    // Backprop dy through this node and accumulate gradients over the inputs.\n    const inputGradients = node.gradient(dys);\n\n    for (const inputName in node.inputs) {\n      if (!(inputName in inputGradients)) {\n        throw new Error(\n            `Cannot backprop through input ${inputName}. ` +\n            `Available gradients found: ${Object.keys(inputGradients)}.`);\n      }\n\n      // Call the gradient function.\n      const dx = tidy(() => inputGradients[inputName]());\n      if (dx.dtype !== 'float32') {\n        throw new Error(\n            `Error in gradient for op ${\n                node.kernelName}. The gradient of input ` +\n            `${inputName} must have 'float32' dtype, but has '${dx.dtype}'`);\n      }\n      const x = node.inputs[inputName];\n      if (!util.arraysEqual(dx.shape, x.shape)) {\n        throw new Error(\n            `Error in gradient for op ${\n                node.kernelName}. The gradient of input ` +\n            `'${inputName}' has shape '${dx.shape}', which does not match ` +\n            `the shape of the input '${x.shape}'`);\n      }\n\n      if (tensorAccumulatedGradientMap[x.id] == null) {\n        tensorAccumulatedGradientMap[x.id] = dx;\n      } else {\n        const curGradient = tensorAccumulatedGradientMap[x.id];\n        tensorAccumulatedGradientMap[x.id] = add(curGradient, dx);\n        curGradient.dispose();\n      }\n    }\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray} from './types';\nimport {computeStrides, isString, rightPad, sizeFromShape} from './util';\n\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\n\nexport function tensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    verbose: boolean) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[]): number[] {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples =\n      dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(\n            padPerCol[j],\n            valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n  return padPerCol;\n}\n\nfunction valToString(\n    val: number|string|[number, number], pad: number, dtype: DataType) {\n  let valStr: string;\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n        `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v: number): string {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[], padPerCol: number[], isLast = true): string[] {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n\n  const size = shape[0];\n  const rank = shape.length;\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0] as number)];\n    }\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n\n      let firstVals = Array.from<number|string|[number, number]>(\n          vals.slice(0, firstValsSize));\n      let lastVals = Array.from<number|string|[number, number]>(vals.slice(\n          (size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement,\n          size * storagePerElement));\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n      return [\n        '[' +\n        firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n            .join(', ') +\n        ', ..., ' +\n        lastVals\n            .map(\n                (x, i) => valToString(\n                    x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n            .join(', ') +\n        ']'\n      ];\n    }\n    const displayVals: Array<number|string|[number, number]> =\n        dtype === 'complex64' ? createComplexTuples(vals) :\n                                Array.from<number|string>(vals);\n\n    return [\n      '[' +\n      displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n          .join(', ') +\n      ']'\n    ];\n  }\n\n  // The array is rank 2 or more.\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines: string[] = [];\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          false /* isLast */));\n    }\n    lines.push('...');\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  }\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + lines[0] + sep;\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n  let newLineSep = ',\\n';\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n  lines[lines.length - 1] =\n      ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals: Array<{}>|\n                             TypedArray): Array<[number, number]> {\n  const complexTuples: Array<[number, number]> = [];\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]] as [number, number]);\n  }\n  return complexTuples;\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlobal} from './global_util';\nimport {tensorToString} from './tensor_format';\nimport {ArrayMap, BackendValues, DataType, DataTypeMap, DataValues, NumericDataType, Rank, ShapeMap, SingleValueMap, TypedArray} from './types';\nimport * as util from './util';\nimport {computeStrides, toNestedArray} from './util';\n\nexport interface TensorData<D extends DataType> {\n  dataId?: DataId;\n  values?: DataTypeMap[D];\n}\n\n// This interface mimics KernelBackend (in backend.ts), which would create a\n// circular dependency if imported.\nexport interface Backend {}\n\n/**\n * A mutable object, similar to `tf.Tensor`, that allows users to set values\n * at locations before converting to an immutable `tf.Tensor`.\n *\n * See `tf.buffer` for creating a tensor buffer.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class TensorBuffer<R extends Rank, D extends DataType = 'float32'> {\n  size: number;\n  shape: ShapeMap[R];\n  strides: number[];\n  values: DataTypeMap[D];\n\n  constructor(shape: ShapeMap[R], public dtype: D, values?: DataTypeMap[D]) {\n    this.shape = shape.slice() as ShapeMap[R];\n    this.size = util.sizeFromShape(shape);\n\n    if (values != null) {\n      const n = values.length;\n      util.assert(\n          n === this.size,\n          () => `Length of values '${n}' does not match the size ` +\n              `inferred by the shape '${this.size}'.`);\n    }\n    if (dtype === 'complex64') {\n      throw new Error(\n          `complex64 dtype TensorBuffers are not supported. Please create ` +\n          `a TensorBuffer for the real and imaginary parts separately and ` +\n          `call tf.complex(real, imag).`);\n    }\n    this.values = values || util.getArrayFromDType(dtype, this.size);\n    this.strides = computeStrides(shape);\n  }\n\n  /**\n   * Sets a value in the buffer at a given location.\n   *\n   * @param value The value to set.\n   * @param locs  The location indices.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Creation'}\n   */\n  set(value: SingleValueMap[D], ...locs: number[]): void {\n    if (locs.length === 0) {\n      locs = [0];\n    }\n    util.assert(\n        locs.length === this.rank,\n        () => `The number of provided coordinates (${locs.length}) must ` +\n            `match the rank (${this.rank})`);\n\n    const index = this.locToIndex(locs);\n    this.values[index] = value as number;\n  }\n\n  /**\n   * Returns the value in the buffer at the provided location.\n   *\n   * @param locs The location indices.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Creation'}\n   */\n  get(...locs: number[]): SingleValueMap[D] {\n    if (locs.length === 0) {\n      locs = [0];\n    }\n    let i = 0;\n    for (const loc of locs) {\n      if (loc < 0 || loc >= this.shape[i]) {\n        const msg = `Requested out of range element at ${locs}. ` +\n            `  Buffer shape=${this.shape}`;\n        throw new Error(msg);\n      }\n      i++;\n    }\n    let index = locs[locs.length - 1];\n    for (let i = 0; i < locs.length - 1; ++i) {\n      index += this.strides[i] * locs[i];\n    }\n    return this.values[index] as SingleValueMap[D];\n  }\n\n  locToIndex(locs: number[]): number {\n    if (this.rank === 0) {\n      return 0;\n    } else if (this.rank === 1) {\n      return locs[0];\n    }\n    let index = locs[locs.length - 1];\n    for (let i = 0; i < locs.length - 1; ++i) {\n      index += this.strides[i] * locs[i];\n    }\n    return index;\n  }\n\n  indexToLoc(index: number): number[] {\n    if (this.rank === 0) {\n      return [];\n    } else if (this.rank === 1) {\n      return [index];\n    }\n    const locs: number[] = new Array(this.shape.length);\n    for (let i = 0; i < locs.length - 1; ++i) {\n      locs[i] = Math.floor(index / this.strides[i]);\n      index -= locs[i] * this.strides[i];\n    }\n    locs[locs.length - 1] = index;\n    return locs;\n  }\n\n  get rank() {\n    return this.shape.length;\n  }\n\n  /**\n   * Creates an immutable `tf.Tensor` object from the buffer.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Creation'}\n   */\n  toTensor(): Tensor<R> {\n    return trackerFn().makeTensor(this.values, this.shape, this.dtype) as\n        Tensor<R>;\n  }\n}\n\nexport interface TensorTracker {\n  makeTensor(\n      values: DataValues, shape: number[], dtype: DataType,\n      backend?: Backend): Tensor;\n  makeVariable(\n      initialValue: Tensor, trainable?: boolean, name?: string,\n      dtype?: DataType): Variable;\n  incRef(a: Tensor, backend: Backend): void;\n  disposeTensor(t: Tensor): void;\n  disposeVariable(v: Variable): void;\n  read(dataId: DataId): Promise<BackendValues>;\n  readSync(dataId: DataId): BackendValues;\n}\n\n/**\n * The Tensor class calls into this handler to delegate chaining operations.\n */\nexport interface OpHandler {\n  cast<T extends Tensor>(x: T, dtype: DataType): T;\n  buffer<R extends Rank, D extends DataType>(\n      shape: ShapeMap[R], dtype: D,\n      values?: DataTypeMap[D]): TensorBuffer<R, D>;\n  print<T extends Tensor>(x: T, verbose: boolean): void;\n  clone<T extends Tensor>(x: T): T;\n  // TODO(yassogba) bring reshape back?\n}\n\n// For tracking tensor creation and disposal.\nlet trackerFn: () => TensorTracker = null;\n// Used by chaining methods to call into ops.\nlet opHandler: OpHandler = null;\n// Used to warn about deprecated methods.\nlet deprecationWarningFn: (msg: string) => void = null;\n// This here so that we can use this method on dev branches and keep the\n// functionality at master.\n// tslint:disable-next-line:no-unused-expression\n[deprecationWarningFn];\n\n/**\n * An external consumer can register itself as the tensor tracker. This way\n * the Tensor class can notify the tracker for every tensor created and\n * disposed.\n */\nexport function setTensorTracker(fn: () => TensorTracker) {\n  trackerFn = fn;\n}\n\n/**\n * An external consumer can register itself as the op handler. This way the\n * Tensor class can have chaining methods that call into ops via the op\n * handler.\n */\nexport function setOpHandler(handler: OpHandler) {\n  opHandler = handler;\n}\n\n/**\n * Sets the deprecation warning function to be used by this file. This way the\n * Tensor class can be a leaf but still use the environment.\n */\nexport function setDeprecationWarningFn(fn: (msg: string) => void) {\n  deprecationWarningFn = fn;\n}\n\n/**\n * We wrap data id since we use weak map to avoid memory leaks.\n * Since we have our own memory management, we have a reference counter\n * mapping a tensor to its data, so there is always a pointer (even if that\n * data is otherwise garbage collectable).\n * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\n * Global_Objects/WeakMap\n */\nexport type DataId = object;  // object instead of {} to force non-primitive.\n\n// Declare this namespace to make Tensor class augmentation work in google3.\nexport declare namespace Tensor {}\n/**\n * A `tf.Tensor` object represents an immutable, multidimensional array of\n * numbers that has a shape and a data type.\n *\n * For performance reasons, functions that create tensors do not necessarily\n * perform a copy of the data passed to them (e.g. if the data is passed as a\n * `Float32Array`), and changes to the data will change the tensor. This is not\n * a feature and is not supported. To avoid this behavior, use the tensor before\n * changing the input data or create a copy with `copy = tf.add(yourTensor, 0)`.\n *\n * See `tf.tensor` for details on how to create a `tf.Tensor`.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class Tensor<R extends Rank = Rank> {\n  /** Unique id of this tensor. */\n  readonly id: number;\n  /**\n   * Id of the bucket holding the data for this tensor. Multiple arrays can\n   * point to the same bucket (e.g. when calling array.reshape()).\n   */\n  dataId: DataId;\n  /** The shape of the tensor. */\n  readonly shape: ShapeMap[R];\n  /** Number of elements in the tensor. */\n  readonly size: number;\n  /** The data type for the array. */\n  readonly dtype: DataType;\n  /** The rank type for the array (see `Rank` enum). */\n  readonly rankType: R;\n\n  /** Whether this tensor has been globally kept. */\n  kept = false;\n  /** The id of the scope this tensor is being tracked in. */\n  scopeId: number;\n\n  /**\n   * Number of elements to skip in each dimension when indexing. See\n   * https://docs.scipy.org/doc/numpy/reference/generated/\\\n   * numpy.ndarray.strides.html\n   */\n  readonly strides: number[];\n\n  constructor(shape: ShapeMap[R], dtype: DataType, dataId: DataId, id: number) {\n    this.shape = shape.slice() as ShapeMap[R];\n    this.dtype = dtype || 'float32';\n    this.size = util.sizeFromShape(shape);\n    this.strides = computeStrides(shape);\n    this.dataId = dataId;\n    this.id = id;\n    this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher') as R;\n  }\n\n  get rank(): number {\n    return this.shape.length;\n  }\n\n  /**\n   * Returns a promise of `tf.TensorBuffer` that holds the underlying data.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  async buffer<D extends DataType = 'float32'>(): Promise<TensorBuffer<R, D>> {\n    const vals = await this.data<D>();\n    return opHandler.buffer(this.shape, this.dtype as D, vals);\n  }\n\n  /**\n   * Returns a `tf.TensorBuffer` that holds the underlying data.\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  bufferSync<D extends DataType = 'float32'>(): TensorBuffer<R, D> {\n    return opHandler.buffer(this.shape, this.dtype as D, this.dataSync());\n  }\n\n  /**\n   * Returns the tensor data as a nested array. The transfer of data is done\n   * asynchronously.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  async array(): Promise<ArrayMap[R]> {\n    const vals = await this.data();\n    return toNestedArray(this.shape, vals, this.dtype === 'complex64') as\n        ArrayMap[R];\n  }\n\n  /**\n   * Returns the tensor data as a nested array. The transfer of data is done\n   * synchronously.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  arraySync(): ArrayMap[R] {\n    return toNestedArray(\n               this.shape, this.dataSync(), this.dtype === 'complex64') as\n        ArrayMap[R];\n  }\n\n  /**\n   * Asynchronously downloads the values from the `tf.Tensor`. Returns a\n   * promise of `TypedArray` that resolves when the computation has finished.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  async data<D extends DataType = NumericDataType>(): Promise<DataTypeMap[D]> {\n    this.throwIfDisposed();\n    const data = trackerFn().read(this.dataId);\n    if (this.dtype === 'string') {\n      const bytes = await data as Uint8Array[];\n      try {\n        return bytes.map(b => util.decodeString(b)) as DataTypeMap[D];\n      } catch {\n        throw new Error(\n            'Failed to decode the string bytes into utf-8. ' +\n            'To get the original bytes, call tensor.bytes().');\n      }\n    }\n    return data as Promise<DataTypeMap[D]>;\n  }\n\n  /**\n   * Synchronously downloads the values from the `tf.Tensor`. This blocks the\n   * UI thread until the values are ready, which can cause performance issues.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  dataSync<D extends DataType = NumericDataType>(): DataTypeMap[D] {\n    this.throwIfDisposed();\n    const data = trackerFn().readSync(this.dataId);\n    if (this.dtype === 'string') {\n      try {\n        return (data as Uint8Array[]).map(b => util.decodeString(b)) as\n            DataTypeMap[D];\n      } catch {\n        throw new Error(\n            'Failed to decode the string bytes into utf-8. ' +\n            'To get the original bytes, call tensor.bytes().');\n      }\n    }\n    return data as DataTypeMap[D];\n  }\n\n  /** Returns the underlying bytes of the tensor's data. */\n  async bytes(): Promise<Uint8Array[]|Uint8Array> {\n    this.throwIfDisposed();\n    const data = await trackerFn().read(this.dataId);\n    if (this.dtype === 'string') {\n      return data as Uint8Array[];\n    } else {\n      return new Uint8Array((data as TypedArray).buffer);\n    }\n  }\n\n  /**\n   * Disposes `tf.Tensor` from memory.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  dispose(): void {\n    if (this.isDisposed) {\n      return;\n    }\n    trackerFn().disposeTensor(this);\n    this.isDisposedInternal = true;\n  }\n\n  protected isDisposedInternal = false;\n  get isDisposed(): boolean {\n    return this.isDisposedInternal;\n  }\n\n  throwIfDisposed() {\n    if (this.isDisposed) {\n      throw new Error(`Tensor is disposed.`);\n    }\n  }\n\n  /**\n   * Prints the `tf.Tensor`. See `tf.print` for details.\n   *\n   * @param verbose Whether to print verbose information about the tensor,\n   *    including dtype and size.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  print(verbose = false): void {\n    return opHandler.print(this, verbose);\n  }\n\n  /**\n   * Returns a copy of the tensor. See `tf.clone` for details.\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  clone<T extends Tensor>(this: T): T {\n    this.throwIfDisposed();\n    return opHandler.clone(this);\n  }\n\n  /**\n   * Returns a human-readable description of the tensor. Useful for logging.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  toString(verbose = false): string {\n    const vals = this.dataSync();\n    return tensorToString(vals, this.shape, this.dtype, verbose);\n  }\n\n  cast<T extends this>(dtype: DataType): T {\n    this.throwIfDisposed();\n    return opHandler.cast(this as T, dtype);\n  }\n  variable(trainable = true, name?: string, dtype?: DataType): Variable<R> {\n    this.throwIfDisposed();\n    return trackerFn().makeVariable(this, trainable, name, dtype) as\n        Variable<R>;\n  }\n}\nObject.defineProperty(Tensor, Symbol.hasInstance, {\n  value: (instance: Tensor) => {\n    // Implementation note: we should use properties of the object that will be\n    // defined before the constructor body has finished executing (methods).\n    // This is because when this code is transpiled by babel, babel will call\n    // classCallCheck before the constructor body is run.\n    // See https://github.com/tensorflow/tfjs/issues/3384 for backstory.\n    return !!instance && instance.data != null && instance.dataSync != null &&\n        instance.throwIfDisposed != null;\n  }\n});\n\nexport function getGlobalTensorClass() {\n  // Use getGlobal so that we can augment the Tensor class across package\n  // boundaries becase the node resolution alg may result in different modules\n  // being returned for this file depending on the path they are loaded from.\n  return getGlobal('Tensor', () => {\n    return Tensor;\n  });\n}\n\n// Global side effect. Cache global reference to Tensor class\ngetGlobalTensorClass();\n\nexport interface NumericTensor<R extends Rank = Rank> extends Tensor<R> {\n  dtype: NumericDataType;\n  dataSync<D extends DataType = NumericDataType>(): DataTypeMap[D];\n  data<D extends DataType = NumericDataType>(): Promise<DataTypeMap[D]>;\n}\n\nexport interface StringTensor<R extends Rank = Rank> extends Tensor<R> {\n  dtype: 'string';\n  dataSync<D extends DataType = 'string'>(): DataTypeMap[D];\n  data<D extends DataType = 'string'>(): Promise<DataTypeMap[D]>;\n}\n\n/** @doclink Tensor */\nexport type Scalar = Tensor<Rank.R0>;\n/** @doclink Tensor */\nexport type Tensor1D = Tensor<Rank.R1>;\n/** @doclink Tensor */\nexport type Tensor2D = Tensor<Rank.R2>;\n/** @doclink Tensor */\nexport type Tensor3D = Tensor<Rank.R3>;\n/** @doclink Tensor */\nexport type Tensor4D = Tensor<Rank.R4>;\n/** @doclink Tensor */\nexport type Tensor5D = Tensor<Rank.R5>;\n/** @doclink Tensor */\nexport type Tensor6D = Tensor<Rank.R6>;\n\n/**\n * A mutable `tf.Tensor`, useful for persisting state, e.g. for training.\n *\n * @doc {heading: 'Tensors', subheading: 'Classes'}\n */\nexport class Variable<R extends Rank = Rank> extends Tensor<R> {\n  name: string;\n\n  constructor(\n      initialValue: Tensor<R>, public trainable: boolean, name: string,\n      tensorId: number) {\n    super(\n        initialValue.shape, initialValue.dtype, initialValue.dataId, tensorId);\n    this.name = name;\n  }\n\n  /**\n   * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have\n   * the same shape and dtype as the old `tf.Tensor`.\n   *\n   * @param newValue New tensor to be assigned to this variable.\n   *\n   * @doc {heading: 'Tensors', subheading: 'Classes'}\n   */\n  assign(newValue: Tensor<R>): void {\n    if (newValue.dtype !== this.dtype) {\n      throw new Error(\n          `dtype of the new value (${newValue.dtype}) and ` +\n          `previous value (${this.dtype}) must match`);\n    }\n    if (!util.arraysEqual(newValue.shape, this.shape)) {\n      throw new Error(\n          `shape of the new value (${newValue.shape}) and ` +\n          `previous value (${this.shape}) must match`);\n    }\n    trackerFn().disposeTensor(this);\n    this.dataId = newValue.dataId;\n    trackerFn().incRef(this, null /* backend */);\n  }\n\n  dispose(): void {\n    trackerFn().disposeVariable(this);\n    this.isDisposedInternal = true;\n  }\n}\n\nObject.defineProperty(Variable, Symbol.hasInstance, {\n  value: (instance: Variable) => {\n    return instance instanceof Tensor && instance.assign != null &&\n        instance.assign instanceof Function;\n  }\n});\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/** @docalias number[] */\nexport interface ShapeMap {\n  R0: number[];\n  R1: [number];\n  R2: [number, number];\n  R3: [number, number, number];\n  R4: [number, number, number, number];\n  R5: [number, number, number, number, number];\n  R6: [number, number, number, number, number, number];\n}\n\n/** @docalias number[] */\nexport interface ArrayMap {\n  R0: number;\n  R1: number[];\n  R2: number[][];\n  R3: number[][][];\n  R4: number[][][][];\n  R5: number[][][][][];\n  R6: number[][][][][][];\n}\n\nexport interface DataTypeMap {\n  float32: Float32Array;\n  int32: Int32Array;\n  bool: Uint8Array;\n  complex64: Float32Array;\n  string: string[];\n}\n\nexport interface SingleValueMap {\n  bool: boolean;\n  int32: number;\n  float32: number;\n  complex64: number;\n  string: string;\n}\n\n/** @docalias 'float32'|'int32'|'bool'|'complex64'|'string' */\nexport type DataType = keyof DataTypeMap;\nexport type NumericDataType = 'float32'|'int32'|'bool'|'complex64';\nexport type TypedArray = Float32Array|Int32Array|Uint8Array;\n/** Tensor data used in tensor creation and user-facing API. */\nexport type DataValues = DataTypeMap[DataType];\n/** The underlying tensor data that gets stored in a backend. */\nexport type BackendValues = Float32Array|Int32Array|Uint8Array|Uint8Array[];\n\nexport enum Rank {\n  R0 = 'R0',\n  R1 = 'R1',\n  R2 = 'R2',\n  R3 = 'R3',\n  R4 = 'R4',\n  R5 = 'R5',\n  R6 = 'R6'\n}\n\nexport type FlatVector = boolean[]|number[]|TypedArray;\nexport type RegularArray<T> =\n    T[]|T[][]|T[][][]|T[][][][]|T[][][][][]|T[][][][][][];\n\n// tslint:disable-next-line:no-any\nexport interface RecursiveArray<T extends any> {\n  [index: number]: T|RecursiveArray<T>;\n}\n\n// Looks for upcasting types. Used, for example, in operations with mixed dtype\n// inputs.\nenum UpcastInt32AndMap {\n  'float32' = 'float32',\n  'int32' = 'int32',\n  'bool' = 'int32',\n  'complex64' = 'complex64'\n}\n\nenum UpcastBoolAndMap {\n  'float32' = 'float32',\n  'int32' = 'int32',\n  'bool' = 'bool',\n  'complex64' = 'complex64'\n}\n\nenum UpcastFloat32AndMap {\n  'float32' = 'float32',\n  'int32' = 'float32',\n  'bool' = 'float32',\n  'complex64' = 'complex64'\n}\n\nenum UpcastComplex64AndMap {\n  'float32' = 'complex64',\n  'int32' = 'complex64',\n  'bool' = 'complex64',\n  'complex64' = 'complex64'\n}\n\nconst upcastTypeMap = {\n  'float32': UpcastFloat32AndMap,\n  'int32': UpcastInt32AndMap,\n  'bool': UpcastBoolAndMap,\n  'complex64': UpcastComplex64AndMap\n};\n\nexport function upcastType(typeA: DataType, typeB: DataType): DataType {\n  if (typeA === 'string' || typeB === 'string') {\n    if (typeA === 'string' && typeB === 'string') {\n      return 'string';\n    }\n    throw new Error(`Can not upcast ${typeA} with ${typeB}`);\n  }\n  return upcastTypeMap[typeA][typeB];\n}\n\n/** Returns the output type after summation. */\nexport function sumOutType(type: DataType): DataType {\n  return upcastType(type, 'int32');\n}\n\n/** @docalias TypedArray|Array */\nexport type TensorLike =\n    TypedArray|number|boolean|string|RecursiveArray<number|number[]|TypedArray>|\n    RecursiveArray<boolean>|RecursiveArray<string>|Uint8Array[];\nexport type ScalarLike = number|boolean|string|Uint8Array;\n/** @docalias TypedArray|Array */\nexport type TensorLike1D = TypedArray|number[]|boolean[]|string[]|Uint8Array[];\n/** @docalias TypedArray|Array */\nexport type TensorLike2D = TypedArray|number[]|number[][]|boolean[]|boolean[][]|\n    string[]|string[][]|Uint8Array[]|Uint8Array[][];\n/** @docalias TypedArray|Array */\nexport type TensorLike3D = TypedArray|number[]|number[][][]|boolean[]|\n    boolean[][][]|string[]|string[][][]|Uint8Array[]|Uint8Array[][][];\n/** @docalias TypedArray|Array */\nexport type TensorLike4D = TypedArray|number[]|number[][][][]|boolean[]|\n    boolean[][][][]|string[]|string[][][][]|Uint8Array[]|Uint8Array[][][][];\n/** @docalias TypedArray|Array */\nexport type TensorLike5D =\n    TypedArray|number[]|number[][][][][]|boolean[]|boolean[][][][][]|string[]|\n    string[][][][][]|Uint8Array[]|Uint8Array[][][][][];\n/** @docalias TypedArray|Array */\nexport type TensorLike6D =\n    TypedArray|number[]|number[][][][][][]|boolean[]|boolean[][][][][][]|\n    string[]|string[][][][][][]|Uint8Array[]|Uint8Array[][][][][];\n\n/** Type for representing image data in Uint8Array type. */\nexport interface PixelData {\n  width: number;\n  height: number;\n  data: Uint8Array;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from './tensor';\nimport {TensorContainer, TensorContainerArray} from './tensor_types';\nimport {upcastType} from './types';\nimport {assert} from './util';\n\nexport function makeTypesMatch<T extends Tensor>(a: T, b: T): [T, T] {\n  if (a.dtype === b.dtype) {\n    return [a, b];\n  }\n  const dtype = upcastType(a.dtype, b.dtype);\n  return [a.cast(dtype), b.cast(dtype)];\n}\n\nexport function assertTypesMatch(a: Tensor, b: Tensor): void {\n  assert(\n      a.dtype === b.dtype,\n      () => `The dtypes of the first(${a.dtype}) and` +\n          ` second(${b.dtype}) input must match`);\n}\n\nexport function isTensorInList(tensor: Tensor, tensorList: Tensor[]): boolean {\n  return tensorList.some(x => x.id === tensor.id);\n}\n\n/**\n * Extracts any `Tensor`s found within the provided object.\n *\n * @param container an object that may be a `Tensor` or may directly contain\n *   `Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. In general it\n *   is safe to pass any object here, except that `Promise`s are not\n *   supported.\n * @returns An array of `Tensors` found within the passed object. If the\n *   argument is simply a `Tensor', a list containing that `Tensor` is\n *   returned. If the object is not a `Tensor` or does not\n *   contain `Tensors`, an empty list is returned.\n */\nexport function getTensorsInContainer(result: TensorContainer): Tensor[] {\n  const list: Tensor[] = [];\n  const seen = new Set<{}|void>();\n  walkTensorContainer(result, list, seen);\n  return list;\n}\n\nfunction walkTensorContainer(\n    container: TensorContainer, list: Tensor[], seen: Set<{}|void>): void {\n  if (container == null) {\n    return;\n  }\n  if (container instanceof Tensor) {\n    list.push(container);\n    return;\n  }\n  if (!isIterable(container)) {\n    return;\n  }\n  // Iteration over keys works also for arrays.\n  const iterable = container as TensorContainerArray;\n  for (const k in iterable) {\n    const val = iterable[k];\n    if (!seen.has(val)) {\n      seen.add(val);\n      walkTensorContainer(val, list, seen);\n    }\n  }\n}\n\n// tslint:disable-next-line:no-any\nfunction isIterable(obj: any): boolean {\n  return Array.isArray(obj) || typeof obj === 'object';\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BackendTimingInfo, DataMover, KernelBackend} from './backends/backend';\nimport {Environment, setEnvironmentGlobal} from './environment';\nimport {getGlobalNamespace} from './global_util';\nimport {Add, Cast, Identity} from './kernel_names';\nimport {getGradient, getKernel, getKernelsForBackend, GradFunc, NamedAttrMap, TensorInfo} from './kernel_registry';\nimport {KernelProfile, Profiler} from './profiler';\nimport {backpropagateGradients, getFilteredNodesXToY, TapeNode} from './tape';\nimport {DataId, setTensorTracker, Tensor, TensorTracker, Variable} from './tensor';\nimport {GradSaveFunc, NamedTensorMap, NamedVariableMap, TensorContainer} from './tensor_types';\nimport {getTensorsInContainer} from './tensor_util';\nimport {BackendValues, DataType, DataValues} from './types';\nimport * as util from './util';\nimport {bytesFromStringArray, makeOnesTypedArray, now, sizeFromShape} from './util';\nimport * as log from './log';\n/**\n * A function that computes an output. The save function is for saving tensors\n * computed in the forward pass, that we need in the backward pass.\n */\nexport type ForwardFunc<T> = (backend: KernelBackend, save?: GradSaveFunc) => T;\n\n/**\n * @docalias (a: Tensor, b: Tensor,..., save?: Function) => {\n *   value: Tensor,\n *   gradFunc: (dy: Tensor, saved?: NamedTensorMap) => Tensor | Tensor[]\n * }\n */\nexport type CustomGradientFunc<T extends Tensor> =\n    (...inputs: Array<Tensor|GradSaveFunc>) => {\n      value: T;\n      gradFunc: (dy: T, saved: Tensor[]) => Tensor | Tensor[];\n    };\n\nexport type MemoryInfo = {\n  numTensors: number; numDataBuffers: number; numBytes: number;\n  unreliable?: boolean; reasons: string[];\n};\n\ntype KernelInfo = {\n  name: string; bytesAdded: number; totalBytesSnapshot: number;\n  tensorsAdded: number;\n  totalTensorsSnapshot: number;\n  inputShapes: number[][];\n  outputShapes: number[][];\n  kernelTimeMs: number | {error: string} | Promise<number|{error: string}>;\n  extraInfo: string | Promise<string>;\n};\n\nexport type ProfileInfo = {\n  newBytes: number; newTensors: number; peakBytes: number;\n  kernels: KernelInfo[];\n  result: TensorContainer;\n  kernelNames: string[];\n};\n\nexport interface TimingInfo extends BackendTimingInfo {\n  wallMs: number;\n}\n\n/** @docalias Function */\nexport type ScopeFn<T extends TensorContainer> = () => T;\n\ninterface ScopeState {\n  track: Tensor[];\n  name: string;\n  id: number;\n}\n\ninterface RegisteredKernelInvocation<I extends NamedTensorMap> {\n  kernelName: string;\n  inputs: I;\n  attrs?: NamedAttrMap;\n}\n\ninterface CustomGradKernelInvocation<T extends Tensor|Tensor[],\n                                               I extends NamedTensorMap> {\n  forwardFunc: ForwardFunc<T>;\n  backwardsFunc: (dy: T, saved: Tensor[]) => {\n    [P in keyof I]: () => I[P]\n  };\n  inputs: I;\n  attrs?: NamedAttrMap;\n}\n\nfunction isRegisteredKernelInvocation<T extends Tensor|Tensor[],\n                                                I extends NamedTensorMap>(\n    kernelInvocation: RegisteredKernelInvocation<I>|\n    CustomGradKernelInvocation<T, I>):\n    kernelInvocation is RegisteredKernelInvocation<I> {\n  return (kernelInvocation as RegisteredKernelInvocation<I>).kernelName != null;\n}\n\nclass EngineState {\n  // Public since optimizers will use it.\n  registeredVariables: NamedVariableMap = {};\n\n  nextTapeNodeId = 0;\n  numBytes = 0;\n  numTensors = 0;\n  numStringTensors = 0;\n  numDataBuffers = 0;\n\n  activeTape: TapeNode[];\n  // Number of nested tf.grad() statements when computing higher-order\n  // gradients. E.g. `1` for first-order gradients and `2` for second-order\n  // gradients. Used to track if the tape should be removed after a backprop.\n  gradientDepth = 0;\n  // Number of nested kernel calls. When kernel depth is greater than 1, we turn\n  // off the tape.\n  kernelDepth = 0;\n\n  // Keep Tensors that parallel the tapes.\n  activeScope: ScopeState;\n  scopeStack: ScopeState[] = [];\n  /**\n   * Keeps track of the number of data moves during a kernel execution. We\n   * maintain a stack since kernels can call other kernels, recursively.\n   */\n  numDataMovesStack: number[] = [];\n  nextScopeId = 0;\n\n  tensorInfo = new WeakMap<DataId, {\n    backend: KernelBackend,\n    bytes: number,\n    dtype: DataType,\n    shape: number[]\n  }>();\n\n  profiling = false;\n  activeProfile: ProfileInfo = {\n    newBytes: 0,\n    newTensors: 0,\n    peakBytes: 0,\n    kernels: [],\n    result: null,\n    get kernelNames():\n        string[] {\n          return Array.from(new Set(this.kernels.map(k => k.name)));\n        }\n  };\n\n  dispose() {\n    for (const variableName in this.registeredVariables) {\n      this.registeredVariables[variableName].dispose();\n    }\n  }\n}\n\nexport class Engine implements TensorTracker, DataMover {\n  state: EngineState;\n  backendName: string;\n  registry: {[id: string]: KernelBackend} = {};\n  registryFactory: {\n    [id: string]: {\n      factory: () => KernelBackend | Promise<KernelBackend>,\n      priority: number\n    }\n  } = {};\n\n  private profiler: Profiler;\n  private backendInstance: KernelBackend;\n  private pendingBackendInit: Promise<boolean>;\n  private pendingBackendInitId = 0;\n\n  constructor(public ENV: Environment) {\n    this.state = new EngineState();\n  }\n\n  async ready(): Promise<void> {\n    if (this.pendingBackendInit != null) {\n      return this.pendingBackendInit.then(() => {});\n    }\n    if (this.backendInstance != null) {\n      return;\n    }\n    const sortedBackends = this.getSortedBackends();\n\n    for (let i = 0; i < sortedBackends.length; i++) {\n      const backendName = sortedBackends[i];\n      const success = await this.initializeBackend(backendName).success;\n      if (success) {\n        await this.setBackend(backendName);\n        return;\n      }\n    }\n\n    throw new Error(\n        `Could not initialize any backends, all backend initializations ` +\n        `failed.`);\n  }\n\n  get backend(): KernelBackend {\n    if (this.pendingBackendInit != null) {\n      throw new Error(\n          `Backend '${this.backendName}' has not yet been initialized. Make ` +\n          `sure to await tf.ready() or await tf.setBackend() before calling ` +\n          `other methods`);\n    }\n    if (this.backendInstance == null) {\n      const {name, asyncInit} = this.initializeBackendsAndReturnBest();\n      if (asyncInit) {\n        throw new Error(\n            `The highest priority backend '${name}' has not yet been ` +\n            `initialized. Make sure to await tf.ready() or ` +\n            `await tf.setBackend() before calling other methods`);\n      }\n      this.setBackend(name);\n    }\n    return this.backendInstance;\n  }\n\n  backendNames(): string[] {\n    return Object.keys(this.registryFactory);\n  }\n\n  findBackend(backendName: string): KernelBackend {\n    if (!(backendName in this.registry)) {\n      // If the backend hasn't been initialized but we have a registry entry for\n      // it, initialize it and return it.\n      if (backendName in this.registryFactory) {\n        const {asyncInit} = this.initializeBackend(backendName);\n        if (asyncInit) {\n          // Backend is not ready yet.\n          return null;\n        }\n      } else {\n        return null;\n      }\n    }\n    return this.registry[backendName];\n  }\n\n  findBackendFactory(backendName: string):\n      () => KernelBackend | Promise<KernelBackend> {\n    if (!(backendName in this.registryFactory)) {\n      return null;\n    }\n    return this.registryFactory[backendName].factory;\n  }\n\n  registerBackend(\n      backendName: string,\n      factory: () => KernelBackend | Promise<KernelBackend>,\n      priority = 1): boolean {\n    if (backendName in this.registryFactory) {\n      log.warn(\n          `${backendName} backend was already registered. ` +\n          `Reusing existing backend factory.`);\n      return false;\n    }\n    this.registryFactory[backendName] = {factory, priority};\n    return true;\n  }\n\n  async setBackend(backendName: string): Promise<boolean> {\n    if (this.registryFactory[backendName] == null) {\n      throw new Error(`Backend name '${backendName}' not found in registry`);\n    }\n    this.backendName = backendName;\n    if (this.registry[backendName] == null) {\n      this.backendInstance = null;\n      const {success, asyncInit} = this.initializeBackend(backendName);\n      const result = asyncInit ? await success : success;\n      if (!result) {\n        return false;\n      }\n    }\n    this.backendInstance = this.registry[backendName];\n    this.setupRegisteredKernels();\n    // Reset the profiler.\n    this.profiler = new Profiler(this.backendInstance);\n\n    return true;\n  }\n\n  private setupRegisteredKernels(): void {\n    const kernels = getKernelsForBackend(this.backendName);\n    kernels.forEach(kernel => {\n      if (kernel.setupFunc != null) {\n        kernel.setupFunc(this.backendInstance);\n      }\n    });\n  }\n\n  private disposeRegisteredKernels(backendName: string): void {\n    const kernels = getKernelsForBackend(backendName);\n    kernels.forEach(kernel => {\n      if (kernel.disposeFunc != null) {\n        kernel.disposeFunc(this.registry[backendName]);\n      }\n    });\n  }\n\n  /**\n   * Initializes a backend by looking up the backend name in the factory\n   * registry and calling the factory method. Returns a boolean representing\n   * whether the initialization of the backend suceeded. Throws an error if\n   * there is no backend in the factory registry.\n   */\n  private initializeBackend(backendName: string):\n      {success: boolean|Promise<boolean>, asyncInit: boolean} {\n    const registryFactoryEntry = this.registryFactory[backendName];\n    if (registryFactoryEntry == null) {\n      throw new Error(\n          `Cannot initialize backend ${backendName}, no registration found.`);\n    }\n\n    try {\n      const backend = registryFactoryEntry.factory();\n      /* Test if the factory returns a promise.\n      Done in a more liberal way than\n      previous 'Promise.resolve(backend)===backend'\n      as we needed to account for custom Promise\n      implementations (e.g. Angular) */\n      if (backend && !(backend instanceof KernelBackend) &&\n          typeof backend.then === 'function') {\n        const promiseId = ++this.pendingBackendInitId;\n        const success =\n            backend\n                .then(backendInstance => {\n                  // Outdated promise. Another backend was set in the meantime.\n                  if (promiseId < this.pendingBackendInitId) {\n                    return false;\n                  }\n                  this.registry[backendName] = backendInstance;\n                  this.pendingBackendInit = null;\n                  return true;\n                })\n                .catch(err => {\n                  // Outdated promise. Another backend was set in the meantime.\n                  if (promiseId < this.pendingBackendInitId) {\n                    return false;\n                  }\n                  this.pendingBackendInit = null;\n                  log.warn(\n                      `Initialization of backend ${backendName} failed`);\n                  log.warn(err.stack || err.message);\n                  return false;\n                });\n        this.pendingBackendInit = success;\n        return {success, asyncInit: true};\n      } else {\n        this.registry[backendName] = backend as KernelBackend;\n        return {success: true, asyncInit: false};\n      }\n    } catch (err) {\n      log.warn(`Initialization of backend ${backendName} failed`);\n      log.warn(err.stack || err.message);\n      return {success: false, asyncInit: false};\n    }\n  }\n\n  removeBackend(backendName: string): void {\n    if (!(backendName in this.registryFactory)) {\n      throw new Error(`${backendName} backend not found in registry`);\n    }\n    if (this.backendName === backendName && this.pendingBackendInit != null) {\n      // There is a pending promise of the backend we want to remove. Make it\n      // obsolete.\n      this.pendingBackendInitId++;\n    }\n\n    if (backendName in this.registry) {\n      this.disposeRegisteredKernels(backendName);\n      this.registry[backendName].dispose();\n      delete this.registry[backendName];\n    }\n\n    delete this.registryFactory[backendName];\n\n    // Unset the backend if it is active.\n    if (this.backendName === backendName) {\n      this.pendingBackendInit = null;\n      this.backendName = null;\n      this.backendInstance = null;\n    }\n  }\n\n  private getSortedBackends(): string[] {\n    if (Object.keys(this.registryFactory).length === 0) {\n      throw new Error('No backend found in registry.');\n    }\n    return Object.keys(this.registryFactory).sort((a: string, b: string) => {\n      // Highest priority comes first.\n      return this.registryFactory[b].priority -\n          this.registryFactory[a].priority;\n    });\n  }\n\n  private initializeBackendsAndReturnBest():\n      {name: string, asyncInit: boolean} {\n    const sortedBackends = this.getSortedBackends();\n\n    for (let i = 0; i < sortedBackends.length; i++) {\n      const backendName = sortedBackends[i];\n      const {success, asyncInit} = this.initializeBackend(backendName);\n      if (asyncInit || success) {\n        return {name: backendName, asyncInit};\n      }\n    }\n    throw new Error(\n        `Could not initialize any backends, all backend initializations ` +\n        `failed.`);\n  }\n\n  moveData(backend: KernelBackend, dataId: DataId) {\n    const info = this.state.tensorInfo.get(dataId);\n    const srcBackend = info.backend;\n    const values = this.readSync(dataId);\n    const refCount = srcBackend.refCount(dataId);\n    // Delete the tensor from the old backend and move it to the new\n    // backend.\n    srcBackend.disposeData(dataId, true);\n    info.backend = backend;\n    backend.move(dataId, values, info.shape, info.dtype, refCount);\n    if (this.shouldCheckForMemLeaks()) {\n      // Track the number of moves during a kernel execution to correctly\n      // detect memory leaks.\n      this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1]++;\n    }\n  }\n\n  tidy<T extends TensorContainer>(nameOrFn: string|ScopeFn<T>, fn?: ScopeFn<T>):\n      T {\n    let name: string = null;\n    if (fn == null) {\n      // Called with only 1 argument.\n      if (typeof nameOrFn !== 'function') {\n        throw new Error('Please provide a function to tidy()');\n      }\n      fn = nameOrFn;\n    } else {\n      // Called with 2 arguments.\n      if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {\n        throw new Error(\n            'When calling with two arguments, the first argument ' +\n            'to tidy() must be a string');\n      }\n      if (typeof fn !== 'function') {\n        throw new Error(\n            'When calling with two arguments, the 2nd argument ' +\n            'to tidy() must be a function');\n      }\n      name = nameOrFn as string;\n      // TODO(nsthorat,smilkov): Do operation logging and performance\n      // profiling.\n    }\n    let result: T;\n    return this.scopedRun(\n        () => this.startScope(name), () => this.endScope(result), () => {\n          result = fn();\n          if (result instanceof Promise) {\n            console.error('Cannot return a Promise inside of tidy.');\n          }\n          return result;\n        });\n  }\n\n  private scopedRun<T>(start: () => void, end: () => void, f: () => T): T {\n    start();\n    try {\n      const res = f();\n      end();\n      return res;\n    } catch (ex) {\n      end();\n      throw ex;\n    }\n  }\n\n  private static nextTensorId = 0;\n  private nextTensorId(): number {\n    return Engine.nextTensorId++;\n  }\n\n  private static nextVariableId = 0;\n  private nextVariableId(): number {\n    return Engine.nextVariableId++;\n  }\n\n  /**\n   * This method is called instead of the public-facing tensor.clone() when\n   * saving a tensor for backwards pass. It makes sure to add the clone\n   * operation to the tape regardless of being called inside a kernel\n   * execution.\n   */\n  private clone(x: Tensor): Tensor {\n    const y: Tensor = ENGINE.runKernel(Identity, {x} as {} as NamedTensorMap);\n    const inputs = {x};\n    const grad = (dy: Tensor) => ({\n      x: () => {\n        const dtype = 'float32';\n        const gradInputs = {x: dy};\n        const attrs = {dtype};\n\n        return ENGINE.runKernel(\n                   Cast, gradInputs as {} as NamedTensorMap,\n                   // tslint:disable-next-line: no-unnecessary-type-assertion\n                   attrs as {} as NamedAttrMap) as Tensor;\n      }\n    });\n    const saved: Tensor[] = [];\n    this.addTapeNode(this.state.activeScope.name, inputs, [y], grad, saved, {});\n    return y;\n  }\n\n  /**\n   * Execute a kernel with the given name and return the output tensor.\n   *\n   * @param kernelName The name of the kernel to execute.\n   * @param inputs A map of input names to tensors.\n   * @param attrs A map of attribute names to their values. An attribute is a\n   *     primitive (non-tensor) input to the kernel.\n   * @param inputsToSave A list of tensors, inputs to save for the backprop\n   *     computation.\n   * @param outputsToSave A list of booleans, specifying which output to save\n   *     for the backprop computation. These are booleans since the output\n   * tensors are not visible to the user.\n   */\n  runKernel<T extends Tensor|Tensor[]>(\n      kernelName: string, inputs: NamedTensorMap, attrs?: NamedAttrMap): T {\n    if (this.backendName == null) {\n      // backend has not been initialized yet (backend initialization is lazy\n      // can be deferred until an op/ kernel is run).\n      // The below getter has side effects that will try to initialize the\n      // backend and set properties like this.backendName\n      // tslint:disable-next-line: no-unused-expression\n      this.backend;\n    }\n    const hasKernel = getKernel(kernelName, this.backendName) != null;\n    if (!hasKernel) {\n      throw new Error(`Kernel '${kernelName}' not registered for backend '${\n          this.backendName}'`);\n    }\n    return this.runKernelFunc({kernelName, inputs, attrs});\n  }\n\n  private shouldCheckForMemLeaks(): boolean {\n    return this.ENV.getBool('IS_TEST');\n  }\n\n  private checkKernelForMemLeak(\n      kernelName: string, numDataIdsBefore: number,\n      outInfos: TensorInfo[]): void {\n    const numDataIdsAfter = this.backend.numDataIds();\n\n    // Count the number of data ids associated with the result of the kernel.\n    let numOutputDataIds = 0;\n    outInfos.forEach(info => {\n      // Complex numbers allocate 3 data ids, one for 'real', one for\n      // 'imaginary', and one for the container that holds the former two.\n      numOutputDataIds += (info.dtype === 'complex64' ? 3 : 1);\n    });\n\n    // Account for the number of moves during kernel execution. A \"data move\"\n    // can happen in the middle of a kernel execution, placing a new (key,value)\n    // pair in the data storage. Since data moves have net zero effect (we\n    // always remove the data from the old backend), we have to cancel them out\n    // when detecting memory leaks.\n    const numMoves =\n        this.state.numDataMovesStack[this.state.numDataMovesStack.length - 1];\n    const dataIdsLeaked =\n        numDataIdsAfter - numDataIdsBefore - numOutputDataIds - numMoves;\n    if (dataIdsLeaked > 0) {\n      throw new Error(\n          `Backend '${this.backendName}' has an internal memory leak ` +\n          `(${dataIdsLeaked} data ids) after running '${kernelName}'`);\n    }\n  }\n\n  /**\n   * Internal helper method to execute a kernel Func\n   *\n   * Use `runKernel` to execute kernels from outside of engine.\n   */\n  private runKernelFunc<T extends Tensor|Tensor[], I extends NamedTensorMap>(\n      kernelParams: RegisteredKernelInvocation<I>|\n      CustomGradKernelInvocation<T, I>): T {\n    let outputs: Tensor[];\n    let saved: Tensor[] = [];\n    const isTapeOn = this.isTapeOn();\n\n    const startingBytecount = this.state.numBytes;\n    const startingNumTensors = this.state.numTensors;\n\n    if (this.shouldCheckForMemLeaks()) {\n      this.state.numDataMovesStack.push(0);\n    }\n\n    let kernelFunc: () => Tensor[];\n    if (this.backendName == null) {\n      // backend has not been initialized yet (backend initialization is lazy\n      // can be deferred until an op/ kernel is run).\n      // The below getter has side effects that will try to initialize the\n      // backend and set properties like this.backendName\n      // tslint:disable-next-line: no-unused-expression\n      this.backend;\n    }\n\n    let out: TensorInfo|TensorInfo[];\n\n    const kernelOrScopeName = isRegisteredKernelInvocation(kernelParams) ?\n        kernelParams.kernelName :\n        this.state.activeScope != null ? this.state.activeScope.name : '';\n\n    // Create the kernelFunc from either a registered kernel OR passed in\n    // forward/backward functions (used by custom grad). In this context a\n    // kernelFunc wraps a kernel implementation with some bookkeeping.\n\n    if (isRegisteredKernelInvocation(kernelParams)) {\n      const {kernelName, inputs, attrs} = kernelParams;\n      if (this.backendName == null) {\n        // backend has not been initialized yet (backend initialization is lazy\n        // can be deferred until an op/ kernel is run).\n        // The below getter has side effects that will try to initialize the\n        // backend and set properties like this.backendName\n        // tslint:disable-next-line: no-unused-expression\n        this.backend;\n      }\n      const kernel = getKernel(kernelName, this.backendName);\n      util.assert(\n          kernel != null,\n          () => `Cannot find registered kernel '${kernelName}' for backend '${\n              this.backendName}'`);\n\n      kernelFunc = () => {\n        const numDataIdsBefore = this.backend.numDataIds();\n        out = kernel.kernelFunc({inputs, attrs, backend: this.backend});\n        const outInfos = Array.isArray(out) ? out : [out];\n        if (this.shouldCheckForMemLeaks()) {\n          this.checkKernelForMemLeak(kernelName, numDataIdsBefore, outInfos);\n        }\n\n        const outTensors = outInfos.map((outInfo: TensorInfo|Tensor) => {\n          // todo (yassogba) remove this option (Tensor) when node backend\n          // methods have been modularized and they all return tensorInfo.\n          // TensorInfos do not have a rank attribute.\n          if ((outInfo as Tensor).rank != null) {\n            return outInfo as Tensor;\n          }\n          const {dataId, shape, dtype} = outInfo as TensorInfo;\n          return this.makeTensorFromDataId(dataId, shape, dtype);\n        });\n\n        // Save any required inputs and outputs.\n\n        // Do not save unless we are recording to the tape. Otherwise it would\n        // cause a mem leak since there would be no backprop for these tensors\n        // (which would otherwise dispose them).\n        if (isTapeOn) {\n          const tensorsToSave =\n              this.getTensorsForGradient(kernelName, inputs, outTensors);\n          saved = this.saveTensorsForBackwardMode(tensorsToSave);\n        }\n        return outTensors;\n      };\n    } else {\n      const {forwardFunc} = kernelParams;\n      // Running a customGrad op.\n      const saveFunc: GradSaveFunc = (tensors) => {\n        // Do not save unless we are recording to the tape. Otherwise it would\n        // cause a mem leak since we would never run backprop, which disposes\n        // the kept tensors.\n        if (!isTapeOn) {\n          return;\n        }\n        saved = tensors.map(tensor => this.keep(this.clone(tensor)));\n      };\n\n      kernelFunc = () => {\n        const numDataIdsBefore = this.backend.numDataIds();\n        out = this.tidy(() => forwardFunc(this.backend, saveFunc));\n        const outs = (Array.isArray(out) ? out : [out]) as Tensor[];\n        if (this.shouldCheckForMemLeaks()) {\n          // Scope name is used to print a more helpful error message if needed.\n          this.checkKernelForMemLeak(kernelOrScopeName, numDataIdsBefore, outs);\n        }\n        return outs;\n      };\n    }\n\n    //\n    // Run the kernelFunc. Optionally profiling it.\n    //\n    const {inputs, attrs} = kernelParams;\n    const backwardsFunc = isRegisteredKernelInvocation(kernelParams) ?\n        null :\n        kernelParams.backwardsFunc;\n\n    let kernelProfile: KernelProfile;\n    this.scopedRun(\n        // Stop recording to a tape when running a kernel.\n        () => this.state.kernelDepth++, () => this.state.kernelDepth--, () => {\n          if (!this.ENV.getBool('DEBUG') && !this.state.profiling) {\n            outputs = kernelFunc();\n          } else {\n            kernelProfile = this.profiler.profileKernel(\n                kernelOrScopeName, inputs, () => kernelFunc());\n            if (this.ENV.getBool('DEBUG')) {\n              this.profiler.logKernelProfile(kernelProfile);\n            }\n            outputs = kernelProfile.outputs;\n          }\n        });\n\n    if (isTapeOn) {\n      this.addTapeNode(\n          kernelOrScopeName, inputs, outputs, backwardsFunc, saved, attrs);\n    }\n\n    if (this.state.profiling) {\n      this.state.activeProfile.kernels.push({\n        name: kernelOrScopeName,\n        bytesAdded: this.state.numBytes - startingBytecount,\n        totalBytesSnapshot: this.state.numBytes,\n        tensorsAdded: this.state.numTensors - startingNumTensors,\n        totalTensorsSnapshot: this.state.numTensors,\n        inputShapes: Object.keys(inputs).map(\n            key => inputs[key] != null ? inputs[key].shape : null),\n        outputShapes: outputs.map(item => item.shape),\n        kernelTimeMs: kernelProfile.timeMs,\n        extraInfo: kernelProfile.extraInfo\n      });\n    }\n    return (Array.isArray(out) ? outputs : outputs[0]) as T;\n  }\n\n  /**\n   * Saves tensors used in forward mode for use in backward mode.\n   *\n   * @param tensors the list of tensors to save.\n   */\n  private saveTensorsForBackwardMode(tensors: Tensor[]): Tensor[] {\n    const saved = tensors.map(tensor => this.keep(this.clone(tensor)));\n    return saved;\n  }\n\n  /**\n   * Returns a list of tensors to save for a given gradient calculation.\n   *\n   * @param kernelName name of kernel to look up gradient for.\n   * @param inputs a map of input tensors.\n   * @param outputs an array of output tensors from forward mode of kernel.\n   */\n  private getTensorsForGradient(\n      kernelName: string, inputs: NamedTensorMap,\n      outputs: Tensor[]): Tensor[]|null {\n    const gradConfig = getGradient(kernelName);\n    if (gradConfig != null) {\n      const inputsToSave: string[] = gradConfig.inputsToSave || [];\n      const outputsToSave: boolean[] = gradConfig.outputsToSave || [];\n\n      // If saveAllInputs is true, all inputs will be saved. Otherwise, inputs\n      // specified in inputsToSave will be saved.\n      let inputTensorsToSave: Tensor[];\n      if (gradConfig.saveAllInputs) {\n        util.assert(\n            Array.isArray(inputs),\n            () => 'saveAllInputs is true, expected inputs to be an array.');\n\n        inputTensorsToSave = Object.keys(inputs).map((key) => inputs[key]);\n      } else {\n        inputTensorsToSave = inputsToSave.map((inputName) => inputs[inputName]);\n      }\n\n      const outputTensorsToSave: Tensor[] =\n          outputs.filter((_, i) => outputsToSave[i]);\n\n      return inputTensorsToSave.concat(outputTensorsToSave);\n    }\n    // We return an empty list rather than throw an error because the kernel we\n    // are looking up may not actually be relevant to backproping through the\n    // overall function\n    //\n    // See 'does not error if irrelevant (pruned) ops are missing grads' test\n    // in gradients_test.ts for an example.\n    return [];\n  }\n\n  /**\n   * Internal method used by public APIs for tensor creation. Makes a new\n   * tensor with the provided shape, dtype and values. It always\n   * creates a new data id and writes the values to the underlying backend.\n   */\n  makeTensor(\n      values: DataValues, shape: number[], dtype: DataType,\n      backend?: KernelBackend): Tensor {\n    if (values == null) {\n      throw new Error('Values passed to engine.makeTensor() are null');\n    }\n    dtype = dtype || 'float32';\n    backend = backend || this.backend;\n    let backendVals = values as BackendValues;\n    if (dtype === 'string' && util.isString(values[0])) {\n      backendVals = (values as string[]).map(d => util.encodeString(d));\n    }\n    const dataId = backend.write(backendVals, shape, dtype);\n    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());\n    this.trackTensor(t, backend);\n\n    // Count bytes for string tensors.\n    if (dtype === 'string') {\n      const info = this.state.tensorInfo.get(dataId);\n      const newBytes = bytesFromStringArray(backendVals as Uint8Array[]);\n      this.state.numBytes += newBytes - info.bytes;\n      info.bytes = newBytes;\n    }\n    return t;\n  }\n\n  /**\n   * Internal method used by backends. Makes a new tensor\n   * that is a wrapper around an existing data id. It doesn't create\n   * a new data id, only increments the ref count used in memory tracking.\n   */\n  makeTensorFromDataId(\n      dataId: DataId, shape: number[], dtype: DataType,\n      backend?: KernelBackend): Tensor {\n    dtype = dtype || 'float32';\n    const t = new Tensor(shape, dtype, dataId, this.nextTensorId());\n    this.trackTensor(t, backend);\n    return t;\n  }\n\n  makeVariable(\n      initialValue: Tensor, trainable = true, name?: string,\n      dtype?: DataType): Variable {\n    name = name || this.nextVariableId().toString();\n    if (dtype != null && dtype !== initialValue.dtype) {\n      initialValue = initialValue.cast(dtype);\n    }\n    const v = new Variable(initialValue, trainable, name, this.nextTensorId());\n    if (this.state.registeredVariables[v.name] != null) {\n      throw new Error(`Variable with name ${v.name} was already registered`);\n    }\n    this.state.registeredVariables[v.name] = v;\n    this.incRef(v, this.backend);\n    return v;\n  }\n\n  trackTensor(a: Tensor, backend: KernelBackend): void {\n    this.state.numTensors++;\n    if (a.dtype === 'string') {\n      this.state.numStringTensors++;\n    }\n    // Bytes for complex numbers are counted by their components. Bytes for\n    // string tensors are counted when writing values.\n    let bytes = 0;\n    if (a.dtype !== 'complex64' && a.dtype !== 'string') {\n      bytes = a.size * util.bytesPerElement(a.dtype);\n    }\n    this.state.numBytes += bytes;\n\n    if (!this.state.tensorInfo.has(a.dataId)) {\n      this.state.numDataBuffers++;\n      this.state.tensorInfo.set(a.dataId, {\n        backend: backend || this.backend,\n        dtype: a.dtype,\n        shape: a.shape,\n        bytes\n      });\n    }\n\n    if (!(a instanceof Variable)) {\n      this.track(a);\n    }\n  }\n\n  // Track the tensor by dataId and increase the refCount for the dataId in the\n  // backend.\n  // TODO(pyu10055): This is currently used by makeVariable method, to increase\n  // refCount on the backend for the dataId. It can potentially be replaced with\n  // Identity op indead of calling backend directly.\n  incRef(a: Tensor, backend: KernelBackend): void {\n    this.trackTensor(a, backend);\n    this.backend.incRef(a.dataId);\n  }\n\n  removeDataId(dataId: DataId, backend: KernelBackend) {\n    if (this.state.tensorInfo.has(dataId) &&\n        this.state.tensorInfo.get(dataId).backend === backend) {\n      this.state.tensorInfo.delete(dataId);\n      this.state.numDataBuffers--;\n    }\n  }\n  disposeTensor(a: Tensor): void {\n    if (!this.state.tensorInfo.has(a.dataId)) {\n      return;\n    }\n    const info = this.state.tensorInfo.get(a.dataId);\n\n    this.state.numTensors--;\n    if (a.dtype === 'string') {\n      this.state.numStringTensors--;\n      this.state.numBytes -= info.bytes;\n    }\n    // Don't count bytes for complex numbers as they are counted by their\n    // components.\n    if (a.dtype !== 'complex64' && a.dtype !== 'string') {\n      const bytes = a.size * util.bytesPerElement(a.dtype);\n      this.state.numBytes -= bytes;\n    }\n\n    // Remove the reference to dataId if backend dispose the data successfully\n    if (info.backend.disposeData(a.dataId)) {\n      this.removeDataId(a.dataId, info.backend);\n    }\n\n    // TODO(nsthorat): Construct an error and save the stack trace for\n    // debugging when in debug mode. Creating a stack trace is too expensive\n    // to do unconditionally.\n  }\n\n  disposeVariables(): void {\n    for (const varName in this.state.registeredVariables) {\n      const v = this.state.registeredVariables[varName];\n      this.disposeVariable(v);\n    }\n  }\n\n  disposeVariable(v: Variable): void {\n    this.disposeTensor(v);\n    if (this.state.registeredVariables[v.name] != null) {\n      delete this.state.registeredVariables[v.name];\n    }\n  }\n\n  memory(): MemoryInfo {\n    const info = this.backend.memory() as MemoryInfo;\n    info.numTensors = this.state.numTensors;\n    info.numDataBuffers = this.state.numDataBuffers;\n    info.numBytes = this.state.numBytes;\n    if (this.state.numStringTensors > 0) {\n      info.unreliable = true;\n      if (info.reasons == null) {\n        info.reasons = [];\n      }\n      info.reasons.push(\n          'Memory usage by string tensors is approximate ' +\n          '(2 bytes per character)');\n    }\n    return info;\n  }\n\n  async profile(query: () => (TensorContainer | Promise<TensorContainer>)):\n      Promise<ProfileInfo> {\n    this.state.profiling = true;\n\n    const startBytes = this.state.numBytes;\n    const startNumTensors = this.state.numTensors;\n\n    this.state.activeProfile.kernels = [];\n    this.state.activeProfile.result = await query();\n\n    this.state.profiling = false;\n\n    this.state.activeProfile.peakBytes = Math.max(\n        ...this.state.activeProfile.kernels.map(d => d.totalBytesSnapshot));\n    this.state.activeProfile.newBytes = this.state.numBytes - startBytes;\n    this.state.activeProfile.newTensors =\n        this.state.numTensors - startNumTensors;\n    for (const kernel of this.state.activeProfile.kernels) {\n      kernel.kernelTimeMs = await kernel.kernelTimeMs;\n      kernel.extraInfo = await kernel.extraInfo;\n    }\n    return this.state.activeProfile;\n  }\n\n  isTapeOn(): boolean {\n    return this.state.gradientDepth > 0 && this.state.kernelDepth === 0;\n  }\n\n  private addTapeNode(\n      kernelName: string, inputs: NamedTensorMap, outputs: Tensor[],\n      gradientsFunc: GradFunc, saved: Tensor[], attrs: NamedAttrMap): void {\n    const tapeNode: TapeNode =\n        {id: this.state.nextTapeNodeId++, kernelName, inputs, outputs, saved};\n\n    const gradConfig = getGradient(kernelName);\n    if (gradConfig != null) {\n      gradientsFunc = gradConfig.gradFunc;\n    }\n    if (gradientsFunc != null) {\n      tapeNode.gradient = (dys: Tensor[]) => {\n        // TODO(smilkov): To optimize back-prop, pass dys that are not used in\n        // the backprop graph to the user as null instead of zeros\n        dys = dys.map((dy, i) => {\n          if (dy == null) {\n            const output = outputs[i];\n            const vals = util.makeZerosTypedArray(output.size, output.dtype);\n            return this.makeTensor(vals, output.shape, output.dtype);\n          }\n          return dy;\n        });\n        // Grad functions of ops with single outputs expect a dy, while ops\n        // with multiple outputs expect dys (array of dy).\n        return gradientsFunc(dys.length > 1 ? dys : dys[0], saved, attrs);\n      };\n    }\n    this.state.activeTape.push(tapeNode);\n  }\n\n  keep<T extends Tensor>(result: T): T {\n    result.kept = true;\n    return result;\n  }\n\n  private startTape() {\n    if (this.state.gradientDepth === 0) {\n      this.state.activeTape = [];\n    }\n    this.state.gradientDepth++;\n  }\n\n  private endTape() {\n    this.state.gradientDepth--;\n  }\n\n  /**\n   * Start a scope. Use this with endScope() to achieve the same functionality\n   * as scope() without the need for a function closure.\n   */\n  startScope(name?: string) {\n    const scopeInfo: ScopeState = {\n      track: [],\n      name: 'unnamed scope',\n      id: this.state.nextScopeId++\n    };\n    if (name) {\n      scopeInfo.name = name;\n    }\n    this.state.scopeStack.push(scopeInfo);\n    this.state.activeScope = scopeInfo;\n  }\n\n  /**\n   * End a scope. Use this with startScope() to achieve the same functionality\n   * as scope() without the need for a function closure.\n   */\n  endScope(result?: TensorContainer) {\n    const tensorsToTrackInParent = getTensorsInContainer(result);\n    const tensorsToTrackInParentSet =\n        new Set(tensorsToTrackInParent.map(t => t.id));\n\n    // Dispose the arrays tracked in this scope.\n    for (let i = 0; i < this.state.activeScope.track.length; i++) {\n      const tensor = this.state.activeScope.track[i];\n      if (!tensor.kept && !tensorsToTrackInParentSet.has(tensor.id)) {\n        tensor.dispose();\n      }\n    }\n\n    const oldScope = this.state.scopeStack.pop();\n    this.state.activeScope = this.state.scopeStack.length === 0 ?\n        null :\n        this.state.scopeStack[this.state.scopeStack.length - 1];\n\n    // Track the current result in the parent scope.\n    tensorsToTrackInParent.forEach(tensor => {\n      // Only track the tensor if was allocated in the inner scope and is not\n      // globally kept.\n      if (!tensor.kept && tensor.scopeId === oldScope.id) {\n        this.track(tensor);\n      }\n    });\n  }\n\n  /**\n   * Returns gradients of `f` with respect to each of the `xs`. The gradients\n   * returned are of the same length as `xs`, but some might be null if `f`\n   * was not a function of that `x`. It also takes optional dy to multiply the\n   * gradient, which defaults to `1`.\n   */\n  gradients<T extends Tensor>(\n      f: () => T, xs: Tensor[], dy?: T,\n      allowNoGradients = false): {value: T, grads: Tensor[]} {\n    util.assert(\n        xs.length > 0, () => 'gradients() received an empty list of xs.');\n    if (dy != null && dy.dtype !== 'float32') {\n      throw new Error(`dy must have 'float32' dtype, but has '${dy.dtype}'`);\n    }\n\n    const y = this.scopedRun(\n        () => this.startTape(), () => this.endTape(),\n        () => this.tidy('forward', f));\n\n    util.assert(\n        y instanceof Tensor,\n        () => 'The result y returned by f() must be a tensor.');\n    // Filter out the nodes that don't connect x => y.\n    const filteredTape = getFilteredNodesXToY(this.state.activeTape, xs, y);\n    if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {\n      throw new Error(\n          'Cannot compute gradient of y=f(x) with respect to x. Make sure ' +\n          'that the f you passed encloses all operations that lead from x ' +\n          'to y.');\n    }\n\n    return this.tidy('backward', () => {\n      const accumulatedGradientMap: {[tensorId: number]: Tensor} = {};\n      accumulatedGradientMap[y.id] = (dy == null) ? ones(y.shape) : dy;\n\n      // Backprop gradients through the filtered nodes.\n      backpropagateGradients(\n          accumulatedGradientMap, filteredTape,\n          // Pass the tidy function to avoid circular dep with `tape.ts`.\n          f => this.tidy(f as ScopeFn<Tensor>),\n          // Pass an add function to avoide a circular dep with `tape.ts`.\n          add);\n      const grads = xs.map(x => accumulatedGradientMap[x.id]);\n\n      if (this.state.gradientDepth === 0) {\n        // This means that we are not computing higher-order gradients\n        // and can clean up the tape.\n        this.state.activeTape.forEach(node => {\n          for (const tensor of node.saved) {\n            tensor.dispose();\n          }\n        });\n        this.state.activeTape = null;\n      }\n      return {value: y, grads};\n    });\n  }\n\n  customGrad<T extends Tensor>(f: CustomGradientFunc<T>):\n      (...args: Array<Tensor|GradSaveFunc>) => T {\n    util.assert(\n        util.isFunction(f),\n        () => 'The f passed in customGrad(f) must be a function.');\n    return (...inputs: Tensor[]): T => {\n      util.assert(\n          inputs.every(t => t instanceof Tensor),\n          () => 'The args passed in customGrad(f)(x1, x2,...) must all be ' +\n              'tensors');\n\n      let res: {\n        value: T,\n        gradFunc: (dy: T, saved: Tensor[]) => Tensor | Tensor[],\n      };\n      const inputMap: NamedTensorMap = {};\n      inputs.forEach((input, i) => {\n        inputMap[i] = input;\n      });\n\n      const forwardFunc: ForwardFunc<T> = (_, save) => {\n        res = f(...[...inputs, save]);\n        util.assert(\n            res.value instanceof Tensor,\n            () => 'The function f passed in customGrad(f) must return an ' +\n                'object where `obj.value` is a tensor');\n        util.assert(\n            util.isFunction(res.gradFunc),\n            () => 'The function f passed in customGrad(f) must return an ' +\n                'object where `obj.gradFunc` is a function.');\n        return res.value;\n      };\n\n      const backwardsFunc = (dy: T, saved: Tensor[]) => {\n        const gradRes = res.gradFunc(dy, saved);\n        const grads: Tensor[] = Array.isArray(gradRes) ? gradRes : [gradRes];\n        util.assert(\n            grads.length === inputs.length,\n            () => 'The function f passed in customGrad(f) must return an ' +\n                'object where `obj.gradFunc` is a function that returns ' +\n                'the same number of tensors as inputs passed to f(...).');\n        util.assert(\n            grads.every(t => t instanceof Tensor),\n            () => 'The function f passed in customGrad(f) must return an ' +\n                'object where `obj.gradFunc` is a function that returns ' +\n                'a list of only tensors.');\n        const gradMap: {[key: string]: () => Tensor} = {};\n        grads.forEach((grad, i) => {\n          gradMap[i] = () => grad;\n        });\n        return gradMap;\n      };\n\n      return this.runKernelFunc({\n        forwardFunc,\n        backwardsFunc,\n        inputs: inputMap,\n      });\n    };\n  }\n\n  readSync(dataId: DataId): BackendValues {\n    // Route the read to the correct backend.\n    const info = this.state.tensorInfo.get(dataId);\n    return info.backend.readSync(dataId);\n  }\n  read(dataId: DataId): Promise<BackendValues> {\n    // Route the read to the correct backend.\n    const info = this.state.tensorInfo.get(dataId);\n    return info.backend.read(dataId);\n  }\n\n  async time(query: () => void): Promise<TimingInfo> {\n    const start = now();\n    const timingInfo = await this.backend.time(query) as TimingInfo;\n    timingInfo.wallMs = now() - start;\n    return timingInfo;\n  }\n\n  /**\n   * Tracks a Tensor in the current scope to be automatically cleaned up\n   * when the current scope ends, and returns the value.\n   *\n   * @param result The Tensor to track in the current scope.\n   */\n  private track<T extends Tensor>(result: T): T {\n    if (this.state.activeScope != null) {\n      result.scopeId = this.state.activeScope.id;\n      this.state.activeScope.track.push(result);\n    }\n\n    return result;\n  }\n\n  get registeredVariables(): NamedVariableMap {\n    return this.state.registeredVariables;\n  }\n\n  /**\n   * Resets the engine state. Removes all backends but does not remove\n   * registered backend factories.\n   */\n  reset(): void {\n    // Make any pending promise obsolete.\n    this.pendingBackendInitId++;\n\n    this.state.dispose();\n    this.ENV.reset();\n    this.state = new EngineState();\n\n    for (const backendName in this.registry) {\n      this.disposeRegisteredKernels(backendName);\n      this.registry[backendName].dispose();\n      delete this.registry[backendName];\n    }\n    this.backendName = null;\n    this.backendInstance = null;\n    this.pendingBackendInit = null;\n  }\n}\n\nfunction ones(shape: number[]): Tensor {\n  const values = makeOnesTypedArray(sizeFromShape(shape), 'float32');\n  return ENGINE.makeTensor(values, shape, 'float32');\n}\n\nexport function getOrMakeEngine(): Engine {\n  const ns = getGlobalNamespace() as {} as {_tfengine: Engine};\n  if (ns._tfengine == null) {\n    const environment = new Environment(ns);\n    ns._tfengine = new Engine(environment);\n  }\n  setEnvironmentGlobal(ns._tfengine.ENV);\n\n  // Tell the current tensor interface that the global engine is responsible\n  // for tracking.\n  setTensorTracker(() => ns._tfengine);\n  return ns._tfengine;\n}\n\nexport const ENGINE = getOrMakeEngine();\n\n/**\n * A implementation of the add op for use within engine and tape.\n *\n * This allows us to avoid a circular dependency between add.ts and engine.\n * It is exported to be available in tape tests.\n */\nexport function add(a: Tensor, b: Tensor): Tensor {\n  // We duplicate Add here to avoid a circular dependency with add.ts.\n  const inputs = {a, b};\n  return ENGINE.runKernel(Add, inputs as {} as NamedTensorMap);\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// tslint:disable-next-line:no-any\nfunction _isNavigatorDefined(): boolean {\n  return typeof navigator !== 'undefined' && navigator != null;\n}\n\nexport function isMobile(nav?: Navigator): boolean {\n  if (nav || _isNavigatorDefined()) {\n    if (!nav) {\n      nav = navigator;\n    }\n    if (nav.product === 'ReactNative') {\n      return true;\n    }\n\n    // tslint:disable-next-line:no-any\n    const a = nav.userAgent || nav.vendor ||\n        (typeof window !== 'undefined' ? (window as any).opera : '');\n    // Use `navigator.userAgentData.mobile` as fallback.\n    if (!a) {\n      // tslint:disable-next-line:no-any\n      const navAny = nav as any;\n      return navAny.userAgentData && navAny.userAgentData.mobile;\n    }\n    // tslint:disable-next-line:max-line-length\n    return /(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i\n               .test(a) ||\n        // tslint:disable-next-line:max-line-length\n        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i\n            .test(a.substr(0, 4));\n  }\n  return false;\n}\n\nexport function isBrowser(): boolean {\n  return (typeof window !== 'undefined' && window.document != null) ||\n      //@ts-ignore\n      (typeof WorkerGlobalScope !== 'undefined');\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport './engine';\n\nimport * as device_util from './device_util';\nimport {env} from './environment';\n\nconst ENV = env();\n\n/**\n * This file contains environment-related flag registrations.\n */\n\n/** Whether to enable debug mode. */\nENV.registerFlag('DEBUG', () => false, debugValue => {\n  if (debugValue) {\n    console.warn(\n        'Debugging mode is ON. The output of every math call will ' +\n        'be downloaded to CPU and checked for NaNs. ' +\n        'This significantly impacts performance.');\n  }\n});\n\n/** Whether we are in a browser (as versus, say, node.js) environment. */\nENV.registerFlag('IS_BROWSER', () => device_util.isBrowser());\n\n/** Whether we are in a browser (as versus, say, node.js) environment. */\nENV.registerFlag(\n    'IS_NODE',\n    () => (typeof process !== 'undefined') &&\n        (typeof process.versions !== 'undefined') &&\n        (typeof process.versions.node !== 'undefined'));\n\n/** Whether this browser is Chrome. */\nENV.registerFlag(\n    'IS_CHROME',\n    () => typeof navigator !== 'undefined' && navigator != null &&\n        navigator.userAgent != null && /Chrome/.test(navigator.userAgent) &&\n        /Google Inc/.test(navigator.vendor));\n\n/**\n * True when the environment is \"production\" where we disable safety checks\n * to gain performance.\n */\nENV.registerFlag('PROD', () => false);\n\n/**\n * Whether to do sanity checks when inferring a shape from user-provided\n * values, used when creating a new tensor.\n */\nENV.registerFlag(\n    'TENSORLIKE_CHECK_SHAPE_CONSISTENCY', () => ENV.getBool('DEBUG'));\n\n/** Whether deprecation warnings are enabled. */\nENV.registerFlag('DEPRECATION_WARNINGS_ENABLED', () => true);\n\n/** True if running unit tests. */\nENV.registerFlag('IS_TEST', () => false);\n\n/** Whether to check computation result for errors. */\nENV.registerFlag('CHECK_COMPUTATION_FOR_ERRORS', () => true);\n\n/** Whether the backend needs to wrap input to imageBitmap. */\nENV.registerFlag('WRAP_TO_IMAGEBITMAP', () => false);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from './engine';\nimport {env} from './environment';\nimport {Tensor} from './tensor';\nimport {DataType, TensorLike} from './types';\nimport {assert, flatten, inferDtype, isTypedArray, toTypedArray} from './util';\n\nexport function inferShape(val: TensorLike, dtype?: DataType): number[] {\n  let firstElem: typeof val = val;\n\n  if (isTypedArray(val)) {\n    return dtype === 'string' ? [] : [val.length];\n  }\n  if (!Array.isArray(val)) {\n    return [];  // Scalar.\n  }\n  const shape: number[] = [];\n\n  while (Array.isArray(firstElem) ||\n         isTypedArray(firstElem) && dtype !== 'string') {\n    shape.push(firstElem.length);\n    firstElem = firstElem[0];\n  }\n  if (Array.isArray(val) &&\n      env().getBool('TENSORLIKE_CHECK_SHAPE_CONSISTENCY')) {\n    deepAssertShapeConsistency(val, shape, []);\n  }\n\n  return shape;\n}\n\nfunction deepAssertShapeConsistency(\n    val: TensorLike, shape: number[], indices: number[]) {\n  indices = indices || [];\n  if (!(Array.isArray(val)) && !isTypedArray(val)) {\n    assert(\n        shape.length === 0,\n        () => `Element arr[${indices.join('][')}] is a primitive, ` +\n            `but should be an array/TypedArray of ${shape[0]} elements`);\n    return;\n  }\n  assert(\n      shape.length > 0,\n      () => `Element arr[${indices.join('][')}] should be a primitive, ` +\n          `but is an array of ${val.length} elements`);\n  assert(\n      val.length === shape[0],\n      () => `Element arr[${indices.join('][')}] should have ${shape[0]} ` +\n          `elements, but has ${val.length} elements`);\n  const subShape = shape.slice(1);\n  for (let i = 0; i < val.length; ++i) {\n    deepAssertShapeConsistency(val[i], subShape, indices.concat(i));\n  }\n}\n\nfunction assertDtype(\n    expectedDtype: DataType|'numeric'|'string_or_numeric',\n    actualDType: DataType, argName: string, functionName: string) {\n  if (expectedDtype === 'string_or_numeric') {\n    return;\n  }\n  if (expectedDtype == null) {\n    throw new Error(`Expected dtype cannot be null.`);\n  }\n  if (expectedDtype !== 'numeric' && expectedDtype !== actualDType ||\n      expectedDtype === 'numeric' && actualDType === 'string') {\n    throw new Error(\n        `Argument '${argName}' passed to '${functionName}' must ` +\n        `be ${expectedDtype} tensor, but got ${actualDType} tensor`);\n  }\n}\n\nexport function convertToTensor<T extends Tensor>(\n    x: T|TensorLike, argName: string, functionName: string,\n    parseAsDtype: DataType|'numeric'|'string_or_numeric' = 'numeric'): T {\n  if (x instanceof Tensor) {\n    assertDtype(parseAsDtype, x.dtype, argName, functionName);\n    return x;\n  }\n  let inferredDtype = inferDtype(x);\n  // If the user expects a bool/int/float, use that info to update the\n  // inferredDtype when it is not a string.\n  if (inferredDtype !== 'string' &&\n      ['bool', 'int32', 'float32'].indexOf(parseAsDtype) >= 0) {\n    inferredDtype = parseAsDtype as DataType;\n  }\n  assertDtype(parseAsDtype, inferredDtype, argName, functionName);\n\n  if ((x == null) ||\n      (!isTypedArray(x) && !Array.isArray(x) && typeof x !== 'number' &&\n       typeof x !== 'boolean' && typeof x !== 'string')) {\n    const type = x == null ? 'null' : (x as {}).constructor.name;\n    throw new Error(\n        `Argument '${argName}' passed to '${functionName}' must be a ` +\n        `Tensor or TensorLike, but got '${type}'`);\n  }\n  const inferredShape = inferShape(x, inferredDtype);\n  if (!isTypedArray(x) && !Array.isArray(x)) {\n    x = [x] as number[];\n  }\n  const skipTypedArray = true;\n  const values = inferredDtype !== 'string' ?\n      toTypedArray(x, inferredDtype as DataType) :\n      flatten(x as string[], [], skipTypedArray) as string[];\n  return ENGINE.makeTensor(values, inferredShape, inferredDtype) as T;\n}\n\nexport function convertToTensorArray<T extends Tensor>(\n    arg: Array<T|TensorLike>, argName: string, functionName: string,\n    parseAsDtype: DataType|'numeric'|'string_or_numeric' = 'numeric'): T[] {\n  if (!Array.isArray(arg)) {\n    throw new Error(\n        `Argument ${argName} passed to ${functionName} must be a ` +\n        '`Tensor[]` or `TensorLike[]`');\n  }\n  const tensors = arg as T[];\n  return tensors.map(\n      (t, i) =>\n          convertToTensor(t, `${argName}[${i}]`, functionName, parseAsDtype));\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {isPromise} from '../util';\n\nexport const OP_SCOPE_SUFFIX = '__op';\n\n/**\n * Used for wrapping functions that perform math operations on\n * Tensors. The function will be wrapped in a named scope that cleans all\n * memory usage after the function is done.\n */\nexport function op<T extends Function>(f: {[name: string]: T}): T {\n  const keys = Object.keys(f);\n  if (keys.length !== 1) {\n    throw new Error(\n        `Please provide an object with a single key ` +\n        `(operation name) mapping to a function. Got an object with ` +\n        `${keys.length} keys.`);\n  }\n\n  let opName = keys[0];\n  const fn = f[opName];\n\n  // Strip the underscore from the end of the function name.\n  if (opName.endsWith('_')) {\n    opName = opName.substring(0, opName.length - 1);\n  }\n\n  // add an __op suffix to distinguish ops from kernels in tf.profile\n  opName = opName + OP_SCOPE_SUFFIX;\n\n  // tslint:disable-next-line:no-any\n  const f2 = (...args: any[]) => {\n    ENGINE.startScope(opName);\n    try {\n      const result = fn(...args);\n      if (isPromise(result)) {\n        console.error('Cannot return a Promise inside of tidy.');\n      }\n      ENGINE.endScope(result);\n      return result;\n    } catch (ex) {\n      ENGINE.endScope(null);\n      throw ex;\n    }\n  };\n  Object.defineProperty(f2, 'name', {value: opName, configurable: true});\n\n  // tslint:disable-next-line:no-any\n  return f2 as any as T;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Complex, ComplexInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Converts two real numbers to a complex number.\n *\n * Given a tensor `real` representing the real part of a complex number, and a\n * tensor `imag` representing the imaginary part of a complex number, this\n * operation returns complex numbers elementwise of the form [r0, i0, r1, i1],\n * where r represents the real part and i represents the imag part.\n *\n * The input tensors real and imag must have the same shape.\n *\n * ```js\n * const real = tf.tensor1d([2.25, 3.25]);\n * const imag = tf.tensor1d([4.75, 5.75]);\n * const complex = tf.complex(real, imag);\n *\n * complex.print();\n * ```\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction complex_<T extends Tensor>(real: T|TensorLike, imag: T|TensorLike): T {\n  const $real = convertToTensor(real, 'real', 'complex');\n  const $imag = convertToTensor(imag, 'imag', 'complex');\n  util.assertShapesMatch(\n      $real.shape, $imag.shape,\n      `real and imag shapes, ${$real.shape} and ${$imag.shape}, ` +\n          `must match in call to tf.complex().`);\n\n  const inputs: ComplexInputs = {real: $real, imag: $imag};\n  return ENGINE.runKernel(Complex, inputs as {} as NamedTensorMap);\n}\n\nexport const complex = op({complex_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {TensorLike, TypedArray} from '../types';\nimport {DataType} from '../types';\nimport {assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray} from '../util';\n\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(\n    values: TensorLike, shape: number[], inferredShape: number[],\n    dtype?: DataType): Tensor {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n  if (dtype === 'complex64') {\n    throw new Error(\n        `Cannot construct a complex64 tensor directly. ` +\n        `Please use tf.complex(real, imag).`);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) &&\n      typeof values !== 'number' && typeof values !== 'boolean' &&\n      typeof values !== 'string') {\n    throw new Error(\n        'values passed to tensor(values) must be a number/boolean/string or ' +\n        'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(\n        providedSize === inferredSize,\n        () =>\n            `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ?\n          inferred !== sizeFromShape(shape.slice(i)) :\n          true;\n      assert(\n          inferredShape[i] === shape[i] || !flatDimsDontMatch,\n          () => `Error creating a new Tensor. Inferred shape ` +\n              `(${inferredShape}) does not match the provided ` +\n              `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values] as number[];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ?\n      toTypedArray(values, dtype) :\n      flatten(values as string[], [], true) as string[];\n  return ENGINE.makeTensor(values as TypedArray, shape, dtype);\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {inferShape} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {DataType, Rank, ShapeMap} from '../types';\n\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates a `tf.Tensor` with the provided values, shape and dtype.\n *\n * ```js\n * // Pass an array of values to create a vector.\n * tf.tensor([1, 2, 3, 4]).print();\n * ```\n *\n * ```js\n * // Pass a nested array of values to make a matrix or a higher\n * // dimensional tensor.\n * tf.tensor([[1, 2], [3, 4]]).print();\n * ```\n *\n * ```js\n * // Pass a flat array and specify a shape yourself.\n * tf.tensor([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`. If the values are strings,\n *     they will be encoded as utf-8 and kept as `Uint8Array[]`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor<R extends Rank>(\n    values: TensorLike, shape?: ShapeMap[R], dtype?: DataType): Tensor<R> {\n  const inferredShape = inferShape(values, dtype);\n  return makeTensor(values, shape, inferredShape, dtype) as Tensor<R>;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/* Type definitions for exporting and importing of models. */\n\n/**\n * A map from Tensor dtype to number of bytes per element of the Tensor.\n */\nexport const DTYPE_VALUE_SIZE_MAP: {[dtype: string]: number} = {\n  'float32': 4,\n  'float16': 2,\n  'int32': 4,\n  'uint16': 2,\n  'uint8': 1,\n  'bool': 1,\n  'complex64': 8\n};\n\n/**\n * A weight manifest.\n *\n * The weight manifest consists of an ordered list of weight-manifest groups.\n * Each weight-manifest group (\"group\" for short hereafter) consists of a\n * number of weight values stored in a number of paths.\n * See the documentation of `WeightManifestGroupConfig` below for more details.\n */\nexport declare type WeightsManifestConfig = WeightsManifestGroupConfig[];\n\n/**\n * A weight-manifest group.\n *\n * Consists of an ordered list of weight values encoded in binary format,\n * stored in an ordered list of paths.\n */\nexport declare interface WeightsManifestGroupConfig {\n  /**\n   * An ordered list of paths.\n   *\n   * Paths are intentionally abstract in order to be general. For example, they\n   * can be relative URL paths or relative paths on the file system.\n   */\n  paths: string[];\n\n  /**\n   * Specifications of the weights stored in the paths.\n   */\n  weights: WeightsManifestEntry[];\n}\n\n/**\n * Group to which the weight belongs.\n *\n * - 'optimizer': Weight from a stateful optimizer.\n */\nexport type WeightGroup = 'model'|'optimizer';\n\n/**\n * An entry in the weight manifest.\n *\n * The entry contains specification of a weight.\n */\nexport declare interface WeightsManifestEntry {\n  /**\n   * Name of the weight, e.g., 'Dense_1/bias'\n   */\n  name: string;\n\n  /**\n   * Shape of the weight.\n   */\n  shape: number[];\n\n  /**\n   * Data type of the weight.\n   */\n  dtype: 'float32'|'int32'|'bool'|'string'|'complex64';\n\n  /**\n   * Type of the weight.\n   *\n   * Optional.\n   *\n   * The value 'optimizer' indicates the weight belongs to an optimizer\n   * (i.e., used only during model training and not during inference).\n   */\n  group?: WeightGroup;\n\n  /**\n   * Information for dequantization of the weight.\n   */\n  quantization?: {\n    scale?: number,  // The scaling constant to multiply by.\n    min?: number,    // The (possibly nudged) minimum weight to add.\n       dtype: 'uint16'|'uint8'|'float16'  // The dtype of the quantized weights.\n  };\n}\n\n/**\n * Options for saving a model.\n * @innamespace io\n */\nexport interface SaveConfig {\n  /**\n   * Whether to save only the trainable weights of the model, ignoring the\n   * non-trainable ones.\n   */\n  trainableOnly?: boolean;\n\n  /**\n   * Whether the optimizer will be saved (if exists).\n   *\n   * Default: `false`.\n   */\n  includeOptimizer?: boolean;\n}\n\n/**\n * Result of a saving operation.\n */\nexport interface SaveResult {\n  /**\n   * Information about the model artifacts saved.\n   */\n  modelArtifactsInfo: ModelArtifactsInfo;\n\n  /**\n   * HTTP responses from the server that handled the model-saving request (if\n   * any). This is applicable only to server-based saving routes.\n   */\n  responses?: Response[];\n\n  /**\n   * Error messages and related data (if any).\n   */\n  errors?: Array<{}|string>;\n}\n\nexport declare interface ModelArtifactsInfo {\n  /**\n   * Timestamp for when the model is saved.\n   */\n  dateSaved: Date;\n\n  /**\n   * TODO (cais,yassogba) consider removing GraphDef as GraphDefs now\n   * come in a JSON format and none of our IOHandlers support a non json\n   * format. We could conder replacing this with 'Binary' if we want to\n   * allow future handlers to save to non json formats (though they will\n   * probably want more information than 'Binary').\n   * Type of the model topology\n   *\n   * Type of the model topology\n   *\n   * Possible values:\n   *   - JSON: JSON config (human-readable, e.g., Keras JSON).\n   *   - GraphDef: TensorFlow\n   *     [GraphDef](https://www.tensorflow.org/extend/tool_developers/#graphdef)\n   *     protocol buffer (binary).\n   */\n  modelTopologyType: 'JSON'|'GraphDef';\n\n  /**\n   * Size of model topology (Keras JSON or GraphDef), in bytes.\n   */\n  modelTopologyBytes?: number;\n\n  /**\n   * Size of weight specification or manifest, in bytes.\n   */\n  weightSpecsBytes?: number;\n\n  /**\n   * Size of weight value data, in bytes.\n   */\n  weightDataBytes?: number;\n}\n\n/** Model training configuration. */\nexport declare interface TrainingConfig {\n  // TODO(cais): Tighten the typing once keras spec is available to tfjs-core.\n  // See\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tfjs-layers/blob/master/src/keras_format/training_config.ts\n  /** Optimizer used for the model training. */\n  optimizer_config: {};\n\n  // TODO(cais): Tighten the typing once keras spec is available to tfjs-core.\n  /** Loss function(s) for the model's output(s). */\n  loss: string|string[]|{[key: string]: string};\n\n  // TODO(cais): Tighten the typing once keras spec is available to tfjs-core.\n  /** Metric function(s) for the model's output(s). */\n  metrics?: string[]|{[key: string]: string};\n\n  // TODO(cais): Tighten the typing once keras spec is available to tfjs-core.\n  weighted_metrics?: string[];\n\n  // TODO(cais): Tighten the typing once keras spec is available to tfjs-core.\n  sample_weight_mode?: string;\n\n  loss_weights?: number[]|{[key: string]: number};\n}\n\n/**\n * The serialized artifacts of a model, including topology and weights.\n *\n * The `modelTopology`, `trainingConfig`, `weightSpecs` and `weightData` fields\n * of this interface are optional, in order to support topology- or weights-only\n * saving and loading.\n *\n * Note this interface is used internally in IOHandlers.  For the file format\n * written to disk as `model.json`, see `ModelJSON`.\n */\nexport declare interface ModelArtifacts {\n  /**\n   * Model topology.\n   *\n   * For Keras-style `tf.Model`s, this is a JSON object.\n   * For TensorFlow-style models (e.g., `SavedModel`), this is the JSON\n   * encoding of the `GraphDef` protocol buffer.\n   */\n  modelTopology?: {}|ArrayBuffer;\n\n  /**\n   * Serialized configuration for the model's training.\n   */\n  trainingConfig?: TrainingConfig;\n\n  /**\n   * Weight specifications.\n   *\n   * This corresponds to the weightsData below.\n   */\n  weightSpecs?: WeightsManifestEntry[];\n\n  /**\n   * Binary buffer for all weight values concatenated in the order specified\n   * by `weightSpecs`.\n   */\n  weightData?: ArrayBuffer;\n\n  /**\n   * Hard-coded format name for models saved from TensorFlow.js or converted\n   * by TensorFlow.js Converter.\n   */\n  format?: string;\n\n  /**\n   * What library is responsible for originally generating this artifact.\n   *\n   * Used for debugging purposes. E.g., 'TensorFlow.js v1.0.0'.\n   */\n  generatedBy?: string;\n\n  /**\n   * What library or tool is responsible for converting the original model\n   * to this format, applicable only if the model is output by a converter.\n   *\n   * Used for debugging purposes.  E.g., 'TensorFlow.js Converter v1.0.0'.\n   *\n   * A value of `null` means the model artifacts are generated without any\n   * conversion process (e.g., saved directly from a TensorFlow.js\n   * `tf.LayersModel` instance.)\n   */\n  convertedBy?: string|null;\n\n  /**\n   * Inputs and outputs signature for saved model.\n   */\n  signature?: {};\n\n  /**\n   * User-defined metadata about the model.\n   */\n  userDefinedMetadata?: {[key: string]: {}};\n\n  /**\n   * Initializer for the model.\n   */\n  modelInitializer?: {};\n}\n\n/**\n * The on-disk format of the `model.json` file.\n *\n * TF.js 1.0 always populates the optional fields when writing model.json.\n * Prior versions did not provide those fields.\n */\nexport declare interface ModelJSON {\n  /**\n   * Model topology.\n   *\n   * For Keras-style `tf.Model`s, this is a JSON object.\n   * For TensorFlow-style models (e.g., `SavedModel`), this is the JSON\n   * encoding of the `GraphDef` protocol buffer.\n   */\n  modelTopology: {};\n\n  /** Model training configuration. */\n  trainingConfig?: TrainingConfig;\n\n  /**\n   * Weights manifest.\n   *\n   * The weights manifest consists of an ordered list of weight-manifest\n   * groups. Each weight-manifest group consists of a number of weight values\n   * stored in a number of paths. See the documentation of\n   * `WeightsManifestConfig` for more details.\n   */\n  weightsManifest: WeightsManifestConfig;\n\n  /**\n   * Hard-coded format name for models saved from TensorFlow.js or converted\n   * by TensorFlow.js Converter.\n   */\n  format?: string;\n\n  /**\n   * What library is responsible for originally generating this artifact.\n   *\n   * Used for debugging purposes. E.g., 'TensorFlow.js v1.0.0'.\n   */\n  generatedBy?: string;\n\n  /**\n   * What library or tool is responsible for converting the original model\n   * to this format, applicable only if the model is output by a converter.\n   *\n   * Used for debugging purposes.  E.g., 'TensorFlow.js Converter v1.0.0'.\n   *\n   * A value of `null` means the model artifacts are generated without any\n   * conversion process (e.g., saved directly from a TensorFlow.js\n   * `tf.LayersModel` instance.)\n   */\n  convertedBy?: string|null;\n\n  /**\n   * Inputs and outputs signature for saved model.\n   */\n  signature?: {};\n\n  /**\n   * User-defined metadata about the model.\n   */\n  userDefinedMetadata?: {[key: string]: {}};\n\n  /**\n   * Initializer for the model.\n   */\n  modelInitializer?: {};\n}\n\n/**\n * Type definition for handlers of loading operations.\n */\nexport type LoadHandler = () => Promise<ModelArtifacts>;\n\n/**\n * Type definition for handlers of saving operations.\n */\nexport type SaveHandler = (modelArtifact: ModelArtifacts) =>\n    Promise<SaveResult>;\n\n/**\n * Interface for a model import/export handler.\n *\n * The `save` and `load` handlers are both optional, in order to allow handlers\n * that support only saving or loading.\n */\n// tslint:disable-next-line:interface-name\nexport interface IOHandler {\n  save?: SaveHandler;\n  load?: LoadHandler;\n}\n\n/**\n * An interface for the manager of a model store.\n *\n * A model store is defined as a storage medium on which multiple models can\n * be stored. Each stored model has a unique `path` as its identifier.\n * A `ModelStoreManager` for the store allows actions including\n *\n * - Listing the models stored in the store.\n * - Deleting a model from the store.\n */\nexport interface ModelStoreManager {\n  /**\n   * List all models in the model store.\n   *\n   * @returns A dictionary mapping paths of existing models to their\n   *   model artifacts info. Model artifacts info include type of the model's\n   *   topology, byte sizes of the topology, weights, etc.\n   */\n  listModels(): Promise<{[path: string]: ModelArtifactsInfo}>;\n\n  /**\n   * Remove a model specified by `path`.\n   *\n   * @param path\n   * @returns ModelArtifactsInfo of the deleted model (if and only if deletion\n   *   is successful).\n   * @throws Error if deletion fails, e.g., if no model exists at `path`.\n   */\n  removeModel(path: string): Promise<ModelArtifactsInfo>;\n}\n\n/**\n * Callback for the progress of a long-running action such as an HTTP\n * request for a large binary object.\n *\n * `fraction` should be a number in the [0, 1] interval, indicating how\n * much of the action has completed.\n */\nexport type OnProgressCallback = (fraction: number) => void;\n\n/** @innamespace io */\nexport interface LoadOptions {\n  /**\n   * RequestInit (options) for HTTP requests.\n   *\n   * For detailed information on the supported fields, see\n   * [https://developer.mozilla.org/en-US/docs/Web/API/Request/Request](\n   *     https://developer.mozilla.org/en-US/docs/Web/API/Request/Request)\n   */\n  requestInit?: RequestInit;\n\n  /**\n   * Progress callback.\n   */\n  onProgress?: OnProgressCallback;\n\n  /**\n   * A function used to override the `window.fetch` function.\n   */\n  fetchFunc?: Function;\n\n  /**\n   * Strict loading model: whether extraneous weights or missing\n   * weights should trigger an `Error`.\n   *\n   * If `true`, require that the provided weights exactly match those\n   * required by the layers. `false` means that both extra weights\n   * and missing weights will be silently ignored.\n   *\n   * Default: `true`.\n   */\n  strict?: boolean;\n\n  /**\n   * Path prefix for weight files, by default this is calculated from the\n   * path of the model JSON file.\n   *\n   * For instance, if the path to the model JSON file is\n   * `http://localhost/foo/model.json`, then the default path prefix will be\n   * `http://localhost/foo/`. If a weight file has the path value\n   * `group1-shard1of2` in the weight manifest, then the weight file will be\n   * loaded from `http://localhost/foo/group1-shard1of2` by default. However,\n   * if you provide a `weightPathPrefix` value of\n   * `http://localhost/foo/alt-weights`, then the weight file will be loaded\n   * from the path `http://localhost/foo/alt-weights/group1-shard1of2` instead.\n   */\n  weightPathPrefix?: string;\n\n  /**\n   * Whether the module or model is to be loaded from TF Hub.\n   *\n   * Setting this to `true` allows passing a TF-Hub module URL, omitting the\n   * standard model file name and the query parameters.\n   *\n   * Default: `false`.\n   */\n  fromTFHub?: boolean;\n\n  /**\n   * An async function to convert weight file name to URL. The weight file\n   * names are stored in model.json's weightsManifest.paths field. By default we\n   * consider weight files are colocated with the model.json file. For example:\n   *     model.json URL: https://www.google.com/models/1/model.json\n   *     group1-shard1of1.bin url:\n   *        https://www.google.com/models/1/group1-shard1of1.bin\n   *\n   * With this func you can convert the weight file name to any URL.\n   */\n  weightUrlConverter?: (weightFileName: string) => Promise<string>;\n}\n\n/**\n * Additional options for Platform.fetch\n */\nexport interface RequestDetails {\n  /**\n   * Is this request for a binary file (as opposed to a json file)\n   */\n  isBinary?: boolean;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {complex} from '../ops/complex';\nimport {tensor} from '../ops/tensor';\nimport {NamedTensor, NamedTensorMap} from '../tensor_types';\nimport {TypedArray} from '../types';\nimport {sizeFromShape} from '../util';\n\nimport {DTYPE_VALUE_SIZE_MAP, ModelArtifacts, ModelArtifactsInfo, ModelJSON, WeightGroup, WeightsManifestConfig, WeightsManifestEntry} from './types';\n\n/** Number of bytes reserved for the length of the string. (32bit integer). */\nconst NUM_BYTES_STRING_LENGTH = 4;\n\n/**\n * Encode a map from names to weight values as an ArrayBuffer, along with an\n * `Array` of `WeightsManifestEntry` as specification of the encoded weights.\n *\n * This function does not perform sharding.\n *\n * This function is the reverse of `decodeWeights`.\n *\n * @param tensors A map (\"dict\") from names to tensors.\n * @param group Group to which the weights belong (optional).\n * @returns A `Promise` of\n *   - A flat `ArrayBuffer` with all the binary values of the `Tensor`s\n *     concatenated.\n *   - An `Array` of `WeightManifestEntry`s, carrying information including\n *     tensor names, `dtype`s and shapes.\n * @throws Error: on unsupported tensor `dtype`.\n */\nexport async function encodeWeights(\n    tensors: NamedTensorMap|NamedTensor[], group?: WeightGroup):\n    Promise<{data: ArrayBuffer, specs: WeightsManifestEntry[]}> {\n  // TODO(adarob, cais): Support quantization.\n  const specs: WeightsManifestEntry[] = [];\n  const dataPromises: Array<Promise<TypedArray>> = [];\n\n  const names: string[] = Array.isArray(tensors) ?\n      tensors.map(tensor => tensor.name) :\n      Object.keys(tensors);\n\n  for (let i = 0; i < names.length; ++i) {\n    const name = names[i];\n    const t = Array.isArray(tensors) ? tensors[i].tensor : tensors[name];\n    if (t.dtype !== 'float32' && t.dtype !== 'int32' && t.dtype !== 'bool' &&\n        t.dtype !== 'string' && t.dtype !== 'complex64') {\n      throw new Error(`Unsupported dtype in weight '${name}': ${t.dtype}`);\n    }\n    const spec: WeightsManifestEntry = {name, shape: t.shape, dtype: t.dtype};\n    if (t.dtype === 'string') {\n      const utf8bytes = new Promise<TypedArray>(async resolve => {\n        const vals = await t.bytes() as Uint8Array[];\n        const totalNumBytes = vals.reduce((p, c) => p + c.length, 0) +\n            NUM_BYTES_STRING_LENGTH * vals.length;\n        const bytes = new Uint8Array(totalNumBytes);\n        let offset = 0;\n        for (let i = 0; i < vals.length; i++) {\n          const val = vals[i];\n          const bytesOfLength =\n              new Uint8Array(new Uint32Array([val.length]).buffer);\n          bytes.set(bytesOfLength, offset);\n          offset += NUM_BYTES_STRING_LENGTH;\n          bytes.set(val, offset);\n          offset += val.length;\n        }\n        resolve(bytes);\n      });\n      dataPromises.push(utf8bytes);\n    } else {\n      dataPromises.push(t.data());\n    }\n    if (group != null) {\n      spec.group = group;\n    }\n    specs.push(spec);\n  }\n\n  const tensorValues = await Promise.all(dataPromises);\n  return {data: concatenateTypedArrays(tensorValues), specs};\n}\n\n/**\n * Decode flat ArrayBuffer as weights.\n *\n * This function does not handle sharding.\n *\n * This function is the reverse of `encodeWeights`.\n *\n * @param buffer A flat ArrayBuffer carrying the binary values of the tensors\n *   concatenated in the order specified in `specs`.\n * @param specs Specifications of the names, dtypes and shapes of the tensors\n *   whose value are encoded by `buffer`.\n * @return A map from tensor name to tensor value, with the names corresponding\n *   to names in `specs`.\n * @throws Error, if any of the tensors has unsupported dtype.\n */\nexport function decodeWeights(\n    buffer: ArrayBuffer, specs: WeightsManifestEntry[]): NamedTensorMap {\n  // TODO(adarob, cais): Support quantization.\n  const out: NamedTensorMap = {};\n  let float16Decode: (buffer: Uint16Array) => Float32Array | undefined;\n  let offset = 0;\n  for (const spec of specs) {\n    const name = spec.name;\n    const dtype = spec.dtype;\n    const shape = spec.shape;\n    const size = sizeFromShape(shape);\n    let values: TypedArray|string[]|Uint8Array[];\n\n    if ('quantization' in spec) {\n      const quantization = spec.quantization;\n      if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {\n        if (!('min' in quantization && 'scale' in quantization)) {\n          throw new Error(\n              `Weight ${spec.name} with quantization ${quantization.dtype} ` +\n              `doesn't have corresponding metadata min and scale.`);\n        }\n      } else if (quantization.dtype === 'float16') {\n        if (dtype !== 'float32') {\n          throw new Error(\n              `Weight ${spec.name} is quantized with ${quantization.dtype} ` +\n              `which only supports weights of type float32 not ${dtype}.`);\n        }\n      } else {\n        throw new Error(\n            `Weight ${spec.name} has unknown ` +\n            `quantization dtype ${quantization.dtype}. ` +\n            `Supported quantization dtypes are: ` +\n            `'uint8', 'uint16', and 'float16'.`);\n      }\n      const quantizationSizeFactor = DTYPE_VALUE_SIZE_MAP[quantization.dtype];\n      const byteBuffer =\n          buffer.slice(offset, offset + size * quantizationSizeFactor);\n      const quantizedArray = (quantization.dtype === 'uint8') ?\n          new Uint8Array(byteBuffer) :\n          new Uint16Array(byteBuffer);\n      if (dtype === 'float32') {\n        if (quantization.dtype === 'uint8' || quantization.dtype === 'uint16') {\n          values = new Float32Array(quantizedArray.length);\n          for (let i = 0; i < quantizedArray.length; i++) {\n            const v = quantizedArray[i];\n            values[i] = v * quantization.scale + quantization.min;\n          }\n        } else if (quantization.dtype === 'float16') {\n          if (float16Decode === undefined) {\n            float16Decode = getFloat16Decoder();\n          }\n          values = float16Decode(quantizedArray as Uint16Array);\n        } else {\n          throw new Error(\n              `Unsupported quantization type ${quantization.dtype} ` +\n              `for weight type float32.`);\n        }\n      } else if (dtype === 'int32') {\n        if (quantization.dtype !== 'uint8' && quantization.dtype !== 'uint16') {\n          throw new Error(\n              `Unsupported quantization type ${quantization.dtype} ` +\n              `for weight type int32.`);\n        }\n        values = new Int32Array(quantizedArray.length);\n        for (let i = 0; i < quantizedArray.length; i++) {\n          const v = quantizedArray[i];\n          values[i] = Math.round(v * quantization.scale + quantization.min);\n        }\n      } else {\n        throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);\n      }\n      offset += size * quantizationSizeFactor;\n    } else if (dtype === 'string') {\n      const size = sizeFromShape(spec.shape);\n      values = [];\n      for (let i = 0; i < size; i++) {\n        const byteLength = new Uint32Array(\n            buffer.slice(offset, offset + NUM_BYTES_STRING_LENGTH))[0];\n        offset += NUM_BYTES_STRING_LENGTH;\n        const bytes = new Uint8Array(buffer.slice(offset, offset + byteLength));\n        (values as Uint8Array[]).push(bytes);\n        offset += byteLength;\n      }\n    } else {\n      const dtypeFactor = DTYPE_VALUE_SIZE_MAP[dtype];\n      const byteBuffer = buffer.slice(offset, offset + size * dtypeFactor);\n\n      if (dtype === 'float32') {\n        values = new Float32Array(byteBuffer);\n      } else if (dtype === 'int32') {\n        values = new Int32Array(byteBuffer);\n      } else if (dtype === 'bool') {\n        values = new Uint8Array(byteBuffer);\n      } else if (dtype === 'complex64') {\n        values = new Float32Array(byteBuffer);\n        const real = new Float32Array(values.length / 2);\n        const image = new Float32Array(values.length / 2);\n        for (let i = 0; i < real.length; i++) {\n          real[i] = values[i * 2];\n          image[i] = values[i * 2 + 1];\n        }\n        const realTensor = tensor(real, shape, 'float32');\n        const imageTensor = tensor(image, shape, 'float32');\n        out[name] = complex(realTensor, imageTensor);\n        realTensor.dispose();\n        imageTensor.dispose();\n      } else {\n        throw new Error(`Unsupported dtype in weight '${name}': ${dtype}`);\n      }\n      offset += size * dtypeFactor;\n    }\n    if (dtype !== 'complex64') {\n      out[name] = tensor(values, shape, dtype);\n    }\n  }\n  return out;\n}\n\n/**\n * Concatenate TypedArrays into an ArrayBuffer.\n */\nexport function concatenateTypedArrays(xs: TypedArray[]): ArrayBuffer {\n  // TODO(adarob, cais): Support quantization.\n  if (xs === null) {\n    throw new Error(`Invalid input value: ${JSON.stringify(xs)}`);\n  }\n\n  let totalByteLength = 0;\n\n  // `normalizedXs` is here for this reason: a `TypedArray`'s `buffer'\n  // can have a different byte length from that of the `TypedArray` itself,\n  // for example, when the `TypedArray` is created from an offset in an\n  // `ArrayBuffer`. `normliazedXs` holds `TypedArray`s whose `buffer`s match\n  // the `TypedArray` in byte length. If an element of `xs` does not show\n  // this property, a new `TypedArray` that satisfy this property will be\n  // constructed and pushed into `normalizedXs`.\n  const normalizedXs: TypedArray[] = [];\n  xs.forEach((x: TypedArray) => {\n    totalByteLength += x.byteLength;\n    // tslint:disable:no-any\n    normalizedXs.push(\n        x.byteLength === x.buffer.byteLength ? x :\n                                               new (x.constructor as any)(x));\n    if (!(x as any instanceof Float32Array || x as any instanceof Int32Array ||\n          x as any instanceof Uint8Array)) {\n      throw new Error(`Unsupported TypedArray subtype: ${x.constructor.name}`);\n    }\n    // tslint:enable:no-any\n  });\n\n  const y = new Uint8Array(totalByteLength);\n  let offset = 0;\n  normalizedXs.forEach((x: TypedArray) => {\n    y.set(new Uint8Array(x.buffer), offset);\n    offset += x.byteLength;\n  });\n\n  return y.buffer;\n}\n\n// Use Buffer on Node.js instead of Blob/atob/btoa\nconst useNodeBuffer = typeof Buffer !== 'undefined' &&\n    (typeof Blob === 'undefined' || typeof atob === 'undefined' ||\n     typeof btoa === 'undefined');\n\n/**\n * Calculate the byte length of a JavaScript string.\n *\n * Note that a JavaScript string can contain wide characters, therefore the\n * length of the string is not necessarily equal to the byte length.\n *\n * @param str Input string.\n * @returns Byte length.\n */\nexport function stringByteLength(str: string): number {\n  if (useNodeBuffer) {\n    return Buffer.byteLength(str);\n  }\n  return new Blob([str]).size;\n}\n\n/**\n * Encode an ArrayBuffer as a base64 encoded string.\n *\n * @param buffer `ArrayBuffer` to be converted.\n * @returns A string that base64-encodes `buffer`.\n */\nexport function arrayBufferToBase64String(buffer: ArrayBuffer): string {\n  if (useNodeBuffer) {\n    return Buffer.from(buffer).toString('base64');\n  }\n  const buf = new Uint8Array(buffer);\n  let s = '';\n  for (let i = 0, l = buf.length; i < l; i++) {\n    s += String.fromCharCode(buf[i]);\n  }\n  return btoa(s);\n}\n\n/**\n * Decode a base64 string as an ArrayBuffer.\n *\n * @param str Base64 string.\n * @returns Decoded `ArrayBuffer`.\n */\nexport function base64StringToArrayBuffer(str: string): ArrayBuffer {\n  if (useNodeBuffer) {\n    const buf = Buffer.from(str, 'base64');\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n  }\n  const s = atob(str);\n  const buffer = new Uint8Array(s.length);\n  for (let i = 0; i < s.length; ++i) {\n    buffer.set([s.charCodeAt(i)], i);\n  }\n  return buffer.buffer;\n}\n\n/**\n * Concatenate a number of ArrayBuffers into one.\n *\n * @param buffers A number of array buffers to concatenate.\n * @returns Result of concatenating `buffers` in order.\n */\nexport function concatenateArrayBuffers(buffers: ArrayBuffer[]): ArrayBuffer {\n  if (buffers.length === 1) {\n    return buffers[0];\n  }\n\n  let totalByteLength = 0;\n  buffers.forEach((buffer: ArrayBuffer) => {\n    totalByteLength += buffer.byteLength;\n  });\n\n  const temp = new Uint8Array(totalByteLength);\n  let offset = 0;\n  buffers.forEach((buffer: ArrayBuffer) => {\n    temp.set(new Uint8Array(buffer), offset);\n    offset += buffer.byteLength;\n  });\n  return temp.buffer;\n}\n\n/**\n * Get the basename of a path.\n *\n * Behaves in a way analogous to Linux's basename command.\n *\n * @param path\n */\nexport function basename(path: string): string {\n  const SEPARATOR = '/';\n  path = path.trim();\n  while (path.endsWith(SEPARATOR)) {\n    path = path.slice(0, path.length - 1);\n  }\n  const items = path.split(SEPARATOR);\n  return items[items.length - 1];\n}\n\n/**\n * Create `ModelJSON` from `ModelArtifacts`.\n *\n * @param artifacts Model artifacts, describing the model and its weights.\n * @param manifest Weight manifest, describing where the weights of the\n *     `ModelArtifacts` are stored, and some metadata about them.\n * @returns Object representing the `model.json` file describing the model\n *     artifacts and weights\n */\nexport function getModelJSONForModelArtifacts(\n    artifacts: ModelArtifacts, manifest: WeightsManifestConfig): ModelJSON {\n  const result: ModelJSON = {\n    modelTopology: artifacts.modelTopology,\n    format: artifacts.format,\n    generatedBy: artifacts.generatedBy,\n    convertedBy: artifacts.convertedBy,\n    weightsManifest: manifest\n  };\n  if (artifacts.signature != null) {\n    result.signature = artifacts.signature;\n  }\n  if (artifacts.userDefinedMetadata != null) {\n    result.userDefinedMetadata = artifacts.userDefinedMetadata;\n  }\n  if (artifacts.modelInitializer != null) {\n    result.modelInitializer = artifacts.modelInitializer;\n  }\n  if (artifacts.trainingConfig != null) {\n    result.trainingConfig = artifacts.trainingConfig;\n  }\n  return result;\n}\n\n/**\n * Create `ModelArtifacts` from a JSON file.\n *\n * @param modelJSON Object containing the parsed JSON of `model.json`\n * @param loadWeights Function that takes the JSON file's weights manifest,\n *     reads weights from the listed path(s), and returns a Promise of the\n *     weight manifest entries along with the weights data.\n * @returns A Promise of the `ModelArtifacts`, as described by the JSON file.\n */\nexport async function getModelArtifactsForJSON(\n    modelJSON: ModelJSON,\n    loadWeights: (weightsManifest: WeightsManifestConfig) => Promise<[\n      /* weightSpecs */ WeightsManifestEntry[], /* weightData */ ArrayBuffer\n    ]>): Promise<ModelArtifacts> {\n  const modelArtifacts: ModelArtifacts = {\n    modelTopology: modelJSON.modelTopology,\n    format: modelJSON.format,\n    generatedBy: modelJSON.generatedBy,\n    convertedBy: modelJSON.convertedBy\n  };\n\n  if (modelJSON.trainingConfig != null) {\n    modelArtifacts.trainingConfig = modelJSON.trainingConfig;\n  }\n  if (modelJSON.weightsManifest != null) {\n    const [weightSpecs, weightData] =\n        await loadWeights(modelJSON.weightsManifest);\n    modelArtifacts.weightSpecs = weightSpecs;\n    modelArtifacts.weightData = weightData;\n  }\n  if (modelJSON.signature != null) {\n    modelArtifacts.signature = modelJSON.signature;\n  }\n  if (modelJSON.userDefinedMetadata != null) {\n    modelArtifacts.userDefinedMetadata = modelJSON.userDefinedMetadata;\n  }\n  if (modelJSON.modelInitializer != null) {\n    modelArtifacts.modelInitializer = modelJSON.modelInitializer;\n  }\n\n  return modelArtifacts;\n}\n\n/**\n * Populate ModelArtifactsInfo fields for a model with JSON topology.\n * @param modelArtifacts\n * @returns A ModelArtifactsInfo object.\n */\nexport function getModelArtifactsInfoForJSON(modelArtifacts: ModelArtifacts):\n    ModelArtifactsInfo {\n  if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n    throw new Error('Expected JSON model topology, received ArrayBuffer.');\n  }\n\n  return {\n    dateSaved: new Date(),\n    modelTopologyType: 'JSON',\n    modelTopologyBytes: modelArtifacts.modelTopology == null ?\n        0 :\n        stringByteLength(JSON.stringify(modelArtifacts.modelTopology)),\n    weightSpecsBytes: modelArtifacts.weightSpecs == null ?\n        0 :\n        stringByteLength(JSON.stringify(modelArtifacts.weightSpecs)),\n    weightDataBytes: modelArtifacts.weightData == null ?\n        0 :\n        modelArtifacts.weightData.byteLength,\n  };\n}\n\n/**\n * Computes mantisa table for casting Float16 to Float32\n * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n *\n * @returns Uint32Array, 2048 mantissa lookup values.\n */\nfunction computeFloat16MantisaTable(): Uint32Array {\n  const convertMantissa = (i: number): number => {\n    let m = i << 13;\n    let e = 0;\n\n    while ((m & 0x00800000) === 0) {\n      e -= 0x00800000;\n      m <<= 1;\n    }\n    m &= ~0x00800000;\n    e += 0x38800000;\n\n    return m | e;\n  };\n\n  const mantisaTable = new Uint32Array(2048);\n\n  mantisaTable[0] = 0;\n  for (let i = 1; i < 1024; i++) {\n    mantisaTable[i] = convertMantissa(i);\n  }\n  for (let i = 1024; i < 2048; i++) {\n    mantisaTable[i] = 0x38000000 + ((i - 1024) << 13);\n  }\n\n  return mantisaTable;\n}\n\n/**\n * Computes exponent table for casting Float16 to Float32\n * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n *\n * @returns Uint32Array, 64 exponent lookup values.\n */\nfunction computeFloat16ExponentTable(): Uint32Array {\n  const exponentTable = new Uint32Array(64);\n\n  exponentTable[0] = 0;\n  exponentTable[31] = 0x47800000;\n  exponentTable[32] = 0x80000000;\n  exponentTable[63] = 0xc7800000;\n  for (let i = 1; i < 31; i++) {\n    exponentTable[i] = i << 23;\n  }\n  for (let i = 33; i < 63; i++) {\n    exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n  }\n\n  return exponentTable;\n}\n\n/**\n * Computes offset table for casting Float16 to Float32\n * See http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n *\n * @returns Uint32Array, 6d offset values.\n */\nfunction computeFloat16OffsetTable(): Uint32Array {\n  const offsetTable = new Uint32Array(64);\n\n  for (let i = 0; i < 64; i++) {\n    offsetTable[i] = 1024;\n  }\n  offsetTable[0] = offsetTable[32] = 0;\n\n  return offsetTable;\n}\n\n/**\n * Retrieve a Float16 decoder which will decode a ByteArray of Float16 values\n * to a Float32Array.\n *\n * @returns Function (buffer: Uint16Array) => Float32Array which decodes\n *          the Uint16Array of Float16 bytes to a Float32Array.\n */\nexport function getFloat16Decoder(): (buffer: Uint16Array) => Float32Array {\n  // Algorithm is based off of\n  // http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\n  // Cache lookup tables\n  const mantisaTable = computeFloat16MantisaTable();\n  const exponentTable = computeFloat16ExponentTable();\n  const offsetTable = computeFloat16OffsetTable();\n\n  return (quantizedArray: Uint16Array) => {\n    const buffer = new ArrayBuffer(4 * quantizedArray.length);\n    const bufferUint32View = new Uint32Array(buffer);\n    for (let index = 0; index < quantizedArray.length; index++) {\n      const float16Bits = quantizedArray[index];\n      const float32Bits =\n          mantisaTable[offsetTable[float16Bits >> 10] + (float16Bits & 0x3ff)] +\n          exponentTable[float16Bits >> 10];\n      bufferUint32View[index] = float32Bits;\n    }\n    return new Float32Array(buffer);\n  };\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {IOHandler, LoadOptions} from './types';\n\nexport type IORouter = (url: string|string[], loadOptions?: LoadOptions) =>\n    IOHandler;\n\nexport class IORouterRegistry {\n  // Singleton instance.\n  private static instance: IORouterRegistry;\n\n  private saveRouters: IORouter[];\n  private loadRouters: IORouter[];\n\n  private constructor() {\n    this.saveRouters = [];\n    this.loadRouters = [];\n  }\n\n  private static getInstance(): IORouterRegistry {\n    if (IORouterRegistry.instance == null) {\n      IORouterRegistry.instance = new IORouterRegistry();\n    }\n    return IORouterRegistry.instance;\n  }\n\n  /**\n   * Register a save-handler router.\n   *\n   * @param saveRouter A function that maps a URL-like string onto an instance\n   * of `IOHandler` with the `save` method defined or `null`.\n   */\n  static registerSaveRouter(saveRouter: IORouter) {\n    IORouterRegistry.getInstance().saveRouters.push(saveRouter);\n  }\n\n  /**\n   * Register a load-handler router.\n   *\n   * @param loadRouter A function that maps a URL-like string onto an instance\n   * of `IOHandler` with the `load` method defined or `null`.\n   */\n  static registerLoadRouter(loadRouter: IORouter) {\n    IORouterRegistry.getInstance().loadRouters.push(loadRouter);\n  }\n\n  /**\n   * Look up IOHandler for saving, given a URL-like string.\n   *\n   * @param url\n   * @returns If only one match is found, an instance of IOHandler with the\n   * `save` method defined. If no match is found, `null`.\n   * @throws Error, if more than one match is found.\n   */\n  static getSaveHandlers(url: string|string[]): IOHandler[] {\n    return IORouterRegistry.getHandlers(url, 'save');\n  }\n\n  /**\n   * Look up IOHandler for loading, given a URL-like string.\n   *\n   * @param url\n   * @param loadOptions Optional, custom load options.\n   * @returns All valid handlers for `url`, given the currently registered\n   *   handler routers.\n   */\n  static getLoadHandlers(url: string|string[], loadOptions?: LoadOptions):\n      IOHandler[] {\n    return IORouterRegistry.getHandlers(url, 'load', loadOptions);\n  }\n\n  private static getHandlers(\n      url: string|string[], handlerType: 'save'|'load',\n      loadOptions?: LoadOptions): IOHandler[] {\n    const validHandlers: IOHandler[] = [];\n    const routers = handlerType === 'load' ?\n        IORouterRegistry.getInstance().loadRouters :\n        IORouterRegistry.getInstance().saveRouters;\n    routers.forEach(router => {\n      const handler = router(url, loadOptions);\n      if (handler !== null) {\n        validHandlers.push(handler);\n      }\n    });\n    return validHandlers;\n  }\n}\n\nexport const registerSaveRouter = (loudRouter: IORouter) =>\n    IORouterRegistry.registerSaveRouter(loudRouter);\nexport const registerLoadRouter = (loudRouter: IORouter) =>\n    IORouterRegistry.registerLoadRouter(loudRouter);\nexport const getSaveHandlers = (url: string|string[]) =>\n    IORouterRegistry.getSaveHandlers(url);\nexport const getLoadHandlers =\n    (url: string|string[], loadOptions?: LoadOptions) =>\n        IORouterRegistry.getLoadHandlers(url, loadOptions);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport '../flags';\n\nimport {env} from '../environment';\n\nimport {getModelArtifactsInfoForJSON} from './io_utils';\nimport {IORouter, IORouterRegistry} from './router_registry';\nimport {IOHandler, ModelArtifacts, ModelArtifactsInfo, ModelStoreManager, SaveResult} from './types';\n\nconst DATABASE_NAME = 'tensorflowjs';\nconst DATABASE_VERSION = 1;\n\n// Model data and ModelArtifactsInfo (metadata) are stored in two separate\n// stores for efficient access of the list of stored models and their metadata.\n// 1. The object store for model data: topology, weights and weight manifests.\nconst MODEL_STORE_NAME = 'models_store';\n// 2. The object store for ModelArtifactsInfo, including meta-information such\n//    as the type of topology (JSON vs binary), byte size of the topology, byte\n//    size of the weights, etc.\nconst INFO_STORE_NAME = 'model_info_store';\n\n/**\n * Delete the entire database for tensorflow.js, including the models store.\n */\nexport async function deleteDatabase(): Promise<void> {\n  const idbFactory = getIndexedDBFactory();\n\n  return new Promise<void>((resolve, reject) => {\n    const deleteRequest = idbFactory.deleteDatabase(DATABASE_NAME);\n    deleteRequest.onsuccess = () => resolve();\n    deleteRequest.onerror = error => reject(error);\n  });\n}\n\nfunction getIndexedDBFactory(): IDBFactory {\n  if (!env().getBool('IS_BROWSER')) {\n    // TODO(cais): Add more info about what IOHandler subtypes are available.\n    //   Maybe point to a doc page on the web and/or automatically determine\n    //   the available IOHandlers and print them in the error message.\n    throw new Error(\n        'Failed to obtain IndexedDB factory because the current environment' +\n        'is not a web browser.');\n  }\n  // tslint:disable-next-line:no-any\n  const theWindow: any = typeof window === 'undefined' ? self : window;\n  const factory = theWindow.indexedDB || theWindow.mozIndexedDB ||\n      theWindow.webkitIndexedDB || theWindow.msIndexedDB ||\n      theWindow.shimIndexedDB;\n  if (factory == null) {\n    throw new Error(\n        'The current browser does not appear to support IndexedDB.');\n  }\n  return factory;\n}\n\nfunction setUpDatabase(openRequest: IDBRequest) {\n  const db = openRequest.result as IDBDatabase;\n  db.createObjectStore(MODEL_STORE_NAME, {keyPath: 'modelPath'});\n  db.createObjectStore(INFO_STORE_NAME, {keyPath: 'modelPath'});\n}\n\n/**\n * IOHandler subclass: Browser IndexedDB.\n *\n * See the doc string of `browserIndexedDB` for more details.\n */\nexport class BrowserIndexedDB implements IOHandler {\n  protected readonly indexedDB: IDBFactory;\n  protected readonly modelPath: string;\n\n  static readonly URL_SCHEME = 'indexeddb://';\n\n  constructor(modelPath: string) {\n    this.indexedDB = getIndexedDBFactory();\n\n    if (modelPath == null || !modelPath) {\n      throw new Error(\n          'For IndexedDB, modelPath must not be null, undefined or empty.');\n    }\n    this.modelPath = modelPath;\n  }\n\n  async save(modelArtifacts: ModelArtifacts): Promise<SaveResult> {\n    // TODO(cais): Support saving GraphDef models.\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n      throw new Error(\n          'BrowserLocalStorage.save() does not support saving model topology ' +\n          'in binary formats yet.');\n    }\n\n    return this.databaseAction(this.modelPath, modelArtifacts) as\n        Promise<SaveResult>;\n  }\n\n  async load(): Promise<ModelArtifacts> {\n    return this.databaseAction(this.modelPath) as Promise<ModelArtifacts>;\n  }\n\n  /**\n   * Perform database action to put model artifacts into or read model artifacts\n   * from IndexedDB object store.\n   *\n   * Whether the action is put or get depends on whether `modelArtifacts` is\n   * specified. If it is specified, the action will be put; otherwise the action\n   * will be get.\n   *\n   * @param modelPath A unique string path for the model.\n   * @param modelArtifacts If specified, it will be the model artifacts to be\n   *   stored in IndexedDB.\n   * @returns A `Promise` of `SaveResult`, if the action is put, or a `Promise`\n   *   of `ModelArtifacts`, if the action is get.\n   */\n  private databaseAction(modelPath: string, modelArtifacts?: ModelArtifacts):\n      Promise<ModelArtifacts|SaveResult> {\n    return new Promise<ModelArtifacts|SaveResult>((resolve, reject) => {\n      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n\n      openRequest.onsuccess = () => {\n        const db = openRequest.result;\n\n        if (modelArtifacts == null) {\n          // Read model out from object store.\n          const modelTx = db.transaction(MODEL_STORE_NAME, 'readonly');\n          const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n          const getRequest = modelStore.get(this.modelPath);\n          getRequest.onsuccess = () => {\n            if (getRequest.result == null) {\n              db.close();\n              return reject(new Error(\n                  `Cannot find model with path '${this.modelPath}' ` +\n                  `in IndexedDB.`));\n            } else {\n              resolve(getRequest.result.modelArtifacts);\n            }\n          };\n          getRequest.onerror = error => {\n            db.close();\n            return reject(getRequest.error);\n          };\n          modelTx.oncomplete = () => db.close();\n        } else {\n          // Put model into object store.\n          const modelArtifactsInfo: ModelArtifactsInfo =\n              getModelArtifactsInfoForJSON(modelArtifacts);\n          // First, put ModelArtifactsInfo into info store.\n          const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n          let infoStore = infoTx.objectStore(INFO_STORE_NAME);\n          const putInfoRequest =\n              infoStore.put({modelPath: this.modelPath, modelArtifactsInfo});\n          let modelTx: IDBTransaction;\n          putInfoRequest.onsuccess = () => {\n            // Second, put model data into model store.\n            modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n            const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n            const putModelRequest = modelStore.put({\n              modelPath: this.modelPath,\n              modelArtifacts,\n              modelArtifactsInfo\n            });\n            putModelRequest.onsuccess = () => resolve({modelArtifactsInfo});\n            putModelRequest.onerror = error => {\n              // If the put-model request fails, roll back the info entry as\n              // well.\n              infoStore = infoTx.objectStore(INFO_STORE_NAME);\n              const deleteInfoRequest = infoStore.delete(this.modelPath);\n              deleteInfoRequest.onsuccess = () => {\n                db.close();\n                return reject(putModelRequest.error);\n              };\n              deleteInfoRequest.onerror = error => {\n                db.close();\n                return reject(putModelRequest.error);\n              };\n            };\n          };\n          putInfoRequest.onerror = error => {\n            db.close();\n            return reject(putInfoRequest.error);\n          };\n          infoTx.oncomplete = () => {\n            if (modelTx == null) {\n              db.close();\n            } else {\n              modelTx.oncomplete = () => db.close();\n            }\n          };\n        }\n      };\n      openRequest.onerror = error => reject(openRequest.error);\n    });\n  }\n}\n\nexport const indexedDBRouter: IORouter = (url: string|string[]) => {\n  if (!env().getBool('IS_BROWSER')) {\n    return null;\n  } else {\n    if (!Array.isArray(url) && url.startsWith(BrowserIndexedDB.URL_SCHEME)) {\n      return browserIndexedDB(url.slice(BrowserIndexedDB.URL_SCHEME.length));\n    } else {\n      return null;\n    }\n  }\n};\nIORouterRegistry.registerSaveRouter(indexedDBRouter);\nIORouterRegistry.registerLoadRouter(indexedDBRouter);\n\n/**\n * Creates a browser IndexedDB IOHandler for saving and loading models.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save('indexeddb://MyModel'));\n * console.log(saveResult);\n * ```\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `BrowserIndexedDB` (sublcass of `IOHandler`),\n *   which can be used with, e.g., `tf.Model.save`.\n */\nexport function browserIndexedDB(modelPath: string): IOHandler {\n  return new BrowserIndexedDB(modelPath);\n}\n\nfunction maybeStripScheme(key: string) {\n  return key.startsWith(BrowserIndexedDB.URL_SCHEME) ?\n      key.slice(BrowserIndexedDB.URL_SCHEME.length) :\n      key;\n}\n\nexport class BrowserIndexedDBManager implements ModelStoreManager {\n  private indexedDB: IDBFactory;\n\n  constructor() {\n    this.indexedDB = getIndexedDBFactory();\n  }\n\n  async listModels(): Promise<{[path: string]: ModelArtifactsInfo}> {\n    return new Promise<{[path: string]: ModelArtifactsInfo}>(\n        (resolve, reject) => {\n          const openRequest =\n              this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n          openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n\n          openRequest.onsuccess = () => {\n            const db = openRequest.result;\n            const tx = db.transaction(INFO_STORE_NAME, 'readonly');\n            const store = tx.objectStore(INFO_STORE_NAME);\n            // tslint:disable:max-line-length\n            // Need to cast `store` as `any` here because TypeScript's DOM\n            // library does not have the `getAll()` method even though the\n            // method is supported in the latest version of most mainstream\n            // browsers:\n            // https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/getAll\n            // tslint:enable:max-line-length\n            // tslint:disable-next-line:no-any\n            const getAllInfoRequest = (store as any).getAll() as IDBRequest;\n            getAllInfoRequest.onsuccess = () => {\n              const out: {[path: string]: ModelArtifactsInfo} = {};\n              for (const item of getAllInfoRequest.result) {\n                out[item.modelPath] = item.modelArtifactsInfo;\n              }\n              resolve(out);\n            };\n            getAllInfoRequest.onerror = error => {\n              db.close();\n              return reject(getAllInfoRequest.error);\n            };\n            tx.oncomplete = () => db.close();\n          };\n          openRequest.onerror = error => reject(openRequest.error);\n        });\n  }\n\n  async removeModel(path: string): Promise<ModelArtifactsInfo> {\n    path = maybeStripScheme(path);\n    return new Promise<ModelArtifactsInfo>((resolve, reject) => {\n      const openRequest = this.indexedDB.open(DATABASE_NAME, DATABASE_VERSION);\n      openRequest.onupgradeneeded = () => setUpDatabase(openRequest);\n\n      openRequest.onsuccess = () => {\n        const db = openRequest.result;\n        const infoTx = db.transaction(INFO_STORE_NAME, 'readwrite');\n        const infoStore = infoTx.objectStore(INFO_STORE_NAME);\n\n        const getInfoRequest = infoStore.get(path);\n        let modelTx: IDBTransaction;\n        getInfoRequest.onsuccess = () => {\n          if (getInfoRequest.result == null) {\n            db.close();\n            return reject(new Error(\n                `Cannot find model with path '${path}' ` +\n                `in IndexedDB.`));\n          } else {\n            // First, delete the entry in the info store.\n            const deleteInfoRequest = infoStore.delete(path);\n            const deleteModelData = () => {\n              // Second, delete the entry in the model store.\n              modelTx = db.transaction(MODEL_STORE_NAME, 'readwrite');\n              const modelStore = modelTx.objectStore(MODEL_STORE_NAME);\n              const deleteModelRequest = modelStore.delete(path);\n              deleteModelRequest.onsuccess = () =>\n                  resolve(getInfoRequest.result.modelArtifactsInfo);\n              deleteModelRequest.onerror = error =>\n                  reject(getInfoRequest.error);\n            };\n            // Proceed with deleting model data regardless of whether deletion\n            // of info data succeeds or not.\n            deleteInfoRequest.onsuccess = deleteModelData;\n            deleteInfoRequest.onerror = error => {\n              deleteModelData();\n              db.close();\n              return reject(getInfoRequest.error);\n            };\n          }\n        };\n        getInfoRequest.onerror = error => {\n          db.close();\n          return reject(getInfoRequest.error);\n        };\n\n        infoTx.oncomplete = () => {\n          if (modelTx == null) {\n            db.close();\n          } else {\n            modelTx.oncomplete = () => db.close();\n          }\n        };\n      };\n      openRequest.onerror = error => reject(openRequest.error);\n    });\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport '../flags';\nimport {env} from '../environment';\n\nimport {assert} from '../util';\nimport {arrayBufferToBase64String, base64StringToArrayBuffer, getModelArtifactsInfoForJSON} from './io_utils';\nimport {IORouter, IORouterRegistry} from './router_registry';\nimport {IOHandler, ModelArtifacts, ModelArtifactsInfo, ModelJSON, ModelStoreManager, SaveResult} from './types';\n\nconst PATH_SEPARATOR = '/';\nconst PATH_PREFIX = 'tensorflowjs_models';\nconst INFO_SUFFIX = 'info';\nconst MODEL_TOPOLOGY_SUFFIX = 'model_topology';\nconst WEIGHT_SPECS_SUFFIX = 'weight_specs';\nconst WEIGHT_DATA_SUFFIX = 'weight_data';\nconst MODEL_METADATA_SUFFIX = 'model_metadata';\n\n/**\n * Purge all tensorflow.js-saved model artifacts from local storage.\n *\n * @returns Paths of the models purged.\n */\nexport function purgeLocalStorageArtifacts(): string[] {\n  if (!env().getBool('IS_BROWSER') || typeof window === 'undefined' ||\n      typeof window.localStorage === 'undefined') {\n    throw new Error(\n        'purgeLocalStorageModels() cannot proceed because local storage is ' +\n        'unavailable in the current environment.');\n  }\n  const LS = window.localStorage;\n  const purgedModelPaths: string[] = [];\n  for (let i = 0; i < LS.length; ++i) {\n    const key = LS.key(i);\n    const prefix = PATH_PREFIX + PATH_SEPARATOR;\n    if (key.startsWith(prefix) && key.length > prefix.length) {\n      LS.removeItem(key);\n      const modelName = getModelPathFromKey(key);\n      if (purgedModelPaths.indexOf(modelName) === -1) {\n        purgedModelPaths.push(modelName);\n      }\n    }\n  }\n  return purgedModelPaths;\n}\n\ntype LocalStorageKeys = {\n  /** Key of the localStorage entry storing `ModelArtifactsInfo`. */\n  info: string,\n  /**\n   * Key of the localStorage entry storing the 'modelTopology' key of\n   * `model.json`\n   */\n  topology: string,\n  /**\n   * Key of the localStorage entry storing the `weightsManifest.weights` entries\n   * of `model.json`\n   */\n  weightSpecs: string,\n  /** Key of the localStorage entry storing the weight data in Base64 */\n  weightData: string,\n  /**\n   * Key of the localStorage entry storing the remaining fields of `model.json`\n   * @see {@link ModelMetadata}\n   */\n  modelMetadata: string,\n};\n\ntype ModelMetadata = Omit<ModelJSON, 'modelTopology'|'weightsManifest'>;\n\nfunction getModelKeys(path: string): LocalStorageKeys {\n  return {\n    info: [PATH_PREFIX, path, INFO_SUFFIX].join(PATH_SEPARATOR),\n    topology: [PATH_PREFIX, path, MODEL_TOPOLOGY_SUFFIX].join(PATH_SEPARATOR),\n    weightSpecs: [PATH_PREFIX, path, WEIGHT_SPECS_SUFFIX].join(PATH_SEPARATOR),\n    weightData: [PATH_PREFIX, path, WEIGHT_DATA_SUFFIX].join(PATH_SEPARATOR),\n    modelMetadata:\n        [PATH_PREFIX, path, MODEL_METADATA_SUFFIX].join(PATH_SEPARATOR)\n  };\n}\n\nfunction removeItems(keys: LocalStorageKeys): void {\n  for (const key of Object.values(keys)) {\n    window.localStorage.removeItem(key);\n  }\n}\n\n/**\n * Get model path from a local-storage key.\n *\n * E.g., 'tensorflowjs_models/my/model/1/info' --> 'my/model/1'\n *\n * @param key\n */\nfunction getModelPathFromKey(key: string) {\n  const items = key.split(PATH_SEPARATOR);\n  if (items.length < 3) {\n    throw new Error(`Invalid key format: ${key}`);\n  }\n  return items.slice(1, items.length - 1).join(PATH_SEPARATOR);\n}\n\nfunction maybeStripScheme(key: string) {\n  return key.startsWith(BrowserLocalStorage.URL_SCHEME) ?\n      key.slice(BrowserLocalStorage.URL_SCHEME.length) :\n      key;\n}\n\n/**\n * IOHandler subclass: Browser Local Storage.\n *\n * See the doc string to `browserLocalStorage` for more details.\n */\nexport class BrowserLocalStorage implements IOHandler {\n  protected readonly LS: Storage;\n  protected readonly modelPath: string;\n  protected readonly keys: LocalStorageKeys;\n\n  static readonly URL_SCHEME = 'localstorage://';\n\n  constructor(modelPath: string) {\n    if (!env().getBool('IS_BROWSER') || typeof window === 'undefined' ||\n        typeof window.localStorage === 'undefined') {\n      // TODO(cais): Add more info about what IOHandler subtypes are\n      // available.\n      //   Maybe point to a doc page on the web and/or automatically determine\n      //   the available IOHandlers and print them in the error message.\n      throw new Error(\n          'The current environment does not support local storage.');\n    }\n    this.LS = window.localStorage;\n\n    if (modelPath == null || !modelPath) {\n      throw new Error(\n          'For local storage, modelPath must not be null, undefined or empty.');\n    }\n    this.modelPath = modelPath;\n    this.keys = getModelKeys(this.modelPath);\n  }\n\n  /**\n   * Save model artifacts to browser local storage.\n   *\n   * See the documentation to `browserLocalStorage` for details on the saved\n   * artifacts.\n   *\n   * @param modelArtifacts The model artifacts to be stored.\n   * @returns An instance of SaveResult.\n   */\n  async save(modelArtifacts: ModelArtifacts): Promise<SaveResult> {\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n      throw new Error(\n          'BrowserLocalStorage.save() does not support saving model topology ' +\n          'in binary formats yet.');\n    } else {\n      const topology = JSON.stringify(modelArtifacts.modelTopology);\n      const weightSpecs = JSON.stringify(modelArtifacts.weightSpecs);\n\n      const modelArtifactsInfo: ModelArtifactsInfo =\n          getModelArtifactsInfoForJSON(modelArtifacts);\n\n      try {\n        this.LS.setItem(this.keys.info, JSON.stringify(modelArtifactsInfo));\n        this.LS.setItem(this.keys.topology, topology);\n        this.LS.setItem(this.keys.weightSpecs, weightSpecs);\n        this.LS.setItem(\n            this.keys.weightData,\n            arrayBufferToBase64String(modelArtifacts.weightData));\n\n        // Note that JSON.stringify doesn't write out keys that have undefined\n        // values, so for some keys, we set undefined instead of a null-ish\n        // value.\n        const metadata: Required<ModelMetadata> = {\n          format: modelArtifacts.format,\n          generatedBy: modelArtifacts.generatedBy,\n          convertedBy: modelArtifacts.convertedBy,\n          signature: modelArtifacts.signature != null ?\n              modelArtifacts.signature :\n              undefined,\n          userDefinedMetadata: modelArtifacts.userDefinedMetadata != null ?\n              modelArtifacts.userDefinedMetadata :\n              undefined,\n          modelInitializer: modelArtifacts.modelInitializer != null ?\n              modelArtifacts.modelInitializer :\n              undefined,\n          trainingConfig: modelArtifacts.trainingConfig != null ?\n              modelArtifacts.trainingConfig :\n              undefined\n        };\n        this.LS.setItem(this.keys.modelMetadata, JSON.stringify(metadata));\n\n        return {modelArtifactsInfo};\n      } catch (err) {\n        // If saving failed, clean up all items saved so far.\n        removeItems(this.keys);\n\n        throw new Error(\n            `Failed to save model '${this.modelPath}' to local storage: ` +\n            `size quota being exceeded is a possible cause of this failure: ` +\n            `modelTopologyBytes=${modelArtifactsInfo.modelTopologyBytes}, ` +\n            `weightSpecsBytes=${modelArtifactsInfo.weightSpecsBytes}, ` +\n            `weightDataBytes=${modelArtifactsInfo.weightDataBytes}.`);\n      }\n    }\n  }\n\n  /**\n   * Load a model from local storage.\n   *\n   * See the documentation to `browserLocalStorage` for details on the saved\n   * artifacts.\n   *\n   * @returns The loaded model (if loading succeeds).\n   */\n  async load(): Promise<ModelArtifacts> {\n    const info =\n        JSON.parse(this.LS.getItem(this.keys.info)) as ModelArtifactsInfo;\n    if (info == null) {\n      throw new Error(\n          `In local storage, there is no model with name '${this.modelPath}'`);\n    }\n\n    if (info.modelTopologyType !== 'JSON') {\n      throw new Error(\n          'BrowserLocalStorage does not support loading non-JSON model ' +\n          'topology yet.');\n    }\n\n    const out: ModelArtifacts = {};\n\n    // Load topology.\n    const topology = JSON.parse(this.LS.getItem(this.keys.topology));\n    if (topology == null) {\n      throw new Error(\n          `In local storage, the topology of model '${this.modelPath}' ` +\n          `is missing.`);\n    }\n    out.modelTopology = topology;\n\n    // Load weight specs.\n    const weightSpecs = JSON.parse(this.LS.getItem(this.keys.weightSpecs));\n    if (weightSpecs == null) {\n      throw new Error(\n          `In local storage, the weight specs of model '${this.modelPath}' ` +\n          `are missing.`);\n    }\n    out.weightSpecs = weightSpecs;\n\n    // Load meta-data fields.\n    const metadataString = this.LS.getItem(this.keys.modelMetadata);\n    if (metadataString != null) {\n      const metadata = JSON.parse(metadataString) as ModelMetadata;\n      out.format = metadata.format;\n      out.generatedBy = metadata.generatedBy;\n      out.convertedBy = metadata.convertedBy;\n      if (metadata.signature != null) {\n        out.signature = metadata.signature;\n      }\n      if (metadata.userDefinedMetadata != null) {\n        out.userDefinedMetadata = metadata.userDefinedMetadata;\n      }\n      if (metadata.modelInitializer != null) {\n        out.modelInitializer = metadata.modelInitializer;\n      }\n      if (metadata.trainingConfig != null) {\n        out.trainingConfig = metadata.trainingConfig;\n      }\n    }\n\n    // Load weight data.\n    const weightDataBase64 = this.LS.getItem(this.keys.weightData);\n    if (weightDataBase64 == null) {\n      throw new Error(\n          `In local storage, the binary weight values of model ` +\n          `'${this.modelPath}' are missing.`);\n    }\n    out.weightData = base64StringToArrayBuffer(weightDataBase64);\n\n    return out;\n  }\n}\n\nexport const localStorageRouter: IORouter = (url: string|string[]) => {\n  if (!env().getBool('IS_BROWSER')) {\n    return null;\n  } else {\n    if (!Array.isArray(url) && url.startsWith(BrowserLocalStorage.URL_SCHEME)) {\n      return browserLocalStorage(\n          url.slice(BrowserLocalStorage.URL_SCHEME.length));\n    } else {\n      return null;\n    }\n  }\n};\nIORouterRegistry.registerSaveRouter(localStorageRouter);\nIORouterRegistry.registerLoadRouter(localStorageRouter);\n\n/**\n * Factory function for local storage IOHandler.\n *\n * This `IOHandler` supports both `save` and `load`.\n *\n * For each model's saved artifacts, four items are saved to local storage.\n *   - `${PATH_SEPARATOR}/${modelPath}/info`: Contains meta-info about the\n *     model, such as date saved, type of the topology, size in bytes, etc.\n *   - `${PATH_SEPARATOR}/${modelPath}/topology`: Model topology. For Keras-\n *     style models, this is a stringized JSON.\n *   - `${PATH_SEPARATOR}/${modelPath}/weight_specs`: Weight specs of the\n *     model, can be used to decode the saved binary weight values (see\n *     item below).\n *   - `${PATH_SEPARATOR}/${modelPath}/weight_data`: Concatenated binary\n *     weight values, stored as a base64-encoded string.\n *\n * Saving may throw an `Error` if the total size of the artifacts exceed the\n * browser-specific quota.\n *\n * @param modelPath A unique identifier for the model to be saved. Must be a\n *   non-empty string.\n * @returns An instance of `IOHandler`, which can be used with, e.g.,\n *   `tf.Model.save`.\n */\nexport function browserLocalStorage(modelPath: string): IOHandler {\n  return new BrowserLocalStorage(modelPath);\n}\n\nexport class BrowserLocalStorageManager implements ModelStoreManager {\n  private readonly LS: Storage;\n\n  constructor() {\n    assert(\n        env().getBool('IS_BROWSER'),\n        () => 'Current environment is not a web browser');\n    assert(\n        typeof window === 'undefined' ||\n            typeof window.localStorage !== 'undefined',\n        () => 'Current browser does not appear to support localStorage');\n    this.LS = window.localStorage;\n  }\n\n  async listModels(): Promise<{[path: string]: ModelArtifactsInfo}> {\n    const out: {[path: string]: ModelArtifactsInfo} = {};\n    const prefix = PATH_PREFIX + PATH_SEPARATOR;\n    const suffix = PATH_SEPARATOR + INFO_SUFFIX;\n    for (let i = 0; i < this.LS.length; ++i) {\n      const key = this.LS.key(i);\n      if (key.startsWith(prefix) && key.endsWith(suffix)) {\n        const modelPath = getModelPathFromKey(key);\n        out[modelPath] = JSON.parse(this.LS.getItem(key)) as ModelArtifactsInfo;\n      }\n    }\n    return out;\n  }\n\n  async removeModel(path: string): Promise<ModelArtifactsInfo> {\n    path = maybeStripScheme(path);\n    const keys = getModelKeys(path);\n    if (this.LS.getItem(keys.info) == null) {\n      throw new Error(`Cannot find model at path '${path}'`);\n    }\n    const info = JSON.parse(this.LS.getItem(keys.info)) as ModelArtifactsInfo;\n    removeItems(keys);\n    return info;\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Classes and functions for model management across multiple storage mediums.\n *\n * Supported client actions:\n * - Listing models on all registered storage mediums.\n * - Remove model by URL from any registered storage mediums, by using URL\n *   string.\n * - Moving or copying model from one path to another in the same medium or from\n *   one medium to another, by using URL strings.\n */\n\nimport {assert} from '../util';\n\nimport {IORouterRegistry} from './router_registry';\nimport {ModelArtifactsInfo, ModelStoreManager} from './types';\n\nconst URL_SCHEME_SUFFIX = '://';\n\nexport class ModelStoreManagerRegistry {\n  // Singleton instance.\n  private static instance: ModelStoreManagerRegistry;\n\n  private managers: {[scheme: string]: ModelStoreManager};\n\n  private constructor() {\n    this.managers = {};\n  }\n\n  private static getInstance(): ModelStoreManagerRegistry {\n    if (ModelStoreManagerRegistry.instance == null) {\n      ModelStoreManagerRegistry.instance = new ModelStoreManagerRegistry();\n    }\n    return ModelStoreManagerRegistry.instance;\n  }\n\n  /**\n   * Register a save-handler router.\n   *\n   * @param saveRouter A function that maps a URL-like string onto an instance\n   * of `IOHandler` with the `save` method defined or `null`.\n   */\n  static registerManager(scheme: string, manager: ModelStoreManager) {\n    assert(scheme != null, () => 'scheme must not be undefined or null.');\n    if (scheme.endsWith(URL_SCHEME_SUFFIX)) {\n      scheme = scheme.slice(0, scheme.indexOf(URL_SCHEME_SUFFIX));\n    }\n    assert(scheme.length > 0, () => 'scheme must not be an empty string.');\n    const registry = ModelStoreManagerRegistry.getInstance();\n    assert(\n        registry.managers[scheme] == null,\n        () => `A model store manager is already registered for scheme '${\n            scheme}'.`);\n    registry.managers[scheme] = manager;\n  }\n\n  static getManager(scheme: string): ModelStoreManager {\n    const manager = this.getInstance().managers[scheme];\n    if (manager == null) {\n      throw new Error(`Cannot find model manager for scheme '${scheme}'`);\n    }\n    return manager;\n  }\n\n  static getSchemes(): string[] {\n    return Object.keys(this.getInstance().managers);\n  }\n}\n\n/**\n * Helper method for parsing a URL string into a scheme and a path.\n *\n * @param url E.g., 'localstorage://my-model'\n * @returns A dictionary with two fields: scheme and path.\n *   Scheme: e.g., 'localstorage' in the example above.\n *   Path: e.g., 'my-model' in the example above.\n */\nfunction parseURL(url: string): {scheme: string, path: string} {\n  if (url.indexOf(URL_SCHEME_SUFFIX) === -1) {\n    throw new Error(\n        `The url string provided does not contain a scheme. ` +\n        `Supported schemes are: ` +\n        `${ModelStoreManagerRegistry.getSchemes().join(',')}`);\n  }\n  return {\n    scheme: url.split(URL_SCHEME_SUFFIX)[0],\n    path: url.split(URL_SCHEME_SUFFIX)[1],\n  };\n}\n\nasync function cloneModelInternal(\n    sourceURL: string, destURL: string,\n    deleteSource = false): Promise<ModelArtifactsInfo> {\n  assert(\n      sourceURL !== destURL,\n      () => `Old path and new path are the same: '${sourceURL}'`);\n\n  const loadHandlers = IORouterRegistry.getLoadHandlers(sourceURL);\n  assert(\n      loadHandlers.length > 0,\n      () => `Copying failed because no load handler is found for source URL ${\n          sourceURL}.`);\n  assert(\n      loadHandlers.length < 2,\n      () => `Copying failed because more than one (${loadHandlers.length}) ` +\n          `load handlers for source URL ${sourceURL}.`);\n  const loadHandler = loadHandlers[0];\n\n  const saveHandlers = IORouterRegistry.getSaveHandlers(destURL);\n  assert(\n      saveHandlers.length > 0,\n      () => `Copying failed because no save handler is found for destination ` +\n          `URL ${destURL}.`);\n  assert(\n      saveHandlers.length < 2,\n      () => `Copying failed because more than one (${loadHandlers.length}) ` +\n          `save handlers for destination URL ${destURL}.`);\n  const saveHandler = saveHandlers[0];\n\n  const sourceScheme = parseURL(sourceURL).scheme;\n  const sourcePath = parseURL(sourceURL).path;\n  const sameMedium = sourceScheme === parseURL(sourceURL).scheme;\n\n  const modelArtifacts = await loadHandler.load();\n\n  // If moving within the same storage medium, remove the old model as soon as\n  // the loading is done. Without doing this, it is possible that the combined\n  // size of the two models will cause the cloning to fail.\n  if (deleteSource && sameMedium) {\n    await ModelStoreManagerRegistry.getManager(sourceScheme)\n        .removeModel(sourcePath);\n  }\n\n  const saveResult = await saveHandler.save(modelArtifacts);\n\n  // If moving between mediums, the deletion is done after the save succeeds.\n  // This guards against the case in which saving to the destination medium\n  // fails.\n  if (deleteSource && !sameMedium) {\n    await ModelStoreManagerRegistry.getManager(sourceScheme)\n        .removeModel(sourcePath);\n  }\n\n  return saveResult.modelArtifactsInfo;\n}\n\n/**\n * List all models stored in registered storage mediums.\n *\n * For a web browser environment, the registered mediums are Local Storage and\n * IndexedDB.\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Delete the model.\n * await tf.io.removeModel('localstorage://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n * ```\n *\n * @returns A `Promise` of a dictionary mapping URLs of existing models to\n * their model artifacts info. URLs include medium-specific schemes, e.g.,\n *   'indexeddb://my/model/1'. Model artifacts info include type of the\n * model's topology, byte sizes of the topology, weights, etc.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function listModels(): Promise<{[url: string]: ModelArtifactsInfo}> {\n  const schemes = ModelStoreManagerRegistry.getSchemes();\n  const out: {[url: string]: ModelArtifactsInfo} = {};\n  for (const scheme of schemes) {\n    const schemeOut =\n        await ModelStoreManagerRegistry.getManager(scheme).listModels();\n    for (const path in schemeOut) {\n      const url = scheme + URL_SCHEME_SUFFIX + path;\n      out[url] = schemeOut[path];\n    }\n  }\n  return out;\n}\n\n/**\n * Remove a model specified by URL from a reigstered storage medium.\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Delete the model.\n * await tf.io.removeModel('localstorage://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n * ```\n *\n * @param url A URL to a stored model, with a scheme prefix, e.g.,\n *   'localstorage://my-model-1', 'indexeddb://my/model/2'.\n * @returns ModelArtifactsInfo of the deleted model (if and only if deletion\n *   is successful).\n * @throws Error if deletion fails, e.g., if no model exists at `path`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function removeModel(url: string): Promise<ModelArtifactsInfo> {\n  const schemeAndPath = parseURL(url);\n  const manager = ModelStoreManagerRegistry.getManager(schemeAndPath.scheme);\n  return manager.removeModel(schemeAndPath.path);\n}\n\n/**\n * Copy a model from one URL to another.\n *\n * This function supports:\n *\n * 1. Copying within a storage medium, e.g.,\n *    `tf.io.copyModel('localstorage://model-1', 'localstorage://model-2')`\n * 2. Copying between two storage mediums, e.g.,\n *    `tf.io.copyModel('localstorage://model-1', 'indexeddb://model-1')`\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Copy the model, from Local Storage to IndexedDB.\n * await tf.io.copyModel(\n *     'localstorage://demo/management/model1',\n *     'indexeddb://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Remove both models.\n * await tf.io.removeModel('localstorage://demo/management/model1');\n * await tf.io.removeModel('indexeddb://demo/management/model1');\n * ```\n *\n * @param sourceURL Source URL of copying.\n * @param destURL Destination URL of copying.\n * @returns ModelArtifactsInfo of the copied model (if and only if copying\n *   is successful).\n * @throws Error if copying fails, e.g., if no model exists at `sourceURL`, or\n *   if `oldPath` and `newPath` are identical.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function copyModel(\n    sourceURL: string, destURL: string): Promise<ModelArtifactsInfo> {\n  const deleteSource = false;\n  return cloneModelInternal(sourceURL, destURL, deleteSource);\n}\n\n/**\n * Move a model from one URL to another.\n *\n * This function supports:\n *\n * 1. Moving within a storage medium, e.g.,\n *    `tf.io.moveModel('localstorage://model-1', 'localstorage://model-2')`\n * 2. Moving between two storage mediums, e.g.,\n *    `tf.io.moveModel('localstorage://model-1', 'indexeddb://model-1')`\n *\n * ```js\n * // First create and save a model.\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * await model.save('localstorage://demo/management/model1');\n *\n * // Then list existing models.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Move the model, from Local Storage to IndexedDB.\n * await tf.io.moveModel(\n *     'localstorage://demo/management/model1',\n *     'indexeddb://demo/management/model1');\n *\n * // List models again.\n * console.log(JSON.stringify(await tf.io.listModels()));\n *\n * // Remove the moved model.\n * await tf.io.removeModel('indexeddb://demo/management/model1');\n * ```\n *\n * @param sourceURL Source URL of moving.\n * @param destURL Destination URL of moving.\n * @returns ModelArtifactsInfo of the copied model (if and only if copying\n *   is successful).\n * @throws Error if moving fails, e.g., if no model exists at `sourceURL`, or\n *   if `oldPath` and `newPath` are identical.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Management',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nasync function moveModel(\n    sourceURL: string, destURL: string): Promise<ModelArtifactsInfo> {\n  const deleteSource = true;\n  return cloneModelInternal(sourceURL, destURL, deleteSource);\n}\n\nexport {moveModel, copyModel, removeModel, listModels};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport '../flags';\n\nimport {env} from '../environment';\nimport {BrowserIndexedDB, BrowserIndexedDBManager} from '../io/indexed_db';\nimport {BrowserLocalStorage, BrowserLocalStorageManager} from '../io/local_storage';\nimport {ModelStoreManagerRegistry} from '../io/model_management';\n\nimport {Platform} from './platform';\n\nexport class PlatformBrowser implements Platform {\n  // According to the spec, the built-in encoder can do only UTF-8 encoding.\n  // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/TextEncoder\n  private textEncoder: TextEncoder;\n\n  fetch(path: string, init?: RequestInit): Promise<Response> {\n    return fetch(path, init);\n  }\n\n  now(): number {\n    return performance.now();\n  }\n\n  encode(text: string, encoding: string): Uint8Array {\n    if (encoding !== 'utf-8' && encoding !== 'utf8') {\n      throw new Error(\n          `Browser's encoder only supports utf-8, but got ${encoding}`);\n    }\n    if (this.textEncoder == null) {\n      this.textEncoder = new TextEncoder();\n    }\n    return this.textEncoder.encode(text);\n  }\n  decode(bytes: Uint8Array, encoding: string): string {\n    return new TextDecoder(encoding).decode(bytes);\n  }\n}\n\nif (env().get('IS_BROWSER')) {\n  env().setPlatform('browser', new PlatformBrowser());\n\n  // Register LocalStorage IOHandler\n  try {\n    ModelStoreManagerRegistry.registerManager(\n        BrowserLocalStorage.URL_SCHEME, new BrowserLocalStorageManager());\n  } catch (err) {\n  }\n\n  // Register IndexedDB IOHandler\n  try {\n    ModelStoreManagerRegistry.registerManager(\n        BrowserIndexedDB.URL_SCHEME, new BrowserIndexedDBManager());\n  } catch (err) {\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {env} from '../environment';\n\nimport {Platform} from './platform';\n\n// We are wrapping this within an object so it can be stubbed by Jasmine.\nexport const getNodeFetch = {\n  // tslint:disable-next-line:no-require-imports\n  importFetch: () => require('node-fetch')\n};\n\ntype FetchFn = (url: string, init?: RequestInit) => Promise<Response>;\nlet systemFetch: FetchFn;\n// These getters and setters are for testing so we don't export a mutable\n// variable.\nexport function resetSystemFetch() {\n  systemFetch = null;\n}\nexport function setSystemFetch(fetchFn: FetchFn) {\n  systemFetch = fetchFn;\n}\nexport function getSystemFetch(): FetchFn {\n  return systemFetch;\n}\n\nexport class PlatformNode implements Platform {\n  private textEncoder: TextEncoder;\n  // tslint:disable-next-line:no-any\n  util: any;\n\n  constructor() {\n    // tslint:disable-next-line:no-require-imports\n    this.util = require('util');\n    // According to the spec, the built-in encoder can do only UTF-8 encoding.\n    // https://developer.mozilla.org/en-US/docs/Web/API/TextEncoder/TextEncoder\n    this.textEncoder = new this.util.TextEncoder();\n  }\n\n  fetch(path: string, requestInits?: RequestInit): Promise<Response> {\n    if (env().global.fetch != null) {\n      return env().global.fetch(path, requestInits);\n    }\n\n    if (systemFetch == null) {\n      systemFetch = getNodeFetch.importFetch();\n    }\n    return systemFetch(path, requestInits);\n  }\n\n  now(): number {\n    const time = process.hrtime();\n    return time[0] * 1000 + time[1] / 1000000;\n  }\n\n  encode(text: string, encoding: string): Uint8Array {\n    if (encoding !== 'utf-8' && encoding !== 'utf8') {\n      throw new Error(\n          `Node built-in encoder only supports utf-8, but got ${encoding}`);\n    }\n    return this.textEncoder.encode(text);\n  }\n  decode(bytes: Uint8Array, encoding: string): string {\n    if (bytes.length === 0) {\n      return '';\n    }\n    return new this.util.TextDecoder(encoding).decode(bytes);\n  }\n}\n\nif (env().get('IS_NODE')) {\n  env().setPlatform('node', new PlatformNode());\n}\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorBuffer} from '../tensor';\nimport {DataType, DataTypeMap, Rank, ShapeMap} from '../types';\nimport * as util from '../util';\n\n/**\n * Creates an empty `tf.TensorBuffer` with the specified `shape` and `dtype`.\n *\n * The values are stored in CPU as `TypedArray`. Fill the buffer using\n * `buffer.set()`, or by modifying directly `buffer.values`.\n *\n * When done, call `buffer.toTensor()` to get an immutable `tf.Tensor` with\n * those values.\n *\n * ```js\n * // Create a buffer and set values at particular indices.\n * const buffer = tf.buffer([2, 2]);\n * buffer.set(3, 0, 0);\n * buffer.set(5, 1, 0);\n *\n * // Convert the buffer back to a tensor.\n * buffer.toTensor().print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The dtype of the buffer. Defaults to 'float32'.\n * @param values The values of the buffer as `TypedArray`. Defaults to\n * zeros.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function buffer<R extends Rank, D extends DataType = 'float32'>(\n    shape: ShapeMap[R], dtype: D = 'float32' as D,\n    values?: DataTypeMap[D]): TensorBuffer<R, D> {\n  dtype = dtype || 'float32' as D;\n  util.assertNonNegativeIntegerDimensions(shape);\n  return new TensorBuffer<R, D>(shape, dtype, values);\n}\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Cast, CastAttrs, CastInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {DataType, TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Casts a `tf.Tensor` to a new dtype.\n *\n * ```js\n * const x = tf.tensor1d([1.5, 2.5, 3]);\n * tf.cast(x, 'int32').print();\n * ```\n * @param x The input tensor to be casted.\n * @param dtype The dtype to cast the input tensor to.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction cast_<T extends Tensor>(x: T|TensorLike, dtype: DataType): T {\n  const $x = convertToTensor(x, 'x', 'cast');\n\n  // Sanity checks.\n  if (!util.isValidDtype(dtype)) {\n    throw new Error(`Failed to cast to unknown dtype ${dtype}`);\n  }\n  if (dtype === 'string' && $x.dtype !== 'string' ||\n      dtype !== 'string' && $x.dtype === 'string') {\n    throw new Error('Only strings can be casted to strings');\n  }\n\n  const inputs: CastInputs = {x: $x};\n  const attrs: CastAttrs = {dtype};\n\n  return ENGINE.runKernel(\n      Cast, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const cast = op({cast_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Identity, IdentityInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Creates a new tensor with the same values and shape as the specified\n * tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n *\n * x.clone().print();\n * ```\n *\n * @param x The tensor to clone.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction clone_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'clone', 'string_or_numeric');\n  const inputs: IdentityInputs = {x: $x};\n\n  // Note this op is called tf.identity in python. Hence the kernel name used\n  // here.\n  return ENGINE.runKernel(Identity, inputs as {} as NamedTensorMap);\n}\n\nexport const clone = op({clone_});\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\n\n/**\n * Prints information about the `tf.Tensor` including its data.\n *\n * ```js\n * const verbose = true;\n * tf.tensor2d([1, 2, 3, 4], [2, 2]).print(verbose);\n * ```\n * @param x The tensor to be printed.\n * @param verbose Whether to print verbose information about the ` Tensor`,\n * including dtype and size.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function print<T extends Tensor>(x: T, verbose = false): void {\n  console.log(x.toString(verbose));\n}\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Required side effectful code for tfjs-core\n\n// Set up Engine and ENV\nimport {getOrMakeEngine} from './engine';\ngetOrMakeEngine();\n\n// Register backend-agnostic flags.\nimport './flags';\n// Register platforms\nimport './platforms/platform_browser';\nimport './platforms/platform_node';\n\n// Set up OpHandler\nimport {buffer} from './ops/buffer';\nimport {cast} from './ops/cast';\nimport {clone} from './ops/clone';\nimport {print} from './ops/print';\nimport {OpHandler, setOpHandler} from './tensor';\nconst opHandler: OpHandler = {\n  buffer,\n  cast,\n  clone,\n  print\n};\nsetOpHandler(opHandler);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * IOHandlers related to files, such as browser-triggered file downloads,\n * user-selected files in browser.\n */\n\nimport '../flags';\nimport {env} from '../environment';\n\nimport {basename, concatenateArrayBuffers, getModelArtifactsForJSON, getModelArtifactsInfoForJSON, getModelJSONForModelArtifacts} from './io_utils';\nimport {IORouter, IORouterRegistry} from './router_registry';\nimport {IOHandler, ModelArtifacts, ModelJSON, SaveResult, WeightsManifestConfig, WeightsManifestEntry} from './types';\n\nconst DEFAULT_FILE_NAME_PREFIX = 'model';\nconst DEFAULT_JSON_EXTENSION_NAME = '.json';\nconst DEFAULT_WEIGHT_DATA_EXTENSION_NAME = '.weights.bin';\n\nfunction defer<T>(f: () => T): Promise<T> {\n  return new Promise(resolve => setTimeout(resolve)).then(f);\n}\n\nexport class BrowserDownloads implements IOHandler {\n  private readonly modelJsonFileName: string;\n  private readonly weightDataFileName: string;\n  private readonly modelJsonAnchor: HTMLAnchorElement;\n  private readonly weightDataAnchor: HTMLAnchorElement;\n\n  static readonly URL_SCHEME = 'downloads://';\n\n  constructor(fileNamePrefix?: string) {\n    if (!env().getBool('IS_BROWSER')) {\n      // TODO(cais): Provide info on what IOHandlers are available under the\n      //   current environment.\n      throw new Error(\n          'browserDownloads() cannot proceed because the current environment ' +\n          'is not a browser.');\n    }\n\n    if (fileNamePrefix.startsWith(BrowserDownloads.URL_SCHEME)) {\n      fileNamePrefix = fileNamePrefix.slice(BrowserDownloads.URL_SCHEME.length);\n    }\n    if (fileNamePrefix == null || fileNamePrefix.length === 0) {\n      fileNamePrefix = DEFAULT_FILE_NAME_PREFIX;\n    }\n\n    this.modelJsonFileName = fileNamePrefix + DEFAULT_JSON_EXTENSION_NAME;\n    this.weightDataFileName =\n        fileNamePrefix + DEFAULT_WEIGHT_DATA_EXTENSION_NAME;\n  }\n\n  async save(modelArtifacts: ModelArtifacts): Promise<SaveResult> {\n    if (typeof (document) === 'undefined') {\n      throw new Error(\n          'Browser downloads are not supported in ' +\n          'this environment since `document` is not present');\n    }\n    const weightsURL = window.URL.createObjectURL(new Blob(\n        [modelArtifacts.weightData], {type: 'application/octet-stream'}));\n\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n      throw new Error(\n          'BrowserDownloads.save() does not support saving model topology ' +\n          'in binary formats yet.');\n    } else {\n      const weightsManifest: WeightsManifestConfig = [{\n        paths: ['./' + this.weightDataFileName],\n        weights: modelArtifacts.weightSpecs\n      }];\n      const modelJSON: ModelJSON =\n          getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);\n\n      const modelJsonURL = window.URL.createObjectURL(\n          new Blob([JSON.stringify(modelJSON)], {type: 'application/json'}));\n\n      // If anchor elements are not provided, create them without attaching them\n      // to parents, so that the downloaded file names can be controlled.\n      const jsonAnchor = this.modelJsonAnchor == null ?\n          document.createElement('a') :\n          this.modelJsonAnchor;\n      jsonAnchor.download = this.modelJsonFileName;\n      jsonAnchor.href = modelJsonURL;\n      // Trigger downloads by evoking a click event on the download anchors.\n      // When multiple downloads are started synchronously, Firefox will only\n      // save the last one.\n      await defer(() => jsonAnchor.dispatchEvent(new MouseEvent('click')));\n\n      if (modelArtifacts.weightData != null) {\n        const weightDataAnchor = this.weightDataAnchor == null ?\n            document.createElement('a') :\n            this.weightDataAnchor;\n        weightDataAnchor.download = this.weightDataFileName;\n        weightDataAnchor.href = weightsURL;\n        await defer(\n            () => weightDataAnchor.dispatchEvent(new MouseEvent('click')));\n      }\n\n      return {modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts)};\n    }\n  }\n}\n\nclass BrowserFiles implements IOHandler {\n  private readonly jsonFile: File;\n  private readonly weightsFiles: File[];\n\n  constructor(files: File[]) {\n    if (files == null || files.length < 1) {\n      throw new Error(\n          `When calling browserFiles, at least 1 file is required, ` +\n          `but received ${files}`);\n    }\n    this.jsonFile = files[0];\n    this.weightsFiles = files.slice(1);\n  }\n\n  async load(): Promise<ModelArtifacts> {\n    return new Promise((resolve, reject) => {\n      const jsonReader = new FileReader();\n      jsonReader.onload = (event: Event) => {\n        // tslint:disable-next-line:no-any\n        const modelJSON = JSON.parse((event.target as any).result) as ModelJSON;\n\n        const modelTopology = modelJSON.modelTopology;\n        if (modelTopology == null) {\n          reject(new Error(`modelTopology field is missing from file ${\n              this.jsonFile.name}`));\n          return;\n        }\n\n        const weightsManifest = modelJSON.weightsManifest;\n        if (weightsManifest == null) {\n          reject(new Error(`weightManifest field is missing from file ${\n              this.jsonFile.name}`));\n          return;\n        }\n\n        if (this.weightsFiles.length === 0) {\n          resolve({modelTopology});\n          return;\n        }\n\n        const modelArtifactsPromise = getModelArtifactsForJSON(\n            modelJSON, (weightsManifest) => this.loadWeights(weightsManifest));\n        resolve(modelArtifactsPromise);\n      };\n\n      jsonReader.onerror = error => reject(\n          `Failed to read model topology and weights manifest JSON ` +\n          `from file '${this.jsonFile.name}'. BrowserFiles supports loading ` +\n          `Keras-style tf.Model artifacts only.`);\n      jsonReader.readAsText(this.jsonFile);\n    });\n  }\n\n  private loadWeights(weightsManifest: WeightsManifestConfig): Promise<[\n    /* weightSpecs */ WeightsManifestEntry[], /* weightData */ ArrayBuffer\n  ]> {\n    const weightSpecs: WeightsManifestEntry[] = [];\n    const paths: string[] = [];\n    for (const entry of weightsManifest) {\n      weightSpecs.push(...entry.weights);\n      paths.push(...entry.paths);\n    }\n\n    const pathToFile: {[path: string]: File} =\n        this.checkManifestAndWeightFiles(weightsManifest);\n\n    const promises: Array<Promise<ArrayBuffer>> =\n        paths.map(path => this.loadWeightsFile(path, pathToFile[path]));\n\n    return Promise.all(promises).then(\n        buffers => [weightSpecs, concatenateArrayBuffers(buffers)]);\n  }\n\n  private loadWeightsFile(path: string, file: File): Promise<ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      const weightFileReader = new FileReader();\n      weightFileReader.onload = (event: Event) => {\n        // tslint:disable-next-line:no-any\n        const weightData = (event.target as any).result as ArrayBuffer;\n        resolve(weightData);\n      };\n      weightFileReader.onerror = error =>\n          reject(`Failed to weights data from file of path '${path}'.`);\n      weightFileReader.readAsArrayBuffer(file);\n    });\n  }\n\n  /**\n   * Check the compatibility between weights manifest and weight files.\n   */\n  private checkManifestAndWeightFiles(manifest: WeightsManifestConfig):\n      {[path: string]: File} {\n    const basenames: string[] = [];\n    const fileNames = this.weightsFiles.map(file => basename(file.name));\n    const pathToFile: {[path: string]: File} = {};\n    for (const group of manifest) {\n      group.paths.forEach(path => {\n        const pathBasename = basename(path);\n        if (basenames.indexOf(pathBasename) !== -1) {\n          throw new Error(\n              `Duplicate file basename found in weights manifest: ` +\n              `'${pathBasename}'`);\n        }\n        basenames.push(pathBasename);\n        if (fileNames.indexOf(pathBasename) === -1) {\n          throw new Error(\n              `Weight file with basename '${pathBasename}' is not provided.`);\n        } else {\n          pathToFile[path] = this.weightsFiles[fileNames.indexOf(pathBasename)];\n        }\n      });\n    }\n\n    if (basenames.length !== this.weightsFiles.length) {\n      throw new Error(\n          `Mismatch in the number of files in weights manifest ` +\n          `(${basenames.length}) and the number of weight files provided ` +\n          `(${this.weightsFiles.length}).`);\n    }\n    return pathToFile;\n  }\n}\n\nexport const browserDownloadsRouter: IORouter = (url: string|string[]) => {\n  if (!env().getBool('IS_BROWSER')) {\n    return null;\n  } else {\n    if (!Array.isArray(url) && url.startsWith(BrowserDownloads.URL_SCHEME)) {\n      return browserDownloads(url.slice(BrowserDownloads.URL_SCHEME.length));\n    } else {\n      return null;\n    }\n  }\n};\nIORouterRegistry.registerSaveRouter(browserDownloadsRouter);\n\n/**\n * Creates an IOHandler that triggers file downloads from the browser.\n *\n * The returned `IOHandler` instance can be used as model exporting methods such\n * as `tf.Model.save` and supports only saving.\n *\n * ```js\n * const model = tf.sequential();\n * model.add(tf.layers.dense(\n *     {units: 1, inputShape: [10], activation: 'sigmoid'}));\n * const saveResult = await model.save('downloads://mymodel');\n * // This will trigger downloading of two files:\n * //   'mymodel.json' and 'mymodel.weights.bin'.\n * console.log(saveResult);\n * ```\n *\n * @param fileNamePrefix Prefix name of the files to be downloaded. For use with\n *   `tf.Model`, `fileNamePrefix` should follow either of the following two\n *   formats:\n *   1. `null` or `undefined`, in which case the default file\n *      names will be used:\n *      - 'model.json' for the JSON file containing the model topology and\n *        weights manifest.\n *      - 'model.weights.bin' for the binary file containing the binary weight\n *        values.\n *   2. A single string or an Array of a single string, as the file name prefix.\n *      For example, if `'foo'` is provided, the downloaded JSON\n *      file and binary weights file will be named 'foo.json' and\n *      'foo.weights.bin', respectively.\n * @param config Additional configuration for triggering downloads.\n * @returns An instance of `BrowserDownloads` `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function browserDownloads(fileNamePrefix = 'model'): IOHandler {\n  return new BrowserDownloads(fileNamePrefix);\n}\n\n/**\n * Creates an IOHandler that loads model artifacts from user-selected files.\n *\n * This method can be used for loading from files such as user-selected files\n * in the browser.\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * // Note: This code snippet won't run properly without the actual file input\n * //   elements in the HTML DOM.\n *\n * // Suppose there are two HTML file input (`<input type=\"file\" ...>`)\n * // elements.\n * const uploadJSONInput = document.getElementById('upload-json');\n * const uploadWeightsInput = document.getElementById('upload-weights');\n * const model = await tf.loadLayersModel(tf.io.browserFiles(\n *     [uploadJSONInput.files[0], uploadWeightsInput.files[0]]));\n * ```\n *\n * @param files `File`s to load from. Currently, this function supports only\n *   loading from files that contain Keras-style models (i.e., `tf.Model`s), for\n *   which an `Array` of `File`s is expected (in that order):\n *   - A JSON file containing the model topology and weight manifest.\n *   - Optionally, One or more binary files containing the binary weights.\n *     These files must have names that match the paths in the `weightsManifest`\n *     contained by the aforementioned JSON file, or errors will be thrown\n *     during loading. These weights files have the same format as the ones\n *     generated by `tensorflowjs_converter` that comes with the `tensorflowjs`\n *     Python PIP package. If no weights files are provided, only the model\n *     topology will be loaded from the JSON file above.\n * @returns An instance of `Files` `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function browserFiles(files: File[]): IOHandler {\n  return new BrowserFiles(files);\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {assert} from '../util';\n\nimport {OnProgressCallback} from './types';\n\n/**\n * Monitor Promise.all progress, fire onProgress callback function.\n *\n * @param promises Promise list going to be monitored\n * @param onProgress Callback function. Fired when a promise resolved.\n * @param startFraction Optional fraction start. Default to 0.\n * @param endFraction Optional fraction end. Default to 1.\n */\nexport function monitorPromisesProgress(\n    promises: Array<Promise<{}|void>>, onProgress: OnProgressCallback,\n    startFraction?: number, endFraction?: number) {\n  checkPromises(promises);\n  startFraction = startFraction == null ? 0 : startFraction;\n  endFraction = endFraction == null ? 1 : endFraction;\n  checkFraction(startFraction, endFraction);\n  let resolvedPromise = 0;\n\n  const registerMonitor = (promise: Promise<{}>) => {\n    promise.then(value => {\n      const fraction = startFraction +\n          ++resolvedPromise / promises.length * (endFraction - startFraction);\n      // pass fraction as parameter to callback function.\n      onProgress(fraction);\n      return value;\n    });\n    return promise;\n  };\n\n  function checkPromises(promises: Array<Promise<{}|void>>): void {\n    assert(\n        promises != null && Array.isArray(promises) && promises.length > 0,\n        () => 'promises must be a none empty array');\n  }\n\n  function checkFraction(startFraction: number, endFraction: number): void {\n    assert(\n        startFraction >= 0 && startFraction <= 1,\n        () => `Progress fraction must be in range [0, 1], but ` +\n            `got startFraction ${startFraction}`);\n    assert(\n        endFraction >= 0 && endFraction <= 1,\n        () => `Progress fraction must be in range [0, 1], but ` +\n            `got endFraction ${endFraction}`);\n    assert(\n        endFraction >= startFraction,\n        () => `startFraction must be no more than endFraction, but ` +\n            `got startFraction ${startFraction} and endFraction ` +\n            `${endFraction}`);\n  }\n\n  return Promise.all(promises.map(registerMonitor));\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '../environment';\n\nimport {NamedTensorMap} from '../tensor_types';\nimport * as util from '../util';\nimport {decodeWeights} from './io_utils';\nimport {monitorPromisesProgress} from './progress';\nimport {DTYPE_VALUE_SIZE_MAP, LoadOptions, WeightsManifestConfig, WeightsManifestEntry} from './types';\n\n/**\n * Reads binary weights data from a number of URLs.\n *\n * @param fetchURLs URLs to send the HTTP requests at, using `fetch` calls.\n * @param requestOptions RequestInit (options) for the HTTP requests.\n * @param fetchFunc Optional overriding value for the `window.fetch` function.\n * @param onProgress Optional, progress callback function, fired periodically\n *   before the load is completed.\n * @returns A `Promise` of an Array of `ArrayBuffer`. The Array has the same\n *   length as `fetchURLs`.\n */\nexport async function loadWeightsAsArrayBuffer(\n    fetchURLs: string[], loadOptions?: LoadOptions): Promise<ArrayBuffer[]> {\n  if (loadOptions == null) {\n    loadOptions = {};\n  }\n\n  const fetchFunc = loadOptions.fetchFunc == null ? env().platform.fetch :\n                                                    loadOptions.fetchFunc;\n\n  // Create the requests for all of the weights in parallel.\n  const requests = fetchURLs.map(\n      fetchURL =>\n          fetchFunc(fetchURL, loadOptions.requestInit, {isBinary: true}));\n\n  const fetchStartFraction = 0;\n  const fetchEndFraction = 0.5;\n\n  const responses = loadOptions.onProgress == null ?\n      await Promise.all(requests) :\n      await monitorPromisesProgress(\n          requests, loadOptions.onProgress, fetchStartFraction,\n          fetchEndFraction);\n\n  const bufferPromises = responses.map(response => response.arrayBuffer());\n\n  const bufferStartFraction = 0.5;\n  const bufferEndFraction = 1;\n\n  const buffers = loadOptions.onProgress == null ?\n      await Promise.all(bufferPromises) :\n      await monitorPromisesProgress(\n          bufferPromises, loadOptions.onProgress, bufferStartFraction,\n          bufferEndFraction);\n  return buffers;\n}\n\n/**\n * Reads a weights manifest JSON configuration, fetches the weights and\n * returns them as `Tensor`s.\n *\n * @param manifest The weights manifest JSON.\n * @param filePathPrefix The path prefix for filenames given in the manifest.\n *     Defaults to the empty string.\n * @param weightNames The names of the weights to be fetched.\n */\nexport async function loadWeights(\n    manifest: WeightsManifestConfig, filePathPrefix = '',\n    weightNames?: string[],\n    requestInit?: RequestInit): Promise<NamedTensorMap> {\n  // TODO(nsthorat): Groups are currently fetched atomically. If you need a\n  // single weight from a group, the whole group will be fetched. At a future\n  // date, we should support fetching only the individual shards within a\n  // group that are needed to reconstruct the requested weight.\n  // TODO(cais): Use `decodeWeights` for implementation.\n\n  const fetchWeights = (fetchUrls: string[]) =>\n      loadWeightsAsArrayBuffer(fetchUrls, {requestInit});\n  const loadWeights = weightsLoaderFactory(fetchWeights);\n\n  return loadWeights(manifest, filePathPrefix, weightNames);\n}\n\n/**\n * Creates a function, which reads a weights manifest JSON configuration,\n * fetches the weight files using the specified function and returns them as\n * `Tensor`s.\n *\n * ```js\n * // example for creating a nodejs weight loader, which reads the weight files\n * // from disk using fs.readFileSync\n *\n * import * as fs from 'fs'\n *\n * const fetchWeightsFromDisk = (filePaths: string[]) =>\n *   filePaths.map(filePath => fs.readFileSync(filePath).buffer)\n *\n * const loadWeights = tf.io.weightsLoaderFactory(fetchWeightsFromDisk)\n *\n * const manifest = JSON.parse(\n *   fs.readFileSync('./my_model-weights_manifest').toString()\n * )\n * const weightMap = await loadWeights(manifest, './')\n * ```\n * @param fetchWeightsFunction The function used for fetching the weight files.\n * @returns Weight loading function.\n */\nexport function weightsLoaderFactory(\n    fetchWeightsFunction: (fetchUrls: string[]) => Promise<ArrayBuffer[]>):\n    (manifest: WeightsManifestConfig, filePathPrefix?: string,\n     weightNames?: string[]) => Promise<NamedTensorMap> {\n  return async(\n             manifest: WeightsManifestConfig, filePathPrefix = '',\n             weightNames?: string[]): Promise<NamedTensorMap> => {\n    // Collect all the groups, weights, and their relative offsets to be\n    // fetched.\n    const groupIndicesToFetchMap = manifest.map(() => false);\n    const groupWeightsToFetch: {\n      [group: number]: Array<{\n        manifestEntry: WeightsManifestEntry; groupOffset: number;\n        sizeBytes: number;\n      }>\n    } = {};\n    const weightsFound =\n        weightNames != null ? weightNames.map(() => false) : [];\n    const allManifestWeightNames: string[] = [];\n    manifest.forEach((manifestGroupConfig, groupIndex) => {\n      let groupOffset = 0;\n      manifestGroupConfig.weights.forEach(weightsEntry => {\n        const rawDtype = ('quantization' in weightsEntry) ?\n            weightsEntry.quantization.dtype :\n            weightsEntry.dtype;\n\n        const weightsBytes = DTYPE_VALUE_SIZE_MAP[rawDtype] *\n            util.sizeFromShape(weightsEntry.shape);\n\n        const enqueueWeightsForFetchingFn = () => {\n          groupIndicesToFetchMap[groupIndex] = true;\n          if (groupWeightsToFetch[groupIndex] == null) {\n            groupWeightsToFetch[groupIndex] = [];\n          }\n\n          groupWeightsToFetch[groupIndex].push({\n            manifestEntry: weightsEntry,\n            groupOffset,\n            sizeBytes: weightsBytes\n          });\n        };\n\n        if (weightNames != null) {\n          weightNames.forEach((weightName, weightIndex) => {\n            if (weightName === weightsEntry.name) {\n              enqueueWeightsForFetchingFn();\n              weightsFound[weightIndex] = true;\n            }\n          });\n        } else {\n          enqueueWeightsForFetchingFn();\n        }\n\n        allManifestWeightNames.push(weightsEntry.name);\n        groupOffset += weightsBytes;\n      });\n    });\n\n    if (!weightsFound.every(found => found)) {\n      const weightsNotFound = weightNames.filter((_, i) => !weightsFound[i]);\n      throw new Error(\n          `Could not find weights in manifest with names: ` +\n          `${weightsNotFound.join(', ')}. \\n` +\n          `Manifest JSON has weights with names: ` +\n          `${allManifestWeightNames.join(', ')}.`);\n    }\n\n    // Convert the one-hot boolean groupId => shouldFetch map to a list of group\n    // IDs.\n    const groupIndicesToFetch =\n        groupIndicesToFetchMap.reduce((accumulator, shouldFetch, i) => {\n          if (shouldFetch) {\n            accumulator.push(i);\n          }\n          return accumulator;\n        }, []);\n\n    const fetchUrls: string[] = [];\n    groupIndicesToFetch.forEach(i => {\n      manifest[i].paths.forEach(filepath => {\n        const fetchUrl = filePathPrefix +\n            (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;\n        fetchUrls.push(fetchUrl);\n      });\n    });\n    const buffers = await fetchWeightsFunction(fetchUrls);\n\n    const weightsTensorMap: NamedTensorMap = {};\n    let bufferIndexOffset = 0;\n    groupIndicesToFetch.forEach(i => {\n      const numBuffers = manifest[i].paths.length;\n\n      let groupBytes = 0;\n      for (let i = 0; i < numBuffers; i++) {\n        groupBytes += buffers[bufferIndexOffset + i].byteLength;\n      }\n\n      // Create a buffer for the whole group.\n      const groupBuffer = new ArrayBuffer(groupBytes);\n      const groupByteBuffer = new Uint8Array(groupBuffer);\n      let groupBufferOffset = 0;\n      for (let i = 0; i < numBuffers; i++) {\n        const buffer = new Uint8Array(buffers[bufferIndexOffset + i]);\n        groupByteBuffer.set(buffer, groupBufferOffset);\n        groupBufferOffset += buffer.byteLength;\n      }\n\n      const weightsEntries = groupWeightsToFetch[i];\n      weightsEntries.forEach(weightsEntry => {\n        const byteBuffer = groupBuffer.slice(\n            weightsEntry.groupOffset,\n            weightsEntry.groupOffset + weightsEntry.sizeBytes);\n        const nameToTensorMap =\n            decodeWeights(byteBuffer, [weightsEntry.manifestEntry]);\n        for (const name in nameToTensorMap) {\n          weightsTensorMap[name] = nameToTensorMap[name];\n        }\n      });\n\n      bufferIndexOffset += numBuffers;\n    });\n\n    return weightsTensorMap;\n  };\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * IOHandler implementations based on HTTP requests in the web browser.\n *\n * Uses [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n */\n\nimport {env} from '../environment';\n\nimport {assert} from '../util';\nimport {concatenateArrayBuffers, getModelArtifactsForJSON, getModelArtifactsInfoForJSON, getModelJSONForModelArtifacts} from './io_utils';\nimport {IORouter, IORouterRegistry} from './router_registry';\nimport {IOHandler, LoadOptions, ModelArtifacts, ModelJSON, OnProgressCallback, SaveResult, WeightsManifestConfig, WeightsManifestEntry} from './types';\nimport {loadWeightsAsArrayBuffer} from './weights_loader';\n\nconst OCTET_STREAM_MIME_TYPE = 'application/octet-stream';\nconst JSON_TYPE = 'application/json';\nexport class HTTPRequest implements IOHandler {\n  protected readonly path: string;\n  protected readonly requestInit: RequestInit;\n\n  private readonly fetch: Function;\n  private readonly weightUrlConverter: (weightName: string) => Promise<string>;\n\n  readonly DEFAULT_METHOD = 'POST';\n\n  static readonly URL_SCHEME_REGEX = /^https?:\\/\\//;\n\n  private readonly weightPathPrefix: string;\n  private readonly onProgress: OnProgressCallback;\n\n  constructor(path: string, loadOptions?: LoadOptions) {\n    if (loadOptions == null) {\n      loadOptions = {};\n    }\n    this.weightPathPrefix = loadOptions.weightPathPrefix;\n    this.onProgress = loadOptions.onProgress;\n    this.weightUrlConverter = loadOptions.weightUrlConverter;\n\n    if (loadOptions.fetchFunc != null) {\n      assert(\n          typeof loadOptions.fetchFunc === 'function',\n          () => 'Must pass a function that matches the signature of ' +\n              '`fetch` (see ' +\n              'https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)');\n      this.fetch = loadOptions.fetchFunc;\n    } else {\n      this.fetch = env().platform.fetch;\n    }\n\n    assert(\n        path != null && path.length > 0,\n        () => 'URL path for http must not be null, undefined or ' +\n            'empty.');\n\n    if (Array.isArray(path)) {\n      assert(\n          path.length === 2,\n          () => 'URL paths for http must have a length of 2, ' +\n              `(actual length is ${path.length}).`);\n    }\n    this.path = path;\n\n    if (loadOptions.requestInit != null &&\n        loadOptions.requestInit.body != null) {\n      throw new Error(\n          'requestInit is expected to have no pre-existing body, but has one.');\n    }\n    this.requestInit = loadOptions.requestInit || {};\n  }\n\n  async save(modelArtifacts: ModelArtifacts): Promise<SaveResult> {\n    if (modelArtifacts.modelTopology instanceof ArrayBuffer) {\n      throw new Error(\n          'BrowserHTTPRequest.save() does not support saving model topology ' +\n          'in binary formats yet.');\n    }\n\n    const init = Object.assign({method: this.DEFAULT_METHOD}, this.requestInit);\n    init.body = new FormData();\n\n    const weightsManifest: WeightsManifestConfig = [{\n      paths: ['./model.weights.bin'],\n      weights: modelArtifacts.weightSpecs,\n    }];\n    const modelTopologyAndWeightManifest: ModelJSON =\n        getModelJSONForModelArtifacts(modelArtifacts, weightsManifest);\n\n    init.body.append(\n        'model.json',\n        new Blob(\n            [JSON.stringify(modelTopologyAndWeightManifest)],\n            {type: JSON_TYPE}),\n        'model.json');\n\n    if (modelArtifacts.weightData != null) {\n      init.body.append(\n          'model.weights.bin',\n          new Blob([modelArtifacts.weightData], {type: OCTET_STREAM_MIME_TYPE}),\n          'model.weights.bin');\n    }\n\n    const response = await this.fetch(this.path, init);\n\n    if (response.ok) {\n      return {\n        modelArtifactsInfo: getModelArtifactsInfoForJSON(modelArtifacts),\n        responses: [response],\n      };\n    } else {\n      throw new Error(\n          `BrowserHTTPRequest.save() failed due to HTTP response status ` +\n          `${response.status}.`);\n    }\n  }\n\n  /**\n   * Load model artifacts via HTTP request(s).\n   *\n   * See the documentation to `tf.io.http` for details on the saved\n   * artifacts.\n   *\n   * @returns The loaded model artifacts (if loading succeeds).\n   */\n  async load(): Promise<ModelArtifacts> {\n    const modelConfigRequest = await this.fetch(this.path, this.requestInit);\n\n    if (!modelConfigRequest.ok) {\n      throw new Error(\n          `Request to ${this.path} failed with status code ` +\n          `${modelConfigRequest.status}. Please verify this URL points to ` +\n          `the model JSON of the model to load.`);\n    }\n    let modelJSON: ModelJSON;\n    try {\n      modelJSON = await modelConfigRequest.json();\n    } catch (e) {\n      let message = `Failed to parse model JSON of response from ${this.path}.`;\n      // TODO(nsthorat): Remove this after some time when we're comfortable that\n      // .pb files are mostly gone.\n      if (this.path.endsWith('.pb')) {\n        message += ' Your path contains a .pb file extension. ' +\n            'Support for .pb models have been removed in TensorFlow.js 1.0 ' +\n            'in favor of .json models. You can re-convert your Python ' +\n            'TensorFlow model using the TensorFlow.js 1.0 conversion scripts ' +\n            'or you can convert your.pb models with the \\'pb2json\\'' +\n            'NPM script in the tensorflow/tfjs-converter repository.';\n      } else {\n        message += ' Please make sure the server is serving valid ' +\n            'JSON for this request.';\n      }\n      throw new Error(message);\n    }\n\n    // We do not allow both modelTopology and weightsManifest to be missing.\n    const modelTopology = modelJSON.modelTopology;\n    const weightsManifest = modelJSON.weightsManifest;\n    if (modelTopology == null && weightsManifest == null) {\n      throw new Error(\n          `The JSON from HTTP path ${this.path} contains neither model ` +\n          `topology or manifest for weights.`);\n    }\n\n    return getModelArtifactsForJSON(\n        modelJSON, (weightsManifest) => this.loadWeights(weightsManifest));\n  }\n\n  private async loadWeights(weightsManifest: WeightsManifestConfig):\n      Promise<[WeightsManifestEntry[], ArrayBuffer]> {\n    const weightPath = Array.isArray(this.path) ? this.path[1] : this.path;\n    const [prefix, suffix] = parseUrl(weightPath);\n    const pathPrefix = this.weightPathPrefix || prefix;\n\n    const weightSpecs = [];\n    for (const entry of weightsManifest) {\n      weightSpecs.push(...entry.weights);\n    }\n\n    const fetchURLs: string[] = [];\n    const urlPromises: Array<Promise<string>> = [];\n    for (const weightsGroup of weightsManifest) {\n      for (const path of weightsGroup.paths) {\n        if (this.weightUrlConverter != null) {\n          urlPromises.push(this.weightUrlConverter(path));\n        } else {\n          fetchURLs.push(pathPrefix + path + suffix);\n        }\n      }\n    }\n\n    if (this.weightUrlConverter) {\n      fetchURLs.push(...await Promise.all(urlPromises));\n    }\n\n    const buffers = await loadWeightsAsArrayBuffer(fetchURLs, {\n      requestInit: this.requestInit,\n      fetchFunc: this.fetch,\n      onProgress: this.onProgress\n    });\n    return [weightSpecs, concatenateArrayBuffers(buffers)];\n  }\n}\n\n/**\n * Extract the prefix and suffix of the url, where the prefix is the path before\n * the last file, and suffix is the search params after the last file.\n * ```\n * const url = 'http://tfhub.dev/model/1/tensorflowjs_model.pb?tfjs-format=file'\n * [prefix, suffix] = parseUrl(url)\n * // prefix = 'http://tfhub.dev/model/1/'\n * // suffix = '?tfjs-format=file'\n * ```\n * @param url the model url to be parsed.\n */\nexport function parseUrl(url: string): [string, string] {\n  const lastSlash = url.lastIndexOf('/');\n  const lastSearchParam = url.lastIndexOf('?');\n  const prefix = url.substring(0, lastSlash);\n  const suffix =\n      lastSearchParam > lastSlash ? url.substring(lastSearchParam) : '';\n  return [prefix + '/', suffix];\n}\n\nexport function isHTTPScheme(url: string): boolean {\n  return url.match(HTTPRequest.URL_SCHEME_REGEX) != null;\n}\n\nexport const httpRouter: IORouter =\n    (url: string, loadOptions?: LoadOptions) => {\n      if (typeof fetch === 'undefined' &&\n          (loadOptions == null || loadOptions.fetchFunc == null)) {\n        // `http` uses `fetch` or `node-fetch`, if one wants to use it in\n        // an environment that is not the browser or node they have to setup a\n        // global fetch polyfill.\n        return null;\n      } else {\n        let isHTTP = true;\n        if (Array.isArray(url)) {\n          isHTTP = url.every(urlItem => isHTTPScheme(urlItem));\n        } else {\n          isHTTP = isHTTPScheme(url);\n        }\n        if (isHTTP) {\n          return http(url, loadOptions);\n        }\n      }\n      return null;\n    };\nIORouterRegistry.registerSaveRouter(httpRouter);\nIORouterRegistry.registerLoadRouter(httpRouter);\n\n/**\n * Creates an IOHandler subtype that sends model artifacts to HTTP server.\n *\n * An HTTP request of the `multipart/form-data` mime type will be sent to the\n * `path` URL. The form data includes artifacts that represent the topology\n * and/or weights of the model. In the case of Keras-style `tf.Model`, two\n * blobs (files) exist in form-data:\n *   - A JSON file consisting of `modelTopology` and `weightsManifest`.\n *   - A binary weights file consisting of the concatenated weight values.\n * These files are in the same format as the one generated by\n * [tfjs_converter](https://js.tensorflow.org/tutorials/import-keras.html).\n *\n * The following code snippet exemplifies the client-side code that uses this\n * function:\n *\n * ```js\n * const model = tf.sequential();\n * model.add(\n *     tf.layers.dense({units: 1, inputShape: [100], activation: 'sigmoid'}));\n *\n * const saveResult = await model.save(tf.io.http(\n *     'http://model-server:5000/upload', {requestInit: {method: 'PUT'}}));\n * console.log(saveResult);\n * ```\n *\n * If the default `POST` method is to be used, without any custom parameters\n * such as headers, you can simply pass an HTTP or HTTPS URL to `model.save`:\n *\n * ```js\n * const saveResult = await model.save('http://model-server:5000/upload');\n * ```\n *\n * The following GitHub Gist\n * https://gist.github.com/dsmilkov/1b6046fd6132d7408d5257b0976f7864\n * implements a server based on [flask](https://github.com/pallets/flask) that\n * can receive the request. Upon receiving the model artifacts via the requst,\n * this particular server reconsistutes instances of [Keras\n * Models](https://keras.io/models/model/) in memory.\n *\n *\n * @param path A URL path to the model.\n *   Can be an absolute HTTP path (e.g.,\n *   'http://localhost:8000/model-upload)') or a relative path (e.g.,\n *   './model-upload').\n * @param requestInit Request configurations to be used when sending\n *    HTTP request to server using `fetch`. It can contain fields such as\n *    `method`, `credentials`, `headers`, `mode`, etc. See\n *    https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n *    for more information. `requestInit` must not have a body, because the\n * body will be set by TensorFlow.js. File blobs representing the model\n * topology (filename: 'model.json') and the weights of the model (filename:\n * 'model.weights.bin') will be appended to the body. If `requestInit` has a\n * `body`, an Error will be thrown.\n * @param loadOptions Optional configuration for the loading. It includes the\n *   following fields:\n *   - weightPathPrefix Optional, this specifies the path prefix for weight\n *     files, by default this is calculated from the path param.\n *   - fetchFunc Optional, custom `fetch` function. E.g., in Node.js,\n *     the `fetch` from node-fetch can be used here.\n *   - onProgress Optional, progress callback function, fired periodically\n *     before the load is completed.\n * @returns An instance of `IOHandler`.\n *\n * @doc {\n *   heading: 'Models',\n *   subheading: 'Loading',\n *   namespace: 'io',\n *   ignoreCI: true\n * }\n */\nexport function http(path: string, loadOptions?: LoadOptions): IOHandler {\n  return new HTTPRequest(path, loadOptions);\n}\n\n/**\n * Deprecated. Use `tf.io.http`.\n * @param path\n * @param loadOptions\n */\nexport function browserHTTPRequest(\n    path: string, loadOptions?: LoadOptions): IOHandler {\n  return http(path, loadOptions);\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * IOHandlers that pass through the in-memory ModelArtifacts format.\n */\n\nimport {IOHandler, ModelArtifacts, SaveResult, TrainingConfig, WeightsManifestEntry} from './types';\n\nclass PassthroughLoader implements IOHandler {\n  constructor(private readonly modelArtifacts?: ModelArtifacts) {}\n\n  async load(): Promise<ModelArtifacts> {\n    return this.modelArtifacts;\n  }\n}\n\nclass PassthroughSaver implements IOHandler {\n  constructor(\n      private readonly saveHandler:\n          (artifacts: ModelArtifacts) => Promise<SaveResult>) {}\n\n  async save(modelArtifacts: ModelArtifacts) {\n    return this.saveHandler(modelArtifacts);\n  }\n}\n\n/**\n * Creates an IOHandler that loads model artifacts from memory.\n *\n * When used in conjunction with `tf.loadLayersModel`, an instance of\n * `tf.LayersModel` (Keras-style) can be constructed from the loaded artifacts.\n *\n * ```js\n * const model = await tf.loadLayersModel(tf.io.fromMemory(\n *     modelTopology, weightSpecs, weightData));\n * ```\n *\n * @param modelArtifacts a object containing model topology (i.e., parsed from\n *   the JSON format).\n * @param weightSpecs An array of `WeightsManifestEntry` objects describing the\n *   names, shapes, types, and quantization of the weight data.\n * @param weightData A single `ArrayBuffer` containing the weight data,\n *   concatenated in the order described by the weightSpecs.\n * @param trainingConfig Model training configuration. Optional.\n *\n * @returns A passthrough `IOHandler` that simply loads the provided data.\n */\nexport function fromMemory(\n    modelArtifacts: {}|ModelArtifacts, weightSpecs?: WeightsManifestEntry[],\n    weightData?: ArrayBuffer, trainingConfig?: TrainingConfig): IOHandler {\n  if (arguments.length === 1) {\n    const isModelArtifacts =\n        (modelArtifacts as ModelArtifacts).modelTopology != null ||\n        (modelArtifacts as ModelArtifacts).weightSpecs != null;\n    if (isModelArtifacts) {\n      return new PassthroughLoader(modelArtifacts as ModelArtifacts);\n    } else {\n      // Legacy support: with only modelTopology.\n      // TODO(cais): Remove this deprecated API.\n      console.warn(\n          'Please call tf.io.fromMemory() with only one argument. ' +\n          'The argument should be of type ModelArtifacts. ' +\n          'The multi-argument signature of tf.io.fromMemory() has been ' +\n          'deprecated and will be removed in a future release.');\n      return new PassthroughLoader({modelTopology: modelArtifacts as {}});\n    }\n  } else {\n    // Legacy support.\n    // TODO(cais): Remove this deprecated API.\n    console.warn(\n        'Please call tf.io.fromMemory() with only one argument. ' +\n        'The argument should be of type ModelArtifacts. ' +\n        'The multi-argument signature of tf.io.fromMemory() has been ' +\n        'deprecated and will be removed in a future release.');\n    return new PassthroughLoader({\n      modelTopology: modelArtifacts as {},\n      weightSpecs,\n      weightData,\n      trainingConfig\n    });\n  }\n}\n\n/**\n * Creates an IOHandler that passes saved model artifacts to a callback.\n *\n * ```js\n * function handleSave(artifacts) {\n *   // ... do something with the artifacts ...\n *   return {modelArtifactsInfo: {...}, ...};\n * }\n *\n * const saveResult = model.save(tf.io.withSaveHandler(handleSave));\n * ```\n *\n * @param saveHandler A function that accepts a `ModelArtifacts` and returns a\n *     `SaveResult`.\n */\nexport function withSaveHandler(\n    saveHandler: (artifacts: ModelArtifacts) =>\n        Promise<SaveResult>): IOHandler {\n  return new PassthroughSaver(saveHandler);\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Importing local_storage and indexed_db is necessary for the routers to be\n// registered.\nimport './indexed_db';\nimport './local_storage';\n\nimport {browserFiles} from './browser_files';\nimport {browserHTTPRequest, http, isHTTPScheme} from './http';\nimport {concatenateArrayBuffers, decodeWeights, encodeWeights, getModelArtifactsForJSON, getModelArtifactsInfoForJSON} from './io_utils';\nimport {fromMemory, withSaveHandler} from './passthrough';\nimport {getLoadHandlers, getSaveHandlers, registerLoadRouter, registerSaveRouter} from './router_registry';\nimport {IOHandler, LoadHandler, LoadOptions, ModelArtifacts, ModelArtifactsInfo, ModelJSON, ModelStoreManager, OnProgressCallback, RequestDetails, SaveConfig, SaveHandler, SaveResult, TrainingConfig, WeightGroup, WeightsManifestConfig, WeightsManifestEntry} from './types';\nimport {loadWeights, weightsLoaderFactory} from './weights_loader';\n\nexport {copyModel, listModels, moveModel, removeModel} from './model_management';\nexport {\n  browserFiles,\n  browserHTTPRequest,\n  concatenateArrayBuffers,\n  decodeWeights,\n  encodeWeights,\n  fromMemory,\n  getLoadHandlers,\n  getModelArtifactsForJSON,\n  getModelArtifactsInfoForJSON,\n  getSaveHandlers,\n  http,\n  IOHandler,\n  isHTTPScheme,\n  LoadHandler,\n  LoadOptions,\n  loadWeights,\n  ModelArtifacts,\n  ModelArtifactsInfo,\n  ModelJSON,\n  ModelStoreManager,\n  OnProgressCallback,\n  registerLoadRouter,\n  registerSaveRouter,\n  RequestDetails,\n  SaveConfig,\n  SaveHandler,\n  SaveResult,\n  TrainingConfig,\n  WeightGroup,\n  weightsLoaderFactory,\n  WeightsManifestConfig,\n  WeightsManifestEntry,\n  withSaveHandler\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {BatchMatMul, BatchMatMulAttrs, BatchMatMulInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the dot product of two matrices, A * B. These must be matrices.\n *\n * ```js\n * const a = tf.tensor2d([1, 2], [1, 2]);\n * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * a.matMul(b).print();  // or tf.matMul(a, b)\n * ```\n * @param a First matrix in dot product operation.\n * @param b Second matrix in dot product operation.\n * @param transposeA If true, `a` is transposed before multiplication.\n * @param transposeB If true, `b` is transposed before multiplication.\n *\n * @doc {heading: 'Operations', subheading: 'Matrices'}\n */\nfunction matMul_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike, transposeA = false,\n    transposeB = false): T {\n  let $a = convertToTensor(a, 'a', 'matMul');\n  let $b = convertToTensor(b, 'b', 'matMul');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const inputs: BatchMatMulInputs = {a: $a, b: $b};\n  const attrs: BatchMatMulAttrs = {transposeA, transposeB};\n\n  return ENGINE.runKernel(\n      BatchMatMul, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const matMul = op({matMul_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {OneHot, OneHotAttrs, OneHotInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Creates a one-hot `tf.Tensor`. The locations represented by `indices` take\n * value `onValue` (defaults to 1), while all other locations take value\n * `offValue` (defaults to 0). If `indices` is rank `R`, the output has rank\n * `R+1` with the last axis of size `depth`.\n *\n * ```js\n * tf.oneHot(tf.tensor1d([0, 1], 'int32'), 3).print();\n * ```\n *\n * @param indices `tf.Tensor` of indices with dtype `int32`.\n * @param depth The depth of the one hot dimension.\n * @param onValue A number used to fill in the output when the index matches\n * the location.\n * @param offValue A number used to fill in the output when the index does\n *     not match the location.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction oneHot_(\n    indices: Tensor|TensorLike, depth: number, onValue = 1,\n    offValue = 0): Tensor {\n  if (depth < 2) {\n    throw new Error(`Error in oneHot: depth must be >=2, but it is ${depth}`);\n  }\n  const $indices = convertToTensor(indices, 'indices', 'oneHot', 'int32');\n\n  const inputs: OneHotInputs = {indices: $indices};\n  const attrs: OneHotAttrs = {depth, onValue, offValue};\n\n  return ENGINE.runKernel(\n      OneHot, inputs as unknown as NamedTensorMap,\n      attrs as unknown as NamedAttrMap);\n}\n\nexport const oneHot = op({oneHot_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Transpose, TransposeAttrs, TransposeInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Transposes the `tf.Tensor`. Permutes the dimensions according to `perm`.\n *\n * The returned `tf.Tensor`'s dimension `i` will correspond to the input\n * dimension `perm[i]`. If `perm` is not given, it is set to `[n-1...0]`,\n * where `n` is the rank of the input `tf.Tensor`. Hence by default, this\n * operation performs a regular matrix transpose on 2-D input `tf.Tensor`s.\n *\n * ```js\n * const a = tf.tensor2d([1, 2, 3, 4, 5, 6], [2, 3]);\n *\n * a.transpose().print();  // or tf.transpose(a)\n * ```\n *\n * @param x The tensor to transpose.\n * @param perm The permutation of the dimensions of a.\n *\n * @doc {heading: 'Operations', subheading: 'Matrices'}\n */\nfunction transpose_<T extends Tensor>(x: T|TensorLike, perm?: number[]): T {\n  const $x = convertToTensor(x, 'x', 'transpose');\n\n  if (perm == null) {\n    perm = $x.shape.map((s, i) => i).reverse();\n  }\n  util.assert(\n      $x.rank === perm.length,\n      () => `Error in transpose: rank of input ${$x.rank} ` +\n          `must match length of perm ${perm}.`);\n  perm.forEach(axis => {\n    util.assert(\n        axis >= 0 && axis < $x.rank,\n        () => `All entries in 'perm' must be between 0 and ${$x.rank - 1}` +\n            ` but got ${perm}`);\n  });\n\n  if ($x.rank <= 1) {\n    return $x.clone();\n  }\n\n  const inputs: TransposeInputs = {x: $x};\n  const attrs: TransposeAttrs = {perm};\n\n  return ENGINE.runKernel(\n      Transpose, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const transpose = op({transpose_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D, Tensor2D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {cast} from './cast';\nimport {matMul} from './mat_mul';\nimport {oneHot} from './one_hot';\nimport {op} from './operation';\nimport {transpose} from './transpose';\n\n/**\n * Computes the confusion matrix from true labels and predicted labels.\n *\n * ```js\n * const labels = tf.tensor1d([0, 1, 2, 1, 0], 'int32');\n * const predictions = tf.tensor1d([0, 2, 2, 1, 0], 'int32');\n * const numClasses = 3;\n * const out = tf.math.confusionMatrix(labels, predictions, numClasses);\n * out.print();\n * // Expected output matrix:\n * // [[2, 0, 0],\n * //  [0, 1, 1],\n * //  [0, 0, 1]]\n * ```\n *\n * @param labels The target labels, assumed to be 0-based integers\n *   for the classes. The shape is `[numExamples]`, where\n *   `numExamples` is the number of examples included.\n * @param predictions The predicted classes, assumed to be\n *   0-based integers for the classes. Must have the same shape as `labels`.\n * @param numClasses Number of all classes, as an integer.\n *   Its value must be larger than the largest element in `labels` and\n *   `predictions`.\n * @returns The confusion matrix as a int32-type 2D tensor. The value at\n *   row `r` and column `c` is the number of times examples of actual class\n *   `r` were predicted as class `c`.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nexport function confusionMatrix_(\n    labels: Tensor1D|TensorLike, predictions: Tensor1D|TensorLike,\n    numClasses: number): Tensor2D {\n  const $labels = convertToTensor(labels, 'labels', 'confusionMatrix');\n  const $predictions =\n      convertToTensor(predictions, 'predictions', 'confusionMatrix');\n\n  util.assert(\n      numClasses == null || numClasses > 0 && Number.isInteger(numClasses),\n      () => `If provided, numClasses must be a positive integer, ` +\n          `but got ${numClasses}`);\n  util.assert(\n      $labels.rank === 1,\n      () => `Expected the rank of labels to be 1, but got ${$labels.rank}`);\n  util.assert(\n      $predictions.rank === 1,\n      () => `Expected the rank of predictions to be 1, ` +\n          `but got ${$predictions.rank}`);\n  util.assert(\n      $labels.shape[0] === $predictions.shape[0],\n      () => `Mismatch in the number of examples: ` +\n          `${$labels.shape[0]} vs. ${$predictions.shape[0]}. ` +\n          `Labels and predictions should have the same number of elements.`);\n  util.assert(\n      numClasses > 0 && Number.isInteger(numClasses),\n      () => `numClasses is required to be a positive integer, but got ` +\n          `${numClasses}`);\n  // TODO(cais): In the future, if oneHot supports tensors inputs for\n  //   `numClasses`, `confusionMatrix` can make `numClasses` optional.\n\n  const oneHotLabels = oneHot(cast($labels, 'int32'), numClasses) as Tensor2D;\n  const oneHotPredictions =\n      oneHot(cast($predictions, 'int32'), numClasses) as Tensor2D;\n  const oneHotLabelsT: Tensor2D = transpose(oneHotLabels);\n  const product: Tensor2D = matMul(oneHotLabelsT, oneHotPredictions);\n  return cast(product, 'int32');\n}\n\nexport const confusionMatrix = op({confusionMatrix_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Exports under the tf.math.* namespace.\n */\n\nimport {confusionMatrix} from './ops/confusion_matrix';\n\nexport {confusionMatrix};\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor3D} from '../tensor';\nimport {inferShape} from '../tensor_util_env';\nimport {TensorLike3D} from '../types';\nimport {DataType} from '../types';\nimport {assertNonNull} from '../util';\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates rank-3 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor3d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor3d([[[1], [2]], [[3], [4]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor3d([1, 2, 3, 4], [2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided,  it is inferred from\n *     `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor3d(\n    values: TensorLike3D, shape?: [number, number, number],\n    dtype?: DataType): Tensor3D {\n  assertNonNull(values);\n  if (shape != null && shape.length !== 3) {\n    throw new Error('tensor3d() requires shape to have three numbers');\n  }\n  const inferredShape = inferShape(values, dtype);\n  if (inferredShape.length !== 3 && inferredShape.length !== 1) {\n    throw new Error(\n        'tensor3d() requires values to be number[][][] or flat/TypedArray');\n  }\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error(\n        'tensor3d() requires shape to be provided when `values` ' +\n        'are a flat array');\n  }\n  return makeTensor(values, shape, inferredShape, dtype) as Tensor3D;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {env} from '../environment';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs} from '../kernel_names';\nimport {getKernel, NamedAttrMap} from '../kernel_registry';\nimport {Tensor, Tensor2D, Tensor3D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {PixelData, TensorLike} from '../types';\n\nimport {cast} from './cast';\nimport {op} from './operation';\nimport {tensor3d} from './tensor3d';\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\n\n/**\n * Creates a `tf.Tensor` from an image.\n *\n * ```js\n * const image = new ImageData(1, 1);\n * image.data[0] = 100;\n * image.data[1] = 150;\n * image.data[2] = 200;\n * image.data[3] = 255;\n *\n * tf.browser.fromPixels(image).print();\n * ```\n *\n * @param pixels The input image to construct the tensor from. The\n * supported image types are all 4-channel. You can also pass in an image\n * object with following attributes:\n * `{data: Uint8Array; width: number; height: number}`\n * @param numChannels The number of channels of the output tensor. A\n * numChannels value less than 4 allows you to ignore channels. Defaults to\n * 3 (ignores alpha channel of input image).\n *\n * @returns A Tensor3D with the shape `[height, width, numChannels]`.\n *\n * @doc {heading: 'Browser', namespace: 'browser', ignoreCI: true}\n */\nfunction fromPixels_(\n    pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n    HTMLVideoElement|ImageBitmap,\n    numChannels = 3): Tensor3D {\n  // Sanity checks.\n  if (numChannels > 4) {\n    throw new Error(\n        'Cannot construct Tensor with more than 4 channels from pixels.');\n  }\n  if (pixels == null) {\n    throw new Error('pixels passed to tf.browser.fromPixels() can not be null');\n  }\n  let isPixelData = false;\n  let isImageData = false;\n  let isVideo = false;\n  let isImage = false;\n  let isCanvasLike = false;\n  let isImageBitmap = false;\n  if ((pixels as PixelData).data instanceof Uint8Array) {\n    isPixelData = true;\n  } else if (\n      typeof (ImageData) !== 'undefined' && pixels instanceof ImageData) {\n    isImageData = true;\n  } else if (\n      typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement) {\n    isVideo = true;\n  } else if (\n      typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement) {\n    isImage = true;\n    // tslint:disable-next-line: no-any\n  } else if ((pixels as any).getContext != null) {\n    isCanvasLike = true;\n  } else if (\n      typeof (ImageBitmap) !== 'undefined' && pixels instanceof ImageBitmap) {\n    isImageBitmap = true;\n  } else {\n    throw new Error(\n        'pixels passed to tf.browser.fromPixels() must be either an ' +\n        `HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData ` +\n        `in browser, or OffscreenCanvas, ImageData in webworker` +\n        ` or {data: Uint32Array, width: number, height: number}, ` +\n        `but was ${(pixels as {}).constructor.name}`);\n  }\n  if (isVideo) {\n    const HAVE_CURRENT_DATA_READY_STATE = 2;\n    if (isVideo &&\n        (pixels as HTMLVideoElement).readyState <\n            HAVE_CURRENT_DATA_READY_STATE) {\n      throw new Error(\n          'The video element has not loaded data yet. Please wait for ' +\n          '`loadeddata` event on the <video> element.');\n    }\n  }\n  // If the current backend has 'FromPixels' registered, it has a more\n  // efficient way of handling pixel uploads, so we call that.\n  const kernel = getKernel(FromPixels, ENGINE.backendName);\n  if (kernel != null) {\n    const inputs: FromPixelsInputs = {pixels};\n    const attrs: FromPixelsAttrs = {numChannels};\n    return ENGINE.runKernel(\n        FromPixels, inputs as {} as NamedTensorMap,\n        attrs as {} as NamedAttrMap);\n  }\n\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n  let vals: Uint8ClampedArray|Uint8Array;\n\n  if (isCanvasLike) {\n    vals =\n        // tslint:disable-next-line:no-any\n        (pixels as any).getContext('2d').getImageData(0, 0, width, height).data;\n  } else if (isImageData || isPixelData) {\n    vals = (pixels as PixelData | ImageData).data;\n  } else if (isImage || isVideo || isImageBitmap) {\n    if (fromPixels2DContext == null) {\n      fromPixels2DContext = document.createElement('canvas').getContext('2d');\n    }\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(\n        pixels as HTMLVideoElement, 0, 0, width, height);\n    vals = fromPixels2DContext.getImageData(0, 0, width, height).data;\n  }\n  let values: Int32Array;\n  if (numChannels === 4) {\n    values = new Int32Array(vals);\n  } else {\n    const numPixels = width * height;\n    values = new Int32Array(numPixels * numChannels);\n    for (let i = 0; i < numPixels; i++) {\n      for (let channel = 0; channel < numChannels; ++channel) {\n        values[i * numChannels + channel] = vals[i * 4 + channel];\n      }\n    }\n  }\n  const outShape: [number, number, number] = [height, width, numChannels];\n  return tensor3d(values, outShape, 'int32');\n}\n\n// Helper functions for |fromPixelsAsync| to check whether the input can\n// be wrapped into imageBitmap.\nfunction isPixelData(pixels: PixelData|ImageData|HTMLImageElement|\n                     HTMLCanvasElement|HTMLVideoElement|\n                     ImageBitmap): pixels is PixelData {\n  return (pixels != null) && ((pixels as PixelData).data instanceof Uint8Array);\n}\n\nfunction isImageBitmapFullySupported() {\n  return typeof window !== 'undefined' &&\n      typeof (ImageBitmap) !== 'undefined' &&\n      window.hasOwnProperty('createImageBitmap');\n}\n\nfunction isNonEmptyPixels(pixels: PixelData|ImageData|HTMLImageElement|\n                          HTMLCanvasElement|HTMLVideoElement|ImageBitmap) {\n  return pixels != null && pixels.width !== 0 && pixels.height !== 0;\n}\n\nfunction canWrapPixelsToImageBitmap(pixels: PixelData|ImageData|\n                                    HTMLImageElement|HTMLCanvasElement|\n                                    HTMLVideoElement|ImageBitmap) {\n  return isImageBitmapFullySupported() && !(pixels instanceof ImageBitmap) &&\n      isNonEmptyPixels(pixels) && !isPixelData(pixels);\n}\n\n/**\n * Creates a `tf.Tensor` from an image in async way.\n *\n * ```js\n * const image = new ImageData(1, 1);\n * image.data[0] = 100;\n * image.data[1] = 150;\n * image.data[2] = 200;\n * image.data[3] = 255;\n *\n * (await tf.browser.fromPixelsAsync(image)).print();\n * ```\n * This API is the async version of fromPixels. The API will first\n * check |WRAP_TO_IMAGEBITMAP| flag, and try to wrap the input to\n * imageBitmap if the flag is set to true.\n *\n * @param pixels The input image to construct the tensor from. The\n * supported image types are all 4-channel. You can also pass in an image\n * object with following attributes:\n * `{data: Uint8Array; width: number; height: number}`\n * @param numChannels The number of channels of the output tensor. A\n * numChannels value less than 4 allows you to ignore channels. Defaults to\n * 3 (ignores alpha channel of input image).\n *\n * @doc {heading: 'Browser', namespace: 'browser', ignoreCI: true}\n */\nexport async function fromPixelsAsync(\n    pixels: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n    HTMLVideoElement|ImageBitmap,\n    numChannels = 3) {\n  let inputs: PixelData|ImageData|HTMLImageElement|HTMLCanvasElement|\n      HTMLVideoElement|ImageBitmap = null;\n\n  // Check whether the backend needs to wrap |pixels| to imageBitmap and\n  // whether |pixels| can be wrapped to imageBitmap.\n  if (env().getBool('WRAP_TO_IMAGEBITMAP') &&\n      canWrapPixelsToImageBitmap(pixels)) {\n    // Force the imageBitmap creation to not do any premultiply alpha\n    // ops.\n    let imageBitmap;\n\n    try {\n      // wrap in try-catch block, because createImageBitmap may not work\n      // properly in some browsers, e.g.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1335594\n      // tslint:disable-next-line: no-any\n      imageBitmap = await (createImageBitmap as any)(\n          pixels as ImageBitmapSource, {premultiplyAlpha: 'none'});\n    } catch (e) {\n      imageBitmap = null;\n    }\n\n    // createImageBitmap will clip the source size.\n    // In some cases, the input will have larger size than its content.\n    // E.g. new Image(10, 10) but with 1 x 1 content. Using\n    // createImageBitmap will clip the size from 10 x 10 to 1 x 1, which\n    // is not correct. We should avoid wrapping such resouce to\n    // imageBitmap.\n    if (imageBitmap != null && imageBitmap.width === pixels.width &&\n        imageBitmap.height === pixels.height) {\n      inputs = imageBitmap;\n    } else {\n      inputs = pixels;\n    }\n  } else {\n    inputs = pixels;\n  }\n\n  return fromPixels_(inputs, numChannels);\n}\n\n/**\n * Draws a `tf.Tensor` of pixel values to a byte array or optionally a\n * canvas.\n *\n * When the dtype of the input is 'float32', we assume values in the range\n * [0-1]. Otherwise, when input is 'int32', we assume values in the range\n * [0-255].\n *\n * Returns a promise that resolves when the canvas has been drawn to.\n *\n * @param img A rank-2 tensor with shape `[height, width]`, or a rank-3 tensor\n * of shape `[height, width, numChannels]`. If rank-2, draws grayscale. If\n * rank-3, must have depth of 1, 3 or 4. When depth of 1, draws\n * grayscale. When depth of 3, we draw with the first three components of\n * the depth dimension corresponding to r, g, b and alpha = 1. When depth of\n * 4, all four components of the depth dimension correspond to r, g, b, a.\n * @param canvas The canvas to draw to.\n *\n * @doc {heading: 'Browser', namespace: 'browser'}\n */\nexport async function toPixels(\n    img: Tensor2D|Tensor3D|TensorLike,\n    canvas?: HTMLCanvasElement): Promise<Uint8ClampedArray> {\n  let $img = convertToTensor(img, 'img', 'toPixels');\n  if (!(img instanceof Tensor)) {\n    // Assume int32 if user passed a native array.\n    const originalImgTensor = $img;\n    $img = cast(originalImgTensor, 'int32');\n    originalImgTensor.dispose();\n  }\n  if ($img.rank !== 2 && $img.rank !== 3) {\n    throw new Error(\n        `toPixels only supports rank 2 or 3 tensors, got rank ${$img.rank}.`);\n  }\n  const [height, width] = $img.shape.slice(0, 2);\n  const depth = $img.rank === 2 ? 1 : $img.shape[2];\n\n  if (depth > 4 || depth === 2) {\n    throw new Error(\n        `toPixels only supports depth of size ` +\n        `1, 3 or 4 but got ${depth}`);\n  }\n\n  if ($img.dtype !== 'float32' && $img.dtype !== 'int32') {\n    throw new Error(\n        `Unsupported type for toPixels: ${$img.dtype}.` +\n        ` Please use float32 or int32 tensors.`);\n  }\n\n  const data = await $img.data();\n  const multiplier = $img.dtype === 'float32' ? 255 : 1;\n  const bytes = new Uint8ClampedArray(width * height * 4);\n\n  for (let i = 0; i < height * width; ++i) {\n    const rgba = [0, 0, 0, 255];\n\n    for (let d = 0; d < depth; d++) {\n      const value = data[i * depth + d];\n\n      if ($img.dtype === 'float32') {\n        if (value < 0 || value > 1) {\n          throw new Error(\n              `Tensor values for a float32 Tensor must be in the ` +\n              `range [0 - 1] but encountered ${value}.`);\n        }\n      } else if ($img.dtype === 'int32') {\n        if (value < 0 || value > 255) {\n          throw new Error(\n              `Tensor values for a int32 Tensor must be in the ` +\n              `range [0 - 255] but encountered ${value}.`);\n        }\n      }\n\n      if (depth === 1) {\n        rgba[0] = value * multiplier;\n        rgba[1] = value * multiplier;\n        rgba[2] = value * multiplier;\n      } else {\n        rgba[d] = value * multiplier;\n      }\n    }\n\n    const j = i * 4;\n    bytes[j + 0] = Math.round(rgba[0]);\n    bytes[j + 1] = Math.round(rgba[1]);\n    bytes[j + 2] = Math.round(rgba[2]);\n    bytes[j + 3] = Math.round(rgba[3]);\n  }\n\n  if (canvas != null) {\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const imageData = new ImageData(bytes, width, height);\n    ctx.putImageData(imageData, 0, 0);\n  }\n  if ($img !== img) {\n    $img.dispose();\n  }\n  return bytes;\n}\n\nexport const fromPixels = op({fromPixels_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TensorInfo} from '../kernel_registry';\nimport {computeStrides, sizeFromShape} from '../util';\n\n/**\n * Validate gather nd inputs.\n *\n * @param tensor The tensor contains the source values.\n * @param indices The tensor contains the indices to slice the source.\n *\n * @returns [resultShape, numUpdates, sliceSize, strides]\n */\nexport function prepareAndValidate(tensor: TensorInfo, indices: TensorInfo):\n    [number[], number, number, number[]] {\n  const tensorRank = tensor.shape.length;\n  const indicesRank = indices.shape.length;\n  if (tensorRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the input to be rank 1 or higher,' +\n        ` but the rank was ${tensorRank}.`);\n  }\n  if (indicesRank < 1) {\n    throw new Error(\n        'tf.gatherND() expects the indices to be rank 1 or higher,' +\n        ` but the rank was ${indicesRank}.`);\n  }\n  if (indices.dtype !== 'int32') {\n    throw new Error(\n        'tf.gatherND() expects the indices to be int32 type,' +\n        ` but the dtype was ${indices.dtype}.`);\n  }\n  if (indices.shape[indicesRank - 1] > tensorRank) {\n    throw new Error(\n        'index innermost dimension length must be <= tensor rank; saw: ' +\n        `${indices.shape[indicesRank - 1]} vs. ${tensorRank}`);\n  }\n\n  if (sizeFromShape(tensor.shape) === 0) {\n    throw new Error(\n        'Requested more than 0 entries, but input is empty.' +\n        ` Input shape: ${tensor.shape}.`);\n  }\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n\n  // The result shape is\n  //   indices.shape[:-1] + params.shape[indices.shape[-1]:]\n  let nResult = 1;\n  for (let i = 0; i < indicesShape.length - 1; ++i) {\n    nResult *= indicesShape[i];\n  }\n\n  const inputShape = tensor.shape;\n\n  const resultShape = indicesShape.slice();\n  resultShape.pop();\n\n  let sliceSize = 1;\n  for (let i = sliceRank; i < tensorRank; ++i) {\n    sliceSize *= inputShape[i];\n    resultShape.push(inputShape[i]);\n  }\n\n  const strides =\n      [...computeStrides(tensor.shape).map(stride => stride / sliceSize),\n       1].slice(0, sliceRank);\n\n  return [resultShape, nResult, sliceSize, strides];\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TensorInfo} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {computeStrides, sizeFromShape} from '../util';\n\n/**\n * Check whether updates.shape = indices.shape[:batchDim] +\n * shape[sliceDim:]\n *\n * @param x The input tensor.\n */\nexport function validateUpdateShape(\n    shape: number[], indices: Tensor, updates: Tensor) {\n  const sliceDim = (indices.rank > 1) ? indices.shape[indices.rank - 1] : 1;\n  const batchDim = (indices.rank > 1) ? indices.rank - 1 : 1;\n\n  const shapeError = 'Must have updates.shape = indices.shape[:batchDim] + ' +\n      `shape[sliceDim:], got updates.shape: ${updates.shape}` +\n      `, indices.shape: ${indices.shape}, shape: ${shape}` +\n      `, sliceDim: ${sliceDim}, and batchDim: ${batchDim}.`;\n\n  if (updates.rank < batchDim) {\n    throw new Error(shapeError + ` update.rank < ${batchDim}. `);\n  }\n  if (shape.length < sliceDim + (updates.rank - batchDim)) {\n    throw new Error(\n        shapeError +\n        ` Output shape length < ${sliceDim + (updates.rank - batchDim)}`);\n  }\n  if (updates.rank !== batchDim + shape.length - sliceDim) {\n    throw new Error(\n        shapeError + ` update.rank != ${batchDim + shape.length - sliceDim}`);\n  }\n  for (let d = 0; d < batchDim; ++d) {\n    if (updates.shape[d] !== indices.shape[d]) {\n      throw new Error(\n          shapeError +\n          ` updates.shape[${d}] (${updates.shape[d]}) != indices.shape[${d}] (${\n              indices.shape[d]}).`);\n    }\n  }\n  for (let d = 0; d < updates.rank - batchDim; ++d) {\n    if (updates.shape[d + batchDim] !== shape[d + sliceDim]) {\n      throw new Error(\n          shapeError +\n          ` updates.shape[${d + batchDim}] (${\n              updates.shape[d + batchDim]}) != shape[${d + batchDim}] (${\n              shape[d + batchDim]})`);\n    }\n  }\n}\n\nexport interface ScatterShapeInfo {\n  sliceRank: number;\n  numUpdates: number;\n  sliceSize: number;\n  strides: number[];\n  outputSize: number;\n}\n/**\n * Validate scatter nd inputs.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n */\nexport function validateInput(\n    updates: Tensor, indices: Tensor, shape: number[]) {\n  if (indices.rank < 1) {\n    throw new Error(\n        'tf.scatterND() expects the indices to be rank 1 or higher,' +\n        ` but the rank was ${indices.rank}.`);\n  }\n  if (updates.rank < 1) {\n    throw new Error(\n        'tf.scatterND() expects the updates to be rank 1 or higher,' +\n        ` but the rank was ${updates.rank}.`);\n  }\n  if (indices.dtype !== 'int32') {\n    throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${\n        indices.dtype}`);\n  }\n  if (shape.length < 1) {\n    throw new Error(\n        `Output rank must be greater or equal to 1, but got shape: ${shape}`);\n  }\n\n  if (shape.length === 0) {\n    if (indices.size === 0) {\n      throw new Error(`Indices specified for empty output. indices shape: ${\n          indices.shape}`);\n    }\n    if (updates.size === 0) {\n      throw new Error(`Updates specified for empty output. updates shape: ${\n          updates.shape}`);\n    }\n  }\n\n  validateUpdateShape(shape, indices, updates);\n}\n\n/**\n * Calculate the shape information for the output.\n *\n * @param update The tensor contains the update values.\n * @param indices The tensor contains the indices for the update values.\n * @param shape The shape of the output tensor.\n *\n * @returns ScatterShapeInfo\n */\nexport function calculateShapes(\n    updates: TensorInfo, indices: TensorInfo,\n    shape: number[]): ScatterShapeInfo {\n  // Calculate the number of dimensions in indices\n  const indicesRank = indices.shape.length;\n  const sliceRank = (indicesRank > 1) ? indices.shape[indicesRank - 1] : 1;\n\n  // Calculate the number of elements that make up each slice of our updated\n  // tensor. This allows us to work with flattened tensors and copy over whole\n  // slices at a time.\n  const totalNd = shape.length;\n\n  let sliceSize = 1;\n  for (let i = sliceRank; i < totalNd; ++i) {\n    sliceSize *= shape[i];\n  }\n\n  const safeSliceDim = (sliceRank < 1) ? 1 : sliceRank;\n  const numUpdates = sizeFromShape(indices.shape) / safeSliceDim;\n\n  const strides = [...computeStrides(shape.slice(0, sliceRank)), 1];\n  const outputSize = sizeFromShape(shape);\n  return {sliceRank, numUpdates, sliceSize, strides, outputSize};\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '../kernel_registry';\nimport * as util from '../util';\n\nexport type SliceInfo = {\n  nonStrided: boolean,\n  $begin: number[],\n  $end: number[],\n  $strides: number[],\n  size: number[],\n  newShape: number[],\n  outShape: number[]\n};\n\nexport function assertParamsValid(\n    input: TensorInfo, begin: number[], size: number[]): void {\n  const inputRank = input.shape.length;\n  util.assert(\n      inputRank === begin.length,\n      () => `Error in slice${inputRank}D: Length of begin ${begin} must ` +\n          `match the rank of the array (${inputRank}).`);\n  util.assert(\n      inputRank === size.length,\n      () => `Error in slice${inputRank}D: Length of size ${size} must ` +\n          `match the rank of the array (${inputRank}).`);\n\n  for (let i = 0; i < inputRank; ++i) {\n    util.assert(\n        begin[i] + size[i] <= input.shape[i],\n        () => `Error in slice${inputRank}D: begin[${i}] + size[${i}] ` +\n            `(${begin[i] + size[i]}) would overflow input.shape[${i}] (${\n                  input.shape[i]})`);\n  }\n}\n\n/** Converts a binary mask to an array of axes. Used in stridedSlice(). */\nexport function maskToAxes(mask: number): number[] {\n  const axes = [];\n  let axis = 0;\n  while (mask > 0) {\n    if (mask & 1) {\n      axes.push(axis);\n    }\n    mask /= 2;\n    axis++;\n  }\n  return axes;\n}\n\n/** Computes the output shape given the strided slice params. */\nexport function computeOutShape(\n    begin: number[], end: number[], strides: number[]): number[] {\n  const size = [];\n  for (let axis = 0; axis < begin.length; axis++) {\n    size[axis] = Math.ceil((end[axis] - begin[axis]) / strides[axis]);\n  }\n  return size;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stride value. Otherwise, insert.\nexport function stridesWithElidedDims(\n    strides: number[], ellipsisInsertionIndex: number, numElidedAxes: number,\n    inputShape: number[]): number[] {\n  const newStrides = [...strides];\n  for (let i = newStrides.length; i < inputShape.length; i++) {\n    newStrides.push(1);\n  }\n  for (let i = 0; i < numElidedAxes; i++) {\n    if (i === 0) {\n      newStrides[ellipsisInsertionIndex] = 1;\n    } else {\n      newStrides.splice(\n          ellipsisInsertionIndex, 0 /* num elements to delete */,\n          1 /* element to add */);\n      newStrides.pop();\n    }\n  }\n  return newStrides;\n}\n\nfunction unnormalizeAxis(\n    ellipsisInsertionIndex: number, numElidedAxes: number,\n    normalizedAxis: number): number {\n  if (normalizedAxis <= ellipsisInsertionIndex) {\n    return normalizedAxis;\n  }\n\n  return normalizedAxis - (numElidedAxes - 1);\n}\n\nfunction getElidedAxes(numElidedAxes: number, ellipsisInsertionIndex: number) {\n  const elidedAxes = [];\n  for (let i = 0; i < numElidedAxes; i++) {\n    elidedAxes.push(ellipsisInsertionIndex + i);\n  }\n  return elidedAxes;\n}\n\n// Normalize the start, end and strides.\nexport function getNormalizedAxes(\n    inputShape: number[], ellipsisAxes: number[], numInterpolatedAxes: number,\n    begin: number[], end: number[], strides: number[], beginMask: number,\n    endMask: number,\n    ellipsisMask: number): {begin: number[], end: number[], strides: number[]} {\n  const inputRank = inputShape.length;\n  let normalizedBegin = new Array(inputRank),\n      normalizedEnd = new Array(inputRank),\n      normalizedStrides = new Array(inputRank);\n  if (ellipsisAxes.length && numInterpolatedAxes > 0) {\n    const fullIndex = ellipsisAxes[0];\n\n    // The ellipsis applies to the masked index as well as any dimensions\n    // that are interpolated.\n    const numElidedAxes = numInterpolatedAxes + 1;\n    normalizedBegin = startIndicesWithElidedDims(\n        beginMask, fullIndex, numElidedAxes, begin, inputShape);\n    normalizedEnd = stopIndicesWithElidedDims(\n        endMask, fullIndex, numElidedAxes, end, inputShape);\n    normalizedStrides =\n        stridesWithElidedDims(strides, fullIndex, numElidedAxes, inputShape);\n  } else {\n    for (let axis = 0; axis < inputRank; axis++) {\n      normalizedBegin[axis] = startForAxis(\n          beginMask, begin, strides, inputShape, axis, ellipsisMask);\n      normalizedEnd[axis] =\n          stopForAxis(endMask, end, strides, inputShape, axis, ellipsisMask);\n      normalizedStrides[axis] = stridesForAxis(strides, axis, ellipsisMask);\n    }\n  }\n\n  return {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  };\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current start value. Otherwise, insert.\nexport function startIndicesWithElidedDims(\n    beginMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalBegin: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = 0;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalBegin[originalAxis];\n      if (beginMask & 1 << originalAxis) {\n        originalValue = 0;\n      }\n\n      newIndices[axis] = originalValue;\n    }\n  }\n  return newIndices;\n}\n\n// Creates full selection at the elided dimensions. If the dimension matches\n// the ellipsis mask, override the current stop value. Otherwise, insert.\nexport function stopIndicesWithElidedDims(\n    endMask: number, ellipsisInsertionIndex: number, numElidedAxes: number,\n    originalEnd: number[], inputShape: number[]): number[] {\n  const newIndices = [...inputShape];\n  const elidedAxes = getElidedAxes(numElidedAxes, ellipsisInsertionIndex);\n\n  for (let axis = 0; axis < newIndices.length; axis++) {\n    if (elidedAxes.indexOf(axis) > -1) {\n      newIndices[axis] = Number.MAX_SAFE_INTEGER;\n    } else {\n      const originalAxis =\n          unnormalizeAxis(ellipsisInsertionIndex, numElidedAxes, axis);\n      let originalValue = originalEnd[originalAxis];\n      if (endMask & 1 << originalAxis) {\n        originalValue = Number.MAX_SAFE_INTEGER;\n      }\n      newIndices[axis] = originalValue;\n    }\n  }\n\n  for (let i = 0; i < newIndices.length; i++) {\n    // Handle negative indices\n    const axisSize = inputShape[i];\n    if (newIndices[i] < 0) {\n      newIndices[i] += axisSize;\n    }\n    newIndices[i] = util.clamp(0, newIndices[i], inputShape[i]);\n  }\n  return newIndices;\n}\n\nexport function stridesForAxis(\n    strides: number[], axis: number, ellipsisMask: number): number {\n  let stride = strides[axis];\n  if (ellipsisMask & (1 << axis) || stride == null) {\n    stride = 1;\n  }\n\n  return stride;\n}\n\nexport function startForAxis(\n    beginMask: number, startIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let start = startIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or the begin index is not set\n  // for the axis.\n  if (beginMask & 1 << axis || ellipsisMask & 1 << axis || start == null) {\n    if (stride > 0) {\n      // Forward iteration - use the first element. These values will get\n      // clamped below (Note: We could have set them to 0 and axis_size-1, but\n      // use lowest() and max() to maintain symmetry with StopForAxis())\n      start = Number.MIN_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the last element.\n      start = Number.MAX_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (start < 0) {\n    start += axisSize;\n  }\n\n  // Clamping\n  start = util.clamp(0, start, axisSize - 1);\n\n  return start;\n}\n\nexport function stopForAxis(\n    endMask: number, stopIndices: number[], strides: number[],\n    inputShape: number[], axis: number, ellipsisMask: number): number {\n  // Begin with the specified index\n  let stop = stopIndices[axis];\n  const stride = strides[axis] || 1;\n\n  // Check the axis bit from right of masked axes, or if the stop index is not\n  // set for this axis.\n  if (endMask & (1 << axis) || ellipsisMask & (1 << axis) || stop == null) {\n    if (stride > 0) {\n      // Forward iteration - use the last element. These values will get\n      // clamped below\n      stop = Number.MAX_SAFE_INTEGER;\n    } else {\n      // Backward iteration - use the first element.\n      stop = Number.MIN_SAFE_INTEGER;\n    }\n  }\n\n  // Handle negative indices\n  const axisSize = inputShape[axis];\n  if (stop < 0) {\n    stop += axisSize;\n  }\n\n  // Clamping\n  // Because the end index points one past the last element, we need slightly\n  // different clamping ranges depending on the direction.\n  if (stride > 0) {\n    // Forward iteration\n    stop = util.clamp(0, stop, axisSize);\n  } else {\n    // Backward iteration\n    stop = util.clamp(-1, stop, axisSize - 1);\n  }\n\n  return stop;\n}\n\n/**\n * Returns true if the slice occupies a continous set of elements in the\n * 'flat' space.\n */\nexport function isSliceContinous(\n    shape: number[], begin: number[], size: number[]) {\n  // Index of the first axis that has size > 1.\n  let firstNonOneAxis = size.length;\n  for (let i = 0; i < size.length; i++) {\n    if (size[i] > 1) {\n      firstNonOneAxis = i;\n      break;\n    }\n  }\n\n  for (let i = firstNonOneAxis + 1; i < size.length; i++) {\n    if (begin[i] > 0 || size[i] !== shape[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function computeFlatOffset(begin: number[], strides: number[]): number {\n  let flatOffset = begin.length > 0 ? begin[begin.length - 1] : 1;\n  for (let i = 0; i < begin.length - 1; i++) {\n    flatOffset += begin[i] * strides[i];\n  }\n  return flatOffset;\n}\n\nexport function parseSliceParams(\n    x: TensorInfo, begin: number|number[], size?: number|number[]) {\n  // The following logic allows for more ergonomic calls.\n  let begin_: number[];\n  const xRank = x.shape.length;\n  if (typeof begin === 'number') {\n    begin_ = [begin, ...new Array(xRank - 1).fill(0)];\n  } else if (begin.length < xRank) {\n    begin_ = begin.concat(new Array(xRank - begin.length).fill(0));\n  } else {\n    begin_ = begin.slice();\n  }\n  begin_.forEach(d => {\n    util.assert(\n        d !== -1, () => 'slice() does not support negative begin indexing.');\n  });\n  let size_: number[];\n  if (size == null) {\n    size_ = new Array(xRank).fill(-1);\n  } else if (typeof size === 'number') {\n    size_ = [size, ...new Array(xRank - 1).fill(-1)];\n  } else if (size.length < xRank) {\n    size_ = size.concat(new Array(xRank - size.length).fill(-1));\n  } else {\n    size_ = size;\n  }\n  size_ = size_.map((d, i) => {\n    if (d >= 0) {\n      return d;\n    } else {\n      util.assert(\n          d === -1,\n          () => `Negative size values should be exactly -1 but got ` +\n              `${d} for the slice() size at index ${i}.`);\n      return x.shape[i] - begin_[i];\n    }\n  });\n  return [begin_, size_];\n}\n\nexport function sliceInfo(\n    xShape: number[], begin: number[], end: number[], strides: number[],\n    beginMask: number, endMask: number, ellipsisMask: number,\n    newAxisMask: number, shrinkAxisMask: number): SliceInfo {\n  // make a copy because it may be modified further down.\n  let $begin = begin.slice();\n  let $end = end.slice();\n  let $strides = strides;\n\n  if (strides == null) {\n    $strides = new Array($begin.length);\n  }\n\n  const ellipsisAxes = maskToAxes(ellipsisMask);\n  if (ellipsisAxes.length > 1) {\n    throw new Error('Multiple ellipses in slice is not allowed.');\n  }\n\n  if (ellipsisMask !== 0 && newAxisMask !== 0) {\n    throw new Error(\n        'Using both ellipsisMask and newAxisMask is not yet supported.');\n  }\n\n  if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {\n    throw new Error(\n        'Using both ellipsisMask and shrinkAxisMask is not yet supported.');\n  }\n\n  const numInterpolatedAxes = xShape.length - $begin.length;\n\n  // Expand the dims of x based on the newAxisMask.\n  const expandAxes = maskToAxes(newAxisMask);\n  const newShape = xShape.slice();\n  expandAxes.forEach(axis => {\n    $begin[axis] = 0;\n    $end[axis] = 1;\n    newShape.splice(axis, 0, 1);\n  });\n\n  const {\n    begin: normalizedBegin,\n    end: normalizedEnd,\n    strides: normalizedStrides\n  } =\n      getNormalizedAxes(\n          newShape, ellipsisAxes, numInterpolatedAxes, $begin, $end, $strides,\n          beginMask, endMask, ellipsisMask);\n  $begin = normalizedBegin;\n  $end = normalizedEnd;\n  $strides = normalizedStrides;\n\n  const shrinkAxes = maskToAxes(shrinkAxisMask);\n  // Adjust the ends based on the shrink mask.\n  shrinkAxes.forEach(axis => {\n    $end[axis] = $begin[axis] + 1;\n    $strides[axis] = 1;\n  });\n\n  // Figure out the output shape.\n  const size = computeOutShape($begin, $end, $strides);\n  // Remove the axes based on shrinkMask.\n  const outShape = size.filter((_, axis) => shrinkAxes.indexOf(axis) === -1);\n\n  const nonStrided = $strides.every(v => v === 1);\n\n  return {nonStrided, $begin, $end, $strides, size, newShape, outShape};\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {assert} from './util';\n\n/**\n * Types to support JSON-esque data structures internally.\n *\n * Internally ConfigDict's use camelCase keys and values where the\n * values are class names to be instantiated.  On the python side, these\n * will be snake_case.  Internally we allow Enums into the values for better\n * type safety, but these need to be converted to raw primitives (usually\n * strings) for round-tripping with python.\n *\n * toConfig returns the TS-friendly representation. model.toJSON() returns\n * the pythonic version as that's the portable format.  If you need to\n * python-ify a non-model level toConfig output, you'll need to use a\n * convertTsToPythonic from serialization_utils in -Layers.\n *\n */\nexport declare type ConfigDictValue =\n    boolean | number | string | null | ConfigDictArray | ConfigDict;\nexport declare interface ConfigDict {\n  [key: string]: ConfigDictValue;\n}\nexport declare interface ConfigDictArray extends Array<ConfigDictValue> {}\n\n/**\n * Type to represent the class-type of Serializable objects.\n *\n * Ie the class prototype with access to the constructor and any\n * static members/methods. Instance methods are not listed here.\n *\n * Source for this idea: https://stackoverflow.com/a/43607255\n */\nexport declare type SerializableConstructor<T extends Serializable> = {\n  // tslint:disable-next-line:no-any\n  new (...args: any[]): T; className: string; fromConfig: FromConfigMethod<T>;\n};\nexport declare type FromConfigMethod<T extends Serializable> =\n    (cls: SerializableConstructor<T>, config: ConfigDict) => T;\n\n/**\n * Serializable defines the serialization contract.\n *\n * TFJS requires serializable classes to return their className when asked\n * to avoid issues with minification.\n */\nexport abstract class Serializable {\n  /**\n   * Return the class name for this class to use in serialization contexts.\n   *\n   * Generally speaking this will be the same thing that constructor.name\n   * would have returned.  However, the class name needs to be robust\n   * against minification for serialization/deserialization to work properly.\n   *\n   * There's also places such as initializers.VarianceScaling, where\n   * implementation details between different languages led to different\n   * class hierarchies and a non-leaf node is used for serialization purposes.\n   */\n  getClassName(): string {\n    return (this.constructor as SerializableConstructor<Serializable>)\n        .className;\n  }\n\n  /**\n   * Return all the non-weight state needed to serialize this object.\n   */\n  abstract getConfig(): ConfigDict;\n\n  /**\n   * Creates an instance of T from a ConfigDict.\n   *\n   * This works for most descendants of serializable.  A few need to\n   * provide special handling.\n   * @param cls A Constructor for the class to instantiate.\n   * @param config The Configuration for the object.\n   */\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(config);\n  }\n}\n\n/**\n * Maps string keys to class constructors.\n *\n * Used during (de)serialization from the cross-language JSON format, which\n * requires the class name in the serialization format matches the class\n * names as used in Python, should it exist.\n */\nexport class SerializationMap {\n  private static instance: SerializationMap;\n  classNameMap: {\n    [className: string]:\n        [SerializableConstructor<Serializable>, FromConfigMethod<Serializable>]\n  };\n\n  private constructor() {\n    this.classNameMap = {};\n  }\n\n  /**\n   * Returns the singleton instance of the map.\n   */\n  static getMap(): SerializationMap {\n    if (SerializationMap.instance == null) {\n      SerializationMap.instance = new SerializationMap();\n    }\n    return SerializationMap.instance;\n  }\n\n  /**\n   * Registers the class as serializable.\n   */\n  static register<T extends Serializable>(cls: SerializableConstructor<T>) {\n    SerializationMap.getMap().classNameMap[cls.className] =\n        [cls, cls.fromConfig];\n  }\n}\n\n/**\n * Register a class with the serialization map of TensorFlow.js.\n *\n * This is often used for registering custom Layers, so they can be\n * serialized and deserialized.\n *\n * Example:\n *\n * ```js\n * class MyCustomLayer extends tf.layers.Layer {\n *   static className = 'MyCustomLayer';\n *\n *   constructor(config) {\n *     super(config);\n *   }\n * }\n * tf.serialization.registerClass(MyCustomLayer);\n * ```\n *\n * @param cls The class to be registered. It must have a public static member\n *   called `className` defined and the value must be a non-empty string.\n *\n * @doc {heading: 'Models', subheading: 'Serialization', ignoreCI: true}\n */\nexport function registerClass<T extends Serializable>(\n    cls: SerializableConstructor<T>) {\n  assert(\n      cls.className != null,\n      () => `Class being registered does not have the static className ` +\n          `property defined.`);\n  assert(\n      typeof cls.className === 'string',\n      () => `className is required to be a string, but got type ` +\n          typeof cls.className);\n  assert(\n      cls.className.length > 0,\n      () => `Class being registered has an empty-string as its className, ` +\n          `which is disallowed.`);\n\n  SerializationMap.register(cls);\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from './engine';\nimport {inferShape} from './tensor_util_env';\nimport {RecursiveArray, TensorLike, TypedArray} from './types';\nimport {arraysEqual, encodeString, flatten, isString, isTypedArray} from './util';\n\nconst TEST_EPSILON_FLOAT32 = 1e-3;\nexport const TEST_EPSILON_FLOAT16 = 1e-1;\n\nexport function expectArraysClose(\n    actual: TypedArray|number|RecursiveArray<number>,\n    expected: TypedArray|number|RecursiveArray<number>, epsilon?: number) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n  return expectArraysPredicate(\n      actual, expected, (a, b) => areClose(a as number, b as number, epsilon));\n}\n\nexport function testEpsilon() {\n  return ENGINE.backend.floatPrecision() === 32 ? TEST_EPSILON_FLOAT32 :\n                                                  TEST_EPSILON_FLOAT16;\n}\n\nfunction expectArraysPredicate(\n    actual: TensorLike, expected: TensorLike,\n    predicate: (a: {}, b: {}) => boolean) {\n  let checkClassType = true;\n  if (isTypedArray(actual) || isTypedArray(expected)) {\n    checkClassType = false;\n  }\n  if (isTypedArray(actual) && isTypedArray(expected)) {\n    checkClassType = true;\n  }\n  if (checkClassType) {\n    const aType = actual.constructor.name;\n    const bType = expected.constructor.name;\n\n    if (aType !== bType) {\n      throw new Error(\n          `Arrays are of different type. Actual: ${aType}. ` +\n          `Expected: ${bType}`);\n    }\n  }\n\n  if (Array.isArray(actual) && Array.isArray(expected)) {\n    const actualShape = inferShape(actual);\n    const expectedShape = inferShape(expected);\n    if (!arraysEqual(actualShape, expectedShape)) {\n      throw new Error(\n          `Arrays have different shapes. ` +\n          `Actual: [${actualShape}]. Expected: [${expectedShape}]`);\n    }\n  }\n\n  const actualFlat =\n      isTypedArray(actual) ? actual : flatten(actual as RecursiveArray<number>);\n  const expectedFlat = isTypedArray(expected) ?\n      expected :\n      flatten(expected as RecursiveArray<number>);\n\n  if (actualFlat.length !== expectedFlat.length) {\n    throw new Error(\n        `Arrays have different lengths actual: ${actualFlat.length} vs ` +\n        `expected: ${expectedFlat.length}.\\n` +\n        `Actual:   ${actualFlat}.\\n` +\n        `Expected: ${expectedFlat}.`);\n  }\n  for (let i = 0; i < expectedFlat.length; ++i) {\n    const a = actualFlat[i];\n    const e = expectedFlat[i];\n\n    if (!predicate(a, e)) {\n      throw new Error(\n          `Arrays differ: actual[${i}] = ${a}, expected[${i}] = ${e}.\\n` +\n          `Actual:   ${actualFlat}.\\n` +\n          `Expected: ${expectedFlat}.`);\n    }\n  }\n}\n\nexport interface DoneFn {\n  (): void;\n  fail: (message?: Error|string) => void;\n}\n\nexport function expectPromiseToFail(fn: () => Promise<{}>, done: DoneFn): void {\n  fn().then(() => done.fail(), () => done());\n}\n\nexport function expectArraysEqual(actual: TensorLike, expected: TensorLike) {\n  const exp = typeof expected === 'string' || typeof expected === 'number' ||\n          typeof expected === 'boolean' ?\n      [expected] as number[] :\n      expected as number[];\n  if (isString(actual) || isString((actual as string[])[0]) ||\n      isString(expected) || isString((expected as string[])[0])) {\n    // tslint:disable-next-line: triple-equals\n    return expectArraysPredicate(actual, exp, (a, b) => a == b);\n  }\n  return expectArraysPredicate(\n      actual, expected, (a, b) => areClose(a as number, b as number, 0));\n}\n\nexport function expectNumbersClose(a: number, e: number, epsilon?: number) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n  if (!areClose(a, e, epsilon)) {\n    throw new Error(`Numbers differ: actual === ${a}, expected === ${e}`);\n  }\n}\n\nfunction areClose(a: number, e: number, epsilon: number): boolean {\n  if (!isFinite(a) && !isFinite(e)) {\n    return true;\n  }\n  if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {\n    return false;\n  }\n  return true;\n}\n\nexport function expectValuesInRange(\n    actual: TypedArray|number[], low: number, high: number) {\n  for (let i = 0; i < actual.length; i++) {\n    if (actual[i] < low || actual[i] > high) {\n      throw new Error(\n          `Value out of range:${actual[i]} low: ${low}, high: ${high}`);\n    }\n  }\n}\n\nexport function expectArrayBuffersEqual(\n    actual: ArrayBuffer, expected: ArrayBuffer) {\n  // Safari & Jasmine don't like comparing ArrayBuffers directly. Wrapping in\n  // a Float32Array solves this issue.\n  expect(new Float32Array(actual)).toEqual(new Float32Array(expected));\n}\n\n/** Encodes strings into utf-8 bytes. */\nexport function encodeStrings(a: RecursiveArray<{}>):\n    RecursiveArray<Uint8Array> {\n  for (let i = 0; i < (a as Array<{}>).length; i++) {\n    const val = a[i];\n    if (Array.isArray(val)) {\n      encodeStrings(val);\n    } else {\n      a[i] = encodeString(val as string);\n    }\n  }\n  return a as RecursiveArray<Uint8Array>;\n}\n", "/** @license See the LICENSE file. */\n\n// This code is auto-generated, do not modify this file!\nconst version = '0.0.0';\nexport {version};\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from './tensor';\nimport {NamedTensorMap} from './tensor_types';\nimport {DataType} from './types';\n\nexport interface ModelPredictConfig {\n  /**\n   * Optional. Batch size (Integer). If unspecified, it will default to 32.\n   */\n  batchSize?: number;\n\n  /**\n   * Optional. Verbosity mode. Defaults to false.\n   */\n  verbose?: boolean;\n}\n\n/**\n * Interface for model input/output tensor info.\n */\nexport interface ModelTensorInfo {\n  // Name of the tensor.\n  name: string;\n  // Tensor shape information, Optional.\n  shape?: number[];\n  // Data type of the tensor.\n  dtype: DataType;\n  // TensorFlow native Data type of the tensor.\n  tfDtype?: string;\n}\n\n/**\n * Common interface for a machine learning model that can do inference.\n */\nexport interface InferenceModel {\n  /**\n   * Return the array of input tensor info.\n   */\n  readonly inputs: ModelTensorInfo[];\n\n  /**\n   * Return the array of output tensor info.\n   */\n  readonly outputs: ModelTensorInfo[];\n\n  /**\n   * Execute the inference for the input tensors.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format.\n   * For batch inference execution, the tensors for each input need to be\n   * concatenated together. For example with mobilenet, the required input shape\n   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n   * If we are provide a batched data of 100 images, the input tensor should be\n   * in the shape of [100, 244, 244, 3].\n   *\n   * @param config Prediction configuration for specifying the batch size.\n   *\n   * @returns Inference result tensors. The output would be single Tensor if\n   * model has single output node, otherwise Tensor[] or NamedTensorMap[] will\n   * be returned for model with multiple outputs.\n   */\n  predict(inputs: Tensor|Tensor[]|NamedTensorMap, config: ModelPredictConfig):\n      Tensor|Tensor[]|NamedTensorMap;\n\n  /**\n   * Single Execute the inference for the input tensors and return activation\n   * values for specified output node names without batching.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format.\n   *\n   * @param outputs string|string[]. List of output node names to retrieve\n   * activation from.\n   *\n   * @returns Activation values for the output nodes result tensors. The return\n   * type matches specified parameter outputs type. The output would be single\n   * Tensor if single output is specified, otherwise Tensor[] for multiple\n   * outputs.\n   */\n  execute(inputs: Tensor|Tensor[]|NamedTensorMap, outputs: string|string[]):\n      Tensor|Tensor[];\n}\n\n/**\n * @deprecated Deprecated interface for SavedModel/GraphModel MetaGraph info.\n *     User MetaGraph instead.\n */\nexport interface MetaGraphInfo {\n  tags: string[];\n  signatureDefs: SignatureDefInfo;\n}\n\n/**\n * @deprecated Deprecated interface for SavedModel/GraphModel SignatureDef info.\n *     User SignatureDef instead.\n */\nexport interface SignatureDefInfo {\n  [key: string]: {\n    inputs: {[key: string]: SavedModelTensorInfo};\n    outputs: {[key: string]: SavedModelTensorInfo};\n  };\n}\n\n/**\n * @deprecated Deprecated interface for SavedModel/GraphModel signature\n *     input/output Tensor info. User ModelTensorInfo instead.\n */\nexport interface SavedModelTensorInfo {\n  dtype: string;\n  shape: number[];\n  name: string;\n}\n\n/**\n * Interface for SavedModel/GraphModel MetaGraph info.\n */\nexport interface MetaGraph {\n  tags: string[];\n  signatureDefs: SignatureDef;\n}\n\n/**\n * Interface for SavedModel/GraphModel SignatureDef entry.\n */\nexport interface SignatureDefEntry {\n  inputs: {[key: string]: ModelTensorInfo};\n  outputs: {[key: string]: ModelTensorInfo};\n}\n\n/**\n * Interface for SavedModel/GraphModel SignatureDef info.\n */\nexport interface SignatureDef {\n  [key: string]: SignatureDefEntry;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelBackend} from './backends/backend';\nimport {ENGINE, Engine, MemoryInfo, ProfileInfo, ScopeFn, TimingInfo} from './engine';\nimport {env} from './environment';\n\nimport {Platform} from './platforms/platform';\nimport {setDeprecationWarningFn, Tensor} from './tensor';\nimport {TensorContainer} from './tensor_types';\nimport {getTensorsInContainer} from './tensor_util';\n\n/**\n * Enables production mode which disables correctness checks in favor of\n * performance.\n *\n * @doc {heading: 'Environment'}\n */\nexport function enableProdMode(): void {\n  env().set('PROD', true);\n}\n\n/**\n * Enables debug mode which will log information about all executed kernels:\n * the elapsed time of the kernel execution, as well as the rank, shape, and\n * size of the output tensor.\n *\n * Debug mode will significantly slow down your application as it will\n * download the result of every operation to the CPU. This should not be used in\n * production. Debug mode does not affect the timing information of the kernel\n * execution as we do not measure download time in the kernel execution time.\n *\n * See also: `tf.profile`, `tf.memory`.\n *\n * @doc {heading: 'Environment'}\n */\nexport function enableDebugMode(): void {\n  env().set('DEBUG', true);\n}\n\n/** Globally disables deprecation warnings */\nexport function disableDeprecationWarnings(): void {\n  env().set('DEPRECATION_WARNINGS_ENABLED', false);\n  console.warn(`TensorFlow.js deprecation warnings have been disabled.`);\n}\n\n/** Warn users about deprecated functionality. */\nexport function deprecationWarn(msg: string) {\n  if (env().getBool('DEPRECATION_WARNINGS_ENABLED')) {\n    console.warn(\n        msg + ' You can disable deprecation warnings with ' +\n        'tf.disableDeprecationWarnings().');\n  }\n}\nsetDeprecationWarningFn(deprecationWarn);\n\n/**\n * Dispose all variables kept in backend engine.\n *\n * @doc {heading: 'Environment'}\n */\nexport function disposeVariables(): void {\n  ENGINE.disposeVariables();\n}\n\n/**\n * It returns the global engine that keeps track of all tensors and backends.\n *\n * @doc {heading: 'Environment'}\n */\nexport function engine(): Engine {\n  return ENGINE;\n}\n\n/**\n * Returns memory info at the current time in the program. The result is an\n * object with the following properties:\n *\n * - `numBytes`: Number of bytes allocated (undisposed) at this time.\n * - `numTensors`: Number of unique tensors allocated.\n * - `numDataBuffers`: Number of unique data buffers allocated\n *   (undisposed) at this time, which is \u2264 the number of tensors\n *   (e.g. `a.reshape(newShape)` makes a new Tensor that shares the same\n *   data buffer with `a`).\n * - `unreliable`: True if the memory usage is unreliable. See `reasons` when\n *    `unreliable` is true.\n * - `reasons`: `string[]`, reasons why the memory is unreliable, present if\n *    `unreliable` is true.\n *\n * WebGL Properties:\n * - `numBytesInGPU`: Number of bytes allocated (undisposed) in the GPU only at\n *     this time.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function memory(): MemoryInfo {\n  return ENGINE.memory();\n}\n\n/**\n * Executes the provided function `f()` and returns a promise that resolves\n * with information about the function's memory use:\n * - `newBytes`: the number of new bytes allocated\n * - `newTensors`: the number of new tensors created\n * - `peakBytes`: the peak number of bytes allocated\n * - `kernels`: an array of objects for each kernel involved that reports\n * their input and output shapes, number of bytes used, and number of new\n * tensors created.\n * - `kernelNames`: an array of unique strings with just the names of the\n * kernels in the `kernels` array.\n *\n * ```js\n * const profile = await tf.profile(() => {\n *   const x = tf.tensor1d([1, 2, 3]);\n *   let x2 = x.square();\n *   x2.dispose();\n *   x2 = x.square();\n *   x2.dispose();\n *   return x;\n * });\n *\n * console.log(`newBytes: ${profile.newBytes}`);\n * console.log(`newTensors: ${profile.newTensors}`);\n * console.log(`byte usage over all kernels: ${profile.kernels.map(k =>\n * k.totalBytesSnapshot)}`);\n * ```\n *\n *\n * @doc {heading: 'Performance', subheading: 'Profile'}\n */\nexport function profile(f: () => (TensorContainer | Promise<TensorContainer>)):\n    Promise<ProfileInfo> {\n  return ENGINE.profile(f);\n}\n\n/**\n * Executes the provided function `fn` and after it is executed, cleans up all\n * intermediate tensors allocated by `fn` except those returned by `fn`.\n * `fn` must not return a Promise (async functions not allowed). The returned\n * result can be a complex object.\n *\n * Using this method helps avoid memory leaks. In general, wrap calls to\n * operations in `tf.tidy` for automatic memory cleanup.\n *\n * NOTE: Variables do *not* get cleaned up when inside a tidy(). If you want to\n * dispose variables, please use `tf.disposeVariables` or call dispose()\n * directly on variables.\n *\n * ```js\n * // y = 2 ^ 2 + 1\n * const y = tf.tidy(() => {\n *   // a, b, and one will be cleaned up when the tidy ends.\n *   const one = tf.scalar(1);\n *   const a = tf.scalar(2);\n *   const b = a.square();\n *\n *   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n *\n *   // The value returned inside the tidy function will return\n *   // through the tidy, in this case to the variable y.\n *   return b.add(one);\n * });\n *\n * console.log('numTensors (outside tidy): ' + tf.memory().numTensors);\n * y.print();\n * ```\n *\n * @param nameOrFn The name of the closure, or the function to execute.\n *     If a name is provided, the 2nd argument should be the function.\n *     If debug mode is on, the timing and the memory usage of the function\n *     will be tracked and displayed on the console using the provided name.\n * @param fn The function to execute.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function tidy<T extends TensorContainer>(\n    nameOrFn: string|ScopeFn<T>, fn?: ScopeFn<T>): T {\n  return ENGINE.tidy(nameOrFn, fn);\n}\n\n/**\n * Disposes any `tf.Tensor`s found within the provided object.\n *\n * @param container an object that may be a `tf.Tensor` or may directly\n *     contain `tf.Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. If\n *     the object is not a `tf.Tensor` or does not contain `Tensors`, nothing\n *     happens. In general it is safe to pass any object here, except that\n *     `Promise`s are not supported.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function dispose(container: TensorContainer) {\n  const tensors = getTensorsInContainer(container);\n  tensors.forEach(tensor => tensor.dispose());\n}\n\n/**\n * Keeps a `tf.Tensor` generated inside a `tf.tidy` from being disposed\n * automatically.\n *\n * ```js\n * let b;\n * const y = tf.tidy(() => {\n *   const one = tf.scalar(1);\n *   const a = tf.scalar(2);\n *\n *   // b will not be cleaned up by the tidy. a and one will be cleaned up\n *   // when the tidy ends.\n *   b = tf.keep(a.square());\n *\n *   console.log('numTensors (in tidy): ' + tf.memory().numTensors);\n *\n *   // The value returned inside the tidy function will return\n *   // through the tidy, in this case to the variable y.\n *   return b.add(one);\n * });\n *\n * console.log('numTensors (outside tidy): ' + tf.memory().numTensors);\n * console.log('y:');\n * y.print();\n * console.log('b:');\n * b.print();\n * ```\n *\n * @param result The tensor to keep from being disposed.\n *\n * @doc {heading: 'Performance', subheading: 'Memory'}\n */\nexport function keep<T extends Tensor>(result: T): T {\n  return ENGINE.keep(result);\n}\n\n/**\n * Executes `f()` and returns a promise that resolves with timing\n * information.\n *\n * The result is an object with the following properties:\n *\n * - `wallMs`: Wall execution time.\n * - `kernelMs`: Kernel execution time, ignoring data transfer. If using the\n * WebGL backend and the query timer extension is not available, this will\n * return an error object.\n * - On `WebGL` The following additional properties exist:\n *   - `uploadWaitMs`: CPU blocking time on texture uploads.\n *   - `downloadWaitMs`: CPU blocking time on texture downloads (readPixels).\n *\n * ```js\n * const x = tf.randomNormal([20, 20]);\n * const time = await tf.time(() => x.matMul(x));\n *\n * console.log(`kernelMs: ${time.kernelMs}, wallTimeMs: ${time.wallMs}`);\n * ```\n *\n * @param f The function to execute and time.\n *\n * @doc {heading: 'Performance', subheading: 'Timing'}\n */\nexport function time(f: () => void): Promise<TimingInfo> {\n  return ENGINE.time(f);\n}\n\n/**\n * Sets the backend (cpu, webgl, wasm, etc) responsible for creating tensors and\n * executing operations on those tensors. Returns a promise that resolves\n * to a boolean if the backend initialization was successful.\n *\n * Note this disposes the current backend, if any, as well as any tensors\n * associated with it. A new backend is initialized, even if it is of the\n * same type as the previous one.\n *\n * @param backendName The name of the backend. Currently supports\n *     `'webgl'|'cpu'` in the browser, `'tensorflow'` under node.js\n *     (requires tfjs-node), and `'wasm'` (requires tfjs-backend-wasm).\n *\n * @doc {heading: 'Backends'}\n */\nexport function setBackend(backendName: string): Promise<boolean> {\n  return ENGINE.setBackend(backendName);\n}\n\n/**\n * Returns a promise that resolves when the currently selected backend (or the\n * highest priority one) has initialized. Await this promise when you are using\n * a backend that has async initialization.\n *\n * @doc {heading: 'Backends'}\n */\nexport function ready(): Promise<void> {\n  return ENGINE.ready();\n}\n\n/**\n * Returns the current backend name (cpu, webgl, etc). The backend is\n * responsible for creating tensors and executing operations on those tensors.\n *\n * @doc {heading: 'Backends'}\n */\nexport function getBackend(): string {\n  return ENGINE.backendName;\n}\n\n/**\n * Removes a backend and the registered factory.\n *\n * @doc {heading: 'Backends'}\n */\nexport function removeBackend(name: string): void {\n  ENGINE.removeBackend(name);\n}\n\n/**\n * Finds the backend registered under the provided name. Returns null if the\n * name is not in the registry, or the registration hasn't finished yet.\n */\nexport function findBackend(name: string): KernelBackend {\n  return ENGINE.findBackend(name);\n}\n\n/**\n * Finds the backend factory registered under the provided name. Returns a\n * function that produces a new backend when called. Returns null if the name\n * is not in the registry.\n */\nexport function findBackendFactory(name: string): () =>\n    KernelBackend | Promise<KernelBackend> {\n  return ENGINE.findBackendFactory(name);\n}\n\n/**\n * Registers a global backend. The registration should happen when importing\n * a module file (e.g. when importing `backend_webgl.ts`), and is used for\n * modular builds (e.g. custom tfjs bundle with only webgl support).\n *\n * @param factory The backend factory function. When called, it should\n * return a backend instance, or a promise of an instance.\n * @param priority The priority of the backend (higher = more important).\n *     In case multiple backends are registered, the priority is used to find\n *     the best backend. Defaults to 1.\n * @return False if there is already a registered backend under this name, true\n *     if not.\n *\n * @doc {heading: 'Backends'}\n */\nexport function registerBackend(\n    name: string, factory: () => KernelBackend | Promise<KernelBackend>,\n    priority = 1): boolean {\n  return ENGINE.registerBackend(name, factory, priority);\n}\n\n/**\n * Gets the current backend. If no backends have been initialized, this will\n * attempt to initialize the best backend. Will throw an error if the highest\n * priority backend has async initialization, in which case, you should call\n * 'await tf.ready()' before running other code.\n *\n * @doc {heading: 'Backends'}\n */\nexport function backend(): KernelBackend {\n  return ENGINE.backend;\n}\n\n/**\n * Sets the global platform.\n *\n * @param platformName The name of this platform.\n * @param platform A platform implementation.\n */\nexport function setPlatform(platformName: string, platform: Platform) {\n  env().setPlatform(platformName, platform);\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Add, AddInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Adds two `tf.Tensor`s element-wise, A + B. Supports broadcasting.\n *\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3, 4]);\n * const b = tf.tensor1d([10, 20, 30, 40]);\n *\n * a.add(b).print();  // or tf.add(a, b)\n * ```\n *\n * ```js\n * // Broadcast add a with b.\n * const a = tf.scalar(5);\n * const b = tf.tensor1d([10, 20, 30, 40]);\n *\n * a.add(b).print();  // or tf.add(a, b)\n * ```\n * @param a The first `tf.Tensor` to add.\n * @param b The second `tf.Tensor` to add. Must have the same type as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction add_<T extends Tensor>(a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'add');\n  let $b = convertToTensor(b, 'b', 'add');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const inputs: AddInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Add, inputs as {} as NamedTensorMap);\n}\n\nexport const add = op({add_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {FloorDiv, FloorDivInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.\n * The result is rounded with floor function.\n *\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 9, 16]);\n * const b = tf.tensor1d([1, 2, 3, 4]);\n *\n * a.floorDiv(b).print();  // or tf.div(a, b)\n * ```\n *\n * ```js\n * // Broadcast div a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(2);\n *\n * a.floorDiv(b).print();  // or tf.floorDiv(a, b)\n * ```\n *\n * @param a The first tensor as the numerator.\n * @param b The second tensor as the denominator. Must have the same dtype as\n * `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction floorDiv_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'floorDiv');\n  let $b = convertToTensor(b, 'b', 'floorDiv');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const inputs: FloorDivInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(FloorDiv, inputs as {} as NamedTensorMap);\n}\n\nexport const floorDiv = op({floorDiv_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {RealDiv, RealDivInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {floorDiv} from './floorDiv';\nimport {op} from './operation';\n\n/**\n * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 9, 16]);\n * const b = tf.tensor1d([1, 2, 3, 4]);\n *\n * a.div(b).print();  // or tf.div(a, b)\n * ```\n *\n * ```js\n * // Broadcast div a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(2);\n *\n * a.div(b).print();  // or tf.div(a, b)\n * ```\n *\n * @param a The first tensor as the numerator.\n * @param b The second tensor as the denominator. Must have the same dtype as\n * `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction div_<T extends Tensor>(a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'div');\n  let $b = convertToTensor(b, 'b', 'div');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  if ($a.dtype === 'int32' && $b.dtype === 'int32') {\n    return floorDiv($a, $b);\n  }\n\n  const inputs: RealDivInputs = {a: $a, b: $b};\n  const attrs = {};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  return ENGINE.runKernel(RealDiv, inputs as {} as NamedTensorMap, attrs) as T;\n}\n\nexport const div = op({div_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Multiply, MultiplyInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Multiplies two `tf.Tensor`s element-wise, A * B. Supports broadcasting.\n *\n * We also expose `tf.mulStrict` which has the same signature as this op and\n * asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3, 4]);\n * const b = tf.tensor1d([2, 3, 4, 5]);\n *\n * a.mul(b).print();  // or tf.mul(a, b)\n * ```\n *\n * ```js\n * // Broadcast mul a with b.\n * const a = tf.tensor1d([1, 2, 3, 4]);\n * const b = tf.scalar(5);\n *\n * a.mul(b).print();  // or tf.mul(a, b)\n * ```\n * @param a The first tensor to multiply.\n * @param b The second tensor to multiply. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction mul_<T extends Tensor>(a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'mul');\n  let $b = convertToTensor(b, 'b', 'mul');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const inputs: MultiplyInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Multiply, inputs as {} as NamedTensorMap);\n}\nexport const mul = op({mul_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Abs, AbsInputs, ComplexAbs, ComplexAbsInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes absolute value element-wise: `abs(x)`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.abs().print();  // or tf.abs(x)\n * ```\n * @param x The input `tf.Tensor`.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction abs_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'abs');\n\n  if ($x.dtype === 'complex64') {\n    const inputs: ComplexAbsInputs = {x: $x};\n    return ENGINE.runKernel(ComplexAbs, inputs as {} as NamedTensorMap);\n  } else {\n    const inputs: AbsInputs = {x: $x};\n    return ENGINE.runKernel(Abs, inputs as {} as NamedTensorMap);\n  }\n}\n\nexport const abs = op({abs_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Acos, AcosInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes acos of the input `tf.Tensor` element-wise: `acos(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.acos().print();  // or tf.acos(x)\n * ```\n * @param x The input tensor.\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction acos_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'acos');\n  const inputs: AcosInputs = {x: $x};\n\n  return ENGINE.runKernel(Acos, inputs as {} as NamedTensorMap);\n}\nexport const acos = op({acos_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Acosh, AcoshInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the inverse hyperbolic cos of the input `tf.Tensor` element-wise:\n * `acosh(x)`\n *\n * ```js\n * const x = tf.tensor1d([10, 1, 3, 5.7]);\n *\n * x.acosh().print();  // or tf.acosh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction acosh_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'acosh');\n  const inputs: AcoshInputs = {x: $x};\n\n  return ENGINE.runKernel(Acosh, inputs as {} as NamedTensorMap);\n}\nexport const acosh = op({acosh_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {AddN, AddNInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Adds a list of `tf.Tensor`s element-wise, each with the same shape and dtype.\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n * const b = tf.tensor1d([3, 4]);\n * const c = tf.tensor1d([5, 6]);\n *\n * tf.addN([a, b, c]).print();\n * ```\n * @param tensors A list of tensors with the same shape and dtype.\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction addN_<T extends Tensor>(tensors: Array<T|TensorLike>): T {\n  util.assert(\n      Array.isArray(tensors),\n      () => 'The argument passed to tf.addN() must be a list of tensors');\n  util.assert(\n      tensors.length >= 1,\n      () => `Must pass at least one tensor to tf.addN(), but got ` +\n          `${tensors.length}`);\n\n  const $tensors =\n      tensors.map((t, i) => convertToTensor(t, `tensors${i}`, 'addN'));\n\n  const firstTensor = $tensors[0];\n  $tensors.forEach(t => {\n    if (t.dtype !== firstTensor.dtype) {\n      throw new Error(\n          'All tensors passed to tf.addN() must have the same dtype');\n    }\n  });\n\n  $tensors.forEach(t => {\n    if (!util.arraysEqual(t.shape, firstTensor.shape)) {\n      throw new Error(\n          'All tensors passed to tf.addN() must have the same shape');\n    }\n  });\n\n  const inputs: AddNInputs = $tensors;\n\n  return ENGINE.runKernel(AddN, inputs as {} as NamedTensorMap);\n}\n\nexport const addN = op({addN_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {All, AllAttrs, AllInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the logical and of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and an\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 1, 1], 'bool');\n *\n * x.all().print();  // or tf.all(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');\n *\n * const axis = 1;\n * x.all(axis).print();  // or tf.all(x, axis)\n * ```\n *\n * @param x The input tensor. Must be of dtype bool.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction all_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'all', 'bool');\n\n  const inputs: AllInputs = {x: $x};\n  const attrs: AllAttrs = {axis, keepDims};\n\n  return ENGINE.runKernel(\n      All, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const all = op({all_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Any, AnyAttrs, AnyInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the logical or of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and an\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 1, 1], 'bool');\n *\n * x.any().print();  // or tf.any(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 1, 0, 0], [2, 2], 'bool');\n *\n * const axis = 1;\n * x.any(axis).print();  // or tf.any(x, axis)\n * ```\n *\n * @param x The input tensor. Must be of dtype bool.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction any_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'any', 'bool');\n\n  const inputs: AnyInputs = {x: $x};\n  const attrs: AnyAttrs = {axis, keepDims};\n\n  return ENGINE.runKernel(\n      Any, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\n// tslint:disable-next-line:variable-name\nexport const any = op({any_});\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {ArgMax, ArgMaxAttrs, ArgMaxInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Returns the indices of the maximum values along an `axis`.\n *\n * The result has the same shape as `input` with the dimension along `axis`\n * removed.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.argMax().print();  // or tf.argMax(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n *\n * const axis = 1;\n * x.argMax(axis).print();  // or tf.argMax(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension to reduce. Defaults to 0 (outer-most dimension).\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction argMax_<T extends Tensor>(x: Tensor|TensorLike, axis = 0): T {\n  const $x = convertToTensor(x, 'x', 'argMax');\n\n  const inputs: ArgMaxInputs = {x: $x};\n  const attrs: ArgMaxAttrs = {axis};\n\n  return ENGINE.runKernel(\n      ArgMax, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const argMax = op({argMax_});\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {ArgMin, ArgMinAttrs, ArgMinInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Returns the indices of the minimum values along an `axis`.\n *\n * The result has the same shape as `input` with the dimension along `axis`\n * removed.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.argMin().print();  // or tf.argMin(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 4, 3], [2, 2]);\n *\n * const axis = 1;\n * x.argMin(axis).print();  // or tf.argMin(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension to reduce. Defaults to 0 (outer-most dimension).\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction argMin_<T extends Tensor>(x: Tensor|TensorLike, axis = 0): T {\n  const $x = convertToTensor(x, 'x', 'argMin');\n\n  const inputs: ArgMinInputs = {x: $x};\n  const attrs: ArgMinAttrs = {axis};\n\n  return ENGINE.runKernel(\n      ArgMin, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const argMin = op({argMin_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Asin, AsinInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes asin of the input `tf.Tensor` element-wise: `asin(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.asin().print();  // or tf.asin(x)\n * ```\n * @param x The input tensor.\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction asin_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'asin');\n  const inputs: AsinInputs = {x: $x};\n\n  return ENGINE.runKernel(Asin, inputs as {} as NamedTensorMap);\n}\nexport const asin = op({asin_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Asinh, AsinhInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes inverse hyperbolic sin of the input `tf.Tensor` element-wise:\n * `asinh(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.asinh().print();  // or tf.asinh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction asinh_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'asinh');\n\n  const inputs: AsinhInputs = {x: $x};\n\n  return ENGINE.runKernel(Asinh, inputs as {} as NamedTensorMap);\n}\nexport const asinh = op({asinh_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Atan, AtanInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes atan of the input `tf.Tensor` element-wise: `atan(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.atan().print();  // or tf.atan(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction atan_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'atan');\n\n  const inputs: AtanInputs = {x: $x};\n\n  return ENGINE.runKernel(Atan, inputs as {} as NamedTensorMap);\n}\nexport const atan = op({atan_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Atan2, Atan2Inputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes arctangent of `tf.Tensor`s a / b element-wise: `atan2(a, b)`.\n * Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1.0, 1.0, -1.0, .7]);\n * const b = tf.tensor1d([2.0, 13.0, 3.5, .21]);\n *\n * tf.atan2(a, b).print()\n * ```\n *\n * @param a The first tensor.\n * @param b The second tensor. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction atan2_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'atan2');\n  let $b = convertToTensor(b, 'b', 'atan2');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const inputs: Atan2Inputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Atan2, inputs as {} as NamedTensorMap);\n}\n\nexport const atan2 = op({atan2_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Atanh, AtanhInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes inverse hyperbolic tan of the input `tf.Tensor` element-wise:\n * `atanh(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, .1, -.1, .7]);\n *\n * x.atanh().print();  // or tf.atanh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction atanh_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'atanh');\n\n  const inputs: AtanhInputs = {x: $x};\n\n  return ENGINE.runKernel(Atanh, inputs as {} as NamedTensorMap);\n}\nexport const atanh = op({atanh_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\ntype PadType = 'SAME'|'VALID'|'NUMBER'|'EXPLICIT';\n\n// For NHWC should be in the following form:\n//  [[0, 0], [pad_top,pad_bottom], [pad_left, pad_right], [0, 0]]\n// For NCHW should be in the following form:\n//  [[0, 0], [0, 0], [pad_top,pad_bottom], [pad_left, pad_right]]\n// Reference: https://www.tensorflow.org/api_docs/python/tf/nn/conv2d\nexport type ExplicitPadding =\n    [[number, number], [number, number], [number, number], [number, number]];\n\nexport type PadInfo = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  type: PadType\n};\n\nexport type PadInfo3D = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  front: number,\n  back: number,\n  type: PadType\n};\n\n/**\n * Information about the forward pass of a convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv2DInfo = {\n  batchSize: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideHeight: number,\n  strideWidth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo,\n  inShape: [number, number, number, number],\n  outShape: [number, number, number, number],\n  filterShape: [number, number, number, number]\n};\n\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(\n    inputShape: [number, number, number, number],\n    filterShape: [number, number, number], strides: number|[number, number],\n    pad: 'same'|'valid'|number, dataFormat: 'NHWC' = 'NHWC',\n    dilations: number|[number, number]) {\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  const inputChannels = inputShape[3];\n  const $filterShape =\n      [...filterShape, inputChannels] as [number, number, number, number];\n  const $dataFormat = convertConv2DDataFormat(dataFormat);\n\n  return computeConv2DInfo(\n      inputShape, $filterShape, strides, dilations, pad,\n      null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\n\nexport function computePool2DInfo(\n    inShape: [number, number, number, number],\n    filterSize: [number, number]|number, strides: number|[number, number],\n    dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n\n  let filterShape: [number, number, number, number];\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv2DInfo(\n      inShape, filterShape, strides, dilations, pad, roundingMode, false,\n      dataFormat);\n}\n\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(\n    inShape: [number, number, number, number, number],\n    filterSize: number|[number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC'): Conv3DInfo {\n  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n\n  let filterShape: [number, number, number, number, number];\n  let $dataFormat: 'channelsFirst'|'channelsLast';\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv3DInfo(\n      inShape, filterShape, strides, dilations, pad, false, $dataFormat,\n      roundingMode);\n}\n\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(\n    inShape: [number, number, number, number],\n    filterShape: [number, number, number, number],\n    strides: number|[number, number], dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil', depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterHeight, filterWidth, , filterChannels] = filterShape;\n  const [strideHeight, strideWidth] = parseTupleParam(strides);\n  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outHeight, outWidth} = getPadAndOutInfo(\n      pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight,\n      effectiveFilterWidth, roundingMode, dataFormat);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inHeight,\n    inWidth,\n    inChannels,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\n/**\n * Information about the forward pass of a 3D convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv3DInfo = {\n  batchSize: number,\n  inDepth: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideDepth: number,\n  strideHeight: number,\n  strideWidth: number,\n  dilationDepth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterDepth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterDepth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo3D,\n  inShape: [number, number, number, number, number],\n  outShape: [number, number, number, number, number],\n  filterShape: [number, number, number, number, number]\n};\n\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(\n    inShape: [number, number, number, number, number],\n    filterShape: [number, number, number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast',\n    roundingMode?: 'floor'|'round'|'ceil'): Conv3DInfo {\n  let [batchSize, inDepth, inHeight, inWidth, inChannels] =\n      [-1, -1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterDepth, filterHeight, filterWidth, , filterChannels] =\n      filterShape;\n  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n  const [dilationDepth, dilationHeight, dilationWidth] =\n      parse3TupleParam(dilations);\n\n  const effectiveFilterDepth =\n      getEffectiveFilterSize(filterDepth, dilationDepth);\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outDepth, outHeight, outWidth} = get3DPadAndOutInfo(\n      pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth,\n      effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth,\n      roundingMode);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inDepth,\n    inHeight,\n    inWidth,\n    inChannels,\n    outDepth,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideDepth,\n    strideHeight,\n    strideWidth,\n    filterDepth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterDepth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationDepth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\nfunction computeOutputShape2D(\n    inShape: [number, number], fieldSize: number, stride: number,\n    zeroPad?: number, roundingMode?: 'floor'|'round'|'ceil'): [number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  const inputRows = inShape[0];\n  const inputCols = inShape[1];\n\n  const outputRows =\n      round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols =\n      round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(\n    inShape: [number, number, number, number], fieldSize: number,\n    outChannels: number, stride: number, zeroPad?: number,\n    roundingMode?: 'floor'|'round'|'ceil'): [number, number, number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  const inputDepth = inShape[0];\n  const inputRows = inShape[1];\n  const inputCols = inShape[2];\n\n  const outputDepths =\n      round((inputDepth - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputRows =\n      round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols =\n      round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n\n  return [outputDepths, outputRows, outputCols, outChannels];\n}\n\nexport function computeDefaultPad(\n    inputShape: [number, number]|[number, number, number, number],\n    fieldSize: number, stride: number, dilation = 1): number {\n  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor(\n      (inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param: number|number[]): [number, number, number] {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n  return param as [number, number, number];\n}\n\nfunction parse3TupleParam(param: number|[number, number, number]):\n    [number, number, number] {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize: number, dilation: number) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(\n    pad: 'same'|'valid'|number|ExplicitPadding, inHeight: number,\n    inWidth: number, strideHeight: number, strideWidth: number,\n    filterHeight: number, filterWidth: number,\n    roundingMode: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|\n    'channelsLast'): {padInfo: PadInfo, outHeight: number, outWidth: number} {\n  let padInfo: PadInfo;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {top: pad, bottom: pad, left: pad, right: pad, type: padType};\n    const outShape = computeOutputShape2D(\n        [inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongHeight =\n        Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    const padAlongWidth =\n        Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {top, bottom, left, right, type: 'SAME'};\n  } else if (pad === 'valid') {\n    padInfo = {top: 0, bottom: 0, left: 0, right: 0, type: 'VALID'};\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?\n        'VALID' :\n        'EXPLICIT';\n    padInfo = {top, bottom, left, right, type: padType};\n    outHeight = round(\n        (inHeight - filterHeight + top + bottom) / strideHeight + 1,\n        roundingMode);\n    outWidth = round(\n        (inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outHeight, outWidth};\n}\n\nfunction get3DPadAndOutInfo(\n    pad: 'same'|'valid'|number, inDepth: number, inHeight: number,\n    inWidth: number, strideDepth: number, strideHeight: number,\n    strideWidth: number, filterDepth: number, filterHeight: number,\n    filterWidth: number, roundingMode?: 'floor'|'round'|'ceil'): {\n  padInfo: PadInfo3D,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number\n} {\n  let padInfo: PadInfo3D;\n  let outDepth: number;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape4D(\n        [inDepth, inHeight, inWidth, 1], filterDepth, 1, strideDepth, pad,\n        roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    const padAlongHeight =\n        (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    const front = Math.floor(padAlongDepth / 2);\n    const back = padAlongDepth - front;\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n\n    padInfo = {top, bottom, left, right, front, back, type: 'SAME'};\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      front: 0,\n      back: 0,\n      type: 'VALID'\n    };\n    outDepth = Math.ceil((inDepth - filterDepth + 1) / strideDepth);\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outDepth, outHeight, outWidth};\n}\n\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value: number, roundingMode?: 'floor'|'round'|'ceil') {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n    case 'floor':\n      return Math.floor(value);\n    default:\n      throw new Error(`Unknown roundingMode ${roundingMode}`);\n  }\n}\n\nexport function tupleValuesAreOne(param: number|number[]): boolean {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\n\nexport function eitherStridesOrDilationsAreOne(\n    strides: number|number[], dilations: number|number[]): boolean {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat: 'NHWC'|'NCHW'):\n    'channelsLast'|'channelsFirst' {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Reshape, ReshapeAttrs, ReshapeInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, ShapeMap, TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Reshapes a `tf.Tensor` to a given shape.\n *\n * Given an input tensor, returns a new tensor with the same values as the\n * input tensor with shape `shape`.\n *\n * If one component of shape is the special value -1, the size of that\n * dimension is computed so that the total size remains constant. In\n * particular, a shape of [-1] flattens into 1-D. At most one component of\n * shape can be -1.\n *\n * If shape is 1-D or higher, then the operation returns a tensor with shape\n * shape filled with the values of tensor. In this case, the number of\n * elements implied by shape must be the same as the number of elements in\n * tensor.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * x.reshape([2, 2]).print();\n * ```\n *\n * @param x The input tensor to be reshaped.\n * @param shape An array of integers defining the output tensor shape.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction reshape_<R extends Rank>(\n    x: Tensor|TensorLike, shape: ShapeMap[R]): Tensor<R> {\n  const $x = convertToTensor(x, 'x', 'reshape', 'string_or_numeric');\n\n  const inputs: ReshapeInputs = {x: $x};\n  const attrs: ReshapeAttrs = {shape};\n  return ENGINE.runKernel(\n      Reshape, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\nexport const reshape = op({reshape_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {AvgPool, AvgPoolAttrs, AvgPoolInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {cast} from './cast';\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the 2D average pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *         https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction avgPool_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'avgPool', 'float32');\n  const dilations = 1;\n\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in avgPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in avgPool: x must be rank 4 but got rank ${x4D.rank}.`);\n\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in avgPool: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inputs: AvgPoolInputs = {x: x4D};\n\n  const attrs: AvgPoolAttrs = {filterSize, strides, pad, dimRoundingMode};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  let res = ENGINE.runKernel(\n                AvgPool, inputs as {} as NamedTensorMap,\n                attrs as {} as NamedAttrMap) as T;\n\n  res = cast(res, $x.dtype);\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n\n  return res;\n}\n\nexport const avgPool = op({avgPool_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {AvgPool3D, AvgPool3DAttrs, AvgPool3DInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor4D, Tensor5D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {cast} from './cast';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the 3D average pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.avgPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction avgPool3d_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike, filterSize: [number, number, number]|number,\n    strides: [number, number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC'): T {\n  const $x = convertToTensor(x, 'x', 'avgPool3d', 'float32');\n\n  let x5D = $x as Tensor5D;\n  let reshapedTo5D = false;\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);\n  }\n\n  util.assert(\n      x5D.rank === 5,\n      () => `Error in avgPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n  util.assert(\n      dataFormat === 'NDHWC',\n      () => `Error in avgPool3d: Only NDHWC is currently supported, ` +\n          `but got dataFormat of ${dataFormat}`);\n\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in avgPool3d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inputs: AvgPool3DInputs = {x: x5D};\n\n  const attrs:\n      AvgPool3DAttrs = {filterSize, strides, pad, dimRoundingMode, dataFormat};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  let res = ENGINE.runKernel(\n                AvgPool3D, inputs as {} as NamedTensorMap,\n                attrs as {} as NamedAttrMap) as T;\n\n  res = cast(res, x5D.dtype);\n\n  if (reshapedTo5D) {\n    return reshape(\n               res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]) as\n        T;\n  }\n\n  return res;\n}\n\nexport const avgPool3d = op({avgPool3d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Concat, ConcatAttrs, ConcatInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensorArray} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert} from '../util';\n\nimport {clone} from './clone';\nimport {op} from './operation';\n\n/**\n * Concatenates a list of `tf.Tensor`s along a given axis.\n *\n * The tensors ranks and types must match, and their sizes must match in all\n * dimensions except `axis`.\n *\n * Also available are stricter rank-specific methods that assert that\n * `tensors` are of the given rank:\n *   - `tf.concat1d`\n *   - `tf.concat2d`\n *   - `tf.concat3d`\n *   - `tf.concat4d`\n *\n * Except `tf.concat1d` (which does not have axis param), all methods have\n * same signature as this method.\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n * const b = tf.tensor1d([3, 4]);\n * a.concat(b).print();  // or a.concat(b)\n * ```\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n * const b = tf.tensor1d([3, 4]);\n * const c = tf.tensor1d([5, 6]);\n * tf.concat([a, b, c]).print();\n * ```\n *\n * ```js\n * const a = tf.tensor2d([[1, 2], [10, 20]]);\n * const b = tf.tensor2d([[3, 4], [30, 40]]);\n * const axis = 1;\n * tf.concat([a, b], axis).print();\n * ```\n * @param tensors A list of tensors to concatenate.\n * @param axis The axis to concate along. Defaults to 0 (the first dim).\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction concat_<T extends Tensor>(tensors: Array<T|TensorLike>, axis = 0): T {\n  assert(tensors.length >= 1, () => 'Pass at least one tensor to concat');\n\n  const $tensors =\n      convertToTensorArray(tensors, 'tensors', 'concat', 'string_or_numeric');\n\n  if ($tensors[0].dtype === 'complex64') {\n    $tensors.forEach(tensor => {\n      if (tensor.dtype !== 'complex64') {\n        throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${tensor.dtype}. `);\n      }\n    });\n  }\n\n  if ($tensors.length === 1) {\n    return clone($tensors[0]);\n  }\n\n  const inputs: ConcatInputs = $tensors;\n  const attr: ConcatAttrs = {axis};\n\n  return ENGINE.runKernel(\n      Concat, inputs as {} as NamedTensorMap, attr as {} as NamedAttrMap);\n}\n\nexport const concat = op({concat_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Sigmoid, SigmoidInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes sigmoid element-wise, `1 / (1 + exp(-x))`\n *\n * ```js\n * const x = tf.tensor1d([0, -1, 2, -3]);\n *\n * x.sigmoid().print();  // or tf.sigmoid(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sigmoid_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'sigmoid');\n\n  const inputs: SigmoidInputs = {x: $x};\n\n  return ENGINE.runKernel(Sigmoid, inputs as {} as NamedTensorMap);\n}\nexport const sigmoid = op({sigmoid_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Slice, SliceAttrs, SliceInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Extracts a slice from a `tf.Tensor` starting at coordinates `begin`\n * and is of size `size`.\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `x` is of the given rank:\n *   - `tf.slice1d`\n *   - `tf.slice2d`\n *   - `tf.slice3d`\n *   - `tf.slice4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.slice([1], [2]).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * x.slice([1, 0], [1, 2]).print();\n * ```\n * @param x The input `tf.Tensor` to slice from.\n * @param begin The coordinates to start the slice from. The length can be\n *     less than the rank of x - the rest of the axes will have implicit 0 as\n *     start. Can also be a single number, in which case it specifies the\n *     first axis.\n * @param size The size of the slice. The length can be less than the rank of\n *     x - the rest of the axes will have implicit -1. A value of -1 requests\n *     the rest of the dimensions in the axis. Can also be a single number,\n *     in which case it specifies the size of the first axis.\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction slice_<R extends Rank, T extends Tensor<R>>(\n    x: T|TensorLike, begin: number|number[], size?: number|number[]): T {\n  const $x = convertToTensor(x, 'x', 'slice', 'string_or_numeric');\n\n  if ($x.rank === 0) {\n    throw new Error('Slicing scalar is not possible');\n  }\n\n  const inputs: SliceInputs = {x: $x};\n  const attrs: SliceAttrs = {begin, size};\n\n  return ENGINE.runKernel(\n      Slice, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const slice = op({slice_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tanh, TanhInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes hyperbolic tangent of the input `tf.Tensor` element-wise: `tanh(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, 70]);\n *\n * x.tanh().print();  // or tf.tanh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction tanh_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'tanh');\n\n  const inputs: TanhInputs = {x: $x};\n\n  return ENGINE.runKernel(Tanh, inputs as {} as NamedTensorMap);\n}\nexport const tanh = op({tanh_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor1D, Tensor2D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {add} from './add';\nimport {concat} from './concat';\nimport {matMul} from './mat_mul';\nimport {mul} from './mul';\nimport {op} from './operation';\nimport {sigmoid} from './sigmoid';\nimport {slice} from './slice';\nimport {tanh} from './tanh';\n\n/**\n * Computes the next state and output of a BasicLSTMCell.\n *\n * Returns `[newC, newH]`.\n *\n * Derived from tf.contrib.rnn.BasicLSTMCell.\n *\n * @param forgetBias Forget bias for the cell.\n * @param lstmKernel The weights for the cell.\n * @param lstmBias The bias for the cell.\n * @param data The input to the cell.\n * @param c Previous cell state.\n * @param h Previous cell output.\n *\n * @doc {heading: 'Operations', subheading: 'RNN'}\n */\nfunction basicLSTMCell_(\n    forgetBias: Scalar|TensorLike, lstmKernel: Tensor2D|TensorLike,\n    lstmBias: Tensor1D|TensorLike, data: Tensor2D|TensorLike,\n    c: Tensor2D|TensorLike, h: Tensor2D|TensorLike): [Tensor2D, Tensor2D] {\n  const $forgetBias =\n      convertToTensor(forgetBias, 'forgetBias', 'basicLSTMCell');\n  const $lstmKernel =\n      convertToTensor(lstmKernel, 'lstmKernel', 'basicLSTMCell');\n  const $lstmBias = convertToTensor(lstmBias, 'lstmBias', 'basicLSTMCell');\n  const $data = convertToTensor(data, 'data', 'basicLSTMCell');\n  const $c = convertToTensor(c, 'c', 'basicLSTMCell');\n  const $h = convertToTensor(h, 'h', 'basicLSTMCell');\n\n  const combined = concat([$data, $h], 1);\n  const weighted = matMul(combined, $lstmKernel);\n  const res: Tensor2D = add(weighted, $lstmBias);\n\n  // i = input_gate, j = new_input, f = forget_gate, o = output_gate\n  const batchSize = res.shape[0];\n  const sliceCols = res.shape[1] / 4;\n  const sliceSize: [number, number] = [batchSize, sliceCols];\n  const i = slice(res, [0, 0], sliceSize);\n  const j = slice(res, [0, sliceCols], sliceSize);\n  const f = slice(res, [0, sliceCols * 2], sliceSize);\n  const o = slice(res, [0, sliceCols * 3], sliceSize);\n\n  const newC: Tensor2D =\n      add(mul(sigmoid(i), tanh(j)),\n          mul($c, sigmoid(add($forgetBias, f)) as Tensor2D));\n  const newH: Tensor2D = mul(tanh(newC), sigmoid(o));\n  return [newC, newH];\n}\n\nexport const basicLSTMCell = op({basicLSTMCell_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {BatchToSpaceND, BatchToSpaceNDAttrs, BatchToSpaceNDInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * This operation reshapes the \"batch\" dimension 0 into `M + 1` dimensions of\n * shape `blockShape + [batch]`, interleaves these blocks back into the grid\n * defined by the spatial dimensions `[1, ..., M]`, to obtain a result with\n * the same rank as the input. The spatial dimensions of this intermediate\n * result are then optionally cropped according to `crops` to produce the\n * output. This is the reverse of `tf.spaceToBatchND`. See below for a precise\n * description.\n *\n * ```js\n * const x = tf.tensor4d([1, 2, 3, 4], [4, 1, 1, 1]);\n * const blockShape = [2, 2];\n * const crops = [[0, 0], [0, 0]];\n *\n * x.batchToSpaceND(blockShape, crops).print();\n * ```\n *\n * @param x A `tf.Tensor`. N-D with `x.shape` = `[batch] + spatialShape +\n * remainingShape`, where spatialShape has `M` dimensions.\n * @param blockShape A 1-D array. Must have shape `[M]`, all values must\n * be >= 1.\n * @param crops A 2-D array.  Must have shape `[M, 2]`, all values must be >= 0.\n * `crops[i] = [cropStart, cropEnd]` specifies the amount to crop from input\n * dimension `i + 1`, which corresponds to spatial dimension `i`. It is required\n * that `cropStart[i] + cropEnd[i] <= blockShape[i] * inputShape[i + 1]`\n *\n * This operation is equivalent to the following steps:\n *\n * 1. Reshape `x` to `reshaped` of shape: `[blockShape[0], ...,\n * blockShape[M-1], batch / prod(blockShape), x.shape[1], ...,\n * x.shape[N-1]]`\n *\n * 2. Permute dimensions of `reshaped`to produce `permuted` of shape `[batch /\n * prod(blockShape),x.shape[1], blockShape[0], ..., x.shape[M],\n * blockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]`\n *\n * 3. Reshape `permuted` to produce `reshapedPermuted` of shape `[batch /\n * prod(blockShape),x.shape[1] * blockShape[0], ..., x.shape[M] *\n * blockShape[M-1],x.shape[M+1], ..., x.shape[N-1]]`\n *\n * 4. Crop the start and end of dimensions `[1, ..., M]` of `reshapedPermuted`\n * according to `crops` to produce the output of shape: `[batch /\n * prod(blockShape),x.shape[1] * blockShape[0] - crops[0,0] - crops[0,1],\n * ..., x.shape[M] * blockShape[M-1] - crops[M-1,0] -\n * crops[M-1,1],x.shape[M+1], ..., x.shape[N-1]]`\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction batchToSpaceND_<T extends Tensor>(\n    x: T|TensorLike, blockShape: number[], crops: number[][]): T {\n  const $x = convertToTensor(x, 'x', 'batchToSpaceND');\n  const prod = blockShape.reduce((a, b) => a * b);\n\n  util.assert(\n      $x.rank >= 1 + blockShape.length,\n      () => `input rank is ${$x.rank} but should be > than blockShape.length ${\n          blockShape.length}`);\n\n  util.assert(\n      crops.length === blockShape.length,\n      () => `crops.length is ${\n          crops.length} but should be equal to blockShape.length  ${\n          blockShape.length}`);\n\n  util.assert(\n      $x.shape[0] % prod === 0,\n      () => `input tensor batch is ${\n                $x.shape[0]} but is not divisible by the product of ` +\n          `the elements of blockShape ${blockShape.join(' * ')} === ${prod}`);\n\n  const inputs: BatchToSpaceNDInputs = {x: $x};\n  const attrs: BatchToSpaceNDAttrs = {blockShape, crops};\n\n  return ENGINE.runKernel(\n      BatchToSpaceND, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n}\n\nexport const batchToSpaceND = op({batchToSpaceND_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor, Tensor4D} from '../tensor';\nimport {Rank} from '../types';\nimport {reshape} from './reshape';\n\nexport function xAs4D<R extends Rank>(x: Tensor<R>) {\n  let x4D: Tensor4D;\n  if (x.rank === 0 || x.rank === 1) {\n    x4D = reshape(x, [1, 1, 1, x.size]);\n  } else if (x.rank === 2) {\n    x4D = reshape(x, [1, 1, x.shape[0], x.shape[1]]);\n  } else if (x.rank === 3) {\n    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\n  } else {\n    x4D = x as Tensor4D;\n  }\n\n  return x4D;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {FusedBatchNorm, FusedBatchNormAttrs, FusedBatchNormInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor, Tensor1D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {xAs4D} from './batchnorm_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Batch normalization.\n *\n * As described in\n * [http://arxiv.org/abs/1502.03167](http://arxiv.org/abs/1502.03167).\n *\n * Mean, variance, scale, and offset can be of two shapes:\n *   - The same shape as the input.\n *   - In the common case, the depth dimension is the last dimension of x, so\n *     the values would be an `tf.Tensor1D` of shape [depth].\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that parameters passed are of given rank\n *   - `tf.batchNorm2d`\n *   - `tf.batchNorm3d`\n *   - `tf.batchNorm4d`\n *\n * @param x The input Tensor.\n * @param mean A mean Tensor.\n * @param variance A variance Tensor.\n * @param offset An offset Tensor.\n * @param scale A scale Tensor.\n * @param varianceEpsilon A small float number to avoid dividing by 0.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction batchNorm_<R extends Rank>(\n    x: Tensor<R>|TensorLike, mean: Tensor<R>|Tensor1D|TensorLike,\n    variance: Tensor<R>|Tensor1D|TensorLike,\n    offset?: Tensor<R>|Tensor1D|TensorLike,\n    scale?: Tensor<R>|Tensor1D|TensorLike,\n    varianceEpsilon?: number): Tensor<R> {\n  if (varianceEpsilon == null) {\n    varianceEpsilon = 0.001;\n  }\n  const $x = convertToTensor(x, 'x', 'batchNorm');\n  const $mean = convertToTensor(mean, 'mean', 'batchNorm');\n  const $variance = convertToTensor(variance, 'variance', 'batchNorm');\n  let $scale: Tensor<R>|Tensor1D;\n  if (scale != null) {\n    $scale = convertToTensor(scale, 'scale', 'batchNorm');\n  }\n  let $offset: Tensor<R>|Tensor1D;\n  if (offset != null) {\n    $offset = convertToTensor(offset, 'offset', 'batchNorm');\n  }\n\n  util.assert(\n      $mean.rank === $variance.rank,\n      () => 'Batch normalization gradient requires mean and variance to have ' +\n          'equal ranks.');\n  util.assert(\n      $offset == null || $mean.rank === $offset.rank,\n      () => 'Batch normalization gradient requires mean and offset to have ' +\n          'equal ranks.');\n  util.assert(\n      $scale == null || $mean.rank === $scale.rank,\n      () => 'Batch normalization gradient requires mean and scale to have ' +\n          'equal ranks.');\n\n  const x4D: Tensor4D = xAs4D($x);\n\n  const inputs: FusedBatchNormInputs = {\n    x: x4D,\n    scale: $scale,\n    offset: $offset,\n    mean: $mean,\n    variance: $variance\n  };\n\n  const attrs: FusedBatchNormAttrs = {varianceEpsilon};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  FusedBatchNorm, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as Tensor<R>;\n\n  return reshape(res, $x.shape);\n}\n\nexport const batchNorm = op({batchNorm_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor1D, Tensor2D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {batchNorm} from './batchnorm';\nimport {op} from './operation';\n\n/**\n * Batch normalization, strictly for 2D. For the more relaxed version, see\n * `tf.batchNorm`.\n *\n * @param x The input Tensor.\n * @param mean A mean Tensor.\n * @param variance A variance Tensor.\n * @param offset An offset Tensor.\n * @param scale A scale Tensor.\n * @param varianceEpsilon A small float number to avoid dividing by 0.\n */\nfunction batchNorm2d_(\n    x: Tensor2D|TensorLike, mean: Tensor2D|Tensor1D|TensorLike,\n    variance: Tensor2D|Tensor1D|TensorLike,\n    offset?: Tensor2D|Tensor1D|TensorLike, scale?: Tensor2D|Tensor1D|TensorLike,\n    varianceEpsilon?: number): Tensor2D {\n  const $x = convertToTensor(x, 'x', 'batchNorm');\n  const $mean = convertToTensor(mean, 'mean', 'batchNorm');\n  const $variance = convertToTensor(variance, 'variance', 'batchNorm');\n  let $scale: Tensor2D|Tensor1D;\n  if (scale != null) {\n    $scale = convertToTensor(scale, 'scale', 'batchNorm');\n  }\n  let $offset: Tensor2D|Tensor1D;\n  if (offset != null) {\n    $offset = convertToTensor(offset, 'offset', 'batchNorm');\n  }\n  util.assert(\n      $x.rank === 2,\n      () => `Error in batchNorm2D: x must be rank 2 but got rank ` +\n          `${$x.rank}.`);\n  util.assert(\n      $mean.rank === 2 || $mean.rank === 1,\n      () => `Error in batchNorm2D: mean must be rank 2 or rank 1 but ` +\n          `got rank ${$mean.rank}.`);\n  util.assert(\n      $variance.rank === 2 || $variance.rank === 1,\n      () => `Error in batchNorm2D: variance must be rank 2 or rank 1 ` +\n          `but got rank ${$variance.rank}.`);\n  if ($scale != null) {\n    util.assert(\n        $scale.rank === 2 || $scale.rank === 1,\n        () => `Error in batchNorm2D: scale must be rank 2 or rank 1 ` +\n            `but got rank ${$scale.rank}.`);\n  }\n  if ($offset != null) {\n    util.assert(\n        $offset.rank === 2 || $offset.rank === 1,\n        () => `Error in batchNorm2D: offset must be rank 2 or rank 1 ` +\n            `but got rank ${$offset.rank}.`);\n  }\n\n  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);\n}\n\nexport const batchNorm2d = op({batchNorm2d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor1D, Tensor3D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {batchNorm} from './batchnorm';\nimport {op} from './operation';\n\n/**\n * Batch normalization, strictly for 3D. For the more relaxed version, see\n * `tf.batchNorm`.\n *\n * @param x The input Tensor.\n * @param mean A mean Tensor.\n * @param variance A variance Tensor.\n * @param offset An offset Tensor.\n * @param scale A scale Tensor.\n * @param varianceEpsilon A small float number to avoid dividing by 0.\n */\nfunction batchNorm3d_(\n    x: Tensor3D|TensorLike, mean: Tensor3D|Tensor1D|TensorLike,\n    variance: Tensor3D|Tensor1D|TensorLike,\n    offset?: Tensor3D|Tensor1D|TensorLike, scale?: Tensor3D|Tensor1D|TensorLike,\n    varianceEpsilon?: number): Tensor3D {\n  const $x = convertToTensor(x, 'x', 'batchNorm');\n  const $mean = convertToTensor(mean, 'mean', 'batchNorm');\n  const $variance = convertToTensor(variance, 'variance', 'batchNorm');\n  let $scale: Tensor3D|Tensor1D;\n  if (scale != null) {\n    $scale = convertToTensor(scale, 'scale', 'batchNorm');\n  }\n  let $offset: Tensor3D|Tensor1D;\n  if (offset != null) {\n    $offset = convertToTensor(offset, 'offset', 'batchNorm');\n  }\n  util.assert(\n      $x.rank === 3,\n      () => `Error in batchNorm3D: x must be rank 3 but got rank ` +\n          `${$x.rank}.`);\n  util.assert(\n      $mean.rank === 3 || $mean.rank === 1,\n      () => `Error in batchNorm3D: mean must be rank 3 or rank 1 but ` +\n          `got rank ${$mean.rank}.`);\n  util.assert(\n      $variance.rank === 3 || $variance.rank === 1,\n      () => `Error in batchNorm3D: variance must be rank 3 or rank 1 ` +\n          `but got rank ${$variance.rank}.`);\n  if ($scale != null) {\n    util.assert(\n        $scale.rank === 3 || $scale.rank === 1,\n        () => `Error in batchNorm3D: scale must be rank 3 or rank 1 ` +\n            `but got rank ${$scale.rank}.`);\n  }\n  if ($offset != null) {\n    util.assert(\n        $offset.rank === 3 || $offset.rank === 1,\n        () => `Error in batchNorm3D: offset must be rank 3 or rank 1 ` +\n            `but got rank ${$offset.rank}.`);\n  }\n\n  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);\n}\n\nexport const batchNorm3d = op({batchNorm3d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor1D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {batchNorm} from './batchnorm';\nimport {op} from './operation';\n\n/**\n * Batch normalization, strictly for 4D. For the more relaxed version, see\n * `tf.batchNorm`.\n *\n * @param x The input Tensor.\n * @param mean A mean Tensor.\n * @param variance A variance Tensor.\n * @param offset An offset Tensor.\n * @param scale A scale Tensor.\n * @param varianceEpsilon A small float number to avoid dividing by 0.\n */\nfunction batchNorm4d_(\n    x: Tensor4D|TensorLike, mean: Tensor4D|Tensor1D|TensorLike,\n    variance: Tensor4D|Tensor1D|TensorLike,\n    offset?: Tensor4D|Tensor1D|TensorLike, scale?: Tensor4D|Tensor1D|TensorLike,\n    varianceEpsilon?: number): Tensor4D {\n  const $x = convertToTensor(x, 'x', 'batchNorm');\n  const $mean = convertToTensor(mean, 'mean', 'batchNorm');\n  const $variance = convertToTensor(variance, 'variance', 'batchNorm');\n  let $scale: Tensor4D|Tensor1D;\n  if (scale != null) {\n    $scale = convertToTensor(scale, 'scale', 'batchNorm');\n  }\n  let $offset: Tensor4D|Tensor1D;\n  if (offset != null) {\n    $offset = convertToTensor(offset, 'offset', 'batchNorm');\n  }\n  util.assert(\n      $x.rank === 4,\n      () => `Error in batchNorm4D: x must be rank 4 but got rank ` +\n          `${$x.rank}.`);\n  util.assert(\n      $mean.rank === 4 || $mean.rank === 1,\n      () => `Error in batchNorm4D: mean must be rank 4 or rank 1 but ` +\n          `got rank ${$mean.rank}.`);\n  util.assert(\n      $variance.rank === 4 || $variance.rank === 1,\n      () => `Error in batchNorm4D: variance must be rank 4 or rank 1 ` +\n          `but got rank ${$variance.rank}.`);\n  if ($scale != null) {\n    util.assert(\n        $scale.rank === 4 || $scale.rank === 1,\n        () => `Error in batchNorm4D: scale must be rank 4 or rank 1 ` +\n            `but got rank ${$scale.rank}.`);\n  }\n  if ($offset != null) {\n    util.assert(\n        $offset.rank === 4 || $offset.rank === 1,\n        () => `Error in batchNorm4D: offset must be rank 4 or rank 1 ` +\n            `but got rank ${$offset.rank}.`);\n  }\n  return batchNorm($x, $mean, $variance, $offset, $scale, varianceEpsilon);\n}\n\nexport const batchNorm4d = op({batchNorm4d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Bincount, BincountAttrs, BincountInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor1D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Outputs a vector with length `size` and the same dtype as `weights`.\n *\n * If `weights` are empty, then index `i` stores the number of times the value\n * `i` is counted in `x`. If `weights` are non-empty, then index `i` stores the\n * sum of the value in `weights` at each index where the corresponding value in\n * `x` is `i`.\n *\n * Values in `x` outside of the range [0, size) are ignored.\n *\n * @param x The input int tensor, rank 1.\n * @param weights The weights tensor, must have the same shape as x, or a\n *     length-0 Tensor, in which case it acts as all weights equal to 1.\n * @param size Non-negative integer.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction bincount_<T extends Tensor1D>(\n    x: T|TensorLike, weights: T|TensorLike, size: number): T {\n  const $x = convertToTensor(x, 'x', 'bincount');\n  const $weights = convertToTensor(weights, 'weights', 'bincount');\n\n  util.assert(\n      $x.dtype === 'int32',\n      () => `Error in bincount: input ` +\n          `dtype must be int32, but got ${$x.dtype}`);\n  util.assert(size >= 0, () => `size must be non-negative, but got ${size}.`);\n  util.assert(\n      $weights.size === $x.size || $weights.size === 0,\n      () => `Error in bincount: weights must have the same size as input or` +\n          `0-length, but got input shape: ${$x.shape}, weights shape: ` +\n          `${$weights.shape}.`);\n\n  const inputs: BincountInputs = {x: $x, weights: $weights};\n  const attrs: BincountAttrs = {size};\n\n  return ENGINE.runKernel(\n      Bincount, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const bincount = op({bincount_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { NamedTensorMap } from '../tensor_types';\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs, BroadcastArgsInputs } from '../kernel_names';\nimport { Tensor } from '../tensor';\nimport { convertToTensor } from '../tensor_util_env';\nimport { Rank, TensorLike } from '../types';\n\nimport { op } from './operation';\n\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastArgs_<R extends Rank>(\n  s0: Tensor | TensorLike, s1: Tensor | TensorLike): Tensor<R> {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n\n  if (shape1Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): first input must be a vector (rank=1). ' +\n      `Has rank ${shape1Input.rank}`);\n  }\n\n  if (shape2Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): second input must be a vector (rank=1). ' +\n      `Has rank ${shape2Input.rank}`);\n  }\n\n  const inputs: BroadcastArgsInputs = { s0: shape1Input, s1: shape2Input };\n  return ENGINE.runKernel(BroadcastArgs, inputs as {} as NamedTensorMap);\n}\n\nexport const broadcastArgs = op({ broadcastArgs_ });\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tile, TileAttrs, TileInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, ShapeMap, TensorLike} from '../types';\n\nimport {clone} from './clone';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Broadcast an array to a compatible shape NumPy-style.\n *\n * The tensor's shape is compared to the broadcast shape from end to beginning.\n * Ones are prepended to the tensor's shape until is has the same length as\n * the broadcast shape. If input.shape[i]==shape[i], the (i+1)-th axis is\n * already broadcast-compatible. If input.shape[i]==1 and shape[i]==N, then\n * the input tensor is tiled N times along that axis (using tf.tile).\n *\n * @param input The tensor that is to be broadcasted.\n * @param shape The input is to be broadcast to this shape.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastTo_<R extends Rank>(\n    x: Tensor|TensorLike, shape: ShapeMap[R]): Tensor<R> {\n  let input = convertToTensor(x, 'broadcastTo', 'x');\n  const xShape = input.shape;\n\n  if (shape.some(d => !(d > 0) || d % 1 !== 0)) {\n    throw new Error(`broadcastTo(): Invalid broadcast shape [${shape}].`);\n  }\n\n  if (shape.length < input.rank) {\n    throw new Error(`broadcastTo(): shape.length=${shape.length} < input.rank=${\n        input.rank}.`);\n  }\n\n  if (shape.length > input.rank) {\n    const newShape = input.shape.slice();\n    while (newShape.length < shape.length) {\n      newShape.unshift(1);\n    }\n    input = reshape(input, newShape);\n  }\n\n  const inputShape = input.shape;\n  const reps: number[] = Array.from(shape);\n  for (let i = shape.length - 1; i >= 0; i--) {\n    if (inputShape[i] === shape[i]) {\n      reps[i] = 1;\n    } else if (input.shape[i] !== 1) {\n      throw new Error(\n          `broadcastTo(): [${xShape}] cannot be broadcast to [${shape}].`);\n    }\n  }\n  const axes = reps.map((n, i) => n > 1 ? i : -1).filter(i => i >= 0);\n\n  if (axes.length === 0) {\n    return clone(input) as Tensor<R>;\n  }\n\n  // TODO call broadcastTo kernel directly once backends implement broadcstTo\n  const inputs: TileInputs = {x: input};\n  const attrs: TileAttrs = {reps};\n  return ENGINE.runKernel(\n      Tile, inputs as {} as NamedTensorMap, attrs as unknown as NamedAttrMap);\n}\n\nexport const broadcastTo = op({broadcastTo_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Ceil, CeilInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes ceiling of input `tf.Tensor` element-wise: `ceil(x)`\n *\n * ```js\n * const x = tf.tensor1d([.6, 1.1, -3.3]);\n *\n * x.ceil().print();  // or tf.ceil(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction ceil_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'ceil');\n\n  const inputs: CeilInputs = {x: $x};\n  return ENGINE.runKernel(Ceil, inputs as {} as NamedTensorMap);\n}\nexport const ceil = op({ceil_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {ClipByValue, ClipByValueAttrs, ClipByValueInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Clips values element-wise. `max(min(x, clipValueMax), clipValueMin)`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.clipByValue(-2, 3).print();  // or tf.clipByValue(x, -2, 3)\n * ```\n * @param x The input tensor.\n * @param clipValueMin Lower-bound of range to be clipped to.\n * @param clipValueMax Upper-bound of range to be clipped to.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction clipByValue_<T extends Tensor>(\n    x: T|TensorLike, clipValueMin: number, clipValueMax: number): T {\n  const $x = convertToTensor(x, 'x', 'clipByValue');\n  util.assert(\n      (clipValueMin <= clipValueMax),\n      () => `Error in clip: min (${clipValueMin}) must be ` +\n          `less than or equal to max (${clipValueMax}).`);\n\n  const inputs: ClipByValueInputs = {x: $x};\n  const attrs: ClipByValueAttrs = {clipValueMin, clipValueMax};\n\n  return ENGINE.runKernel(\n      ClipByValue, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const clipByValue = op({clipByValue_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor1D} from '../tensor';\nimport {TensorLike} from '../types';\n\nimport {concat} from './concat';\nimport {op} from './operation';\n\n/**\n * Concatenates a list of`tf.Tensor1D`s along an axis. See `concat` for details.\n *\n * For example, if:\n * A: shape(3) = |r1, g1, b1|\n * B: shape(2) = |r2, g2|\n * C = tf.concat1d([A, B]) == |r1, g1, b1, r2, g2|\n *\n * @param tensors A list of`tf.Tensor`s to concatenate.\n * @return The concatenated array.\n */\nfunction concat1d_(tensors: Array<Tensor1D|TensorLike>): Tensor1D {\n  return concat(tensors, 0 /* axis */);\n}\n\nexport const concat1d = op({concat1d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor2D} from '../tensor';\nimport {TensorLike} from '../types';\n\nimport {concat} from './concat';\nimport {op} from './operation';\n\n/**\n * Concatenates a list of`tf.Tensor2D`s along an axis. See `concat` for details.\n *\n * For example, if:\n * A: shape(2, 3) = | r1, g1, b1 |\n *                  | r2, g2, b2 |\n *\n * B: shape(2, 3) = | r3, g3, b3 |\n *                  | r4, g4, b4 |\n *\n * C = tf.concat2d([A, B], axis)\n *\n * if axis = 0:\n * C: shape(4, 3) = | r1, g1, b1 |\n *                  | r2, g2, b2 |\n *                  | r3, g3, b3 |\n *                  | r4, g4, b4 |\n *\n * if axis = 1:\n * C = shape(2, 6) = | r1, g1, b1, r3, g3, b3 |\n *                   | r2, g2, b2, r4, g4, b4 |\n *\n *\n * @param tensors A list of `tf.Tensor`s to concatenate.\n * @param axis The axis to concatenate along.\n * @return The concatenated array.\n */\nfunction concat2d_(\n    tensors: Array<Tensor2D|TensorLike>, axis: number): Tensor2D {\n  return concat(tensors, axis);\n}\n\nexport const concat2d = op({concat2d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor3D} from '../tensor';\nimport {TensorLike} from '../types';\n\nimport {concat} from './concat';\nimport {op} from './operation';\n\n/**\n * Concatenates a list of `tf.Tensor3D`s along an axis.\n * See `concat` for details.\n *\n * For example, if:\n * A: shape(2, 1, 3) = | r1, g1, b1 |\n *                     | r2, g2, b2 |\n *\n * B: shape(2, 1, 3) = | r3, g3, b3 |\n *                     | r4, g4, b4 |\n *\n * C = tf.concat3d([A, B], axis)\n *\n * if axis = 0:\n * C: shape(4, 1, 3) = | r1, g1, b1 |\n *                     | r2, g2, b2 |\n *                     | r3, g3, b3 |\n *                     | r4, g4, b4 |\n *\n * if axis = 1:\n * C: shape(2, 2, 3) = | r1, g1, b1, r3, g3, b3 |\n *                     | r2, g2, b2, r4, g4, b4 |\n *\n * if axis = 2:\n * C = shape(2, 1, 6) = | r1, g1, b1, r3, g3, b3 |\n *                      | r2, g2, b2, r4, g4, b4 |\n *\n * @param tensors A list of`tf.Tensor`s to concatenate.\n * @param axis The axis to concate along.\n * @return The concatenated array.\n */\nfunction concat3d_(\n    tensors: Array<Tensor3D|TensorLike>, axis: number): Tensor3D {\n  return concat(tensors, axis);\n}\n\nexport const concat3d = op({concat3d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor4D} from '../tensor';\nimport {TensorLike} from '../types';\n\nimport {concat} from './concat';\nimport {op} from './operation';\n\n/**\n * Concatenates a list of `tf.Tensor4D`s along an axis.\n * See `concat` for details.\n *\n * @param tensors A list of `tf.Tensor`s to concatenate.\n * @param axis The axis to concate along.\n * @return The concatenated array.\n */\nfunction concat4d_(\n    tensors: Array<Tensor4D|TensorLike>, axis: number): Tensor4D {\n  return concat(tensors, axis);\n}\n\nexport const concat4d = op({concat4d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Conv2D, Conv2DAttrs, Conv2DInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes a 2D convolution over the input x.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv2d_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filter: Tensor4D|TensorLike,\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dilations: [number, number]|number = [1, 1],\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'conv2d');\n  const $filter = convertToTensor(filter, 'filter', 'conv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in conv2d: input must be rank 4, but got rank ${x4D.rank}.`);\n  util.assert(\n      $filter.rank === 4,\n      () => `Error in conv2d: filter must be rank 4, but got rank ` +\n          `${$filter.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv2d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n  util.assert(\n      inDepth === $filter.shape[2],\n      () => `Error in conv2d: depth of input (${inDepth}) must match ` +\n          `input depth for filter ${$filter.shape[2]}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in conv2D: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const inputs: Conv2DInputs = {x: x4D, filter: $filter};\n  const attrs:\n      Conv2DAttrs = {strides, pad, dataFormat, dilations, dimRoundingMode};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  Conv2D, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const conv2d = op({conv2d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor2D, Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {conv2d} from './conv2d';\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes a 1D convolution over the input x.\n *\n * @param x The input tensor, of rank 3 or rank 2, of shape\n *     `[batch, width, inChannels]`. If rank 2, batch of 1 is assumed.\n * @param filter The filter, rank 3, of shape\n *     `[filterWidth, inDepth, outDepth]`.\n * @param stride The number of entries by which the filter is moved right at\n *     each step.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat An optional string from \"NWC\", \"NCW\". Defaults to \"NWC\",\n *     the data is stored in the order of [batch, in_width, in_channels]. Only\n *     \"NWC\" is currently supported.\n * @param dilation The dilation rate in which we sample input values in\n *     atrous convolution. Defaults to `1`. If it is greater than 1, then\n *     stride must be `1`.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv1d_<T extends Tensor2D|Tensor3D>(\n    x: T|TensorLike, filter: Tensor3D|TensorLike, stride: number,\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dataFormat: 'NWC'|'NCW' = 'NWC', dilation = 1,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'conv1d');\n  const $filter = convertToTensor(filter, 'filter', 'conv1d');\n\n  let x3D = $x as Tensor3D;\n  let reshapedTo3D = false;\n  if ($x.rank === 2) {\n    reshapedTo3D = true;\n    x3D = reshape($x, [1, $x.shape[0], $x.shape[1]]);\n  }\n\n  util.assert(\n      x3D.rank === 3,\n      () => `Error in conv1d: input must be rank 3, but got rank ${x3D.rank}.`);\n  util.assert(\n      $filter.rank === 3,\n      () => `Error in conv1d: filter must be rank 3, but got rank ` +\n          `${$filter.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv1d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  util.assert(\n      x3D.shape[2] === $filter.shape[1],\n      () => `Error in conv1d: depth of input (${x3D.shape[2]}) must match ` +\n          `input depth for filter ${$filter.shape[1]}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(stride, dilation),\n      () => 'Error in conv1D: Either stride or dilation must be 1. ' +\n          `Got stride ${stride} and dilation '${dilation}'`);\n  util.assert(\n      dataFormat === 'NWC',\n      () => `Error in conv1d: got dataFormat of ${\n          dataFormat} but only NWC is currently supported.`);\n\n  const filter4D = reshape(\n      $filter, [1, $filter.shape[0], $filter.shape[1], $filter.shape[2]]);\n  const input4D = reshape(x3D, [x3D.shape[0], 1, x3D.shape[1], x3D.shape[2]]);\n  const strides: [number, number] = [1, stride];\n  const dilations: [number, number] = [1, dilation];\n\n  const conv2dDataFormat = 'NHWC';\n\n  const res = conv2d(\n      (input4D as Tensor4D), (filter4D as Tensor4D), strides, pad,\n      conv2dDataFormat, dilations, dimRoundingMode);\n\n  if (reshapedTo3D) {\n    return reshape(res, [res.shape[2], res.shape[3]]) as T;\n  }\n\n  return reshape(res, [res.shape[0], res.shape[2], res.shape[3]]) as T;\n}\n\nexport const conv1d = op({conv1d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Conv2DBackpropInput, Conv2DBackpropInputAttrs, Conv2DBackpropInputInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport * as util from '../util';\n\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the derivative of the input of a 2D convolution.\n *\n * @param xShape The shape of the input: [batch, height, width, inDepth].\n * If length of 3, batch of 1 is assumed.\n * @param dy The derivative of the output, of rank 4 or rank 3 of shape\n *   `[batch, outHeight, outWidth, outDepth]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm used:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction conv2DBackpropInput_<T extends Tensor3D|Tensor4D>(\n    xShape: [number, number, number, number]|[number, number, number], dy: T,\n    filter: Tensor4D, strides: [number, number]|number,\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  util.assert(\n      xShape.length === dy.rank,\n      () => `Length of inShape ` +\n          `(${xShape.length}) and rank of dy (${dy.rank}) must match`);\n\n  let xShape4D = xShape as [number, number, number, number];\n  let dy4D = dy as Tensor4D;\n  let reshapedTo4D = false;\n  if (dy.rank === 3) {\n    reshapedTo4D = true;\n    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n    xShape4D = [1, xShape[0], xShape[1], xShape[2]];\n  }\n\n  util.assert(\n      xShape4D.length === 4,\n      () =>\n          `Error in conv2dDerInput: inShape must be length 4, but got length ` +\n          `${xShape4D.length}.`);\n  util.assert(\n      dy4D.rank === 4,\n      () => `Error in conv2dDerInput: dy must be rank 4, but got ` +\n          `rank ${dy4D.rank}`);\n  util.assert(\n      filter.rank === 4,\n      () => `Error in conv2dDerInput: filter must be rank 4, but got ` +\n          `rank ${filter.rank}`);\n  const inDepth = dataFormat === 'NHWC' ? xShape4D[3] : xShape4D[1];\n  const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n  util.assert(\n      inDepth === filter.shape[2],\n      () => `Error in conv2dDerInput: depth of input (${inDepth}) must ` +\n          `match input depth for filter ${filter.shape[2]}.`);\n  util.assert(\n      outDepth === filter.shape[3],\n      () => `Error in conv2dDerInput: depth of output (${outDepth}) must ` +\n          `match output depth for filter ${filter.shape[3]}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv2dDerInput: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inputs: Conv2DBackpropInputInputs = {dy: dy4D, filter};\n\n  const attrs: Conv2DBackpropInputAttrs =\n      {strides, pad, dataFormat, dimRoundingMode, inputShape: xShape4D};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  Conv2DBackpropInput, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const conv2DBackpropInput = op({conv2DBackpropInput_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {conv2DBackpropInput} from './conv2d_backprop_input';\nimport {ExplicitPadding} from './conv_util';\nimport {op} from './operation';\n\n/**\n * Computes the transposed 2D convolution of an image, also known as a\n * deconvolution.\n *\n * @param x The input image, of rank 4 or rank 3, of shape\n *   `[batch, height, width, inDepth]`. If rank 3, batch of 1 is assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, outDepth, inDepth]`.\n *     `inDepth` must match `inDepth` in `x`.\n * @param outputShape Output shape, of rank 4 or rank 3:\n *     `[batch, height, width, outDepth]`. If rank 3, batch of 1 is assumed.\n * @param strides The strides of the original convolution:\n *     `[strideHeight, strideWidth]`.\n * @param pad  The type of padding algorithm used in the non-transpose version\n *    of the op.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv2dTranspose_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filter: Tensor4D|TensorLike,\n    outputShape: [number, number, number, number]|[number, number, number],\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|ExplicitPadding,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'conv2dTranspose');\n  const $filter = convertToTensor(filter, 'filter', 'conv2dTranspose');\n\n  return conv2DBackpropInput(\n      outputShape, $x, $filter, strides, pad, 'NHWC', dimRoundingMode);\n}\n\nexport const conv2dTranspose = op({conv2dTranspose_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Conv3D, Conv3DAttrs, Conv3DInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor4D, Tensor5D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {eitherStridesOrDilationsAreOne} from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes a 3D convolution over the input x.\n *\n * @param x The input tensor, of rank 5 or rank 4, of shape\n *     `[batch, depth, height, width, channels]`. If rank 4,\n * batch of 1 is assumed.\n * @param filter The filter, rank 5, of shape\n *     `[filterDepth, filterHeight, filterWidth, inChannels, outChannels]`.\n *      inChannels must match between input and filter.\n * @param strides The strides of the convolution: `[strideDepth, strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat: An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param dilations The dilation rates: `[dilationDepth, dilationHeight,\n *     dilationWidth]` in which we sample input values across the height\n *     and width dimensions in atrous convolution. Defaults to `[1, 1, 1]`.\n *     If `dilations` is a single number, then\n *     `dilationDepth == dilationHeight == dilationWidth`. If it is greater\n *     than 1, then all values of `strides` must be 1.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv3d_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike, filter: Tensor5D|TensorLike,\n    strides: [number, number, number]|number, pad: 'valid'|'same',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC',\n    dilations: [number, number, number]|number = [1, 1, 1]): T {\n  const $x = convertToTensor(x, 'x', 'conv3d');\n  const $filter = convertToTensor(filter, 'filter', 'conv3d');\n\n  let x5D = $x as Tensor5D;\n  let reshapedTo5D = false;\n\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);\n  }\n  util.assert(\n      x5D.rank === 5,\n      () => `Error in conv3d: input must be rank 5, but got rank ${x5D.rank}.`);\n  util.assert(\n      $filter.rank === 5,\n      () => `Error in conv3d: filter must be rank 5, but got rank ` +\n          `${$filter.rank}.`);\n  util.assert(\n      x5D.shape[4] === $filter.shape[3],\n      () => `Error in conv3d: depth of input (${x5D.shape[4]}) must match ` +\n          `input depth for filter ${$filter.shape[3]}.`);\n  util.assert(\n      eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in conv3D: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  util.assert(\n      dataFormat === 'NDHWC',\n      () => `Error in conv3d: got dataFormat of ${\n          dataFormat} but only NDHWC is currently supported.`);\n\n  const inputs: Conv3DInputs = {x: x5D, filter: $filter};\n\n  const attrs: Conv3DAttrs = {strides, pad, dataFormat, dilations};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  Conv3D, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo5D) {\n    return reshape(\n               res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]) as\n        T;\n  }\n  return res;\n}\n\nexport const conv3d = op({conv3d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Conv3DBackpropInputV2, Conv3DBackpropInputV2Attrs, Conv3DBackpropInputV2Inputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor4D, Tensor5D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the derivative of the input of a 3D convolution.\n *\n * @param xShape The shape of the input: [batch, depth, height, width,\n * in_channels]. If length of 4, batch of 1 is assumed.\n * @param dy The derivative of the output, of rank 5 or rank 4 of shape\n *   `[batch, outDepth, outHeight, outWidth, in_channels]`.\n * If rank 4, batch of 1 is assumed.\n * @param filter The filter, rank 5, of shape\n *     `[filterDepth, filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideDepth, strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm used:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n */\nfunction conv3DBackpropInput_<T extends Tensor4D|Tensor5D>(\n    xShape:\n        [number, number, number, number,\n         number]|[number, number, number, number],\n    dy: T, filter: Tensor5D, strides: [number, number, number]|number,\n    pad: 'valid'|'same'): T {\n  util.assert(\n      xShape.length === dy.rank,\n      () => `Length of inShape ` +\n          `(${xShape.length}) and rank of dy (${dy.rank}) must match`);\n\n  let xShape5D = xShape as [number, number, number, number, number];\n  let dy5D = dy as Tensor5D;\n  let reshapedTo5D = false;\n  if (dy.rank === 4) {\n    reshapedTo5D = true;\n    dy5D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2], dy.shape[3]]);\n    xShape5D = [1, xShape[0], xShape[1], xShape[2], xShape[3]];\n  }\n\n  const inDepth = xShape5D[4];\n  const outDepth = dy5D.shape[4];\n  util.assert(\n      xShape5D.length === 5,\n      () =>\n          `Error in conv3dDerInput: inShape must be length 5, but got length ` +\n          `${xShape5D.length}.`);\n  util.assert(\n      dy5D.rank === 5,\n      () => `Error in conv3dDerInput: dy must be rank 5, but got ` +\n          `rank ${dy5D.rank}`);\n  util.assert(\n      filter.rank === 5,\n      () => `Error in conv3dDerInput: filter must be rank 5, but got ` +\n          `rank ${filter.rank}`);\n  util.assert(\n      inDepth === filter.shape[3],\n      () => `Error in conv3dDerInput: depth of input (${inDepth}) must ` +\n          `match input depth for filter ${filter.shape[3]}.`);\n  util.assert(\n      outDepth === filter.shape[4],\n      () => `Error in conv3dDerInput: depth of output (${outDepth}) must ` +\n          `match output depth for filter ${filter.shape[4]}.`);\n\n  const inputs: Conv3DBackpropInputV2Inputs = {dy: dy5D, filter};\n\n  const attrs:\n      Conv3DBackpropInputV2Attrs = {pad, strides, inputShape: xShape5D};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  Conv3DBackpropInputV2, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo5D) {\n    return reshape(\n               res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]) as\n        T;\n  }\n  return res;\n}\n\nexport const conv3DBackpropInput = op({conv3DBackpropInput_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor4D, Tensor5D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {conv3DBackpropInput} from './conv3d_backprop_input';\nimport {op} from './operation';\n\n/**\n * Computes the transposed 3D convolution of a volume, also known as a\n * deconvolution.\n *\n * @param x The input image, of rank 5 or rank 4, of shape\n *   `[batch, depth, height, width, inDepth]`. If rank 4, batch of 1 is assumed.\n * @param filter The filter, rank 4, of shape\n *     `[depth, filterHeight, filterWidth, outDepth, inDepth]`.\n *     `inDepth` must match `inDepth` in `x`.\n * @param outputShape Output shape, of rank 5 or rank 4:\n *     `[batch, depth, height, width, outDepth]`. If rank 3, batch of 1 is\n *    assumed.\n * @param strides The strides of the original convolution:\n *     `[strideDepth, strideHeight, strideWidth]`.\n * @param pad  The type of padding algorithm used in the non-transpose version\n *    of the op.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction conv3dTranspose_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike, filter: Tensor5D|TensorLike,\n    outputShape:\n        [number, number, number, number,\n         number]|[number, number, number, number],\n    strides: [number, number, number]|number, pad: 'valid'|'same'): T {\n  const $x = convertToTensor(x, 'x', 'conv3dTranspose');\n  const $filter = convertToTensor(filter, 'filter', 'conv3dTranspose');\n\n  return conv3DBackpropInput(outputShape, $x, $filter, strides, pad);\n}\n\nexport const conv3dTranspose = op({conv3dTranspose_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Cos, CosInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes cos of the input `tf.Tensor` element-wise: `cos(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n *\n * x.cos().print();  // or tf.cos(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction cos_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'cos');\n\n  const inputs: CosInputs = {x: $x};\n\n  return ENGINE.runKernel(Cos, inputs as {} as NamedTensorMap);\n}\nexport const cos = op({cos_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Cosh, CoshInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes hyperbolic cos of the input `tf.Tensor` element-wise: `cosh(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.cosh().print();  // or tf.cosh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction cosh_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'cosh');\n  const inputs: CoshInputs = {x: $x};\n\n  return ENGINE.runKernel(Cosh, inputs as {} as NamedTensorMap);\n}\nexport const cosh = op({cosh_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Cumsum, CumsumAttrs, CumsumInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the cumulative sum of a `tf.Tensor` along `axis`.\n *\n * ```js\n * const x = tf.tensor([1, 2, 3, 4]);\n * x.cumsum().print();\n * ```\n * ```js\n * const x = tf.tensor([[1, 2], [3, 4]]);\n * x.cumsum().print();\n * ```\n *\n * @param x The input tensor to be summed.\n * @param axis The axis along which to sum. Optional. Defaults to 0.\n * @param exclusive Whether to perform exclusive cumulative sum. Optional.\n *     Defaults to false. If set to true then the sum of each tensor entry\n *     does not include its own value, but only the values previous to it\n *     along the specified axis.\n * @param reverse Whether to sum in the opposite direction. Optional.\n *     Defaults to false.\n *\n * @doc {heading: 'Operations', subheading: 'Scan'}\n */\nfunction cumsum_<T extends Tensor>(\n    x: Tensor|TensorLike, axis = 0, exclusive = false, reverse = false): T {\n  const $x = convertToTensor(x, 'x', 'cumsum');\n\n  const inputs: CumsumInputs = {x: $x};\n  const attrs: CumsumAttrs = {axis, exclusive, reverse};\n\n  return ENGINE.runKernel(\n      Cumsum, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const cumsum = op({cumsum_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {DenseBincount, DenseBincountAttrs, DenseBincountInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor1D, Tensor2D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Outputs a vector with length `size` and the same dtype as `weights`.\n *\n * If `weights` are empty, then index `i` stores the number of times the value\n * `i` is counted in `x`. If `weights` are non-empty, then index `i` stores the\n * sum of the value in `weights` at each index where the corresponding value in\n * `x` is `i`.\n *\n * Values in `x` outside of the range [0, size) are ignored.\n *\n * @param x The input int tensor, rank 1 or rank 2.\n * @param weights The weights tensor, must have the same shape as x, or a\n *     length-0 Tensor, in which case it acts as all weights equal to 1.\n * @param size Non-negative integer.\n * @param binaryOutput Optional. Whether the kernel should count the appearance\n *     or number of occurrences. Defaults to False.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction denseBincount_<T extends Tensor1D|Tensor2D>(\n    x: T|TensorLike, weights: T|TensorLike, size: number,\n    binaryOutput = false): T {\n  const $x = convertToTensor(x, 'x', 'denseBincount');\n  const $weights = convertToTensor(weights, 'weights', 'denseBincount');\n\n  util.assert(\n      $x.dtype === 'int32',\n      () => `Error in denseBincount: input ` +\n          `dtype must be int32, but got ${$x.dtype}`);\n  util.assert(\n      $x.rank <= 2,\n      () => `Error in denseBincount: input must be at most rank 2, but got ` +\n          `rank ${$x.rank}.`);\n  util.assert(size >= 0, () => `size must be non-negative, but got ${size}.`);\n  util.assert(\n      $weights.size === $x.size || $weights.size === 0,\n      () =>\n          `Error in denseBincount: weights must have the same shape as x or ` +\n          `0-length, but got x shape: ${$x.shape}, weights shape: ` +\n          `${$weights.shape}.`);\n\n  const inputs: DenseBincountInputs = {x: $x, weights: $weights};\n  const attrs: DenseBincountAttrs = {size, binaryOutput};\n\n  return ENGINE.runKernel(\n      DenseBincount, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n}\n\nexport const denseBincount = op({denseBincount_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {DepthToSpace, DepthToSpaceAttrs, DepthToSpaceInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike4D} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Rearranges data from depth into blocks of spatial data. More specifically,\n * this op outputs a copy of the input tensor where values from the `depth`\n * dimension are moved in spatial blocks to the `height` and `width` dimensions.\n * The attr `blockSize` indicates the input block size and how the data is\n * moved.\n *\n *  - Chunks of data of size `blockSize * blockSize` from depth are rearranged\n * into non-overlapping blocks of size `blockSize x blockSize`\n *\n *  - The width the output tensor is `inputWidth * blockSize`, whereas the\n * height is `inputHeight * blockSize`\n *\n *  - The Y, X coordinates within each block of the output image are determined\n * by the high order component of the input channel index\n *\n *  - The depth of the input tensor must be divisible by `blockSize *\n * blockSize`\n *\n * The `dataFormat` attr specifies the layout of the input and output tensors\n * with the following options: \"NHWC\": [ `batch, height, width, channels` ]\n * \"NCHW\": [ `batch, channels, height, width` ]\n *\n * ```js\n * const x = tf.tensor4d([1, 2, 3, 4], [1, 1, 1, 4]);\n * const blockSize = 2;\n * const dataFormat = \"NHWC\";\n *\n * tf.depthToSpace(x, blockSize, dataFormat).print();\n * ```\n *\n * @param x The input tensor of rank 4\n * @param blockSIze  An `int` that is `>= 2`. The size of the spatial block\n * @param dataFormat An optional string from: \"NHWC\", \"NCHW\". Defaults to \"NHWC\"\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction depthToSpace_(\n    x: Tensor4D|TensorLike4D, blockSize: number,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC'): Tensor4D {\n  const $x = convertToTensor(x, 'x', 'depthToSpace') as Tensor4D;\n\n  const inputHeight = (dataFormat === 'NHWC') ? $x.shape[1] : $x.shape[2];\n  const inputWidth = (dataFormat === 'NHWC') ? $x.shape[2] : $x.shape[3];\n  const inputDepth = (dataFormat === 'NHWC') ? $x.shape[3] : $x.shape[1];\n\n  util.assert(\n      inputHeight * blockSize >= 0,\n      () => `Negative dimension size caused by overflow when multiplying\n    ${inputHeight} and ${blockSize}  for depthToSpace with input shape\n    ${$x.shape}`);\n\n  util.assert(\n      inputWidth * blockSize >= 0,\n      () => `Negative dimension size caused by overflow when multiplying\n    ${inputWidth} and ${blockSize} for depthToSpace with input shape\n        ${$x.shape}`);\n\n  util.assert(\n      (inputDepth % (blockSize * blockSize) === 0),\n      () => `Dimension size must be evenly divisible by ${\n          blockSize * blockSize} but is ${\n          inputDepth} for depthToSpace with input shape ${$x.shape}`);\n\n  const inputs: DepthToSpaceInputs = {x: $x};\n  const attrs: DepthToSpaceAttrs = {blockSize, dataFormat};\n\n  return ENGINE.runKernel(\n      DepthToSpace, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n}\n\nexport const depthToSpace = op({depthToSpace_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {DepthwiseConv2dNative, DepthwiseConv2dNativeAttrs, DepthwiseConv2dNativeInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {ExplicitPadding} from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Depthwise 2D convolution.\n *\n * Given a 4D `input` array and a `filter` array of shape\n * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing\n * `inChannels` convolutional filters of depth 1, this op applies a\n * different filter to each input channel (expanding from 1 channel to\n * `channelMultiplier` channels for each), then concatenates the results\n * together. The output has `inChannels * channelMultiplier` channels.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)\n * for more details.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction depthwiseConv2d_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filter: Tensor4D|TensorLike,\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|ExplicitPadding,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dilations: [number, number]|number = [1, 1],\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'depthwiseConv2d');\n  const $filter = convertToTensor(filter, 'filter', 'depthwiseConv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in depthwiseConv2d: input must be rank 4, but got ` +\n          `rank ${x4D.rank}.`);\n  util.assert(\n      $filter.rank === 4,\n      () => `Error in depthwiseConv2d: filter must be rank 4, but got rank ` +\n          `${$filter.rank}.`);\n  util.assert(\n      x4D.shape[3] === $filter.shape[2],\n      () => `Error in depthwiseConv2d: number of input channels ` +\n          `(${x4D.shape[3]}) must match the inChannels dimension in ` +\n          `filter ${$filter.shape[2]}.`);\n\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in depthwiseConv2d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inputs: DepthwiseConv2dNativeInputs = {x: x4D, filter: $filter};\n  const attrs: DepthwiseConv2dNativeAttrs =\n      {strides, pad, dataFormat, dilations, dimRoundingMode};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  DepthwiseConv2dNative, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const depthwiseConv2d = op({depthwiseConv2d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Diag, DiagInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\n\nimport {op} from './operation';\n\n/**\n * Returns a diagonal tensor with a given diagonal values.\n *\n * Given a diagonal, this operation returns a tensor with the diagonal and\n * everything else padded with zeros.\n *\n * Assume the input has dimensions `[D1,..., Dk]`, then the output is a tensor\n * of rank 2k with dimensions `[D1,..., Dk, D1,..., Dk]`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * tf.diag(x).print()\n * ```\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 6, 8], [4, 2])\n *\n * tf.diag(x).print()\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction diag_(x: Tensor): Tensor {\n  const $x = convertToTensor(x, 'x', 'diag');\n\n  const inputs: DiagInputs = {x: $x};\n\n  return ENGINE.runKernel(Diag, inputs as {} as NamedTensorMap);\n}\n\nexport const diag = op({diag_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Dilation2D, Dilation2DAttrs, Dilation2DInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the grayscale dilation over the input `x`.\n *\n * @param x The input tensor, rank 3 or rank 4 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filter The filter tensor, rank 3, of shape\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat Specify the data format of the input and output data.\n *      Defaults to 'NHWC'. Only 'NHWC' is currently supported. With the\n *      default format \"NHWC\", the data is stored in the order of: [batch,\n *      height, width, channels].\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     for atrous morphological dilation. Defaults to `[1, 1]`. If `dilations`\n *     is a single number, then `dilationHeight == dilationWidth`. If it is\n *     greater than 1, then all values of `strides` must be 1.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction dilation2d_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filter: Tensor3D|TensorLike,\n    strides: [number, number]|number, pad: 'valid'|'same',\n    dilations: [number, number]|number = [1, 1],\n    dataFormat: 'NHWC' = 'NHWC'): T {\n  const $x = convertToTensor(x, 'x', 'dilation2d');\n  const $filter = convertToTensor(filter, 'filter', 'dilation2d');\n\n  util.assert(\n      $x.rank === 3 || $x.rank === 4,\n      () => `Error in dilation2d: input must be rank 3 or 4, but got rank ` +\n          `${$x.rank}.`);\n  util.assert(\n      $filter.rank === 3,\n      () => `Error in dilation2d: filter must be rank 3, but got rank ` +\n          `${$filter.rank}.`);\n  util.assert(\n      dataFormat === 'NHWC',\n      () => `Error in dilation2d: Only NHWC is currently supported, ` +\n          `but got dataFormat of ${dataFormat}`);\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n    reshapedTo4D = true;\n  }\n\n  const inputs: Dilation2DInputs = {x: x4D, filter: $filter};\n  const attrs: Dilation2DAttrs = {strides, pad, dilations};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  Dilation2D, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n\n  return res;\n}\n\nexport const dilation2d = op({dilation2d_});\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Returns the dimensions in the input shape that are broadcasted to\n * produce the provided output shape.\n *\n * The returned dimensions are 0-indexed and sorted. An example:\n * inShape = [4, 1, 3]\n * outShape = [5, 4, 3, 3]\n * result = [1]. Dimension 1 (2nd dimension of input) gets broadcasted 1 => 3.\n */\nexport function getBroadcastDims(\n    inShape: number[], outShape: number[]): number[] {\n  const inRank = inShape.length;\n  const dims: number[] = [];\n  for (let i = 0; i < inRank; i++) {\n    const dim = inRank - 1 - i;\n    const a = inShape[dim] || 1;\n    const b = outShape[outShape.length - 1 - i] || 1;\n    if (b > 1 && a === 1) {\n      dims.unshift(dim);\n    }\n  }\n  return dims;\n}\n\n/**\n * Returns the axes in the output space that should be reduced to produce\n * the input space.\n */\nexport function getReductionAxes(\n    inShape: number[], outShape: number[]): number[] {\n  const result: number[] = [];\n  for (let i = 0; i < outShape.length; i++) {\n    const inDim = inShape[inShape.length - i - 1];\n    const outAxis = outShape.length - i - 1;\n    const outDim = outShape[outAxis];\n    if (inDim == null || (inDim === 1 && outDim > 1)) {\n      result.unshift(outAxis);\n    }\n  }\n  return result;\n}\n\nexport function assertAndGetBroadcastShape(\n    shapeA: number[], shapeB: number[]): number[] {\n  const result: number[] = [];\n  const l = Math.max(shapeA.length, shapeB.length);\n\n  for (let i = 0; i < l; i++) {\n    let a = shapeA[shapeA.length - i - 1];\n    if (a == null) {\n      a = 1;\n    }\n    let b = shapeB[shapeB.length - i - 1];\n    if (b == null) {\n      b = 1;\n    }\n    if (a === 1) {\n      result.unshift(b);\n    } else if (b === 1) {\n      result.unshift(a);\n    } else if (a !== b) {\n      const errMsg = `Operands could not be broadcast together with shapes ` +\n          `${shapeA} and ${shapeB}.`;\n      throw Error(errMsg);\n    } else {\n      result.unshift(a);\n    }\n  }\n  return result;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Equal, EqualInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of (a == b) element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.equal(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction equal_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'equal', 'string_or_numeric');\n  let $b = convertToTensor(b, 'b', 'equal', 'string_or_numeric');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: EqualInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Equal, inputs as {} as NamedTensorMap);\n}\n\nexport const equal = op({equal_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Select, SelectInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {broadcastTo} from './broadcast_to';\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the elements, either `a` or `b` depending on the `condition`.\n *\n * If the condition is true, select from `a`, otherwise select from `b`.\n *\n * ```js\n * const cond = tf.tensor1d([false, false, true], 'bool');\n * const a = tf.tensor1d([1 , 2, 3]);\n * const b = tf.tensor1d([-1, -2, -3]);\n *\n * a.where(cond, b).print();\n * ```\n *\n * @param condition The input condition. Must be of dtype bool.\n * @param a If `condition` is rank 1, `a` may have a higher rank but\n *     its first dimension must match the size of `condition`.\n * @param b A tensor with the same dtype as `a` and with shape that is\n *     compatible with `a`.\n * @return A tensor with same dtype as `a` and `b`, and shape that is\n *     broadcastable from `a` and `b`.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction where_<T extends Tensor>(\n    condition: Tensor|TensorLike, a: T|TensorLike, b: T|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'where');\n  const $b = convertToTensor(b, 'b', 'where');\n  const $condition = convertToTensor(condition, 'condition', 'where', 'bool');\n  // TODO: move this logic to forward function when the broadcastTo op is\n  // implemented in WASM.\n  // Find the broadcastable shape for $condition, $a, and $b.\n  const broadcastShape = assertAndGetBroadcastShape(\n      assertAndGetBroadcastShape($condition.shape, $a.shape), $b.shape);\n  const $broadcastedCondition = broadcastTo($condition, broadcastShape);\n  const $broadcastedA = broadcastTo($a, broadcastShape);\n  const $broadcastedB = broadcastTo($b, broadcastShape);\n\n  const inputs: SelectInputs = {\n    condition: $broadcastedCondition,\n    t: $broadcastedA,\n    e: $broadcastedB\n  };\n  return ENGINE.runKernel(Select, inputs as {} as NamedTensorMap);\n}\n\nexport const where = op({where_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {ZerosLike, ZerosLikeInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Creates a `tf.Tensor` with all elements set to 0 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.zerosLike(x).print();\n * ```\n *\n * @param x The tensor of required shape.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction zerosLike_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'zerosLike');\n  const inputs: ZerosLikeInputs = {x: $x};\n  return ENGINE.runKernel(ZerosLike, inputs as {} as NamedTensorMap);\n}\nexport const zerosLike = op({zerosLike_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {div} from './div';\nimport {equal} from './equal';\nimport {op} from './operation';\nimport {where} from './where';\nimport {zerosLike} from './zeros_like';\n\n/**\n * Divides two `tf.Tensor`s element-wise, A / B. Supports broadcasting. Return 0\n * if denominator is 0.\n *\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 9, 16]);\n * const b = tf.tensor1d([1, 2, 3, 4]);\n * const c = tf.tensor1d([0, 0, 0, 0]);\n *\n * a.divNoNan(b).print();  // or tf.divNoNan(a, b)\n * a.divNoNan(c).print();  // or tf.divNoNan(a, c)\n * ```\n *\n * ```js\n * // Broadcast div a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(2);\n * const c = tf.scalar(0);\n *\n * a.divNoNan(b).print();  // or tf.divNoNan(a, b)\n * a.divNoNan(c).print();  // or tf.divNoNan(a, c)\n * ```\n *\n * @param a The first tensor as the numerator.\n * @param b The second tensor as the denominator. Must have the same dtype as\n * `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction divNoNan_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  // TODO: Make this into its own kernel.\n  let $a = convertToTensor(a, 'a', 'div');\n  let $b = convertToTensor(b, 'b', 'div');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const divResult = div($a, $b);\n  const zeros = zerosLike(divResult);\n  const bEqualsZero = equal($b, zeros);\n  return where(bEqualsZero, zeros, divResult) as T;\n}\n\nexport const divNoNan = op({divNoNan_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor,} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {matMul} from './mat_mul';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the dot product of two matrices and/or vectors, `t1` and `t2`.\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n * const b = tf.tensor2d([[1, 2], [3, 4]]);\n * const c = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);\n *\n * a.dot(b).print();  // or tf.dot(a, b)\n * b.dot(a).print();\n * b.dot(c).print();\n * ```\n * @param t1 The first tensor in the dot operation.\n * @param t2 The second tensor in the dot operation.\n *\n * @doc {heading: 'Operations', subheading: 'Matrices'}\n */\nfunction dot_(t1: Tensor|TensorLike, t2: Tensor|TensorLike): Tensor {\n  const $t1 = convertToTensor(t1, 't1', 'dot');\n  const $t2 = convertToTensor(t2, 't2', 'dot');\n\n  util.assert(\n      ($t1.rank === 1 || $t1.rank === 2) && ($t2.rank === 1 || $t2.rank === 2),\n      () => `Error in dot: inputs must all be rank 1 or 2, but got ranks ` +\n          `${$t1.rank} and ${$t2.rank}.`);\n\n  const t1Inner = ($t1.rank === 1 ? $t1.size : $t1.shape[1]);\n  const t2Inner = ($t2.rank === 1 ? $t2.size : $t2.shape[0]);\n\n  util.assert(\n      t1Inner === t2Inner,\n      () => `Error in dot: inner dimensions of inputs must match, but got ` +\n          `${t1Inner} and ${t2Inner}.`);\n\n  if ($t1.rank === 1 && $t2.rank === 1) {\n    const t12D = reshape($t1, [1, -1]);\n    const t22D = reshape($t2, [-1, 1]);\n    const t1t2 = matMul(t12D, t22D);\n    return reshape(t1t2, []);\n  } else if ($t1.rank === 1 && $t2.rank === 2) {\n    const t12D = reshape($t1, [1, -1]);\n    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);\n    const t1t2 = matMul(t12D, t22D);\n    return reshape(t1t2, [t1t2.size]);\n  } else if ($t1.rank === 2 && $t2.rank === 1) {\n    const t22D = reshape($t2, [-1, 1]);\n    const t1t2 = matMul($t1, t22D);\n    return reshape(t1t2, [t1t2.size]);\n  } else {\n    const t22D = reshape($t2, [$t2.shape[0], $t2.shape[1]]);\n    const t1t2 = matMul($t1, t22D);\n    return t1t2;\n  }\n}\n\nexport const dot = op({dot_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Einsum, EinsumAttrs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\n\nimport {op} from './operation';\n\n/**\n * Tensor contraction over specified indices and outer product.\n *\n * `einsum` allows defining Tensors by defining their element-wise computation.\n * This computation is based on\n * [Einstein summation](https://en.wikipedia.org/wiki/Einstein_notation).\n *\n * Some special cases include:\n *\n * Matrix multiplication:\n * ```js\n * const x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);\n * const y = tf.tensor2d([[0, 1], [2, 3], [4, 5]]);\n * x.print();\n * y.print();\n * tf.einsum('ij,jk->ik', x, y).print();\n * ```\n *\n * Dot product:\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n * const y = tf.tensor1d([0, 1, 2]);\n * x.print();\n * y.print();\n * tf.einsum('i,i->', x, y).print();\n * ```\n *\n * Batch dot product:\n * ```js\n * const x = tf.tensor2d([[1, 2, 3], [4, 5, 6]]);\n * const y = tf.tensor2d([[0, 1, 2], [3, 4, 5]]);\n * x.print();\n * y.print();\n * tf.einsum('bi,bi->b', x, y).print();\n * ```\n *\n * Outer prouduct:\n * ```js\n * const x = tf.tensor1d([1, 3, 5]);\n * const y = tf.tensor1d([2, 4, 6]);\n * x.print();\n * y.print();\n * tf.einsum('i,j->ij', x, y).print();\n * ```\n *\n * Matrix transpose:\n * ```js\n * const x = tf.tensor2d([[1, 2], [3, 4]]);\n * x.print();\n * tf.einsum('ij->ji', x).print();\n * ```\n *\n * Batch matrix transpose:\n * ```js\n * const x = tf.tensor3d([[[1, 2], [3, 4]], [[-1, -2], [-3, -4]]]);\n * x.print();\n * tf.einsum('bij->bji', x).print();\n * ```\n *\n * Limitations:\n *\n * This implementation of einsum has the following limitations:\n *\n * - Does not support >2 input tensors.\n * - Does not support duplicate axes for any given input tensor. E.g., equation\n *   'ii->' is not suppoted.\n * - The `...` notation is not supported.\n *\n * @param equation a string describing the contraction, in the same format as\n * [numpy.einsum](https://numpy.org/doc/stable/reference/generated/numpy.einsum.html).\n * @param tensors the input(s) to contract (each one a Tensor), whose shapes\n *     should be consistent with equation.\n * @returns The output tensor.\n *\n * @doc {heading: 'Tensors', subheading: 'Matrices'}\n */\nexport function einsum_(equation: string, ...tensors: Tensor[]): Tensor {\n  const $tensors =\n      tensors.map((t, i) => convertToTensor(t, `tensors${i}`, 'einsum'));\n  const attrs: EinsumAttrs = {equation};\n  return ENGINE.runKernel(\n      Einsum, $tensors as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const einsum = op({einsum_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Elu, EluInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes exponential linear element-wise: `x > 0 ? x : (e ^ x) - 1`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 1, -3, 2]);\n *\n * x.elu().print();  // or tf.elu(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction elu_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'elu');\n\n  const inputs: EluInputs = {x: $x};\n\n  return ENGINE.runKernel(Elu, inputs as {} as NamedTensorMap);\n}\n\nexport const elu = op({elu_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Erf, ErfInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {cast} from './cast';\nimport {op} from './operation';\n\n/**\n * Computes gause error function of the input `tf.Tensor` element-wise:\n * `erf(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, .1, -.1, .7]);\n *\n * x.erf().print(); // or tf.erf(x);\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction erf_<T extends Tensor>(x: T|TensorLike): T {\n  let $x = convertToTensor(x, 'x', 'erf');\n  util.assert(\n      $x.dtype === 'int32' || $x.dtype === 'float32',\n      () => 'Input dtype must be `int32` or `float32`.');\n\n  if ($x.dtype === 'int32') {\n    $x = cast($x, 'float32');\n  }\n\n  const inputs: ErfInputs = {x: $x};\n  return ENGINE.runKernel(Erf, inputs as {} as NamedTensorMap);\n}\nexport const erf = op({erf_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Exp, ExpInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes exponential of the input `tf.Tensor` element-wise. `e ^ x`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, -3]);\n *\n * x.exp().print();  // or tf.exp(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction exp_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'exp');\n\n  const inputs: ExpInputs = {x: $x};\n  return ENGINE.runKernel(Exp, inputs as {} as NamedTensorMap);\n}\nexport const exp = op({exp_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {ExpandDims, ExpandDimsAttrs, ExpandDimsInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Returns a `tf.Tensor` that has expanded rank, by inserting a dimension\n * into the tensor's shape.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const axis = 1;\n * x.expandDims(axis).print();\n * ```\n *\n * @param x The input tensor whose dimensions to be expanded.\n * @param axis The dimension index at which to insert shape of `1`. Defaults\n *     to 0 (the first dimension).\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction expandDims_<T extends Tensor>(x: Tensor|TensorLike, axis = 0): T {\n  const $x = convertToTensor(x, 'x', 'expandDims', 'string_or_numeric');\n\n  util.assert(axis <= $x.rank, () => 'Axis must be <= rank of the tensor');\n\n  const inputs: ExpandDimsInputs = {input: $x};\n  const attrs: ExpandDimsAttrs = {dim: axis};\n\n  return ENGINE.runKernel(\n      ExpandDims, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const expandDims = op({expandDims_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Expm1, Expm1Inputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes exponential of the input `tf.Tensor` minus one element-wise.\n * `e ^ x - 1`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, -3]);\n *\n * x.expm1().print();  // or tf.expm1(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction expm1_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'expm1');\n\n  const inputs: Expm1Inputs = {x: $x};\n  return ENGINE.runKernel(Expm1, inputs as {} as NamedTensorMap);\n}\nexport const expm1 = op({expm1_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tile, TileAttrs, TileInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Construct a tensor by repeating it the number of times given by reps.\n *\n * This operation creates a new tensor by replicating `input` `reps`\n * times. The output tensor's i'th dimension has `input.shape[i] *\n * reps[i]` elements, and the values of `input` are replicated\n * `reps[i]` times along the i'th dimension. For example, tiling\n * `[a, b, c, d]` by `[2]` produces `[a, b, c, d, a, b, c, d]`.\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n *\n * a.tile([2]).print();    // or a.tile([2])\n * ```\n *\n * ```js\n * const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * a.tile([1, 2]).print();  // or a.tile([1, 2])\n * ```\n * @param x The tensor to tile.\n * @param reps Determines the number of replications per dimension.\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction tile_<T extends Tensor>(x: T|TensorLike, reps: number[]): T {\n  const $x = convertToTensor(x, 'x', 'tile', 'string_or_numeric');\n  util.assert(\n      $x.rank === reps.length,\n      () => `Error in transpose: rank of input ${$x.rank} ` +\n          `must match length of reps ${reps}.`);\n\n  const inputs: TileInputs = {x: $x};\n  const attrs: TileAttrs = {reps};\n\n  return ENGINE.runKernel(\n      Tile, inputs as unknown as NamedTensorMap,\n      attrs as unknown as NamedAttrMap);\n}\n\nexport const tile = op({tile_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D} from '../tensor';\nimport {DataType} from '../types';\n\nimport {buffer} from './buffer';\nimport {expandDims} from './expand_dims';\nimport {op} from './operation';\nimport {reshape} from './reshape';\nimport {tile} from './tile';\n\n/**\n * Create an identity matrix.\n *\n * @param numRows Number of rows.\n * @param numColumns Number of columns. Defaults to `numRows`.\n * @param batchShape If provided, will add the batch shape to the beginning\n *   of the shape of the returned `tf.Tensor` by repeating the identity\n *   matrix.\n * @param dtype Data type.\n * @returns Identity matrix of the specified size and data type, possibly\n *   with batch repetition if `batchShape` is specified.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction eye_(\n    numRows: number, numColumns?: number,\n    batchShape?:\n        [\n          number\n        ]|[number,\n           number]|[number, number, number]|[number, number, number, number],\n    dtype: DataType = 'float32'): Tensor2D {\n  if (numColumns == null) {\n    numColumns = numRows;\n  }\n  const buff = buffer([numRows, numColumns], dtype);\n  const n = numRows <= numColumns ? numRows : numColumns;\n  for (let i = 0; i < n; ++i) {\n    buff.set(1, i, i);\n  }\n  const out: Tensor2D = reshape(buff.toTensor(), [numRows, numColumns]);\n  if (batchShape == null) {\n    return out;\n  } else {\n    if (batchShape.length === 1) {\n      return tile(expandDims(out, 0), [batchShape[0], 1, 1]) as Tensor2D;\n    } else if (batchShape.length === 2) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n      return tile(\n                 expandDims(expandDims(out, 0), 0),\n                 [batchShape[0], batchShape[1], 1, 1]) as Tensor2D;\n    } else if (batchShape.length === 3) {\n      // tslint:disable-next-line:no-unnecessary-type-assertion\n      return tile(expandDims(expandDims(expandDims(out, 0), 0), 0), [\n               batchShape[0], batchShape[1], batchShape[2], 1, 1\n             ]) as Tensor2D;\n    } else {\n      throw new Error(\n          `eye() currently supports only 1D and 2D ` +\n          // tslint:disable-next-line:no-any\n          `batchShapes, but received ${(batchShape as any).length}D.`);\n    }\n  }\n}\n\nexport const eye = op({eye_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Fill, FillAttrs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\n\n/**\n * Creates a `tf.Tensor` filled with a scalar value.\n *\n * ```js\n * tf.fill([2, 2], 4).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param value The scalar value to fill the tensor with.\n * @param dtype The type of an element in the resulting tensor. Defaults to\n * 'float'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction fill<R extends Rank>(\n    shape: ShapeMap[R], value: number|string, dtype?: DataType): Tensor<R> {\n  const attrs: FillAttrs = {shape, value, dtype};\n\n  return ENGINE.runKernel(Fill, {}, attrs as {} as NamedAttrMap);\n}\n\nexport {fill};\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Floor, FloorInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes floor of input `tf.Tensor` element-wise: `floor(x)`.\n *\n * ```js\n * const x = tf.tensor1d([.6, 1.1, -3.3]);\n *\n * x.floor().print();  // or tf.floor(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction floor_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'floor');\n\n  const inputs: FloorInputs = {x: $x};\n  return ENGINE.runKernel(Floor, inputs as {} as NamedTensorMap);\n}\nexport const floor = op({floor_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {GatherV2, GatherV2Attrs, GatherV2Inputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Gather slices from tensor `x`'s axis `axis` according to `indices`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const indices = tf.tensor1d([1, 3, 3], 'int32');\n *\n * x.gather(indices).print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const indices = tf.tensor1d([1, 1, 0], 'int32');\n *\n * x.gather(indices).print();\n * ```\n * @param x The input tensor whose slices to be gathered.\n * @param indices The indices of the values to extract.\n * @param axis The axis over which to select values. Defaults to 0.\n * @param batchDims Optional. The number of batch dimensions. It must be less\n *     than or equal to rank(indices). Defaults to 0.\n *     The output tensor will have shape of\n *     `x.shape[:axis] + indices.shape[batchDims:] + x.shape[axis + 1:]`\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction gather_<T extends Tensor>(\n    x: T|TensorLike, indices: Tensor|TensorLike, axis = 0, batchDims = 0): T {\n  const $x = convertToTensor(x, 'x', 'gather');\n  const $indices = convertToTensor(indices, 'indices', 'gather', 'int32');\n\n  const inputs: GatherV2Inputs = {x: $x, indices: $indices};\n  const attrs: GatherV2Attrs = {axis, batchDims};\n\n  return ENGINE.runKernel(\n      GatherV2, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const gather = op({gather_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Greater, GreaterInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of (a > b) element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.greater(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction greater_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'greater', 'string_or_numeric');\n  let $b = convertToTensor(b, 'b', 'greater', 'string_or_numeric');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: GreaterInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Greater, inputs as {} as NamedTensorMap);\n}\n\nexport const greater = op({greater_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {GreaterEqual, GreaterEqualInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of (a >= b) element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.greaterEqual(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction greaterEqual_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'greaterEqual', 'string_or_numeric');\n  let $b = convertToTensor(b, 'b', 'greaterEqual', 'string_or_numeric');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: GreaterEqualInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(GreaterEqual, inputs as {} as NamedTensorMap);\n}\n\nexport const greaterEqual = op({greaterEqual_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Imag, ImagInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n/**\n * Returns the imaginary part of a complex (or real) tensor.\n *\n * Given a tensor input, this operation returns a tensor of type float that is\n * the imaginary part of each element in input considered as a complex number.\n * If input is real, a tensor of all zeros is returned.\n *\n * ```js\n * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);\n * tf.imag(x).print();\n * ```\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction imag_<T extends Tensor>(input: T|TensorLike): T {\n  const $input = convertToTensor(input, 'input', 'imag');\n\n  const inputs: ImagInputs = {input: $input};\n  return ENGINE.runKernel(Imag, inputs as {} as NamedTensorMap);\n}\n\nexport const imag = op({imag_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {IsFinite, IsFiniteInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Returns which elements of x are finite.\n *\n * ```js\n * const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);\n *\n * x.isFinite().print();  // or tf.isNaN(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction isFinite_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'isFinite');\n\n  const inputs: IsFiniteInputs = {x: $x};\n\n  return ENGINE.runKernel(IsFinite, inputs as {} as NamedTensorMap);\n}\nexport const isFinite = op({isFinite_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {IsInf, IsInfInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Returns which elements of x are Infinity or -Infinity.\n *\n * ```js\n * const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);\n *\n * x.isInf().print();  // or tf.isNaN(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction isInf_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'isInf');\n\n  const inputs: IsInfInputs = {x: $x};\n\n  return ENGINE.runKernel(IsInf, inputs as {} as NamedTensorMap);\n}\nexport const isInf = op({isInf_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {IsNan, IsNanInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * RReturns which elements of x are NaN.\n *\n * ```js\n * const x = tf.tensor1d([NaN, Infinity, -Infinity, 0, 1]);\n *\n * x.isNaN().print();  // or tf.isNaN(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction isNaN_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'isNaN');\n  const inputs: IsNanInputs = {x: $x};\n\n  return ENGINE.runKernel(IsNan, inputs as {} as NamedTensorMap);\n}\nexport const isNaN = op({isNaN_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {LeakyRelu, LeakyReluAttrs, LeakyReluInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes leaky rectified linear element-wise.\n *\n * See\n * [http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf](\n *     http://web.stanford.edu/~awni/papers/relu_hybrid_icml2013_final.pdf)\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.leakyRelu(0.1).print();  // or tf.leakyRelu(x, 0.1)\n * ```\n * @param x The input tensor.\n * @param alpha The scaling factor for negative values, defaults to 0.2.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction leakyRelu_<T extends Tensor>(x: T|TensorLike, alpha = 0.2): T {\n  const $x = convertToTensor(x, 'x', 'leakyRelu');\n\n  const inputs: LeakyReluInputs = {x: $x};\n  const attrs: LeakyReluAttrs = {alpha};\n\n  return ENGINE.runKernel(\n      LeakyRelu, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const leakyRelu = op({leakyRelu_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Less, LessInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of (a < b) element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.less(b).print();\n * ```\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction less_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'less', 'string_or_numeric');\n  let $b = convertToTensor(b, 'b', 'less', 'string_or_numeric');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: LessInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Less, inputs as {} as NamedTensorMap);\n}\n\nexport const less = op({less_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {LessEqual, LessEqualInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of (a <= b) element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([2, 2, 2]);\n *\n * a.lessEqual(b).print();\n * ```\n *\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction lessEqual_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'lessEqual', 'string_or_numeric');\n  let $b = convertToTensor(b, 'b', 'lessEqual', 'string_or_numeric');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: LessEqualInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(LessEqual, inputs as {} as NamedTensorMap);\n}\n\nexport const lessEqual = op({lessEqual_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {LinSpace, LinSpaceAttrs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor1D} from '../tensor';\n\n/**\n * Return an evenly spaced sequence of numbers over the given interval.\n *\n * ```js\n * tf.linspace(0, 9, 10).print();\n * ```\n * @param start The start value of the sequence.\n * @param stop The end value of the sequence.\n * @param num The number of values to generate.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function linspace(start: number, stop: number, num: number): Tensor1D {\n  if (num <= 0) {\n    throw new Error('The number of values should be positive.');\n  }\n\n  const attrs: LinSpaceAttrs = {start, stop, num};\n  return ENGINE.runKernel(LinSpace, {}, attrs as {} as NamedAttrMap);\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {LRN, LRNAttrs, LRNInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Normalizes the activation of a local neighborhood across or within\n * channels.\n *\n * @param x The input tensor. The 4-D input tensor is treated as a 3-D array\n *     of 1D vectors (along the last dimension), and each vector is\n *     normalized independently.\n * @param depthRadius The number of adjacent channels in the 1D normalization\n *     window.\n * @param bias A constant bias term for the basis.\n * @param alpha A scale factor, usually positive.\n * @param beta An exponent.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction localResponseNormalization_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, depthRadius = 5, bias = 1, alpha = 1, beta = 0.5): T {\n  const $x = convertToTensor(x, 'x', 'localResponseNormalization');\n  util.assert(\n      $x.rank === 4 || $x.rank === 3,\n      () => `Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${$x.rank}.`);\n  util.assert(\n      util.isInt(depthRadius),\n      () => `Error in localResponseNormalization: depthRadius must be an ` +\n          `integer but got depthRadius ${depthRadius}.`);\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n\n  const inputs: LRNInputs = {x: x4D};\n\n  const attrs: LRNAttrs = {depthRadius, bias, alpha, beta};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  LRN, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  } else {\n    return res;\n  }\n}\n\nexport const localResponseNormalization = op({localResponseNormalization_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Log, LogInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes natural logarithm of the input `tf.Tensor` element-wise: `ln(x)`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, Math.E]);\n *\n * x.log().print();  // or tf.log(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction log_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'log');\n\n  const inputs: LogInputs = {x: $x};\n  return ENGINE.runKernel(Log, inputs as {} as NamedTensorMap);\n}\nexport const log = op({log_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Log1p, Log1pInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes natural logarithm of the input `tf.Tensor` plus one\n * element-wise: `ln(1 + x)`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, Math.E - 1]);\n *\n * x.log1p().print();  // or tf.log1p(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction log1p_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'log1p');\n\n  const inputs: Log1pInputs = {x: $x};\n  return ENGINE.runKernel(Log1p, inputs as {} as NamedTensorMap);\n}\nexport const log1p = op({log1p_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {CustomGradientFunc, ENGINE} from './engine';\nimport {Scalar, Tensor, Variable} from './tensor';\nimport {NamedTensorMap} from './tensor_types';\nimport {convertToTensor, convertToTensorArray} from './tensor_util_env';\nimport {TensorLike} from './types';\nimport * as util from './util';\n\n/**\n * Provided `f(x)`, returns another function `g(x, dy?)`, which gives the\n * gradient of `f(x)` with respect to `x`.\n *\n * If `dy` is provided, the gradient of `f(x).mul(dy).sum()` with respect to\n * `x` is computed instead. `f(x)` must take a single tensor `x` and return a\n * single tensor `y`. If `f()` takes multiple inputs, use `tf.grads` instead.\n *\n * ```js\n * // f(x) = x ^ 2\n * const f = x => x.square();\n * // f'(x) = 2x\n * const g = tf.grad(f);\n *\n * const x = tf.tensor1d([2, 3]);\n * g(x).print();\n * ```\n *\n * ```js\n * // f(x) = x ^ 3\n * const f = x => x.pow(tf.scalar(3, 'int32'));\n * // f'(x) = 3x ^ 2\n * const g = tf.grad(f);\n * // f''(x) = 6x\n * const gg = tf.grad(g);\n *\n * const x = tf.tensor1d([2, 3]);\n * gg(x).print();\n * ```\n *\n * @param f The function f(x), to compute gradient for.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction grad(f: (x: Tensor) => Tensor): (\n    x: TensorLike|Tensor, dy?: TensorLike|Tensor) => Tensor {\n  util.assert(\n      util.isFunction(f), () => 'The f passed in grad(f) must be a function');\n  return (x: TensorLike|Tensor, dy?: TensorLike|Tensor): Tensor => {\n    // x can be of any dtype, thus null as the last argument.\n    const $x = convertToTensor(x, 'x', 'tf.grad', 'string_or_numeric');\n    const $dy: Tensor =\n        (dy != null) ? convertToTensor(dy, 'dy', 'tf.grad') : null;\n    return ENGINE.tidy(() => {\n      const {value, grads} = ENGINE.gradients(() => f($x), [$x], $dy);\n      if ($dy != null) {\n        util.assertShapesMatch(\n            value.shape, $dy.shape,\n            'The shape of dy passed in grad(f)(x, dy) must match the shape ' +\n                'returned by f(x)');\n      }\n      checkGrads(grads);\n      return grads[0];\n    });\n  };\n}\n\n/**\n * Provided `f(x1, x2,...)`, returns another function `g([x1, x2,...], dy?)`,\n * which gives an array of gradients of `f()` with respect to each input\n * [`x1`,`x2`,...].\n *\n * If `dy` is passed when calling `g()`, the gradient of\n * `f(x1,...).mul(dy).sum()` with respect to each input is computed instead.\n * The provided `f` must take one or more tensors and return a single tensor\n * `y`. If `f()` takes a single input, we recommend using `tf.grad` instead.\n *\n * ```js\n * // f(a, b) = a * b\n * const f = (a, b) => a.mul(b);\n * // df / da = b, df / db = a\n * const g = tf.grads(f);\n *\n * const a = tf.tensor1d([2, 3]);\n * const b = tf.tensor1d([-2, -3]);\n * const [da, db] = g([a, b]);\n * console.log('da');\n * da.print();\n * console.log('db');\n * db.print();\n * ```\n *\n * @param f The function `f(x1, x2,...)` to compute gradients for.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction grads(f: (...args: Tensor[]) => Tensor): (\n    args: Array<Tensor|TensorLike>, dy?: Tensor|TensorLike) => Tensor[] {\n  util.assert(\n      util.isFunction(f), () => 'The f passed in grads(f) must be a function');\n  return (args: Array<Tensor|TensorLike>, dy?: Tensor|TensorLike): Tensor[] => {\n    util.assert(\n        Array.isArray(args),\n        () => 'The args passed in grads(f)(args) must be an array ' +\n            'of `Tensor`s or `TensorLike`s');\n    // args can be of any dtype, thus null as the last argument.\n    const $args =\n        convertToTensorArray(args, 'args', 'tf.grads', 'string_or_numeric');\n    const $dy: Tensor =\n        (dy != null) ? convertToTensor(dy, 'dy', 'tf.grads') : null;\n    return ENGINE.tidy(() => {\n      const {value, grads} = ENGINE.gradients(() => f(...$args), $args, $dy);\n      if ($dy != null) {\n        util.assertShapesMatch(\n            value.shape, $dy.shape,\n            'The shape of dy passed in grads(f)([x1,...], dy) must ' +\n                'match the shape returned by f([x1,...])');\n      }\n      checkGrads(grads);\n      return grads;\n    });\n  };\n}\n\n/**\n * Like `tf.grad`, but also returns the value of `f()`. Useful when `f()`\n * returns a metric you want to show.\n *\n * The result is a rich object with the following properties:\n * - grad: The gradient of `f(x)` w.r.t `x` (result of `tf.grad`).\n * - value: The value returned by `f(x)`.\n *\n * ```js\n * // f(x) = x ^ 2\n * const f = x => x.square();\n * // f'(x) = 2x\n * const g = tf.valueAndGrad(f);\n *\n * const x = tf.tensor1d([2, 3]);\n * const {value, grad} = g(x);\n *\n * console.log('value');\n * value.print();\n * console.log('grad');\n * grad.print();\n * ```\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction valueAndGrad<I extends Tensor, O extends Tensor>(f: (x: I) => O): (\n    x: I, dy?: O) => {\n  value: O;\n  grad: I;\n} {\n  util.assert(\n      util.isFunction(f),\n      () => 'The f passed in valueAndGrad(f) must be a function');\n  return (x: I, dy?: O) => {\n    util.assert(\n        x instanceof Tensor,\n        () => 'The x passed in valueAndGrad(f)(x) must be a tensor');\n    util.assert(\n        dy == null || dy instanceof Tensor,\n        () => 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor');\n    const {grads, value} = ENGINE.gradients(() => f(x), [x], dy);\n    checkGrads(grads);\n    return {grad: grads[0] as I, value};\n  };\n}\n\n/**\n * Like `tf.grads`, but returns also the value of `f()`. Useful when `f()`\n * returns a metric you want to show.\n *\n * The result is a rich object with the following properties:\n * - grads: The gradients of `f()` w.r.t each input (result of `tf.grads`).\n * - value: The value returned by `f(x)`.\n *\n * ```js\n * // f(a, b) = a * b\n * const f = (a, b) => a.mul(b);\n * // df/da = b, df/db = a\n * const g = tf.valueAndGrads(f);\n *\n * const a = tf.tensor1d([2, 3]);\n * const b = tf.tensor1d([-2, -3]);\n * const {value, grads} = g([a, b]);\n *\n * const [da, db] = grads;\n *\n * console.log('value');\n * value.print();\n *\n * console.log('da');\n * da.print();\n * console.log('db');\n * db.print();\n * ```\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction valueAndGrads<O extends Tensor>(f: (...args: Tensor[]) => O): (\n    args: Tensor[], dy?: O) => {\n  grads: Tensor[];\n  value: O;\n} {\n  util.assert(\n      util.isFunction(f),\n      () => 'The f passed in valueAndGrads(f) must be a function');\n  return (args: Tensor[], dy?: O) => {\n    util.assert(\n        Array.isArray(args) && args.every(arg => arg instanceof Tensor),\n        () => 'The args passed in valueAndGrads(f)(args) must be array of ' +\n            'tensors');\n    util.assert(\n        dy == null || dy instanceof Tensor,\n        () => 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor');\n    const res = ENGINE.gradients(() => f(...args), args, dy);\n    if (dy != null) {\n      util.assertShapesMatch(\n          res.value.shape, dy.shape,\n          'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must ' +\n              'match the shape returned by f([x1,...])');\n    }\n    checkGrads(res.grads);\n    return res;\n  };\n}\n\n/**\n * Computes and returns the gradient of f(x) with respect to the list of\n * trainable variables provided by `varList`. If no list is provided, it\n * defaults to all trainable variables.\n *\n * ```js\n * const a = tf.variable(tf.tensor1d([3, 4]));\n * const b = tf.variable(tf.tensor1d([5, 6]));\n * const x = tf.tensor1d([1, 2]);\n *\n * // f(a, b) = a * x ^ 2 + b * x\n * const f = () => a.mul(x.square()).add(b.mul(x)).sum();\n * // df/da = x ^ 2, df/db = x\n * const {value, grads} = tf.variableGrads(f);\n *\n * Object.keys(grads).forEach(varName => grads[varName].print());\n * ```\n *\n * @param f The function to execute. f() should return a scalar.\n * @param varList The list of variables to compute the gradients with respect\n *     to. Defaults to all trainable variables.\n * @returns An object with the following keys and values:\n *   - `value`: The value of the function `f`.\n *   - `grads`: A map from the names of the variables to the gradients.\n *     If the `varList` argument is provided explicitly and contains a subset of\n *     non-trainable variables, this map in the return value will contain keys\n *     that map the names of the non-trainable variables to `null`.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction variableGrads(f: () => Scalar, varList?: Variable[]):\n    {value: Scalar, grads: NamedTensorMap} {\n  util.assert(\n      util.isFunction(f),\n      () => 'The f passed in variableGrads(f) must be a function');\n  util.assert(\n      varList == null ||\n          Array.isArray(varList) && varList.every(v => v instanceof Variable),\n      () =>\n          'The varList passed in variableGrads(f, varList) must be an array ' +\n          'of variables');\n\n  const specifiedVarList = varList != null;\n  if (!specifiedVarList) {\n    // Get all of the trainable variables.\n    varList = [];\n    for (const varName in ENGINE.registeredVariables) {\n      varList.push(ENGINE.registeredVariables[varName]);\n    }\n  }\n\n  const specifiedNonTrainable: Variable[] =\n      specifiedVarList ? varList.filter(variable => !variable.trainable) : null;\n\n  // Prune non-trainable variables.\n  const originalVarCount = varList.length;\n  varList = varList.filter(variable => variable.trainable);\n  util.assert(\n      varList.length > 0,\n      () => `variableGrads() expects at least one of the input variables to ` +\n          `be trainable, but none of the ${originalVarCount} variables is ` +\n          `trainable.`);\n\n  const allowNoGradients = true;\n  const {value, grads} = ENGINE.gradients(f, varList, null, allowNoGradients);\n\n  util.assert(\n      grads.some(g => g != null),\n      () => 'Cannot find a connection between any variable and the result of ' +\n          'the loss function y=f(x). Please make sure the operations that ' +\n          'use variables are inside the function f passed to minimize().');\n  util.assert(\n      value.rank === 0,\n      () => `The f passed in variableGrads(f) must return a scalar, but it ` +\n          `returned a rank-${value.rank} tensor`);\n\n  const namedGrads: NamedTensorMap = {};\n  varList.forEach((v, i) => {\n    if (grads[i] != null) {\n      namedGrads[v.name] = grads[i];\n    }\n  });\n  if (specifiedNonTrainable != null) {\n    // If varList is explicitly provided and contains non-trainable values,\n    // add them to the returned gradients with `null` values.\n    specifiedNonTrainable.forEach(v => namedGrads[v.name] = null);\n  }\n  return {value, grads: namedGrads};\n}\n\n/**\n * Overrides the gradient computation of a function `f`.\n *\n * Takes a function\n * `f(...inputs, save) => {value: Tensor, gradFunc: (dy, saved) => Tensor[]}`\n * and returns another function `g(...inputs)` which takes the same inputs as\n * `f`. When called, `g` returns `f().value`. In backward mode, custom gradients\n * with respect to each input of `f` are computed using `f().gradFunc`.\n *\n * The `save` function passsed to `f` should be used for saving tensors needed\n * in the gradient. And the `saved` passed to the `gradFunc` is a\n * `NamedTensorMap`, which contains those saved tensor.\n *\n * ```js\n * const customOp = tf.customGrad((x, save) => {\n *   // Save x to make sure it's available later for the gradient.\n *   save([x]);\n *   // Override gradient of our custom x ^ 2 op to be dy * abs(x);\n *   return {\n *     value: x.square(),\n *     // Note `saved.x` which points to the `x` we saved earlier.\n *     gradFunc: (dy, saved) => [dy.mul(saved[0].abs())]\n *   };\n * });\n *\n * const x = tf.tensor1d([-1, -2, 3]);\n * const dx = tf.grad(x => customOp(x));\n *\n * console.log(`f(x):`);\n * customOp(x).print();\n * console.log(`f'(x):`);\n * dx(x).print();\n * ```\n *\n * @param f The function to evaluate in forward mode, which should return\n *     `{value: Tensor, gradFunc: (dy, saved) => Tensor[]}`, where `gradFunc`\n *     returns the custom gradients of `f` with respect to its inputs.\n *\n * @doc {heading: 'Training', subheading: 'Gradients'}\n */\nfunction customGrad<T extends Tensor>(f: CustomGradientFunc<T>):\n    (...args: Tensor[]) => T {\n  return ENGINE.customGrad(f);\n}\n\nfunction checkGrads(grads: Tensor[]) {\n  const numNullGradients = grads.filter(g => g == null).length;\n  if (numNullGradients > 0) {\n    throw new Error(\n        `Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.`);\n  }\n}\n\nexport {\n  customGrad,\n  variableGrads,\n  valueAndGrad,\n  valueAndGrads,\n  grad,\n  grads,\n};\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Neg, NegInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes `-1 * x` element-wise.\n *\n * ```js\n * const x = tf.tensor2d([1, 2, -2, 0], [2, 2]);\n *\n * x.neg().print();  // or tf.neg(x)\n * ```\n *\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction neg_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'neg');\n\n  const inputs: NegInputs = {x: $x};\n  return ENGINE.runKernel(Neg, inputs as {} as NamedTensorMap);\n}\nexport const neg = op({neg_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Softplus, SoftplusInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes softplus of the input `tf.Tensor` element-wise: `log(exp(x) + 1)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.softplus().print();  // or tf.softplus(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction softplus_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'softplus');\n\n  const inputs: SoftplusInputs = {x: $x};\n  return ENGINE.runKernel(Softplus, inputs as {} as NamedTensorMap);\n}\nexport const softplus = op({softplus_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {customGrad} from '../gradients';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {mul} from './mul';\nimport {neg} from './neg';\nimport {op} from './operation';\nimport {sigmoid} from './sigmoid';\nimport {softplus} from './softplus';\n\n/**\n * Computes log sigmoid of the input `tf.Tensor` element-wise:\n * `logSigmoid(x)`. For numerical stability, we use `-tf.softplus(-x)`.\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.logSigmoid().print();  // or tf.logSigmoid(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction logSigmoid_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'logSigmoid');\n\n  // Use a custom gradient to maintain previous implementation.\n  // There is no LogSigmoid kernel in TF so we can't use engine.runKernel\n  // directly\n  const customOp = customGrad((x: Tensor) => {\n    // TODO(yassogba) we can remove the chained softplus call here only\n    // after backends have modualrized softplus at which point we can call\n    // engine runKernel(..., Sotfplus, ...) directly.\n    const value = neg(softplus(neg(x)));\n\n    const gradFunc = (dy: T) => {\n      const derX = mul(dy, sigmoid(neg(x)));\n      return derX;\n    };\n    return {value, gradFunc};\n  });\n\n  return customOp($x) as T;\n}\nexport const logSigmoid = op({logSigmoid_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Max, MaxAttrs, MaxInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the maximum of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and an\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.max().print();  // or tf.max(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.max(axis).print();  // or tf.max(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction max_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'max');\n\n  const inputs: MaxInputs = {x: $x};\n  const attrs: MaxAttrs = {reductionIndices: axis, keepDims};\n\n  return ENGINE.runKernel(\n      Max, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const max = op({max_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Sub, SubInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Subtracts two `tf.Tensor`s element-wise, A - B. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([10, 20, 30, 40]);\n * const b = tf.tensor1d([1, 2, 3, 4]);\n *\n * a.sub(b).print();  // or tf.sub(a, b)\n * ```\n *\n * ```js\n * // Broadcast subtract a with b.\n * const a = tf.tensor1d([10, 20, 30, 40]);\n * const b = tf.scalar(5);\n *\n * a.sub(b).print();  // or tf.sub(a, b)\n * ```\n * @param a The first `tf.Tensor` to subtract from.\n * @param b The second `tf.Tensor` to be subtracted. Must have the same dtype as\n * `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction sub_<T extends Tensor>(a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'sub');\n  let $b = convertToTensor(b, 'b', 'sub');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const inputs: SubInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Sub, inputs as {} as NamedTensorMap);\n}\n\nexport const sub = op({sub_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Sum, SumAttrs, SumInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {cast} from './cast';\nimport {op} from './operation';\n\n/**\n * Computes the sum of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If axes has no entries, all dimensions are reduced, and a\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.sum().print();  // or tf.sum(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.sum(axis).print();  // or tf.sum(x, axis)\n * ```\n *\n * @param x The input tensor to compute the sum over. If the dtype is `bool`\n *   it will be converted to `int32` and the output dtype will be `int32`.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction sum_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'sum');\n  if ($x.dtype === 'bool') {\n    $x = cast($x, 'int32');\n  }\n\n  const inputs: SumInputs = {x: $x};\n  const attrs: SumAttrs = {axis, keepDims};\n\n  return ENGINE.runKernel(\n      Sum, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const sum = op({sum_});\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {customGrad} from '../gradients';\n\nimport {Tensor} from '../tensor';\nimport {GradSaveFunc} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {cast} from './cast';\nimport {exp} from './exp';\nimport {log} from './log';\nimport {max} from './max';\nimport {mul} from './mul';\nimport {op} from './operation';\nimport {sub} from './sub';\nimport {sum} from './sum';\n\n/**\n * Computes the log softmax.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n *\n * a.logSoftmax().print();  // or tf.logSoftmax(a)\n * ```\n *\n * ```js\n * const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);\n *\n * a.logSoftmax().print();  // or tf.logSoftmax(a)\n * ```\n *\n * @param logits The logits array.\n * @param axis The dimension softmax would be performed on. Defaults to `-1`\n *     which indicates the last dimension.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction logSoftmax_<T extends Tensor>(logits: T|TensorLike, axis = -1): T {\n  const $logits = convertToTensor(logits, 'logits', 'logSoftmax');\n\n  if (axis === -1) {\n    axis = $logits.rank - 1;\n  }\n  if (axis !== $logits.rank - 1) {\n    throw Error(\n        'Log Softmax along a non-last dimension is not yet supported. ' +\n        `Logits was rank ${$logits.rank} and axis was ${axis}`);\n  }\n\n  // const forward: ForwardFunc<Tensor> = (backend, save) => {\n  //   const keepDims = true;\n  //   const xMax = max(logits, axis, true);\n  //   const shifted = sub(logits, xMax);\n  //   const value =\n  //       sub(cast(shifted, 'float32'), log(sum(exp(shifted), axis,\n  //       keepDims)));\n  //   save([value]);\n  //   return value;\n  // };\n\n  // Use a custom gradient for numerical stability.\n  const customOp = customGrad((logits: Tensor, save: GradSaveFunc) => {\n    const keepDims = true;\n    const xMax = max(logits, axis, true);\n    const shifted = sub(logits, xMax);\n    const value =\n        sub(cast(shifted, 'float32'), log(sum(exp(shifted), axis, keepDims)));\n    save([value]);\n\n    const gradFunc = (dy: Tensor, saved: Tensor[]) => {\n      const [value] = saved;\n      const keepDims = true;\n      const softmax = exp(value);\n      return sub(dy, mul(sum(dy, axis, keepDims), softmax));\n    };\n    return {value, gradFunc};\n  });\n\n  return customOp($logits) as T;\n\n  // TODO Use Engine.runKernel when CPU/WebGL/WASM backends implement this.\n  // const inputs: LogSoftmaxInputs = {logits: $logits};\n  // const attrs: LogSoftmaxAttrs = {axis};\n  // return ENGINE.runKernel(\n  //            LogSoftmax, inputs as {} as NamedTensorMap,\n  //            attrs as {} as NamedAttrMap);\n}\n\nexport const logSoftmax = op({logSoftmax_});\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as util from '../util';\n\n/**\n * Returns true if the axis specifies the inner most dimensions of the\n * array.\n */\nexport function axesAreInnerMostDims(axes: number[], rank: number): boolean {\n  for (let i = 0; i < axes.length; ++i) {\n    if (axes[axes.length - i - 1] !== rank - 1 - i) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function combineLocations(\n    outputLoc: number[], reduceLoc: number[], axes: number[]): number[] {\n  const rank = outputLoc.length + reduceLoc.length;\n  const loc = [];\n  let outIdx = 0;\n  let reduceIdx = 0;\n  \u00A0 for (let dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      loc.push(outputLoc[outIdx++]);\n    } else {\n      loc.push(reduceLoc[reduceIdx++]);\n    }\n  }\n  return loc;\n}\n\nexport function computeOutAndReduceShapes(\n    aShape: number[], axes: number[]): [number[], number[]] {\n  const outShape = [];\n  const rank = aShape.length;\n  for (let dim = 0; dim < rank; dim++) {\n    if (axes.indexOf(dim) === -1) {\n      outShape.push(aShape[dim]);\n    }\n  }\n  const reduceShape = axes.map(dim => aShape[dim]);\n  return [outShape, reduceShape];\n}\n\nexport function expandShapeToKeepDim(\n    shape: number[], axes: number[]): number[] {\n  const reduceSubShape = axes.map(x => 1);\n  return combineLocations(shape, reduceSubShape, axes);\n}\n\nexport function assertAxesAreInnerMostDims(\n    msg: string, axes: number[], rank: number): void {\n  util.assert(\n      axesAreInnerMostDims(axes, rank),\n      () => `${msg} supports only inner-most axes for now. ` +\n          `Got axes ${axes} and rank-${rank} input.`);\n}\n\n/**\n * Returns the axes permutation to be used with `tf.transpose`, if such\n * permutation is necessary. Otherwise it returns null. This method is used by\n * operations that operate only on inner-most axes.\n */\nexport function getAxesPermutation(axes: number[], rank: number): number[]|\n    null {\n  if (axesAreInnerMostDims(axes, rank)) {\n    return null;\n  }\n  const result: number[] = [];\n  for (let i = 0; i < rank; ++i) {\n    if (axes.indexOf(i) === -1) {\n      result.push(i);\n    }\n  }\n  axes.forEach(axis => result.push(axis));\n  return result;\n}\n\n/** Returns the axes permutation that undoes the original permutation. */\nexport function getUndoAxesPermutation(axes: number[]): number[] {\n  return axes.map((axis, i) => [i, axis])\n      .sort((a, b) => a[1] - b[1])\n      .map(x => x[0]);\n}\n\nexport function getInnerMostAxes(numAxes: number, rank: number): number[] {\n  const res: number[] = [];\n  for (let i = rank - numAxes; i < rank; ++i) {\n    res.push(i);\n  }\n  return res;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {parseAxisParam} from '../util';\n\nimport {add} from './add';\nimport {expandShapeToKeepDim} from './axis_util';\nimport {exp} from './exp';\nimport {log} from './log';\nimport {max} from './max';\nimport {op} from './operation';\nimport {reshape} from './reshape';\nimport {sub} from './sub';\nimport {sum} from './sum';\n\n/**\n * Computes the log(sum(exp(elements across the reduction dimensions)).\n *\n * Reduces the input along the dimensions given in `axis`. Unless `keepDims`\n * is true, the rank of the array is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and an array with a\n * single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.logSumExp().print();  // or tf.logSumExp(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.logSumExp(axis).print();  // or tf.logSumExp(a, axis)\n * ```\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. If null (the default),\n *     reduces all dimensions.\n * @param keepDims If true, retains reduced dimensions with length\n *     of 1. Defaults to false.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction logSumExp_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'logSumExp');\n\n  const axes = parseAxisParam(axis, $x.shape);\n  const xMax = max($x, axes, true /* keepDims */);\n  const a = sub($x, xMax);\n  const b = exp(a);\n  const c = sum(b, axes);\n  const d = log(c);\n  const res = add(reshape(xMax, d.shape), d);\n\n  if (keepDims) {\n    const newShape = expandShapeToKeepDim(res.shape, axes);\n    return reshape(res, newShape) as T;\n  }\n  return res as T;\n}\n\nexport const logSumExp = op({logSumExp_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {LogicalAnd, LogicalAndInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of `a AND b` element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([false, false, true, true], 'bool');\n * const b = tf.tensor1d([false, true, false, true], 'bool');\n *\n * a.logicalAnd(b).print();\n * ```\n *\n * @param a The first input tensor. Must be of dtype bool.\n * @param b The second input tensor. Must be of dtype bool.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction logicalAnd_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'logicalAnd', 'bool');\n  const $b = convertToTensor(b, 'b', 'logicalAnd', 'bool');\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: LogicalAndInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(LogicalAnd, inputs as {} as NamedTensorMap);\n}\n\nexport const logicalAnd = op({logicalAnd_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {LogicalNot, LogicalNotInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of `NOT x` element-wise.\n *\n * ```js\n * const a = tf.tensor1d([false, true], 'bool');\n *\n * a.logicalNot().print();\n * ```\n *\n * @param x The input tensor. Must be of dtype 'bool'.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction logicalNot_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'logicalNot', 'bool');\n  const inputs: LogicalNotInputs = {x: $x};\n  return ENGINE.runKernel(LogicalNot, inputs as {} as NamedTensorMap);\n}\n\nexport const logicalNot = op({logicalNot_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {LogicalOr, LogicalOrInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of `a OR b` element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([false, false, true, true], 'bool');\n * const b = tf.tensor1d([false, true, false, true], 'bool');\n *\n * a.logicalOr(b).print();\n * ```\n * @param a The first input tensor. Must be of dtype bool.\n * @param b The second input tensor. Must be of dtype bool.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction logicalOr_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'logicalOr', 'bool');\n  const $b = convertToTensor(b, 'b', 'logicalOr', 'bool');\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: LogicalOrInputs = {a: $a, b: $b};\n  return ENGINE.runKernel(LogicalOr, inputs as {} as NamedTensorMap);\n}\nexport const logicalOr = op({logicalOr_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {logicalAnd} from './logical_and';\nimport {logicalNot} from './logical_not';\nimport {logicalOr} from './logical_or';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of `a XOR b` element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([false, false, true, true], 'bool');\n * const b = tf.tensor1d([false, true, false, true], 'bool');\n *\n * a.logicalXor(b).print();\n * ```\n *\n * @param a The first input tensor. Must be of dtype bool.\n * @param b The second input tensor. Must be of dtype bool.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction logicalXor_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  const $a = convertToTensor(a, 'a', 'logicalXor', 'bool');\n  const $b = convertToTensor(b, 'b', 'logicalXor', 'bool');\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  // x ^ y = (x | y) & ~(x & y)\n  return logicalAnd(logicalOr(a, b), logicalNot(logicalAnd(a, b)));\n}\n\nexport const logicalXor = op({logicalXor_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {MaxPool, MaxPoolAttrs, MaxPoolInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the 2D max pooling of an image.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction maxPool_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  const $x = convertToTensor(x, 'x', 'maxPool');\n  const dilations = 1;\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in maxPool: input must be rank 4 but got rank ${x4D.rank}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in maxPool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in maxPool: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inputs: MaxPoolInputs = {x: x4D};\n\n  const attrs: MaxPoolAttrs = {filterSize, strides, pad, dimRoundingMode};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  MaxPool, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const maxPool = op({maxPool_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {MaxPool3D, MaxPool3DAttrs, MaxPool3DInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor4D, Tensor5D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the 3D max pooling.\n *\n * ```js\n * const x = tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]);\n * const result = tf.maxPool3d(x, 2, 1, 'valid');\n * result.print();\n * ```\n *\n * @param x The input tensor, of rank 5 or rank 4 of shape\n *     `[batch, depth, height, width, inChannels]`.\n * @param filterSize The filter size:\n *     `[filterDepth, filterHeight, filterWidth]`.\n *     If `filterSize` is a single number,\n *     then `filterDepth == filterHeight == filterWidth`.\n * @param strides The strides of the pooling:\n *     `[strideDepth, strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideDepth == strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction maxPool3d_<T extends Tensor4D|Tensor5D>(\n    x: T|TensorLike, filterSize: [number, number, number]|number = [1, 1, 1],\n    strides: [number, number, number]|number, pad: 'valid'|'same'|number,\n    dimRoundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC'): T {\n  const $x = convertToTensor(x, 'x', 'maxPool3d');\n\n  let x5D = $x as Tensor5D;\n  let reshapedTo5D = false;\n  if ($x.rank === 4) {\n    reshapedTo5D = true;\n    x5D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2], $x.shape[3]]);\n  }\n\n  util.assert(\n      x5D.rank === 5,\n      () => `Error in maxPool3d: x must be rank 5 but got rank ${x5D.rank}.`);\n  util.assert(\n      dataFormat === 'NDHWC',\n      () => `Error in maxPool3d: Only NDHWC is currently supported, ` +\n          `but got dataFormat of ${dataFormat}`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in maxPool3d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inputs: MaxPool3DInputs = {x: x5D};\n\n  const attrs:\n      MaxPool3DAttrs = {filterSize, strides, pad, dimRoundingMode, dataFormat};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  MaxPool3D, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo5D) {\n    return reshape(\n               res, [res.shape[1], res.shape[2], res.shape[3], res.shape[4]]) as\n        T;\n  }\n\n  return res;\n}\n\nexport const maxPool3d = op({maxPool3d_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {MaxPoolWithArgmax, MaxPoolWithArgmaxAttrs, MaxPoolWithArgmaxInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the 2D max pooling of an image with Argmax index.\n * The indices in argmax are flattened, so that a maximum value at position `[b,\n * y, x, c]` becomes flattened index: `(y * width + x) * channels + c` if\n * include_batch_in_index is False; `((b * height + y) * width + x) * channels\n * +c` if include_batch_in_index is True.\n *\n * The indices returned are always in `[0, height) x [0, width)` before\n * flattening.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param filterSize The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n * @param dataFormat An optional string from: \"NDHWC\", \"NCDHW\". Defaults to\n *     \"NDHWC\". Specify the data format of the input and output data. With the\n *     default format \"NDHWC\", the data is stored in the order of: [batch,\n *     depth, height, width, channels]. Only \"NDHWC\" is currently supported.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param includeBatchIndex Defaults to False. Whether to include batch\n *    dimension in flattened index of argmax.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction maxPoolWithArgmax_<T extends Tensor4D>(\n    x: T|TensorLike, filterSize: [number, number]|number,\n    strides: [number, number]|number, pad: 'valid'|'same'|number,\n    includeBatchInIndex = false): NamedTensorMap {\n  const $x = convertToTensor(x, 'x', 'maxPoolWithArgmax');\n\n  const inputs: MaxPoolWithArgmaxInputs = {x: $x};\n  const attrs:\n      MaxPoolWithArgmaxAttrs = {filterSize, strides, pad, includeBatchInIndex};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const result = ENGINE.runKernel(\n                     MaxPoolWithArgmax, inputs as {} as NamedTensorMap,\n                     attrs as {} as NamedAttrMap) as Tensor[];\n\n  return {result: result[0], indexes: result[1]};\n}\n\nexport const maxPoolWithArgmax = op({maxPoolWithArgmax_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Maximum, MaximumInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {cast} from './cast';\nimport {op} from './operation';\n\n/**\n * Returns the max of a and b (`a > b ? a : b`) element-wise.\n * Supports broadcasting.\n *\n * We also expose `tf.maximumStrict` which has the same signature as this op and\n * asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 3, 16]);\n * const b = tf.tensor1d([1, 2, 9, 4]);\n *\n * a.maximum(b).print();  // or tf.maximum(a, b)\n * ```\n *\n * ```js\n * // Broadcast maximum a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(5);\n *\n * a.maximum(b).print();  // or tf.maximum(a, b)\n * ```\n *\n * @param a The first tensor.\n * @param b The second tensor. Must have the same type as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction maximum_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'maximum');\n  let $b = convertToTensor(b, 'b', 'maximum');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  if ($a.dtype === 'bool') {\n    $a = cast($a, 'int32');\n    $b = cast($b, 'int32');\n  }\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: MaximumInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Maximum, inputs as {} as NamedTensorMap);\n}\n\nexport const maximum = op({maximum_});\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Mean, MeanAttrs, MeanInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the mean of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces `x` along the dimensions given in `axis`. Unless `keepDims` is\n * true, the rank of the `tf.Tensor` is reduced by 1 for each entry in `axis`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axis` has no entries, all dimensions are reduced, and a `tf.Tensor` with\n * a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.mean().print();  // or tf.mean(a)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.mean(axis).print();  // or tf.mean(x, axis)\n * ```\n *\n * @param x The input tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction mean_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'mean');\n\n  const inputs: MeanInputs = {x: $x};\n  const attrs: MeanAttrs = {axis, keepDims};\n\n  return ENGINE.runKernel(\n      Mean, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const mean = op({mean_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\nimport {makeZerosTypedArray, sizeFromShape} from '../util';\n\nimport {complex} from './complex';\n\n/**\n * Creates a `tf.Tensor` with all elements set to 0.\n *\n * ```js\n * tf.zeros([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Can\n *     be 'float32', 'int32' or 'bool'. Defaults to 'float'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function zeros<R extends Rank>(\n    shape: ShapeMap[R], dtype: DataType = 'float32'): Tensor<R> {\n  if (dtype === 'complex64') {\n    const real = zeros(shape, 'float32');\n    const imag = zeros(shape, 'float32');\n    return complex(real, imag);\n  }\n  const values = makeZerosTypedArray(sizeFromShape(shape), dtype);\n  return ENGINE.makeTensor(values, shape, dtype) as Tensor<R>;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\nimport {makeOnesTypedArray, sizeFromShape} from '../util';\n\nimport {complex} from './complex';\nimport {zeros} from './zeros';\n\n/**\n * Creates a `tf.Tensor` with all elements set to 1.\n *\n * ```js\n * tf.ones([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param dtype The type of an element in the resulting tensor. Defaults to\n *     'float'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function ones<R extends Rank>(\n    shape: ShapeMap[R], dtype: DataType = 'float32'): Tensor<R> {\n  if (dtype === 'complex64') {\n    const real = ones(shape, 'float32');\n    const imag = zeros(shape, 'float32');\n    return complex(real, imag);\n  }\n  const values = makeOnesTypedArray(sizeFromShape(shape), dtype);\n  return ENGINE.makeTensor(values, shape, dtype) as Tensor<R>;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {matMul} from './mat_mul';\nimport {ones} from './ones';\nimport {reshape} from './reshape';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {sizeFromShape} from '../util_base';\n\n/**\n * Broadcasts parameters for evaluation on an N-D grid.\n *\n * Given N one-dimensional coordinate arrays `*args`, returns a list `outputs`\n * of N-D coordinate arrays for evaluating expressions on an N-D grid.\n *\n * Notes:\n * `meshgrid` supports cartesian ('xy') and matrix ('ij') indexing conventions.\n * When the `indexing` argument is set to 'xy' (the default), the broadcasting\n * instructions for the first two dimensions are swapped.\n * Examples:\n * Calling `const [X, Y] = meshgrid(x, y)` with the tensors\n *\n * ```javascript\n * const x = [1, 2, 3];\n * const y = [4, 5, 6];\n * const [X, Y] = tf.meshgrid(x, y);\n * // X = [[1, 2, 3],\n * //      [1, 2, 3],\n * //      [1, 2, 3]]\n * // Y = [[4, 4, 4],\n * //      [5, 5, 5],\n * //      [6, 6, 6]]\n * ```\n *\n * @param x Tensor with rank geq 1.\n * @param y Tensor with rank geq 1.\n * @param indexing\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nexport function meshgrid<T extends Tensor>(\n    x?: T|TensorLike, y?: T|TensorLike, {indexing = 'xy'} = {}): T[] {\n  if (indexing !== 'xy' && indexing !== 'ij') {\n    throw new TypeError(\n        `${indexing} is not a valid third argument to meshgrid`);\n  }\n  if (x === undefined) {\n    return [];\n  }\n  let $x = convertToTensor(\n      x, 'x', 'meshgrid', x instanceof Tensor ? x.dtype : 'float32');\n\n  if (y === undefined) {\n    return [$x];\n  }\n  let $y = convertToTensor(\n      y, 'y', 'meshgrid', y instanceof Tensor ? y.dtype : 'float32');\n\n  const w = sizeFromShape($x.shape);\n  const h = sizeFromShape($y.shape);\n\n  if (indexing === 'xy') {\n    $x = reshape($x, [1, -1]) as T;\n    $y = reshape($y, [-1, 1]) as T;\n    return [\n      matMul(ones([h, 1], $x.dtype), $x),\n      matMul($y, ones([1, w], $y.dtype)),\n    ];\n  }\n\n  $x = reshape($x, [-1, 1]) as T;\n  $y = reshape($y, [1, -1]) as T;\n  return [\n    matMul($x, ones([1, h], $x.dtype)),\n    matMul(ones([w, 1], $y.dtype), $y),\n  ];\n}\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Min, MinAttrs, MinInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the minimum value from the input.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the array is reduced by 1 for each entry in `axes`.\n * If `keepDims` is true, the reduced dimensions are retained with length 1.\n * If `axes` has no entries, all dimensions are reduced, and an array with a\n * single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.min().print();  // or tf.min(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.min(axis).print();  // or tf.min(x, axis)\n * ```\n *\n * @param x The input Tensor.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction min_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  const $x = convertToTensor(x, 'x', 'min');\n\n  const inputs: MinInputs = {x: $x};\n  const attrs: MinAttrs = {axis, keepDims};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  return ENGINE.runKernel(\n             Min, inputs as {} as NamedTensorMap,\n             attrs as {} as NamedAttrMap) as T;\n}\n\nexport const min = op({min_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Minimum, MinimumInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {cast} from './cast';\nimport {op} from './operation';\n\n/**\n * Returns the min of a and b (`a < b ? a : b`) element-wise.\n * Supports broadcasting.\n *\n * We also expose `minimumStrict` which has the same signature as this op and\n * asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 3, 16]);\n * const b = tf.tensor1d([1, 2, 9, 4]);\n *\n * a.minimum(b).print();  // or tf.minimum(a, b)\n * ```\n *\n * ```js\n * // Broadcast minimum a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(5);\n *\n * a.minimum(b).print();  // or tf.minimum(a, b)\n * ```\n *\n * @param a The first tensor.\n * @param b The second tensor. Must have the same type as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction minimum_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'minimum');\n  let $b = convertToTensor(b, 'b', 'minimum');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  if ($a.dtype === 'bool') {\n    $a = cast($a, 'int32');\n    $b = cast($b, 'int32');\n  }\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: MinimumInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Minimum, inputs as {} as NamedTensorMap);\n}\n\nexport const minimum = op({minimum_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {MirrorPad, MirrorPadAttrs, MirrorPadInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Pads a `tf.Tensor` using mirror padding.\n *\n * This operation implements the `REFLECT` and `SYMMETRIC` modes of pad.\n *\n * ```js\n * const x = tf.range(0, 9).reshape([1, 1, 3, 3]);\n * x.mirrorPad([[0, 0], [0, 0], [2, 2], [2, 2]], 'reflect').print();\n * ```\n * @param x The tensor to pad.\n * @param paddings An array of length `R` (the rank of the tensor), where\n * each element is a length-2 tuple of ints `[padBefore, padAfter]`,\n * specifying how much to pad along each dimension of the tensor.\n * In \"reflect\" mode, the padded regions do not include the borders,\n * while in \"symmetric\" mode the padded regions do include the borders.\n * For example, if the input is `[1, 2, 3]` and paddings is `[0, 2]`,\n * then the output is `[1, 2, 3, 2, 1]` in \"reflect\" mode, and\n * `[1, 2, 3, 3, 2]` in \"symmetric\" mode.\n * If `mode` is \"reflect\" then both `paddings[D, 0]` and `paddings[D, 1]`\n * must be no greater than `x.shape[D] - 1`. If mode is \"symmetric\"\n * then both `paddings[D, 0]` and `paddings[D, 1]` must be no greater than\n * `x.shape[D]`\n * @param mode String to specify padding mode. Can be `'reflect' | 'symmetric'`\n */\n/** @doc {heading: 'Tensors', subheading: 'Transformations'} */\nfunction mirrorPad_<T extends Tensor>(\n    x: T|TensorLike, paddings: Array<[number, number]>,\n    mode: 'reflect'|'symmetric'): T {\n  util.assert(\n      mode === 'reflect' || mode === 'symmetric',\n      () => `Invalid mode. Mode must be either reflect or symmetric. ` +\n          `Got ${mode}.`);\n\n  const $x = convertToTensor(x, 'x', 'mirrorPad');\n  if ($x.rank === 0) {\n    throw new Error(\n        'mirrorPad(scalar) is not defined. ' +\n        'Pass non-scalar to mirrorPad');\n  }\n  util.assert(\n      paddings.length === $x.rank,\n      () => `Padding doesn't match input. Must be ${$x.rank}. ` +\n          `Got ${paddings.length}.`);\n  const shapeOffset = mode === 'reflect' ? 1 : 0;\n  for (let i = 0; i < $x.rank; i++) {\n    util.assert(\n        paddings[i].length === 2,\n        () => `Invalid number of paddings. Must be length of 2 each.`);\n    util.assert(\n        paddings[i][0] >= 0 && paddings[i][0] <= $x.shape[i] - shapeOffset &&\n            paddings[i][1] >= 0 && paddings[i][1] <= $x.shape[i] - shapeOffset,\n        () => `Padding in dimension ${i} cannot be greater than or equal ` +\n            `to ${$x.shape[i] - shapeOffset} or less than 0 for input of ` +\n            `shape ${$x.shape}`);\n  }\n\n  const attrs: MirrorPadAttrs = {paddings, mode};\n  const inputs: MirrorPadInputs = {x: $x};\n  return ENGINE.runKernel(\n      MirrorPad, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const mirrorPad = op({mirrorPad_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Mod, ModInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Returns the mod of a and b element-wise.\n * `floor(x / y) * y + mod(x, y) = x`\n * Supports broadcasting.\n *\n * We also expose `tf.modStrict` which has the same signature as this op and\n * asserts that `a` and `b` are the same shape (does not broadcast).\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 3, 16]);\n * const b = tf.tensor1d([1, 2, 9, 4]);\n *\n * a.mod(b).print();  // or tf.mod(a, b)\n * ```\n *\n * ```js\n * // Broadcast a mod b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(5);\n *\n * a.mod(b).print();  // or tf.mod(a, b)\n * ```\n *\n * @param a The first tensor.\n * @param b The second tensor. Must have the same type as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction mod_<T extends Tensor>(a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'mod');\n  let $b = convertToTensor(b, 'b', 'mod');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  const inputs: ModInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(Mod, inputs as {} as NamedTensorMap);\n}\n\nexport const mod = op({mod_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Computes square of `x` element-wise: `x ^ 2`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, Math.sqrt(2), -1]);\n *\n * x.square().print();  // or tf.square(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction square_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'square');\n  const attrs = {};\n  return ENGINE.runKernel('Square', {x: $x}, attrs);\n}\n\nexport const square = op({square_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {parseAxisParam} from '../util';\n\nimport {expandShapeToKeepDim} from './axis_util';\nimport {cast} from './cast';\nimport {mean} from './mean';\nimport {op} from './operation';\nimport {reshape} from './reshape';\nimport {square} from './square';\nimport {sub} from './sub';\n\n/**\n * Calculates the mean and variance of `x`. The mean and variance are\n * calculated by aggregating the contents of `x` across `axes`. If `x` is\n * 1-D and `axes = [0]` this is just the mean and variance of a vector.\n *\n * @param x The input tensor.\n * @param axis The dimension(s) along with to compute mean and\n *     variance. By default it reduces all dimensions.\n * @param keepDims If true, the moments have the same dimensionality as the\n *     input.\n * @return An object with two keys: `mean` and `variance`.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction moments_(\n    x: Tensor|TensorLike, axis: number|number[] = null,\n    keepDims = false): {mean: Tensor, variance: Tensor} {\n  x = convertToTensor(x, 'x', 'moments');\n  const axes = parseAxisParam(axis, x.shape);\n  const xMean = mean(x, axes, keepDims);\n  let keepDimsShape = xMean.shape;\n  if (!keepDims) {\n    keepDimsShape = expandShapeToKeepDim(xMean.shape, axes);\n  }\n  const devSquared =\n      square(sub(cast(x, 'float32'), reshape(xMean, keepDimsShape)));\n  const variance = mean(devSquared, axes, keepDims);\n  return {mean: xMean, variance};\n}\n\nexport const moments = op({moments_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor2D} from '../tensor';\nimport {convertToTensor, convertToTensorArray} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * @docalias (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D]\n */\nexport type LSTMCellFunc = {\n  (data: Tensor2D, c: Tensor2D, h: Tensor2D): [Tensor2D, Tensor2D];\n};\n\n/**\n * Computes the next states and outputs of a stack of LSTMCells.\n *\n * Each cell output is used as input to the next cell.\n *\n * Returns `[cellState, cellOutput]`.\n *\n * Derived from tf.contrib.rn.MultiRNNCell.\n *\n * @param lstmCells Array of LSTMCell functions.\n * @param data The input to the cell.\n * @param c Array of previous cell states.\n * @param h Array of previous cell outputs.\n *\n * @doc {heading: 'Operations', subheading: 'RNN'}\n */\nfunction multiRNNCell_(\n    lstmCells: LSTMCellFunc[], data: Tensor2D|TensorLike,\n    c: Array<Tensor2D|TensorLike>,\n    h: Array<Tensor2D|TensorLike>): [Tensor2D[], Tensor2D[]] {\n  const $data = convertToTensor(data, 'data', 'multiRNNCell');\n  const $c = convertToTensorArray(c, 'c', 'multiRNNCell');\n  const $h = convertToTensorArray(h, 'h', 'multiRNNCell');\n\n  let input = $data;\n  const newStates = [];\n  for (let i = 0; i < lstmCells.length; i++) {\n    const output = lstmCells[i](input, $c[i], $h[i]);\n    newStates.push(output[0]);\n    newStates.push(output[1]);\n    input = output[1];\n  }\n  const newC: Tensor2D[] = [];\n  const newH: Tensor2D[] = [];\n  for (let i = 0; i < newStates.length; i += 2) {\n    newC.push(newStates[i]);\n    newH.push(newStates[i + 1]);\n  }\n  return [newC, newH];\n}\nexport const multiRNNCell = op({multiRNNCell_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Multinomial, MultinomialAttrs, MultinomialInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor1D, Tensor2D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Creates a `tf.Tensor` with values drawn from a multinomial distribution.\n *\n * ```js\n * const probs = tf.tensor([.75, .25]);\n * tf.multinomial(probs, 3).print();\n * ```\n *\n * @param logits 1D array with unnormalized log-probabilities, or\n *     2D array of shape `[batchSize, numOutcomes]`. See the `normalized`\n *     parameter.\n * @param numSamples Number of samples to draw for each row slice.\n * @param seed The seed number.\n * @param normalized Whether the provided `logits` are normalized true\n *     probabilities (sum to 1). Defaults to false.\n * @return 1D array of shape `[numSamples]`, or 2D array of shape\n *     `[batchSize, numSamples]`, depending on the rank of the input.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction multinomial_(\n    logits: Tensor1D|Tensor2D|TensorLike, numSamples: number, seed?: number,\n    normalized = false): Tensor1D|Tensor2D {\n  const $logits = convertToTensor(logits, 'logits', 'multinomial');\n  const numOutcomes = $logits.size;\n  const origRank = $logits.rank;\n  if (numOutcomes < 2) {\n    throw new Error(\n        `Error in multinomial: you need at least 2 outcomes, but got ` +\n        `${numOutcomes}.`);\n  }\n  if (origRank > 2) {\n    throw new Error(`Rank of probabilities must be 1 or 2, but is ${origRank}`);\n  }\n  // TODO(lina128): Investigate correct seed behavior. The code seems not allow\n  // setting see to 0.\n  seed = seed || Math.random();\n\n  // The kernel only accepts (and returns) rank 2 tensors.\n  const logits2D: Tensor2D =\n      origRank === 1 ? reshape($logits, [1, -1]) : $logits as Tensor2D;\n\n  const inputs: MultinomialInputs = {logits: logits2D};\n  const attrs: MultinomialAttrs = {numSamples, seed, normalized};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  Multinomial, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as Tensor2D;\n\n  // tslint:disable-next-line:no-unnecessary-type-assertion\n  return origRank === 1 ? reshape(res, [res.size]) as Tensor1D : res;\n}\n\nexport const multinomial = op({multinomial_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {NotEqual, NotEqualInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns the truth value of (a != b) element-wise. Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([0, 2, 3]);\n *\n * a.notEqual(b).print();\n * ```\n * @param a The first input tensor.\n * @param b The second input tensor. Must have the same dtype as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nfunction notEqual_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'notEqual', 'string_or_numeric');\n  let $b = convertToTensor(b, 'b', 'notEqual', 'string_or_numeric');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: NotEqualInputs = {a: $a, b: $b};\n\n  return ENGINE.runKernel(NotEqual, inputs as {} as NamedTensorMap);\n}\n\nexport const notEqual = op({notEqual_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {OnesLike, OnesLikeInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Creates a `tf.Tensor` with all elements set to 1 with the same shape as the\n * given tensor.\n *\n * ```js\n * const x = tf.tensor([1, 2]);\n * tf.onesLike(x).print();\n * ```\n * @param x A tensor.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction onesLike_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'onesLike');\n\n  const inputs: OnesLikeInputs = {x: $x};\n  return ENGINE.runKernel(OnesLike, inputs as {} as NamedTensorMap);\n}\n\nexport const onesLike = op({onesLike_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor1D, Tensor2D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {matMul} from './mat_mul';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the outer product of two vectors, `v1` and `v2`.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n * const b = tf.tensor1d([3, 4, 5]);\n *\n * tf.outerProduct(a, b).print();\n * ```\n * @param v1 The first vector in the outer product operation.\n * @param v2 The second vector in the outer product operation.\n *\n * @doc {heading: 'Operations', subheading: 'Matrices'}\n */\nfunction outerProduct_(\n    v1: Tensor1D|TensorLike, v2: Tensor1D|TensorLike): Tensor2D {\n  const $v1 = convertToTensor(v1, 'v1', 'outerProduct');\n  const $v2 = convertToTensor(v2, 'v2', 'outerProduct');\n\n  util.assert(\n      $v1.rank === 1 && $v2.rank === 1,\n      () => `Error in outerProduct: inputs must be rank 1, but got ranks ` +\n          `${$v1.rank} and ${$v2.rank}.`);\n\n  const v12D = reshape($v1, [-1, 1]);\n  const v22D = reshape($v2, [1, -1]);\n  return matMul(v12D, v22D);\n}\n\nexport const outerProduct = op({outerProduct_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {PadV2, PadV2Attrs, PadV2Inputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Pads a `tf.Tensor` with a given value and paddings.\n *\n * This operation implements `CONSTANT` mode. For `REFLECT` and `SYMMETRIC`,\n * refer to `tf.mirrorPad`\n *\n * Also available are stricter rank-specific methods with the same signature\n * as this method that assert that `paddings` is of given length.\n *   - `tf.pad1d`\n *   - `tf.pad2d`\n *   - `tf.pad3d`\n *   - `tf.pad4d`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * x.pad([[1, 2]]).print();\n * ```\n * @param x The tensor to pad.\n * @param paddings An array of length `R` (the rank of the tensor), where\n * each element is a length-2 tuple of ints `[padBefore, padAfter]`,\n * specifying how much to pad along each dimension of the tensor.\n * @param constantValue The pad value to use. Defaults to 0.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction pad_<T extends Tensor>(\n    x: T|TensorLike, paddings: Array<[number, number]>, constantValue = 0): T {\n  const $x = convertToTensor(x, 'x', 'pad');\n  if ($x.rank === 0) {\n    throw new Error('pad(scalar) is not defined. Pass non-scalar to pad');\n  }\n\n  const attrs: PadV2Attrs = {paddings, constantValue};\n  const inputs: PadV2Inputs = {x: $x};\n  return ENGINE.runKernel(\n      PadV2, inputs as unknown as NamedTensorMap,\n      attrs as unknown as NamedAttrMap);\n}\n\nexport const pad = op({pad_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor1D} from '../tensor';\nimport {TensorLike} from '../types';\nimport {assert} from '../util';\nimport {op} from './operation';\nimport {pad} from './pad';\n\n/**\n * Pads a `tf.Tensor1D` with a given value and paddings. See `pad` for details.\n */\nfunction pad1d_(\n    x: Tensor1D|TensorLike, paddings: [number, number],\n    constantValue = 0): Tensor1D {\n  assert(\n      paddings.length === 2,\n      () => 'Invalid number of paddings. Must be length of 2.');\n  return pad(x, [paddings], constantValue);\n}\n\nexport const pad1d = op({pad1d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor2D} from '../tensor';\nimport {TensorLike} from '../types';\nimport {assert} from '../util';\nimport {op} from './operation';\nimport {pad} from './pad';\n\n/**\n * Pads a `tf.Tensor2D` with a given value and paddings. See `pad` for details.\n */\nfunction pad2d_(\n    x: Tensor2D|TensorLike, paddings: [[number, number], [number, number]],\n    constantValue = 0): Tensor2D {\n  assert(\n      paddings.length === 2 && paddings[0].length === 2 &&\n          paddings[1].length === 2,\n      () => 'Invalid number of paddings. Must be length of 2 each.');\n  return pad(x, paddings, constantValue);\n}\n\nexport const pad2d = op({pad2d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor3D} from '../tensor';\nimport {TensorLike} from '../types';\nimport {assert} from '../util';\nimport {op} from './operation';\nimport {pad} from './pad';\n\n/**\n * Pads a `tf.Tensor3D` with a given value and paddings. See `pad` for details.\n */\nfunction pad3d_(\n    x: Tensor3D|TensorLike,\n    paddings: [[number, number], [number, number], [number, number]],\n    constantValue = 0): Tensor3D {\n  assert(\n      paddings.length === 3 && paddings[0].length === 2 &&\n          paddings[1].length === 2 && paddings[2].length === 2,\n      () => 'Invalid number of paddings. Must be length of 2 each.');\n  return pad(x, paddings, constantValue);\n}\n\nexport const pad3d = op({pad3d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor4D} from '../tensor';\nimport {TensorLike} from '../types';\nimport {assert} from '../util';\nimport {op} from './operation';\nimport {pad} from './pad';\n\n/**\n * Pads a `tf.Tensor4D` with a given value and paddings. See `pad` for details.\n */\nfunction pad4d_(\n    x: Tensor4D|TensorLike,\n    paddings:\n        [\n          [number, number], [number, number], [number, number], [number, number]\n        ],\n    constantValue = 0): Tensor4D {\n  assert(\n      paddings.length === 4 && paddings[0].length === 2 &&\n          paddings[1].length === 2 && paddings[2].length === 2 &&\n          paddings[3].length === 2,\n      () => 'Invalid number of paddings. Must be length of 2 each.');\n  return pad(x, paddings, constantValue);\n}\n\nexport const pad4d = op({pad4d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {SpaceToBatchND, SpaceToBatchNDAttrs, SpaceToBatchNDInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * This operation divides \"spatial\" dimensions `[1, ..., M]` of the input into\n * a grid of blocks of shape `blockShape`, and interleaves these blocks with\n * the \"batch\" dimension (0) such that in the output, the spatial\n * dimensions `[1, ..., M]` correspond to the position within the grid,\n * and the batch dimension combines both the position within a spatial block\n * and the original batch position. Prior to division into blocks,\n * the spatial dimensions of the input are optionally zero padded\n * according to `paddings`. See below for a precise description.\n *\n * ```js\n * const x = tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]);\n * const blockShape = [2, 2];\n * const paddings = [[0, 0], [0, 0]];\n *\n * x.spaceToBatchND(blockShape, paddings).print();\n * ```\n *\n * @param x A `tf.Tensor`. N-D with `x.shape` = `[batch] + spatialShape +\n * remainingShape`, where spatialShape has `M` dimensions.\n * @param blockShape A 1-D array. Must have shape `[M]`, all values must\n * be >= 1.\n * @param paddings A 2-D array. Must have shape `[M, 2]`, all values must be >=\n *     0. `paddings[i] = [padStart, padEnd]` specifies the amount to zero-pad\n * from input dimension `i + 1`, which corresponds to spatial dimension `i`. It\n * is required that\n * `(inputShape[i + 1] + padStart + padEnd) % blockShape[i] === 0`\n *\n * This operation is equivalent to the following steps:\n *\n * 1. Zero-pad the start and end of dimensions `[1, ..., M]` of the input\n * according to `paddings` to produce `padded` of shape paddedShape.\n *\n * 2. Reshape `padded` to `reshapedPadded` of shape:\n * `[batch] + [paddedShape[1] / blockShape[0], blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1], blockShape[M-1]] + remainingShape`\n *\n * 3. Permute dimensions of `reshapedPadded` to produce `permutedReshapedPadded`\n * of shape: `blockShape + [batch] + [paddedShape[1] / blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1]] + remainingShape`\n *\n * 4. Reshape `permutedReshapedPadded` to flatten `blockShape` into the\n * batch dimension, producing an output tensor of shape:\n * `[batch * prod(blockShape)] + [paddedShape[1] / blockShape[0], ...,\n * paddedShape[M] / blockShape[M-1]] + remainingShape`\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction spaceToBatchND_<T extends Tensor>(\n    x: T|TensorLike, blockShape: number[], paddings: number[][]): T {\n  const $x = convertToTensor(x, 'x', 'spaceToBatchND');\n\n  util.assert(\n      $x.rank >= 1 + blockShape.length,\n      () => `input rank ${$x.rank} should be > than [blockShape] ${\n          blockShape.length}`);\n\n  util.assert(\n      paddings.length === blockShape.length,\n      () => `paddings.shape[0] ${\n          paddings.length} must be equal to [blockShape] ${blockShape.length}`);\n\n  util.assert(\n      $x.shape.reduce(\n          (a, b, i) => {\n            if (i > 0 && i <= blockShape.length) {\n              return a &&\n                  ((b + paddings[i - 1][0] + paddings[i - 1][1]) %\n                       blockShape[i - 1] ===\n                   0);\n            }\n            return a;\n          },\n          true),\n      () => `input spatial dimensions ${$x.shape.slice(1)} with paddings ${\n          paddings.toString()} must be divisible by blockShapes ${\n          blockShape.toString()}`);\n\n  const inputs: SpaceToBatchNDInputs = {x: $x};\n  const attrs: SpaceToBatchNDAttrs = {blockShape, paddings};\n\n  return ENGINE.runKernel(\n      SpaceToBatchND, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n}\n\nexport const spaceToBatchND = op({spaceToBatchND_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {avgPool} from './avg_pool';\nimport {batchToSpaceND} from './batch_to_space_nd';\nimport * as conv_util from './conv_util';\nimport {maxPool} from './max_pool';\nimport {op} from './operation';\nimport {reshape} from './reshape';\nimport {spaceToBatchND} from './space_to_batch_nd';\n\n/**\n * Performs an N-D pooling operation\n *\n * @param input The input tensor, of rank 4 or rank 3 of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param windowShape The filter size: `[filterHeight, filterWidth]`. If\n *     `filterSize` is a single number, then `filterHeight == filterWidth`.\n * @param poolingType The type of pooling, either 'max' or 'avg'.\n * @param pad The type of padding algorithm:\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_guides/python/nn#Convolution](\n *         https://www.tensorflow.org/api_guides/python/nn#Convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in dilated pooling. Defaults to `[1, 1]`. If `dilationRate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param strides The strides of the pooling: `[strideHeight, strideWidth]`. If\n *     `strides` is a single number, then `strideHeight == strideWidth`.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction pool_<T extends Tensor3D|Tensor4D>(\n    input: T|TensorLike, windowShape: [number, number]|number,\n    poolingType: 'avg'|'max',\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dilations?: [number, number]|number, strides?: [number, number]|number) {\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  if (strides == null) {\n    strides = 1;\n  }\n  if (pad === 0) {\n    pad = 'valid';\n  }\n\n  const $x = convertToTensor(input, 'x', 'maxPool');\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in pool: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n\n  const convInfo = conv_util.computePool2DInfo(\n      x4D.shape, windowShape, strides, dilations, pad);\n  const dilation: [number, number] =\n      [convInfo.dilationHeight, convInfo.dilationWidth];\n\n  // The following implementation does batchToSpace(pool(spaceToBatch(x)))\n  // whenever dilation > 1 since the TF kernels do not support dilation > 1.\n  // tslint:disable-next-line:max-line-length\n  // https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L1037\n\n  let basePadding: number[][];\n  if (pad === 'same') {\n    basePadding = withSpaceToBatchBasePaddings(\n        [convInfo.filterHeight, convInfo.filterWidth], dilation);\n  } else {\n    basePadding = [[0, 0], [0, 0]];\n  }\n\n  const isDilationOne = dilation[0] === 1 && dilation[1] === 1;\n  const [adjustedPadding, adjustedCrops] = requiredSpaceToBatchPaddings(\n      [convInfo.inHeight, convInfo.inWidth], dilation, basePadding);\n  const convertedPad = isDilationOne ? pad : 'valid';\n  const convertedX =\n      isDilationOne ? x4D : spaceToBatchND(x4D, dilation, adjustedPadding);\n\n  const forwardOp = poolingType === 'avg' ?\n      () => avgPool(convertedX, windowShape, strides, convertedPad) :\n      () => maxPool(convertedX, windowShape, strides, convertedPad);\n  const y = forwardOp();\n\n  const res = isDilationOne ? y : batchToSpaceND(y, dilation, adjustedCrops);\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n\n  return res as T;\n}\n\n// Helper function to compute crops and paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/array_ops.py#L2184\nfunction requiredSpaceToBatchPaddings(\n    inputShape: [number, number], blockShape: [number, number],\n    basePadding: number[][]) {\n  const padStart = basePadding.map(b => b[0]);\n  const origPadEnd = basePadding.map(b => b[1]);\n  const fullInputShape = inputShape.concat(padStart, origPadEnd);\n  const padEndExtra = blockShape.map((b, i) => (b - fullInputShape[i] % b) % b);\n  const padEnd = origPadEnd.map((s, i) => s + padEndExtra[i]);\n  const paddings = blockShape.map((_, i) => [padStart[i], padEnd[i]]);\n  const crops = blockShape.map((_, i) => [0, padEndExtra[i]]);\n  return [paddings, crops];\n}\n\n// Helper function to compute base paddings for pool with dilation > 1.\n// tslint:disable-next-line:max-line-length\n// https://github.com/tensorflow/tensorflow/blob/50f6bb67dc98c9b74630b6047aae7a4f8a40fd02/tensorflow/python/ops/nn_ops.py#L524\nfunction withSpaceToBatchBasePaddings(\n    filterShape: [number, number], dilation: [number, number]) {\n  // Spatial dimensions of the filters and the upsampled filters in which we\n  // introduce (rate - 1) zeros between consecutive filter values.\n  const dilatedFilterShape = filterShape.map((s, i) => {\n    return s + (s - 1) * (dilation[i] - 1);\n  });\n  const padExtraShape = dilatedFilterShape.map(s => s - 1);\n\n  // When padding is odd, we pad more at end, following the same\n  // convention as conv2d.\n  const padExtraStart = padExtraShape.map(s => Math.floor(s / 2));\n  const padExtraEnd = padExtraShape.map((s, i) => s - padExtraStart[i]);\n  return padExtraShape.map((_, i) => {\n    return [padExtraStart[i], padExtraEnd[i]];\n  });\n}\n\nexport const pool = op({pool_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Pow, PowInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the power of one `tf.Tensor` to another. Supports broadcasting.\n *\n * Given a `tf.Tensor` x and a `tf.Tensor` y, this operation computes x^y for\n * corresponding elements in x and y. The result's dtype will be the upcasted\n * type of the `base` and `exp` dtypes.\n *\n * ```js\n * const a = tf.tensor([[2, 3], [4, 5]])\n * const b = tf.tensor([[1, 2], [3, 0]]).toInt();\n *\n * a.pow(b).print();  // or tf.pow(a, b)\n * ```\n *\n * ```js\n * const a = tf.tensor([[1, 2], [3, 4]])\n * const b = tf.tensor(2).toInt();\n *\n * a.pow(b).print();  // or tf.pow(a, b)\n * ```\n * We also expose `powStrict` which has the same signature as this op and\n * asserts that `base` and `exp` are the same shape (does not broadcast).\n *\n * @param base The base `tf.Tensor` to pow element-wise.\n * @param exp The exponent `tf.Tensor` to pow element-wise.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction pow_<T extends Tensor>(\n    base: Tensor|TensorLike, exp: Tensor|TensorLike): T {\n  let $base = convertToTensor(base, 'base', 'pow');\n  let $exp = convertToTensor(exp, 'exp', 'pow');\n  [$base, $exp] = makeTypesMatch($base, $exp);\n\n  const inputs: PowInputs = {a: $base, b: $exp};\n\n  return ENGINE.runKernel(Pow, inputs as {} as NamedTensorMap);\n}\n\nexport const pow = op({pow_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Prelu, PreluInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes leaky rectified linear element-wise with parametric alphas.\n *\n * `x < 0 ? alpha * x : f(x) = x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n * const alpha = tf.scalar(0.1);\n *\n * x.prelu(alpha).print();  // or tf.prelu(x, alpha)\n * ```\n * @param x The input tensor.\n * @param alpha Scaling factor for negative values.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction prelu_<T extends Tensor>(x: T|TensorLike, alpha: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'prelu');\n  const $alpha = convertToTensor(alpha, 'alpha', 'prelu');\n\n  const inputs: PreluInputs = {x: $x, alpha: $alpha};\n  return ENGINE.runKernel(Prelu, inputs as {} as NamedTensorMap);\n}\n\nexport const prelu = op({prelu_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Prod, ProdAttrs, ProdInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {cast} from './cast';\nimport {op} from './operation';\n\n/**\n * Computes the product of elements across dimensions of a `tf.Tensor`.\n *\n * Reduces the input along the dimensions given in `axes`. Unless `keepDims`\n * is true, the rank of the `tf.Tensor` is reduced by 1 for each entry in\n * `axes`. If `keepDims` is true, the reduced dimensions are retained with\n * length 1. If `axes` has no entries, all dimensions are reduced, and a\n * `tf.Tensor` with a single element is returned.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3]);\n *\n * x.prod().print();  // or tf.prod(x)\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.prod(axis).print();  // or tf.prod(x, axis)\n * ```\n *\n * @param x The input tensor to compute the product over. If the dtype is `bool`\n *   it will be converted to `int32` and the output dtype will be `int32`.\n * @param axis The dimension(s) to reduce. By default it reduces\n *     all dimensions.\n * @param keepDims If true, retains reduced dimensions with size 1.\n *\n * @doc {heading: 'Operations', subheading: 'Reduction'}\n */\nfunction prod_<T extends Tensor>(\n    x: Tensor|TensorLike, axis: number|number[] = null, keepDims = false): T {\n  let $x = convertToTensor(x, 'x', 'prod');\n\n  if ($x.dtype === 'bool') {\n    // bool is not an allowed type for the underlying kernel.\n    $x = cast($x, 'int32');\n  }\n\n  const inputs: ProdInputs = {x: $x};\n  const attrs: ProdAttrs = {axis, keepDims};\n\n  return ENGINE.runKernel(\n      Prod, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const prod = op({prod_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\nimport {sizeFromShape} from '../util';\n\nimport {op} from './operation';\n\n/**\n * Creates a `tf.Tensor` with values sampled from a random number generator\n * function defined by the user.\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param randFunction A random number generator function which is called\n * for each element in the output tensor.\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction rand_<R extends Rank>(\n    shape: ShapeMap[R], randFunction: () => number,\n    dtype?: DataType): Tensor<R> {\n  const size = sizeFromShape(shape);\n  let values = null;\n  if (dtype == null || dtype === 'float32') {\n    values = new Float32Array(size);\n  } else if (dtype === 'int32') {\n    values = new Int32Array(size);\n  } else if (dtype === 'bool') {\n    values = new Uint8Array(size);\n  } else {\n    throw new Error(`Unknown data type ${dtype}`);\n  }\n  for (let i = 0; i < size; i++) {\n    values[i] = randFunction();\n  }\n  return ENGINE.makeTensor(values, shape, dtype) as Tensor<R>;\n}\n\nexport const rand = op({rand_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as seedrandom from 'seedrandom';\n\nimport {expectNumbersClose, testEpsilon} from '../test_util';\nimport {TypedArray} from '../types';\n\nexport interface RandomBase {\n  nextValue(): number;\n}\n\nexport interface RandomGamma {\n  nextValue(): number;\n}\n\nexport interface RandNormalDataTypes {\n  float32: Float32Array;\n  int32: Int32Array;\n}\n\nexport interface RandGammaDataTypes {\n  float32: Float32Array;\n  int32: Int32Array;\n}\n\n// https://en.wikipedia.org/wiki/Marsaglia_polar_method\nexport class MPRandGauss implements RandomBase {\n  private mean: number;\n  private stdDev: number;\n  private nextVal: number;\n  private dtype?: keyof RandNormalDataTypes;\n  private truncated?: boolean;\n  private upper?: number;\n  private lower?: number;\n  private random: seedrandom.prng;\n\n  constructor(\n      mean: number, stdDeviation: number, dtype?: keyof RandNormalDataTypes,\n      truncated?: boolean, seed?: number) {\n    this.mean = mean;\n    this.stdDev = stdDeviation;\n    this.dtype = dtype;\n    this.nextVal = NaN;\n    this.truncated = truncated;\n    if (this.truncated) {\n      this.upper = this.mean + this.stdDev * 2;\n      this.lower = this.mean - this.stdDev * 2;\n    }\n    const seedValue = seed ? seed : Math.random();\n    this.random = seedrandom.alea(seedValue.toString());\n  }\n\n  /** Returns next sample from a Gaussian distribution. */\n  public nextValue(): number {\n    if (!isNaN(this.nextVal)) {\n      const value = this.nextVal;\n      this.nextVal = NaN;\n      return value;\n    }\n\n    let resultX: number, resultY: number;\n    let isValid = false;\n    while (!isValid) {\n      let v1: number, v2: number, s: number;\n      do {\n        v1 = 2 * this.random() - 1;\n        v2 = 2 * this.random() - 1;\n        s = v1 * v1 + v2 * v2;\n      } while (s >= 1 || s === 0);\n\n      const mul = Math.sqrt(-2.0 * Math.log(s) / s);\n      resultX = this.mean + this.stdDev * v1 * mul;\n      resultY = this.mean + this.stdDev * v2 * mul;\n\n      if (!this.truncated || this.isValidTruncated(resultX)) {\n        isValid = true;\n      }\n    }\n\n    if (!this.truncated || this.isValidTruncated(resultY)) {\n      this.nextVal = this.convertValue(resultY);\n    }\n    return this.convertValue(resultX);\n  }\n\n  /** Handles proper rounding for non-floating-point numbers. */\n  private convertValue(value: number): number {\n    if (this.dtype == null || this.dtype === 'float32') {\n      return value;\n    }\n    return Math.round(value);\n  }\n\n  /** Returns true if less than 2-standard-deviations from the mean. */\n  private isValidTruncated(value: number): boolean {\n    return value <= this.upper && value >= this.lower;\n  }\n}\n\n// Marsaglia, George, and Wai Wan Tsang. 2000. \"A Simple Method for Generating\n// Gamma Variables.\"\nexport class RandGamma implements RandomGamma {\n  private alpha: number;\n  private beta: number;\n  private d: number;\n  private c: number;\n  private dtype?: keyof RandGammaDataTypes;\n  private randu: seedrandom.prng;\n  private randn: MPRandGauss;\n\n  constructor(\n      alpha: number, beta: number, dtype: keyof RandGammaDataTypes,\n      seed?: number) {\n    this.alpha = alpha;\n    this.beta = 1 / beta;  // convert rate to scale parameter\n    this.dtype = dtype;\n\n    const seedValue = seed ? seed : Math.random();\n    this.randu = seedrandom.alea(seedValue.toString());\n    this.randn = new MPRandGauss(0, 1, dtype, false, this.randu());\n\n    if (alpha < 1) {\n      this.d = alpha + (2 / 3);\n    } else {\n      this.d = alpha - (1 / 3);\n    }\n    this.c = 1 / Math.sqrt(9 * this.d);\n  }\n\n  /** Returns next sample from a gamma distribution. */\n  public nextValue(): number {\n    let x2: number, v0: number, v1: number, x: number, u: number, v: number;\n    while (true) {\n      do {\n        x = this.randn.nextValue();\n        v = 1 + (this.c * x);\n      } while (v <= 0);\n      v *= v * v;\n      x2 = x * x;\n      v0 = 1 - (0.331 * x2 * x2);\n      v1 = (0.5 * x2) + (this.d * (1 - v + Math.log(v)));\n      u = this.randu();\n      if (u < v0 || Math.log(u) < v1) {\n        break;\n      }\n    }\n    v = (1 / this.beta) * this.d * v;\n    if (this.alpha < 1) {\n      v *= Math.pow(this.randu(), 1 / this.alpha);\n    }\n    return this.convertValue(v);\n  }\n  /** Handles proper rounding for non-floating-point numbers. */\n  private convertValue(value: number): number {\n    if (this.dtype === 'float32') {\n      return value;\n    }\n    return Math.round(value);\n  }\n}\n\nexport class UniformRandom implements RandomBase {\n  private min: number;\n  private range: number;\n  private random: seedrandom.prng;\n  private dtype?: keyof RandNormalDataTypes;\n\n  constructor(\n      min = 0, max = 1, dtype?: keyof RandNormalDataTypes,\n      seed?: string|number) {\n    this.min = min;\n    this.range = max - min;\n    this.dtype = dtype;\n    if (seed == null) {\n      seed = Math.random();\n    }\n    if (typeof seed === 'number') {\n      seed = seed.toString();\n    }\n\n    if (!this.canReturnFloat() && this.range <= 1) {\n      throw new Error(\n          `The difference between ${min} - ${max} <= 1 and dtype is not float`);\n    }\n    this.random = seedrandom.alea(seed);\n  }\n\n  /** Handles proper rounding for non floating point numbers. */\n  private canReturnFloat = () =>\n      (this.dtype == null || this.dtype === 'float32');\n\n  private convertValue(value: number): number {\n    if (this.canReturnFloat()) {\n      return value;\n    }\n    return Math.round(value);\n  }\n\n  nextValue() {\n    return this.convertValue(this.min + this.range * this.random());\n  }\n}\n\nexport function jarqueBeraNormalityTest(values: TypedArray|number[]) {\n  // https://en.wikipedia.org/wiki/Jarque%E2%80%93Bera_test\n  const n = values.length;\n  const s = skewness(values);\n  const k = kurtosis(values);\n  const jb = n / 6 * (Math.pow(s, 2) + 0.25 * Math.pow(k - 3, 2));\n  // JB test requires 2-degress of freedom from Chi-Square @ 0.95:\n  // http://www.itl.nist.gov/div898/handbook/eda/section3/eda3674.htm\n  const CHI_SQUARE_2DEG = 5.991;\n  if (jb > CHI_SQUARE_2DEG) {\n    throw new Error(`Invalid p-value for JB: ${jb}`);\n  }\n}\n\nexport function expectArrayInMeanStdRange(\n    actual: TypedArray|number[], expectedMean: number, expectedStdDev: number,\n    epsilon?: number) {\n  if (epsilon == null) {\n    epsilon = testEpsilon();\n  }\n  const actualMean = mean(actual);\n  expectNumbersClose(actualMean, expectedMean, epsilon);\n  expectNumbersClose(\n      standardDeviation(actual, actualMean), expectedStdDev, epsilon);\n}\n\nfunction mean(values: TypedArray|number[]) {\n  let sum = 0;\n  for (let i = 0; i < values.length; i++) {\n    sum += values[i];\n  }\n  return sum / values.length;\n}\n\nfunction standardDeviation(values: TypedArray|number[], mean: number) {\n  let squareDiffSum = 0;\n  for (let i = 0; i < values.length; i++) {\n    const diff = values[i] - mean;\n    squareDiffSum += diff * diff;\n  }\n  return Math.sqrt(squareDiffSum / values.length);\n}\n\nfunction kurtosis(values: TypedArray|number[]) {\n  // https://en.wikipedia.org/wiki/Kurtosis\n  const valuesMean = mean(values);\n  const n = values.length;\n  let sum2 = 0;\n  let sum4 = 0;\n  for (let i = 0; i < n; i++) {\n    const v = values[i] - valuesMean;\n    sum2 += Math.pow(v, 2);\n    sum4 += Math.pow(v, 4);\n  }\n  return (1 / n) * sum4 / Math.pow((1 / n) * sum2, 2);\n}\n\nfunction skewness(values: TypedArray|number[]) {\n  // https://en.wikipedia.org/wiki/Skewness\n  const valuesMean = mean(values);\n  const n = values.length;\n  let sum2 = 0;\n  let sum3 = 0;\n  for (let i = 0; i < n; i++) {\n    const v = values[i] - valuesMean;\n    sum2 += Math.pow(v, 2);\n    sum3 += Math.pow(v, 3);\n  }\n  return (1 / n) * sum3 / Math.pow((1 / (n - 1)) * sum2, 3 / 2);\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {Rank, ShapeMap} from '../types';\n\nimport {buffer} from './buffer';\nimport {op} from './operation';\nimport {RandGamma} from './rand_util';\n\n/**\n * Creates a `tf.Tensor` with values sampled from a gamma distribution.\n *\n * ```js\n * tf.randomGamma([2, 2], 1).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param alpha The shape parameter of the gamma distribution.\n * @param beta The inverse scale parameter of the gamma distribution. Defaults\n *     to 1.\n * @param dtype The data type of the output. Defaults to float32.\n * @param seed The seed for the random number generator.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction randomGamma_<R extends Rank>(\n    shape: ShapeMap[R], alpha: number, beta = 1,\n    dtype: 'float32'|'int32' = 'float32', seed?: number): Tensor<R> {\n  if (beta == null) {\n    beta = 1;\n  }\n  if (dtype == null) {\n    dtype = 'float32';\n  }\n  if (dtype !== 'float32' && dtype !== 'int32') {\n    throw new Error(`Unsupported data type ${dtype}`);\n  }\n  const rgamma = new RandGamma(alpha, beta, dtype, seed);\n  const res = buffer(shape, dtype);\n  for (let i = 0; i < res.values.length; i++) {\n    res.values[i] = rgamma.nextValue();\n  }\n  return res.toTensor();\n}\n\nexport const randomGamma = op({randomGamma_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\n\nimport {buffer} from './buffer';\nimport {op} from './operation';\nimport {MPRandGauss} from './rand_util';\n\n/**\n * Creates a `tf.Tensor` with values sampled from a normal distribution.\n *\n * ```js\n * tf.randomNormal([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param mean The mean of the normal distribution.\n * @param stdDev The standard deviation of the normal distribution.\n * @param dtype The data type of the output.\n * @param seed The seed for the random number generator.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction randomNormal_<R extends Rank>(\n    shape: ShapeMap[R], mean = 0, stdDev = 1, dtype?: 'float32'|'int32',\n    seed?: number): Tensor<R> {\n  if (dtype != null && (dtype as DataType) === 'bool') {\n    throw new Error(`Unsupported data type ${dtype}`);\n  }\n  const randGauss =\n      new MPRandGauss(mean, stdDev, dtype, false /* truncated */, seed);\n  const res = buffer(shape, dtype);\n  for (let i = 0; i < res.values.length; i++) {\n    res.values[i] = randGauss.nextValue();\n  }\n  return res.toTensor();\n}\n\nexport const randomNormal = op({randomNormal_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\n\nimport {buffer} from './buffer';\nimport {op} from './operation';\nimport {UniformRandom} from './rand_util';\n\n/**\n * Creates a `tf.Tensor` with values sampled from a uniform distribution.\n *\n * The generated values follow a uniform distribution in the range [minval,\n * maxval). The lower bound minval is included in the range, while the upper\n * bound maxval is excluded.\n *\n * ```js\n * tf.randomUniform([2, 2]).print();\n * ```\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param minval The lower bound on the range of random values to generate.\n *   Defaults to 0.\n * @param maxval The upper bound on the range of random values to generate.\n *   Defaults to 1.\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Random'}\n */\nfunction randomUniform_<R extends Rank>(\n    shape: ShapeMap[R], minval = 0, maxval = 1, dtype: DataType = 'float32',\n    seed?: number|string): Tensor<R> {\n  const res = buffer(shape, dtype);\n  const random = new UniformRandom(minval, maxval, null, seed);\n  for (let i = 0; i < res.values.length; i++) {\n    res.values[i] = random.nextValue();\n  }\n  return res.toTensor();\n}\n\nexport const randomUniform = op({randomUniform_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Range, RangeAttrs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor1D} from '../tensor';\n\n/**\n * Creates a new `tf.Tensor1D` filled with the numbers in the range provided.\n *\n * The tensor is a is half-open interval meaning it includes start, but\n * excludes stop. Decrementing ranges and negative step values are also\n * supported.sv\n *\n *\n * ```js\n * tf.range(0, 9, 2).print();\n * ```\n *\n * @param start An integer start value\n * @param stop An integer stop value\n * @param step An integer increment (will default to 1 or -1)\n * @param dtype The data type of the output tensor. Defaults to 'float32'.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function range(\n    start: number, stop: number, step = 1,\n    dtype: 'float32'|'int32' = 'float32'): Tensor1D {\n  if (step === 0) {\n    throw new Error('Cannot have a step of zero');\n  }\n\n  const attrs: RangeAttrs = {start, stop, step, dtype};\n\n  return ENGINE.runKernel(Range, {} /* inputs */, attrs as {} as NamedAttrMap);\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Real, RealInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Returns the real part of a complex (or real) tensor.\n *\n * Given a tensor input, this operation returns a tensor of type float that is\n * the real part of each element in input considered as a complex number.\n *\n * If the input is real, it simply makes a clone.\n *\n * ```js\n * const x = tf.complex([-2.25, 3.25], [4.75, 5.75]);\n * tf.real(x).print();\n * ```\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction real_<T extends Tensor>(input: T|TensorLike): T {\n  const $input = convertToTensor(input, 'input', 'real');\n\n  const inputs: RealInputs = {input: $input};\n  return ENGINE.runKernel(Real, inputs as {} as NamedTensorMap);\n}\n\nexport const real = op({real_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Reciprocal, ReciprocalInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes reciprocal of x element-wise: `1 / x`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, 2]);\n *\n * x.reciprocal().print();  // or tf.reciprocal(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction reciprocal_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'reciprocal');\n\n  const inputs: ReciprocalInputs = {x: $x};\n  return ENGINE.runKernel(Reciprocal, inputs as {} as NamedTensorMap);\n}\nexport const reciprocal = op({reciprocal_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Relu, ReluInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes rectified linear element-wise: `max(x, 0)`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.relu().print();  // or tf.relu(x)\n * ```\n * @param x The input tensor. If the dtype is `bool`, the output dtype will be\n *     `int32'.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction relu_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'relu');\n\n  const inputs: ReluInputs = {x: $x};\n\n  return ENGINE.runKernel(Relu, inputs as {} as NamedTensorMap);\n}\n\nexport const relu = op({relu_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Relu6, Relu6Inputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes rectified linear 6 element-wise: `min(max(x, 0), 6)`.\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 8]);\n *\n * x.relu6().print();  // or tf.relu6(x)\n * ```\n * @param x The input tensor. If the dtype is `bool`, the output dtype will be\n *     `int32'.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction relu6_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'relu6');\n\n  const inputs: Relu6Inputs = {x: $x};\n\n  return ENGINE.runKernel(Relu6, inputs as {} as NamedTensorMap);\n}\n\nexport const relu6 = op({relu6_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Reverse, ReverseAttrs, ReverseInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Reverses a `tf.Tensor` along a specified axis.\n *\n * Also available are stricter rank-specific methods that assert that `x` is\n * of the given rank:\n *   - `tf.reverse1d`\n *   - `tf.reverse2d`\n *   - `tf.reverse3d`\n *   - `tf.reverse4d`\n *\n * Except `tf.reverse1d` (which does not have axis param), all methods have\n * same signature as this method.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.reverse().print();\n * ```\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * const axis = 1;\n * x.reverse(axis).print();\n * ```\n * @param x The input tensor to be reversed.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction reverse_<T extends Tensor>(\n    x: T|TensorLike, axis?: number|number[]): T {\n  const $x = convertToTensor(x, 'x', 'reverse');\n\n  const inputs: ReverseInputs = {x: $x};\n  const attrs: ReverseAttrs = {dims: axis};\n\n  return ENGINE.runKernel(\n      Reverse, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const reverse = op({reverse_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\nimport {reverse} from './reverse';\n\n/**\n * Reverses a `tf.Tensor1D`.\n *\n * @param x The input tensor.\n */\nfunction reverse1d_(x: Tensor1D|TensorLike): Tensor1D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 1,\n      () => `Error in reverse1D: x must be rank 1 but got rank ${$x.rank}.`);\n  return reverse($x, 0);\n}\n\nexport const reverse1d = op({reverse1d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\nimport {reverse} from './reverse';\n\n/**\n * Reverses a `tf.Tensor2D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse2d_(x: Tensor2D|TensorLike, axis?: number|number[]): Tensor2D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 2,\n      () => `Error in reverse2D: x must be rank 2 but got rank ${$x.rank}.`);\n  return reverse($x, axis);\n}\n\nexport const reverse2d = op({reverse2d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor3D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\nimport {reverse} from './reverse';\n\n/**\n * Reverses a `tf.Tensor3D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse3d_(x: Tensor3D|TensorLike, axis?: number|number[]): Tensor3D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 3,\n      () => `Error in reverse3D: x must be rank 3 but got rank ${$x.rank}.`);\n  return reverse($x, axis);\n}\n\nexport const reverse3d = op({reverse3d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\nimport {op} from './operation';\nimport {reverse} from './reverse';\n\n/**\n * Reverses a `tf.Tensor4D` along a specified axis.\n *\n * @param x The input tensor.\n * @param axis The set of dimensions to reverse. Must be in the\n *     range [-rank(x), rank(x)). Defaults to all axes.\n */\nfunction reverse4d_(x: Tensor4D|TensorLike, axis?: number|number[]): Tensor4D {\n  const $x = convertToTensor(x, 'x', 'reverse');\n  util.assert(\n      $x.rank === 4,\n      () => `Error in reverse4D: x must be rank 4 but got rank ${$x.rank}.`);\n  return reverse($x, axis);\n}\n\nexport const reverse4d = op({reverse4d_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Round, RoundInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes round of input `tf.Tensor` element-wise: `round(x)`.\n * It implements banker's rounding.\n *\n * ```js\n * const x = tf.tensor1d([.6, 1.1, -3.3]);\n *\n * x.round().print();  // or tf.round(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction round_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'round');\n  const inputs: RoundInputs = {x: $x};\n\n  return ENGINE.runKernel(Round, inputs as {} as NamedTensorMap);\n}\n\nexport const round = op({round_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Rsqrt, RsqrtInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes reciprocal of square root of the input `tf.Tensor` element-wise:\n * `y = 1 / sqrt(x)`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 4, -1]);\n *\n * x.rsqrt().print();  // or tf.rsqrt(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction rsqrt_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'rsqrt');\n\n  const inputs: RsqrtInputs = {x: $x};\n\n  return ENGINE.runKernel(Rsqrt, inputs as {} as NamedTensorMap);\n}\nexport const rsqrt = op({rsqrt_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar} from '../tensor';\nimport {DataType} from '../types';\nimport {isTypedArray} from '../util';\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates rank-0 `tf.Tensor` (scalar) with the provided value and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.scalar` as it makes the code more readable.\n *\n * ```js\n * tf.scalar(3.14).print();\n * ```\n *\n * @param value The value of the scalar.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function scalar(\n    value: number|boolean|string|Uint8Array, dtype?: DataType): Scalar {\n  if (((isTypedArray(value) && dtype !== 'string') || Array.isArray(value)) &&\n      dtype !== 'complex64') {\n    throw new Error(\n        'Error creating a new Scalar: value must be a primitive ' +\n        '(number|boolean|string)');\n  }\n  if (dtype === 'string' && isTypedArray(value) &&\n      !(value instanceof Uint8Array)) {\n    throw new Error(\n        'When making a scalar from encoded string, ' +\n        'the value must be `Uint8Array`.');\n  }\n  const shape: number[] = [];\n  const inferredShape: number[] = [];\n  return makeTensor(value, shape, inferredShape, dtype) as Scalar;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Selu, SeluInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes scaled exponential linear element-wise.\n *\n * `x < 0 ? scale * alpha * (exp(x) - 1) : x`\n *\n * ```js\n * const x = tf.tensor1d([-1, 2, -3, 4]);\n *\n * x.selu().print();  // or tf.selu(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction selu_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'selu');\n\n  const inputs: SeluInputs = {x: $x};\n\n  return ENGINE.runKernel(Selu, inputs as {} as NamedTensorMap);\n}\n\nexport const selu = op({selu_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {conv2d} from './conv2d';\nimport {depthwiseConv2d} from './depthwise_conv2d';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * 2-D convolution with separable filters.\n *\n * Performs a depthwise convolution that acts separately on channels followed\n * by a pointwise convolution that mixes channels. Note that this is\n * separability between dimensions [1, 2] and 3, not spatial separability\n * between dimensions 1 and 2.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/separable_conv2d)\n * for more details.\n *\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param depthwiseFilter The depthwise filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`. This is\n *     the filter used in the first step.\n * @param pointwiseFilter The pointwise filter tensor, rank 4, of shape\n *     `[1, 1, inChannels * channelMultiplier, outChannels]`. This is\n *     the filter used in the second step.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n *\n * @doc {heading: 'Operations', subheading: 'Convolution'}\n */\nfunction separableConv2d_<T extends Tensor3D|Tensor4D>(\n    x: T|TensorLike, depthwiseFilter: Tensor4D|TensorLike,\n    pointwiseFilter: Tensor4D|TensorLike, strides: [number, number]|number,\n    pad: 'valid'|'same', dilation: [number, number]|number = [1, 1],\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC'): T {\n  const $x = convertToTensor(x, 'x', 'separableConv2d');\n  const $depthwiseFilter =\n      convertToTensor(depthwiseFilter, 'depthwiseFilter', 'separableConv2d');\n  const $pointwiseFilter =\n      convertToTensor(pointwiseFilter, 'pointwiseFilter', 'separableConv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n\n  if (dataFormat === 'NCHW') {\n    throw new Error(\n        'separableConv2d currently does not support dataFormat NCHW; only ' +\n        'NHWC is supported');\n  }\n\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in separableConv2d: input must be rank 4, but got ` +\n          `rank ${x4D.rank}.`);\n  util.assert(\n      $depthwiseFilter.rank === 4,\n      () => `Error in separableConv2d: depthwise filter must be rank 4, but ` +\n          `got rank ${$depthwiseFilter.rank}.`);\n  util.assert(\n      $pointwiseFilter.rank === 4,\n      () => `Error in separableConv2d: pointwise filter must be rank 4, but ` +\n          `got rank ${$depthwiseFilter.rank}.`);\n  util.assert(\n      $pointwiseFilter.shape[0] === 1,\n      () =>\n          `Error in separableConv2d: the first dimension of pointwise filter ` +\n          ` must be 1, but got ${$pointwiseFilter.shape[0]}.`);\n  util.assert(\n      $pointwiseFilter.shape[1] === 1,\n      () => `Error in separableConv2d: the second dimension of pointwise ` +\n          `filter must be 1, but got ${$pointwiseFilter.shape[1]}.`);\n\n  const inChannels = $depthwiseFilter.shape[2];\n  const channelMultiplier = $depthwiseFilter.shape[3];\n  util.assert(\n      $pointwiseFilter.shape[2] === inChannels * channelMultiplier,\n      () =>\n          `Error in separableConv2d: the third dimension of pointwise filter ` +\n          `must be ${inChannels * channelMultiplier}, ` +\n          `but got ${$pointwiseFilter.shape[2]}.`);\n\n  const depthwise = depthwiseConv2d(\n      x4D, $depthwiseFilter, strides, pad, dataFormat, dilation);\n  const pointwiseStride = 1;\n  const res =\n      conv2d(depthwise, $pointwiseFilter, pointwiseStride, 'valid', dataFormat);\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res as T;\n}\n\nexport const separableConv2d = op({separableConv2d_});\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor, TensorBuffer} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\n/**\n * Computes the difference between two lists of numbers.\n *\n * Given a Tensor `x` and a Tensor `y`, this operation returns a Tensor `out`\n * that represents all values that are in `x` but not in `y`. The returned\n * Tensor `out` is sorted in the same order that the numbers appear in `x`\n * (duplicates are preserved). This operation also returns a Tensor indices that\n * represents the position of each out element in `x`. In other words:\n *\n * `out[i] = x[idx[i]] for i in [0, 1, ..., out.length - 1]`\n *\n * ```js\n * const x = [1, 2, 3, 4, 5, 6];\n * const y = [1, 3, 5];\n *\n * const [out, indices] = await tf.setdiff1dAsync(x, y);\n * out.print(); // [2, 4, 6]\n * indices.print(); // [1, 3, 5]\n * ```\n *\n * @param x 1-D Tensor. Values to keep.\n * @param y 1-D Tensor. Must have the same type as x. Values to exclude in the\n *     output.\n * @returns Promise of Tensor tuple [out, indices].\n *  out: Tensor with the same type as x.\n *  indices: A Tensor of type int32.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nasync function setdiff1dAsync_(\n    x: Tensor|TensorLike, y: Tensor|TensorLike): Promise<[Tensor, Tensor]> {\n  const $x = convertToTensor(x, 'x', 'setdiff1d');\n  const $y = convertToTensor(y, 'y', 'setdiff1d');\n\n  util.assert(\n      $x.dtype === $y.dtype,\n      () => `x and y should have the same dtype, but got x (${\n          $x.dtype}) and y (${$y.dtype}).`);\n\n  util.assert(\n      $x.rank === 1, () => `x should be 1D tensor, but got x (${$x.shape}).`);\n\n  util.assert(\n      $y.rank === 1, () => `y should be 1D tensor, but got y (${$y.shape}).`);\n\n  const xVals = await $x.data();\n  const yVals = await $y.data();\n  const ySet = new Set(yVals);\n\n  let outputSize = 0;\n  for (let i = 0; i < xVals.length; i++) {\n    if (!ySet.has(xVals[i])) {\n      outputSize++;\n    }\n  }\n\n  const buffer = new TensorBuffer([outputSize], $x.dtype);\n  const indices = new TensorBuffer([outputSize], 'int32');\n  for (let i = 0, p = 0; i < xVals.length; i++) {\n    if (!ySet.has(xVals[i])) {\n      buffer.values[p] = xVals[i];\n      indices.values[p] = i;\n      p++;\n    }\n  }\n  return [buffer.toTensor(), indices.toTensor()];\n}\nexport const setdiff1dAsync = setdiff1dAsync_;\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Sign, SignInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Returns an element-wise indication of the sign of a number.\n *\n * ```js\n * const x = tf.tensor1d([.6, 1.1, -3.3, NaN, 0]);\n *\n * x.sign().print();  // or tf.sign(x)\n * ```\n * @param x The input Tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sign_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'sign');\n  const inputs: SignInputs = {x: $x};\n  return ENGINE.runKernel(Sign, inputs as {} as NamedTensorMap);\n}\nexport const sign = op({sign_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Sin, SinInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes sin of the input Tensor element-wise: `sin(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n *\n * x.sin().print();  // or tf.sin(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sin_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'sin');\n\n  const inputs: SinInputs = {x: $x};\n\n  return ENGINE.runKernel(Sin, inputs as {} as NamedTensorMap);\n}\nexport const sin = op({sin_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Sinh, SinhInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes hyperbolic sin of the input `tf.Tensor` element-wise: `sinh(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, 1, -1, .7]);\n *\n * x.sinh().print();  // or tf.sinh(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sinh_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'sinh');\n  const inputs: SinhInputs = {x: $x};\n\n  return ENGINE.runKernel(Sinh, inputs as {} as NamedTensorMap);\n}\nexport const sinh = op({sinh_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {slice} from './slice';\n\n/**\n * Extracts a 1D slice from 1D array starting at coordinates `begin` and is\n * of length `size`. See `slice` for details.\n */\nfunction slice1d_(\n    x: Tensor1D|TensorLike, begin: number, size: number): Tensor1D {\n  const $x = convertToTensor(x, 'x', 'slice1d');\n  util.assert(\n      $x.rank === 1,\n      () =>\n          `slice1d expects a rank-1 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, [begin], [size]);\n}\nexport const slice1d = op({slice1d_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {slice} from './slice';\n\n/**\n * Extracts a 2D slice from a 2D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice2d_(\n    x: Tensor2D|TensorLike, begin: [number, number],\n    size: [number, number]): Tensor2D {\n  const $x = convertToTensor(x, 'x', 'slice2d');\n  util.assert(\n      $x.rank === 2,\n      () =>\n          `slice2d expects a rank-2 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\nexport const slice2d = op({slice2d_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor3D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {slice} from './slice';\n\n/**\n * Extracts a 3D slice from a 3D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice3d_(\n    x: Tensor3D|TensorLike, begin: [number, number, number],\n    size: [number, number, number]): Tensor3D {\n  const $x = convertToTensor(x, 'x', 'slice3d');\n  util.assert(\n      $x.rank === 3,\n      () =>\n          `slice3d expects a rank-3 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\nexport const slice3d = op({slice3d_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor4D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\nimport {slice} from './slice';\n\n/**\n * Extracts a 4D slice from a 4D array starting at coordinates `begin` and\n * is of size `size`. See `slice` for details.\n */\nfunction slice4d_(\n    x: Tensor4D|TensorLike, begin: [number, number, number, number],\n    size: [number, number, number, number]): Tensor4D {\n  const $x = convertToTensor(x, 'x', 'slice4d');\n  util.assert(\n      $x.rank === 4,\n      () =>\n          `slice4d expects a rank-4 tensor, but got a rank-${$x.rank} tensor`);\n  return slice($x, begin, size);\n}\nexport const slice4d = op({slice4d_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Softmax, SoftmaxAttrs, SoftmaxInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes the softmax normalized vector given the logits.\n *\n * ```js\n * const a = tf.tensor1d([1, 2, 3]);\n *\n * a.softmax().print();  // or tf.softmax(a)\n * ```\n *\n * ```js\n * const a = tf.tensor2d([2, 4, 6, 1, 2, 3], [2, 3]);\n *\n * a.softmax().print();  // or tf.softmax(a)\n * ```\n *\n * @param logits The logits array.\n * @param dim The dimension softmax would be performed on. Defaults to `-1`\n *     which indicates the last dimension.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction softmax_<T extends Tensor>(logits: T|TensorLike, dim = -1): T {\n  const $logits = convertToTensor(logits, 'logits', 'softmax', 'float32');\n\n  if (dim === -1) {\n    dim = $logits.rank - 1;\n  }\n  if (dim !== $logits.rank - 1) {\n    throw Error(\n        'Softmax along a non-last dimension is not yet supported. ' +\n        `Logits was rank ${$logits.rank} and dim was ${dim}`);\n  }\n\n  const inputs: SoftmaxInputs = {logits: $logits};\n  const attrs: SoftmaxAttrs = {dim};\n\n  return ENGINE.runKernel(\n      Softmax, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const softmax = op({softmax_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {FFT, FFTInputs} from '../../kernel_names';\nimport {Tensor} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {assert} from '../../util';\nimport {op} from '../operation';\n\n/**\n * Fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the inner-most\n * dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.fft().print();  // tf.spectral.fft(x).print();\n * ```\n * @param input The complex input to compute an fft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction fft_(input: Tensor): Tensor {\n  assert(\n      input.dtype === 'complex64',\n      () => `The dtype for tf.spectral.fft() must be complex64 ` +\n          `but got ${input.dtype}.`);\n\n  const inputs: FFTInputs = {input};\n\n  return ENGINE.runKernel(FFT, inputs as {} as NamedTensorMap);\n}\n\nexport const fft = op({fft_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {IFFT, IFFTInputs} from '../../kernel_names';\nimport {Tensor} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {assert} from '../../util';\nimport {op} from '../operation';\n\n/**\n * Inverse fast Fourier transform.\n *\n * Computes the inverse 1-dimensional discrete Fourier transform over the\n * inner-most dimension of input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([1, 2, 3]);\n * const x = tf.complex(real, imag);\n *\n * x.ifft().print();  // tf.spectral.ifft(x).print();\n * ```\n * @param input The complex input to compute an ifft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction ifft_(input: Tensor): Tensor {\n  assert(\n      input.dtype === 'complex64',\n      () => `The dtype for tf.spectral.ifft() must be complex64 ` +\n          `but got ${input.dtype}.`);\n\n  const inputs: IFFTInputs = {input};\n\n  return ENGINE.runKernel(IFFT, inputs as {} as NamedTensorMap);\n}\n\nexport const ifft = op({ifft_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor, Tensor2D} from '../../tensor';\nimport {complex} from '../complex';\nimport {concat} from '../concat';\nimport {imag} from '../imag';\nimport {mul} from '../mul';\nimport {op} from '../operation';\nimport {real} from '../real';\nimport {reshape} from '../reshape';\nimport {reverse} from '../reverse';\nimport {scalar} from '../scalar';\nimport {slice} from '../slice';\n\nimport {ifft} from './ifft';\n\n/**\n * Inversed real value input fast Fourier transform.\n *\n * Computes the 1-dimensional inversed discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n * const imag = tf.tensor1d([0, 0, 0]);\n * const x = tf.complex(real, imag);\n *\n * x.irfft().print();\n * ```\n * @param input The real value input to compute an irfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction irfft_(input: Tensor): Tensor {\n  const innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n  let ret: Tensor;\n  if (innerDimensionSize <= 2) {\n    const complexInput = reshape(input, [batch, innerDimensionSize]);\n    ret = ifft(complexInput);\n  } else {\n    // The length of unique components of the DFT of a real-valued signal\n    // is 2 * (input_len - 1)\n    const outputShape = [batch, 2 * (innerDimensionSize - 1)];\n    const realInput = reshape(real(input), [batch, innerDimensionSize]);\n    const imagInput = reshape(imag(input), [batch, innerDimensionSize]);\n\n    const realConjugate =\n        reverse(slice(realInput, [0, 1], [batch, innerDimensionSize - 2]), 1);\n    const imagConjugate: Tensor2D = mul(\n        reverse(slice(imagInput, [0, 1], [batch, innerDimensionSize - 2]), 1),\n        scalar(-1));\n\n    const r = concat([realInput, realConjugate], 1);\n    const i = concat([imagInput, imagConjugate], 1);\n    const complexInput =\n        reshape(complex(r, i), [outputShape[0], outputShape[1]]);\n    ret = ifft(complexInput);\n  }\n  ret = real(ret);\n  // reshape the result if the input is 3D tensor.\n  if (input.rank === 3 && input.shape[0] !== 0) {\n    const temp = ret;\n    const batch = input.shape[0];\n    ret = reshape(ret, [batch, ret.shape[0] / batch, ret.shape[1]]);\n    temp.dispose();\n  }\n  return ret;\n}\n\nexport const irfft = op({irfft_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {SplitV, SplitVAttrs, SplitVInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Splits a `tf.Tensor` into sub tensors.\n *\n * If `numOrSizeSplits` is a number, splits `x` along dimension `axis`\n * into `numOrSizeSplits` smaller tensors.\n * Requires that `numOrSizeSplits` evenly divides `x.shape[axis]`.\n *\n * If `numOrSizeSplits` is a number array, splits `x` into\n * `numOrSizeSplits.length` pieces. The shape of the `i`-th piece has the\n * same size as `x` except along dimension `axis` where the size is\n * `numOrSizeSplits[i]`.\n *\n * ```js\n * const x = tf.tensor2d([1, 2, 3, 4, 5, 6, 7, 8], [2, 4]);\n * const [a, b] = tf.split(x, 2, 1);\n * a.print();\n * b.print();\n *\n * const [c, d, e] = tf.split(x, [1, 2, 1], 1);\n * c.print();\n * d.print();\n * e.print();\n * ```\n *\n * @param x The input tensor to split.\n * @param numOrSizeSplits Either an integer indicating the number of\n * splits along the axis or an array of integers containing the sizes of\n * each output tensor along the axis. If a number then it must evenly divide\n * `x.shape[axis]`; otherwise the sum of sizes must match `x.shape[axis]`.\n * Can contain one -1 indicating that dimension is to be inferred.\n * @param axis The dimension along which to split. Defaults to 0 (the first\n * dim).\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction split_<T extends Tensor>(\n    x: Tensor|TensorLike, numOrSizeSplits: number[]|number, axis = 0): T[] {\n  const $x = convertToTensor(x, 'x', 'split');\n\n  const inputs: SplitVInputs = {x: $x};\n  const attr: SplitVAttrs = {numOrSizeSplits, axis};\n\n  return ENGINE.runKernel(\n             SplitV, inputs as {} as NamedTensorMap,\n             attr as {} as NamedAttrMap) as {} as T[];\n}\n\nexport const split = op({split_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {assert} from '../../util';\nimport {complex} from '../complex';\nimport {concat} from '../concat';\nimport {imag} from '../imag';\nimport {op} from '../operation';\nimport {real} from '../real';\nimport {reshape} from '../reshape';\nimport {slice} from '../slice';\nimport {split} from '../split';\nimport {zeros} from '../zeros';\nimport {zerosLike} from '../zeros_like';\n\nimport {fft} from './fft';\n\n/**\n * Real value input fast Fourier transform.\n *\n * Computes the 1-dimensional discrete Fourier transform over the\n * inner-most dimension of the real input.\n *\n * ```js\n * const real = tf.tensor1d([1, 2, 3]);\n *\n * real.rfft().print();\n * ```\n * @param input The real value input to compute an rfft over.\n *\n * @doc {heading: 'Operations', subheading: 'Spectral', namespace: 'spectral'}\n */\nfunction rfft_(input: Tensor, fftLength?: number): Tensor {\n  assert(\n      input.dtype === 'float32',\n      () => `The dtype for rfft() must be real value but got ${input.dtype}`);\n\n  let innerDimensionSize = input.shape[input.shape.length - 1];\n  const batch = input.size / innerDimensionSize;\n\n  let adjustedInput: Tensor;\n  if (fftLength != null && fftLength < innerDimensionSize) {\n    // Need to crop\n    const begin = input.shape.map(v => 0);\n    const size = input.shape.map(v => v);\n    size[input.shape.length - 1] = fftLength;\n    adjustedInput = slice(input, begin, size);\n    innerDimensionSize = fftLength;\n  } else if (fftLength != null && fftLength > innerDimensionSize) {\n    // Need to pad with zeros\n    const zerosShape = input.shape.map(v => v);\n    zerosShape[input.shape.length - 1] = fftLength - innerDimensionSize;\n    adjustedInput = concat([input, zeros(zerosShape)], input.shape.length - 1);\n    innerDimensionSize = fftLength;\n  } else {\n    adjustedInput = input;\n  }\n\n  // Complement the input with zero imaginary numbers.\n  const zerosInput = zerosLike(adjustedInput);\n  const complexInput =\n      reshape(complex(adjustedInput, zerosInput), [batch, innerDimensionSize]);\n\n  const ret = fft(complexInput);\n\n  // Exclude complex conjugations. These conjugations are put symmetrically.\n  const half = Math.floor(innerDimensionSize / 2) + 1;\n  const realValues = real(ret);\n  const imagValues = imag(ret);\n  const realComplexConjugate = split(\n      realValues, [half, innerDimensionSize - half],\n      realValues.shape.length - 1);\n  const imagComplexConjugate = split(\n      imagValues, [half, innerDimensionSize - half],\n      imagValues.shape.length - 1);\n\n  const outputShape = adjustedInput.shape.slice();\n  outputShape[adjustedInput.shape.length - 1] = half;\n\n  return reshape(\n      complex(realComplexConjugate[0], imagComplexConjugate[0]), outputShape);\n}\n\nexport const rfft = op({rfft_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Sqrt, SqrtInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes square root of the input `tf.Tensor` element-wise: `y = sqrt(x)`\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 4, -1]);\n *\n * x.sqrt().print();  // or tf.sqrt(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction sqrt_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'sqrt');\n\n  const inputs: SqrtInputs = {x: $x};\n\n  return ENGINE.runKernel(Sqrt, inputs as {} as NamedTensorMap);\n}\nexport const sqrt = op({sqrt_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {SquaredDifference, SquaredDifferenceInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {makeTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {assertAndGetBroadcastShape} from './broadcast_util';\nimport {op} from './operation';\n\n/**\n * Returns (a - b) * (a - b) element-wise.\n * Supports broadcasting.\n *\n * ```js\n * const a = tf.tensor1d([1, 4, 3, 16]);\n * const b = tf.tensor1d([1, 2, 9, 4]);\n *\n * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n * ```\n *\n * ```js\n * // Broadcast squared difference  a with b.\n * const a = tf.tensor1d([2, 4, 6, 8]);\n * const b = tf.scalar(5);\n *\n * a.squaredDifference(b).print();  // or tf.squaredDifference(a, b)\n * ```\n *\n * @param a The first tensor.\n * @param b The second tensor. Must have the same type as `a`.\n *\n * @doc {heading: 'Operations', subheading: 'Arithmetic'}\n */\nfunction squaredDifference_<T extends Tensor>(\n    a: Tensor|TensorLike, b: Tensor|TensorLike): T {\n  let $a = convertToTensor(a, 'a', 'squaredDifference');\n  let $b = convertToTensor(b, 'b', 'squaredDifference');\n  [$a, $b] = makeTypesMatch($a, $b);\n\n  assertAndGetBroadcastShape($a.shape, $b.shape);\n\n  const inputs: SquaredDifferenceInputs = {a: $a, b: $b};\n  const attrs = {};\n\n  return ENGINE.runKernel(\n      SquaredDifference, inputs as unknown as NamedTensorMap, attrs);\n}\n\nexport const squaredDifference = op({squaredDifference_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {squeezeShape} from '../util';\n\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Removes dimensions of size 1 from the shape of a `tf.Tensor`.\n *\n * ```js\n * const x = tf.tensor([1, 2, 3, 4], [1, 1, 4]);\n * x.squeeze().print();\n * ```\n *\n * @param x The input tensor to be squeezed.\n * @param axis An optional list of numbers. If specified, only\n *     squeezes the dimensions listed. The dimension index starts at 0. It\n * is an error to squeeze a dimension that is not 1.\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction squeeze_<T extends Tensor>(x: Tensor|TensorLike, axis?: number[]): T {\n  const $x = convertToTensor(x, 'x', 'squeeze');\n  return reshape($x, squeezeShape($x.shape, axis).newShape) as T;\n}\n\nexport const squeeze = op({squeeze_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Pack, PackAttrs, PackInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensorArray} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Stacks a list of rank-`R` `tf.Tensor`s into one rank-`(R+1)` `tf.Tensor`.\n *\n * ```js\n * const a = tf.tensor1d([1, 2]);\n * const b = tf.tensor1d([3, 4]);\n * const c = tf.tensor1d([5, 6]);\n * tf.stack([a, b, c]).print();\n * ```\n *\n * @param tensors A list of tensor objects with the same shape and dtype.\n * @param axis The axis to stack along. Defaults to 0 (the first dim).\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction stack_<T extends Tensor>(\n    tensors: Array<T|TensorLike>, axis = 0): Tensor {\n  const $tensors =\n      convertToTensorArray(tensors, 'tensors', 'stack', 'string_or_numeric');\n\n  util.assert(\n      $tensors.length >= 1, () => 'Pass at least one tensor to tf.stack');\n\n  if ($tensors.length > 0) {\n    util.assert(\n        axis <= $tensors[0].rank, () => 'Axis must be <= rank of the tensor');\n  }\n\n  const inputs: PackInputs = $tensors;\n  const attrs: PackAttrs = {axis};\n\n  return ENGINE.runKernel(\n      Pack, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const stack = op({stack_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Step, StepAttrs, StepInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes step of the input `tf.Tensor` element-wise: `x > 0 ? 1 : alpha * x`\n *\n * ```js\n * const x = tf.tensor1d([0, 2, -1, -3]);\n *\n * x.step(.5).print();  // or tf.step(x, .5)\n * ```\n * @param x The input tensor.\n * @param alpha The gradient when input is negative.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction step_<T extends Tensor>(x: T|TensorLike, alpha = 0.0): T {\n  const $x = convertToTensor(x, 'x', 'step');\n\n  const inputs: StepInputs = {x: $x};\n  const attrs: StepAttrs = {alpha};\n\n  return ENGINE.runKernel(\n      Step, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\nexport const step = op({step_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {StridedSlice, StridedSliceAttrs, StridedSliceInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Extracts a strided slice of a tensor.\n *\n * Roughly speaking, this op extracts a slice of size (end-begin)/stride from\n * the given input tensor (x). Starting at the location specified by begin the\n * slice continues by adding stride to the index until all dimensions are not\n * less than end. Note that a stride can be negative, which causes a reverse\n * slice.\n *\n * ```js\n * const t = tf.tensor3d([1, 1, 1 ,2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6],\n *    [3, 2, 3]);\n * t.stridedSlice([1, 0, 0], [2, 1, 3], [1, 1, 1]).print()  // [[[3, 3, 3]]]\n * t.stridedSlice([1, 0, 0], [2, 2, 3], [1, 1, 1]).print()  // [[[3, 3, 3],\n *                                                     // [4, 4, 4]]]\n * t.stridedSlice([1, -1, 0], [2, -3, 3], [1, -1, 1]).print() // [[[4, 4, 4],\n *                                                     // [3, 3, 3]]]\n * ```\n *\n * @param x The tensor to stride slice.\n * @param begin The coordinates to start the slice from.\n * @param end: The coordinates to end the slice at.\n * @param strides: The size of the slice.\n * @param beginMask: If the ith bit of beginMask is set, begin[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param endMask: If the ith bit of endMask is set, end[i] is ignored\n *      and the fullest possible range in that dimension is used instead.\n * @param shrinkAxisMask: a bitmask where bit i implies that\n * the ith specification should shrink the dimensionality. begin and end must\n * imply a slice of size 1 in the dimension.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction stridedSlice_(\n    x: Tensor|TensorLike, begin: number[], end: number[], strides?: number[],\n    beginMask = 0, endMask = 0, ellipsisMask = 0, newAxisMask = 0,\n    shrinkAxisMask = 0): Tensor {\n  const $x = convertToTensor(x, 'x', 'stridedSlice', 'string_or_numeric');\n\n  const inputs: StridedSliceInputs = {x: $x};\n  const attrs: StridedSliceAttrs = {\n    begin,\n    end,\n    strides,\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  };\n\n  return ENGINE.runKernel(\n      StridedSlice, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n}\n\nexport const stridedSlice = op({stridedSlice_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tan, TanInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Computes tan of the input `tf.Tensor` element-wise, `tan(x)`\n *\n * ```js\n * const x = tf.tensor1d([0, Math.PI / 2, Math.PI * 3 / 4]);\n *\n * x.tan().print();  // or tf.tan(x)\n * ```\n * @param x The input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Basic math'}\n */\nfunction tan_<T extends Tensor>(x: T|TensorLike): T {\n  const $x = convertToTensor(x, 'x', 'tan');\n\n  const inputs: TanInputs = {x: $x};\n\n  return ENGINE.runKernel(Tan, inputs as {} as NamedTensorMap);\n}\nexport const tan = op({tan_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D} from '../tensor';\nimport {inferShape} from '../tensor_util_env';\nimport {TensorLike1D} from '../types';\nimport {DataType} from '../types';\nimport {assertNonNull} from '../util';\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates rank-1 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor1d` as it makes the code more readable.\n *\n * ```js\n * tf.tensor1d([1, 2, 3]).print();\n * ```\n *\n * @param values The values of the tensor. Can be array of numbers,\n *     or a `TypedArray`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor1d(values: TensorLike1D, dtype?: DataType): Tensor1D {\n  assertNonNull(values);\n  const inferredShape = inferShape(values, dtype);\n  if (inferredShape.length !== 1) {\n    throw new Error('tensor1d() requires values to be a flat/TypedArray');\n  }\n  const shape: number[] = null;\n  return makeTensor(values, shape, inferredShape, dtype) as Tensor1D;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D} from '../tensor';\nimport {inferShape} from '../tensor_util_env';\nimport {TensorLike2D} from '../types';\nimport {DataType} from '../types';\nimport {assertNonNull} from '../util';\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates rank-2 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor2d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor2d([[1, 2], [3, 4]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor2d([1, 2, 3, 4], [2, 2]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. If not provided, it is inferred from\n *     `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor2d(\n    values: TensorLike2D, shape?: [number, number],\n    dtype?: DataType): Tensor2D {\n  assertNonNull(values);\n  if (shape != null && shape.length !== 2) {\n    throw new Error('tensor2d() requires shape to have two numbers');\n  }\n  const inferredShape = inferShape(values, dtype);\n  if (inferredShape.length !== 2 && inferredShape.length !== 1) {\n    throw new Error(\n        'tensor2d() requires values to be number[][] or flat/TypedArray');\n  }\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error(\n        'tensor2d() requires shape to be provided when `values` ' +\n        'are a flat/TypedArray');\n  }\n  return makeTensor(values, shape, inferredShape, dtype) as Tensor2D;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor4D} from '../tensor';\nimport {inferShape} from '../tensor_util_env';\nimport {TensorLike4D} from '../types';\nimport {DataType} from '../types';\nimport {assertNonNull} from '../util';\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates rank-4 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor4d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor4d([[[[1], [2]], [[3], [4]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor4d([1, 2, 3, 4], [1, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor4d(\n    values: TensorLike4D, shape?: [number, number, number, number],\n    dtype?: DataType): Tensor4D {\n  assertNonNull(values);\n  if (shape != null && shape.length !== 4) {\n    throw new Error('tensor4d() requires shape to have four numbers');\n  }\n  const inferredShape = inferShape(values, dtype);\n  if (inferredShape.length !== 4 && inferredShape.length !== 1) {\n    throw new Error(\n        'tensor4d() requires values to be number[][][][] or flat/TypedArray');\n  }\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error(\n        'tensor4d() requires shape to be provided when `values` ' +\n        'are a flat array');\n  }\n  return makeTensor(values, shape, inferredShape, dtype) as Tensor4D;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor5D} from '../tensor';\nimport {inferShape} from '../tensor_util_env';\nimport {TensorLike5D} from '../types';\nimport {DataType} from '../types';\nimport {assertNonNull} from '../util';\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates rank-5 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor5d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor5d([[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor5d([1, 2, 3, 4, 5, 6, 7, 8], [1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor5d(\n    values: TensorLike5D, shape?: [number, number, number, number, number],\n    dtype?: DataType): Tensor5D {\n  assertNonNull(values);\n  if (shape != null && shape.length !== 5) {\n    throw new Error('tensor5d() requires shape to have five numbers');\n  }\n  const inferredShape = inferShape(values, dtype);\n  if (inferredShape.length !== 5 && inferredShape.length !== 1) {\n    throw new Error(\n        'tensor5d() requires values to be ' +\n        'number[][][][][] or flat/TypedArray');\n  }\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error(\n        'tensor5d() requires shape to be provided when `values` ' +\n        'are a flat array');\n  }\n  return makeTensor(values, shape, inferredShape, dtype) as Tensor5D;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor6D} from '../tensor';\nimport {inferShape} from '../tensor_util_env';\nimport {TensorLike6D} from '../types';\nimport {DataType} from '../types';\nimport {assertNonNull} from '../util';\nimport {makeTensor} from './tensor_ops_util';\n\n/**\n * Creates rank-6 `tf.Tensor` with the provided values, shape and dtype.\n *\n * The same functionality can be achieved with `tf.tensor`, but in general\n * we recommend using `tf.tensor6d` as it makes the code more readable.\n *\n *  ```js\n * // Pass a nested array.\n * tf.tensor6d([[[[[[1],[2]],[[3],[4]]],[[[5],[6]],[[7],[8]]]]]]).print();\n * ```\n * ```js\n * // Pass a flat array and specify a shape.\n * tf.tensor6d([1, 2, 3, 4, 5, 6, 7, 8], [1, 1, 2, 2, 2, 1]).print();\n * ```\n *\n * @param values The values of the tensor. Can be nested array of numbers,\n *     or a flat array, or a `TypedArray`.\n * @param shape The shape of the tensor. Optional. If not provided,\n *   it is inferred from `values`.\n * @param dtype The data type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function tensor6d(\n    values: TensorLike6D,\n    shape?: [number, number, number, number, number, number],\n    dtype?: DataType): Tensor6D {\n  assertNonNull(values);\n  if (shape != null && shape.length !== 6) {\n    throw new Error('tensor6d() requires shape to have six numbers');\n  }\n  const inferredShape = inferShape(values, dtype);\n  if (inferredShape.length !== 6 && inferredShape.length !== 1) {\n    throw new Error(\n        'tensor6d() requires values to be number[][][][][][] or ' +\n        'flat/TypedArray');\n  }\n  if (inferredShape.length === 1 && shape == null) {\n    throw new Error(\n        'tensor6d() requires shape to be provided when `values` ' +\n        'are a flat array');\n  }\n  shape = shape ||\n      inferredShape as [number, number, number, number, number, number];\n  return makeTensor(values, shape, inferredShape, dtype) as Tensor6D;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {TopK, TopKAttrs, TopKInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Finds the values and indices of the `k` largest entries along the last\n * dimension.\n *\n * If the input is a vector (rank=1), finds the k largest entries in the vector\n * and outputs their values and indices as vectors. Thus values[j] is the j-th\n * largest entry in input, and its index is indices[j].\n * For higher rank inputs, computes the top k entries along the last dimension.\n *\n * If two elements are equal, the lower-index element appears first.\n *\n * ```js\n * const a = tf.tensor2d([[1, 5], [4, 3]]);\n * const {values, indices} = tf.topk(a);\n * values.print();\n * indices.print();\n * ```\n * @param x 1-D or higher `tf.Tensor` with last dimension being at least `k`.\n * @param k Number of top elements to look for along the last dimension.\n * @param sorted If true, the resulting `k` elements will be sorted by the\n *     values in descending order.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nfunction topk_<T extends Tensor>(\n    x: T|TensorLike, k = 1, sorted = true): {values: T, indices: T} {\n  const $x = convertToTensor(x, 'x', 'topk');\n  if ($x.rank === 0) {\n    throw new Error('topk() expects the input to be of rank 1 or higher');\n  }\n  const lastDim = $x.shape[$x.shape.length - 1];\n\n  if (k < 0) {\n    throw new Error(`'k' passed to topk() must be >= 0 but got ${k}`);\n  }\n\n  if (k > lastDim) {\n    throw new Error(\n        `'k' passed to topk() must be <= the last dimension (${lastDim}) ` +\n        `but got ${k}`);\n  }\n\n  const inputs: TopKInputs = {x: $x};\n  const attrs: TopKAttrs = {k, sorted};\n\n  const [values, indices] = ENGINE.runKernel(\n      TopK, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n\n  return {values, indices} as {values: T, indices: T};\n}\n\nexport const topk = op({topk_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {DataType, Rank, ShapeMap} from '../types';\n\nimport {buffer} from './buffer';\nimport {op} from './operation';\nimport {MPRandGauss} from './rand_util';\n\n/**\n * Creates a `tf.Tensor` with values sampled from a truncated normal\n * distribution.\n *\n * ```js\n * tf.truncatedNormal([2, 2]).print();\n * ```\n *\n * The generated values follow a normal distribution with specified mean and\n * standard deviation, except that values whose magnitude is more than 2\n * standard deviations from the mean are dropped and re-picked.\n *\n * @param shape An array of integers defining the output tensor shape.\n * @param mean The mean of the normal distribution.\n * @param stdDev The standard deviation of the normal distribution.\n * @param dtype The data type of the output tensor.\n * @param seed The seed for the random number generator.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nfunction truncatedNormal_<R extends Rank>(\n    shape: ShapeMap[R], mean = 0, stdDev = 1, dtype?: 'float32'|'int32',\n    seed?: number): Tensor<R> {\n  if (dtype != null && (dtype as DataType) === 'bool') {\n    throw new Error(`Unsupported data type $ { dtype }`);\n  }\n  const randGauss =\n      new MPRandGauss(mean, stdDev, dtype, true /* truncated */, seed);\n  const res = buffer(shape, dtype);\n  for (let i = 0; i < res.values.length; i++) {\n    res.values[i] = randGauss.nextValue();\n  }\n  return res.toTensor();\n}\n\nexport const truncatedNormal = op({truncatedNormal_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Unique, UniqueAttrs, UniqueInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor, Tensor1D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert} from '../util';\n\nimport {op} from './operation';\n\n/**\n * Finds unique elements along an axis of a tensor.\n *\n * It returns a tensor `values` containing all of the unique elements along the\n * `axis` of the given tensor `x` in the same order that they occur along the\n * `axis` in `x`; `x` does not need to be sorted. It also returns a tensor\n * `indices` the same size as the number of the elements in `x` along the `axis`\n * dimension. It contains the index in the unique output `values`.\n *\n * ```js\n * // A 1-D tensor\n * const a = tf.tensor1d([1, 1, 2, 4, 4, 4, 7, 8, 8]);\n * const {values, indices} = tf.unique(a);\n * values.print();   // [1, 2, 4, 7, 8,]\n * indices.print();  // [0, 0, 1, 2, 2, 2, 3, 4, 4]\n * ```\n *\n * ```js\n * // A 2-D tensor with axis=0\n * //\n * // 'a' is: [[1, 0, 0],\n * //          [1, 0, 0],\n * //          [2, 0, 0]]\n * const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);\n * const {values, indices} = tf.unique(a, 0)\n * values.print();   // [[1, 0, 0],\n *                   //  [2, 0, 0]]\n * indices.print();  // [0, 0, 1]\n * ```\n *\n * ```js\n * // A 2-D tensor with axis=1\n * //\n * // 'a' is: [[1, 0, 0],\n * //          [1, 0, 0],\n * //          [2, 0, 0]]\n * const a = tf.tensor2d([[1, 0, 0], [1, 0, 0], [2, 0, 0]]);\n * const {values, indices} = tf.unique(a, 1)\n * values.print();   // [[1, 0],\n *                   //  [1, 0],\n *                   //  [2, 0]]\n * indices.print();  // [0, 1, 1]\n * ```\n * @param x A tensor (int32, string, bool).\n * @param axis The axis of the tensor to find the unique elements.\n * @returns [uniqueElements, indices] (see above for details)\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nfunction unique_<T extends Tensor>(\n    x: T|TensorLike, axis = 0): {values: T, indices: Tensor1D} {\n  const $x = convertToTensor(x, 'x', 'unique', 'string_or_numeric');\n  assert($x.rank > 0, () => 'The input tensor must be at least 1D');\n\n  const inputs: UniqueInputs = {x: $x};\n  const attrs: UniqueAttrs = {axis};\n  const [values, indices] = ENGINE.runKernel(\n                                Unique, inputs as {} as NamedTensorMap,\n                                attrs as {} as NamedAttrMap) as [T, Tensor1D];\n  return {values, indices};\n}\n\nexport const unique = op({unique_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {UnsortedSegmentSum, UnsortedSegmentSumAttrs, UnsortedSegmentSumInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor, Tensor1D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert, isInt} from '../util';\n\nimport {op} from './operation';\n\n/**\n * Computes the sum along segments of a `tf.Tensor`.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n * const segmentIds = tf.tensor1d([1, 2, 0, 1], 'int32');\n * const numSegments = 3;\n *\n * x.unsortedSegmentSum(segmentIds, numSegments).print()\n * //or tf.unsortedSegmentSum(x, segmentIds, numSegments)\n * ```\n * @param x The `tf.Tensor` that will be summed along its segments.\n * @param segmentIds A `tf.Tensor1D` whose rank is equal to the rank of `x`'s\n * dimension along the `axis`.  Maps each element of `x` to a segment.\n * @param numSegments The number of distinct `segmentIds`.\n *\n * @doc {heading: 'Operations', subheading: 'Segment'}\n */\nfunction unsortedSegmentSum_<T extends Tensor>(\n    x: T|TensorLike, segmentIds: Tensor1D|TensorLike, numSegments: number): T {\n  const $x = convertToTensor(x, 'x', 'unsortedSegmentSum');\n  const $segmentIds =\n      convertToTensor(segmentIds, 'segmentIds', 'unsortedSegmentSum', 'int32');\n  assert(isInt(numSegments), () => 'numSegments must be of dtype int');\n\n  const inputs: UnsortedSegmentSumInputs = {x: $x, segmentIds: $segmentIds};\n  const attrs: UnsortedSegmentSumAttrs = {numSegments};\n\n  return ENGINE.runKernel(\n      UnsortedSegmentSum, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n}\n\nexport const unsortedSegmentSum = op({unsortedSegmentSum_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Unpack, UnpackAttrs, UnpackInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {op} from './operation';\n\n/**\n * Unstacks a `tf.Tensor` of rank-`R` into a list of rank-`(R-1)` `tf.Tensor`s.\n *\n * ```js\n * const a = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n *\n * tf.unstack(a).forEach(tensor => tensor.print());\n * ```\n *\n * @param x A tensor object.\n * @param axis The axis to unstack along. Defaults to 0 (the first dim).\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nfunction unstack_(x: Tensor|TensorLike, axis = 0): Tensor[] {\n  const $x = convertToTensor(x, 'x', 'unstack', 'string_or_numeric');\n  util.assert(\n      axis >= -$x.shape.length && axis < $x.shape.length,\n      () =>\n          `Axis = ${axis} is not in [-${$x.shape.length}, ${$x.shape.length})`);\n\n  const inputs: UnpackInputs = {value: $x};\n  const attrs: UnpackAttrs = {axis};\n\n  return ENGINE.runKernel(\n      Unpack, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const unstack = op({unstack_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor, Variable} from '../tensor';\nimport {DataType, Rank} from '../types';\n\n/**\n * Creates a new variable with the provided initial value.\n * ```js\n * const x = tf.variable(tf.tensor([1, 2, 3]));\n * x.assign(tf.tensor([4, 5, 6]));\n *\n * x.print();\n * ```\n *\n * @param initialValue Initial value for the tensor.\n * @param trainable If true, optimizers are allowed to update it.\n * @param name Name of the variable. Defaults to a unique id.\n * @param dtype If set, initialValue will be converted to the given type.\n *\n * @doc {heading: 'Tensors', subheading: 'Creation'}\n */\nexport function variable<R extends Rank>(\n    initialValue: Tensor<R>, trainable = true, name?: string,\n    dtype?: DataType): Variable<R> {\n  return ENGINE.makeVariable(initialValue, trainable, name, dtype) as\n      Variable<R>;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/** An implementation of the Where kernel shared between cpu and webgl */\n\nimport {buffer} from '../ops/buffer';\nimport {Tensor2D} from '../tensor';\nimport {TypedArray} from '../types';\n\nexport function whereImpl(condShape: number[], condVals: TypedArray): Tensor2D {\n  const indices = [];\n  for (let i = 0; i < condVals.length; i++) {\n    if (condVals[i]) {\n      indices.push(i);\n    }\n  }\n\n  const inBuffer = buffer(condShape, 'int32');\n\n  const out = buffer([indices.length, condShape.length], 'int32');\n  for (let i = 0; i < indices.length; i++) {\n    const loc = inBuffer.indexToLoc(indices[i]);\n    const offset = i * condShape.length;\n    out.values.set(loc, offset);\n  }\n  return out.toTensor() as Tensor2D;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {whereImpl} from '../backends/where_impl';\nimport {Tensor, Tensor2D} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\n\n/**\n * Returns the coordinates of true elements of condition.\n *\n * The coordinates are returned in a 2-D tensor where the first dimension (rows)\n * represents the number of true elements, and the second dimension (columns)\n * represents the coordinates of the true elements. Keep in mind, the shape of\n * the output tensor can vary depending on how many true values there are in\n * input. Indices are output in row-major order. The resulting tensor has the\n * shape `[numTrueElems, condition.rank]`.\n *\n * This is analogous to calling the python `tf.where(cond)` without an x or y.\n *\n * ```js\n * const cond = tf.tensor1d([false, false, true], 'bool');\n * const result = await tf.whereAsync(cond);\n * result.print();\n * ```\n *\n * @doc {heading: 'Operations', subheading: 'Logical'}\n */\nasync function whereAsync_(condition: Tensor|TensorLike): Promise<Tensor2D> {\n  const $condition =\n      convertToTensor(condition, 'condition', 'whereAsync', 'bool');\n  const vals = await $condition.data();\n  const res = whereImpl($condition.shape, vals);\n  if (condition !== $condition) {\n    $condition.dispose();\n  }\n  return res;\n}\n\nexport const whereAsync = whereAsync_;\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {gather} from './gather';\nimport {reshape} from './reshape';\nimport {squeeze} from './squeeze';\nimport {whereAsync} from './where_async';\n\n/**\n * Apply boolean mask to tensor.\n *\n * ```js\n * const tensor = tf.tensor2d([1, 2, 3, 4, 5, 6], [3, 2]);\n * const mask = tf.tensor1d([1, 0, 1], 'bool');\n * const result = await tf.booleanMaskAsync(tensor, mask);\n * result.print();\n * ```\n *\n * @param tensor N-D tensor.\n * @param mask K-D boolean tensor, K <= N and K must be known statically.\n * @param axis A 0-D int Tensor representing the axis in tensor to mask from.\n *     By default, axis is 0 which will mask from the first dimension.\n *     Otherwise K + axis <= N.\n *\n * @doc {heading: 'Tensors', subheading: 'Slicing and Joining'}\n */\nasync function booleanMaskAsync_(\n    tensor: Tensor|TensorLike, mask: Tensor|TensorLike,\n    axis?: number): Promise<Tensor> {\n  const $tensor = convertToTensor(tensor, 'tensor', 'boolMask');\n  const $mask = convertToTensor(mask, 'mask', 'boolMask', 'bool');\n\n  const axisFrom = axis == null ? 0 : axis;\n  const maskDim = $mask.rank;\n  const tensorShape = $tensor.shape;\n\n  util.assert(maskDim > 0, () => 'mask cannot be scalar');\n  util.assertShapesMatch(\n      tensorShape.slice(axisFrom, axisFrom + maskDim), $mask.shape,\n      `mask's shape must match the first K dimensions of tensor's shape,`);\n\n  let leadingSize = 1;\n  for (let i = axisFrom; i < axisFrom + maskDim; i++) {\n    leadingSize *= tensorShape[i];\n  }\n  const targetTensorShape =\n      tensorShape.slice(0, axisFrom)\n          .concat([leadingSize], tensorShape.slice(axisFrom + maskDim));\n  const reshapedTensor = reshape($tensor, targetTensorShape);\n  const reshapedMask = reshape($mask, [-1]);\n  const positivePositions = await whereAsync(reshapedMask);\n  const indices = squeeze(positivePositions, [1]);\n\n  const res = gather(reshapedTensor, indices, axisFrom);\n\n  // Ensure no memory leak.\n  if (tensor !== $tensor) {\n    $tensor.dispose();\n  }\n  if (mask !== $mask) {\n    $mask.dispose();\n  }\n  indices.dispose();\n  reshapedTensor.dispose();\n  reshapedMask.dispose();\n  positivePositions.dispose();\n\n  return res;\n}\n\nexport const booleanMaskAsync = booleanMaskAsync_;\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {parseAxisParam} from '../util';\n\nimport {abs} from './abs';\nimport * as axis_util from './axis_util';\nimport {max} from './max';\nimport {min} from './min';\nimport {op} from './operation';\nimport {pow} from './pow';\nimport {reshape} from './reshape';\nimport {scalar} from './scalar';\nimport {sqrt} from './sqrt';\nimport {square} from './square';\nimport {sum} from './sum';\n\n/**\n * Computes the norm of scalar, vectors, and matrices.\n * This function can compute several different vector norms (the 1-norm, the\n * Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0)\n * and matrix norms (Frobenius, 1-norm, and inf-norm).\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 3, 4]);\n *\n * x.norm().print();  // or tf.norm(x)\n * ```\n *\n * @param x The input array.\n * @param ord Optional. Order of the norm. Supported norm types are\n * following:\n *\n *  | ord        | norm for matrices         | norm for vectors\n *  |------------|---------------------------|---------------------\n *  |'euclidean' |Frobenius norm             |2-norm\n *  |'fro'       |Frobenius norm\t           |\n *  |Infinity    |max(sum(abs(x), axis=1))   |max(abs(x))\n *  |-Infinity   |min(sum(abs(x), axis=1))   |min(abs(x))\n *  |1           |max(sum(abs(x), axis=0))   |sum(abs(x))\n *  |2           |                           |sum(abs(x)^2)^1/2*\n *\n * @param axis Optional. If axis is null (the default), the input is\n * considered a vector and a single vector norm is computed over the entire\n * set of values in the Tensor, i.e. norm(x, ord) is equivalent\n * to norm(x.reshape([-1]), ord). If axis is a integer, the input\n * is considered a batch of vectors, and axis determines the axis in x\n * over which to compute vector norms. If axis is a 2-tuple of integer it is\n * considered a batch of matrices and axis determines the axes in NDArray\n * over which to compute a matrix norm.\n * @param keepDims Optional. If true, the norm have the same dimensionality\n * as the input.\n *\n * @doc {heading: 'Operations', subheading: 'Matrices'}\n */\nfunction norm_(\n    x: Tensor|TensorLike, ord: number|'euclidean'|'fro' = 'euclidean',\n    axis: number|number[] = null, keepDims = false): Tensor {\n  x = convertToTensor(x, 'x', 'norm');\n\n  const norm = normImpl(x, ord, axis);\n  let keepDimsShape = norm.shape;\n  if (keepDims) {\n    const axes = parseAxisParam(axis, x.shape);\n    keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);\n  }\n  return reshape(norm, keepDimsShape);\n}\n\nfunction normImpl(\n    x: Tensor, p: number|string, axis: number|number[] = null): Tensor {\n  if (x.rank === 0) {\n    return abs(x);\n  }\n\n  // consider vector when no axis is specified\n  if (x.rank !== 1 && axis === null) {\n    return normImpl(reshape(x, [-1]), p, axis);\n  }\n\n  // vector\n  if (x.rank === 1 || typeof axis === 'number' ||\n      Array.isArray(axis) && axis.length === 1) {\n    if (p === 1) {\n      return sum(abs(x), axis);\n    }\n    if (p === Infinity) {\n      return max(abs(x), axis);\n    }\n    if (p === -Infinity) {\n      return min(abs(x), axis);\n    }\n    if (p === 'euclidean' || p === 2) {\n      // norm(x, 2) = sum(abs(xi) ^ 2) ^ 1/2\n      return sqrt(sum(pow(abs(x), scalar(2, 'int32')), axis));\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n\n  // matrix (assumption axis[0] < axis[1])\n  if (Array.isArray(axis) && axis.length === 2) {\n    if (p === 1) {\n      return max(sum(abs(x), axis[0]), axis[1] - 1);\n    }\n    if (p === Infinity) {\n      return max(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === -Infinity) {\n      return min(sum(abs(x), axis[1]), axis[0]);\n    }\n    if (p === 'fro' || p === 'euclidean') {\n      // norm(x) = sqrt(sum(pow(x, 2)))\n      return sqrt(sum(square(x), axis));\n    }\n\n    throw new Error(`Error in norm: invalid ord value: ${p}`);\n  }\n\n  throw new Error(`Error in norm: invalid axis: ${axis}`);\n}\n\nexport const norm = op({norm_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Scalar, Tensor} from '../tensor';\nimport {assertTypesMatch} from '../tensor_util';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {add} from './add';\nimport {div} from './div';\nimport {mul} from './mul';\nimport {op} from './operation';\nimport {pow} from './pow';\nimport {scalar} from './scalar';\nimport {sub} from './sub';\n\n/**\n * Compute the moving average of a variable.\n *\n * Without zeroDebias, the moving average operation is defined by:\n *   `v += delta`\n * where\n *   `delta = (1 - decay) * (x - v)`\n *\n * With zeroDebias (default), the `delta` term is scaled to debias the\n * effect of the (assumed) zero-initialization of `v`.\n *   `delta /= (1 - decay ^ step)`\n *\n * For more details on the zero-debiasing algorithm, see:\n *   https://arxiv.org/abs/1412.6980\n *\n * Note that this function is completely stateless and does not keep track of\n * step count. The step count needs to be maintained by the caller and passed\n * in as `step`.\n *\n * @param v The current moving average value.\n * @param x New input value, must have the same shape and dtype as `v`.\n * @param decay The decay factor. Typical values are 0.95 and 0.99.\n * @param step Step count.\n * @param zeroDebias: Whether zeroDebias is to be performed (default: `true`).\n * @returns The new moving average value.\n *\n * @doc {heading: 'Operations', subheading: 'Moving Average'}\n */\nfunction movingAverage_<T extends Tensor>(\n    v: T|TensorLike, x: T|TensorLike, decay: number|Scalar,\n    step?: number|Scalar, zeroDebias = true): T {\n  const $v = convertToTensor(v, 'v', 'movingAverage');\n  const $x = convertToTensor(x, 'x', 'movingAverage');\n  const $decay = convertToTensor(decay, 'decay', 'movingAverage');\n\n  assertTypesMatch($v, $x);\n  util.assert(\n      util.arraysEqual($v.shape, $x.shape), () => 'Shape mismatch in v and x');\n\n  const one = scalar(1);\n  const oneMinusDecay = sub(one, $decay);\n\n  let update = mul(sub($x, $v), oneMinusDecay);\n  if (zeroDebias) {\n    util.assert(\n        step != null, () => 'When using zeroDebias: true, step is required.');\n    const $step = convertToTensor(step, 'step', 'movingAverage');\n    update = div(update, sub(one, pow($decay, $step)));\n  }\n  return add($v, update);\n}\n\nexport const movingAverage = op({movingAverage_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {ScatterNd, ScatterNdAttrs, ScatterNdInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, ShapeMap, TensorLike} from '../types';\n\nimport {op} from './operation';\nimport * as scatter_nd_util from './scatter_nd_util';\n\n/**\n * Creates a new tensor by applying sparse updates to individual\n * values or slices within a zero tensor of the given shape tensor according to\n * indices. This operator is the inverse of the `tf.gatherND` operator which\n * extracts values or slices from a given tensor.\n *\n * ```js\n * const indices = tf.tensor2d([4, 3, 1, 7], [4, 1], 'int32');\n * const updates = tf.tensor1d([9, 10, 11, 12]);\n * const shape = [8];\n * tf.scatterND(indices, updates, shape).print() //[0, 11, 0, 10, 9, 0, 0, 12]\n * ```\n *\n * @param indices The tensor contains the indices into the output tensor.\n * @param updates The tensor contains the value for the indices.\n * @param shape: The shape of the output tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction scatterND_<R extends Rank>(\n    indices: Tensor|TensorLike, updates: Tensor|TensorLike,\n    shape: ShapeMap[R]): Tensor<R> {\n  const $indices = convertToTensor(indices, 'indices', 'scatterND', 'int32');\n  const $updates = convertToTensor(updates, 'updates', 'scatterND');\n  scatter_nd_util.validateInput($updates, $indices, shape);\n\n  const inputs: ScatterNdInputs = {indices: $indices, updates: $updates};\n  const attrs: ScatterNdAttrs = {shape};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  return ENGINE.runKernel(\n             ScatterNd, inputs as {} as NamedTensorMap,\n             attrs as {} as NamedAttrMap) as Tensor<R>;\n}\n\nexport const scatterND = op({scatterND_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../tensor';\n\n/**\n * Validate sparseToDense inputs.\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape number[]. Shape of the dense output tensor.\n * @param validateIndices boolean. indice validation is not supported, error\n * will be thrown if it is set.\n */\nexport function validateInput(\n    sparseIndices: Tensor, sparseValues: Tensor, outputShape: number[],\n    defaultValues: Tensor) {\n  if (sparseIndices.dtype !== 'int32') {\n    throw new Error(\n        'tf.sparseToDense() expects the indices to be int32 type,' +\n        ` but the dtype was ${sparseIndices.dtype}.`);\n  }\n  if (sparseIndices.rank > 2) {\n    throw new Error(\n        'sparseIndices should be a scalar, vector, or matrix,' +\n        ` but got shape ${sparseIndices.shape}.`);\n  }\n\n  const numElems = sparseIndices.rank > 0 ? sparseIndices.shape[0] : 1;\n  const numDims = sparseIndices.rank > 1 ? sparseIndices.shape[1] : 1;\n\n  if (outputShape.length !== numDims) {\n    throw new Error(\n        'outputShape has incorrect number of elements:,' +\n        ` ${outputShape.length}, should be: ${numDims}.`);\n  }\n\n  const numValues = sparseValues.size;\n  if (!(sparseValues.rank === 0 ||\n        sparseValues.rank === 1 && numValues === numElems)) {\n    throw new Error(\n        'sparseValues has incorrect shape ' +\n        `${sparseValues.shape}, should be [] or [${numElems}]`);\n  }\n\n  if (sparseValues.dtype !== defaultValues.dtype) {\n    throw new Error('sparseValues.dtype must match defaultValues.dtype');\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {SparseToDense, SparseToDenseAttrs, SparseToDenseInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport * as sparse_to_dense from '../ops/sparse_to_dense_util';\nimport {Scalar, Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {Rank, ScalarLike, ShapeMap, TensorLike} from '../types';\n\nimport {op} from './operation';\n\n/**\n * Converts a sparse representation into a dense tensor.\n *\n * Builds an array dense with shape outputShape such that:\n *\n * // If sparseIndices is scalar\n * dense[i] = (i == sparseIndices ? sparseValues : defaultValue)\n *\n * // If sparseIndices is a vector, then for each i\n * dense[sparseIndices[i]] = sparseValues[i]\n *\n * // If sparseIndices is an n by d matrix, then for each i in [0, n)\n * dense[sparseIndices[i][0], ..., sparseIndices[i][d-1]] = sparseValues[i]\n * All other values in dense are set to defaultValue. If sparseValues is a\n * scalar, all sparse indices are set to this single value.\n *\n * If indices are repeated the final value is summed over all values for those\n * indices.\n *\n * ```js\n * const indices = tf.tensor1d([4, 5, 6, 1, 2, 3], 'int32');\n * const values = tf.tensor1d([10, 11, 12, 13, 14, 15], 'float32');\n * const shape = [8];\n * tf.sparseToDense(indices, values, shape).print();\n * ```\n *\n * @param sparseIndices A 0-D, 1-D, or 2-D Tensor of type int32.\n * sparseIndices[i] contains the complete index where sparseValues[i] will be\n * placed.\n * @param sparseValues A 0-D or 1-D Tensor. Values\n * corresponding to each row of sparseIndices, or a scalar value to be used for\n * all sparse indices.\n * @param outputShape Shape of the dense output tensor. the type is inferred.\n * @param defaultValue Scalar. Value to set for indices not specified in\n * sparseIndices. Defaults to zero.\n *\n * @doc {heading: 'Operations', subheading: 'Normalization'}\n */\nfunction sparseToDense_<R extends Rank>(\n    sparseIndices: Tensor|TensorLike, sparseValues: Tensor|TensorLike,\n    outputShape: ShapeMap[R], defaultValue: Scalar|ScalarLike = 0): Tensor<R> {\n  const $sparseIndices =\n      convertToTensor(sparseIndices, 'sparseIndices', 'sparseToDense', 'int32');\n  const $sparseValues =\n      convertToTensor(sparseValues, 'sparseValues', 'sparseToDense');\n  const $defaultValue = convertToTensor(\n      defaultValue, 'defaultValue', 'sparseToDense', $sparseValues.dtype);\n\n  sparse_to_dense.validateInput(\n      $sparseIndices, $sparseValues, outputShape, $defaultValue);\n\n  const inputs: SparseToDenseInputs = {\n    sparseIndices: $sparseIndices,\n    sparseValues: $sparseValues,\n    defaultValue: $defaultValue\n  };\n\n  const attrs: SparseToDenseAttrs = {outputShape};\n\n  return ENGINE.runKernel(\n      SparseToDense, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n}\n\nexport const sparseToDense = op({sparseToDense_});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {GatherNd, GatherNdInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Gather slices from input tensor into a Tensor with shape specified by\n * `indices`.\n *\n * `indices` is an K-dimensional integer tensor, best thought of as a\n * (K-1)-dimensional tensor of indices into input, where each element defines a\n * slice of input:\n * output[\\\\(i_0, ..., i_{K-2}\\\\)] = input[indices[\\\\(i_0, ..., i_{K-2}\\\\)]]\n *\n * Whereas in `tf.gather`, `indices` defines slices into the first dimension of\n * input, in `tf.gatherND`, `indices` defines slices into the first N dimensions\n * of input, where N = indices.shape[-1].\n *\n * The last dimension of indices can be at most the rank of input:\n * indices.shape[-1] <= input.rank\n *\n * The last dimension of `indices` corresponds to elements\n * (if indices.shape[-1] == input.rank) or slices\n * (if indices.shape[-1] < input.rank) along dimension indices.shape[-1] of\n * input.\n * The output tensor has shape\n * indices.shape[:-1] + input.shape[indices.shape[-1]:]\n *\n * Note that on CPU, if an out of bound index is found, an error is returned. On\n * GPU, if an out of bound index is found, a 0 is stored in the corresponding\n * output value.\n *\n * ```js\n * const indices = tf.tensor2d([0, 1, 1, 0], [2,2], 'int32');\n * const input = tf.tensor2d([9, 10, 11, 12], [2, 2]);\n * tf.gatherND(input, indices).print() // [10, 11]\n * ```\n *\n * @param x The tensor from which to gather values.\n * @param indices Index tensor, must be of type int32.\n *\n * @doc {heading: 'Operations', subheading: 'Slicing and Joining'}\n */\nfunction gatherND_(x: Tensor|TensorLike, indices: Tensor|TensorLike): Tensor {\n  const $indices = convertToTensor(indices, 'indices', 'gatherND', 'int32');\n  const $x = convertToTensor(x, 'x', 'gatherND', 'string_or_numeric');\n\n  const inputs: GatherNdInputs = {params: $x, indices: $indices};\n\n  return ENGINE.runKernel(GatherNd, inputs as {} as NamedTensorMap);\n}\n\nexport const gatherND = op({gatherND_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport * as util from '../util';\n\n/**\n * Normalize noise shape based on provided tensor and noise shape.\n *\n * @param x Tensor.\n * @param noiseShape The shape for the randomly generated keep/drop flags, as\n *   an array of numbers. Optional.\n * @returns Normalized noise shape.\n */\nexport function getNoiseShape(x: Tensor, noiseShape?: number[]): number[] {\n  if (noiseShape == null) {\n    return x.shape.slice();\n  }\n  if (util.arraysEqual(x.shape, noiseShape)) {\n    return noiseShape;\n  }\n  if (x.shape.length === noiseShape.length) {\n    const newDimension: number[] = [];\n    for (let i = 0; i < x.shape.length; i++) {\n      if (noiseShape[i] == null && x.shape[i] != null) {\n        newDimension.push(x.shape[i]);\n      } else {\n        newDimension.push(noiseShape[i]);\n      }\n    }\n    return newDimension;\n  }\n\n  return noiseShape;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport * as util from '../util';\n\nimport {add} from './add';\nimport {div} from './div';\nimport {getNoiseShape} from './dropout_util';\nimport {floor} from './floor';\nimport {mul} from './mul';\nimport {op} from './operation';\nimport {randomUniform} from './random_uniform';\n\n/**\n * Computes dropout.\n *\n * ```js\n * const x = tf.tensor1d([1, 2, 2, 1]);\n * const rate = 0.75;\n * const output = tf.dropout(x, rate);\n * output.print();\n * ```\n *\n * @param x A floating point Tensor or TensorLike.\n * @param rate A float in the range [0, 1). The probability that each element\n *   of x is discarded.\n * @param noiseShape An array of numbers of type int32, representing the\n * shape for randomly generated keep/drop flags. If the noiseShape has null\n * value, it will be automatically replaced with the x's relative dimension\n * size. Optional.\n * @param seed Used to create random seeds. Optional.\n * @returns A Tensor of the same shape of x.\n *\n * @doc {heading: 'Operations', subheading: 'Dropout'}\n */\nfunction dropout_(\n    x: Tensor|TensorLike, rate: number, noiseShape?: number[],\n    seed?: number|string): Tensor {\n  const $x = convertToTensor(x, 'x', 'dropout');\n\n  util.assert(\n      $x.dtype === 'float32',\n      () => `x has to be a floating point tensor since it's going to be ` +\n          `scaled, but got a ${$x.dtype} tensor instead.`);\n  util.assert(\n      rate >= 0 && rate < 1,\n      () => `rate must be a float in the range [0, 1), but got ${rate}.`);\n\n  if (rate === 0) {\n    return x instanceof Tensor ? $x.clone() : $x;\n  }\n\n  const $noiseShape = getNoiseShape($x, noiseShape);\n  const keepProb = 1 - rate;\n  const multiplier = div(\n      floor(add(randomUniform($noiseShape, 0, 1, 'float32', seed), keepProb)),\n      keepProb);\n\n  return mul($x, multiplier);\n}\n\nexport const dropout = op({dropout_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D} from '../tensor';\nimport {tensor1d} from './tensor1d';\n\nexport function enclosingPowerOfTwo(value: number) {\n  // Return 2**N for integer N such that 2**N >= value.\n  return Math.floor(Math.pow(2, Math.ceil(Math.log(value) / Math.log(2.0))));\n}\n\nexport function cosineWindow(\n    windowLength: number, a: number, b: number): Tensor1D {\n  const even = 1 - windowLength % 2;\n  const newValues = new Float32Array(windowLength);\n  for (let i = 0; i < windowLength; ++i) {\n    const cosArg = (2.0 * Math.PI * i) / (windowLength + even - 1);\n    newValues[i] = a - b * Math.cos(cosArg);\n  }\n  return tensor1d(newValues, 'float32');\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {assert, assertShapesMatch, getTypedArrayFromDType} from '../util';\nimport {tensor} from './tensor';\n\n/**\n * Returns whether the targets are in the top K predictions.\n *\n * ```js\n * const predictions = tf.tensor2d([[20, 10, 40, 30], [30, 50, -20, 10]]);\n * const targets = tf.tensor1d([2, 0]);\n * const precision = await tf.inTopKAsync(predictions, targets);\n * precision.print();\n * ```\n * @param predictions 2-D or higher `tf.Tensor` with last dimension being\n *     at least `k`.\n * @param targets 1-D or higher `tf.Tensor`.\n * @param k Optional Number of top elements to look at for computing precision,\n *     default to 1.\n *\n * @doc {heading: 'Operations', subheading: 'Evaluation'}\n */\nasync function inTopKAsync_<T extends Tensor, U extends Tensor>(\n    predictions: T|TensorLike, targets: U|TensorLike, k = 1): Promise<U> {\n  const $predictions = convertToTensor(predictions, 'predictions', 'inTopK');\n  const $targets = convertToTensor(targets, 'targets', 'inTopK');\n\n  assert(\n      $predictions.rank > 1,\n      () => 'inTopK() expects the predictions to be of rank 2 or higher, ' +\n          `but got ${$predictions.rank}`);\n  assert(\n      $predictions.rank - 1 === $targets.rank,\n      () => `predictions rank should be 1 larger than ` +\n          `targets rank, but got predictions rank ` +\n          `${$predictions.rank} and targets rank ${$targets.rank}`);\n  assertShapesMatch(\n      $predictions.shape.slice(0, $predictions.shape.length - 1),\n      $targets.shape,\n      `predictions's shape should be align with the targets' shape, ` +\n          'except the last dimension.');\n  const lastDim = $predictions.shape[$predictions.shape.length - 1];\n  assert(\n      k > 0 && k <= lastDim,\n      () => `'k' passed to inTopK() must be > 0 && <= the predictions last ` +\n          `dimension (${lastDim}), but got ${k}`);\n\n  const predictionsVals = await $predictions.data();\n  const targetsVals = await $targets.data();\n\n  // Reshape predictionsVals into a 2d tensor [batch, lastDim]\n  // and look up topK along lastDim.\n  const [batch, size] = [predictionsVals.length / lastDim, lastDim];\n  const precision = getTypedArrayFromDType('bool', batch);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = predictionsVals.subarray(offset, offset + size);\n    const valAndInd: Array<{value: number, index: number}> = [];\n    for (let i = 0; i < vals.length; i++) {\n      valAndInd.push({value: vals[i], index: i});\n    }\n    valAndInd.sort((a, b) => b.value - a.value);\n\n    precision[b] = 0;\n    for (let i = 0; i < k; i++) {\n      if (valAndInd[i].index === targetsVals[b]) {\n        precision[b] = 1;\n        break;\n      }\n    }\n  }\n\n  if (predictions !== $predictions) {\n    $predictions.dispose();\n  }\n  if (targets !== $targets) {\n    $targets.dispose();\n  }\n\n  // Output precision has the same shape as targets.\n  return tensor(precision, $targets.shape, 'bool') as U;\n}\n\nexport const inTopKAsync = inTopKAsync_;\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {Conv2DBackpropFilter, Conv2DBackpropFilterAttrs, Conv2DBackpropFilterInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport * as util from '../util';\n\nimport * as conv_util from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\n/**\n * Computes the derivative of the filter of a 2D convolution.\n *\n * @param x The input tensor, of rank 4 or rank 3 of shape\n *     [batch, height, width, inChannels]. If rank 3, batch of 1 is assumed.\n * @param dy The dy image, of rank 4 or rank 3, of shape\n *     [batch, height, width, outDepth]. If rank 3, batch of 1 is assumed.\n * @param filterShape The shape of the filter, length 4,\n *     [filterHeight, filterWidth, inDepth, outDepth].\n * @param strides The strides of the convolution: [strideHeight,\n * strideWidth].\n * @param pad A string from: 'same', 'valid'. The type of padding algorithm\n *     used in the forward prop of the op.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels].\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction conv2DBackpropFilter_<T extends Tensor3D|Tensor4D>(\n    x: T, dy: T, filterShape: [number, number, number, number],\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n    dataFormat: 'NHWC'|'NCHW' = 'NHWC',\n    dimRoundingMode?: 'floor'|'round'|'ceil'): Tensor4D {\n  let x4D = x as Tensor4D;\n  if (x.rank === 3) {\n    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\n  }\n  let dy4D = dy as Tensor4D;\n  if (dy4D.rank === 3) {\n    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in conv2dDerFilter: input must be rank 4, but got shape ` +\n          `${x4D.shape}.`);\n  util.assert(\n      dy4D.rank === 4,\n      () => `Error in conv2dDerFilter: dy must be rank 4, but got shape ` +\n          `${dy4D.shape}.`);\n  util.assert(\n      filterShape.length === 4,\n      () => `Error in conv2dDerFilter: filterShape must be length 4, but got ` +\n          `${filterShape}.`);\n  const inDepth = dataFormat === 'NHWC' ? x4D.shape[3] : x4D.shape[1];\n  const outDepth = dataFormat === 'NHWC' ? dy4D.shape[3] : dy4D.shape[1];\n  util.assert(\n      inDepth === filterShape[2],\n      () => `Error in conv2dDerFilter: depth of input ${inDepth}) must ` +\n          `match input depth in filter (${filterShape[2]}.`);\n  util.assert(\n      outDepth === filterShape[3],\n      () => `Error in conv2dDerFilter: depth of dy (${outDepth}) must ` +\n          `match output depth for filter (${filterShape[3]}).`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in conv2dDerFilter: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const inputs: Conv2DBackpropFilterInputs = {x: x4D, dy: dy4D};\n  const attrs: Conv2DBackpropFilterAttrs =\n      {strides, pad, dataFormat, dimRoundingMode, filterShape};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  return ENGINE.runKernel(\n             Conv2DBackpropFilter, inputs as {} as NamedTensorMap,\n             attrs as {} as NamedAttrMap) as Tensor4D;\n}\n\nexport const conv2DBackpropFilter = op({conv2DBackpropFilter_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../tensor';\n\nimport * as broadcast_util from './broadcast_util';\nimport {elu} from './elu';\nimport {Activation} from './fused_types';\nimport {leakyRelu} from './leaky_relu';\nimport {mul} from './mul';\nimport {prelu} from './prelu';\nimport {relu} from './relu';\nimport {relu6} from './relu6';\nimport {reshape} from './reshape';\nimport {sigmoid} from './sigmoid';\nimport {step} from './step';\nimport {sum} from './sum';\n\n// Returns gradient for fused activation.\nexport function getFusedDyActivation(\n    dy: Tensor, y: Tensor, activation: Activation): Tensor {\n  if (activation == null || activation === 'linear') {\n    return dy;\n  }\n  if (activation === 'relu') {\n    return mul(dy, step(y));\n  }\n  throw new Error(\n      `Cannot compute gradient for fused activation ${activation}.`);\n}\n\n// Returns gradient for fused bias.\nexport function getFusedBiasGradient(\n    bias: Tensor, dyActivation: Tensor): Tensor {\n  let res = dyActivation;\n  const reduceAxes =\n      broadcast_util.getReductionAxes(bias.shape, dyActivation.shape);\n  if (reduceAxes.length > 0) {\n    res = sum(res, reduceAxes);\n  }\n  return reshape(res, bias.shape);\n}\n\nexport function applyActivation(\n    x: Tensor, activation: Activation, preluActivationWeights?: Tensor,\n    leakyreluAlpha?: number): Tensor {\n  if (activation === 'linear') {\n    return x;\n  } else if (activation === 'relu') {\n    return relu(x);\n  } else if (activation === 'elu') {\n    return elu(x);\n  } else if (activation === 'relu6') {\n    return relu6(x);\n  } else if (activation === 'prelu') {\n    return prelu(x, preluActivationWeights);\n  } else if (activation === 'leakyrelu') {\n    return leakyRelu(x, leakyreluAlpha);\n  } else if (activation === 'sigmoid') {\n    return sigmoid(x);\n  }\n  throw new Error(`Unknown fused activation ${activation}.`);\n}\n\n// Whether we should call fused ops.\nexport const shouldFuse = (gradientDepth: number, activation: Activation) => {\n  const gradientMode = gradientDepth > 0;\n  return !gradientMode || activation === 'linear';\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {customGrad} from '../../gradients';\nimport {FusedConv2D, FusedConv2DAttrs, FusedConv2DInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor, Tensor3D, Tensor4D} from '../../tensor';\nimport {GradSaveFunc, NamedTensorMap} from '../../tensor_types';\nimport {makeTypesMatch} from '../../tensor_util';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\nimport {add} from '../add';\nimport * as broadcast_util from '../broadcast_util';\nimport {conv2d as unfusedConv2d} from '../conv2d';\nimport {conv2DBackpropFilter} from '../conv2d_backprop_filter';\nimport {conv2DBackpropInput} from '../conv2d_backprop_input';\nimport * as conv_util from '../conv_util';\nimport {Activation} from '../fused_types';\nimport {applyActivation, getFusedBiasGradient, getFusedDyActivation, shouldFuse} from '../fused_util';\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\n\n/**\n * Computes a 2D convolution over the input x, optionally fused with adding a\n * bias and applying an activation.\n *\n * ```js\n * const inputDepth = 2;\n * const inShape = [2, 2, 2, inputDepth];\n * const outputDepth = 2;\n * const fSize = 1;\n * const pad = 0;\n * const strides = 1;\n *\n * const x = tf.tensor4d( [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n * 16], inShape);\n * const w = tf.tensor4d([-1, 1, -2, 0.5], [fSize, fSize, inputDepth,\n * outputDepth]);\n *\n * tf.fused.conv2d({ x, filter: w, strides, pad, dataFormat: 'NHWC',\n * dilations: [1, 1], bias: tf.scalar(5), activation: 'relu' }).print();\n * ```\n *\n * @param obj An object with the following properties:\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter, rank 4, of shape\n *     `[filterHeight, filterWidth, inDepth, outDepth]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `dilations` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @param bias Tensor to be added to the result.\n * @param activation Name of activation kernel (defaults to `linear`) to be\n *     applied\n *      after biasAdd.\n * @param preluActivationWeights Tensor of prelu weights to be applied as part\n *     of a `prelu` activation, typically the same shape as `x`.\n * @param leakyreluAlpha Optional. Alpha to be applied as part of a `leakyrelu`\n *     activation.\n */\nfunction fusedConv2d_<T extends Tensor3D|Tensor4D>({\n  x,\n  filter,\n  strides,\n  pad,\n  dataFormat = 'NHWC',\n  dilations = [1, 1],\n  dimRoundingMode,\n  bias,\n  activation = 'linear',\n  preluActivationWeights,\n  leakyreluAlpha\n}: {\n  x: T|TensorLike,\n  filter: Tensor4D|TensorLike,\n  strides: [number, number]|number,\n  pad: 'valid'|'same'|number|conv_util.ExplicitPadding,\n  dataFormat?: 'NHWC'|'NCHW',\n  dilations?: [number, number]|number,\n  dimRoundingMode?: 'floor'|'round'|'ceil',\n  bias?: Tensor|TensorLike,\n  activation?: Activation,\n  preluActivationWeights?: Tensor,\n  leakyreluAlpha?: number\n}): T {\n  activation = activation || 'linear';\n\n  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {\n    let result = unfusedConv2d(\n        x, filter, strides, pad, dataFormat, dilations, dimRoundingMode);\n    if (bias != null) {\n      result = add(result, bias);\n    }\n\n    return applyActivation(\n               result, activation, preluActivationWeights, leakyreluAlpha) as T;\n  }\n\n  const $x = convertToTensor(x, 'x', 'conv2d');\n  const $filter = convertToTensor(filter, 'filter', 'conv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in fused conv2d: input must be rank 4, but got rank ` +\n          `${x4D.rank}.`);\n  util.assert(\n      $filter.rank === 4,\n      () => `Error in fused conv2d: filter must be rank 4, but got rank ` +\n          `${$filter.rank}.`);\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in fused conv2d: pad must be an integer when using, ` +\n            `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  util.assert(\n      x4D.shape[3] === $filter.shape[2],\n      () => `Error in conv2d: depth of input (${x4D.shape[3]}) must match ` +\n          `input depth for filter ${$filter.shape[2]}.`);\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () => 'Error in conv2D: Either strides or dilations must be 1. ' +\n          `Got strides ${strides} and dilations '${dilations}'`);\n  util.assert(\n      dataFormat === 'NHWC',\n      () => `Error in conv2d: got dataFormat of ${\n          dataFormat} but only NHWC is currently supported.`);\n\n  const convInfo = conv_util.computeConv2DInfo(\n      x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode);\n\n  let $bias: Tensor;\n  if (bias != null) {\n    $bias = convertToTensor(bias, 'bias', 'fused conv2d');\n    [$bias] = makeTypesMatch($bias, $x);\n\n    broadcast_util.assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);\n  }\n\n  let $preluActivationWeights: Tensor;\n  if (preluActivationWeights != null) {\n    $preluActivationWeights = convertToTensor(\n        preluActivationWeights, 'prelu weights', 'fused conv2d');\n  }\n\n  const grad = (dy: Tensor4D, saved: Tensor[]) => {\n    const [$filter, x4D, y, $bias] =\n        saved as [Tensor4D, Tensor4D, Tensor4D, Tensor];\n\n    const dyActivation = getFusedDyActivation(dy, y, activation) as Tensor4D;\n\n    util.assert(\n        conv_util.tupleValuesAreOne(dilations),\n        () => 'Error in gradient of fused conv2D: ' +\n            `dilation rates greater than 1 ` +\n            `are not yet supported in gradients. Got dilations '${dilations}'`);\n\n    const xDer =\n        conv2DBackpropInput(x4D.shape, dyActivation, $filter, strides, pad);\n    const filterDer =\n        conv2DBackpropFilter(x4D, dyActivation, $filter.shape, strides, pad);\n    const der: Tensor[] = [xDer, filterDer];\n\n    if ($bias != null) {\n      const biasDer = getFusedBiasGradient($bias, dyActivation);\n      der.push(biasDer);\n    }\n    return der;\n  };\n\n  const inputs: FusedConv2DInputs = {\n    x: x4D,\n    filter: $filter,\n    bias: $bias,\n    preluActivationWeights: $preluActivationWeights\n  };\n\n  const attrs: FusedConv2DAttrs = {\n    strides,\n    pad,\n    dataFormat,\n    dilations,\n    dimRoundingMode,\n    activation,\n    leakyreluAlpha\n  };\n\n  // Depending on the the params passed in we will have different number of\n  // inputs and thus a a different number of elements in the gradient.\n  if (bias == null) {\n    const customOp =\n        customGrad((x4D: Tensor4D, filter: Tensor4D, save: GradSaveFunc) => {\n          let res: Tensor4D|Tensor3D =\n              // tslint:disable-next-line: no-unnecessary-type-assertion\n              ENGINE.runKernel(\n                  FusedConv2D, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap);\n\n          save([filter, x4D, res]);\n\n          if (reshapedTo4D) {\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as\n                Tensor3D;\n          }\n\n          return {value: res, gradFunc: grad};\n        });\n    return customOp(x4D, $filter) as T;\n  } else {\n    const customOpWithBias = customGrad(\n        (x4D: Tensor4D, filter: Tensor4D, bias: Tensor, save: GradSaveFunc) => {\n          let res: Tensor4D|Tensor3D = ENGINE.runKernel(\n              FusedConv2D, inputs as {} as NamedTensorMap,\n              attrs as {} as NamedAttrMap);\n\n          save([filter, x4D, res, bias]);\n\n          if (reshapedTo4D) {\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as\n                Tensor3D;\n          }\n\n          return {value: res, gradFunc: grad};\n        });\n\n    return customOpWithBias(x4D, $filter, $bias) as T;\n  }\n}\nexport const conv2d = op({fusedConv2d_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {DepthwiseConv2dNativeBackpropFilter, DepthwiseConv2dNativeBackpropFilterAttrs, DepthwiseConv2dNativeBackpropFilterInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\n\nimport {ExplicitPadding} from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\nfunction depthwiseConv2dNativeBackpropFilter_<T extends Tensor3D|Tensor4D>(\n    x: T, dy: T, filterShape: [number, number, number, number],\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|ExplicitPadding,\n    dilations: [number, number]|number = [1, 1],\n    dimRoundingMode?: 'floor'|'round'|'ceil'): Tensor4D {\n  let x4D = x as Tensor4D;\n  if (x.rank === 3) {\n    x4D = reshape(x, [1, x.shape[0], x.shape[1], x.shape[2]]);\n  }\n  let dy4D = dy as Tensor4D;\n  if (dy4D.rank === 3) {\n    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n  }\n\n  const inputs: DepthwiseConv2dNativeBackpropFilterInputs = {x: x4D, dy: dy4D};\n  const attrs: DepthwiseConv2dNativeBackpropFilterAttrs =\n      {strides, pad, dimRoundingMode, dilations, filterShape};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  return ENGINE.runKernel(\n             DepthwiseConv2dNativeBackpropFilter,\n             inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap) as\n      Tensor4D;\n}\n\nexport const depthwiseConv2dNativeBackpropFilter =\n    op({depthwiseConv2dNativeBackpropFilter_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../engine';\nimport {DepthwiseConv2dNativeBackpropInput, DepthwiseConv2dNativeBackpropInputAttrs, DepthwiseConv2dNativeBackpropInputInputs} from '../kernel_names';\nimport {NamedAttrMap} from '../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\n\nimport {ExplicitPadding} from './conv_util';\nimport {op} from './operation';\nimport {reshape} from './reshape';\n\nfunction depthwiseConv2dNativeBackpropInput_<T extends Tensor3D|Tensor4D>(\n    xShape: [number, number, number, number], dy: T, filter: Tensor4D,\n    strides: [number, number]|number,\n    pad: 'valid'|'same'|number|ExplicitPadding,\n    dilations: [number, number]|number = [1, 1],\n    dimRoundingMode?: 'floor'|'round'|'ceil'): T {\n  let dy4D = dy as Tensor4D;\n  let reshapedTo4D = false;\n  if (dy.rank === 3) {\n    reshapedTo4D = true;\n    dy4D = reshape(dy, [1, dy.shape[0], dy.shape[1], dy.shape[2]]);\n  }\n\n  const inputs: DepthwiseConv2dNativeBackpropInputInputs = {dy: dy4D, filter};\n  const attrs: DepthwiseConv2dNativeBackpropInputAttrs =\n      {strides, pad, dimRoundingMode, dilations, inputShape: xShape};\n\n  const res =\n      // tslint:disable-next-line: no-unnecessary-type-assertion\n      ENGINE.runKernel(\n          DepthwiseConv2dNativeBackpropInput, inputs as {} as NamedTensorMap,\n          attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const depthwiseConv2dNativeBackpropInput =\n    op({depthwiseConv2dNativeBackpropInput_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {customGrad} from '../../gradients';\nimport {FusedDepthwiseConv2D, FusedDepthwiseConv2DAttrs, FusedDepthwiseConv2DInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor, Tensor3D, Tensor4D} from '../../tensor';\nimport {GradSaveFunc, NamedTensorMap} from '../../tensor_types';\nimport {makeTypesMatch} from '../../tensor_util';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {add} from '../add';\nimport * as broadcast_util from '../broadcast_util';\nimport * as conv_util from '../conv_util';\nimport {depthwiseConv2d as unfusedDepthwiseConv2d} from '../depthwise_conv2d';\nimport {depthwiseConv2dNativeBackpropFilter} from '../depthwise_conv2d_native_backprop_filter';\nimport {depthwiseConv2dNativeBackpropInput} from '../depthwise_conv2d_native_backprop_input';\nimport {Activation} from '../fused_types';\nimport {applyActivation, getFusedBiasGradient, getFusedDyActivation, shouldFuse} from '../fused_util';\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\n\n/**\n * Computes depthwise 2D convolution, optionally fused with adding a\n * bias and applying an activation.\n *\n * Given a 4D `input` array and a `filter` array of shape\n * `[filterHeight, filterWidth, inChannels, channelMultiplier]` containing\n * `inChannels` convolutional filters of depth 1, this op applies a\n * different filter to each input channel (expanding from 1 channel to\n * `channelMultiplier` channels for each), then concatenates the results\n * together. The output has `inChannels * channelMultiplier` channels.\n *\n * See\n * [https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d](\n *     https://www.tensorflow.org/api_docs/python/tf/nn/depthwise_conv2d)\n * for more details.\n *\n * @param obj An object with the following properties:\n * @param x The input tensor, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is\n * assumed.\n * @param filter The filter tensor, rank 4, of shape\n *     `[filterHeight, filterWidth, inChannels, channelMultiplier]`.\n * @param strides The strides of the convolution: `[strideHeight,\n * strideWidth]`. If strides is a single number, then `strideHeight ==\n * strideWidth`.\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid`: output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`\n *     in which we sample input values across the height and width dimensions\n *     in atrous convolution. Defaults to `[1, 1]`. If `rate` is a single\n *     number, then `dilationHeight == dilationWidth`. If it is greater than\n *     1, then all values of `strides` must be 1.\n * @param dataFormat: An optional string from: \"NHWC\", \"NCHW\". Defaults to\n *     \"NHWC\". Specify the data format of the input and output data. With the\n *     default format \"NHWC\", the data is stored in the order of: [batch,\n *     height, width, channels]. Only \"NHWC\" is currently supported.\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @param bias Tensor to be added to the result.\n * @param activation Name of activation kernel (defaults to `linear`).\n * @param preluActivationWeights Tensor of prelu weights to be applied as part\n *     of a `prelu` activation, typically the same shape as `x`.\n * @param leakyreluAlpha Optional. Alpha to be applied as part of a `leakyrelu`\n *     activation.\n */\nfunction fusedDepthwiseConv2d_<T extends Tensor3D|Tensor4D>({\n  x,\n  filter,\n  strides,\n  pad,\n  dataFormat = 'NHWC',\n  dilations = [1, 1],\n  dimRoundingMode,\n  bias,\n  activation = 'linear',\n  preluActivationWeights,\n  leakyreluAlpha\n}: {\n  x: T|TensorLike,\n  filter: Tensor4D|TensorLike,\n  strides: [number, number]|number,\n  pad: 'valid'|'same'|number,\n  dataFormat?: 'NHWC'|'NCHW',\n  dilations?: [number, number]|number,\n  dimRoundingMode?: 'floor'|'round'|'ceil',\n  bias?: Tensor|TensorLike,\n  activation?: Activation,\n  preluActivationWeights?: Tensor,\n  leakyreluAlpha?: number\n}): T {\n  if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {\n    let result = unfusedDepthwiseConv2d(\n        x, filter, strides, pad, dataFormat, dilations, dimRoundingMode);\n    if (bias != null) {\n      result = add(result, bias);\n    }\n\n    return applyActivation(\n               result, activation, preluActivationWeights, leakyreluAlpha) as T;\n  }\n\n  const $x = convertToTensor(x, 'x', 'depthwiseConv2d');\n  const $filter = convertToTensor(filter, 'filter', 'depthwiseConv2d');\n\n  let x4D = $x as Tensor4D;\n  let reshapedTo4D = false;\n  if ($x.rank === 3) {\n    reshapedTo4D = true;\n    x4D = reshape($x, [1, $x.shape[0], $x.shape[1], $x.shape[2]]);\n  }\n  util.assert(\n      x4D.rank === 4,\n      () => `Error in fused depthwiseConv2d: input must be rank 4, but got ` +\n          `rank ${x4D.rank}.`);\n  util.assert(\n      $filter.rank === 4,\n      () => `Error in fused depthwiseConv2d: filter must be rank 4, ` +\n          `but got rank ${$filter.rank}.`);\n  util.assert(\n      x4D.shape[3] === $filter.shape[2],\n      () => `Error in fused depthwiseConv2d: number of input channels ` +\n          `(${x4D.shape[3]}) must match the inChannels dimension in ` +\n          `filter ${$filter.shape[2]}.`);\n  if (dilations == null) {\n    dilations = [1, 1];\n  }\n  util.assert(\n      conv_util.eitherStridesOrDilationsAreOne(strides, dilations),\n      () =>\n          'Error in fused depthwiseConv2d: Either strides or dilations must ' +\n          `be 1. Got strides ${strides} and dilations '${dilations}'`);\n\n  if (dimRoundingMode != null) {\n    util.assert(\n        util.isInt(pad as number),\n        () => `Error in fused depthwiseConv2d: pad must be an integer when ` +\n            `using dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n  }\n\n  const convInfo = conv_util.computeConv2DInfo(\n      x4D.shape, $filter.shape, strides, dilations, pad, dimRoundingMode,\n      true /* depthwise */);\n\n  let $bias: Tensor;\n  if (bias != null) {\n    $bias = convertToTensor(bias, 'bias', 'fused conv2d');\n    [$bias] = makeTypesMatch($bias, $x);\n\n    broadcast_util.assertAndGetBroadcastShape(convInfo.outShape, $bias.shape);\n  }\n\n  let $preluActivationWeights: Tensor;\n  if (preluActivationWeights != null) {\n    $preluActivationWeights = convertToTensor(\n        preluActivationWeights, 'prelu weights', 'fused depthwiseConv2d');\n  }\n\n  const grad = (dy: Tensor4D, saved: Tensor[]) => {\n    util.assert(\n        conv_util.tupleValuesAreOne(dilations),\n        () => 'Error in gradient of fused depthwiseConv2d: dilation rates ' +\n            `greater than 1 are not yet supported. Got dilations ` +\n            `'${dilations}'`);\n    const [$filter, x4D, y, bias] = saved;\n\n    const dyActivation = getFusedDyActivation(dy, y, activation) as Tensor4D;\n\n    const xDer = depthwiseConv2dNativeBackpropInput(\n        (x4D as Tensor4D).shape, dyActivation, $filter as Tensor4D, strides,\n        pad, dilations, dimRoundingMode);\n    const filterDer = depthwiseConv2dNativeBackpropFilter(\n        x4D as Tensor4D, dyActivation, ($filter as Tensor4D).shape, strides,\n        pad, dilations, dimRoundingMode);\n\n    if (bias != null) {\n      const biasDer = getFusedBiasGradient($bias, dyActivation);\n      return [xDer, filterDer, biasDer];\n    }\n    return [xDer, filterDer];\n  };\n\n  const inputs: FusedDepthwiseConv2DInputs = {\n    x: x4D,\n    filter: $filter,\n    bias: $bias,\n    preluActivationWeights: $preluActivationWeights\n  };\n  const attrs: FusedDepthwiseConv2DAttrs = {\n    strides,\n    pad,\n    dataFormat,\n    dilations,\n    dimRoundingMode,\n    activation,\n    leakyreluAlpha\n  };\n\n  // Depending on the the params passed in we will have different number of\n  // inputs and thus a a different number of elements in the gradient.\n  if (bias == null) {\n    const customOp =\n        customGrad((x4D: Tensor4D, filter: Tensor4D, save: GradSaveFunc) => {\n          // tslint:disable-next-line: no-unnecessary-type-assertion\n          let res: Tensor4D|Tensor3D = ENGINE.runKernel(\n              FusedDepthwiseConv2D, inputs as {} as NamedTensorMap,\n              attrs as {} as NamedAttrMap);\n\n          save([filter, x4D, res]);\n\n          if (reshapedTo4D) {\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as\n                Tensor3D;\n          }\n\n          return {value: res, gradFunc: grad};\n        });\n    return customOp(x4D, $filter) as T;\n  } else {\n    const customOpWithBias = customGrad(\n        (x4D: Tensor4D, filter: Tensor4D, bias: Tensor, save: GradSaveFunc) => {\n          // tslint:disable-next-line: no-unnecessary-type-assertion\n          let res: Tensor4D|Tensor3D = ENGINE.runKernel(\n              FusedDepthwiseConv2D, inputs as {} as NamedTensorMap,\n              attrs as {} as NamedAttrMap);\n\n          save([filter, x4D, res, bias]);\n\n          if (reshapedTo4D) {\n            // tslint:disable-next-line: no-unnecessary-type-assertion\n            res = reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as\n                Tensor3D;\n          }\n\n          return {value: res, gradFunc: grad};\n        });\n\n    return customOpWithBias(x4D, $filter, $bias) as T;\n  }\n}\nexport const depthwiseConv2d = op({fusedDepthwiseConv2d_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {customGrad} from '../../gradients';\nimport {_FusedMatMul, _FusedMatMulAttrs, _FusedMatMulInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor, Tensor3D} from '../../tensor';\nimport {GradSaveFunc, NamedTensorMap} from '../../tensor_types';\nimport {makeTypesMatch} from '../../tensor_util';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {add} from '../add';\nimport * as broadcast_util from '../broadcast_util';\nimport {Activation} from '../fused_types';\nimport {applyActivation, getFusedBiasGradient, getFusedDyActivation, shouldFuse} from '../fused_util';\nimport {matMul as unfusedMatMul} from '../mat_mul';\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\n\n/**\n * Computes the dot product of two matrices with optional activation and bias.\n *\n * ```js\n * const a = tf.tensor2d([-1, -2], [1, 2]);\n * const b = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const bias = tf.tensor2d([1, 2], [1, 2]);\n *\n * tf.fused.matMul({a, b, bias, activation: 'relu'}).print();\n * ```\n *\n * @param obj An object with the following properties:\n * - `a` First matrix in dot product operation.\n * - `b` Second matrix in dot product operation.\n * - `transposeA` If true, `a` is transposed before multiplication.\n * - `transposeB` If true, `b` is transposed before multiplication.\n * - `bias` Matrix to be added to the result.\n * - `activation` Name of activation kernel (defaults to `linear`).\n * - `preluActivationWeights` Tensor of prelu weights.\n * - `leakyreluAlpha` Alpha of leakyrelu.\n */\nfunction fusedMatMul_<T extends Tensor>({\n  a,\n  b,\n  transposeA = false,\n  transposeB = false,\n  bias,\n  activation = 'linear',\n  preluActivationWeights,\n  leakyreluAlpha,\n}: {\n  a: T|TensorLike,\n  b: T|TensorLike,\n  transposeA?: boolean,\n  transposeB?: boolean,\n  bias?: Tensor|TensorLike,\n  activation?: Activation,\n  preluActivationWeights?: Tensor\n  leakyreluAlpha?: number\n}): T {\n    if (shouldFuse(ENGINE.state.gradientDepth, activation) === false) {\n      let result = unfusedMatMul(a, b, transposeA, transposeB);\n      if (bias != null) {\n        result = add(result, bias);\n      }\n\n      return applyActivation(\n                 result, activation, preluActivationWeights, leakyreluAlpha) as\n          T;\n    }\n\n    let $a = convertToTensor(a, 'a', 'fused matMul');\n    let $b = convertToTensor(b, 'b', 'fused matMul');\n    [$a, $b] = makeTypesMatch($a, $b);\n\n    const innerShapeA =\n        transposeA ? $a.shape[$a.rank - 2] : $a.shape[$a.rank - 1];\n    const innerShapeB =\n        transposeB ? $b.shape[$b.rank - 1] : $b.shape[$b.rank - 2];\n\n    const outerShapeA =\n        transposeA ? $a.shape[$a.rank - 1] : $a.shape[$a.rank - 2];\n    const outerShapeB =\n        transposeB ? $b.shape[$b.rank - 2] : $b.shape[$b.rank - 1];\n\n    const outerDimsA = $a.shape.slice(0, -2);\n    const outerDimsB = $b.shape.slice(0, -2);\n    const batchDimA = util.sizeFromShape(outerDimsA);\n    const batchDimB = util.sizeFromShape(outerDimsB);\n\n    util.assert(\n        $a.rank >= 2 && $b.rank >= 2 && $a.rank === $b.rank,\n        () => `Error in fused matMul: inputs must have the same rank of at ` +\n            `least 2, got ranks ${$a.rank} and ${$b.rank}.`);\n\n    util.assert(\n        util.arraysEqual(outerDimsA, outerDimsB),\n        () => `Error in fused matMul: outer dimensions (${outerDimsA}) and (` +\n            `${outerDimsB}) of Tensors with shapes ${$a.shape} and ` +\n            `${$b.shape} must match.`);\n\n    util.assert(\n        innerShapeA === innerShapeB,\n        () => `Error in fused matMul: inner shapes (${innerShapeA}) and (` +\n            `${innerShapeB}) of Tensors with shapes ${$a.shape} and ` +\n            `${$b.shape} and transposeA=${transposeA}` +\n            ` and transposeB=${transposeB} must match.`);\n\n    const outShape = $a.shape.slice(0, -2).concat([outerShapeA, outerShapeB]);\n\n    const a3D: Tensor3D = transposeA ?\n        reshape($a, [batchDimA, innerShapeA, outerShapeA]) :\n        reshape($a, [batchDimA, outerShapeA, innerShapeA]);\n    const b3D: Tensor3D = transposeB ?\n        reshape($b, [batchDimB, outerShapeB, innerShapeB]) :\n        reshape($b, [batchDimB, innerShapeB, outerShapeB]);\n\n    let $bias: Tensor;\n    if (bias != null) {\n      $bias = convertToTensor(bias, 'bias', 'fused matMul');\n      [$bias] = makeTypesMatch($bias, $a);\n\n      broadcast_util.assertAndGetBroadcastShape(outShape, $bias.shape);\n    }\n\n    let $preluActivationWeights: Tensor;\n    if (preluActivationWeights != null) {\n      $preluActivationWeights = convertToTensor(\n          preluActivationWeights, 'prelu weights', 'fused matMul');\n    }\n\n    const grad = (dy: Tensor3D, saved: Tensor[]) => {\n      const [a3D, b3D, y, $bias] = saved;\n      // we reshape dy because the result of the forward is not\n      // necessarily going to be a 3d tensor due to a reshape done at the end of\n      // the customOp.\n      const dyActivation =\n          getFusedDyActivation(reshape(dy, y.shape), y, activation);\n      let aDer: Tensor;\n      let bDer: Tensor;\n\n      if (!transposeA && !transposeB) {\n        aDer = unfusedMatMul(dyActivation, b3D, false, true);\n        bDer = unfusedMatMul(a3D, dyActivation, true, false);\n      } else if (!transposeA && transposeB) {\n        aDer = unfusedMatMul(dyActivation, b3D, false, false);\n        bDer = unfusedMatMul(dyActivation, a3D, true, false);\n      } else if (transposeA && !transposeB) {\n        aDer = unfusedMatMul(b3D, dyActivation, false, true);\n        bDer = unfusedMatMul(a3D, dyActivation, false, false);\n      } else {\n        aDer = unfusedMatMul(b3D, dyActivation, true, true);\n        bDer = unfusedMatMul(dyActivation, a3D, true, true);\n      }\n\n      if (bias != null) {\n        const biasDer = getFusedBiasGradient($bias, dyActivation);\n        return [aDer, bDer, biasDer];\n      } else {\n        return [aDer, bDer];\n      }\n    };\n\n    const inputs: _FusedMatMulInputs = {\n      a: a3D,\n      b: b3D,\n      bias: $bias,\n      preluActivationWeights: $preluActivationWeights\n    };\n    const attrs: _FusedMatMulAttrs =\n        {transposeA, transposeB, activation, leakyreluAlpha};\n\n    // Depending on the the params passed in we will have different number of\n    // inputs and thus a a different number of elements in the gradient.\n    if (bias == null) {\n      const customOp =\n          customGrad((a3D: Tensor3D, b3D: Tensor3D, save: GradSaveFunc) => {\n            const res =\n                // tslint:disable-next-line: no-unnecessary-type-assertion\n                ENGINE.runKernel(\n                    _FusedMatMul, inputs as {} as NamedTensorMap,\n                    attrs as {} as NamedAttrMap) as T;\n\n            save([a3D, b3D, res]);\n\n            return {value: reshape(res, outShape), gradFunc: grad};\n          });\n      return customOp(a3D, b3D) as T;\n    } else {\n      const customOpWithBias = customGrad(\n          (a3D: Tensor3D, b3D: Tensor3D, $bias: Tensor, save: GradSaveFunc) => {\n            const res =\n                // tslint:disable-next-line: no-unnecessary-type-assertion\n                ENGINE.runKernel(\n                    _FusedMatMul, inputs as {} as NamedTensorMap,\n                    attrs as {} as NamedAttrMap) as T;\n\n            save([a3D, b3D, res, $bias]);\n\n            return {value: reshape(res, outShape), gradFunc: grad};\n          });\n\n      return customOpWithBias(a3D, b3D, $bias) as T;\n    }\n  }\n\n  export const matMul = op({fusedMatMul_});\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor, Tensor3D, Tensor4D} from '../tensor';\nimport {Conv2DInfo} from './conv_util';\n\nexport type FusedConv2DConfig = {\n  input: Tensor4D,\n  filter: Tensor4D,\n  convInfo: Conv2DInfo,\n  bias?: Tensor,\n  activation?: Activation,\n  preluActivationWeights?: Tensor,\n  leakyreluAlpha?: number\n};\n\nexport type FusedBatchMatMulConfig = {\n  a: Tensor3D,\n  b: Tensor3D,\n  transposeA: boolean,\n  transposeB: boolean,\n  bias?: Tensor,\n  activation?: Activation,\n  preluActivationWeights?: Tensor,\n  leakyreluAlpha?: number\n};\n\nexport type Activation =\n    'linear'|'relu'|'prelu'|'elu'|'relu6'|'leakyrelu'|'sigmoid';\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {conv2d} from './fused/conv2d';\nimport {depthwiseConv2d} from './fused/depthwise_conv2d';\nimport {matMul} from './fused/mat_mul';\nimport {Activation} from './fused_types';\n\nexport {Activation, conv2d, depthwiseConv2d, matMul};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D} from '../../tensor';\nimport {op} from '../operation';\nimport {cosineWindow} from '../signal_ops_util';\n\n/**\n * Generate a hamming window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hammingWindow(10).print();\n * ```\n * @param The length of window\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hammingWindow_(windowLength: number): Tensor1D {\n  return cosineWindow(windowLength, 0.54, 0.46);\n}\nexport const hammingWindow = op({hammingWindow_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D} from '../../tensor';\nimport {op} from '../operation';\nimport {cosineWindow} from '../signal_ops_util';\n\n/**\n * Generate a Hann window.\n *\n * See: https://en.wikipedia.org/wiki/Window_function#Hann_and_Hamming_windows\n *\n * ```js\n * tf.signal.hannWindow(10).print();\n * ```\n * @param The length of window\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction hannWindow_(windowLength: number): Tensor1D {\n  return cosineWindow(windowLength, 0.5, 0.5);\n}\n\nexport const hannWindow = op({hannWindow_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor, Tensor1D} from '../../tensor';\nimport {concat} from '../concat';\nimport {fill} from '../fill';\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\nimport {slice} from '../slice';\nimport {tensor2d} from '../tensor2d';\n\n/**\n * Expands input into frames of frameLength.\n * Slides a window size with frameStep.\n *\n * ```js\n * tf.signal.frame([1, 2, 3], 2, 1).print();\n * ```\n * @param signal The input tensor to be expanded\n * @param frameLength Length of each frame\n * @param frameStep The frame hop size in samples.\n * @param padEnd Whether to pad the end of signal with padValue.\n * @param padValue An number to use where the input signal does\n *     not exist when padEnd is True.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction frame_(\n    signal: Tensor1D, frameLength: number, frameStep: number, padEnd = false,\n    padValue = 0): Tensor {\n  let start = 0;\n  const output: Tensor[] = [];\n  while (start + frameLength <= signal.size) {\n    output.push(slice(signal, start, frameLength));\n    start += frameStep;\n  }\n\n  if (padEnd) {\n    while (start < signal.size) {\n      const padLen = (start + frameLength) - signal.size;\n      const pad = concat([\n        slice(signal, start, frameLength - padLen), fill([padLen], padValue)\n      ]);\n      output.push(pad);\n      start += frameStep;\n    }\n  }\n\n  if (output.length === 0) {\n    return tensor2d([], [0, frameLength]);\n  }\n\n  return reshape(concat(output), [output.length, frameLength]);\n}\nexport const frame = op({frame_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor, Tensor1D} from '../../tensor';\nimport {mul} from '../mul';\nimport {op} from '../operation';\nimport {enclosingPowerOfTwo} from '../signal_ops_util';\nimport {rfft} from '../spectral/rfft';\n\nimport {frame} from './frame';\nimport {hannWindow} from './hann_window';\n\n/**\n * Computes the Short-time Fourier Transform of signals\n * See: https://en.wikipedia.org/wiki/Short-time_Fourier_transform\n *\n * ```js\n * const input = tf.tensor1d([1, 1, 1, 1, 1])\n * tf.signal.stft(input, 3, 1).print();\n * ```\n * @param signal 1-dimensional real value tensor.\n * @param frameLength The window length of samples.\n * @param frameStep The number of samples to step.\n * @param fftLength The size of the FFT to apply.\n * @param windowFn A callable that takes a window length and returns 1-d tensor.\n *\n * @doc {heading: 'Operations', subheading: 'Signal', namespace: 'signal'}\n */\nfunction stft_(\n    signal: Tensor1D, frameLength: number, frameStep: number,\n    fftLength?: number,\n    windowFn: (length: number) => Tensor1D = hannWindow): Tensor {\n  if (fftLength == null) {\n    fftLength = enclosingPowerOfTwo(frameLength);\n  }\n  const framedSignal = frame(signal, frameLength, frameStep);\n  const windowedSignal = mul(framedSignal, windowFn(frameLength));\n  return rfft(windowedSignal, fftLength);\n}\nexport const stft = op({stft_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {CropAndResize, CropAndResizeAttrs, CropAndResizeInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor1D, Tensor2D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\n\n/**\n * Extracts crops from the input image tensor and resizes them using bilinear\n * sampling or nearest neighbor sampling (possibly with aspect ratio change)\n * to a common output size specified by cropSize.\n *\n * @param image 4d tensor of shape `[batch,imageHeight,imageWidth, depth]`,\n *     where imageHeight and imageWidth must be positive, specifying the\n *     batch of images from which to take crops\n * @param boxes 2d float32 tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the normalized\n *     coordinates of the box in the boxInd[i]'th image in the batch\n * @param boxInd 1d int32 tensor of shape `[numBoxes]` with values in range\n *     `[0, batch)` that specifies the image that the `i`-th box refers to.\n * @param cropSize 1d int32 tensor of 2 elements `[cropHeigh, cropWidth]`\n *     specifying the size to which all crops are resized to.\n * @param method Optional string from `'bilinear' | 'nearest'`,\n *     defaults to bilinear, which specifies the sampling method for resizing\n * @param extrapolationValue A threshold for deciding when to remove boxes based\n *     on score. Defaults to 0.\n * @return A 4D tensor of the shape `[numBoxes,cropHeight,cropWidth,depth]`\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction cropAndResize_(\n    image: Tensor4D|TensorLike,\n    boxes: Tensor2D|TensorLike,\n    boxInd: Tensor1D|TensorLike,\n    cropSize: [number, number],\n    method: 'bilinear'|'nearest' = 'bilinear',\n    extrapolationValue = 0,\n    ): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'cropAndResize');\n  const $boxes = convertToTensor(boxes, 'boxes', 'cropAndResize', 'float32');\n  const $boxInd = convertToTensor(boxInd, 'boxInd', 'cropAndResize', 'int32');\n\n  const numBoxes = $boxes.shape[0];\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in cropAndResize: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n  util.assert(\n      $boxes.rank === 2 && $boxes.shape[1] === 4,\n      () => `Error in cropAndResize: boxes must be have size [${numBoxes},4] ` +\n          `but had shape ${$boxes.shape}.`);\n  util.assert(\n      $boxInd.rank === 1 && $boxInd.shape[0] === numBoxes,\n      () => `Error in cropAndResize: boxInd must be have size [${numBoxes}] ` +\n          `but had shape ${$boxes.shape}.`);\n  util.assert(\n      cropSize.length === 2,\n      () => `Error in cropAndResize: cropSize must be of length 2, but got ` +\n          `length ${cropSize.length}.`);\n  util.assert(\n      cropSize[0] >= 1 && cropSize[1] >= 1,\n      () => `cropSize must be atleast [1,1], but was ${cropSize}`);\n  util.assert(\n      method === 'bilinear' || method === 'nearest',\n      () => `method must be bilinear or nearest, but was ${method}`);\n\n  const inputs:\n      CropAndResizeInputs = {image: $image, boxes: $boxes, boxInd: $boxInd};\n  const attrs: CropAndResizeAttrs = {method, extrapolationValue, cropSize};\n  const res = ENGINE.runKernel(\n      CropAndResize, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n  return res as Tensor4D;\n}\n\nexport const cropAndResize = op({cropAndResize_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {FlipLeftRight, FlipLeftRightInputs} from '../../kernel_names';\nimport {Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\nimport {op} from '../operation';\n\n/**\n * Flips the image left to right. Currently available in the CPU, WebGL, and\n * WASM backends.\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n */\n/** @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'} */\nfunction flipLeftRight_(image: Tensor4D|TensorLike): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'flipLeftRight', 'float32');\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in flipLeftRight: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n\n  const inputs: FlipLeftRightInputs = {image: $image};\n  const res =\n      ENGINE.runKernel(FlipLeftRight, inputs as {} as NamedTensorMap, {});\n  return res as Tensor4D;\n}\n\nexport const flipLeftRight = op({flipLeftRight_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D, Tensor3D, Tensor4D, Tensor5D, Tensor6D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\nimport {tile} from '../tile';\n\n/**\n * Converts images from grayscale to RGB format.\n *\n * @param image A grayscale tensor to convert. The `image`'s last dimension must\n *     be size 1 with at least a two-dimensional shape.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction grayscaleToRGB_<T extends Tensor2D|Tensor3D|Tensor4D|Tensor5D|\n                         Tensor6D>(image: T|TensorLike): T {\n  const $image = convertToTensor(image, 'image', 'grayscaleToRGB');\n\n  const lastDimsIdx = $image.rank - 1;\n  const lastDims = $image.shape[lastDimsIdx];\n\n  util.assert(\n      $image.rank >= 2,\n      () => 'Error in grayscaleToRGB: images must be at least rank 2, ' +\n          `but got rank ${$image.rank}.`);\n\n  util.assert(\n      lastDims === 1,\n      () => 'Error in grayscaleToRGB: last dimension of a grayscale image ' +\n          `should be size 1, but got size ${lastDims}.`);\n\n  const reps = new Array($image.rank);\n\n  reps.fill(1, 0, lastDimsIdx);\n  reps[lastDimsIdx] = 3;\n\n  return tile($image, reps);\n}\n\nexport const grayscaleToRGB = op({grayscaleToRGB_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {RotateWithOffset, RotateWithOffsetAttrs, RotateWithOffsetInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\n\n/**\n * Rotates the input image tensor counter-clockwise with an optional offset\n * center of rotation. Currently available in the CPU, WebGL, and WASM backends.\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n * @param radians The amount of rotation.\n * @param fillValue The value to fill in the empty space leftover\n *     after rotation. Can be either a single grayscale value (0-255), or an\n *     array of three numbers `[red, green, blue]` specifying the red, green,\n *     and blue channels. Defaults to `0` (black).\n * @param center The center of rotation. Can be either a single value (0-1), or\n *     an array of two numbers `[centerX, centerY]`. Defaults to `0.5` (rotates\n *     the image around its center).\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction rotateWithOffset_(\n    image: Tensor4D|TensorLike, radians: number,\n    fillValue: number|[number, number, number] = 0,\n    center: number|[number, number] = 0.5): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'rotateWithOffset', 'float32');\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in rotateWithOffset: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n\n  const inputs: RotateWithOffsetInputs = {image: $image};\n  const attrs: RotateWithOffsetAttrs = {radians, fillValue, center};\n  const res = ENGINE.runKernel(\n      RotateWithOffset, inputs as {} as NamedTensorMap,\n      attrs as {} as NamedAttrMap);\n  return res as Tensor4D;\n}\n\nexport const rotateWithOffset = op({rotateWithOffset_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor1D, Tensor2D} from '../tensor';\nimport * as util from '../util';\n\nfunction nonMaxSuppSanityCheck(\n    boxes: Tensor2D, scores: Tensor1D, maxOutputSize: number,\n    iouThreshold: number, scoreThreshold: number, softNmsSigma?: number): {\n  maxOutputSize: number,\n  iouThreshold: number,\n  scoreThreshold: number,\n  softNmsSigma: number\n} {\n  if (iouThreshold == null) {\n    iouThreshold = 0.5;\n  }\n  if (scoreThreshold == null) {\n    scoreThreshold = Number.NEGATIVE_INFINITY;\n  }\n  if (softNmsSigma == null) {\n    softNmsSigma = 0.0;\n  }\n\n  const numBoxes = boxes.shape[0];\n  maxOutputSize = Math.min(maxOutputSize, numBoxes);\n\n  util.assert(\n      0 <= iouThreshold && iouThreshold <= 1,\n      () => `iouThreshold must be in [0, 1], but was '${iouThreshold}'`);\n  util.assert(\n      boxes.rank === 2,\n      () => `boxes must be a 2D tensor, but was of rank '${boxes.rank}'`);\n  util.assert(\n      boxes.shape[1] === 4,\n      () =>\n          `boxes must have 4 columns, but 2nd dimension was ${boxes.shape[1]}`);\n  util.assert(scores.rank === 1, () => 'scores must be a 1D tensor');\n  util.assert(\n      scores.shape[0] === numBoxes,\n      () => `scores has incompatible shape with boxes. Expected ${numBoxes}, ` +\n          `but was ${scores.shape[0]}`);\n  util.assert(\n      0 <= softNmsSigma && softNmsSigma <= 1,\n      () => `softNmsSigma must be in [0, 1], but was '${softNmsSigma}'`);\n  return {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma};\n}\n\nexport {nonMaxSuppSanityCheck};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {NonMaxSuppressionV3} from '../../kernel_names';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\n\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {op} from '../operation';\n\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @return A 1D tensor with the selected box indices.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction nonMaxSuppression_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY): Tensor1D {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n\n  const inputs = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n\n  const attrs = {maxOutputSize, iouThreshold, scoreThreshold};\n  return ENGINE.runKernel(\n      NonMaxSuppressionV3, {boxes: $boxes, scores: $scores}, attrs);\n}\n\nexport const nonMaxSuppression = op({nonMaxSuppression_});\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Inserts a value into a sorted array. This method allows duplicate, meaning it\n * allows inserting duplicate value, in which case, the element will be inserted\n * at the lowest index of the value.\n * @param arr The array to modify.\n * @param element The element to insert.\n * @param comparator Optional. If no comparator is specified, elements are\n * compared using array_util.defaultComparator, which is suitable for Strings\n * and Numbers in ascending arrays. If the array contains multiple instances of\n * the target value, the left-most instance will be returned. To provide a\n * comparator, it should take 2 arguments to compare and return a negative,\n * zero, or a positive number.\n */\nexport function binaryInsert<T>(\n    arr: T[], element: T, comparator?: (a: T, b: T) => number) {\n  const index = binarySearch(arr, element, comparator);\n  const insertionPoint = index < 0 ? -(index + 1) : index;\n  arr.splice(insertionPoint, 0, element);\n}\n\n/**\n * Searches the array for the target using binary search, returns the index\n * of the found element, or position to insert if element not found. If no\n * comparator is specified, elements are compared using array_\n * util.defaultComparator, which is suitable for Strings and Numbers in\n * ascending arrays. If the array contains multiple instances of the target\n * value, the left-most instance will be returned.\n * @param arr The array to be searched in.\n * @param target The target to be searched for.\n * @param comparator Should take 2 arguments to compare and return a negative,\n *    zero, or a positive number.\n * @return Lowest index of the target value if found, otherwise the insertion\n *    point where the target should be inserted, in the form of\n *    (-insertionPoint - 1).\n */\nexport function binarySearch<T>(\n    arr: T[], target: T, comparator?: (a: T, b: T) => number) {\n  return binarySearch_(arr, target, comparator || defaultComparator);\n}\n\n/**\n * Compares its two arguments for order.\n * @param a The first element to be compared.\n * @param b The second element to be compared.\n * @return A negative number, zero, or a positive number as the first\n *     argument is less than, equal to, or greater than the second.\n */\nfunction defaultComparator<T>(a: T, b: T): number {\n  return a > b ? 1 : a < b ? -1 : 0;\n}\n\nfunction binarySearch_<T>(\n    arr: T[], target: T, comparator: (a: T, b: T) => number) {\n  let left = 0;\n  let right = arr.length;\n  let middle = 0;\n  let found = false;\n  while (left < right) {\n    middle = left + ((right - left) >>> 1);\n    const compareResult = comparator(target, arr[middle]);\n    if (compareResult > 0) {\n      left = middle + 1;\n    } else {\n      right = middle;\n      // If compareResult is 0, the value is found. We record it is found,\n      // and then keep looking because there may be duplicate.\n      found = !compareResult;\n    }\n  }\n\n  return found ? left : -left - 1;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray} from '../types';\nimport {binaryInsert} from './non_max_suppression_util';\n\n/**\n * Implementation of the NonMaxSuppression kernel shared between webgl and cpu.\n */\ninterface Candidate {\n  score: number;\n  boxIndex: number;\n  suppressBeginIndex: number;\n}\n\ninterface NonMaxSuppressionResult {\n  selectedIndices: number[];\n  selectedScores?: number[];\n  validOutputs?: number;\n}\n\nexport function nonMaxSuppressionV3Impl(\n    boxes: TypedArray, scores: TypedArray, maxOutputSize: number,\n    iouThreshold: number, scoreThreshold: number): NonMaxSuppressionResult {\n  return nonMaxSuppressionImpl_(\n      boxes, scores, maxOutputSize, iouThreshold, scoreThreshold,\n      0 /* softNmsSigma */);\n}\n\nexport function nonMaxSuppressionV4Impl(\n    boxes: TypedArray, scores: TypedArray, maxOutputSize: number,\n    iouThreshold: number, scoreThreshold: number,\n    padToMaxOutputSize: boolean): NonMaxSuppressionResult {\n  return nonMaxSuppressionImpl_(\n      boxes, scores, maxOutputSize, iouThreshold, scoreThreshold,\n      0 /* softNmsSigma */, false /* returnScoresTensor */,\n      padToMaxOutputSize /* padToMaxOutputSize */, true\n      /* returnValidOutputs */);\n}\n\nexport function nonMaxSuppressionV5Impl(\n    boxes: TypedArray, scores: TypedArray, maxOutputSize: number,\n    iouThreshold: number, scoreThreshold: number,\n    softNmsSigma: number): NonMaxSuppressionResult {\n  return nonMaxSuppressionImpl_(\n      boxes, scores, maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma,\n      true /* returnScoresTensor */);\n}\n\nfunction nonMaxSuppressionImpl_(\n    boxes: TypedArray, scores: TypedArray, maxOutputSize: number,\n    iouThreshold: number, scoreThreshold: number, softNmsSigma: number,\n    returnScoresTensor = false, padToMaxOutputSize = false,\n    returnValidOutputs = false): NonMaxSuppressionResult {\n  // The list is sorted in ascending order, so that we can always pop the\n  // candidate with the largest score in O(1) time.\n  const candidates = [];\n\n  for (let i = 0; i < scores.length; i++) {\n    if (scores[i] > scoreThreshold) {\n      candidates.push({score: scores[i], boxIndex: i, suppressBeginIndex: 0});\n    }\n  }\n\n  candidates.sort(ascendingComparator);\n\n  // If softNmsSigma is 0, the outcome of this algorithm is exactly same as\n  // before.\n  const scale = softNmsSigma > 0 ? (-0.5 / softNmsSigma) : 0.0;\n\n  const selectedIndices: number[] = [];\n  const selectedScores: number[] = [];\n\n  while (selectedIndices.length < maxOutputSize && candidates.length > 0) {\n    const candidate = candidates.pop();\n    const {score: originalScore, boxIndex, suppressBeginIndex} = candidate;\n\n    if (originalScore < scoreThreshold) {\n      break;\n    }\n\n    // Overlapping boxes are likely to have similar scores, therefore we\n    // iterate through the previously selected boxes backwards in order to\n    // see if candidate's score should be suppressed. We use\n    // suppressBeginIndex to track and ensure a candidate can be suppressed\n    // by a selected box no more than once. Also, if the overlap exceeds\n    // iouThreshold, we simply ignore the candidate.\n    let ignoreCandidate = false;\n    for (let j = selectedIndices.length - 1; j >= suppressBeginIndex; --j) {\n      const iou = intersectionOverUnion(boxes, boxIndex, selectedIndices[j]);\n\n      if (iou >= iouThreshold) {\n        ignoreCandidate = true;\n        break;\n      }\n\n      candidate.score =\n          candidate.score * suppressWeight(iouThreshold, scale, iou);\n\n      if (candidate.score <= scoreThreshold) {\n        break;\n      }\n    }\n\n    // At this point, if `candidate.score` has not dropped below\n    // `scoreThreshold`, then we know that we went through all of the\n    // previous selections and can safely update `suppressBeginIndex` to the\n    // end of the selected array. Then we can re-insert the candidate with\n    // the updated score and suppressBeginIndex back in the candidate list.\n    // If on the other hand, `candidate.score` has dropped below the score\n    // threshold, we will not add it back to the candidates list.\n    candidate.suppressBeginIndex = selectedIndices.length;\n\n    if (!ignoreCandidate) {\n      // Candidate has passed all the tests, and is not suppressed, so\n      // select the candidate.\n      if (candidate.score === originalScore) {\n        selectedIndices.push(boxIndex);\n        selectedScores.push(candidate.score);\n      } else if (candidate.score > scoreThreshold) {\n        // Candidate's score is suppressed but is still high enough to be\n        // considered, so add back to the candidates list.\n        binaryInsert(candidates, candidate, ascendingComparator);\n      }\n    }\n  }\n\n  // NonMaxSuppressionV4 feature: padding output to maxOutputSize.\n  const validOutputs = selectedIndices.length;\n  const elemsToPad = maxOutputSize - validOutputs;\n\n  if (padToMaxOutputSize && elemsToPad > 0) {\n    selectedIndices.push(...new Array(elemsToPad).fill(0));\n    selectedScores.push(...new Array(elemsToPad).fill(0.0));\n  }\n\n  const result: NonMaxSuppressionResult = {selectedIndices};\n\n  if (returnScoresTensor) {\n    result['selectedScores'] = selectedScores;\n  }\n\n  if (returnValidOutputs) {\n    result['validOutputs'] = validOutputs;\n  }\n\n  return result;\n}\n\nfunction intersectionOverUnion(boxes: TypedArray, i: number, j: number) {\n  const iCoord = boxes.subarray(i * 4, i * 4 + 4);\n  const jCoord = boxes.subarray(j * 4, j * 4 + 4);\n  const yminI = Math.min(iCoord[0], iCoord[2]);\n  const xminI = Math.min(iCoord[1], iCoord[3]);\n  const ymaxI = Math.max(iCoord[0], iCoord[2]);\n  const xmaxI = Math.max(iCoord[1], iCoord[3]);\n  const yminJ = Math.min(jCoord[0], jCoord[2]);\n  const xminJ = Math.min(jCoord[1], jCoord[3]);\n  const ymaxJ = Math.max(jCoord[0], jCoord[2]);\n  const xmaxJ = Math.max(jCoord[1], jCoord[3]);\n  const areaI = (ymaxI - yminI) * (xmaxI - xminI);\n  const areaJ = (ymaxJ - yminJ) * (xmaxJ - xminJ);\n  if (areaI <= 0 || areaJ <= 0) {\n    return 0.0;\n  }\n  const intersectionYmin = Math.max(yminI, yminJ);\n  const intersectionXmin = Math.max(xminI, xminJ);\n  const intersectionYmax = Math.min(ymaxI, ymaxJ);\n  const intersectionXmax = Math.min(xmaxI, xmaxJ);\n  const intersectionArea = Math.max(intersectionYmax - intersectionYmin, 0.0) *\n      Math.max(intersectionXmax - intersectionXmin, 0.0);\n  return intersectionArea / (areaI + areaJ - intersectionArea);\n}\n\n// A Gaussian penalty function, this method always returns values in [0, 1].\n// The weight is a function of similarity, the more overlap two boxes are, the\n// smaller the weight is, meaning highly overlapping boxe will be significantly\n// penalized. On the other hand, a non-overlapping box will not be penalized.\nfunction suppressWeight(iouThreshold: number, scale: number, iou: number) {\n  const weight = Math.exp(scale * iou * iou);\n  return iou <= iouThreshold ? weight : 0.0;\n}\n\nfunction ascendingComparator(c1: Candidate, c2: Candidate) {\n  // For objects with same scores, we make the object with the larger index go\n  // first. In an array that pops from the end, this means that the object with\n  // the smaller index will be popped first. This ensures the same output as\n  // the TensorFlow python version.\n  return (c1.score - c2.score) ||\n      ((c1.score === c2.score) && (c2.boxIndex - c1.boxIndex));\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {nonMaxSuppressionV3Impl} from '../../backends/non_max_suppression_impl';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This is the async version of `nonMaxSuppression`\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @return A 1D tensor with the selected box indices.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nasync function nonMaxSuppressionAsync_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY): Promise<Tensor1D> {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n\n  const inputs = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold);\n  maxOutputSize = inputs.maxOutputSize;\n  iouThreshold = inputs.iouThreshold;\n  scoreThreshold = inputs.scoreThreshold;\n\n  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n  const boxesVals = boxesAndScores[0];\n  const scoresVals = boxesAndScores[1];\n\n  // We call a cpu based impl directly with the typedarray data  here rather\n  // than a kernel because all kernels are synchronous (and thus cannot await\n  // .data()).\n  const {selectedIndices} = nonMaxSuppressionV3Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return tensor1d(selectedIndices, 'int32');\n}\n\nexport const nonMaxSuppressionAsync = nonMaxSuppressionAsync_;\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {NonMaxSuppressionV5, NonMaxSuppressionV5Attrs, NonMaxSuppressionV5Inputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\n\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {op} from '../operation';\n\n/**\n * Performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This op also supports a Soft-NMS mode (c.f.\n * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\n * of other overlapping boxes, therefore favoring different regions of the image\n * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\n * parameter to be larger than 0.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param softNmsSigma A float representing the sigma parameter for Soft NMS.\n *     When sigma is 0, it falls back to nonMaxSuppression.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - selectedScores: A 1D tensor with the corresponding scores for each\n *       selected box.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction nonMaxSuppressionWithScore_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    softNmsSigma = 0.0): NamedTensorMap {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      softNmsSigma);\n  maxOutputSize = params.maxOutputSize;\n  iouThreshold = params.iouThreshold;\n  scoreThreshold = params.scoreThreshold;\n  softNmsSigma = params.softNmsSigma;\n\n  const inputs: NonMaxSuppressionV5Inputs = {boxes: $boxes, scores: $scores};\n  const attrs: NonMaxSuppressionV5Attrs =\n      {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const result = ENGINE.runKernel(\n                     NonMaxSuppressionV5, inputs as {} as NamedTensorMap,\n                     attrs as {} as NamedAttrMap) as Tensor[];\n\n  return {selectedIndices: result[0], selectedScores: result[1]};\n}\n\nexport const nonMaxSuppressionWithScore = op({nonMaxSuppressionWithScore_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {nonMaxSuppressionV5Impl} from '../../backends/non_max_suppression_impl';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Asynchronously performs non maximum suppression of bounding boxes based on\n * iou (intersection over union).\n *\n * This op also supports a Soft-NMS mode (c.f.\n * Bodla et al, https://arxiv.org/abs/1704.04503) where boxes reduce the score\n * of other overlapping boxes, therefore favoring different regions of the image\n * with high scores. To enable this Soft-NMS mode, set the `softNmsSigma`\n * parameter to be larger than 0.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param softNmsSigma A float representing the sigma parameter for Soft NMS.\n *     When sigma is 0, it falls back to nonMaxSuppression.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - selectedScores: A 1D tensor with the corresponding scores for each\n *       selected box.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nasync function nonMaxSuppressionWithScoreAsync_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    softNmsSigma = 0.0): Promise<NamedTensorMap> {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      softNmsSigma);\n  maxOutputSize = params.maxOutputSize;\n  iouThreshold = params.iouThreshold;\n  scoreThreshold = params.scoreThreshold;\n  softNmsSigma = params.softNmsSigma;\n\n  const boxesAndScores = await Promise.all([$boxes.data(), $scores.data()]);\n  const boxesVals = boxesAndScores[0];\n  const scoresVals = boxesAndScores[1];\n\n  // We call a cpu based impl directly with the typedarray data  here rather\n  // than a kernel because all kernels are synchronous (and thus cannot await\n  // .data()).\n  const {selectedIndices, selectedScores} = nonMaxSuppressionV5Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold,\n      softNmsSigma);\n\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return {\n    selectedIndices: tensor1d(selectedIndices, 'int32'),\n    selectedScores: tensor1d(selectedScores)\n  };\n}\n\nexport const nonMaxSuppressionWithScoreAsync = nonMaxSuppressionWithScoreAsync_;\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {NonMaxSuppressionV4, NonMaxSuppressionV4Attrs, NonMaxSuppressionV4Inputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\n\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {op} from '../operation';\n\n/**\n * Asynchronously performs non maximum suppression of bounding boxes based on\n * iou (intersection over union), with an option to pad results.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param padToMaxOutputSize Defalts to false. If true, size of output\n *     `selectedIndices` is padded to maxOutputSize.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - validOutputs: A scalar denoting how many elements in `selectedIndices`\n *       are valid. Valid elements occur first, then padding.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction nonMaxSuppressionPadded_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    padToMaxOutputSize = false): NamedTensorMap {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppression');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppression');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      null /* softNmsSigma */);\n  const $maxOutputSize = params.maxOutputSize;\n  const $iouThreshold = params.iouThreshold;\n  const $scoreThreshold = params.scoreThreshold;\n\n  const inputs: NonMaxSuppressionV4Inputs = {boxes: $boxes, scores: $scores};\n  const attrs: NonMaxSuppressionV4Attrs = {\n    maxOutputSize: $maxOutputSize,\n    iouThreshold: $iouThreshold,\n    scoreThreshold: $scoreThreshold,\n    padToMaxOutputSize\n  };\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const result = ENGINE.runKernel(\n                     NonMaxSuppressionV4, inputs as {} as NamedTensorMap,\n                     attrs as {} as NamedAttrMap) as Tensor[];\n\n  return {selectedIndices: result[0], validOutputs: result[1]};\n}\n\nexport const nonMaxSuppressionPadded = op({nonMaxSuppressionPadded_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {nonMaxSuppressionV4Impl} from '../../backends/non_max_suppression_impl';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {nonMaxSuppSanityCheck} from '../nonmax_util';\nimport {scalar} from '../scalar';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Asynchronously performs non maximum suppression of bounding boxes based on\n * iou (intersection over union), with an option to pad results.\n *\n * @param boxes a 2d tensor of shape `[numBoxes, 4]`. Each entry is\n *     `[y1, x1, y2, x2]`, where `(y1, x1)` and `(y2, x2)` are the corners of\n *     the bounding box.\n * @param scores a 1d tensor providing the box scores of shape `[numBoxes]`.\n * @param maxOutputSize The maximum number of boxes to be selected.\n * @param iouThreshold A float representing the threshold for deciding whether\n *     boxes overlap too much with respect to IOU. Must be between [0, 1].\n *     Defaults to 0.5 (50% box overlap).\n * @param scoreThreshold A threshold for deciding when to remove boxes based\n *     on score. Defaults to -inf, which means any score is accepted.\n * @param padToMaxOutputSize Defalts to false. If true, size of output\n *     `selectedIndices` is padded to maxOutputSize.\n * @return A map with the following properties:\n *     - selectedIndices: A 1D tensor with the selected box indices.\n *     - validOutputs: A scalar denoting how many elements in `selectedIndices`\n *       are valid. Valid elements occur first, then padding.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nasync function nonMaxSuppressionPaddedAsync_(\n    boxes: Tensor2D|TensorLike, scores: Tensor1D|TensorLike,\n    maxOutputSize: number, iouThreshold = 0.5,\n    scoreThreshold = Number.NEGATIVE_INFINITY,\n    padToMaxOutputSize = false): Promise<NamedTensorMap> {\n  const $boxes = convertToTensor(boxes, 'boxes', 'nonMaxSuppressionAsync');\n  const $scores = convertToTensor(scores, 'scores', 'nonMaxSuppressionAsync');\n\n  const params = nonMaxSuppSanityCheck(\n      $boxes, $scores, maxOutputSize, iouThreshold, scoreThreshold,\n      null /* softNmsSigma */);\n  const $maxOutputSize = params.maxOutputSize;\n  const $iouThreshold = params.iouThreshold;\n  const $scoreThreshold = params.scoreThreshold;\n\n  const [boxesVals, scoresVals] =\n      await Promise.all([$boxes.data(), $scores.data()]);\n\n  // We call a cpu based impl directly with the typedarray data here rather\n  // than a kernel because all kernels are synchronous (and thus cannot await\n  // .data()).\n  const {selectedIndices, validOutputs} = nonMaxSuppressionV4Impl(\n      boxesVals, scoresVals, $maxOutputSize, $iouThreshold, $scoreThreshold,\n      padToMaxOutputSize);\n\n  if ($boxes !== boxes) {\n    $boxes.dispose();\n  }\n  if ($scores !== scores) {\n    $scores.dispose();\n  }\n\n  return {\n    selectedIndices: tensor1d(selectedIndices, 'int32'),\n    validOutputs: scalar(validOutputs, 'int32')\n  };\n}\n\nexport const nonMaxSuppressionPaddedAsync = nonMaxSuppressionPaddedAsync_;\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {ResizeBilinear, ResizeBilinearAttrs, ResizeBilinearInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\n\n/**\n * Bilinear resize a single 3D image or a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to `false`. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n * @param halfPixelCenters Defaults to `false`. Whether to assume pixel centers\n *     are at 0.5, which would make the floating point coordinates of the top\n *     left pixel 0.5, 0.5.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction resizeBilinear_<T extends Tensor3D|Tensor4D>(\n    images: T|TensorLike, size: [number, number], alignCorners = false,\n    halfPixelCenters = false): T {\n  const $images = convertToTensor(images, 'images', 'resizeBilinear');\n\n  util.assert(\n      $images.rank === 3 || $images.rank === 4,\n      () => `Error in resizeBilinear: x must be rank 3 or 4, but got ` +\n          `rank ${$images.rank}.`);\n  util.assert(\n      size.length === 2,\n      () => `Error in resizeBilinear: new shape must 2D, but got shape ` +\n          `${size}.`);\n  util.assert(\n      halfPixelCenters === false || alignCorners === false,\n      () => `Error in resizeBilinear: If halfPixelCenters is true, ` +\n          `alignCorners must be false.`);\n\n  let batchImages = $images as Tensor4D;\n  let reshapedTo4D = false;\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages = reshape(\n        $images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);\n  }\n\n  const [] = size;\n\n  const inputs: ResizeBilinearInputs = {images: batchImages};\n  const attrs: ResizeBilinearAttrs = {alignCorners, halfPixelCenters, size};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  ResizeBilinear, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const resizeBilinear = op({resizeBilinear_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {ResizeNearestNeighbor, ResizeNearestNeighborAttrs, ResizeNearestNeighborInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor3D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\n\n/**\n * NearestNeighbor resize a batch of 3D images to a new shape.\n *\n * @param images The images, of rank 4 or rank 3, of shape\n *     `[batch, height, width, inChannels]`. If rank 3, batch of 1 is assumed.\n * @param size The new shape `[newHeight, newWidth]` to resize the\n *     images to. Each channel is resized individually.\n * @param alignCorners Defaults to False. If true, rescale\n *     input by `(new_height - 1) / (height - 1)`, which exactly aligns the 4\n *     corners of images and resized images. If false, rescale by\n *     `new_height / height`. Treat similarly the width dimension.\n * @param halfPixelCenters Defaults to `false`. Whether to assumes pixels are of\n *      half the actual dimensions, and yields more accurate resizes. This flag\n *      would also make the floating point coordinates of the top left pixel\n *      0.5, 0.5.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction resizeNearestNeighbor_<T extends Tensor3D|Tensor4D>(\n    images: T|TensorLike, size: [number, number], alignCorners = false,\n    halfPixelCenters = false): T {\n  const $images = convertToTensor(images, 'images', 'resizeNearestNeighbor');\n\n  util.assert(\n      $images.rank === 3 || $images.rank === 4,\n      () => `Error in resizeNearestNeighbor: x must be rank 3 or 4, but got ` +\n          `rank ${$images.rank}.`);\n  util.assert(\n      size.length === 2,\n      () =>\n          `Error in resizeNearestNeighbor: new shape must 2D, but got shape ` +\n          `${size}.`);\n  util.assert(\n      $images.dtype === 'float32' || $images.dtype === 'int32',\n      () => '`images` must have `int32` or `float32` as dtype');\n  util.assert(\n      halfPixelCenters === false || alignCorners === false,\n      () => `Error in resizeNearestNeighbor: If halfPixelCenters is true, ` +\n          `alignCorners must be false.`);\n  let batchImages = $images as Tensor4D;\n  let reshapedTo4D = false;\n  if ($images.rank === 3) {\n    reshapedTo4D = true;\n    batchImages = reshape(\n        $images, [1, $images.shape[0], $images.shape[1], $images.shape[2]]);\n  }\n  const [] = size;\n\n  const inputs: ResizeNearestNeighborInputs = {images: batchImages};\n  const attrs:\n      ResizeNearestNeighborAttrs = {alignCorners, halfPixelCenters, size};\n\n  // tslint:disable-next-line: no-unnecessary-type-assertion\n  const res = ENGINE.runKernel(\n                  ResizeNearestNeighbor, inputs as {} as NamedTensorMap,\n                  attrs as {} as NamedAttrMap) as T;\n\n  if (reshapedTo4D) {\n    return reshape(res, [res.shape[1], res.shape[2], res.shape[3]]) as T;\n  }\n  return res;\n}\n\nexport const resizeNearestNeighbor = op({resizeNearestNeighbor_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { Tensor1D, Tensor3D } from '../../tensor';\nimport { tensor1d } from '../tensor1d';\nimport { TensorLike } from '../../types';\nimport { op } from '../operation';\nimport { cast } from '../cast';\nimport { split } from '../split';\nimport { bincount } from '../bincount';\nimport { lessEqual } from '../less_equal';\nimport { greater } from '../greater';\nimport { sum } from '../sum';\nimport { add } from '../add';\nimport { mul } from '../mul';\nimport { div } from '../div';\nimport { sub } from '../sub';\nimport { round } from '../round';\nimport { where } from '../where';\nimport { fill } from '../fill';\nimport {slice} from '../slice';\nimport { range } from '../range';\nimport { tensor } from '../tensor';\nimport * as util from '../../util';\nimport { convertToTensor } from '../../tensor_util_env';\n\n/**\n * Performs image binarization with corresponding threshold\n * (depends on the method)value, which creates a binary image from a grayscale.\n * @param image 3d tensor of shape [imageHeight,imageWidth, depth],\n * where imageHeight and imageWidth must be positive.The image color\n * range should be [0, 255].\n * @param method Optional string from `'binary' | 'otsu'`\n * which specifies the method for thresholding. Defaults to 'binary'.\n * @param inverted Optional boolean whichspecifies\n * if colours should be inverted. Defaults to false.\n * @param threshValue Optional number which defines threshold value from 0 to 1.\n * Defaults to 0.5.\n * @return A 3d tensor of shape [imageHeight,imageWidth, depth], which\n * contains binarized image.\n */\n\nfunction threshold_(\n    image: Tensor3D | TensorLike,\n    method = 'binary',\n    inverted = false,\n    threshValue = 0.5\n): Tensor3D {\n    const $image = convertToTensor(image, 'image', 'threshold');\n\n    /* 0.2989, 0.5870, 0.1140 are represent luma coefficients in CCIR601.\n\tReference for converting between RGB and grayscale: https://en.wikipedia.org/wiki/Luma_%28video%29  */\n\n    const RED_INTENCITY_COEF = 0.2989;\n    const GREEN_INTENCITY_COEF = 0.5870;\n    const BLUE_INTENCITY_COEF = 0.1140;\n    const totalPixelsInImage = $image.shape[0] * $image.shape[1];\n\n    let $threshold = mul(tensor1d([threshValue]), 255);\n    let r, g, b, grayscale;\n\n    util.assert(\n        $image.rank === 3,\n        () => 'Error in threshold: image must be rank 3,' +\n            `but got rank ${$image.rank}.`);\n\n    util.assert(\n        $image.shape[2] === 3 || $image.shape[2]=== 1,\n        () => 'Error in threshold: ' +\n            'image color channel must be equal to 3 or 1' +\n            `but got ${$image.shape[2]}.`);\n\n    util.assert(\n      $image.dtype === 'int32' || $image.dtype === 'float32',\n      () => 'Error in dtype: image dtype must be int32 or float32,' +\n          `but got dtype ${$image.dtype}.`);\n\n    util.assert(\n      method === 'otsu' || method === 'binary',\n      () => `Method must be binary or otsu, but was ${method}`);\n\n    if ($image.shape[2] === 3) {\n        [r, g, b] = split($image, [1, 1, 1], -1);\n        const $r = mul(r,RED_INTENCITY_COEF);\n        const $g = mul(g,GREEN_INTENCITY_COEF);\n        const $b = mul(b,BLUE_INTENCITY_COEF);\n        grayscale = add(add($r, $g), $b);\n    } else {\n        grayscale = image;\n    }\n\n    if (method === 'otsu') {\n        const $histogram = bincount(cast(round(grayscale), 'int32') as Tensor1D,\n            tensor([]),\n            256);\n        $threshold = otsu($histogram, totalPixelsInImage);\n    }\n\n    const invCondition = inverted ?\n        lessEqual(grayscale, $threshold) : greater(grayscale, $threshold);\n\n    const result = cast(mul(invCondition,255), 'int32');\n\n    return result as Tensor3D;\n}\n\nfunction otsu(histogram: Tensor1D, total: number):Tensor1D {\n\n    let bestThresh = tensor1d([-1]);\n    let bestInBetVar = tensor1d([0]);\n    let cInBetVar = tensor1d([0]);\n    let classFirst, classSecond, meanFirst,\n        meanSec, weightForeground, weightBack;\n\n    for (let index = 0; index < histogram.size-1; index++) {\n\n        classFirst = slice(histogram, 0, index + 1);\n\n        classSecond = slice(histogram,index + 1);\n\n        weightForeground = div(sum(classFirst),total);\n\n        weightBack = div(sum(classSecond),total);\n\n        const meanFirstDivA = sum(mul(classFirst, range(0, classFirst.size)));\n\n        meanFirst = div(meanFirstDivA, sum(classFirst) );\n\n        const meanSecFill = fill(classSecond.shape, classFirst.size);\n        const meanSecAdd = add(range(0,classSecond.size),meanSecFill);\n        const meanSecMul = mul(classSecond, (meanSecAdd));\n        meanSec = div(sum(meanSecMul), sum(classSecond));\n\n        const cInBetVarSubA = sub(meanFirst, meanSec);\n        const cInBetVarSubB = sub(meanFirst, meanSec);\n        const cInBetVarMul = mul(weightForeground, weightBack);\n        cInBetVar = mul(mul(cInBetVarMul,cInBetVarSubA), cInBetVarSubB);\n\n        const condition = greater(cInBetVar, bestInBetVar);\n\n        bestInBetVar = where(condition, cInBetVar, bestInBetVar);\n\n        bestThresh = where(condition, tensor1d([index]), bestThresh);\n\n    }\n    return bestThresh;\n}\n\nexport const threshold = op({ threshold_ });\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../../engine';\nimport {Transform, TransformAttrs, TransformInputs} from '../../kernel_names';\nimport {NamedAttrMap} from '../../kernel_registry';\nimport {Tensor2D, Tensor4D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\n\nimport {op} from '../operation';\n\n/**\n * Applies the given transform(s) to the image(s).\n *\n * @param image 4d tensor of shape `[batch, imageHeight, imageWidth, depth]`.\n * @param transforms Projective transform matrix/matrices. A tensor1d of length\n *     8 or tensor of size N x 8. If one row of transforms is [a0, a1, a2, b0\n *     b1, b2, c0, c1], then it maps the output point (x, y) to a transformed\n *     input point (x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k),\n *     where k = c0 x + c1 y + 1. The transforms are inverted compared to the\n *     transform mapping input points to output points.\n * @param interpolation Interpolation mode.\n *     Supported values: 'nearest', 'bilinear'. Default to 'nearest'.\n * @param fillMode Points outside the boundaries of the input are filled\n *     according to the given mode, one of 'constant', 'reflect', 'wrap',\n *     'nearest'. Default to 'constant'.\n *     'reflect': (d c b a | a b c d | d c b a ) The input is extended by\n *     reflecting about the edge of the last pixel.\n *     'constant': (k k k k | a b c d | k k k k) The input is extended by\n *     filling all values beyond the edge with the same constant value k.\n *     'wrap': (a b c d | a b c d | a b c d) The input is extended by\n *     wrapping around to the opposite edge.\n *     'nearest': (a a a a | a b c d | d d d d) The input is extended by\n *     the nearest pixel.\n * @param fillValue A float represents the value to be filled outside the\n *     boundaries when fillMode is 'constant'.\n * @param Output dimension after the transform, [height, width]. If undefined,\n *     output is the same size as input image.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction transform_(\n    image: Tensor4D|TensorLike, transforms: Tensor2D|TensorLike,\n    interpolation: 'nearest'|'bilinear' = 'nearest',\n    fillMode: 'constant'|'reflect'|'wrap'|'nearest' = 'constant', fillValue = 0,\n    outputShape?: [number, number]): Tensor4D {\n  const $image = convertToTensor(image, 'image', 'transform', 'float32');\n  const $transforms =\n      convertToTensor(transforms, 'transforms', 'transform', 'float32');\n\n  util.assert(\n      $image.rank === 4,\n      () => 'Error in transform: image must be rank 4,' +\n          `but got rank ${$image.rank}.`);\n\n  util.assert(\n      $transforms.rank === 2 &&\n          ($transforms.shape[0] === $image.shape[0] ||\n           $transforms.shape[0] === 1) &&\n          $transforms.shape[1] === 8,\n      () => `Error in transform: Input transform should be batch x 8 or 1 x 8`);\n\n  util.assert(\n      outputShape == null || outputShape.length === 2,\n      () =>\n          'Error in transform: outputShape must be [height, width] or null, ' +\n          `but got ${outputShape}.`);\n\n  const inputs: TransformInputs = {image: $image, transforms: $transforms};\n  const attrs:\n      TransformAttrs = {interpolation, fillMode, fillValue, outputShape};\n\n  return ENGINE.runKernel(\n      Transform, inputs as {} as NamedTensorMap, attrs as {} as NamedAttrMap);\n}\n\nexport const transform = op({transform_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assert} from '../../util';\n\nimport {greaterEqual} from '../greater_equal';\nimport {lessEqual} from '../less_equal';\nimport {logicalAnd} from '../logical_and';\nimport {op} from '../operation';\nimport {range} from '../range';\nimport {reshape} from '../reshape';\nimport {scalar} from '../scalar';\nimport {stack} from '../stack';\nimport {sub} from '../sub';\nimport {unstack} from '../unstack';\nimport {where} from '../where';\nimport {zeros} from '../zeros';\n\n/**\n * Copy a tensor setting everything outside a central band in each innermost\n * matrix to zero.\n *\n * The band part is computed as follows: Assume input has `k` dimensions\n * `[I, J, K, ..., M, N]`, then the output is a tensor with the same shape where\n * `band[i, j, k, ..., m, n] = in_band(m, n) * input[i, j, k, ..., m, n]`.\n * The indicator function\n * `in_band(m, n) = (num_lower < 0 || (m-n) <= num_lower))`\n * `&& (num_upper < 0 || (n-m) <= num_upper)`\n *\n * ```js\n * const x = tf.tensor2d([[ 0,  1,  2, 3],\n *                        [-1,  0,  1, 2],\n *                        [-2, -1,  0, 1],\n *                        [-3, -2, -1, 0]]);\n * let y = tf.linalg.bandPart(x, 1, -1);\n * y.print(); // [[ 0,  1,  2, 3],\n *            //  [-1,  0,  1, 2],\n *            //  [ 0, -1,  0, 1],\n *            //  [ 0, 0 , -1, 0]]\n * let z = tf.linalg.bandPart(x, 2, 1);\n * z.print(); // [[ 0,  1,  0, 0],\n *            //  [-1,  0,  1, 0],\n *            //  [-2, -1,  0, 1],\n *            //  [ 0, -2, -1, 0]]\n * ```\n *\n * @param x Rank `k` tensor\n * @param numLower Number of subdiagonals to keep.\n *   If negative, keep entire lower triangle.\n * @param numUpper Number of subdiagonals to keep.\n *   If negative, keep entire upper triangle.\n * @returns Rank `k` tensor of the same shape as input.\n *   The extracted banded tensor.\n *\n * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}\n */\nfunction bandPart_<T extends Tensor>(\n    a: T|TensorLike, numLower: number, numUpper: number): T {\n  assert(\n      numLower % 1 === 0,\n      () => `bandPart(): numLower must be an integer, got ${numLower}.`);\n  assert(\n      numUpper % 1 === 0,\n      () => `bandPart(): numUpper must be an integer, got ${numUpper}.`);\n\n  const $a = convertToTensor(a, 'a', 'bandPart');\n\n  assert(\n      $a.rank >= 2,\n      () => `bandPart(): Rank must be at least 2, got ${$a.rank}.`);\n\n  const shape = $a.shape;\n  const [M, N] = $a.shape.slice(-2);\n\n  if (!(numLower <= M)) {\n    throw new Error(\n        `bandPart(): numLower (${numLower})` +\n        ` must not be greater than the number of rows (${M}).`);\n  }\n  if (!(numUpper <= N)) {\n    throw new Error(\n        `bandPart(): numUpper (${numUpper})` +\n        ` must not be greater than the number of columns (${N}).`);\n  }\n\n  if (numLower < 0) {\n    numLower = M;\n  }\n  if (numUpper < 0) {\n    numUpper = N;\n  }\n\n  const i = reshape(range(0, M, 1, 'int32'), [-1, 1]);\n  const j = range(0, N, 1, 'int32');\n  const ij = sub(i, j);\n\n  const inBand = logicalAnd(\n      lessEqual(ij, scalar(+numLower, 'int32')),\n      greaterEqual(ij, scalar(-numUpper, 'int32')));\n\n  const zero = zeros([M, N], $a.dtype);\n\n  return reshape(\n             stack(unstack(reshape($a, [-1, M, N]))\n                       .map(mat => where(inBand, mat, zero))),\n             shape) as T;\n}\n\nexport const bandPart = op({bandPart_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {Tensor1D, Tensor2D} from '../../tensor';\nimport {assert} from '../../util';\n\nimport {div} from '../div';\nimport {mul} from '../mul';\nimport {norm} from '../norm';\nimport {op} from '../operation';\nimport {split} from '../split';\nimport {squeeze} from '../squeeze';\nimport {stack} from '../stack';\nimport {sub} from '../sub';\nimport {sum} from '../sum';\n\n/**\n * Gram-Schmidt orthogonalization.\n *\n * ```js\n * const x = tf.tensor2d([[1, 2], [3, 4]]);\n * let y = tf.linalg.gramSchmidt(x);\n * y.print();\n * console.log('Othogonalized:');\n * y.dot(y.transpose()).print();  // should be nearly the identity matrix.\n * console.log('First row direction maintained:');\n * const data = await y.array();\n * console.log(data[0][1] / data[0][0]);  // should be nearly 2.\n * ```\n *\n * @param xs The vectors to be orthogonalized, in one of the two following\n *   formats:\n *   - An Array of `tf.Tensor1D`.\n *   - A `tf.Tensor2D`, i.e., a matrix, in which case the vectors are the rows\n *     of `xs`.\n *   In each case, all the vectors must have the same length and the length\n *   must be greater than or equal to the number of vectors.\n * @returns The orthogonalized and normalized vectors or matrix.\n *   Orthogonalization means that the vectors or the rows of the matrix\n *   are orthogonal (zero inner products). Normalization means that each\n *   vector or each row of the matrix has an L2 norm that equals `1`.\n *\n * @doc {heading:'Operations', subheading:'Linear Algebra', namespace:'linalg'}\n */\nfunction gramSchmidt_(xs: Tensor1D[]|Tensor2D): Tensor1D[]|Tensor2D {\n  let inputIsTensor2D: boolean;\n  if (Array.isArray(xs)) {\n    inputIsTensor2D = false;\n    assert(\n        xs != null && xs.length > 0,\n        () => 'Gram-Schmidt process: input must not be null, undefined, or ' +\n            'empty');\n    const dim = xs[0].shape[0];\n    for (let i = 1; i < xs.length; ++i) {\n      assert(\n          xs[i].shape[0] === dim,\n          () =>\n              'Gram-Schmidt: Non-unique lengths found in the input vectors: ' +\n              `(${(xs as Tensor1D[])[i].shape[0]} vs. ${dim})`);\n    }\n  } else {\n    inputIsTensor2D = true;\n    xs = split(xs, xs.shape[0], 0).map(x => squeeze(x, [0]));\n  }\n\n  assert(\n      xs.length <= xs[0].shape[0],\n      () => `Gram-Schmidt: Number of vectors (${\n                (xs as Tensor1D[]).length}) exceeds ` +\n          `number of dimensions (${(xs as Tensor1D[])[0].shape[0]}).`);\n\n  const ys: Tensor1D[] = [];\n  const xs1d = xs;\n  for (let i = 0; i < xs.length; ++i) {\n    ys.push(ENGINE.tidy(() => {\n      let x = xs1d[i];\n      if (i > 0) {\n        for (let j = 0; j < i; ++j) {\n          const proj = mul(sum(mul(ys[j], x)), ys[j]);\n          x = sub(x, proj);\n        }\n      }\n      return div(x, norm(x, 'euclidean'));\n    }));\n  }\n\n  if (inputIsTensor2D) {\n    return stack(ys, 0) as Tensor2D;\n  } else {\n    return ys;\n  }\n}\n\nexport const gramSchmidt = op({gramSchmidt_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {ENGINE} from '../../engine';\nimport {dispose} from '../../globals';\nimport {Tensor, Tensor2D} from '../../tensor';\nimport {assert} from '../../util';\n\nimport {clone} from '../clone';\nimport {concat} from '../concat';\nimport {div} from '../div';\nimport {eye} from '../eye';\nimport {greater} from '../greater';\nimport {matMul} from '../mat_mul';\nimport {mul} from '../mul';\nimport {neg} from '../neg';\nimport {norm} from '../norm';\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\nimport {slice} from '../slice';\nimport {stack} from '../stack';\nimport {sub} from '../sub';\nimport {tensor2d} from '../tensor2d';\nimport {transpose} from '../transpose';\nimport {unstack} from '../unstack';\nimport {where} from '../where';\n\n/**\n * Compute QR decomposition of m-by-n matrix using Householder transformation.\n *\n * Implementation based on\n *   [http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf]\n * (http://www.cs.cornell.edu/~bindel/class/cs6210-f09/lec18.pdf)\n *\n * ```js\n * const a = tf.tensor2d([[1, 2], [3, 4]]);\n * let [q, r] = tf.linalg.qr(a);\n * console.log('Q');\n * q.print();\n * console.log('R');\n * r.print();\n * console.log('Orthogonalized');\n * q.dot(q.transpose()).print()  // should be nearly the identity matrix.\n * console.log('Reconstructed');\n * q.dot(r).print(); // should be nearly [[1, 2], [3, 4]];\n * ```\n *\n * @param x The `tf.Tensor` to be QR-decomposed. Must have rank >= 2. Suppose\n *   it has the shape `[..., M, N]`.\n * @param fullMatrices An optional boolean parameter. Defaults to `false`.\n *   If `true`, compute full-sized `Q`. If `false` (the default),\n *   compute only the leading N columns of `Q` and `R`.\n * @returns An `Array` of two `tf.Tensor`s: `[Q, R]`. `Q` is a unitary matrix,\n *   i.e., its columns all have unit norm and are mutually orthogonal.\n *   If `M >= N`,\n *     If `fullMatrices` is `false` (default),\n *       - `Q` has a shape of `[..., M, N]`,\n *       - `R` has a shape of `[..., N, N]`.\n *     If `fullMatrices` is `true` (default),\n *       - `Q` has a shape of `[..., M, M]`,\n *       - `R` has a shape of `[..., M, N]`.\n *   If `M < N`,\n *     - `Q` has a shape of `[..., M, M]`,\n *     - `R` has a shape of `[..., M, N]`.\n * @throws If the rank of `x` is less than 2.\n *\n * @doc {heading:'Operations',\n *       subheading:'Linear Algebra',\n *       namespace:'linalg'}\n */\nfunction qr_(x: Tensor, fullMatrices = false): [Tensor, Tensor] {\n  assert(\n      x.rank >= 2,\n      () => `qr() requires input tensor to have a rank >= 2, but got rank ${\n          x.rank}`);\n\n  if (x.rank === 2) {\n    return qr2d(x as Tensor2D, fullMatrices);\n  } else {\n    // Rank > 2.\n    // TODO(cais): Below we split the input into individual 2D tensors,\n    //   perform QR decomposition on them and then stack the results back\n    //   together. We should explore whether this can be parallelized.\n    const outerDimsProd = x.shape.slice(0, x.shape.length - 2)\n                              .reduce((value, prev) => value * prev);\n    const x2ds = unstack(\n        reshape(\n            x,\n            [\n              outerDimsProd, x.shape[x.shape.length - 2],\n              x.shape[x.shape.length - 1]\n            ]),\n        0);\n    const q2ds: Tensor2D[] = [];\n    const r2ds: Tensor2D[] = [];\n    x2ds.forEach(x2d => {\n      const [q2d, r2d] = qr2d(x2d as Tensor2D, fullMatrices);\n      q2ds.push(q2d);\n      r2ds.push(r2d);\n    });\n    const q = reshape(stack(q2ds, 0), x.shape);\n    const r = reshape(stack(r2ds, 0), x.shape);\n    return [q, r];\n  }\n}\n\nfunction qr2d(x: Tensor2D, fullMatrices = false): [Tensor2D, Tensor2D] {\n  return ENGINE.tidy(() => {\n    assert(\n        x.shape.length === 2,\n        () => `qr2d() requires a 2D Tensor, but got a ${\n            x.shape.length}D Tensor.`);\n\n    const m = x.shape[0];\n    const n = x.shape[1];\n\n    let q = eye(m);    // Orthogonal transform so far.\n    let r = clone(x);  // Transformed matrix so far.\n\n    const one2D = tensor2d([[1]], [1, 1]);\n    let w: Tensor2D = clone(one2D);\n\n    const iters = m >= n ? n : m;\n    for (let j = 0; j < iters; ++j) {\n      // This tidy within the for-loop ensures we clean up temporary\n      // tensors as soon as they are no longer needed.\n      const rTemp = r;\n      const wTemp = w;\n      const qTemp = q;\n      [w, r, q] = ENGINE.tidy((): [Tensor2D, Tensor2D, Tensor2D] => {\n        // Find H = I - tau * w * w', to put zeros below R(j, j).\n        const rjEnd1 = slice(r, [j, j], [m - j, 1]);\n        const normX = norm(rjEnd1);\n        const rjj = slice(r, [j, j], [1, 1]);\n\n        // The sign() function returns 0 on 0, which causes division by zero.\n        const s = where(greater(rjj, 0), tensor2d([[-1]]), tensor2d([[1]]));\n\n        const u1 = sub(rjj, mul(s, normX));\n        const wPre = div(rjEnd1, u1);\n        if (wPre.shape[0] === 1) {\n          w = clone(one2D);\n        } else {\n          w = concat(\n              [\n                one2D,\n                slice(wPre, [1, 0], [wPre.shape[0] - 1, wPre.shape[1]]) as\n                    Tensor2D\n              ],\n              0);\n        }\n        const tau = neg(div(matMul(s, u1), normX)) as Tensor2D;\n\n        // -- R := HR, Q := QH.\n        const rjEndAll = slice(r, [j, 0], [m - j, n]);\n        const tauTimesW: Tensor2D = mul(tau, w);\n        const wT: Tensor2D = transpose(w);\n        if (j === 0) {\n          r = sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));\n        } else {\n          const rTimesTau: Tensor2D =\n              sub(rjEndAll, matMul(tauTimesW, matMul(wT, rjEndAll)));\n          r = concat([slice(r, [0, 0], [j, n]), rTimesTau], 0);\n        }\n        const tawTimesWT: Tensor2D = transpose(tauTimesW);\n        const qAllJEnd = slice(q, [0, j], [m, q.shape[1] - j]);\n        if (j === 0) {\n          q = sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));\n        } else {\n          const qTimesTau: Tensor2D =\n              sub(qAllJEnd, matMul(matMul(qAllJEnd, w), tawTimesWT));\n          q = concat([slice(q, [0, 0], [m, j]), qTimesTau], 1);\n        }\n        return [w, r, q];\n      });\n      dispose([rTemp, wTemp, qTemp]);\n    }\n\n    if (!fullMatrices && m > n) {\n      q = slice(q, [0, 0], [m, n]);\n      r = slice(r, [0, 0], [n, n]);\n    }\n\n    return [q, r];\n  }) as [Tensor2D, Tensor2D];\n}\n\nexport const qr = op({qr_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum Reduction {\n  NONE,\n  MEAN,\n  SUM,\n  SUM_BY_NONZERO_WEIGHTS\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\n\nimport {cast} from '../cast';\nimport {div} from '../div';\nimport {Reduction} from '../loss_ops_utils';\nimport {mean} from '../mean';\nimport {mul} from '../mul';\nimport {notEqual} from '../not_equal';\nimport {ones} from '../ones';\nimport {op} from '../operation';\nimport {scalar} from '../scalar';\nimport {sum} from '../sum';\n\n/**\n * Computes the weighted loss between two tensors.\n *\n * @param losses Tensor of shape `[batch_size, d1, ... dN]`.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `losses`, and must be broadcastable to `losses` (i.e., all\n *    dimensions must be either `1`, or the same as the corresponding\n *    `losses` dimension).\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction computeWeightedLoss_<T extends Tensor, O extends Tensor>(\n    losses: T|TensorLike, weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $losses = convertToTensor(losses, 'losses', 'computeWeightedLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'computeWeightedLoss');\n  }\n\n  const weightedLoss = ($weights == null) ? $losses : mul($losses, $weights);\n\n  if (reduction === Reduction.NONE) {\n    return weightedLoss as O;\n  }\n  if (reduction === Reduction.SUM) {\n    return sum(weightedLoss);\n  }\n  if (reduction === Reduction.MEAN) {\n    if ($weights == null) {\n      return mean(weightedLoss);\n    } else {\n      const broadcastFactor = $losses.size / $weights.size;\n      const result = div(sum(weightedLoss), sum($weights));\n      return broadcastFactor > 1 ? div(result, scalar(broadcastFactor)) :\n                                   result as O;\n    }\n  }\n  if (reduction === Reduction.SUM_BY_NONZERO_WEIGHTS) {\n    if ($weights == null) {\n      return div(sum(weightedLoss), scalar($losses.size));\n    } else {\n      const broadcastedWeights = mul($weights, ones($losses.shape));\n\n      const numNonZeros =\n          cast(sum(notEqual(broadcastedWeights, scalar(0))), 'float32');\n      return div(sum(weightedLoss), numNonZeros);\n    }\n  }\n\n  throw Error(`Unknown reduction: ${reduction}`);\n}\nexport const computeWeightedLoss = op({computeWeightedLoss_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {abs} from '../abs';\nimport {Reduction} from '../loss_ops_utils';\nimport {op} from '../operation';\nimport {sub} from '../sub';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\n/**\n * Computes the absolute difference loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction absoluteDifference_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'absoluteDifference');\n  const $predictions =\n      convertToTensor(predictions, 'predictions', 'absoluteDifference');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'absoluteDifference');\n  }\n  assertShapesMatch(\n      $labels.shape, $predictions.shape, 'Error in absoluteDifference: ');\n\n  const losses = abs(sub($labels, $predictions));\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\nexport const absoluteDifference = op({absoluteDifference_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {Reduction} from '../loss_ops_utils';\nimport {mul} from '../mul';\nimport {op} from '../operation';\nimport {scalar} from '../scalar';\nimport {sub} from '../sub';\nimport {sum} from '../sum';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\n/**\n * Computes the cosine distance loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param axis The dimension along which the cosine distance is computed.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction cosineDistance_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike, axis: number,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'cosineDistance');\n  const $predictions =\n      convertToTensor(predictions, 'predictions', 'cosineDistance');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'cosineDistance');\n  }\n  assertShapesMatch(\n      $labels.shape, $predictions.shape, 'Error in cosineDistance: ');\n\n  const one = scalar(1);\n  const losses = sub(one, sum(mul($labels, $predictions), axis, true));\n  return computeWeightedLoss(losses, $weights, reduction);\n}\nexport const cosineDistance = op({cosineDistance_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {Reduction} from '../loss_ops_utils';\nimport {mul} from '../mul';\nimport {op} from '../operation';\nimport {relu} from '../relu';\nimport {scalar} from '../scalar';\nimport {sub} from '../sub';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\n/**\n * Computes the Hinge loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction hingeLoss_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  let $labels = convertToTensor(labels, 'labels', 'hingeLoss');\n  const $predictions = convertToTensor(predictions, 'predictions', 'hingeLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'hingeLoss');\n  }\n  assertShapesMatch($labels.shape, $predictions.shape, 'Error in hingeLoss: ');\n\n  const one = scalar(1);\n  // Convert binary labels to (-1, 1)\n  $labels = sub(mul(scalar(2), $labels), one);\n  const losses = relu(sub(one, mul($labels, $predictions)));\n  return computeWeightedLoss(losses, $weights, reduction);\n}\nexport const hingeLoss = op({hingeLoss_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {abs} from '../abs';\nimport {add} from '../add';\nimport {Reduction} from '../loss_ops_utils';\nimport {minimum} from '../minimum';\nimport {mul} from '../mul';\nimport {op} from '../operation';\nimport {scalar} from '../scalar';\nimport {square} from '../square';\nimport {sub} from '../sub';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\n/**\n * Computes the huber loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param delta Point where huber loss changes from quadratic to linear.\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`.\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction huberLoss_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike, delta = 1.0,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'huberLoss');\n  const $predictions = convertToTensor(predictions, 'predictions', 'huberLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'huberLoss');\n  }\n  assertShapesMatch($labels.shape, $predictions.shape, 'Error in huberLoss: ');\n\n  const deltaScalar = scalar(delta);\n  const error = abs(sub($predictions, $labels));\n  const quadratic = minimum(error, deltaScalar);\n  const linear = sub(error, quadratic);\n\n  const losses =\n      add(mul(scalar(0.5), square(quadratic)), mul(deltaScalar, linear));\n  return computeWeightedLoss(losses, $weights, reduction);\n}\nexport const huberLoss = op({huberLoss_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {add} from '../add';\nimport {log} from '../log';\nimport {Reduction} from '../loss_ops_utils';\nimport {mul} from '../mul';\nimport {neg} from '../neg';\nimport {op} from '../operation';\nimport {scalar} from '../scalar';\nimport {sub} from '../sub';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\n/**\n * Computes the log loss between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param epsilon A small increment to avoid taking log of zero\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction logLoss_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike, epsilon = 1e-7,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'logLoss');\n  const $predictions = convertToTensor(predictions, 'predictions', 'logLoss');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'logLoss');\n  }\n  assertShapesMatch($labels.shape, $predictions.shape, 'Error in logLoss: ');\n\n  const one = scalar(1);\n  const epsilonScalar = scalar(epsilon);\n\n  const l1 = neg(mul($labels, log(add($predictions, epsilonScalar))));\n  const l2 =\n      mul(sub(one, $labels), log(add(sub(one, $predictions), epsilonScalar)));\n  const losses = sub(l1, l2);\n  return computeWeightedLoss(losses, $weights, reduction);\n}\nexport const logLoss = op({logLoss_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {Reduction} from '../loss_ops_utils';\nimport {op} from '../operation';\nimport {squaredDifference} from '../squared_difference';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\n/**\n * Computes the mean squared error between two tensors.\n *\n * @param labels The ground truth output tensor, same dimensions as\n *    'predictions'.\n * @param predictions The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n *\n * @doc {heading: 'Training', subheading: 'Losses', namespace: 'losses'}\n */\nfunction meanSquaredError_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, predictions: T|TensorLike,\n    weights?: Tensor|TensorLike,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  const $labels = convertToTensor(labels, 'labels', 'meanSquaredError');\n  const $predictions =\n      convertToTensor(predictions, 'predictions', 'meanSquaredError');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'meanSquaredError');\n  }\n  assertShapesMatch(\n      $labels.shape, $predictions.shape, 'Error in meanSquaredError: ');\n\n  const losses = squaredDifference($labels, $predictions);\n  return computeWeightedLoss(losses, $weights, reduction);\n}\nexport const meanSquaredError = op({meanSquaredError_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {abs} from '../abs';\nimport {add} from '../add';\nimport {exp} from '../exp';\nimport {log1p} from '../log1p';\nimport {Reduction} from '../loss_ops_utils';\nimport {mul} from '../mul';\nimport {neg} from '../neg';\nimport {op} from '../operation';\nimport {relu} from '../relu';\nimport {scalar} from '../scalar';\nimport {sub} from '../sub';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\nfunction sigmoidCrossEntropyWithLogits_<T extends Tensor, O extends Tensor>(\n    labels: T|TensorLike, logits: T|TensorLike): O {\n  const $labels =\n      convertToTensor(labels, 'labels', 'sigmoidCrossEntropyWithLogits');\n  const $logits =\n      convertToTensor(logits, 'logits', 'sigmoidCrossEntropyWithLogits');\n  assertShapesMatch(\n      $labels.shape, $logits.shape, 'Error in sigmoidCrossEntropyWithLogits: ');\n\n  /**\n   * Implementation Details:\n   *\n   * For brevity, let `x = logits`, `z = labels`.  The logistic loss is\n   *     z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))\n   *   = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))\n   *   = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))\n   *   = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))\n   *   = (1 - z) * x + log(1 + exp(-x))\n   *   = x - x * z + log(1 + exp(-x))\n   *\n   *   For x < 0, to avoid overflow in exp(-x), we reformulate the above\n   *     x - x * z + log(1 + exp(-x))\n   *   = log(exp(x)) - x * z + log(1 + exp(-x))\n   *   = - x * z + log(1 + exp(x))\n   *\n   * Hence, to ensure stability and avoid overflow, the implementation uses\n   * this equivalent formulation:\n   *     max(x, 0) - x * z + log(1 + exp(-abs(x)))\n   */\n  const maxOutput = relu($logits);\n  const outputXTarget = mul($logits, $labels);\n  const sigmoidOutput = log1p(exp(neg(abs($logits))));\n\n  return add(sub(maxOutput, outputXTarget), sigmoidOutput);\n}\n\n/**\n * Computes the sigmoid cross entropy loss between two tensors.\n *\n * If labelSmoothing is nonzero, smooth the labels towards 1/2:\n *\n *   newMulticlassLabels = multiclassLabels * (1 - labelSmoothing)\n *                         + 0.5 * labelSmoothing\n *\n * @param multiClassLabels The ground truth output tensor of shape\n * [batch_size, num_classes], same dimensions as 'predictions'.\n * @param logits The predicted outputs.\n * @param weights Tensor whose rank is either 0, or the same rank as\n *    `labels`, and must be broadcastable to `labels` (i.e., all dimensions\n *    must be either `1`, or the same as the corresponding `losses`\n *    dimension).\n * @param labelSmoothing If greater than 0, then smooth the labels.\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n *\n * @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' }\n */\nfunction sigmoidCrossEntropy_<T extends Tensor, O extends Tensor>(\n    multiClassLabels: T|TensorLike, logits: T|TensorLike,\n    weights?: Tensor|TensorLike, labelSmoothing = 0,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  let $multiClassLabels = convertToTensor(\n      multiClassLabels, 'multiClassLabels', 'sigmoidCrossEntropy');\n  const $logits = convertToTensor(logits, 'logits', 'sigmoidCrossEntropy');\n  let $weights: Tensor = null;\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'sigmoidCrossEntropy');\n  }\n  assertShapesMatch(\n      $multiClassLabels.shape, $logits.shape, 'Error in sigmoidCrossEntropy: ');\n\n  if (labelSmoothing > 0) {\n    const labelSmoothingScalar = scalar(labelSmoothing);\n    const one = scalar(1);\n    const half = scalar(0.5);\n\n    $multiClassLabels =\n        add(mul($multiClassLabels, sub(one, labelSmoothingScalar)),\n            mul(half, labelSmoothingScalar));\n  }\n  const losses = sigmoidCrossEntropyWithLogits_($multiClassLabels, $logits);\n\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\nexport const sigmoidCrossEntropy = op({sigmoidCrossEntropy_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {customGrad} from '../../gradients';\nimport {Tensor} from '../../tensor';\nimport {GradSaveFunc} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {assertShapesMatch} from '../../util';\nimport {add} from '../add';\nimport {expandShapeToKeepDim} from '../axis_util';\nimport {cast} from '../cast';\nimport {div} from '../div';\nimport {exp} from '../exp';\nimport {logSumExp} from '../log_sum_exp';\nimport {Reduction} from '../loss_ops_utils';\nimport {mul} from '../mul';\nimport {neg} from '../neg';\nimport {op} from '../operation';\nimport {reshape} from '../reshape';\nimport {scalar} from '../scalar';\nimport {sub} from '../sub';\nimport {sum} from '../sum';\n\nimport {computeWeightedLoss} from './compute_weighted_loss';\n\n/**\n * Computes softmax cross entropy between logits and labels.\n *\n * Measures the probability error in discrete classification tasks in which\n * the classes are mutually exclusive (each entry is in exactly one class).\n * For example, each CIFAR-10 image is labeled with one and only one label: an\n * image can be a dog or a truck, but not both.\n *\n * `NOTE`: While the classes are mutually exclusive, their probabilities need\n * not be. All that is required is that each row of labels is a valid\n * probability distribution. If they are not, the computation of the gradient\n * will be incorrect.\n *\n * `WARNING`: This op expects unscaled logits, since it performs a softmax on\n * logits internally for efficiency. Do not call this op with the output of\n * softmax, as it will produce incorrect results.\n *\n * logits and labels must have the same shape, e.g. [batch_size, num_classes]\n * and the same dtype.\n * @param labels The labels array.\n * @param logits The logits array.\n * @param dim The dimension softmax would be performed on. Defaults to `-1`\n *     which indicates the last dimension.\n */\nfunction softmaxCrossEntropyWithLogits_<T extends Tensor, O extends Tensor>(\n    labels: T, logits: T, dim = -1): O {\n  if (dim === -1) {\n    dim = logits.rank - 1;\n  }\n\n  if (dim !== logits.rank - 1) {\n    throw Error(\n        `Softmax cross entropy along a non-last dimension is not yet ` +\n        `supported. Labels / logits was rank ${logits.rank} ` +\n        `and dim was ${dim}`);\n  }\n  // Use a custom gradient for numerical stability.\n  const customOp =\n      customGrad((labels: Tensor, logits: Tensor, save: GradSaveFunc) => {\n        // Reference:\n        //   1. http://cs231n.github.io/linear-classify/#softmax\n        //   2. https://blog.feedly.com/tricks-of-the-trade-logsumexp/\n        const keepDims = true;\n        const lse = logSumExp(logits, [dim], keepDims);\n        const logResult = sub(cast(logits, 'float32'), lse);\n        save([labels, logResult]);\n\n        const costVector = neg(mul(logResult, labels));\n        const value: O = sum(costVector, [dim]);\n\n        const gradFunc = (dy: O, saved: Tensor[]) => {\n          const [labels, logResult] = saved;\n          const dyShape = expandShapeToKeepDim(dy.shape, [dim]);\n          return [\n            mul(reshape(dy, dyShape),\n                sub(cast(labels, 'float32'), exp(logResult))),\n            mul(reshape(dy, dyShape),\n                sub(exp(logResult), cast(labels, 'float32'))),\n          ];\n        };\n        return {value, gradFunc};\n      });\n\n  return customOp(labels, logits);\n}\n\n/**\n * Computes the softmax cross entropy loss between two tensors.\n *\n * If labelSmoothing is nonzero, smooth the labels towards 1/2:\n *\n *   newOnehotLabels = onehotLabels * (1 - labelSmoothing)\n *                         + labelSmoothing / numClasses\n *\n * @param onehotLabels One hot encoded labels\n *    [batch_size, num_classes], same dimensions as 'predictions'.\n * @param logits The predicted outputs.\n * @param weights Tensor whose rank is either 0, or 1, and must be\n *    broadcastable to `loss`  of shape [batch_size]\n * @param labelSmoothing If greater than 0, then smooth the labels.\n * @param reduction Type of reduction to apply to loss. Should be of type\n *    `Reduction`\n *\n * @doc { heading: 'Training', subheading: 'Losses', namespace: 'losses' }\n */\nfunction softmaxCrossEntropy_<T extends Tensor, O extends Tensor>(\n    onehotLabels: T|TensorLike, logits: T|TensorLike,\n    weights?: Tensor|TensorLike, labelSmoothing = 0,\n    reduction = Reduction.SUM_BY_NONZERO_WEIGHTS): O {\n  let $onehotLabels =\n      convertToTensor(onehotLabels, 'onehotLabels', 'softmaxCrossEntropy');\n  const $logits = convertToTensor(logits, 'logits', 'softmaxCrossEntropy');\n  let $weights: Tensor = null;\n\n  if (weights != null) {\n    $weights = convertToTensor(weights, 'weights', 'softmaxCrossEntropy');\n  }\n\n  assertShapesMatch(\n      $onehotLabels.shape, $logits.shape, 'Error in softmaxCrossEntropy: ');\n\n  if (labelSmoothing > 0) {\n    const labelSmoothingScalar = scalar(labelSmoothing);\n    const one = scalar(1);\n    const numClasses = scalar($onehotLabels.shape[1]);\n\n    $onehotLabels =\n        add(mul($onehotLabels, sub(one, labelSmoothingScalar)),\n            div(labelSmoothingScalar, numClasses));\n  }\n\n  const losses = softmaxCrossEntropyWithLogits_($onehotLabels, $logits);\n\n  return computeWeightedLoss(losses, $weights, reduction);\n}\n\nexport const softmaxCrossEntropy = op({softmaxCrossEntropy_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {SparseFillEmptyRows, SparseFillEmptyRowsInputs} from '../../kernel_names';\nimport {Scalar, Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {ScalarLike, TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * The input SparseTensor is represented via the map of inputs {`indices`,\n * `values`, `denseShape`}. The output SparseTensor has the same `denseShape`\n * but with indices `outputIndices` and values `outputValues`. This op inserts a\n * single entry for every row that doesn't have any values. The index is created\n * as `[row, 0, ..., 0]` and the inserted value is `defaultValue`.\n *\n * For example, suppose `spInput` has shape [5, 6] and non-empty values:\n * [0, 1]: a\n * [0, 3]: b\n * [2, 0]: c\n * [3, 1]: d\n *\n * Rows 1 and 4 are empty, so the output will be of shape [5, 6] with values:\n * [0, 1]: a\n * [0, 3]: b\n * [1, 0]: `defaultValue`\n * [2, 0]: c\n * [3, 1]: d\n * [4, 0]: `defaultValue`\n *\n * The output SparseTensor will be in row-major order and will have the same\n * shape as the input.\n *\n * This op also returns an indicator vector shaped [dense_shape[0]] such that\n * emptyRowIndicator[i] = True iff row i was an empty row.\n *\n * And a reverse index map vector shaped [indices.shape[0]] that is used during\n * backpropagation, reverseIndexMap[i] = outi s.t. indices[i, j] ==\n * outputIndices[outi, j] for all j\n *\n * ```js\n * const result = tf.sparse.sparseFillEmptyRows(\n *   [[0, 0], [1, 0], [1, 3], [1, 4], [3, 2], [3, 3]],\n *   [0, 10, 13, 14, 32, 33], [5, 6], -1);\n * console.log(result);\n * result['outputIndices'].print(); // [[0, 0], [1, 0], [1, 3], [1, 4],\n *                                  //  [2, 0], [3, 2], [3, 3], [4, 0]]\n * result['outputValues'].print(); // [0, 10, 13, 14,-1, 32, 33, -1]\n * result['emptyRowIndicator'].print(); // [false, false, true, false, true]\n * result['reverseIndexMap'].print(); // [0, 1, 2, 3, 5, 6]\n * ```\n * @param indices: 2-D. the indices of the sparse tensor.\n * @param values: 1-D. the values of the sparse tensor.\n * @param denseShape: 1-D. the shape of the sparse tensor.\n * @param defaultValue: 0-D. default value to insert into location [row, 0, ...,\n *     0] for rows missing from the input sparse tensor.\n * @return A map with the following properties:\n *     - outputIndices\n *     - outputValues: 1-D. the values of the filled sparse tensor.\n *     - emptyRowIndicator: 1-D. whether the dense row was missing in the input\n * sparse tensor.\n *     - reverseIndexMap: 1-D. a map from the input indices to the output\n * indices.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseFillEmptyRows_(\n    indices: Tensor2D|TensorLike, values: Tensor1D|TensorLike,\n    denseShape: Tensor1D|TensorLike,\n    defaultValue: Scalar|ScalarLike): NamedTensorMap {\n  const $indices = convertToTensor(indices, 'indices', 'sparseFillEmptyRows');\n  const $values = convertToTensor(values, 'values', 'sparseFillEmptyRows');\n  const $denseShape =\n      convertToTensor(denseShape, 'denseShape', 'sparseFillEmptyRows');\n  const $defaultValue = convertToTensor(\n      defaultValue, 'defaultValue', 'sparseFillEmptyRows', $values.dtype);\n\n  if ($indices.rank !== 2) {\n    throw new Error(`Indices should be Tensor2D but received shape\n        ${$indices.shape}`);\n  }\n  if ($values.rank !== 1) {\n    throw new Error(\n        `Values should be Tensor1D but received shape ${$values.shape}`);\n  }\n  if ($denseShape.rank !== 1) {\n    throw new Error(`Dense shape should be Tensor1D but received shape ${\n        $denseShape.shape}`);\n  }\n  if ($defaultValue.rank !== 0) {\n    throw new Error(`Default value should be a scalar but received shape ${\n        $defaultValue.shape}`);\n  }\n\n  const inputs: SparseFillEmptyRowsInputs = {\n    indices: $indices,\n    values: $values,\n    denseShape: $denseShape,\n    defaultValue: $defaultValue\n  };\n\n  const result: Tensor[] = ENGINE.runKernel(SparseFillEmptyRows, inputs as {});\n  return {\n    outputIndices: result[0],\n    outputValues: result[1],\n    emptyRowIndicator: result[2],\n    reverseIndexMap: result[3]\n  };\n}\n\nexport const sparseFillEmptyRows = op({sparseFillEmptyRows_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {SparseReshape, SparseReshapeInputs} from '../../kernel_names';\nimport {Tensor, Tensor1D, Tensor2D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * This operation has the same semantics as reshape on the represented dense\n * tensor. The `inputIndices` are recomputed based on the requested `newShape`.\n * If one component of `newShape` is the special value -1, the size of that\n * dimension is computed so that the total dense size remains constant. At most\n * one component of `newShape` can be -1. The number of dense elements implied\n * by `newShape` must be the same as the number of dense elements originally\n * implied by `inputShape`. Reshaping does not affect the order of values in the\n * SparseTensor. If the input tensor has rank R_in and N non-empty values, and\n * `newShape` has length R_out, then `inputIndices` has shape [N, R_in],\n * `inputShape` has length R_in, `outputIndices` has shape [N, R_out], and\n * `outputShape` has length R_out.\n *\n * ```js\n * const result = tf.sparse.sparseReshape(\n *   [[0, 0, 0], [0, 0, 1], [0, 1, 0], [1, 0, 0], [1, 2, 3]],\n *   [2, 3, 6], [9, -1]);\n * console.log(result);\n * result['outputIndices'].print(); //[[0, 0], [0, 1], [1, 2], [4, 2], [8, 1]]\n * result['outputShape'].print(); // [9, 4]\n * ```\n * @param inputIndices: 2-D. N x R_in matrix with the indices of non-empty\n * values in a SparseTensor.\n * @param inputShape: 1-D. R_in Tensor1D with the input SparseTensor's dense\n * shape.\n * @param newShape: 1-D. R_out Tensor1D with the requested new dense shape.\n * @return A map with the following properties:\n *     - outputIndices: 2-D. N x R_out matrix with the updated indices of\n *       non-empty values in the output SparseTensor.\n *     - outputShape: 1-D. R_out vector with the full dense shape of the output\n *       SparseTensor. This is the same as newShape but with any -1 dimensions\n *        filled in.\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseReshape_(\n    inputIndices: Tensor2D|TensorLike, inputShape: Tensor1D|TensorLike,\n    newShape: Tensor1D|TensorLike): NamedTensorMap {\n  const $inputIndices =\n      convertToTensor(inputIndices, 'inputIndices', 'sparseReshape');\n  const $inputShape =\n      convertToTensor(inputShape, 'inputShape', 'sparseReshape');\n  const $newShape = convertToTensor(newShape, 'newShape', 'sparseReshape');\n\n  if ($inputIndices.rank !== 2) {\n    throw new Error(`Input indices should be Tensor2D but received shape\n        ${$inputIndices.shape}`);\n  }\n  if ($inputShape.rank !== 1) {\n    throw new Error(`Input shape should be Tensor1D but received shape ${\n        $inputShape.shape}`);\n  }\n  if ($newShape.rank !== 1) {\n    throw new Error(\n        `New shape should be Tensor1D but received shape ${$newShape.shape}`);\n  }\n\n  const inputs: SparseReshapeInputs = {\n    inputIndices: $inputIndices,\n    inputShape: $inputShape,\n    newShape: $newShape\n  };\n  const result: Tensor[] = ENGINE.runKernel(SparseReshape, inputs as {});\n  return {outputIndices: result[0], outputShape: result[1]};\n}\n\nexport const sparseReshape = op({sparseReshape_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {SparseSegmentMean, SparseSegmentMeanInputs} from '../../kernel_names';\nimport {Tensor, Tensor1D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * Computes the mean along sparse segments of a tensor.\n *\n * ```js\n * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [6,7,8,9]]);\n * // Select two rows, one segment.\n * const result1 = tf.sparse.sparseSegmentMean(c,\n *                                           tf.tensor1d([0, 1], 'int32'),\n *                                           tf.tensor1d([0, 0], 'int32'));\n * result1.print(); // [[0, 0, 0, 0]]\n *\n * // Select two rows, two segments.\n * const result2 = tf.sparse.sparseSegmentMean(c,\n *                                             tf.tensor1d([0, 1], 'int32'),\n *                                             tf.tensor1d([0, 1], 'int32'));\n * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]\n *\n * // Select all rows, two segments.\n * const result3 = tf.sparse.sparseSegmentMean(c,\n *                                             tf.tensor1d([0, 1, 2], 'int32'),\n *                                             tf.tensor1d([0, 1, 1], 'int32'));\n * result3.print(); // [[1.0, 2.0, 3.0, 4.0], [2.5, 2.5, 2.5, 2.5]]\n * ```\n * @param data: A Tensor of at least one dimension with data that will be\n *     assembled in the output.\n * @param indices: A 1-D Tensor with indices into data. Has same rank as\n *     segmentIds.\n * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values\n *     should be sorted and can be repeated.\n * @return Has same shape as data, except for dimension 0 which has equal to\n *         the number of segments.\n *\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseSegmentMean_(\n    data: Tensor|TensorLike, indices: Tensor1D|TensorLike,\n    segmentIds: Tensor1D|TensorLike): Tensor {\n  const $data = convertToTensor(data, 'data', 'sparseSegmentMean');\n  const $indices = convertToTensor(indices, 'indices', 'sparseSegmentMean');\n  const $segmentIds =\n      convertToTensor(segmentIds, 'segmentIds', 'sparseSegmentMean');\n\n  if ($data.rank < 1) {\n    throw new Error(\n        `Data should be at least 1 dimensional but received scalar`);\n  }\n  if ($indices.rank !== 1) {\n    throw new Error(`Indices should be Tensor1D but received shape\n          ${$indices.shape}`);\n  }\n  if ($segmentIds.rank !== 1) {\n    throw new Error(`Segment ids should be Tensor1D but received shape\n          ${$segmentIds.shape}`);\n  }\n\n  const inputs: SparseSegmentMeanInputs = {\n    data: $data,\n    indices: $indices,\n    segmentIds: $segmentIds\n  };\n\n  return ENGINE.runKernel(SparseSegmentMean, inputs as {});\n}\n\nexport const sparseSegmentMean = op({sparseSegmentMean_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {SparseSegmentSum, SparseSegmentSumInputs} from '../../kernel_names';\nimport {Tensor, Tensor1D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * Computes the sum along sparse segments of a tensor.\n *\n * ```js\n * const c = tf.tensor2d([[1,2,3,4], [-1,-2,-3,-4], [5,6,7,8]]);\n * // Select two rows, one segment.\n * const result1 = tf.sparse.sparseSegmentSum(c,\n *                                           tf.tensor1d([0, 1], 'int32'),\n *                                           tf.tensor1d([0, 0], 'int32'));\n * result1.print(); // [[0, 0, 0, 0]]\n *\n * // Select two rows, two segment.\n * const result2 = tf.sparse.sparseSegmentSum(c,\n *                                           tf.tensor1d([0, 1], 'int32'),\n *                                           tf.tensor1d([0, 1], 'int32'));\n * result2.print(); // [[1, 2, 3, 4], [-1, -2, -3, -4]]\n *\n * // Select all rows, two segments.\n * const result3 = tf.sparse.sparseSegmentSum(c,\n *                                           tf.tensor1d([0, 1, 2], 'int32'),\n *                                           tf.tensor1d([0, 0, 1], 'int32'));\n * result3.print(); // [[0, 0, 0, 0], [5, 6, 7, 8]]\n * ```\n * @param data: A Tensor of at least one dimension with data that will be\n *     assembled in the output.\n * @param indices: A 1-D Tensor with indices into data. Has same rank as\n *     segmentIds.\n * @param segmentIds: A 1-D Tensor with indices into the output Tensor. Values\n *     should be sorted and can be repeated.\n * @return Has same shape as data, except for dimension 0 which has equal to\n *         the number of segments.\n *\n * @doc {heading: 'Operations', subheading: 'Sparse'}\n */\nfunction sparseSegmentSum_(\n    data: Tensor|TensorLike, indices: Tensor1D|TensorLike,\n    segmentIds: Tensor1D|TensorLike): Tensor {\n  const $data = convertToTensor(data, 'data', 'sparseSegmentSum');\n  const $indices = convertToTensor(indices, 'indices', 'sparseSegmentSum');\n  const $segmentIds =\n      convertToTensor(segmentIds, 'segmentIds', 'sparseSegmentSum');\n\n  if ($data.rank < 1) {\n    throw new Error(\n        `Data should be at least 1 dimensional but received scalar`);\n  }\n  if ($indices.rank !== 1) {\n    throw new Error(`Indices should be Tensor1D but received shape\n         ${$indices.shape}`);\n  }\n  if ($segmentIds.rank !== 1) {\n    throw new Error(`Segment ids should be Tensor1D but received shape\n         ${$segmentIds.shape}`);\n  }\n\n  const inputs: SparseSegmentSumInputs = {\n    data: $data,\n    indices: $indices,\n    segmentIds: $segmentIds\n  };\n\n  return ENGINE.runKernel(SparseSegmentSum, inputs as {});\n}\n\nexport const sparseSegmentSum = op({sparseSegmentSum_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {StringNGrams, StringNGramsAttrs, StringNGramsInputs} from '../../kernel_names';\nimport {Tensor, Tensor1D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * Creates ngrams from ragged string data.\n *\n * This op accepts a ragged tensor with 1 ragged dimension containing only\n * strings and outputs a ragged tensor with 1 ragged dimension containing ngrams\n * of that string, joined along the innermost axis.\n *\n * ```js\n * const result = tf.string.stringNGrams(\n *   ['a', 'b', 'c', 'd'], tf.tensor1d([0, 2, 4], 'int32'),\n *   '|', [1, 2], 'LP', 'RP', -1, false);\n * result['nGrams'].print(); // ['a', 'b', 'LP|a', 'a|b', 'b|RP',\n *                           //  'c', 'd', 'LP|c', 'c|d', 'd|RP']\n * result['nGramsSplits'].print(); // [0, 5, 10]\n * ```\n * @param data: The values tensor of the ragged string tensor to make ngrams out\n *     of. Must be a 1D string tensor.\n * @param dataSplits: The splits tensor of the ragged string tensor to make\n *     ngrams out of.\n * @param separator: The string to append between elements of the token. Use \"\"\n *     for no separator.\n * @param nGramWidths: The sizes of the ngrams to create.\n * @param leftPad: The string to use to pad the left side of the ngram sequence.\n *     Only used if pad_width !== 0.\n * @param rightPad: The string to use to pad the right side of the ngram\n *     sequence. Only used if pad_width !== 0.\n * @param padWidth: The number of padding elements to add to each side of each\n *     sequence. Note that padding will never be greater than `nGramWidths`-1\n *     regardless of this value. If `padWidth`=-1 , then add max(`nGramWidths)-1\n *     elements.\n * @param preserveShortSequences: If true, then ensure that at least one ngram\n *     is generated for each input sequence. In particular, if an input sequence\n *     is shorter than min(ngramWidth) + 2*padWidth, then generate a single\n *     ngram containing the entire sequence. If false, then no ngrams are\n *     generated for these short input sequences.\n * @return A map with the following properties:\n *     - nGrams: The values tensor of the output ngrams ragged tensor.\n *     - nGramsSplits: The splits tensor of the output ngrams ragged tensor.\n *\n * @doc {heading: 'Operations', subheading: 'String'}\n */\nfunction stringNGrams_(\n    data: Tensor1D|TensorLike, dataSplits: Tensor|TensorLike, separator: string,\n    nGramWidths: number[], leftPad: string, rightPad: string, padWidth: number,\n    preserveShortSequences: boolean): NamedTensorMap {\n  const $data = convertToTensor(data, 'data', 'stringNGrams', 'string');\n  if ($data.dtype !== 'string') {\n    throw new Error('Data must be of datatype string');\n  }\n  if ($data.shape.length !== 1) {\n    throw new Error(`Data must be a vector, saw: ${$data.shape}`);\n  }\n\n  const $dataSplits = convertToTensor(dataSplits, 'dataSplits', 'stringNGrams');\n  if ($dataSplits.dtype !== 'int32') {\n    throw new Error('Data splits must be of datatype int32');\n  }\n\n  const attrs: StringNGramsAttrs = {\n    separator,\n    nGramWidths,\n    leftPad,\n    rightPad,\n    padWidth,\n    preserveShortSequences\n  };\n\n  const inputs: StringNGramsInputs = {data: $data, dataSplits: $dataSplits};\n  const result: Tensor[] =\n      ENGINE.runKernel(StringNGrams, inputs as {}, attrs as {});\n  return {nGrams: result[0], nGramsSplits: result[1]};\n}\n\nexport const stringNGrams = op({stringNGrams_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {StringSplit, StringSplitAttrs, StringSplitInputs} from '../../kernel_names';\nimport {Scalar, Tensor, Tensor1D} from '../../tensor';\nimport {NamedTensorMap} from '../../tensor_types';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {ScalarLike, TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * Split elements of `input` based on `delimiter` into a SparseTensor .\n *\n * Let N be the size of source (typically N will be the batch size). Split each\n * element of `input` based on `delimiter` and return a SparseTensor containing\n * the splitted tokens. Empty tokens are ignored if `skipEmpty` is set to True.\n *\n * `delimiter` can be empty, or a string of split characters. If `delimiter` is\n * an empty string, each element of `input` is split into individual\n * character strings. Otherwise every character of `delimiter` is a potential\n * split point.\n *\n * ```js\n * const result = tf.string.stringSplit(['hello world',  'a b c'], ' ');\n * result['indices'].print(); // [[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]]\n * result['values'].print(); // ['hello', 'world', 'a', 'b', 'c']\n * result['shape'].print(); // [2, 3]\n * ```\n * @param input: 1-D. Strings to split.\n * @param delimiter: 0-D. Delimiter characters, or empty string.\n * @param skipEmpty: Optional. If true, skip the empty strings from the result.\n *     Defaults to true.\n * @return A map with the following properties:\n *     - indices: A dense matrix of int32 representing the indices of the sparse\n *       tensor.\n *     - values: A vector of strings corresponding to the splited values.\n *     - shape: a length-2 vector of int32 representing the shape of the sparse\n * tensor, where the first value is N and the second value is the maximum number\n * of tokens in a single input entry.\n *\n * @doc {heading: 'Operations', subheading: 'String'}\n */\nfunction stringSplit_(\n    input: Tensor1D|TensorLike, delimiter: Scalar|ScalarLike,\n    skipEmpty = true): NamedTensorMap {\n  const $input = convertToTensor(input, 'input', 'stringSplit', 'string');\n  const $delimiter =\n      convertToTensor(delimiter, 'delimiter', 'stringSplit', 'string');\n\n  if ($input.rank !== 1) {\n    throw new Error(\n        `Input should be Tensor1D but received shape ${$input.shape}`);\n  }\n  if ($delimiter.rank !== 0) {\n    throw new Error(\n        `Delimiter should be a scalar but received shape ${$delimiter.shape}`);\n  }\n\n  const attrs: StringSplitAttrs = {skipEmpty};\n  const inputs: StringSplitInputs = {input: $input, delimiter: $delimiter};\n  const result: Tensor[] =\n      ENGINE.runKernel(StringSplit, inputs as {}, attrs as {});\n  return {indices: result[0], values: result[1], shape: result[2]};\n}\n\nexport const stringSplit = op({stringSplit_});\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../../engine';\nimport {StringToHashBucketFast, StringToHashBucketFastAttrs, StringToHashBucketFastInputs} from '../../kernel_names';\nimport {Tensor} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport {op} from '../operation';\n\n/**\n * Converts each string in the input Tensor to its hash mod by a number of\n * buckets.\n *\n * The hash function is deterministic on the content of the string within the\n * process and will never change. However, it is not suitable for cryptography.\n * This function may be used when CPU time is scarce and inputs are trusted or\n * unimportant. There is a risk of adversaries constructing inputs that all hash\n * to the same bucket.\n *\n * ```js\n * const result = tf.string.stringToHashBucketFast(\n *   ['Hello', 'TensorFlow', '2.x'], 3);\n * result.print(); // [0, 2, 2]\n * ```\n * @param input: The strings to assign a hash bucket.\n * @param numBuckets: The number of buckets.\n * @return A Tensor of the same shape as the input tensor.\n *\n * @doc {heading: 'Operations', subheading: 'String'}\n */\nfunction stringToHashBucketFast_(\n    input: Tensor|TensorLike, numBuckets: number): Tensor {\n  const $input =\n      convertToTensor(input, 'input', 'stringToHashBucketFast', 'string');\n  const attrs: StringToHashBucketFastAttrs = {numBuckets};\n\n  if (numBuckets <= 0) {\n    throw new Error(`Number of buckets must be at least 1`);\n  }\n\n  const inputs: StringToHashBucketFastInputs = {input: $input};\n  return ENGINE.runKernel(StringToHashBucketFast, inputs as {}, attrs as {});\n}\n\nexport const stringToHashBucketFast = op({stringToHashBucketFast_});\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Modularized ops.\nexport {abs} from './abs';\nexport {acos} from './acos';\nexport {acosh} from './acosh';\nexport {add} from './add';\nexport {addN} from './add_n';\nexport {all} from './all';\nexport {any} from './any';\nexport {argMax} from './arg_max';\nexport {argMin} from './arg_min';\nexport {asin} from './asin';\nexport {asinh} from './asinh';\nexport {atan} from './atan';\nexport {atan2} from './atan2';\nexport {atanh} from './atanh';\nexport {avgPool} from './avg_pool';\nexport {avgPool3d} from './avg_pool_3d';\nexport {basicLSTMCell} from './basic_lstm_cell';\nexport {batchToSpaceND} from './batch_to_space_nd';\nexport {batchNorm} from './batchnorm';\nexport {batchNorm2d} from './batchnorm2d';\nexport {batchNorm3d} from './batchnorm3d';\nexport {batchNorm4d} from './batchnorm4d';\nexport {bincount} from './bincount';\nexport {broadcastArgs} from './broadcast_args';\nexport {broadcastTo} from './broadcast_to';\nexport {buffer} from './buffer';\nexport {cast} from './cast';\nexport {ceil} from './ceil';\nexport {clipByValue} from './clip_by_value';\nexport {clone} from './clone';\nexport {complex} from './complex';\nexport {concat} from './concat';\nexport {concat1d} from './concat_1d';\nexport {concat2d} from './concat_2d';\nexport {concat3d} from './concat_3d';\nexport {concat4d} from './concat_4d';\nexport {conv1d} from './conv1d';\nexport {conv2d} from './conv2d';\nexport {conv2dTranspose} from './conv2d_transpose';\nexport {conv3d} from './conv3d';\nexport {conv3dTranspose} from './conv3d_transpose';\nexport {cos} from './cos';\nexport {cosh} from './cosh';\nexport {cumsum} from './cumsum';\nexport {denseBincount} from './dense_bincount';\nexport {depthToSpace} from './depth_to_space';\nexport {depthwiseConv2d} from './depthwise_conv2d';\nexport {diag} from './diag';\nexport {dilation2d} from './dilation2d';\nexport {div} from './div';\nexport {divNoNan} from './div_no_nan';\nexport {dot} from './dot';\nexport {einsum} from './einsum';\nexport {elu} from './elu';\nexport {equal} from './equal';\nexport {erf} from './erf';\nexport {exp} from './exp';\nexport {expandDims} from './expand_dims';\nexport {expm1} from './expm1';\nexport {eye} from './eye';\nexport {fill} from './fill';\nexport {floor} from './floor';\nexport {floorDiv} from './floorDiv';\nexport {gather} from './gather';\nexport {greater} from './greater';\nexport {greaterEqual} from './greater_equal';\nexport {imag} from './imag';\nexport {isFinite} from './is_finite';\nexport {isInf} from './is_inf';\nexport {isNaN} from './is_nan';\nexport {leakyRelu} from './leaky_relu';\nexport {less} from './less';\nexport {lessEqual} from './less_equal';\nexport {linspace} from './linspace';\nexport {localResponseNormalization} from './local_response_normalization';\nexport {log} from './log';\nexport {log1p} from './log1p';\nexport {logSigmoid} from './log_sigmoid';\nexport {logSoftmax} from './log_softmax';\nexport {logSumExp} from './log_sum_exp';\nexport {logicalAnd} from './logical_and';\nexport {logicalNot} from './logical_not';\nexport {logicalOr} from './logical_or';\nexport {logicalXor} from './logical_xor';\nexport {matMul} from './mat_mul';\nexport {max} from './max';\nexport {maxPool} from './max_pool';\nexport {maxPool3d} from './max_pool_3d';\nexport {maxPoolWithArgmax} from './max_pool_with_argmax';\nexport {maximum} from './maximum';\nexport {mean} from './mean';\nexport {meshgrid} from './meshgrid';\nexport {min} from './min';\nexport {minimum} from './minimum';\nexport {mirrorPad} from './mirror_pad';\nexport {mod} from './mod';\nexport {moments} from './moments';\nexport {mul} from './mul';\nexport {LSTMCellFunc, multiRNNCell} from './multi_rnn_cell';\nexport {multinomial} from './multinomial';\nexport {neg} from './neg';\nexport {notEqual} from './not_equal';\nexport {oneHot} from './one_hot';\nexport {ones} from './ones';\nexport {onesLike} from './ones_like';\nexport {outerProduct} from './outer_product';\nexport {pad} from './pad';\nexport {pad1d} from './pad1d';\nexport {pad2d} from './pad2d';\nexport {pad3d} from './pad3d';\nexport {pad4d} from './pad4d';\nexport {pool} from './pool';\nexport {pow} from './pow';\nexport {prelu} from './prelu';\nexport {print} from './print';\nexport {prod} from './prod';\nexport {rand} from './rand';\nexport {randomGamma} from './random_gamma';\nexport {randomNormal} from './random_normal';\nexport {randomUniform} from './random_uniform';\nexport {range} from './range';\nexport {real} from './real';\nexport {reciprocal} from './reciprocal';\nexport {relu} from './relu';\nexport {relu6} from './relu6';\nexport {reshape} from './reshape';\nexport {reverse} from './reverse';\nexport {reverse1d} from './reverse_1d';\nexport {reverse2d} from './reverse_2d';\nexport {reverse3d} from './reverse_3d';\nexport {reverse4d} from './reverse_4d';\nexport {round} from './round';\nexport {rsqrt} from './rsqrt';\nexport {scalar} from './scalar';\nexport {selu} from './selu';\nexport {separableConv2d} from './separable_conv2d';\nexport {setdiff1dAsync} from './setdiff1d_async';\nexport {sigmoid} from './sigmoid';\nexport {sign} from './sign';\nexport {sin} from './sin';\nexport {sinh} from './sinh';\nexport {slice} from './slice';\nexport {slice1d} from './slice1d';\nexport {slice2d} from './slice2d';\nexport {slice3d} from './slice3d';\nexport {slice4d} from './slice4d';\nexport {softmax} from './softmax';\nexport {softplus} from './softplus';\nexport {spaceToBatchND} from './space_to_batch_nd';\nexport {fft} from './spectral/fft';\nexport {ifft} from './spectral/ifft';\nexport {irfft} from './spectral/irfft';\nexport {rfft} from './spectral/rfft';\nexport {split} from './split';\nexport {sqrt} from './sqrt';\nexport {square} from './square';\nexport {squaredDifference} from './squared_difference';\nexport {squeeze} from './squeeze';\nexport {stack} from './stack';\nexport {step} from './step';\nexport {stridedSlice} from './strided_slice';\nexport {sub} from './sub';\nexport {sum} from './sum';\nexport {tan} from './tan';\nexport {tanh} from './tanh';\nexport {tensor} from './tensor';\nexport {tensor1d} from './tensor1d';\nexport {tensor2d} from './tensor2d';\nexport {tensor3d} from './tensor3d';\nexport {tensor4d} from './tensor4d';\nexport {tensor5d} from './tensor5d';\nexport {tensor6d} from './tensor6d';\nexport {tile} from './tile';\nexport {topk} from './topk';\nexport {truncatedNormal} from './truncated_normal';\nexport {unique} from './unique';\nexport {unsortedSegmentSum} from './unsorted_segment_sum';\nexport {unstack} from './unstack';\nexport {variable} from './variable';\nexport {where} from './where';\nexport {whereAsync} from './where_async';\nexport {zeros} from './zeros';\nexport {zerosLike} from './zeros_like';\n\nexport * from './boolean_mask';\nexport * from './transpose';\nexport * from './norm';\nexport * from './moving_average';\nexport * from './scatter_nd';\nexport * from './sparse_to_dense';\nexport * from './gather_nd';\nexport * from './dropout';\nexport * from './signal_ops_util';\nexport * from './in_top_k';\n\nexport {op, OP_SCOPE_SUFFIX} from './operation';\n\nimport {rfft} from './spectral/rfft';\nimport {fft} from './spectral/fft';\nimport {ifft} from './spectral/ifft';\nimport {irfft} from './spectral/irfft';\nconst spectral = {\n  fft,\n  ifft,\n  rfft,\n  irfft\n};\n\nimport * as fused from './fused_ops';\n\nimport {hammingWindow} from './signal/hamming_window';\nimport {hannWindow} from './signal/hann_window';\nimport {frame} from './signal/frame';\nimport {stft} from './signal/stft';\nconst signal = {\n  hammingWindow,\n  hannWindow,\n  frame,\n  stft,\n};\n\n// Image Ops namespace\nimport {cropAndResize} from './image/crop_and_resize';\nimport {flipLeftRight} from './image/flip_left_right';\nimport {grayscaleToRGB} from './image/grayscale_to_rgb';\nimport {rotateWithOffset} from './image/rotate_with_offset';\nimport {nonMaxSuppression} from './image/non_max_suppression';\nimport {nonMaxSuppressionAsync} from './image/non_max_suppression_async';\nimport {nonMaxSuppressionWithScore} from './image/non_max_suppression_with_score';\nimport {nonMaxSuppressionWithScoreAsync} from './image/non_max_suppression_with_score_async';\nimport {nonMaxSuppressionPadded} from './image/non_max_suppression_padded';\nimport {nonMaxSuppressionPaddedAsync} from './image/non_max_suppression_padded_async';\nimport {resizeBilinear} from './image/resize_bilinear';\nimport {resizeNearestNeighbor} from './image/resize_nearest_neighbor';\nimport {threshold} from './image/threshold';\nimport {transform} from './image/transform';\nconst image = {\n  flipLeftRight,\n  grayscaleToRGB,\n  resizeNearestNeighbor,\n  resizeBilinear,\n  rotateWithOffset,\n  cropAndResize,\n  nonMaxSuppression,\n  nonMaxSuppressionAsync,\n  nonMaxSuppressionWithScore,\n  nonMaxSuppressionWithScoreAsync,\n  nonMaxSuppressionPadded,\n  nonMaxSuppressionPaddedAsync,\n  threshold,\n  transform\n};\n\n// linalg namespace\nimport {bandPart} from './linalg/band_part';\nimport {gramSchmidt} from './linalg/gram_schmidt';\nimport {qr} from './linalg/qr';\nconst linalg = {\n  bandPart,\n  gramSchmidt,\n  qr\n};\n\n// losses namespace;\nimport {absoluteDifference} from './losses/absolute_difference';\nimport {computeWeightedLoss} from './losses/compute_weighted_loss';\nimport {cosineDistance} from './losses/cosine_distance';\nimport {hingeLoss} from './losses/hinge_loss';\nimport {huberLoss} from './losses/huber_loss';\nimport {logLoss} from './losses/log_loss';\nimport {meanSquaredError} from './losses/mean_squared_error';\nimport {sigmoidCrossEntropy} from './losses/sigmoid_cross_entropy';\nimport {softmaxCrossEntropy} from './losses/softmax_cross_entropy';\nconst losses = {\n  absoluteDifference,\n  computeWeightedLoss,\n  cosineDistance,\n  hingeLoss,\n  huberLoss,\n  logLoss,\n  meanSquaredError,\n  sigmoidCrossEntropy,\n  softmaxCrossEntropy\n};\n\nimport {sparseFillEmptyRows} from './sparse/sparse_fill_empty_rows';\nimport {sparseReshape} from './sparse/sparse_reshape';\nimport {sparseSegmentMean} from './sparse/sparse_segment_mean';\nimport {sparseSegmentSum} from './sparse/sparse_segment_sum';\nconst sparse = {\n  sparseFillEmptyRows,\n  sparseReshape,\n  sparseSegmentMean,\n  sparseSegmentSum\n};\n\nimport {stringNGrams} from './string/string_n_grams';\nimport {stringSplit} from './string/string_split';\nimport {stringToHashBucketFast} from './string/string_to_hash_bucket_fast';\n// tslint:disable-next-line:variable-name\nconst string = {\n  stringNGrams,\n  stringSplit,\n  stringToHashBucketFast\n};\n\n// Second level exports.\nexport {image, linalg, losses, spectral, fused, signal, sparse, string};\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {dispose} from '../globals';\nimport {variableGrads} from '../gradients';\nimport {scalar} from '../ops/ops';\nimport {Serializable} from '../serialization';\nimport {Scalar, Variable} from '../tensor';\nimport {NamedTensor, NamedTensorMap} from '../tensor_types';\n\n/**\n * A variable that belongs to an optimizer.\n *\n * The `originalName` field is required for keeping track of the canonical\n * name of the variable, which is usually the name of the model weight that\n * the variable is related to plus a suffix, e.g., 'dense1/kernel/momentum'.\n * The name of the `Variable` object itself cannot be used directly due to\n * possible deduplication: Every `Variable` must have a unique name but more\n * than one optimizer objects of the same type may be created for the same model\n * or the same `Variable`.\n */\nexport interface OptimizerVariable {\n  originalName: string;\n  variable: Variable;\n}\n\n/** @doc {heading: 'Training', subheading: 'Classes', namespace: 'train'} */\nexport abstract class Optimizer extends Serializable {\n  protected iterations_: number;\n\n  /**\n   * Executes `f()` and minimizes the scalar output of `f()` by computing\n   * gradients of y with respect to the list of trainable variables provided by\n   * `varList`. If no list is provided, it defaults to all trainable variables.\n   *\n   * @param f The function to execute and whose output to minimize.\n   * @param returnCost Whether to return the scalar cost value produced by\n   * executing `f()`.\n   * @param varList An optional list of variables to update. If specified, only\n   * the trainable variables in varList will be updated by minimize. Defaults to\n   * all trainable variables.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers'}\n   */\n  minimize(f: () => Scalar, returnCost = false, varList?: Variable[]): Scalar\n      |null {\n    const {value, grads} = this.computeGradients(f, varList);\n\n    if (varList != null) {\n      const gradArray: NamedTensor[] =\n          varList.map(v => ({name: v.name, tensor: grads[v.name]}));\n      this.applyGradients(gradArray);\n    } else {\n      this.applyGradients(grads);\n    }\n\n    // Dispose gradients.\n    dispose(grads);\n\n    if (returnCost) {\n      return value;\n    } else {\n      value.dispose();\n      return null;\n    }\n  }\n\n  /**\n   * The number of iterations that this optimizer instance has been invoked for.\n   */\n  get iterations(): number {\n    if (this.iterations_ == null) {\n      this.iterations_ = 0;\n    }\n    return this.iterations_;\n  }\n\n  protected incrementIterations() {\n    this.iterations_ = this.iterations + 1;\n  }\n\n  /**\n   * Executes f() and computes the gradient of the scalar output of f() with\n   * respect to the list of trainable variables provided by `varList`. If no\n   * list is provided, it defaults to all trainable variables.\n   *\n   * @param f The function to execute and whose output to use for computing\n   * gradients with respect to variables.\n   * @param varList An optional list of variables to compute gradients with\n   * respect to. If specified, only the trainable variables in varList will have\n   * gradients computed with respect to. Defaults to all trainable variables.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers'}\n   */\n  computeGradients(f: () => Scalar, varList?: Variable[]):\n      {value: Scalar, grads: NamedTensorMap} {\n    return variableGrads(f, varList);\n  }\n\n  /**\n   * Updates variables by using the computed gradients.\n   *\n   * @param variableGradients A mapping of variable name to its gradient value.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers'}\n   */\n  abstract applyGradients(variableGradients: NamedTensorMap|\n                          NamedTensor[]): void;\n\n  /**\n   * Dispose the variables (if any) owned by this optimizer instance.\n   */\n  dispose(): void {\n    if (this.iterations_ != null) {\n      dispose(this.iterations_);\n    }\n  }\n\n  async saveIterations(): Promise<NamedTensor> {\n    if (this.iterations_ == null) {\n      this.iterations_ = 0;\n    }\n    return {\n      name: 'iter',  // Named for Python compatibility.\n      // TODO(cais): Use 'int64' type when available.\n      tensor: scalar(this.iterations_, 'int32')\n    };\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    throw new Error('getWeights() is not implemented for this optimizer yet.');\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    throw new Error(\n        `setWeights() is not implemented for this optimizer class ` +\n        `${this.getClassName()}`);\n  }\n\n  /**\n   * Extract the first element of the weight values and set it\n   * as the iterations counter variable of this instance of optimizer.\n   *\n   * @param weightValues\n   * @returns Weight values with the first element consumed and excluded.\n   */\n  protected async extractIterations(weightValues: NamedTensor[]):\n      Promise<NamedTensor[]> {\n    this.iterations_ = (await weightValues[0].tensor.data())[0];\n    return weightValues.slice(1);\n  }\n}\n\nObject.defineProperty(Optimizer, Symbol.hasInstance, {\n  value: (instance: Optimizer) => {\n    return instance.minimize != null && instance.computeGradients != null &&\n        instance.applyGradients != null;\n  }\n});\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {dispose, tidy} from '../globals';\nimport {add} from '../ops/add';\nimport {div} from '../ops/div';\nimport {mul} from '../ops/mul';\nimport {sqrt} from '../ops/ops';\nimport {square} from '../ops/square';\nimport {zerosLike} from '../ops/zeros_like';\nimport {ConfigDict, registerClass, Serializable, SerializableConstructor} from '../serialization';\nimport {NamedTensor, NamedVariableMap} from '../tensor_types';\n\nimport {Optimizer, OptimizerVariable} from './optimizer';\n\n/** @doclink Optimizer */\nexport class AdadeltaOptimizer extends Optimizer {\n  /** @nocollapse */\n  static className = 'Adadelta';  // Name matters for Python compatibility.\n  private accumulatedGrads: OptimizerVariable[] = [];\n  private accumulatedUpdates: OptimizerVariable[] = [];\n\n  constructor(\n      protected learningRate: number, protected rho: number,\n      protected epsilon: number = null) {\n    super();\n\n    if (epsilon == null) {\n      this.epsilon = ENGINE.backend.epsilon();\n    }\n  }\n\n  applyGradients(variableGradients: NamedVariableMap|NamedTensor[]) {\n    const variableNames = Array.isArray(variableGradients) ?\n        variableGradients.map(item => item.name) :\n        Object.keys(variableGradients);\n\n    variableNames.forEach((name, i) => {\n      const value = ENGINE.registeredVariables[name];\n      const trainable = false;\n      if (this.accumulatedGrads[i] == null) {\n        this.accumulatedGrads[i] = {\n          originalName: `${name}/accum_grad`,\n          variable: tidy(() => zerosLike(value).variable(trainable))\n        };\n      }\n      if (this.accumulatedUpdates[i] == null) {\n        this.accumulatedUpdates[i] = {\n          originalName: `${name}/accum_var`,\n          variable: tidy(() => zerosLike(value).variable(trainable))\n        };\n      }\n\n      const gradient = Array.isArray(variableGradients) ?\n          variableGradients[i].tensor :\n          variableGradients[name];\n      if (gradient == null) {\n        return;\n      }\n\n      const accumulatedGrad = this.accumulatedGrads[i].variable;\n      const accumulatedUpdate = this.accumulatedUpdates[i].variable;\n\n      tidy(() => {\n        const newAccumulatedGrad =\n            add(mul(accumulatedGrad, this.rho),\n                mul(square(gradient), 1 - this.rho));\n\n        const updates =\n            mul(div(sqrt(add(accumulatedUpdate, this.epsilon)),\n                    sqrt(add(accumulatedGrad, this.epsilon))),\n                gradient);\n\n        const newAccumulatedUpdate =\n            add(mul(accumulatedUpdate, this.rho),\n                mul(square(updates), 1 - this.rho));\n\n        accumulatedGrad.assign(newAccumulatedGrad);\n        accumulatedUpdate.assign(newAccumulatedUpdate);\n\n        const newValue = add(mul(updates, -this.learningRate), value);\n        value.assign(newValue);\n      });\n    });\n    this.incrementIterations();\n  }\n\n  dispose(): void {\n    if (this.accumulatedUpdates != null) {\n      dispose(this.accumulatedGrads.map(v => v.variable));\n      dispose(this.accumulatedUpdates.map(v => v.variable));\n    }\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    // Order matters for Python compatibility.\n    const variables: OptimizerVariable[] =\n        [...this.accumulatedGrads, ...this.accumulatedUpdates];\n    return [await this.saveIterations()].concat(\n        variables.map(v => ({name: v.originalName, tensor: v.variable})));\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    weightValues = await this.extractIterations(weightValues);\n    const variableCount = weightValues.length / 2;\n    const trainable = false;\n    this.accumulatedGrads =\n        weightValues.slice(0, variableCount).map(v => ({\n                                                   originalName: v.name,\n                                                   variable: v.tensor.variable(\n                                                       trainable)\n                                                 }));\n    this.accumulatedUpdates =\n        weightValues.slice(variableCount, variableCount * 2)\n            .map(v => ({\n                   originalName: v.name,\n                   variable: v.tensor.variable(trainable)\n                 }));\n  }\n\n  getConfig(): ConfigDict {\n    return {\n      'learningRate': this.learningRate,\n      'rho': this.rho,\n      'epsilon': this.epsilon\n    };\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(config['learningRate'], config['rho'], config['epsilon']);\n  }\n}\nregisterClass(AdadeltaOptimizer);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {dispose, tidy} from '../globals';\nimport {add} from '../ops/add';\nimport {div} from '../ops/div';\nimport {fill} from '../ops/fill';\nimport {mul} from '../ops/mul';\nimport {sqrt} from '../ops/sqrt';\nimport {square} from '../ops/square';\nimport {ConfigDict, registerClass, Serializable, SerializableConstructor} from '../serialization';\nimport {NamedTensor, NamedVariableMap} from '../tensor_types';\n\nimport {Optimizer, OptimizerVariable} from './optimizer';\n\n/** @doclink Optimizer */\nexport class AdagradOptimizer extends Optimizer {\n  /** @nocollapse */\n  static className = 'Adagrad';  // Note: Name matters for Python compatibility.\n\n  private accumulatedGrads: OptimizerVariable[] = [];\n\n  constructor(\n      protected learningRate: number, private initialAccumulatorValue = 0.1) {\n    super();\n  }\n\n  applyGradients(variableGradients: NamedVariableMap|NamedTensor[]) {\n    const variableNames = Array.isArray(variableGradients) ?\n        variableGradients.map(item => item.name) :\n        Object.keys(variableGradients);\n\n    variableNames.forEach((name, i) => {\n      const value = ENGINE.registeredVariables[name];\n      if (this.accumulatedGrads[i] == null) {\n        const trainable = false;\n        this.accumulatedGrads[i] = {\n          originalName: `${name}/accumulator`,\n          variable: tidy(\n              () => fill(value.shape, this.initialAccumulatorValue)\n                        .variable(trainable))\n        };\n      }\n\n      const gradient = Array.isArray(variableGradients) ?\n          variableGradients[i].tensor :\n          variableGradients[name];\n      if (gradient == null) {\n        return;\n      }\n\n      const accumulatedGrad = this.accumulatedGrads[i].variable;\n\n      tidy(() => {\n        const newAccumulatedGrad = add(accumulatedGrad, square(gradient));\n        accumulatedGrad.assign(newAccumulatedGrad);\n\n        const newValue = add(\n            mul(div(gradient,\n                    sqrt(add(newAccumulatedGrad, ENGINE.backend.epsilon()))),\n                -this.learningRate),\n            value);\n        value.assign(newValue);\n      });\n    });\n    this.incrementIterations();\n  }\n\n  dispose(): void {\n    if (this.accumulatedGrads != null) {\n      dispose(this.accumulatedGrads.map(v => v.variable));\n    }\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    // Order matters for Python compatibility.\n    return [await this.saveIterations()].concat(this.accumulatedGrads.map(\n        v => ({name: v.originalName, tensor: v.variable})));\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    weightValues = await this.extractIterations(weightValues);\n    const trainable = false;\n    this.accumulatedGrads = weightValues.map(\n        v => ({originalName: v.name, variable: v.tensor.variable(trainable)}));\n  }\n\n  getConfig(): ConfigDict {\n    return {\n      'learningRate': this.learningRate,\n      'initialAccumulatorValue': this.initialAccumulatorValue,\n    };\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(config['learningRate'], config['initialAccumulatorValue']);\n  }\n}\nregisterClass(AdagradOptimizer);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {dispose, tidy} from '../globals';\nimport {add} from '../ops/add';\nimport {div} from '../ops/div';\nimport {mul} from '../ops/mul';\nimport {pow} from '../ops/pow';\nimport {scalar} from '../ops/scalar';\nimport {sqrt} from '../ops/sqrt';\nimport {square} from '../ops/square';\nimport {sub} from '../ops/sub';\nimport {zerosLike} from '../ops/zeros_like';\nimport {ConfigDict, registerClass, Serializable, SerializableConstructor} from '../serialization';\nimport {Variable} from '../tensor';\nimport {NamedTensor, NamedVariableMap} from '../tensor_types';\n\nimport {Optimizer, OptimizerVariable} from './optimizer';\n\nexport class AdamOptimizer extends Optimizer {\n  /** @nocollapse */\n  static className = 'Adam';  // Note: Name matters for Python compatibility.\n  private accBeta1: Variable;\n  private accBeta2: Variable;\n\n  private accumulatedFirstMoment: OptimizerVariable[] = [];\n  private accumulatedSecondMoment: OptimizerVariable[] = [];\n\n  constructor(\n      protected learningRate: number, protected beta1: number,\n      protected beta2: number, protected epsilon: number = null) {\n    super();\n    tidy(() => {\n      // accB* will be updated by batch.\n      this.accBeta1 = scalar(beta1).variable();\n      this.accBeta2 = scalar(beta2).variable();\n    });\n\n    if (epsilon == null) {\n      this.epsilon = ENGINE.backend.epsilon();\n    }\n  }\n\n  applyGradients(variableGradients: NamedVariableMap|NamedTensor[]) {\n    const varNames = Array.isArray(variableGradients) ?\n        variableGradients.map(v => v.name) :\n        Object.keys(variableGradients);\n    tidy(() => {\n      const oneMinusAccBeta1 = sub(1, this.accBeta1);\n      const oneMinusAccBeta2 = sub(1, this.accBeta2);\n\n      varNames.forEach((name, i) => {\n        const value = ENGINE.registeredVariables[name];\n        const trainable = false;\n        if (this.accumulatedFirstMoment[i] == null) {\n          this.accumulatedFirstMoment[i] = {\n            originalName: `${name}/m`,\n            variable: tidy(() => zerosLike(value).variable(trainable))\n          };\n        }\n        if (this.accumulatedSecondMoment[i] == null) {\n          this.accumulatedSecondMoment[i] = {\n            originalName: `${name}/v`,\n            variable: tidy(() => zerosLike(value).variable(trainable))\n          };\n        }\n\n        const gradient = Array.isArray(variableGradients) ?\n            variableGradients[i].tensor :\n            variableGradients[name];\n        if (gradient == null) {\n          return;\n        }\n\n        const firstMoment = this.accumulatedFirstMoment[i].variable;\n        const secondMoment = this.accumulatedSecondMoment[i].variable;\n\n        const newFirstMoment =\n            add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));\n        const newSecondMoment =\n            add(mul(secondMoment, this.beta2),\n                mul(square(gradient), 1 - this.beta2));\n\n        const biasCorrectedFirstMoment = div(newFirstMoment, oneMinusAccBeta1);\n        const biasCorrectedSecondMoment =\n            div(newSecondMoment, oneMinusAccBeta2);\n\n        firstMoment.assign(newFirstMoment);\n        secondMoment.assign(newSecondMoment);\n\n        const newValue =\n            add(mul(div(biasCorrectedFirstMoment,\n                        add(sqrt(biasCorrectedSecondMoment), this.epsilon)),\n                    -this.learningRate),\n                value);\n        value.assign(newValue);\n      });\n\n      this.accBeta1.assign(mul(this.accBeta1, this.beta1));\n      this.accBeta2.assign(mul(this.accBeta2, this.beta2));\n    });\n    this.incrementIterations();\n  }\n\n  dispose(): void {\n    this.accBeta1.dispose();\n    this.accBeta2.dispose();\n\n    if (this.accumulatedFirstMoment != null) {\n      dispose(this.accumulatedFirstMoment.map(v => v.variable));\n    }\n    if (this.accumulatedSecondMoment != null) {\n      dispose(this.accumulatedSecondMoment.map(v => v.variable));\n    }\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    // Order matters for Python compatibility.\n    const variables: OptimizerVariable[] =\n        [...this.accumulatedFirstMoment, ...this.accumulatedSecondMoment];\n    return [await this.saveIterations()].concat(\n        variables.map(v => ({name: v.originalName, tensor: v.variable})));\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    weightValues = await this.extractIterations(weightValues);\n    tidy(() => {\n      this.accBeta1.assign(pow(this.beta1, this.iterations_ + 1));\n      this.accBeta2.assign(pow(this.beta2, this.iterations_ + 1));\n    });\n\n    const variableCount = weightValues.length / 2;\n    const trainable = false;\n    this.accumulatedFirstMoment =\n        weightValues.slice(0, variableCount).map(v => ({\n                                                   originalName: v.name,\n                                                   variable: v.tensor.variable(\n                                                       trainable)\n                                                 }));\n    this.accumulatedSecondMoment =\n        weightValues.slice(variableCount, variableCount * 2)\n            .map(v => ({\n                   originalName: v.name,\n                   variable: v.tensor.variable(trainable)\n                 }));\n  }\n\n  getConfig(): ConfigDict {\n    return {\n      'learningRate': this.learningRate,\n      'beta1': this.beta1,\n      'beta2': this.beta2,\n      'epsilon': this.epsilon,\n    };\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(\n        config['learningRate'], config['beta1'], config['beta2'],\n        config['epsilon']);\n  }\n}\nregisterClass(AdamOptimizer);\n", "\uFEFF/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {dispose, tidy} from '../globals';\nimport {abs} from '../ops/abs';\nimport {add} from '../ops/add';\nimport {div} from '../ops/div';\nimport {maximum} from '../ops/maximum';\nimport {mul} from '../ops/mul';\nimport {scalar} from '../ops/scalar';\nimport {sub} from '../ops/sub';\nimport {zerosLike} from '../ops/zeros_like';\nimport {ConfigDict, registerClass, Serializable, SerializableConstructor} from '../serialization';\nimport {Variable} from '../tensor';\nimport {NamedTensor, NamedVariableMap} from '../tensor_types';\n\nimport {Optimizer, OptimizerVariable} from './optimizer';\n\nexport class AdamaxOptimizer extends Optimizer {\n  /** @nocollapse */\n  static className = 'Adamax';  // Note: Name matters for Python compatbility.\n  private accBeta1: Variable;\n  private iteration: Variable;\n\n  private accumulatedFirstMoment: OptimizerVariable[] = [];\n  private accumulatedWeightedInfNorm: OptimizerVariable[] = [];\n\n  constructor(\n      protected learningRate: number, protected beta1: number,\n      protected beta2: number, protected epsilon: number = null,\n      protected decay = 0.0) {\n    super();\n\n    tidy(() => {\n      this.iteration = scalar(0).variable();\n      this.accBeta1 = scalar(beta1).variable();\n    });\n\n    if (epsilon == null) {\n      this.epsilon = ENGINE.backend.epsilon();\n    }\n  }\n\n  applyGradients(variableGradients: NamedVariableMap|NamedTensor[]) {\n    const variableNames = Array.isArray(variableGradients) ?\n        variableGradients.map(item => item.name) :\n        Object.keys(variableGradients);\n\n    tidy(() => {\n      const oneMinusAccBeta1 = sub(1, this.accBeta1);\n      const lr =\n          div(-this.learningRate, add(mul(this.iteration, this.decay), 1));\n\n      variableNames.forEach((name, i) => {\n        const value = ENGINE.registeredVariables[name];\n        const trainable = false;\n        if (this.accumulatedFirstMoment[i] == null) {\n          this.accumulatedFirstMoment[i] = {\n            originalName: `${name}/m`,\n            variable: zerosLike(value).variable(trainable)\n          };\n        }\n        if (this.accumulatedWeightedInfNorm[i] == null) {\n          this.accumulatedWeightedInfNorm[i] = {\n            originalName: `${name}/v`,\n            variable: zerosLike(value).variable(trainable)\n          };\n        }\n\n        const gradient = Array.isArray(variableGradients) ?\n            variableGradients[i].tensor :\n            variableGradients[name];\n        if (gradient == null) {\n          return;\n        }\n\n        const firstMoment = this.accumulatedFirstMoment[i].variable;\n        const weightedInfNorm = this.accumulatedWeightedInfNorm[i].variable;\n\n        const newFirstMoment =\n            add(mul(firstMoment, this.beta1), mul(gradient, 1 - this.beta1));\n\n        const ut0 = mul(weightedInfNorm, this.beta2);\n        const ut1 = abs(gradient);\n\n        const newWeightedInfNorm = maximum(ut0, ut1);\n\n        firstMoment.assign(newFirstMoment);\n        weightedInfNorm.assign(newWeightedInfNorm);\n\n        const newValue =\n            add(mul(div(lr, oneMinusAccBeta1),\n                    div(newFirstMoment, add(newWeightedInfNorm, this.epsilon))),\n                value);\n\n        value.assign(newValue);\n      });\n\n      this.iteration.assign(add(this.iteration, 1));\n      this.accBeta1.assign(mul(this.accBeta1, this.beta1));\n    });\n    this.incrementIterations();\n  }\n\n  dispose(): void {\n    this.accBeta1.dispose();\n    this.iteration.dispose();\n\n    if (this.accumulatedFirstMoment != null) {\n      dispose(this.accumulatedFirstMoment.map(v => v.variable));\n    }\n    if (this.accumulatedWeightedInfNorm != null) {\n      dispose(this.accumulatedWeightedInfNorm.map(v => v.variable));\n    }\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    throw new Error('getWeights() is not implemented for Adamax yet.');\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    throw new Error('setWeights() is not implemented for Adamax yet.');\n  }\n\n  getConfig(): ConfigDict {\n    return {\n      'learningRate': this.learningRate,\n      'beta1': this.beta1,\n      'beta2': this.beta2,\n      'epsilon': this.epsilon,\n      'decay': this.decay\n    };\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(\n        config['learningRate'], config['beta1'], config['beta2'],\n        config['epsilon'], config['decay']);\n  }\n}\nregisterClass(AdamaxOptimizer);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {keep, tidy} from '../globals';\nimport {add} from '../ops/add';\nimport {mul} from '../ops/mul';\nimport {scalar} from '../ops/scalar';\nimport {ConfigDict, registerClass, Serializable, SerializableConstructor} from '../serialization';\nimport {Scalar} from '../tensor';\nimport {NamedTensor, NamedTensorMap} from '../tensor_types';\n\nimport {Optimizer} from './optimizer';\n\n/** @doclink Optimizer */\nexport class SGDOptimizer extends Optimizer {\n  /** @nocollapse */\n  static className = 'SGD';  // Note: Name matters for Python compatibility.\n  protected c: Scalar;\n\n  constructor(protected learningRate: number) {\n    super();\n    this.setLearningRate(learningRate);\n  }\n\n  applyGradients(variableGradients: NamedTensorMap|NamedTensor[]) {\n    const varNames = Array.isArray(variableGradients) ?\n        variableGradients.map(v => v.name) :\n        Object.keys(variableGradients);\n    varNames.forEach((name, i) => {\n      const gradient = Array.isArray(variableGradients) ?\n          variableGradients[i].tensor :\n          variableGradients[name];\n      if (gradient == null) {\n        return;\n      }\n      const value = ENGINE.registeredVariables[name];\n      tidy(() => {\n        const newValue = add(mul(this.c, gradient), value);\n        value.assign(newValue);\n      });\n    });\n    this.incrementIterations();\n  }\n\n  /**\n   * Sets the learning rate of the optimizer.\n   */\n  setLearningRate(learningRate: number) {\n    this.learningRate = learningRate;\n    if (this.c != null) {\n      this.c.dispose();\n    }\n    this.c = keep(scalar(-learningRate));\n  }\n\n  dispose() {\n    this.c.dispose();\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    return [await this.saveIterations()];\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    weightValues = await this.extractIterations(weightValues);\n    if (weightValues.length !== 0) {\n      throw new Error('SGD optimizer does not have settable weights.');\n    }\n  }\n\n  getConfig(): ConfigDict {\n    return {'learningRate': this.learningRate};\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(config['learningRate']);\n  }\n}\nregisterClass(SGDOptimizer);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {dispose, tidy} from '../globals';\nimport {add} from '../ops/add';\nimport {mul} from '../ops/mul';\nimport {scalar} from '../ops/scalar';\nimport {zerosLike} from '../ops/zeros_like';\nimport {ConfigDict, registerClass, Serializable, SerializableConstructor} from '../serialization';\nimport {Scalar, Tensor} from '../tensor';\nimport {NamedTensor, NamedVariableMap} from '../tensor_types';\n\nimport {OptimizerVariable} from './optimizer';\nimport {SGDOptimizer} from './sgd_optimizer';\n\n/** @doclink Optimizer */\nexport class MomentumOptimizer extends SGDOptimizer {\n  /** @nocollapse */\n  static className = 'Momentum';  // Name matters for Python compatibility.\n  private m: Scalar;\n  private accumulations: OptimizerVariable[] = [];\n\n  constructor(\n      protected learningRate: number, private momentum: number,\n      private useNesterov = false) {\n    super(learningRate);\n    this.m = scalar(this.momentum);\n  }\n\n  applyGradients(variableGradients: NamedVariableMap|NamedTensor[]) {\n    const variableNames = Array.isArray(variableGradients) ?\n        variableGradients.map(item => item.name) :\n        Object.keys(variableGradients);\n\n    variableNames.forEach((name, i) => {\n      const value = ENGINE.registeredVariables[name];\n      if (this.accumulations[i] == null) {\n        const trainable = false;\n        this.accumulations[i] = {\n          originalName: `${name}/momentum`,\n          variable: tidy(() => zerosLike(value).variable(trainable))\n        };\n      }\n\n      const accumulation = this.accumulations[i].variable;\n      const gradient = Array.isArray(variableGradients) ?\n          variableGradients[i].tensor :\n          variableGradients[name];\n      if (gradient == null) {\n        return;\n      }\n\n      tidy(() => {\n        let newValue: Tensor;\n        const newAccumulation = add(mul(this.m, accumulation), gradient);\n        if (this.useNesterov) {\n          newValue = add(\n              mul(this.c, add(gradient, mul(newAccumulation, this.m))), value);\n        } else {\n          newValue = add(mul(this.c, newAccumulation), value);\n        }\n        accumulation.assign(newAccumulation);\n        value.assign(newValue);\n      });\n    });\n    this.incrementIterations();\n  }\n\n  dispose(): void {\n    this.m.dispose();\n    if (this.accumulations != null) {\n      dispose(this.accumulations.map(v => v.variable));\n    }\n  }\n\n  /**\n   * Sets the momentum of the optimizer.\n   *\n   * @param momentum\n   */\n  setMomentum(momentum: number) {\n    this.momentum = momentum;\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    // Order matters for Python compatibility.\n    return [await this.saveIterations()].concat(this.accumulations.map(\n        v => ({name: v.originalName, tensor: v.variable})));\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    weightValues = await this.extractIterations(weightValues);\n    const trainable = false;\n    this.accumulations = weightValues.map(\n        v => ({originalName: v.name, variable: v.tensor.variable(trainable)}));\n  }\n\n  getConfig(): ConfigDict {\n    return {\n      'learningRate': this.learningRate,\n      'momentum': this.momentum,\n      'useNesterov': this.useNesterov\n    };\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(\n        config['learningRate'], config['momentum'], config['useNesterov']);\n  }\n}\nregisterClass(MomentumOptimizer);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {dispose, tidy} from '../globals';\nimport {add} from '../ops/add';\nimport {div} from '../ops/div';\nimport {mul} from '../ops/mul';\nimport {sqrt} from '../ops/sqrt';\nimport {square} from '../ops/square';\nimport {sub} from '../ops/sub';\nimport {zerosLike} from '../ops/zeros_like';\nimport {ConfigDict, registerClass, Serializable, SerializableConstructor} from '../serialization';\nimport {NamedTensor, NamedTensorMap} from '../tensor_types';\n\nimport {Optimizer, OptimizerVariable} from './optimizer';\n\n/** @doclink Optimizer */\nexport class RMSPropOptimizer extends Optimizer {\n  /** @nocollapse */\n  static className = 'RMSProp';  // Note: Name matters for Python compatibility.\n  private centered: boolean;\n\n  private accumulatedMeanSquares: OptimizerVariable[] = [];\n  private accumulatedMoments: OptimizerVariable[] = [];\n  private accumulatedMeanGrads: OptimizerVariable[] = [];\n\n  constructor(\n      protected learningRate: number, protected decay = 0.9,\n      protected momentum = 0.0, protected epsilon: number = null,\n      centered = false) {\n    super();\n\n    this.centered = centered;\n\n    if (epsilon == null) {\n      this.epsilon = ENGINE.backend.epsilon();\n    }\n    if (learningRate == null) {\n      throw new Error(`learningRate for RMSPropOptimizer must be defined.`);\n    }\n  }\n\n  applyGradients(variableGradients: NamedTensorMap|NamedTensor[]) {\n    const variableNames = Array.isArray(variableGradients) ?\n        variableGradients.map(item => item.name) :\n        Object.keys(variableGradients);\n\n    variableNames.forEach((name, i) => {\n      const value = ENGINE.registeredVariables[name];\n      const trainable = false;\n      if (this.accumulatedMeanSquares[i] == null) {\n        this.accumulatedMeanSquares[i] = {\n          originalName: `${name}/rms`,\n          variable: tidy(() => zerosLike(value).variable(trainable))\n        };\n      }\n      if (this.accumulatedMoments[i] == null) {\n        this.accumulatedMoments[i] = {\n          originalName: `${name}/momentum`,\n          variable: tidy(() => zerosLike(value).variable(trainable))\n        };\n      }\n      if (this.accumulatedMeanGrads[i] == null && this.centered) {\n        this.accumulatedMeanGrads[i] = {\n          originalName: `${name}/mg`,\n          variable: tidy(() => zerosLike(value).variable(trainable))\n        };\n      }\n\n      const gradient = Array.isArray(variableGradients) ?\n          variableGradients[i].tensor :\n          variableGradients[name];\n      if (gradient == null) {\n        return;\n      }\n\n      const accumulatedMeanSquare = this.accumulatedMeanSquares[i].variable;\n      const accumulatedMoments = this.accumulatedMoments[i].variable;\n      tidy(() => {\n        const newAccumulatedMeanSquare =\n            add(mul(accumulatedMeanSquare, this.decay),\n                mul(square(gradient), 1 - this.decay));\n\n        if (this.centered) {\n          const accumulatedMeanGrad = this.accumulatedMeanGrads[i].variable;\n          // Centered gradient\n          const newAccumulatedMeanGrad =\n              add(mul(accumulatedMeanGrad, this.decay),\n                  mul(gradient, 1 - this.decay));\n\n          const gradContribution =\n              div(mul(gradient, this.learningRate),\n                  sqrt(\n                      sub(newAccumulatedMeanSquare,\n                          add(square(newAccumulatedMeanGrad), this.epsilon))));\n          const newAccumulatedMoments =\n              add(mul(accumulatedMoments, this.momentum), gradContribution);\n\n          accumulatedMeanSquare.assign(newAccumulatedMeanSquare);\n          accumulatedMeanGrad.assign(newAccumulatedMeanGrad);\n          accumulatedMoments.assign(newAccumulatedMoments);\n\n          const newValue = sub(value, newAccumulatedMoments);\n          value.assign(newValue);\n        } else {\n          // Plain gradient\n          const newAccumulatedMeanSquare =\n              add(mul(accumulatedMeanSquare, this.decay),\n                  mul(square(gradient), 1 - this.decay));\n\n          const newAccumulatedMoments =\n              add(mul(accumulatedMoments, this.momentum),\n                  div(mul(gradient, this.learningRate),\n                      sqrt(add(newAccumulatedMeanSquare, this.epsilon))));\n\n          accumulatedMeanSquare.assign(newAccumulatedMeanSquare);\n          accumulatedMoments.assign(newAccumulatedMoments);\n\n          const newValue = sub(value, newAccumulatedMoments);\n          value.assign(newValue);\n        }\n      });\n    });\n    this.incrementIterations();\n  }\n\n  dispose(): void {\n    if (this.accumulatedMeanSquares != null) {\n      dispose(this.accumulatedMeanSquares.map(v => v.variable));\n    }\n    if (this.accumulatedMeanGrads != null && this.centered) {\n      dispose(this.accumulatedMeanGrads.map(v => v.variable));\n    }\n    if (this.accumulatedMoments != null) {\n      dispose(this.accumulatedMoments.map(v => v.variable));\n    }\n  }\n\n  async getWeights(): Promise<NamedTensor[]> {\n    // Order matters for Python compatibility.\n    const variables: OptimizerVariable[] =\n        [...this.accumulatedMeanSquares, ...this.accumulatedMoments];\n    if (this.centered) {\n      variables.push(...this.accumulatedMeanGrads);\n    }\n    return [await this.saveIterations()].concat(\n        variables.map(v => ({name: v.originalName, tensor: v.variable})));\n  }\n\n  async setWeights(weightValues: NamedTensor[]): Promise<void> {\n    weightValues = await this.extractIterations(weightValues);\n    const variableCount =\n        this.centered ? weightValues.length / 3 : weightValues.length / 2;\n    const trainable = false;\n    this.accumulatedMeanSquares =\n        weightValues.slice(0, variableCount).map(v => ({\n                                                   originalName: v.name,\n                                                   variable: v.tensor.variable(\n                                                       trainable)\n                                                 }));\n    this.accumulatedMoments =\n        weightValues.slice(variableCount, variableCount * 2)\n            .map(v => ({\n                   originalName: v.name,\n                   variable: v.tensor.variable(trainable)\n                 }));\n    if (this.centered) {\n      this.accumulatedMeanGrads =\n          weightValues.slice(variableCount * 2, variableCount * 3)\n              .map(v => ({\n                     originalName: v.name,\n                     variable: v.tensor.variable(trainable)\n                   }));\n    }\n  }\n\n  getConfig(): ConfigDict {\n    return {\n      'learningRate': this.learningRate,\n      'decay': this.decay,\n      'momentum': this.momentum,\n      'epsilon': this.epsilon,\n      'centered': this.centered\n    };\n  }\n\n  /** @nocollapse */\n  static fromConfig<T extends Serializable>(\n      cls: SerializableConstructor<T>, config: ConfigDict): T {\n    return new cls(\n        config['learningRate'], config['decay'], config['momentum'],\n        config['epsilon'], config['centered']);\n  }\n}\nregisterClass(RMSPropOptimizer);\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor, Variable} from './tensor';\n\n/** @docalias {[name: string]: Tensor} */\nexport type NamedTensorMap = {\n  [name: string]: Tensor;\n};\n\nexport interface NamedTensor {\n  name: string;\n  tensor: Tensor;\n}\n\nexport type NamedVariableMap = {\n  [name: string]: Variable;\n};\n\nexport type GradSaveFunc = (save: Tensor[]) => void;\n\n/**\n * @docalias void|number|string|TypedArray|Tensor|Tensor[]|{[key:\n * string]:Tensor|number|string}\n */\nexport type TensorContainer =\n    void|Tensor|string|number|boolean|TensorContainerObject|\n    TensorContainerArray|Float32Array|Int32Array|Uint8Array;\nexport interface TensorContainerObject {\n  [x: string]: TensorContainer;\n}\nexport interface TensorContainerArray extends Array<TensorContainer> {}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {AdadeltaOptimizer} from './adadelta_optimizer';\nimport {AdagradOptimizer} from './adagrad_optimizer';\nimport {AdamOptimizer} from './adam_optimizer';\nimport {AdamaxOptimizer} from './adamax_optimizer';\nimport {MomentumOptimizer} from './momentum_optimizer';\nimport {RMSPropOptimizer} from './rmsprop_optimizer';\nimport {SGDOptimizer} from './sgd_optimizer';\n\nexport class OptimizerConstructors {\n  /**\n   * Constructs a `tf.SGDOptimizer` that uses stochastic gradient descent.\n   *\n   * ```js\n   * // Fit a quadratic function by learning the coefficients a, b, c.\n   * const xs = tf.tensor1d([0, 1, 2, 3]);\n   * const ys = tf.tensor1d([1.1, 5.9, 16.8, 33.9]);\n   *\n   * const a = tf.scalar(Math.random()).variable();\n   * const b = tf.scalar(Math.random()).variable();\n   * const c = tf.scalar(Math.random()).variable();\n   *\n   * // y = a * x^2 + b * x + c.\n   * const f = x => a.mul(x.square()).add(b.mul(x)).add(c);\n   * const loss = (pred, label) => pred.sub(label).square().mean();\n   *\n   * const learningRate = 0.01;\n   * const optimizer = tf.train.sgd(learningRate);\n   *\n   * // Train the model.\n   * for (let i = 0; i < 10; i++) {\n   *   optimizer.minimize(() => loss(f(xs), ys));\n   * }\n   *\n   * // Make predictions.\n   * console.log(\n   *     `a: ${a.dataSync()}, b: ${b.dataSync()}, c: ${c.dataSync()}`);\n   * const preds = f(xs).dataSync();\n   * preds.forEach((pred, i) => {\n   *   console.log(`x: ${i}, pred: ${pred}`);\n   * });\n   * ```\n   *\n   * @param learningRate The learning rate to use for the SGD algorithm.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}\n   */\n  static sgd(learningRate: number): SGDOptimizer {\n    return new SGDOptimizer(learningRate);\n  }\n\n  /**\n   * Constructs a `tf.MomentumOptimizer` that uses momentum gradient\n   * descent.\n   *\n   * See\n   * [http://proceedings.mlr.press/v28/sutskever13.pdf](\n   * http://proceedings.mlr.press/v28/sutskever13.pdf)\n   *\n   * @param learningRate The learning rate to use for the Momentum gradient\n   * descent algorithm.\n   * @param momentum The momentum to use for the momentum gradient descent\n   * algorithm.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}\n   */\n  static momentum(learningRate: number, momentum: number, useNesterov = false):\n      MomentumOptimizer {\n    return new MomentumOptimizer(learningRate, momentum, useNesterov);\n  }\n\n  /**\n   * Constructs a `tf.RMSPropOptimizer` that uses RMSProp gradient\n   * descent. This implementation uses plain momentum and is not centered\n   * version of RMSProp.\n   *\n   * See\n   * [http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf](\n   * http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf)\n   *\n   * @param learningRate The learning rate to use for the RMSProp gradient\n   * descent algorithm.\n   * @param decay The discounting factor for the history/coming gradient.\n   * @param momentum The momentum to use for the RMSProp gradient descent\n   * algorithm.\n   * @param epsilon Small value to avoid zero denominator.\n   * @param centered If true, gradients are normalized by the estimated\n   * variance of the gradient.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}\n   */\n  static rmsprop(\n      learningRate: number, decay = .9, momentum = 0.0, epsilon: number = null,\n      centered = false): RMSPropOptimizer {\n    return new RMSPropOptimizer(\n        learningRate, decay, momentum, epsilon, centered);\n  }\n\n  /**\n   * Constructs a `tf.AdamOptimizer` that uses the Adam algorithm.\n   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)\n   *\n   * @param learningRate The learning rate to use for the Adam gradient\n   * descent algorithm.\n   * @param beta1 The exponential decay rate for the 1st moment estimates.\n   * @param beta2 The exponential decay rate for the 2nd moment estimates.\n   * @param epsilon A small constant for numerical stability.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}\n   */\n  static adam(\n      learningRate = 0.001, beta1 = 0.9, beta2 = 0.999,\n      epsilon: number = null): AdamOptimizer {\n    return new AdamOptimizer(learningRate, beta1, beta2, epsilon);\n  }\n\n  /**\n   * Constructs a `tf.AdadeltaOptimizer` that uses the Adadelta algorithm.\n   * See [https://arxiv.org/abs/1212.5701](https://arxiv.org/abs/1212.5701)\n   *\n   * @param learningRate The learning rate to use for the Adadelta gradient\n   * descent algorithm.\n   * @param rho The learning rate decay over each update.\n   * @param epsilon A constant epsilon used to better condition the grad\n   * update.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}\n   */\n  static adadelta(learningRate = .001, rho = .95, epsilon: number = null):\n      AdadeltaOptimizer {\n    return new AdadeltaOptimizer(learningRate, rho, epsilon);\n  }\n\n  /**\n   * Constructs a `tf.AdamaxOptimizer` that uses the Adamax algorithm.\n   * See [https://arxiv.org/abs/1412.6980](https://arxiv.org/abs/1412.6980)\n   *\n   * @param learningRate The learning rate to use for the Adamax gradient\n   * descent algorithm.\n   * @param beta1 The exponential decay rate for the 1st moment estimates.\n   * @param beta2 The exponential decay rate for the 2nd moment estimates.\n   * @param epsilon A small constant for numerical stability.\n   * @param decay The learning rate decay over each update.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}\n   */\n  static adamax(\n      learningRate = 0.002, beta1 = 0.9, beta2 = 0.999, epsilon: number = null,\n      decay = 0.0): AdamaxOptimizer {\n    return new AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay);\n  }\n\n  /**\n   * Constructs a `tf.AdagradOptimizer` that uses the Adagrad algorithm.\n   * See\n   * [http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf](\n   * http://www.jmlr.org/papers/volume12/duchi11a/duchi11a.pdf)\n   * or\n   * [http://ruder.io/optimizing-gradient-descent/index.html#adagrad](\n   * http://ruder.io/optimizing-gradient-descent/index.html#adagrad)\n   *\n   * @param learningRate The learning rate to use for the Adagrad gradient\n   * descent algorithm.\n   * @param initialAccumulatorValue Starting value for the accumulators, must be\n   * positive.\n   *\n   * @doc {heading: 'Training', subheading: 'Optimizers', namespace: 'train'}\n   */\n  static adagrad(learningRate: number, initialAccumulatorValue = 0.1):\n      AdagradOptimizer {\n    return new AdagradOptimizer(learningRate, initialAccumulatorValue);\n  }\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// So typings can propagate.\nimport {AdadeltaOptimizer} from './optimizers/adadelta_optimizer';\nimport {AdagradOptimizer} from './optimizers/adagrad_optimizer';\nimport {AdamOptimizer} from './optimizers/adam_optimizer';\nimport {AdamaxOptimizer} from './optimizers/adamax_optimizer';\nimport {MomentumOptimizer} from './optimizers/momentum_optimizer';\nimport {OptimizerConstructors} from './optimizers/optimizer_constructors';\nimport {RMSPropOptimizer} from './optimizers/rmsprop_optimizer';\nimport {SGDOptimizer} from './optimizers/sgd_optimizer';\n\n// tslint:disable-next-line:no-unused-expression\n[MomentumOptimizer, SGDOptimizer, AdadeltaOptimizer, AdagradOptimizer,\n RMSPropOptimizer, AdamaxOptimizer, AdamOptimizer];\n\nexport const train = {\n  sgd: OptimizerConstructors.sgd,\n  momentum: OptimizerConstructors.momentum,\n  adadelta: OptimizerConstructors.adadelta,\n  adagrad: OptimizerConstructors.adagrad,\n  rmsprop: OptimizerConstructors.rmsprop,\n  adamax: OptimizerConstructors.adamax,\n  adam: OptimizerConstructors.adam\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {RequestDetails} from '../io/types';\n\n/**\n * At any given time a single platform is active and represents and\n * implementation of this interface. In practice, a platform is an environment\n * where TensorFlow.js can be executed, e.g. the browser or Node.js.\n */\nexport interface Platform {\n  /**\n   * Makes an HTTP request.\n   * @param path The URL path to make a request to\n   * @param init The request init. See init here:\n   *     https://developer.mozilla.org/en-US/docs/Web/API/Request/Request\n   */\n  fetch(path: string, requestInits?: RequestInit, options?: RequestDetails):\n      Promise<Response>;\n\n  /**\n   * Returns the current high-resolution time in milliseconds relative to an\n   * arbitrary time in the past. It works across different platforms (node.js,\n   * browsers).\n   */\n  now(): number;\n\n  /**\n   * Encode the provided string into an array of bytes using the provided\n   * encoding.\n   */\n  encode(text: string, encoding: string): Uint8Array;\n  /** Decode the provided bytes into a string using the provided encoding. */\n  decode(bytes: Uint8Array, encoding: string): string;\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nconst delayCallback: Function = (() => {\n  if (typeof requestAnimationFrame !== 'undefined') {\n    return requestAnimationFrame;\n  } else if (typeof setImmediate !== 'undefined') {\n    return setImmediate;\n  }\n  return (f: Function) => f();  // no delays\n})();\n\n/**\n * Returns a promise that resolve when a requestAnimationFrame has completed.\n *\n * On Node.js this uses setImmediate instead of requestAnimationFrame.\n *\n * This is simply a sugar method so that users can do the following:\n * `await tf.nextFrame();`\n *\n * @doc {heading: 'Performance', subheading: 'Timing'}\n */\nfunction nextFrame(): Promise<void> {\n  return new Promise<void>(resolve => delayCallback(() => resolve()));\n}\n\nexport {nextFrame};\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {decodeString, encodeString} from '../util';\n\n// Utilities needed by backend consumers of tf-core.\nexport * from '../ops/axis_util';\nexport * from '../ops/broadcast_util';\nexport * from '../ops/concat_util';\nexport * from '../ops/conv_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/fused_types';\nexport * from '../ops/reduce_util';\n\nimport * as slice_util from '../ops/slice_util';\nexport {slice_util};\n\nexport {BackendValues, TypedArray, upcastType, PixelData} from '../types';\nexport {MemoryInfo, TimingInfo} from '../engine';\nexport * from '../ops/rotate_util';\nexport * from '../ops/array_ops_util';\nexport * from '../ops/gather_nd_util';\nexport * from '../ops/scatter_nd_util';\nexport * from '../ops/selu_util';\nexport * from '../ops/fused_util';\nexport * from '../ops/erf_util';\nexport * from '../log';\nexport * from '../backends/complex_util';\nexport * from '../backends/einsum_util';\nexport * from '../ops/split_util';\n\nimport * as segment_util from '../ops/segment_util';\nexport {segment_util};\n\nexport function fromUint8ToStringArray(vals: Uint8Array[]) {\n  try {\n    // Decode the bytes into string.\n    return vals.map(val => decodeString(val));\n  } catch (err) {\n    throw new Error(\n        `Failed to decode encoded string bytes into utf-8, error: ${err}`);\n  }\n}\n\nexport function fromStringArrayToUint8(strings: string[]) {\n  return strings.map(s => encodeString(s));\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as util from '../util';\n\nexport function assertParamsConsistent(shapes: number[][], axis: number) {\n  const rank = shapes[0].length;\n  shapes.forEach((shape, i) => {\n    util.assert(\n        shape.length === rank,\n        () =>\n            `Error in concat${rank}D: rank of tensors[${i}] must be the same ` +\n            `as the rank of the rest (${rank})`);\n  });\n\n  util.assert(\n      axis >= 0 && axis < rank,\n      () => `Error in concat${rank}D: axis must be between 0 and ${rank - 1}.`);\n\n  const firstShape = shapes[0];\n  shapes.forEach((shape, i) => {\n    for (let r = 0; r < rank; r++) {\n      util.assert(\n          (r === axis) || (shape[r] === firstShape[r]),\n          () => `Error in concat${rank}D: Shape of tensors[${i}] (${shape}) ` +\n              `does not match the shape of the rest (${firstShape}) ` +\n              `along the non-concatenated axis ${i}.`);\n    }\n  });\n}\n\nexport function computeOutShape(shapes: number[][], axis: number): number[] {\n  const outputShape = shapes[0].slice();\n  for (let i = 1; i < shapes.length; i++) {\n    outputShape[axis] += shapes[i][axis];\n  }\n  return outputShape;\n}\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Inputs of size above this threshold will be parallelized by calling multiple\n * shader programs.\n */\nimport {nearestDivisor} from '../util';\n\nexport const PARALLELIZE_THRESHOLD = 30;\n\nexport interface ReduceInfo {\n  windowSize: number;\n  batchSize: number;\n  inSize: number;\n  outSize: number;\n}\n\nexport function computeOptimalWindowSize(inSize: number): number {\n  if (inSize <= PARALLELIZE_THRESHOLD) {\n    return inSize;\n  }\n  return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Returns the image center in pixels.\nexport function getImageCenter(\n    center: number|[number, number], imageHeight: number,\n    imageWidth: number): [number, number] {\n  const centerX =\n      imageWidth * (typeof center === 'number' ? center : center[0]);\n  const centerY =\n      imageHeight * (typeof center === 'number' ? center : center[1]);\n  return [centerX, centerY];\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Gets the new shape of the input Tensor after it's been reshaped\n * to:\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\n * inputShape[1], ..., inputShape[N-1]]\n *\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshaped(\n    inputShape: number[], blockShape: number[], prod: number,\n    batchToSpace = true): number[] {\n  let reshaped: number[] = [];\n  if (batchToSpace) {\n    reshaped = reshaped.concat(blockShape.slice(0));\n    reshaped.push(inputShape[0] / prod);\n    reshaped = reshaped.concat(inputShape.slice(1));\n  } else {\n    reshaped = reshaped.concat(inputShape[0]);\n    const spatialLength = blockShape.length;\n    for (let i = 0; i < spatialLength; ++i) {\n      reshaped =\n          reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\n    }\n    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\n  }\n  return reshaped;\n}\n\n/**\n * Gets the permutation that will transpose the dimensions of the\n * reshaped tensor to shape:\n *\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getPermuted(\n    reshapedRank: number, blockShapeRank: number,\n    batchToSpace = true): number[] {\n  const permuted = [];\n  if (batchToSpace) {\n    permuted.push(blockShapeRank);\n    for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {\n      if (i <= 2 * blockShapeRank) {\n        permuted.push(i);\n        permuted.push(i - (blockShapeRank + 1));\n      } else {\n        permuted.push(i);\n      }\n    }\n  } else {\n    const permutedBeforeBatch = [];\n    const permutedAfterBatch = [];\n    for (let i = 1; i < reshapedRank; ++i) {\n      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {\n        permutedAfterBatch.push(i);\n      } else {\n        permutedBeforeBatch.push(i);\n      }\n    }\n    permuted.push(...permutedBeforeBatch);\n    permuted.push(0);\n    permuted.push(...permutedAfterBatch);\n  }\n  return permuted;\n}\n\n/**\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\n * is applied.  The new shape will be:\n *\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshapedPermuted(\n    inputShape: number[], blockShape: number[], prod: number,\n    batchToSpace = true): number[] {\n  const reshapedPermuted = [];\n\n  if (batchToSpace) {\n    reshapedPermuted.push(inputShape[0] / prod);\n  } else {\n    reshapedPermuted.push(inputShape[0] * prod);\n  }\n\n  for (let i = 1; i < inputShape.length; ++i) {\n    if (i <= blockShape.length) {\n      if (batchToSpace) {\n        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\n      } else {\n        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\n      }\n    } else {\n      reshapedPermuted.push(inputShape[i]);\n    }\n  }\n\n  return reshapedPermuted;\n}\n\n/**\n * Converts the crops argument into the beginning coordinates of a slice\n * operation.\n */\nexport function getSliceBeginCoords(\n    crops: number[][], blockShape: number): number[] {\n  const sliceBeginCoords = [0];\n  for (let i = 0; i < blockShape; ++i) {\n    sliceBeginCoords.push(crops[i][0]);\n  }\n  return sliceBeginCoords;\n}\n\n/**\n * Converts the crops argument into the size of a slice operation.  When\n * combined with getSliceBeginCoords this function allows the reshaped and\n * permuted Tensor to be cropped to its final output shape of:\n *\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getSliceSize(\n    uncroppedShape: number[], crops: number[][], blockShape: number): number[] {\n  const sliceSize = uncroppedShape.slice(0, 1);\n  for (let i = 0; i < blockShape; ++i) {\n    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\n  }\n\n  return sliceSize;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport const SELU_SCALEALPHA = 1.7580993408473768599402175208123;\nexport const SELU_SCALE = 1.0507009873554804934193349852946;\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport const ERF_P = 0.3275911;\nexport const ERF_A1 = 0.254829592;\nexport const ERF_A2 = -0.284496736;\nexport const ERF_A3 = 1.421413741;\nexport const ERF_A4 = -1.453152027;\nexport const ERF_A5 = 1.061405429;\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray} from '../types';\n/**\n * Merges real and imaginary Float32Arrays into a single complex Float32Array.\n *\n * The memory layout is interleaved as follows:\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n * complex: [r0, i0, r1, i1, r2, i2]\n *\n * This is the inverse of splitRealAndImagArrays.\n *\n * @param real The real values of the complex tensor values.\n * @param imag The imag values of the complex tensor values.\n * @returns A complex tensor as a Float32Array with merged values.\n */\nexport function mergeRealAndImagArrays(\n    real: Float32Array, imag: Float32Array): Float32Array {\n  if (real.length !== imag.length) {\n    throw new Error(\n        `Cannot merge real and imag arrays of different lengths. real:` +\n        `${real.length}, imag: ${imag.length}.`);\n  }\n  const result = new Float32Array(real.length * 2);\n  for (let i = 0; i < result.length; i += 2) {\n    result[i] = real[i / 2];\n    result[i + 1] = imag[i / 2];\n  }\n  return result;\n}\n\n/**\n * Splits a complex Float32Array into real and imag parts.\n *\n * The memory layout is interleaved as follows:\n * complex: [r0, i0, r1, i1, r2, i2]\n * real: [r0, r1, r2]\n * imag: [i0, i1, i2]\n *\n * This is the inverse of mergeRealAndImagArrays.\n *\n * @param complex The complex tensor values.\n * @returns An object with real and imag Float32Array components of the complex\n *     tensor.\n */\nexport function splitRealAndImagArrays(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const real = new Float32Array(complex.length / 2);\n  const imag = new Float32Array(complex.length / 2);\n  for (let i = 0; i < complex.length; i += 2) {\n    real[i / 2] = complex[i];\n    imag[i / 2] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Extracts even indexed complex values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithEvenIndex(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const len = Math.ceil(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 0; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Extracts odd indexed comple values in the given array.\n * @param complex The complex tensor values\n */\nexport function complexWithOddIndex(complex: Float32Array):\n    {real: Float32Array, imag: Float32Array} {\n  const len = Math.floor(complex.length / 4);\n  const real = new Float32Array(len);\n  const imag = new Float32Array(len);\n  for (let i = 2; i < complex.length; i += 4) {\n    real[Math.floor(i / 4)] = complex[i];\n    imag[Math.floor(i / 4)] = complex[i + 1];\n  }\n  return {real, imag};\n}\n\n/**\n * Get the map representing a complex value in the given array.\n * @param complex The complex tensor values.\n * @param index An index of the target complex value.\n */\nexport function getComplexWithIndex(\n    complex: Float32Array, index: number): {real: number, imag: number} {\n  const real = complex[index * 2];\n  const imag = complex[index * 2 + 1];\n  return {real, imag};\n}\n\n/**\n * Insert a given complex value into the TypedArray.\n * @param data The array in which the complex value is inserted.\n * @param c The complex value to be inserted.\n * @param index An index of the target complex value.\n */\nexport function assignToTypedArray(\n    data: TypedArray, real: number, imag: number, index: number) {\n  data[index * 2] = real;\n  data[index * 2 + 1] = imag;\n}\n\n/**\n * Make the list of exponent terms used by FFT.\n */\nexport function exponents(\n    n: number, inverse: boolean): {real: Float32Array, imag: Float32Array} {\n  const real = new Float32Array(n / 2);\n  const imag = new Float32Array(n / 2);\n  for (let i = 0; i < Math.ceil(n / 2); i++) {\n    const x = (inverse ? 2 : -2) * Math.PI * (i / n);\n    real[i] = Math.cos(x);\n    imag[i] = Math.sin(x);\n  }\n  return {real, imag};\n}\n\n/**\n * Make the exponent term used by FFT.\n */\nexport function exponent(\n    k: number, n: number, inverse: boolean): {real: number, imag: number} {\n  const x = (inverse ? 2 : -2) * Math.PI * (k / n);\n  const real = Math.cos(x);\n  const imag = Math.sin(x);\n  return {real, imag};\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Utility functions for computing einsum (tensor contraction and summation\n * based on Einstein summation.)\n */\n\nimport {Tensor} from '../tensor';\nimport {assert} from '../util_base';\n\nconst ARROW = '->';\nconst ARROW_REGEX = /->/g;\nconst COMMA = ',';\nconst ELLIPSIS = '...';\n\n/**\n * Parse an equation for einsum.\n *\n * @param equation The einsum equation (e.g., \"ij,jk->ik\").\n * @param numTensors Number of tensors provided along with `equation`. Used to\n *   check matching number of input tensors.\n * @returns An object consisting of the following fields:\n *   - allDims: all dimension names as strings.\n *   - summedDims: a list of all dimensions being summed over, as indices to\n *     the elements of `allDims`.\n *   - idDims: indices of the dimensions in each input tensor, as indices to\n *     the elements of `allDims.\n */\nexport function decodeEinsumEquation(equation: string, numTensors: number): {\n  allDims: string[],\n  summedDims: number[],\n  idDims: number[][],\n} {\n  equation = equation.replace(/\\s/g, '');  // Remove witespace in equation.\n  const numArrows =\n      (equation.length - equation.replace(ARROW_REGEX, '').length) /\n      ARROW.length;\n  if (numArrows < 1) {\n    throw new Error('Equations without an arrow are not supported.');\n  } else if (numArrows > 1) {\n    throw new Error(`Equation must contain exactly one arrow (\"${ARROW}\").`);\n  }\n  const [inputString, outputString] = equation.split(ARROW);\n  assert(\n      inputString.indexOf(ELLIPSIS) === -1,\n      () => `The ellipsis notation (\"${ELLIPSIS}\") is not supported yet.`);\n  const inputTerms = inputString.split(COMMA);\n  const numInputs = inputTerms.length;\n  if (numTensors !== numInputs) {\n    throw new Error(\n        `Expected ${numInputs} input tensors, received ${numTensors}`);\n  }\n  if (numInputs > 2) {\n    throw new Error(\n        'Support for more than 2 input tensors is not implemented yet.');\n  }\n\n  const allDims: string[] = [];\n  for (let i = 0; i < outputString.length; ++i) {\n    const dimName = outputString[i];\n    if (!inputTerms.some(inputTerm => inputTerm.indexOf(dimName) !== -1)) {\n      throw new Error(\n          `Output subscripts contain the label ${dimName} ` +\n          `not present in the input subscripts.`);\n    }\n    if (allDims.indexOf(dimName) === -1) {\n      allDims.push(dimName);\n    }\n  }\n  for (let i = 0; i < inputString.length; ++i) {\n    const dimName = inputString[i];\n    if (allDims.indexOf(dimName) === -1 && dimName !== COMMA) {\n      allDims.push(dimName);\n    }\n  }\n\n  const idDims: number[][] = new Array<number[]>(inputTerms.length);\n  for (let i = 0; i < numInputs; ++i) {\n    if (new Set(inputTerms[i].split('')).size !== inputTerms[i].length) {\n      throw new Error(\n          `Found duplicate axes in input component ${inputTerms[i]}. ` +\n          `Support for duplicate axes in input is not implemented yet.`);\n    }\n    idDims[i] = [];\n    for (let j = 0; j < inputTerms[i].length; ++j) {\n      idDims[i].push(allDims.indexOf(inputTerms[i][j]));\n    }\n  }\n\n  const numDims = allDims.length;          // Number of unique dimensions.\n  const numOutDims = outputString.length;  // Number of output dimensions.\n  const summedDims: number[] = [];         // Dimensions being summed over.\n  for (let i = numOutDims; i < numDims; ++i) {\n    summedDims.push(i);\n  }\n  return {allDims, summedDims, idDims};\n}\n\n/**\n * Get the permutation for a given input tensor.\n *\n * @param nDims Total number of dimension of all tensors involved in the einsum\n *   operation.\n * @param idDims Dimension indices involve in the tensor in question.\n * @returns An object consisting of the following fields:\n *   - permutationIndices: Indices to permute the axes of the tensor with.\n *   - expandDims: Indices to the dimension that need to be expanded from the\n *     tensor after permutation.\n */\nexport function getEinsumPermutation(nDims: number, idDims: number[]):\n    {permutationIndices: number[], expandDims: number[]} {\n  let permutationIndices: number[] = new Array<number>(nDims);\n  permutationIndices.fill(-1);\n  for (let i = 0; i < idDims.length; ++i) {\n    permutationIndices[idDims[i]] = i;\n  }\n  const expandDims: number[] = [];\n  for (let i = 0; i < nDims; ++i) {\n    if (permutationIndices[i] === -1) {\n      expandDims.push(i);\n    }\n  }\n  permutationIndices = permutationIndices.filter(d => d !== -1);\n  return {permutationIndices, expandDims};\n}\n\n/**\n * Checks that the dimension sizes from different input tensors match the\n * equation.\n */\nexport function checkEinsumDimSizes(\n    nDims: number, idDims: number[][], tensors: Tensor[]) {\n  const dimSizes: number[] = new Array<number>(nDims);\n  for (let i = 0; i < tensors.length; ++i) {\n    const shape: number[] = tensors[i].shape;\n    for (let j = 0; j < idDims[i].length; ++j) {\n      if (dimSizes[idDims[i][j]] === undefined) {\n        dimSizes[idDims[i][j]] = shape[j];\n      } else {\n        assert(\n            dimSizes[idDims[i][j]] === shape[j],\n            () => `Expected dimension ${dimSizes[idDims[i][j]]} at axis ${j} ` +\n                `of input shaped ${JSON.stringify(shape)}, ` +\n                `but got dimension ${shape[j]}`);\n      }\n    }\n  }\n}\n\n/**\n * Gets path of computation for einsum.\n *\n * @param summedDims indices to the dimensions being summed over.\n * @param idDims A look up table for the dimensions present in each input\n *     tensor. Each consituent array contains indices for the dimensions in the\n *     corresponding input tensor.\n *\n * @return A map with two fields:\n *   - path: The path of computation, with each element indicating the dimension\n *     being summed over after the element-wise multiplication in that step.\n *   - steps: With the same length as `path`. Each element contains the indices\n *     to the input tensors being used for element-wise multiplication in the\n *     corresponding step.\n */\nexport function getEinsumComputePath(summedDims: number[], idDims: number[][]):\n    {path: number[], steps: number[][]} {\n  const path: number[] = summedDims;\n  const steps: number[][] = [];\n  let nSteps = 0;\n  if (summedDims.length === 0) {\n    // Einsum that involes no summing: e.g., transpose and outer product.\n    path.push(-1);\n  }\n  nSteps = summedDims.length + 1;\n  for (let i = 0; i < nSteps; ++i) {\n    steps.push([]);\n  }\n  const computedTermIndices: number[] = [];\n  for (let i = 0; i < path.length; ++i) {\n    const summedDim = path[i];\n    const termIndices = findTermsWithDim(idDims, summedDim);\n    for (const termIndex of termIndices) {\n      if (computedTermIndices.indexOf(termIndex) === -1) {\n        steps[i].push(termIndex);\n        computedTermIndices.push(termIndex);\n      }\n    }\n  }\n  return {path, steps};\n}\n\n/** Determines if an axes permutation is the identity permutation. */\nexport function isIdentityPermutation(perm: number[]): boolean {\n  return perm.every((dim: number, index: number) => dim === index);\n}\n\nfunction findTermsWithDim(idDims: number[][], dim: number): number[] {\n  const termIndices: number[] = [];\n  for (let i = 0; i < idDims.length; ++i) {\n    if (idDims[i].length === 0 || idDims[i].indexOf(dim) !== -1 || dim === -1) {\n      termIndices.push(i);\n    }\n  }\n  return termIndices;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TensorInfo} from '../kernel_registry';\nimport {Tensor} from '../tensor';\nimport {assert} from '../util';\n\n/**\n * Prepare the split size array. When the input is a number, the axis is evenly\n * divided among the split size. When the input contains the negative value, the\n * rest of the axis is allocated toward that.\n */\nexport function prepareSplitSize(\n    x: Tensor|TensorInfo, numOrSizeSplits: number[]|number,\n    axis = 0): number[] {\n  let splitSizes = [];\n  if (typeof (numOrSizeSplits) === 'number') {\n    assert(\n        x.shape[axis] % numOrSizeSplits === 0,\n        () => 'Number of splits must evenly divide the axis.');\n    splitSizes =\n        new Array(numOrSizeSplits).fill(x.shape[axis] / numOrSizeSplits);\n  } else {\n    const numOfNegs = numOrSizeSplits.reduce((count, value) => {\n      if (value === -1) {\n        count += 1;\n      }\n      return count;\n    }, 0);\n    assert(\n        numOfNegs <= 1,\n        () => 'There should be only one negative value in split array.');\n    const negIndex = numOrSizeSplits.indexOf(-1);\n    // Allow the number of split array to be -1, which indicates the rest\n    // of dimension is allocated to that split.\n    if (negIndex !== -1) {\n      const total = numOrSizeSplits.reduce((a, b) => b > 0 ? a + b : a);\n      numOrSizeSplits[negIndex] = x.shape[axis] - total;\n    }\n    assert(\n        x.shape[axis] === numOrSizeSplits.reduce((a, b) => a + b),\n        () => 'The sum of sizes must match the size of the axis dimension.');\n    splitSizes = numOrSizeSplits;\n  }\n\n  return splitSizes;\n}\n", "/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '../kernel_registry';\nimport {nearestDivisor} from '../util';\n\nimport {PARALLELIZE_THRESHOLD} from './reduce_util';\n\nexport interface SegOpInfo {\n  windowSize: number;\n  batchSize: number;\n  inSize: number;\n  numSegments: number;\n}\n\nexport function segOpComputeOptimalWindowSize(\n    inSize: number, numSegments: number): number {\n  let done = false;\n  let res;\n\n  if (inSize <= PARALLELIZE_THRESHOLD) {\n    res = inSize;\n    done = true;\n  } else {\n    res = nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));\n  }\n\n  while (!done) {\n    if (res > numSegments || res === inSize) {\n      done = true;\n    } else {\n      res = nearestDivisor(inSize, res + 1);\n    }\n  }\n  return res;\n}\n\nexport function computeOutShape(\n    aShape: number[], axis: number, numSegments: number): number[] {\n  const outShape = [];\n  const rank = aShape.length;\n  for (let dim = 0; dim < rank; dim++) {\n    if (dim !== axis) {\n      outShape.push(aShape[dim]);\n    } else {\n      outShape.push(numSegments);\n    }\n  }\n  return outShape;\n}\n\nexport interface GatherOpShapeInfo {\n  batchSize: number;\n  sliceSize: number;\n  outerSize: number;\n  dimSize: number;\n  outputShape: number[];\n}\n\nexport function collectGatherOpShapeInfo(\n    x: TensorInfo, indices: TensorInfo, axis: number,\n    batchDims: number): GatherOpShapeInfo {\n  const indicesRank = indices.shape.length;\n  const xRank = x.shape.length;\n\n  if (batchDims !== 0) {\n    if (batchDims < -indicesRank || batchDims > indicesRank) {\n      throw new Error(`Expect batchDims in the range of [-${indicesRank}, ${\n          indicesRank}], but got ${batchDims}`);\n    }\n  }\n\n  if (batchDims < 0) {\n    batchDims += indicesRank;\n  }\n\n  if (batchDims > xRank) {\n    throw new Error(`batchDims (${batchDims}) must be less than rank(x) (\n    ${xRank}).`);\n  }\n\n  if (axis < batchDims) {\n    throw new Error(`batchDims (${\n        batchDims}) must be less than or equal to axis (${axis}).`);\n  }\n\n  for (let i = 0; i < batchDims; ++i) {\n    if (x.shape[i] !== indices.shape[i]) {\n      throw new Error(\n          `x.shape[${i}]: ${x.shape[i]} should be equal to indices.shape[${\n              i}]: ${indices.shape[i]}.`);\n    }\n  }\n  const dimSize = x.shape[axis];\n\n  const outputShape: number[] = [];\n  let batchSize = 1;\n  let outerSize = 1;\n  let sliceSize = 1;\n\n  for (let i = 0; i < batchDims; ++i) {\n    outputShape.push(x.shape[i]);\n    batchSize *= x.shape[i];\n  }\n\n  for (let i = batchDims; i < axis; i++) {\n    outputShape.push(x.shape[i]);\n    outerSize *= x.shape[i];\n  }\n\n  for (let i = batchDims; i < indicesRank; i++) {\n    outputShape.push(indices.shape[i]);\n  }\n\n  for (let i = axis + 1; i < xRank; i++) {\n    outputShape.push(x.shape[i]);\n    sliceSize *= x.shape[i];\n  }\n\n  return {batchSize, sliceSize, outerSize, dimSize, outputShape};\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport {nonMaxSuppressionV3Impl, nonMaxSuppressionV4Impl, nonMaxSuppressionV5Impl} from './non_max_suppression_impl';\nexport {whereImpl} from './where_impl';\n", "/**\n * @license\n * Copyright 2020 Google Inc. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// base.ts is tfjs-core without auto registration of things like flags,\n// gradients, chained ops or the opHandler. See base_side_effects.ts for parts\n// tfjs core that are required side effects.\n\n/**\n * @fileoverview\n * @suppress {partialAlias} Optimization disabled due to passing the module\n * object into a function below:\n *\n *   import * as ops from './ops/ops';\n *   setOpHandler(ops);\n */\n\n// Serialization.\nimport * as io from './io/io';\nimport * as math from './math';\nimport * as browser from './ops/browser';\nimport * as gather_util from './ops/gather_nd_util';\nimport * as scatter_util from './ops/scatter_nd_util';\nimport * as slice_util from './ops/slice_util';\nimport * as serialization from './serialization';\nimport * as tensor_util from './tensor_util';\nimport * as test_util from './test_util';\nimport * as util from './util';\nimport {version} from './version';\n\nexport {InferenceModel, MetaGraph, MetaGraphInfo, ModelPredictConfig, ModelTensorInfo, SavedModelTensorInfo, SignatureDef, SignatureDefEntry, SignatureDefInfo} from './model_types';\n// Optimizers.\nexport {AdadeltaOptimizer} from './optimizers/adadelta_optimizer';\nexport {AdagradOptimizer} from './optimizers/adagrad_optimizer';\nexport {AdamOptimizer} from './optimizers/adam_optimizer';\nexport {AdamaxOptimizer} from './optimizers/adamax_optimizer';\nexport {MomentumOptimizer} from './optimizers/momentum_optimizer';\nexport {Optimizer} from './optimizers/optimizer';\nexport {RMSPropOptimizer} from './optimizers/rmsprop_optimizer';\nexport {SGDOptimizer} from './optimizers/sgd_optimizer';\nexport {Scalar, Tensor, Tensor1D, Tensor2D, Tensor3D, Tensor4D, Tensor5D, TensorBuffer, Variable} from './tensor';\nexport {GradSaveFunc, NamedTensorMap, TensorContainer, TensorContainerArray, TensorContainerObject} from './tensor_types';\nexport {BackendValues, DataType, DataTypeMap, DataValues, NumericDataType, PixelData, Rank, RecursiveArray, ScalarLike, ShapeMap, sumOutType, TensorLike, TypedArray, upcastType} from './types';\n\nexport * from './ops/ops';\nexport {Reduction} from './ops/loss_ops_utils';\n\nexport * from './train';\nexport * from './globals';\nexport * from './kernel_registry';\nexport {customGrad, grad, grads, valueAndGrad, valueAndGrads, variableGrads} from './gradients';\n\nexport {TimingInfo, MemoryInfo, ForwardFunc} from './engine';\nexport {Environment, env, ENV} from './environment';\nexport {Platform} from './platforms/platform';\n\nexport {version as version_core};\n\n// Top-level method exports.\nexport {nextFrame} from './browser_util';\n\n// Second level exports.\nimport * as backend_util from './backends/backend_util';\nimport * as device_util from './device_util';\nexport {\n  browser,\n  io,\n  math,\n  serialization,\n  test_util,\n  util,\n  backend_util,\n  tensor_util,\n  slice_util,\n  gather_util,\n  scatter_util,\n  device_util\n};\n\nimport * as kernel_impls from './backends/kernel_impls';\nexport {kernel_impls};\n// Backend specific.\nexport {KernelBackend, BackendTimingInfo, DataMover, DataStorage} from './backends/backend';\n\n// Export all kernel names / info.\nexport * from './kernel_names';\n", "/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Required side effectful code.\nimport './base_side_effects';\n// All exports from this package should be in base.\nexport * from './base';\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env} from '@tensorflow/tfjs-core';\n\nconst ENV = env();\n\n/** The batched command encoders size in the device queue. */\nENV.registerFlag('WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE', () => 15);\n\n/**\n * Whether we forward execution to the CPU backend if tensors are small and\n * reside on the CPU.\n */\nENV.registerFlag('WEBGPU_CPU_FORWARD', () => true);\n\n/**\n * Thread register block size for matmul kernel.\n */\nENV.registerFlag('WEBGPU_MATMUL_WORK_PER_THREAD', () => 4);\n\n/**\n * Whether to use conv2d_naive which directly implement the conv2d logic rather\n * than using a matmul to simulate.\n */\nENV.registerFlag('WEBGPU_USE_NAIVE_CONV2D', () => false);\n\n/**\n * Whether to use GLSL shading language.\n */\nENV.registerFlag('WEBGPU_USE_GLSL', () => true);\n\n/**\n * Whether to use conv2dTranspose_naive which directly implement the\n * conv2dTranspose logic rather than using a matmul to simulate.\n */\nENV.registerFlag('WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE', () => false);\n\n/**\n * Whether we will run im2col as a separate shader for convolution.\n */\nENV.registerFlag('WEBGPU_CONV_SEPARATE_IM2COL_SHADER', () => false);\n\n/**\n * Whether we use low power GPU. Otherwise, a high performance GPU will be\n * requested.\n */\nENV.registerFlag('WEBGPU_USE_LOW_POWER_GPU', () => false);\n\n/**\n * Threshold for input tensor size that determines whether WebGPU backend will\n * delegate computation to CPU.\n *\n * Default value is 128.\n */\nENV.registerFlag('CPU_HANDOFF_SIZE_THRESHOLD', () => 128);\n\n/**\n * Whether to use a dummy canvas to make profiling tools like PIX work with\n * TFJS webgpu backend.\n */\nENV.registerFlag('WEBGPU_USE_PROFILE_TOOL', () => false);\n\n/**\n * Whether to use import API.\n */\nENV.registerFlag('WEBGPU_USE_IMPORT', () => false);\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Generates GLSL that computes strides.\nexport function symbolicallyComputeStrides(\n    indicesArr: number[], variableName: string): string[] {\n  if (Math.max(...indicesArr) > 3) {\n    throw new Error('Cannot symbolically compute strides for rank > 4 tensor.');\n  }\n\n  const numCoords = indicesArr.length;\n  const shape = indicesArr.map(d => `${variableName}[${d}]`);\n  const strides = new Array(numCoords - 1);\n  strides[numCoords - 2] = shape[numCoords - 1];\n  for (let i = numCoords - 3; i >= 0; --i) {\n    strides[i] = `(${strides[i + 1]} * ${shape[i + 1]})`;\n  }\n\n  return strides;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, util} from '@tensorflow/tfjs-core';\nimport {symbolicallyComputeStrides} from './shader_util';\n\nexport function getCoordsDataTypeWgsl(rank: number): string {\n  if (rank <= 1) {\n    return 'u32';\n  } else if (rank === 2) {\n    return 'vec2<u32>';\n  } else if (rank === 3) {\n    return 'vec3<u32>';\n  } else if (rank === 4) {\n    return 'vec4<u32>';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\ntype DataTypeWGSL = 'f32'|'i32'|'vec4<f32>'|'vec4<i32>'|'vec4<bool>';\nfunction mapToTypesWgsl(type: DataType, isVec4: boolean): DataTypeWGSL|\n    DataType {\n  if (type === 'float32') {\n    return isVec4 ? 'vec4<f32>' : 'f32';\n  } else if (type === 'int32') {\n    return isVec4 ? 'vec4<i32>' : 'i32';\n  } else if (type === 'bool') {\n    // Type 'bool' cannot be used in storage class,\n    // https://www.w3.org/TR/WGSL/#host-shareable-types.\n    return isVec4 ? 'vec4<i32>' : 'i32';\n  }\n\n  return type;\n}\n\ninterface ProgramParams {\n  dispatchLayout: {x: number[], y?: number[], z?: number[]};\n  workGroupSize: [number, number, number];\n  variableNames: string[];\n  uniforms?: string;\n  uniformsWgsl?: string;\n  isVec4?: boolean;\n  size?: number;\n  getUserCode: () => string;\n  getUserCodeWgsl?: () => string;\n}\n\nexport interface InputInfo {\n  dtype: DataType;\n  shape: number[];\n  name: string;\n}\n\nexport function getWorkGroupSizeStringWgsl(): string {\n  return `\n  [[stage(compute), workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)]]\n`;\n}\n\nexport function getGlobalIndexStringWgsl(): string {\n  return `\n  let index = getGlobalIndex(globalId, localId);\n`;\n}\n\nexport function getMainHeaderStringWgsl() {\n  return `\n  [[stage(compute), workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)]]\n  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>, [[builtin(global_invocation_id)]] globalId : vec3<u32>)\n`;\n}\n\nexport function makeShader(\n    inputInfo: InputInfo[], outputData: {dtype: DataType, shape: number[]},\n    program: ProgramParams, isFromPixel = false): string {\n  const workGroupSizeSnippet = `\n    let workGroupSizeX = ${program.workGroupSize[0]}u;\n    let workGroupSizeY = ${program.workGroupSize[1]}u;\n    let workGroupSizeZ = ${program.workGroupSize[2]}u;`;\n\n  if (isFromPixel === true) {\n    const getCoords = generateGetCoordsFromFlatIndex(outputData.shape);\n    const outputBufferStr = `\n      [[block]] struct Matrix0 {\n        numbers: array<${mapToTypesWgsl(outputData.dtype, program.isVec4)}>;\n      };\n      [[block]] struct Uniform {\n        size            : u32;\n        numChannels     : u32;\n        outShapeStrides : vec2<u32>;\n        dispatchSize    : vec3<u32>;\n      };\n\n      [[group(0), binding(0)]] var<storage, write> result : Matrix0;\n      [[group(0), binding(2)]] var<uniform> uniforms: Uniform;\n    `;\n    return [\n      SHADER_PREFIX,\n      outputBufferStr,\n      workGroupSizeSnippet,\n      SAMPLING_SNIPPETS,\n      getCoords,\n      program.getUserCodeWgsl(),\n    ].join('\\n');\n  }\n\n  const prefixSnippets: string[] = [];\n  let uniformDeclaration = '[[block]] struct Uniforms { NAN : f32; ';\n  program.variableNames.forEach((x, i) => {\n    uniformDeclaration += `${x.charAt(0).toLowerCase() + x.slice(1)}Shape : ${\n        getCoordsDataTypeWgsl(inputInfo[i].shape.length)}; `;\n  });\n  uniformDeclaration +=\n      `outShape : ${getCoordsDataTypeWgsl(outputData.shape.length)} ; `;\n  const stridesLength = outputData.shape.length - 1;\n  uniformDeclaration += `\n       outShapeStrides: ${getCoordsDataTypeWgsl(stridesLength)}; `;\n\n  if (program.size != null) {\n    uniformDeclaration += 'size : u32; ';\n  }\n  uniformDeclaration += 'dispatchSize : vec3<u32>; ';\n  if (program.uniformsWgsl) {\n    uniformDeclaration += program.uniformsWgsl;\n  }\n  uniformDeclaration += '};';\n\n  prefixSnippets.push(uniformDeclaration);\n\n  // Output buffer.\n  prefixSnippets.push(`\n    [[block]] struct Matrix0 {\n        numbers: array<${mapToTypesWgsl(outputData.dtype, program.isVec4)}>;\n    };\n\n    [[group(0), binding(0)]] var<storage, write> result : Matrix0;\n  `);\n  program.variableNames.forEach((x, i) => {\n    prefixSnippets.push(`\n    [[block]] struct Matrix${1 + i} {\n      numbers: array<${mapToTypesWgsl(inputInfo[i].dtype, program.isVec4)}>;\n    };\n    [[group(0), binding(${1 + i})]] var<storage, read> ${x} : Matrix${1 + i};\n    `);\n  });\n\n  if (uniformDeclaration !== '') {\n    prefixSnippets.push(`\n    [[group(0), binding(${\n        1 + program.variableNames.length})]] var<uniform> uniforms : Uniforms;\n    `);\n  }\n\n  prefixSnippets.push(workGroupSizeSnippet);\n\n  const [getOutputCoords, dispatchLayoutRank] =\n      generateGetOutputCoords(outputData.shape, program.dispatchLayout);\n  const getCoords = generateGetCoordsFromFlatIndex(outputData.shape);\n\n  const sources = [\n    SHADER_PREFIX, prefixSnippets.join('\\n'), SAMPLING_SNIPPETS, getCoords,\n    getOutputCoords,\n    getSetOutputSnippet(outputData.shape, outputData.dtype, program.isVec4)\n  ];\n  if (dispatchLayoutRank === outputData.shape.length) {\n    // Input sampling snippet is only meaningful when the output isn't getting\n    // implicitly reshaped (like it does in conv2d_matmul).\n    const inputSamplingSnippet =\n        inputInfo\n            .map(\n                x => getInputSamplingSnippet(\n                    x, outputData.shape, program.isVec4,\n                    program.dispatchLayout.x.length ===\n                        outputData.shape.length))\n            .join('\\n');\n    sources.push(inputSamplingSnippet);\n  }\n\n  sources.push(program.getUserCodeWgsl());\n  const source = sources.join('\\n');\n  return source;\n}\n\nconst SHADER_PREFIX = `\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let mod: i32 = a % b;\n    if (sign < 0. && mod != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // The GLSL mod and WGSL '%' are defined differently.\n  // GLSL mod returns the value of x modulo y. This is computed as x - y * floor(x/y).\n  // WGSL '%' is floating point remainder, where sign of non-zero result matches sign of e1.\n  // Component-wise when T is a vector. Result equals to: e1 - e2 * trunc(e1 / e2).\n  // The below mod and modVec4 can be used as alternatives to GLSL's mod, not WGSL's '%'.\n  fn mod(a : f32, b : f32) -> f32 {\n    return a - b * floor(a/b);\n  }\n\n  fn modVec4(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n    return a - b * floor(a/b);\n  }\n\n  fn isNanCustom(val : f32) -> bool {\n    if (val > 0.0) {\n      return false;\n    }\n    if (val < 0.0) {\n      return false;\n    }\n    if (val == 0.0) {\n      return false;\n    }\n    return true;\n  }\n\n  fn isNanCustomVec4F32(val : vec4<f32>) -> vec4<f32> {\n    var res = vec4<f32> (0.0);\n    for (var i = 0u; i < 4u; i = i + 1u) {\n      if (isNanCustom(val[i])) {\n        res[i] = 1.0;\n      } else {\n        res[i] = 0.0;\n      }\n    }\n    return res;\n  }\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds4D(coord : vec4<u32>, shape : vec4<u32>) -> bool {\n    return all(coord < shape);\n  }\n\n  fn coordsInBounds3D(coord : vec3<u32>, shape : vec3<u32>) -> bool {\n    return all(coord < shape);\n  }\n\n  fn coordsInBounds2D(coord : vec2<u32>, shape : vec2<u32>) -> bool {\n    return all(coord < shape);\n  }\n  `;\nconst SAMPLING_SNIPPETS = `\n  fn getFlatIndex1D(coord : u32, shape : u32) -> u32 {\n    return coord;\n  }\n\n  fn getFlatIndex2D(coords : vec2<u32>, shape : vec2<u32>) -> u32 {\n    return u32(dot(vec2<f32>(coords), vec2<f32>(f32(shape.y), 1.0)));\n  }\n\n  fn getFlatIndex3D(coords : vec3<u32>, shape : vec3<u32>) -> u32 {\n    return u32(dot(vec3<f32>(coords), vec3<f32>(f32(shape.y) * f32(shape.z), f32(shape.z), 1.0)));\n  }\n\n  fn getFlatIndex4D(coords : vec4<u32>, shape : vec4<u32>) -> u32 {\n    return u32(dot(vec4<f32>(coords), vec4<f32>(\n        f32(shape.y) * f32(shape.z) * f32(shape.w), f32(shape.z) * f32(shape.w), f32(shape.w), 1.0)));\n  }\n\n  // Only used when the y/z dimension of workgroup size is 1.\n  fn getGlobalIndex(globalId : vec3<u32>, localId : vec3<u32>) -> u32 {\n    if (uniforms.dispatchSize.y == 1u && uniforms.dispatchSize.z == 1u) {\n      return globalId.x;\n    }\n    let localInvocationIndex = localId.z * workGroupSizeX * workGroupSizeY +\n      localId.y * workGroupSizeX + localId.x;\n    let workGroupID = (globalId - localId)/vec3<u32>(\n      workGroupSizeX, workGroupSizeY, workGroupSizeZ);\n    return (workGroupID.z * uniforms.dispatchSize.x * uniforms.dispatchSize.y +\n      workGroupID.y * uniforms.dispatchSize.x + workGroupID.x) *\n      (workGroupSizeX * workGroupSizeY * workGroupSizeZ) +\n      localInvocationIndex;\n  }\n`;\n\nfunction getSetOutputSnippet(\n    outShape: number[], outBufferType: DataType, isVec4: boolean): string {\n  const outRank = outShape.length;\n  const wgslType = mapToTypesWgsl(outBufferType, isVec4);\n  let snippet;\n  if (isVec4) {\n    snippet = `fn setOutputFlat(flatIndex : u32, value : vec4<f32>) {\n      result.numbers[flatIndex] = ${wgslType}(value);\n    }\n    fn setOutputFlatI32(flatIndex : u32, value : vec4<i32>) {\n      result.numbers[flatIndex] = ${wgslType}(value);\n    }`;\n  } else {\n    snippet = `fn setOutputFlat(flatIndex : u32, value : f32) {\n      result.numbers[flatIndex] = ${wgslType}(value);\n    }\n    fn setOutputFlatI32(flatIndex : u32, value : i32) {\n      result.numbers[flatIndex] = ${wgslType}(value);\n    }`;\n  }\n\n  if (outRank >= 2) {\n    switch (outRank) {\n      case 2:\n        snippet += `\n        fn getOutputFlatIndex(coords : vec2<u32>) -> u32 {\n          return u32(dot(vec2<f32>(coords), vec2<f32>(f32(uniforms.outShapeStrides), 1.0)));\n        }\n        `;\n        break;\n      case 3:\n        snippet += `\n        fn getOutputFlatIndex(coords : vec3<u32>) -> u32 {\n          return u32(dot(vec3<f32>(coords), vec3<f32>(f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), 1.0)));\n        }\n        `;\n        break;\n      case 4:\n        snippet += `\n        fn getOutputFlatIndex(coords : vec4<u32>) -> u32 {\n          return u32(dot(vec4<f32>(coords), vec4<f32>(\n            f32(uniforms.outShapeStrides.x), f32(uniforms.outShapeStrides.y), f32(uniforms.outShapeStrides.z), 1.0)));\n        }\n        `;\n        break;\n      default:\n        util.assert(false, () => `Unsupported ${outRank}D shape`);\n        break;\n    }\n    const dims = ['d0', 'd1', 'd2', 'd3'].slice(0, outRank);\n    const type = getCoordsDataTypeWgsl(outRank);\n\n    if (isVec4) {\n      snippet += `\n      fn setOutput(${\n          dims.map(d => `${d} : u32`).join(', ')}, value : vec4<f32>) {\n        let flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutputFlat(flatIndex / 4u, value);\n      }\n      fn setOutputVectorI32(${\n          dims.map(d => `${d} : u32`).join(', ')}, value : vec4<i32>) {\n        let flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutputFlatI32(flatIndex / 4u, value);\n      }\n    `;\n    } else {\n      snippet += `\n      fn setOutput(${dims.map(d => `${d} : u32`).join(', ')}, value : f32) {\n        let flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutputFlat(flatIndex, value);\n      }\n      fn setOutputI32(${dims.map(d => `${d} : u32`).join(', ')}, value : i32) {\n        let flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutputFlatI32(flatIndex, value);\n      }\n    `;\n    }\n  }\n\n  return snippet;\n}\n\nfunction getInputSamplingSnippet(\n    inInfo: InputInfo, outShape: number[], isVec4: boolean,\n    isFlatDispatchLayout: boolean): string {\n  let res = getSamplerFromInInfo(inInfo, isVec4);\n\n  const inShape = inInfo.shape;\n  if (inShape.length <= outShape.length) {\n    res += getSamplerAtOutputCoords(\n        inInfo, outShape, isVec4, isFlatDispatchLayout);\n  }\n\n  return res;\n}\n\nfunction getSamplerFromInInfo(inInfo: InputInfo, isVec4: boolean): string {\n  const texName = inInfo.name;\n  const rank = inInfo.shape.length;\n  const type = getCoordsDataTypeWgsl(rank);\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const dims = ['d0', 'd1', 'd2', 'd3'].slice(0, rank);\n  const inputs = dims.map(d => `${d} : u32`).join(', ');\n\n  if (rank < 1) {\n    if (isVec4) {\n      return `\n        fn ${funcName}() -> vec4<f32> {\n          return vec4<f32>(${texName}.numbers[0]);\n        }\n      `;\n    }\n\n    return `\n      fn ${funcName}() ->f32 {\n        return f32(${texName}.numbers[0]);\n      }\n    `;\n  }\n\n  const shapeStr =\n      `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  let rankStr = `${rank}D`;\n  if (rank === 0) {\n    rankStr = '1D';\n  }\n\n  if (isVec4) {\n    return `\n      fn ${funcName}(${inputs}) -> vec4<f32> {\n        return vec4<f32>(${texName}.numbers[getFlatIndex${rankStr}(${type}(${\n        dims.join(',')}),\n          ${shapeStr}) / 4u]);\n      }\n      `;\n  }\n\n  return `\n    fn ${funcName}(${inputs}) -> f32 {\n      return f32(${texName}.numbers[getFlatIndex${rankStr}(${type}(${\n      dims.join(',')}),\n        ${shapeStr})]);\n    }\n   `;\n}\n// TODO: Implement getXXXFromFlatIndex, use it instead of getXXXAtOutCoords when\n// it's flat dispatch layout.\nexport function getSamplerAtOutputCoords(\n    inInfo: InputInfo, outShape: number[], isVec4: boolean,\n    isFlatDispatchLayout: boolean): string {\n  const texName = inInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n\n  const inRank = inInfo.shape.length;\n  const outRank = outShape.length;\n  const type = getCoordsDataTypeWgsl(outRank);\n\n  // If the inShape equals the outShape and the dispatch layout is flat, we can\n  // directly use |gl_GlobalInvocationID.x| as the index and don't need coords\n  // conversion between these two shapes.\n  if (util.arraysEqual(inInfo.shape, outShape) && isFlatDispatchLayout) {\n    if (isVec4) {\n      return `\n        fn ${\n          funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : u32) -> vec4<f32> {\n          return vec4<f32>(${texName}.numbers[globalIndex]);\n        }\n\n        fn ${funcName}ByCoords(coords : ${type}) -> vec4<f32> {\n          return vec4<f32>(${texName}.numbers[${\n          outRank > 1 ? 'getOutputFlatIndex(coords)' : 'coords'} / 4u]);\n        }\n        `;\n    } else {\n      return `\n      fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : u32) -> f32 {\n        return f32(${texName}.numbers[globalIndex]);\n      }\n\n      fn ${funcName}ByCoords(coords : ${type}) -> f32 {\n        return f32(${texName}.numbers[${\n          outRank > 1 ? 'getOutputFlatIndex(coords)' : 'coords'}]);\n      }\n      `;\n    }\n  }\n\n  const broadcastDims = backend_util.getBroadcastDims(inInfo.shape, outShape);\n  const rankDiff = outRank - inRank;\n\n  let coordsSnippet = '';\n\n  if (inRank === 0) {\n    if (isVec4) {\n      return `\n      fn ${\n          funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : u32) -> vec4<f32> {\n        return get${texFuncSnippet}();\n      }\n\n      fn ${funcName}ByCoords(coords : ${type}) -> vec4<f32> {\n        return get${texFuncSnippet}();\n      }\n    `;\n    }\n    return `\n      fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : u32) -> f32{\n        return get${texFuncSnippet}();\n      }\n\n      fn ${funcName}ByCoords(coords : ${type}) -> f32{\n        return get${texFuncSnippet}();\n      }\n    `;\n  } else {\n    if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0u;';\n    } else {\n      coordsSnippet =\n          broadcastDims.map(d => `coords[${d + rankDiff}u] = 0u;`).join('\\n');\n    }\n  }\n\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    if (outRank > 1) {\n      const coordsType = getCoordsDataTypeWgsl(inRank);\n      const coordsValues =\n          inInfo.shape.map((s, i) => `coords[${i + rankDiff}u]`).join(', ');\n      unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;\n    } else {\n      unpackedCoordsSnippet = 'coords';\n    }\n  }\n\n  const shapeStr =\n      `uniforms.${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n  const rankStr = `${inRank}D`;\n  if (isVec4) {\n    return `\n      fn ${\n        funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : u32) -> vec4<f32> {\n        var coords = getOutputCoords(globalId, globalIndex);\n        ${coordsSnippet}\n        return ${texName}.numbers[getFlatIndex${rankStr}(${\n        unpackedCoordsSnippet}, ${shapeStr}) / 4u];\n      }\n\n      fn ${funcName}ByCoords(coordsIn : ${type}) -> vec4<f32> {\n        var coords = coordsIn;\n        ${coordsSnippet}\n        return ${texName}.numbers[getFlatIndex${rankStr}(${\n        unpackedCoordsSnippet}, ${shapeStr}) / 4u];\n      }\n    `;\n  }\n\n  return `\n    fn ${funcName}ByGlobalId(globalId : vec3<u32>, globalIndex : u32) -> f32 {\n      var coords = getOutputCoords(globalId, globalIndex);\n      ${coordsSnippet}\n      return f32(${texName}.numbers[getFlatIndex${rankStr}(${\n      unpackedCoordsSnippet}, ${shapeStr})]);\n    }\n\n    fn ${funcName}ByCoords(coordsIn : ${type}) -> f32 {\n      var coords = coordsIn;\n      ${coordsSnippet}\n      return f32(${texName}.numbers[getFlatIndex${rankStr}(${\n      unpackedCoordsSnippet}, ${shapeStr})]);\n    }\n  `;\n}\n\n/**\n * Generates getOutputCoords() function that computes output coordinates from\n * dispatch geometry to reduce arithmetic.\n */\nexport function generateGetOutputCoords(\n    outShape: number[],\n    dispatchLayout: {x: number[], y?: number[], z?: number[]}):\n    [string, number] {\n  const {x, y = [], z = []} = dispatchLayout;\n\n  const outRank = outShape.length;\n  if (x.length === outRank) {\n    const dtype = getCoordsDataTypeWgsl(outRank);\n    const snippet =\n        `fn getOutputCoords(globalId : vec3<u32>, globalIndex : u32) -> ${\n            dtype}{\n      return getCoordsFromFlatIndex(u32(globalIndex));\n    }\n    `;\n    return [snippet, outRank];\n  }\n\n  let gatherDimensionsStr = '';\n  const dims = [x, y, z];\n\n  let rank = 0;\n\n  for (let i = 0; i < dims.length; i++) {\n    const arr = dims[i];\n\n    if (arr.length === 0) {\n      continue;\n    }\n\n    rank += arr.length;\n\n    if (arr.length === 1) {\n      gatherDimensionsStr += `let d${arr[0]} = globalId[${i}];`;\n    } else {\n      const strides = symbolicallyComputeStrides(arr, 'uniforms.outShape');\n      gatherDimensionsStr += `var index${i} = globalId[${i}];`;\n      for (let j = 0; j < strides.length; j++) {\n        gatherDimensionsStr += `let d${arr[j]} = index${i} / ${strides[j]};`;\n\n        if (j === strides.length - 1) {\n          gatherDimensionsStr += `let d${arr[j + 1]} = ` +\n              `index${i} - d${arr[j]} * ${strides[j]};`;\n        } else {\n          gatherDimensionsStr +=\n              `index${i} = index${i} - d${arr[j]} * ${strides[j]};`;\n        }\n      }\n    }\n  }\n\n  const dimensions = [];\n  for (let i = 0; i < rank; i++) {\n    dimensions.push(`d${i}`);\n  }\n\n  const dtype = getCoordsDataTypeWgsl(rank);\n  let snippet =\n      `fn getOutputCoords(globalId : vec3<u32>, globalIndex : u32) -> ${dtype} {\n    ${gatherDimensionsStr}\n  `;\n  if (dimensions.length === 0) {\n    snippet += `return ${dtype}(0); }`;\n  } else {\n    snippet += `return ${dtype}(${dimensions.join(',')}); }`;\n  }\n\n  return [snippet, rank];\n}\n\n/**\n * Derives logical coordinates from a flat index. Performs integer division\n * with each stride and decrements the index until the index equals the final\n * dimension coordinate.\n */\nfunction generateGetCoordsFromFlatIndex(shape: number[]): string {\n  const rank = shape.length;\n\n  if (rank <= 1) {\n    return `fn getCoordsFromFlatIndex(index : u32) -> u32 { return index; }`;\n  }\n\n  const strides = util.computeStrides(shape);\n  const dtype = getCoordsDataTypeWgsl(rank);\n\n  const coords: string[] = [];\n  for (let i = 0; i < rank; i++) {\n    coords.push(`d${i}`);\n  }\n\n  if (strides.length === 1) {\n    return `    fn getCoordsFromFlatIndex(index : u32) -> vec2<u32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<u32>(d0, d1);\n    }`;\n  }\n  const snippet = 'var index2 = index;' +\n      strides\n          .map((_, i) => {\n            const line1 =\n                `let ${coords[i]} = index2 / uniforms.outShapeStrides[${i}]`;\n            const line2 = i === strides.length - 1 ?\n                `let ${coords[i + 1]} = index2 - ${\n                    coords[i]} * uniforms.outShapeStrides[${i}]` :\n                `index2 = index2 - ${coords[i]} * uniforms.outShapeStrides[${\n                    i}]`;\n            return `${line1}; ${line2};`;\n          })\n          .join('');\n\n  return `\n    fn getCoordsFromFlatIndex(index : u32) -> ${dtype} {\n      ${snippet}\n      return ${dtype}(${coords.join(',')});\n    }\n  `;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {DataType, util} from '@tensorflow/tfjs-core';\n\nimport {MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE} from './constants';\n\nconst arrayProduct = (arr: number[]) => {\n  let product = 1;\n  for (let i = 0; i < arr.length; i++) {\n    product *= arr[i];\n  }\n  return product;\n};\n\nexport function tilesFitEvenlyIntoShape(\n    tileSize: number[], shape: number[]): boolean {\n  if (tileSize.length !== shape.length) {\n    throw new Error(\n        `Cannot compute whether rank ${tileSize.length}` +\n        ` tiles fit evenly into rank ${shape.length} shape` +\n        ` - ranks must match.`);\n  }\n  return shape.every(\n      (dim: number, dimIdx: number) => dim % tileSize[dimIdx] === 0);\n}\n\n// Computes dispatch geometry based on layout of output dimensions and\n// workGroupSize.\nexport function computeDispatch(\n    layout: {x: number[], y?: number[], z?: number[]}, outputShape: number[],\n    workGroupSize: [number, number, number] = [1, 1, 1],\n    elementsPerThread: [number, number, number] =\n        [1, 1, 1]): [number, number, number] {\n  const [dispatchX, dispatchY, dispatchZ] = [\n    Math.ceil(\n        arrayProduct(layout.x.map(d => outputShape[d])) /\n        (workGroupSize[0] * elementsPerThread[0])),\n    layout.y ? Math.ceil(\n                   arrayProduct(layout.y.map(d => outputShape[d])) /\n                   (workGroupSize[1] * elementsPerThread[1])) :\n               1,\n    layout.z ? Math.ceil(\n                   arrayProduct(layout.z.map(d => outputShape[d])) /\n                   (workGroupSize[2] * elementsPerThread[2])) :\n               1\n  ];\n\n  if (dispatchX <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE &&\n      dispatchY <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE &&\n      dispatchZ <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE) {\n    return [dispatchX, dispatchY, dispatchZ];\n  }\n\n  util.assert(dispatchX > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE &&\n      layout.y === undefined && layout.z === undefined, () =>\n      'Dispatch size exceeds WebGPU limits in Y or Z dimension.');\n\n  let dispatchAverage = Math.ceil(Math.sqrt(dispatchX));\n  if (dispatchAverage > MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE) {\n    dispatchAverage = Math.ceil(Math.cbrt(dispatchX));\n    util.assert(dispatchAverage <= MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE,\n        () => 'Total dispatch size exceeds WebGPU maximum.');\n    return [dispatchAverage, dispatchAverage, dispatchAverage];\n  } else {\n    return [dispatchAverage, dispatchAverage, 1];\n  }\n}\n\nexport function computeWorkGroupSizeForConv2d(\n    layout: {x: number[], y?: number[], z?: number[]},\n    outputShape: number[]): [number, number, number] {\n  const dim0 = arrayProduct(layout.x.map(d => outputShape[d]));\n  const dim1 = arrayProduct(layout.y.map(d => outputShape[d]));\n  // TODO(jiajia.qin@intel.com): More fine tune based on outputShape.\n  // These are experimental values. Usually, we need to adjust the work group\n  // size based on the output shape. For example, when one dimension is smaller\n  // than 4, it will be wasteful if we assign a larger size for this dimension,\n  // which results lots of threads doing useless work and reduces parallelism\n  // of hardware threads. But it is always a balance between work group size\n  // and shared memory. If one dimension is too small, such as 1, shared memory\n  // will won't be fully utilized.\n  if (dim0 <= 4) {\n    return [4, 16, 1];\n  }\n  if (dim1 <= 4) {\n    return [16, 4, 1];\n  }\n\n  return [16, 16, 1];\n}\n\nexport function computeWorkGroupSizeForMatMul(\n    dimAOuter: number, dimInner: number,\n    dimBOuter: number): [number, number, number] {\n  // These are experimental values. Usually, we need to adjust the work group\n  // size based on the input shapes to improve the EU occupancy.\n  // TODO: WebGPU limits the maximum allowed shared memory size as 16K. To make\n  // sure it doesn't exceed this limitations. Temporarily reduce the work group\n  // size to [8, 8, 1] and the work per thread size is [4, 4, 1]. But we should\n  // revisit it and find the balance between work group size and work per thread\n  // size.\n  if (dimAOuter === 1) {\n    return [32, 1, 1];\n  } else if (dimBOuter === 1) {\n    return [1, 32, 1];\n  }\n\n  return [8, 8, 1];\n}\n\nexport function computeWorkPerThreadForConv2d(\n    layout: {x: number[], y?: number[], z?: number[]},\n    outputShape: number[]): [number, number, number] {\n  const dim0 = arrayProduct(layout.x.map(d => outputShape[d]));\n  const dim1 = arrayProduct(layout.y.map(d => outputShape[d]));\n  // TODO(jiajia.qin@intel.com): More fine tune based on outputShape.\n  // The following conditions correspond to the values set in\n  // computeWorkGroupSizeForConv2d.\n  if (dim0 <= 4) {\n    return [1, 2, 1];\n  }\n  if (dim1 <= 4) {\n    return [2, 1, 1];\n  }\n\n  return [2, 2, 1];\n}\n\nexport function flatDispatchLayout(shape: number[]) {\n  return {x: shape.map((d, i) => i)};\n}\n\nexport function GPUBytesPerElement(dtype: DataType): number {\n  if (dtype === 'float32' || dtype === 'int32' || dtype === 'bool' ||\n      dtype === 'string') {\n    return 4;\n  } else if (dtype === 'complex64') {\n    return 8;\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n\nexport function ArrayBufferToTypedArray(data: ArrayBuffer, dtype: DataType) {\n  if (dtype === 'float32') {\n    return new Float32Array(data);\n  } else if (dtype === 'int32') {\n    return new Int32Array(data);\n  } else if (dtype === 'bool' || dtype === 'string') {\n    const dataAsInt32Array = new Int32Array(data);\n    const boolData = new ArrayBuffer(dataAsInt32Array.length);\n    const dataAsTypedArray = new Uint8Array(boolData);\n    for (let i = 0; i < dataAsInt32Array.length; i++) {\n      dataAsTypedArray[i] = dataAsInt32Array[i];\n    }\n    return dataAsTypedArray;\n  } else {\n    throw new Error(`Unknown dtype ${dtype}`);\n  }\n}\n\nexport function isWebGPUSupported(): boolean {\n  if (!navigator.gpu) {\n    return false;\n  }\n  return true;\n}\n\nexport interface WebGPULayout {\n  bindGroupLayout: GPUBindGroupLayout;\n  pipelineLayout: GPUPipelineLayout;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport const MAX_COMPUTE_WORKGROUP_INVOCATIONS = 256;\n\nexport const MAX_COMPUTE_PER_DIMENSION_DISPATCH_SIZE = 65535;\n\nexport const MAX_COMPUTE_WORKGROUP_SIZE_X = 256;\n\nexport const MAX_COMPUTE_WORKGROUP_SIZE_Y = 256;\n\nexport const MAX_COMPUTE_WORKGROUP_SIZE_Z = 256;\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum BinaryOpType {\n  MUL,\n  ADD,\n  SUB,\n  DIV,\n  EQUAL,\n  GREATER,\n  GREATER_EQUAL,\n  LESS,\n  LESS_EQUAL,\n  LOGICAL_AND,\n  NOT_EQUAL,\n  SQUARED_DIFFERENCE,\n  INT_DIV,\n  POW,\n  PRELU,\n  MAX,\n  MIN,\n  COMPLEX_MULTIPLY_REAL,\n  COMPLEX_MULTIPLY_IMAG\n}\n\n// GLSL shader.\nconst CHECK_NAN_SNIPPET = `\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n  `;\nconst CHECK_NAN_SNIPPET_VEC4 = `\n  result.r = isNaN.r > 0. ? NAN : result.r;\n  result.g = isNaN.g > 0. ? NAN : result.g;\n  result.b = isNaN.b > 0. ? NAN : result.b;\n  result.a = isNaN.a > 0. ? NAN : result.a;\n  `;\n\nconst ADD = 'return a + b;';\n// (Ar + Ai)(Br + Bi) =\n// ArBr + ArBi + AiBr + AiBi = ArBr - AB + ArBi + AiBr\n// Yr = ArBr - AB\n// Yi = ArBi + AiBr\nconst COMPLEX_MULTIPLY_REAL = 'return areal * breal - aimag * bimag;';\nconst COMPLEX_MULTIPLY_IMAG = 'return areal * bimag + aimag * breal;';\nconst DIV = 'return a / b;';\nconst EQUAL = 'return float(a == b);';\nconst EQUAL_VEC4 = 'return vec4(equal(a, b));';\nconst GREATER = 'return float(a > b);';\nconst GREATER_VEC4 = 'return vec4(greaterThan(a, b));';\nconst GREATER_EQUAL = 'return float(a >= b);';\nconst GREATER_EQUAL_VEC4 = 'return vec4(greaterThanEqual(a, b));';\nconst INT_DIV = `\n  float s = sign(a) * sign(b);\n  int ia = int(round(a));\n  int ib = int(round(b));\n  return float(idiv(ia, ib, s));\n  `;\nconst INT_DIV_VEC4 = `\n  ivec4 ia = ivec4(round(a));\n  ivec4 ib = ivec4(round(b));\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n  `;\nconst LESS = 'return float(a < b);';\nconst LESS_VEC4 = 'return vec4(lessThan(a, b));';\nconst LESS_EQUAL = 'return float(a <= b);';\nconst LESS_EQUAL_VEC4 = 'return vec4(lessThanEqual(a, b));';\nconst LOGICAL_AND = 'return float(float(a) >= 1.0 && float(b) >= 1.0);';\nconst LOGICAL_AND_VEC4 = `return vec4(\n  vec4(greaterThanEqual(a, vec4(1.0))) *\n  vec4(greaterThanEqual(b, vec4(1.0))));`;\nconst MUL = 'return a * b;';\nconst NOT_EQUAL = 'return float(a != b);';\nconst NOT_EQUAL_VEC4 = 'return vec4(notEqual(a, b));';\nconst POW = `\n  if(a < 0.0 && floor(b) < b) {\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n  `;\nconst POW_VEC4 = `\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));\n  ${CHECK_NAN_SNIPPET_VEC4}\n  return result;\n  `;\nconst PRELU = 'return (a < 0.) ? b * a : a;';\nconst PRELU_VEC4 = `\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n  `;\nconst SQUARED_DIFFERENCE = 'return (a - b) * (a - b);';\nconst SUB = 'return a - b;';\n\n// WGSL shader.\nconst EQUAL_WGSL = 'return f32(a == b);';\nconst EQUAL_VEC4_WGSL = 'return vec4<f32>(a == b);';\nconst GREATER_WGSL = 'return f32(a > b);';\nconst GREATER_VEC4_WGSL = 'return vec4<f32>(a > b);';\nconst GREATER_EQUAL_WGSL = 'return f32(a >= b);';\nconst GREATER_EQUAL_VEC4_WGSL = 'return vec4<f32>(a >= b);';\nconst LESS_WGSL = 'return f32(a < b);';\nconst LESS_VEC4_WGSL = 'return vec4<f32>(a < b);';\nconst LESS_EQUAL_WGSL = 'return f32(a <= b);';\nconst LESS_EQUAL_VEC4_WGSL = 'return vec4<f32>(a <= b);';\nconst LOGICAL_AND_WGSL = 'return f32(f32(a) >= 1.0 && f32(b) >= 1.0);';\nconst LOGICAL_AND_VEC4_WGSL = `return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));`;\nconst CHECK_NAN_SNIPPET_WGSL = `\n  if (isNanCustom(a)) { return a; }\n  if (isNanCustom(b)) { return b; }\n  `;\nconst CHECK_NAN_SNIPPET_VEC4_WGSL = `\n  if (isNaN.r > 0.) {\n    resultTemp.r = uniforms.NAN;\n  }\n  if (isNaN.g > 0.) {\n    resultTemp.g = uniforms.NAN;\n  }\n  if (isNaN.b > 0.) {\n    resultTemp.b = uniforms.NAN;\n  }\n  if (isNaN.a > 0.) {\n    resultTemp.a = uniforms.NAN;\n  }\n  `;\nconst INT_DIV_WGSL = `\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n  `;\nconst INT_DIV_VEC4_WGSL = `\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n  `;\n\nconst NOT_EQUAL_WGSL = 'return f32(a != b);';\nconst NOT_EQUAL_VEC4_WGSL = 'return vec4<f32>(a != b);';\n\nconst POW_WGSL = `\n  if(a < 0.0 && floor(b) < b) {\n    return f32(uniforms.NAN);\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (i32(round(mod(b, 2.0))) != 1) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n  `;\n\nconst POW_VEC4_WGSL = `\n  let isModRound1Bool = vec4<i32>(round(modVec4(b, vec4<f32>(2.0)))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = vec4<f32>(a < vec4<f32>(0.0)) * vec4<f32>(floor(b) < b);\n  ${CHECK_NAN_SNIPPET_VEC4_WGSL}\n  return resultTemp;\n  `;\n\nconst PRELU_WGSL = `if (a < 0.0) { return b * a; }  return a;`;\nconst PRELU_VEC4_WGSL = `\n  let aLessThanZero : vec4<bool> = vec4<bool>(a < vec4<f32>(0.0));\n  let aLessThanZeroF32 = vec4<f32>(aLessThanZero);\n  return (vec4<f32>(aLessThanZeroF32) * (b * a)) + ((vec4<f32>(1.0) - vec4<f32>(aLessThanZeroF32)) * a);\n  `;\n\nfunction getMinMaxString(op: string, useVec4: boolean, useWGSL = false) {\n  if (useWGSL) {\n    const checkNanSnippetWgsl =\n        useVec4 ? CHECK_NAN_SNIPPET_VEC4_WGSL : CHECK_NAN_SNIPPET_WGSL;\n    return useVec4 ? `\n    var resultTemp = vec4<f32>(${op}(a, b));\n    let isNaN = min(vec4<f32>(isNanCustomVec4F32(a)) + vec4<f32>(isNanCustomVec4F32(b)), vec4<f32>(1.0));\n    ` + checkNanSnippetWgsl +\n            `\n    return resultTemp;\n  ` :\n                     checkNanSnippetWgsl + `\n    return ${op}(a, b);\n  `;\n  }\n  const checkNanSnippet = useVec4 ? CHECK_NAN_SNIPPET_VEC4 : CHECK_NAN_SNIPPET;\n  return useVec4 ? `\n    vec4 result = vec4(${op}(a, b));\n    vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));\n    ` + checkNanSnippet +\n          `\n    return result;\n  ` :\n                   checkNanSnippet + `\n    return ${op}(a, b);\n  `;\n}\n\nexport function getBinaryOpString(\n    type: BinaryOpType, useVec4?: boolean, useWgsl?: boolean): string {\n  switch (type) {\n    case BinaryOpType.MUL:\n      return MUL;\n    case BinaryOpType.ADD:\n      return ADD;\n    case BinaryOpType.SUB:\n      return SUB;\n    case BinaryOpType.DIV:\n      return DIV;\n    case BinaryOpType.EQUAL:\n      if (useWgsl) {\n        return useVec4 ? EQUAL_VEC4_WGSL : EQUAL_WGSL;\n      } else {\n        return useVec4 ? EQUAL_VEC4 : EQUAL;\n      }\n    case BinaryOpType.GREATER:\n      if (useWgsl) {\n        return useVec4 ? GREATER_VEC4_WGSL : GREATER_WGSL;\n      } else {\n        return useVec4 ? GREATER_VEC4 : GREATER;\n      }\n    case BinaryOpType.GREATER_EQUAL:\n      if (useWgsl) {\n        return useVec4 ? GREATER_EQUAL_VEC4_WGSL : GREATER_EQUAL_WGSL;\n      } else {\n        return useVec4 ? GREATER_EQUAL_VEC4 : GREATER_EQUAL;\n      }\n    case BinaryOpType.LESS:\n      if (useWgsl) {\n        return useVec4 ? LESS_VEC4_WGSL : LESS_WGSL;\n      } else {\n        return useVec4 ? LESS_VEC4 : LESS;\n      }\n    case BinaryOpType.LESS_EQUAL:\n      if (useWgsl) {\n        return useVec4 ? LESS_EQUAL_VEC4_WGSL : LESS_EQUAL_WGSL;\n      } else {\n        return useVec4 ? LESS_EQUAL_VEC4 : LESS_EQUAL;\n      }\n    case BinaryOpType.LOGICAL_AND:\n      if (useWgsl) {\n        return useVec4 ? LOGICAL_AND_VEC4_WGSL : LOGICAL_AND_WGSL;\n      } else {\n        return useVec4 ? LOGICAL_AND_VEC4 : LOGICAL_AND;\n      }\n    case BinaryOpType.NOT_EQUAL:\n      if (useWgsl) {\n        return useVec4 ? NOT_EQUAL_VEC4_WGSL : NOT_EQUAL_WGSL;\n      } else {\n        return useVec4 ? NOT_EQUAL_VEC4 : NOT_EQUAL;\n      }\n    case BinaryOpType.SQUARED_DIFFERENCE:\n      return SQUARED_DIFFERENCE;\n    case BinaryOpType.INT_DIV:\n      if (useWgsl) {\n        return useVec4 ? INT_DIV_VEC4_WGSL : INT_DIV_WGSL;\n      } else {\n        return useVec4 ? INT_DIV_VEC4 : INT_DIV;\n      }\n    case BinaryOpType.PRELU:\n      if (useWgsl) {\n        return useVec4 ? PRELU_VEC4_WGSL : PRELU_WGSL;\n      } else {\n        return useVec4 ? PRELU_VEC4 : PRELU;\n      }\n    case BinaryOpType.MAX:\n      return getMinMaxString('max', useVec4, useWgsl);\n    case BinaryOpType.MIN:\n      return getMinMaxString('min', useVec4, useWgsl);\n    case BinaryOpType.POW:\n      if (useWgsl) {\n        return useVec4 ? POW_VEC4_WGSL : POW_WGSL;\n      } else {\n        return useVec4 ? POW_VEC4 : POW;\n      }\n    case BinaryOpType.COMPLEX_MULTIPLY_REAL:\n      return COMPLEX_MULTIPLY_REAL;\n    case BinaryOpType.COMPLEX_MULTIPLY_IMAG:\n      return COMPLEX_MULTIPLY_IMAG;\n    default:\n      throw new Error(`BinaryType ${type} is not implemented!`);\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum UnaryOpType {\n  ABS,\n  CEIL,\n  ELU,\n  EXP,\n  EXPM1,\n  FLOOR,\n  LINEAR,\n  LOG,\n  NEG,\n  PRELU,\n  RELU,\n  RELU6,\n  RSQRT,\n  SIGMOID,\n  SQRT,\n  SQUARE,\n  TANH,\n  TO_INT\n}\n\n// GLSL shader.\nconst ABS = `return abs(a);`;\nconst CEIL = `return ceil(a);`;\nconst EXPM1 = `return exp(a) - 1.0;`;\nconst ELU = `return (a >= 0.0) ? a : (exp(a) - 1.0);`;\nconst ELU_VEC4 = `\n  vec4 result;\n\n  result.r = (a.r >= 0.0) ? a.r : (exp(a.r) - 1.0);\n  result.g = (a.g >= 0.0) ? a.g : (exp(a.g) - 1.0);\n  result.b = (a.b >= 0.0) ? a.b : (exp(a.b) - 1.0);\n  result.a = (a.a >= 0.0) ? a.a : (exp(a.a) - 1.0);\n\n  return result;\n`;\nconst EXP = `return exp(a);`;\nconst FLOOR = `return floor(a);`;\nconst LINEAR = `return a;`;\nconst LOG = `if (a < 0.0) { return 1.0/0.0; }\n  return log(a);`;\nconst NEG = `return -a;`;\nconst PRELU = `return (a < 0.0) ? b * a : a;`;\nconst RELU = 'return max(a, 0.0);';\nconst RELU6 = 'return clamp(a, 0.0, 6.0);';\nconst RELU_VEC4 = `\n  vec4 result = a * vec4(greaterThanEqual(a, vec4(0.0)));\n  bvec4 isNaN = isnan(a);\n\n  result.r = isNaN.r ? a.r : result.r;\n  result.g = isNaN.g ? a.g : result.g;\n  result.b = isNaN.b ? a.b : result.b;\n  result.a = isNaN.a ? a.a : result.a;\n\n  return result;\n`;\nconst RSQRT = `return 1.0/sqrt(a);`;\nconst SIGMOID = `return 1.0 / (1.0 + exp(-1.0 * a));`;\nconst SQRT = `return sqrt(a);`;\nconst SQUARE = `return a * a;`;\nconst TANH = `\n  float e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n`;\nconst TO_INT = `return float(int(a));`;\n\n// WGSL shader.\nconst ELU_WGSL = `if (a >= 0.0) { return a; }  return (exp(a) - 1.0);`;\nconst RELU_WGSL = 'return max(a, 0.0);';\nconst RELU6_VEC4_WGSL =\n    'return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));';\nconst RELU_VEC4_WGSL = `\n  var resBool : vec4<bool> = vec4<bool>(a >= vec4<f32>(0.0, 0.0, 0.0, 0.0));\n  let isNaN : vec4<bool> = isNan(a);\n  var resFloat : vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  for (var i:u32 = 0u; i< 4u; i = i+1u ) {\n    if (resBool[i]) {\n      resFloat[i] = 1.0;\n    }\n  }\n  resFloat = a * resFloat;\n  if (isNaN.r) {\n    resFloat.r = a.r;\n  }\n  if (isNaN.g) {\n    resFloat.g = a.g;\n  }\n  if (isNaN.b) {\n    resFloat.b = a.b;\n  }\n  if (isNaN.a) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n`;\n\nconst TO_INT_WGSL = `return f32(i32((a)));`;\n\nexport function getUnaryOpString(\n    type: UnaryOpType, useVec4?: boolean, useWgsl?: boolean): string {\n  switch (type) {\n    case UnaryOpType.ABS:\n      return ABS;\n    case UnaryOpType.CEIL:\n      return CEIL;\n    case UnaryOpType.ELU:\n      if (useWgsl) {\n        if (useVec4) {\n          throw new Error(`UnaryOpType ELU vec4 for WGSL is not implemented!`);\n        }\n        return ELU_WGSL;\n      } else {\n        return useVec4 ? ELU_VEC4 : ELU;\n      }\n    case UnaryOpType.EXP:\n      return EXP;\n    case UnaryOpType.EXPM1:\n      return EXPM1;\n    case UnaryOpType.FLOOR:\n      return FLOOR;\n    case UnaryOpType.LINEAR:\n      return LINEAR;\n    case UnaryOpType.LOG:\n      return LOG;\n    case UnaryOpType.NEG:\n      return NEG;\n    case UnaryOpType.PRELU:\n      return PRELU;\n    case UnaryOpType.RELU:\n      if (useWgsl) {\n        return useVec4 ? RELU_VEC4_WGSL : RELU_WGSL;\n      } else {\n        return useVec4 ? RELU_VEC4 : RELU;\n      }\n    case UnaryOpType.RELU6:\n      if (useWgsl) {\n        return useVec4 ? RELU6_VEC4_WGSL : RELU6;\n      } else {\n        return RELU6;\n      }\n    case UnaryOpType.RSQRT:\n      return RSQRT;\n    case UnaryOpType.SIGMOID:\n      return SIGMOID;\n    case UnaryOpType.SQRT:\n      return SQRT;\n    case UnaryOpType.SQUARE:\n      return SQUARE;\n    case UnaryOpType.TANH:\n      return TANH;\n    case UnaryOpType.TO_INT:\n      return useWgsl ? TO_INT_WGSL : TO_INT;\n\n    default:\n      throw new Error(`BinaryType ${type} is not implemented!`);\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {BinaryOpType, getBinaryOpString} from './binary_op_util';\nimport {getUnaryOpString, UnaryOpType} from './unary_op_util';\n\nexport function mapActivationToShaderProgram(\n    activation: backend_util.Activation, packed = false,\n    useWgsl = false): string {\n  if (activation === null) {\n    return null;\n  } else if (activation === 'linear') {\n    return getUnaryOpString(UnaryOpType.LINEAR);\n  } else if (activation === 'relu') {\n    return getUnaryOpString(UnaryOpType.RELU, packed, useWgsl);\n  } else if (activation === 'elu') {\n    return getUnaryOpString(UnaryOpType.ELU, packed, useWgsl);\n  } else if (activation === 'relu6') {\n    return getUnaryOpString(UnaryOpType.RELU6, packed, useWgsl);\n  } else if (activation === 'prelu') {\n    return getBinaryOpString(BinaryOpType.PRELU, packed, useWgsl);\n  } else if (activation === 'sigmoid') {\n    return getUnaryOpString(UnaryOpType.SIGMOID);\n  }\n  throw new Error(`Activation ${\n      activation} has not been implemented for the WebGPU backend.`);\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\ntype GLSL = {\n  defineSpecialNaN: string\n};\n\nexport function getGlslDifferences(): GLSL {\n  const defineSpecialNaN = `\n      bool isnan_custom(float val) {\n        // logical or has undefined behavior, https://bugs.chromium.org/p/tint/issues/detail?id=976.\n        if (val > 0.0) {\n          return false;\n        }\n        if (val < 0.0) {\n          return false;\n        }\n        if (val == 0.0) {\n          return false;\n        }\n        return true;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    `;\n\n  return {defineSpecialNaN};\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, util} from '@tensorflow/tfjs-core';\nimport {getGlslDifferences} from './glsl_version';\nimport {symbolicallyComputeStrides} from './shader_util';\n\nexport function getCoordsDataType(rank: number): string {\n  if (rank <= 1) {\n    return 'int';\n  } else if (rank === 2) {\n    return 'ivec2';\n  } else if (rank === 3) {\n    return 'ivec3';\n  } else if (rank === 4) {\n    return 'ivec4';\n  } else {\n    throw Error(`GPU for rank ${rank} is not yet supported`);\n  }\n}\n\ntype GLSLDataType = 'float'|'int'|'vec4'|'ivec4'|'bvec4';\nfunction mapToGlslTypes(type: DataType, isVec4: boolean): GLSLDataType|\n    DataType {\n  if (type === 'float32') {\n    return isVec4 ? 'vec4' : 'float';\n  } else if (type === 'int32') {\n    return isVec4 ? 'ivec4' : 'int';\n  } else if (type === 'bool') {\n    return isVec4 ? 'bvec4' : 'bool';\n  }\n\n  return type;\n}\n\ninterface ProgramParams {\n  dispatchLayout: {x: number[], y?: number[], z?: number[]};\n  workGroupSize?: [number, number, number];\n  variableNames: string[];\n  uniforms?: string;\n  isVec4?: boolean;\n  size?: number;\n  getUserCode: () => string;\n}\n\nexport interface InputInfo {\n  dtype: DataType;\n  shape: number[];\n  name: string;\n}\n\nexport function makeShader(\n    inputInfo: InputInfo[], outputData: {dtype: DataType, shape: number[]},\n    program: ProgramParams, isFromPixel = false): string {\n  const outputBufferStr =\n      `    layout(std430, set = 0, binding = 0) writeonly buffer ssbOut {\n      ${mapToGlslTypes(outputData.dtype, program.isVec4)} result[];\n    };`;\n  if (isFromPixel === true) {\n    const getCoords = generateGetCoordsFromFlatIndex(outputData.shape);\n    return [\n      SHADER_PREFIX, outputBufferStr, program.getUserCode(), getCoords\n    ].join('\\n');\n  }\n  const prefixSnippets: string[] = [];\n\n  if (program.workGroupSize != null) {\n    prefixSnippets.push(`\n      layout (local_size_x = ${program.workGroupSize[0]},\n              local_size_y = ${program.workGroupSize[1]},\n              local_size_z = ${program.workGroupSize[2]}) in;\n    `);\n  }\n\n  // Output buffer.\n  prefixSnippets.push(`\n    layout(std430, set = 0, binding = 0) writeonly buffer ssbOut {\n      ${mapToGlslTypes(outputData.dtype, program.isVec4)} result[];\n    };\n  `);\n\n  program.variableNames.forEach((x, i) => {\n    prefixSnippets.push(`\n      layout(std430, set = 0, binding = ${1 + i}) readonly buffer ssb${x} {\n        ${mapToGlslTypes(inputInfo[i].dtype, program.isVec4)} ${x}[];\n      };\n    `);\n  });\n\n  let uniformDeclaration = 'float NAN; ';\n  program.variableNames.forEach((x, i) => {\n    uniformDeclaration += `${getCoordsDataType(inputInfo[i].shape.length)} ${\n        x.charAt(0).toLowerCase() + x.slice(1)}Shape; `;\n  });\n  uniformDeclaration +=\n      `${getCoordsDataType(outputData.shape.length)} outShape; `;\n  const stridesLength = outputData.shape.length - 1;\n  uniformDeclaration += `${getCoordsDataType(stridesLength)} outShapeStrides; `;\n\n  if (program.size != null) {\n    uniformDeclaration += 'int size; ';\n  }\n\n  uniformDeclaration += 'ivec3 dispatchSize; ';\n\n  if (program.uniforms) {\n    uniformDeclaration += program.uniforms;\n  }\n\n  if (uniformDeclaration !== '') {\n    prefixSnippets.push(`\n        layout(std140, set = 0, binding = ${\n        1 + program.variableNames.length}) uniform Uniforms {\n            ${uniformDeclaration}\n        };\n    `);\n  }\n\n  prefixSnippets.push(getGlslDifferences().defineSpecialNaN);\n\n  const [getOutputCoords, dispatchLayoutRank] =\n      generateGetOutputCoords(outputData.shape, program.dispatchLayout);\n  const getCoords = generateGetCoordsFromFlatIndex(outputData.shape);\n  const sources = [\n    SHADER_PREFIX, prefixSnippets.join('\\n'), SAMPLING_SNIPPETS, getCoords,\n    getOutputCoords,\n    getSetOutputSnippet(outputData.shape, outputData.dtype, program.isVec4)\n  ];\n\n  if (dispatchLayoutRank === outputData.shape.length) {\n    // Input sampling snippet is only meaningful when the output isn't getting\n    // implicitly reshaped (like it does in conv2d_matmul).\n    const inputSamplingSnippet =\n        inputInfo\n            .map(\n                x => getInputSamplingSnippet(\n                    x, outputData.shape, program.isVec4,\n                    program.dispatchLayout.x.length ===\n                        outputData.shape.length))\n            .join('\\n');\n    sources.push(inputSamplingSnippet);\n  }\n\n  sources.push(program.getUserCode());\n  const source = sources.join('\\n');\n  return source;\n}\n\nconst SHADER_PREFIX = `#version 450\n\n  int idiv(int a, int b, float sign) {\n    int res = a / b;\n    int mod = a % b;\n    if (sign < 0. && mod != 0) {\n      res -= 1;\n    }\n    return res;\n  }\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  bool coordsInBounds(ivec4 coord, ivec4 shape) {\n    return all(greaterThanEqual(coord, ivec4(0))) &&\n        all(lessThan(coord, shape));\n  }\n\n  bool coordsInBounds(ivec3 coord, ivec3 shape) {\n    return all(greaterThanEqual(coord, ivec3(0))) &&\n        all(lessThan(coord, shape));\n  }\n\n  bool coordsInBounds(ivec2 coord, ivec2 shape) {\n    return all(greaterThanEqual(coord, ivec2(0))) &&\n        all(lessThan(coord, shape));\n  }\n`;\n\nconst SAMPLING_SNIPPETS = `\n  int getFlatIndex(int coord, int shape) {\n    return coord;\n  }\n\n  int getFlatIndex(ivec2 coords, ivec2 shape) {\n    return int(dot(coords, ivec2(shape.y, 1.)));\n  }\n\n  int getFlatIndex(ivec3 coords, ivec3 shape) {\n    return int(dot(coords, ivec3(shape.y * shape.z, shape.z, 1.)));\n  }\n\n  int getFlatIndex(ivec4 coords, ivec4 shape) {\n    return int(dot(coords, ivec4(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1.)));\n  }\n\n  // Only used when the y/z dimension of workgroup size is 1.\n  int getGlobalIndex() {\n    if (dispatchSize.y == 1 && dispatchSize.z == 1) {\n      return int(gl_GlobalInvocationID.x);\n    } else {\n      return int((gl_WorkGroupID.z * dispatchSize.x * dispatchSize.y +\n        gl_WorkGroupID.y * dispatchSize.x + gl_WorkGroupID.x) *\n        (gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z) +\n        gl_LocalInvocationIndex);\n    }\n  }\n`;\n\nfunction getSetOutputSnippet(\n    outShape: number[], outBufferType: DataType, isVec4: boolean): string {\n  const outRank = outShape.length;\n  const glslType = mapToGlslTypes(outBufferType, isVec4);\n  let snippet;\n  if (isVec4) {\n    snippet = `void setOutput(int flatIndex, vec4 value) {\n      result[flatIndex] = ${\n        glslType === 'ivec4' ?\n            'ivec4(value)' :\n            (glslType === 'bvec4' ? 'bvec4(value)' : 'value')};\n    }\n    void setOutput(int flatIndex, ivec4 value) {\n      result[flatIndex] = ${\n        glslType === 'vec4' ?\n            'vec4(value)' :\n            (glslType === 'bvec4' ? 'bvec4(value)' : 'value')};\n    }`;\n  } else {\n    snippet = `void setOutput(int flatIndex, float value) {\n      result[flatIndex] = ${\n        glslType === 'int' ? 'int(value)' :\n                             (glslType === 'bool' ? 'bool(value)' : 'value')};\n    }\n    void setOutput(int flatIndex, int value) {\n      result[flatIndex] = ${\n        glslType === 'float' ?\n            'float(value)' :\n            (glslType === 'bool' ? 'bool(value)' : 'value')};\n    }`;\n  }\n\n  if (outRank >= 2) {\n    switch (outRank) {\n      case 2:\n        snippet += `\n        int getOutputFlatIndex(ivec2 coords) {\n          return int(dot(coords, ivec2(outShapeStrides, 1)));\n        }\n        `;\n        break;\n      case 3:\n        snippet += `\n        int getOutputFlatIndex(ivec3 coords) {\n          return int(dot(coords, ivec3(outShapeStrides.x, outShapeStrides.y, 1)));\n        }\n        `;\n        break;\n      case 4:\n        snippet += `\n        int getOutputFlatIndex(ivec4 coords) {\n          return int(dot(coords, ivec4(\n            outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1)));\n        }\n        `;\n        break;\n      default:\n        util.assert(false, () => `Unsupported ${outRank}D shape`);\n        break;\n    }\n    const dims = ['d0', 'd1', 'd2', 'd3'].slice(0, outRank);\n    const type = getCoordsDataType(outRank);\n\n    if (isVec4) {\n      snippet += `\n      void setOutput(${dims.map(d => `int ${d}`).join(', ')}, vec4 value) {\n        int flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutput(flatIndex / 4, value);\n      }\n      void setOutput(${dims.map(d => `int ${d}`).join(', ')}, ivec4 value) {\n        int flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutput(flatIndex / 4, value);\n      }\n    `;\n    } else {\n      snippet += `\n      void setOutput(${dims.map(d => `int ${d}`).join(', ')}, float value) {\n        int flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutput(flatIndex, value);\n      }\n      void setOutput(${dims.map(d => `int ${d}`).join(', ')}, int value) {\n        int flatIndex = getOutputFlatIndex(${type}(${dims.join(', ')}));\n        setOutput(flatIndex, value);\n      }\n    `;\n    }\n  }\n\n  return snippet;\n}\n\nfunction getInputSamplingSnippet(\n    inInfo: InputInfo, outShape: number[], isVec4: boolean,\n    isFlatDispatchLayout: boolean): string {\n  let res = getSamplerFromInInfo(inInfo, isVec4);\n\n  const inShape = inInfo.shape;\n  if (inShape.length <= outShape.length) {\n    res += getSamplerAtOutputCoords(\n        inInfo, outShape, isVec4, isFlatDispatchLayout);\n  }\n\n  return res;\n}\n\nfunction getSamplerFromInInfo(inInfo: InputInfo, isVec4: boolean): string {\n  const texName = inInfo.name;\n  const rank = inInfo.shape.length;\n  const type = getCoordsDataType(rank);\n  const funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);\n  const dims = ['d0', 'd1', 'd2', 'd3'].slice(0, rank);\n  const inputs = dims.map(d => `int ${d}`).join(', ');\n\n  if (rank < 1) {\n    if (isVec4) {\n      return `\n        vec4 ${funcName}() {\n          return vec4(${texName}[0]);\n        }\n      `;\n    }\n\n    return `\n      float ${funcName}() {\n        return float(${texName}[0]);\n      }\n    `;\n  }\n\n  const shapeStr = `${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n\n  if (isVec4) {\n    return `\n      vec4 ${funcName}(${inputs}) {\n        return vec4(${texName}[getFlatIndex(${type}(${dims.join(',')}),\n          ${shapeStr}) / 4]);\n      }\n      `;\n  }\n\n  return `\n    float ${funcName}(${inputs}) {\n      return float(${texName}[getFlatIndex(${type}(${dims.join(',')}),\n        ${shapeStr})]);\n    }\n   `;\n}\n\nfunction getSamplerAtOutputCoords(\n    inInfo: InputInfo, outShape: number[], isVec4: boolean,\n    isFlatDispatchLayout: boolean): string {\n  const texName = inInfo.name;\n  const texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);\n\n  const funcName = 'get' + texFuncSnippet + 'AtOutCoords';\n\n  const inRank = inInfo.shape.length;\n  const outRank = outShape.length;\n  const type = getCoordsDataType(outRank);\n\n  // If the inShape equals the outShape and the dispatch layout is flat, we can\n  // directly use |gl_GlobalInvocationID.x| as the index and don't need coords\n  // conversion between these two shapes.\n  if (util.arraysEqual(inInfo.shape, outShape) && isFlatDispatchLayout) {\n    if (isVec4) {\n      return `\n        vec4 ${funcName}() {\n          return vec4(${texName}[getGlobalIndex()]);\n        }\n\n        vec4 ${funcName}(${type} coords) {\n          return vec4(${texName}[${\n          outRank > 1 ? 'getOutputFlatIndex(coords)' : 'coords'} / 4]);\n        }\n        `;\n    } else {\n      return `\n      float ${funcName}() {\n        return float(${texName}[getGlobalIndex()]);\n      }\n\n      float ${funcName}(${type} coords) {\n        return float(${texName}[${\n          outRank > 1 ? 'getOutputFlatIndex(coords)' : 'coords'}]);\n      }\n      `;\n    }\n  }\n\n  const broadcastDims = backend_util.getBroadcastDims(inInfo.shape, outShape);\n  const rankDiff = outRank - inRank;\n\n  let coordsSnippet = '';\n\n  if (inRank === 0) {\n    if (isVec4) {\n      return `\n      vec4 ${funcName}() {\n        return get${texFuncSnippet}();\n      }\n\n      vec4 ${funcName}(${type} coords) {\n        return get${texFuncSnippet}();\n      }\n    `;\n    }\n    return `\n      float ${funcName}() {\n        return get${texFuncSnippet}();\n      }\n\n      float ${funcName}(${type} coords) {\n        return get${texFuncSnippet}();\n      }\n    `;\n  } else {\n    if (outRank < 2 && broadcastDims.length >= 1) {\n      coordsSnippet = 'coords = 0;';\n    } else {\n      coordsSnippet =\n          broadcastDims.map(d => `coords[${d + rankDiff}] = 0;`).join('\\n');\n    }\n  }\n\n  let unpackedCoordsSnippet = '';\n  if (outRank < 2 && inRank > 0) {\n    unpackedCoordsSnippet = 'coords';\n  } else {\n    if (outRank > 1) {\n      const coordsType = getCoordsDataType(inRank);\n      const coordsValues =\n          inInfo.shape.map((s, i) => `coords[${i + rankDiff}]`).join(', ');\n      unpackedCoordsSnippet = `${coordsType}(${coordsValues})`;\n    } else {\n      unpackedCoordsSnippet = 'coords';\n    }\n  }\n\n  const shapeStr = `${texName.charAt(0).toLowerCase() + texName.slice(1)}Shape`;\n\n  if (isVec4) {\n    return `\n      vec4 ${funcName}() {\n        ${type} coords = getOutputCoords();\n        ${coordsSnippet}\n        return ${texName}[getFlatIndex(${unpackedCoordsSnippet}, ${\n        shapeStr}) / 4];\n      }\n\n      vec4 ${funcName}(${type} coords) {\n        ${coordsSnippet}\n        return ${texName}[getFlatIndex(${unpackedCoordsSnippet}, ${\n        shapeStr}) / 4];\n      }\n    `;\n  }\n\n  return `\n    float ${funcName}() {\n      ${type} coords = getOutputCoords();\n      ${coordsSnippet}\n      return float(${texName}[getFlatIndex(${unpackedCoordsSnippet}, ${\n      shapeStr})]);\n    }\n\n    float ${funcName}(${type} coords) {\n      ${coordsSnippet}\n      return float(${texName}[getFlatIndex(${unpackedCoordsSnippet}, ${\n      shapeStr})]);\n    }\n  `;\n}\n\n/**\n * Generates getOutputCoords() function that computes output coordinates from\n * dispatch geometry to reduce arithmetic.\n */\nfunction generateGetOutputCoords(\n    outShape: number[],\n    dispatchLayout: {x: number[], y?: number[], z?: number[]}):\n    [string, number] {\n  const {x, y = [], z = []} = dispatchLayout;\n\n  const outRank = outShape.length;\n  if (x.length === outRank) {\n    const dtype = getCoordsDataType(outRank);\n    const snippet = `${dtype} getOutputCoords() {\n      return getCoordsFromFlatIndex(getGlobalIndex());\n    }\n    `;\n    return [snippet, outRank];\n  }\n\n  let gatherDimensionsStr = '';\n  const dims = [x, y, z];\n\n  let rank = 0;\n\n  for (let i = 0; i < dims.length; i++) {\n    const arr = dims[i];\n\n    if (arr.length === 0) {\n      continue;\n    }\n\n    rank += arr.length;\n\n    if (arr.length === 1) {\n      gatherDimensionsStr += `int d${arr[0]} =\n        int(gl_GlobalInvocationID[${i}]);`;\n    } else {\n      const strides = symbolicallyComputeStrides(arr, 'outShape');\n      gatherDimensionsStr += `int index${i} =\n          int(gl_GlobalInvocationID[${i}]);`;\n      for (let j = 0; j < strides.length; j++) {\n        gatherDimensionsStr += `int d${arr[j]} = index${i} / ${strides[j]};`;\n\n        if (j === strides.length - 1) {\n          gatherDimensionsStr += `int d${arr[j + 1]} = ` +\n              `index${i} - d${arr[j]} * ${strides[j]};`;\n        } else {\n          gatherDimensionsStr += `index${i} -= d${arr[j]} * ${strides[j]};`;\n        }\n      }\n    }\n  }\n\n  const dimensions = [];\n  for (let i = 0; i < rank; i++) {\n    dimensions.push(`d${i}`);\n  }\n\n  const dtype = getCoordsDataType(rank);\n  let snippet = `${dtype} getOutputCoords() {\n    ${gatherDimensionsStr}\n  `;\n  if (dimensions.length === 0) {\n    snippet += `return ${dtype}(0);}`;\n  } else {\n    snippet += `return ${dtype}(${dimensions.join(',')});}`;\n  }\n\n  return [snippet, rank];\n}\n\n/**\n * Derives logical coordinates from a flat index. Performs integer division\n * with each stride and decrements the index until the index equals the final\n * dimension coordinate.\n */\nfunction generateGetCoordsFromFlatIndex(shape: number[]): string {\n  const rank = shape.length;\n\n  if (rank <= 1) {\n    return `int getCoordsFromFlatIndex(int index) {return index; }`;\n  }\n\n  const strides = util.computeStrides(shape);\n  const dtype = getCoordsDataType(rank);\n  const coords: string[] = [];\n  for (let i = 0; i < rank; i++) {\n    coords.push(`d${i}`);\n  }\n\n  if (strides.length === 1) {\n    return `    ivec2 getCoordsFromFlatIndex(int index) {\n      int d0 = index / outShapeStrides; int d1 = index - d0 * outShapeStrides;\n      return ivec2(d0,d1);\n    }`;\n  }\n  const snippet = strides\n                      .map((_, i) => {\n                        const line1 =\n                            `int ${coords[i]} = index / outShapeStrides[${i}]`;\n                        const line2 = i === strides.length - 1 ?\n                            `int ${coords[i + 1]} = index - ${\n                                coords[i]} * outShapeStrides[${i}]` :\n                            `index -= ${coords[i]} * outShapeStrides[${i}]`;\n                        return `${line1}; ${line2};`;\n                      })\n                      .join('');\n\n  return `\n    ${dtype} getCoordsFromFlatIndex(int index) {\n      ${snippet}\n      return ${dtype}(${coords.join(',')});\n    }\n  `;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, env, Rank, ShapeMap, TensorInfo} from '@tensorflow/tfjs-core';\nimport {Glslang} from '@webgpu/glslang/dist/web-devel/glslang.onefile';\n\nimport * as shader_preprocessor from '../shader_preprocessor';\nimport * as shader_preprocessor_wgsl from '../shader_preprocessor_wgsl';\n\nexport interface WebGPUProgram {\n  // The unique key to distinguish different shader source code.\n  shaderKey: string;\n  outputShape: number[];\n  // dispatchLayout enumerates how tensor dimensions are distributed among\n  // dispatch x,y,z dimensions.\n  dispatchLayout: {x: number[], y?: number[], z?: number[]};\n  // dispatch specifies geometry of thread groups - derived from dispatchLayout.\n  dispatch: [number, number, number];\n  variableNames: string[];\n  uniforms?: string;\n  uniformsWgsl?: string;\n  // Size of register cache in one dimension (assumes square cache).\n  // Each thread writes to workPerThread * workPerThread locations in the output\n  // buffer.\n  workPerThread?: number;\n  // workGroupSize.x * workGroupSize.y * workGroupSize.z = the number of threads\n  // in a thread group. Individual dimensions determines thread layout within\n  // the group.\n  workGroupSize: [number, number, number];\n  useWgsl?: boolean;\n  isVec4?: boolean;\n  // size is used for bounds checking.\n  size?: number;\n  getUserCode: () => string;\n}\n\nexport interface TensorData {\n  dtype: DataType;\n}\n\nexport const makeBindGroup =\n    (device: GPUDevice, bindGroupLayout: GPUBindGroupLayout,\n     inputs: GPUBindingResource[], output: GPUBindingResource,\n     uniforms?: GPUBindingResource) => {\n      const bindings = [output, ...inputs];\n      if (uniforms) {\n        bindings.push(uniforms);\n      }\n      return device.createBindGroup({\n        layout: bindGroupLayout,\n        entries: bindings.map((b, i) => ({binding: i, resource: b})),\n      });\n    };\n\nexport const compileProgram =\n    (glslang: Glslang, device: GPUDevice, program: WebGPUProgram,\n     pipelineLayout: GPUPipelineLayout,\n     inputsData: shader_preprocessor.InputInfo[], output: TensorInfo,\n     isFromPixel = false): GPUComputePipeline => {\n      const outputData = {dtype: output.dtype, shape: output.shape};\n\n      let source;\n      let module;\n      if (program.useWgsl) {\n        source = shader_preprocessor_wgsl.makeShader(\n            inputsData, outputData, program, isFromPixel);\n        module = device.createShaderModule({code: source});\n      } else {\n        source = shader_preprocessor.makeShader(\n            inputsData, outputData, program, isFromPixel);\n        const result = glslang.compileGLSLZeroCopy(source, 'compute', false);\n        if (result.data.length === 0) {\n          throw new Error('Shader compilation failed');\n        }\n        result.free();\n        module = device.createShaderModule({code: result.data});\n      }\n      const pipeline = device.createComputePipeline(\n          {layout: pipelineLayout, compute: {module, entryPoint: 'main'}});\n\n      return pipeline;\n    };\n\nexport function makeShaderKey<R extends Rank>(\n    program: WebGPUProgram, shapes: Array<ShapeMap[R]>, types: string[],\n    broadcastDimsKey = '', inputShapesEqualsOutShape = ''): string {\n  let useWgslKey = '';\n  if (program.useWgsl) {\n    useWgslKey = '_1';\n  }\n  const key = (program.workGroupSize ? program.workGroupSize.join(',') : '') +\n      shapes.map(shape => shape.length).join(',') + types.join(',') +\n      program.variableNames.join(',') + broadcastDimsKey +\n      inputShapesEqualsOutShape + program.shaderKey + useWgslKey;\n  return key;\n}\n\n// This is global flag, but program may ignore this flag.\nexport function getUseWgsl () {\n  return !env().getBool('WEBGPU_USE_GLSL');\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {getWorkGroupSizeStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, computeWorkGroupSizeForMatMul, tilesFitEvenlyIntoShape} from '../webgpu_util';\n\nimport {mapActivationToShaderProgram} from './activation_util';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport function makeMatMulPackedVec4Source(workPerThread: number[]): string {\n  return `\n    vec4 mm_readA(int row, int col);\n    vec4 mm_readB(int row, int col);\n    void mm_write(int row, int col, vec4 value);\n\n    const int RowPerThread = ${workPerThread[1]};\n    const int ColPerThread = ${\n      workPerThread[0]}; // only support ColPerThread = 4\n    const int TileAOuter = int(gl_WorkGroupSize.y) * RowPerThread;\n    const int TileBOuter = int(gl_WorkGroupSize.x) * ColPerThread;\n    const int TileInner = TileBOuter;\n\n    shared vec4 mm_Asub[TileAOuter][TileInner / ColPerThread];\n    shared vec4 mm_Bsub[TileInner][TileBOuter / ColPerThread];\n\n    void mm_matMul(int dimAOuter, int dimInner, int dimBOuter) {\n      int tileRow = int(gl_LocalInvocationID.y) * RowPerThread;\n      int tileCol = int(gl_LocalInvocationID.x);\n\n      int globalRow = int(gl_GlobalInvocationID.y) * RowPerThread;\n      int globalCol = int(gl_GlobalInvocationID.x);\n\n      int numTiles = (dimInner - 1) / TileInner + 1;\n\n      vec4 acc[RowPerThread];\n      vec4 ACached;\n      vec4 BCached[4];\n\n      // Without this initialization strange values show up in acc.\n      for (int innerRow = 0; innerRow < RowPerThread; innerRow++) {\n          acc[innerRow] = vec4(0.0);\n      }\n\n      // Loop over shared dimension.\n      int globalColA = tileCol;\n      const int RowPerThreadB = TileInner / int(gl_WorkGroupSize.y);\n      int tileRowB = int(gl_LocalInvocationID.y) * RowPerThreadB;\n      for (int t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (int innerRow = 0; innerRow < RowPerThread; innerRow++) {\n            int inputRow = tileRow + innerRow;\n            int inputCol = tileCol;\n\n            mm_Asub[inputRow][inputCol] = mm_readA(\n                globalRow + innerRow,\n                globalColA);\n        }\n        globalColA += TileInner / ColPerThread;\n\n        // Load one tile of B into local memory.\n        for (int innerRow = 0; innerRow < RowPerThreadB; innerRow++) {\n            int inputRow = tileRowB + innerRow;\n            int inputCol = tileCol;\n\n            mm_Bsub[inputRow][inputCol] = mm_readB(\n              t * TileInner + inputRow,\n              globalCol);\n        }\n\n        barrier();\n\n        // Compute acc values for a single thread.\n        for (int k = 0; k < TileInner / ColPerThread; k++) {\n          BCached[0] = mm_Bsub[k * ColPerThread][tileCol];\n          BCached[1] = mm_Bsub[k * ColPerThread + 1][tileCol];\n          BCached[2] = mm_Bsub[k * ColPerThread + 2][tileCol];\n          BCached[3] = mm_Bsub[k * ColPerThread + 3][tileCol];\n\n          for (int i = 0; i < RowPerThread; i++) {\n            ACached = mm_Asub[tileRow + i][k];\n            acc[i] = BCached[0] * ACached.x + acc[i];\n            acc[i] = BCached[1] * ACached.y + acc[i];\n            acc[i] = BCached[2] * ACached.z + acc[i];\n            acc[i] = BCached[3] * ACached.w + acc[i];\n          }\n        }\n        barrier();\n      }\n\n      for (int innerRow = 0; innerRow < RowPerThread; innerRow++) {\n        mm_write(globalRow + innerRow,\n          globalCol,\n          acc[innerRow]);\n      }\n    }\n  `;\n}\n\nexport function makeMatMulVectorVec4Source(): string {\n  return `\n    vec4 mm_readA(int row, int col);\n    vec4 mm_readB(int row, int col);\n    void mm_write(int row, int col, vec4 value);\n\n    const int TileSize = int(gl_WorkGroupSize.x) * 4;\n\n    shared vec4 mm_Asub[TileSize / 4];\n\n    void mm_matMul(int dimAOuter, int dimInner, int dimBOuter) {\n      int tileCol = int(gl_LocalInvocationID.x);\n      int globalCol = int(gl_GlobalInvocationID.x);\n      int globalRow = int(gl_GlobalInvocationID.y);\n\n      int numTiles = (dimInner - 1) / TileSize + 1;\n\n      // Without this initialization strange values show up in acc.\n      vec4 acc = vec4(0.0);\n\n      // Loop over shared dimension.\n      for (int t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        int colA = t * TileSize / 4 + tileCol;\n        mm_Asub[tileCol] = mm_readA(globalRow, colA);\n        barrier();\n\n        // Compute acc values for a single thread.\n        for (int k = 0; k < TileSize / 4; k++) {\n          int rowB = t * TileSize + k * 4;\n          vec4 BCached0 = mm_readB(rowB, globalCol);\n          vec4 BCached1 = mm_readB(rowB + 1, globalCol);\n          vec4 BCached2 = mm_readB(rowB + 2, globalCol);\n          vec4 BCached3 = mm_readB(rowB + 3, globalCol);\n\n          vec4 ACached = mm_Asub[k];\n          acc += BCached0 * ACached.x;\n          acc += BCached1 * ACached.y;\n          acc += BCached2 * ACached.z;\n          acc += BCached3 * ACached.w;\n        }\n\n        barrier();\n      }\n\n      if (globalRow < dimAOuter && globalCol < dimBOuter) {\n        mm_write(globalRow, globalCol, acc);\n      }\n    }\n  `;\n}\n\nexport function makeMatMulPackedVec4SourceWgsl(\n    workPerThread: number[], workGroupSize: [number, number, number]): string {\n  const tileInfo = {\n    RowPerThread: workPerThread[1],\n    ColPerThread: workPerThread[0],\n    TileAOuter: workGroupSize[1] * workPerThread[1],\n    TileBOuter: workGroupSize[0] * workPerThread[0],\n    TileInner: workGroupSize[0] * workPerThread[0]\n  };\n  return `\n  var<workgroup> mm_Asub : array<array<vec4<f32>, ${\n      tileInfo.TileInner / tileInfo.ColPerThread}>, ${tileInfo.TileAOuter}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${\n      tileInfo.TileBOuter / tileInfo.ColPerThread}>, ${tileInfo.TileInner}>;\n\n  let RowPerThread = ${tileInfo.RowPerThread}u;\n  let ColPerThread = ${tileInfo.ColPerThread}u; // only support ColPerThread = 4\n  let TileAOuter = ${tileInfo.TileAOuter}u;\n  let TileBOuter = ${tileInfo.TileBOuter}u;\n  let TileInner = ${tileInfo.TileInner}u;\n\n  ${getWorkGroupSizeStringWgsl()}\n  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,\n        [[builtin(global_invocation_id)]] globalId : vec3<u32>) {\n\n    let tileRow = localId.y * RowPerThread;\n    let tileCol = localId.x;\n\n    let globalRow = globalId.y * RowPerThread;\n    let globalCol = globalId.x;\n    let numTiles = (uniforms.dimInner - 1u) / TileInner + 1u;\n\n    var acc: array<vec4<f32>, ${tileInfo.RowPerThread}>;\n    var ACached : vec4<f32>;\n    var BCached : array<vec4<f32>, 4>;\n\n    // Loop over shared dimension.\n    var globalColA = tileCol;\n    let RowPerThreadB = TileInner / ${workGroupSize[1]}u;\n    let tileRowB = localId.y * RowPerThreadB;\n    for (var t = 0u; t < numTiles; t = t + 1u) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0u; innerRow < RowPerThread; innerRow = innerRow + 1u) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            mm_Asub[inputRow][inputCol] = mm_readA(globalRow + innerRow, globalColA, globalId);\n        }\n        globalColA = globalColA + TileInner / ColPerThread;\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0u; innerRow < RowPerThreadB; innerRow = innerRow + 1u) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(t * TileInner + inputRow, globalCol, globalId);\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0u; k < TileInner / ColPerThread; k = k + 1u) {\n            BCached[0] = mm_Bsub[k * ColPerThread][tileCol];\n            BCached[1] = mm_Bsub[k * ColPerThread + 1u][tileCol];\n            BCached[2] = mm_Bsub[k * ColPerThread + 2u][tileCol];\n            BCached[3] = mm_Bsub[k * ColPerThread + 3u][tileCol];\n\n            for (var i = 0u; i < RowPerThread; i = i + 1u) {\n                ACached = mm_Asub[tileRow + i][k];\n                acc[i] = BCached[0] * ACached.x + acc[i];\n                acc[i] = BCached[1] * ACached.y + acc[i];\n                acc[i] = BCached[2] * ACached.z + acc[i];\n                acc[i] = BCached[3] * ACached.w + acc[i];\n            }\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0u; innerRow < RowPerThread; innerRow = innerRow + 1u) {\n        mm_write(globalRow + innerRow,\n                 globalCol,\n                 acc[innerRow], globalId);\n    }\n}`;\n}\n\nexport function makeMatMulVectorVec4SourceWgsl(\n    workGroupSize: [number, number, number]): string {\n  return `\n  var<workgroup> mm_Asub : array<vec4<f32>, ${workGroupSize[0]}>;\n  let tileSize = ${workGroupSize[0] * 4}u;\n  ${getWorkGroupSizeStringWgsl()}\n  fn main([[builtin(local_invocation_id)]] localId : vec3<u32>,\n        [[builtin(global_invocation_id)]] globalId : vec3<u32>) {\n    let tileCol = localId.x;\n    let globalCol = globalId.x;\n    let globalRow = globalId.y;\n\n    let numTiles = (uniforms.dimInner - 1u) / tileSize + 1u;\n\n    // Without this initialization strange values show up in acc.\n    var acc = vec4<f32>(0.0);\n\n    // Loop over shared dimension.\n    for (var t = 0u; t < numTiles; t = t + 1u) {\n      // Load one tile of A into local memory.\n      let colA = t * tileSize / 4u + tileCol;\n      mm_Asub[tileCol] = mm_readA(globalRow, colA, globalId);\n\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0u; k < tileSize / 4u; k = k + 1u) {\n        let rowB = t * tileSize + k * 4u;\n        let BCached0 = mm_readB(rowB, globalCol, globalId);\n        let BCached1 = mm_readB(rowB + 1u, globalCol, globalId);\n        let BCached2 = mm_readB(rowB + 2u, globalCol, globalId);\n        let BCached3 = mm_readB(rowB + 3u, globalCol, globalId);\n\n        let ACached = mm_Asub[k];\n        acc = acc + BCached0 * ACached.x;\n        acc = acc + BCached1 * ACached.y;\n        acc = acc + BCached2 * ACached.z;\n        acc = acc + BCached3 * ACached.w;\n      }\n\n      workgroupBarrier();\n    }\n\n    if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {\n      mm_write(globalRow, globalCol, acc, globalId);\n    }\n  }\n`;\n}\n\nexport class MatMulPackedVec4Program implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  workPerThread: number;\n  variableNames = ['A', 'B'];\n  uniformsWgsl = `dimAOuter : u32; dimBOuter : u32; dimInner : u32;`;\n  workGroupSize: [number, number, number] = [16, 16, 1];\n  useWgsl: boolean;\n  isVec4 = true;\n  aShape: [number, number, number];\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  vecSize = 4;\n  fitA: boolean;\n  fitB: boolean;\n\n  constructor(\n      aShape: [number, number, number], outputShape: [number, number, number],\n      rowPerThread: number, bias: TensorInfo = null,\n      activation: backend_util.Activation = null,\n      preluActivationWeights: TensorInfo = null) {\n    this.outputShape = outputShape;\n    this.workGroupSize = computeWorkGroupSizeForMatMul(\n        outputShape[1], aShape[2], outputShape[2]);\n    this.dispatchLayout = {x: [2], y: [1], z: [0]};\n    if (outputShape[1] === 1) {\n      rowPerThread = 1;\n    }\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.vecSize, rowPerThread, 1]);\n\n    const addBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.workPerThread = rowPerThread;\n    this.aShape = aShape;\n    this.addBias = addBias;\n    this.useWgsl = getUseWgsl();\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n\n    [this.fitA, this.fitB] = this.getShapeFit();\n\n    this.shaderKey = `matMulPackedVec4_${rowPerThread}_${this.activation}_${\n        this.fitA}_${this.fitB}_${this.outputShape[1] > 1}`;\n  }\n\n  getShapeFit(): boolean[] {\n    const dimInner = this.aShape[2];\n    const dimBOuter = this.outputShape[2];\n    const bShape = [this.outputShape[0], dimInner, dimBOuter];\n    const tileAOuter = this.workGroupSize[1] * this.workPerThread;\n    const tileBOuter = this.workGroupSize[0] * this.vecSize;\n    const tileInner = tileBOuter;  // Make sure tileInner is divisible by 4.\n\n    const tileSizeA = [tileAOuter, tileInner];\n    const tileSizeB = [tileInner, tileBOuter];\n    return [\n      tilesFitEvenlyIntoShape(tileSizeA, this.aShape.slice(1)),\n      tilesFitEvenlyIntoShape(tileSizeB, bShape.slice(1))\n    ];\n  }\n\n  getUserCode(): string {\n    const sampleA = this.fitA ?\n        `A[batch * batchASize + row * dimInner / 4 + col]` :\n        `coordsInBounds(ivec2(row, col * 4), ivec2(dimAOuter, dimInner)) ?\n            A[batch * batchASize + row * dimInner / 4 + col] :\n            vec4(0.0)`;\n\n    const sampleB = this.fitB ?\n        `B[batch * batchBSize + row * dimBOuter / 4 + col]` :\n        `coordsInBounds(ivec2(row, col * 4), ivec2(dimInner, dimBOuter)) ?\n            B[batch * batchBSize + row * dimBOuter / 4 + col] :\n            vec4(0.0)`;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(\n          this.activation, this.isVec4, this.useWgsl);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet = `vec4 activation(vec4 a, ivec3 outCoord) {\n                  vec4 b = getPreluActivationWeightsAtOutCoords(outCoord);\n                  ${activationOp}\n                }`;\n      } else {\n        activationSnippet = `\n                vec4 activation(vec4 a, ivec3 outCoord) {\n                  ${activationOp}\n                }`;\n      }\n\n      applyActivationSnippet = 'value = activation(value, outCoord);';\n    }\n\n    const addBiasSnippet =\n        this.addBias ? 'value += getBiasAtOutCoords(outCoord);' : '';\n    const userCode = `\n      ${activationSnippet}\n      int dimAOuter = aShape[1];\n      int dimInner = aShape[2];\n      int dimBOuter = bShape[2];\n      int batch;\n\n      ${\n        this.outputShape[1] > 1 ?\n            makeMatMulPackedVec4Source([this.vecSize, this.workPerThread, 1]) :\n            makeMatMulVectorVec4Source()}\n\n      vec4 mm_readA(int row, int col) {\n        int batchASize = aShape[1] * aShape[2] / ${this.vecSize};\n        return ${sampleA};\n      }\n\n      vec4 mm_readB(int row, int col) {\n        int batchBSize = bShape[1] * bShape[2] / ${this.vecSize};\n        return ${sampleB};\n      }\n\n      void mm_write(int row, int col, vec4 value) {\n        if (row < dimAOuter && col * 4 < dimBOuter)\n        {\n          ivec3 outCoord = ivec3(batch, row, col * 4);\n          ${addBiasSnippet}\n          ${applyActivationSnippet}\n          setOutput(outCoord[0], outCoord[1], outCoord[2], value);\n        }\n      }\n\n      void main() {\n        batch = int(gl_GlobalInvocationID.z);\n        mm_matMul(dimAOuter, dimInner, dimBOuter);\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const sampleA = this.fitA ?\n        `return A.numbers[batch * batchASize + row * uniforms.dimInner / 4u + col]` :\n        `if (coordsInBounds2D(vec2<u32>(row, col * 4u), vec2<u32>(uniforms.dimAOuter, uniforms.dimInner))) {\n            return A.numbers[batch * batchASize + row * uniforms.dimInner / 4u + col];\n        }\n        return vec4<f32>(0.0)`;\n\n    const sampleB = this.fitB ?\n        `return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4u + col]` :\n        `if(coordsInBounds2D(vec2<u32>(row, col * 4u), vec2<u32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter / 4u + col];\n        }\n        return vec4<f32>(0.0)`;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(\n          this.activation, this.isVec4, this.useWgsl);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet =\n            `fn activation(a : vec4<f32>, outCoord : vec3<u32>) -> vec4<f32> {\n                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n                  ${activationOp}\n                }`;\n      } else {\n        activationSnippet = `\n            fn activation(a : vec4<f32>, outCoord : vec3<u32>) -> vec4<f32> {\n              ${activationOp}\n            }`;\n      }\n\n      applyActivationSnippet = 'value = activation(value, outCoord);';\n    }\n    const addBiasSnippet = this.addBias ?\n        'value = value + getBiasAtOutCoordsByCoords(outCoord);' :\n        '';\n\n    const userCode = `\n      ${activationSnippet}\n      fn mm_readA(row : u32, col : u32,  globalId : vec3<u32>) -> vec4<f32> {\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2] / ${\n        this.vecSize}u;\n        let batch = globalId.z;\n        ${sampleA};\n      }\n\n      fn mm_readB(row : u32, col : u32,  globalId : vec3<u32>) -> vec4<f32> {\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2] / ${\n        this.vecSize}u;\n        let batch = globalId.z;\n        ${sampleB};\n      }\n\n      fn mm_write(row : u32, col : u32, valueIn : vec4<f32>, globalId : vec3<u32>) {\n        if (row < uniforms.aShape[1] && col * 4u < uniforms.bShape[2])\n        {\n          var value = valueIn;\n          let batch = globalId.z;\n          let outCoord = vec3<u32>(batch, row, col * 4u);\n          ${addBiasSnippet}\n          ${applyActivationSnippet}\n          setOutput(outCoord[0], outCoord[1], outCoord[2], value);\n        }\n      }\n      ${\n        this.outputShape[1] > 1 ?\n            makeMatMulPackedVec4SourceWgsl(\n                [this.vecSize, this.workPerThread, 1], this.workGroupSize) :\n            makeMatMulVectorVec4SourceWgsl(this.workGroupSize)}\n\n    `;\n\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, computeWorkGroupSizeForMatMul, tilesFitEvenlyIntoShape} from '../webgpu_util';\n\nimport {mapActivationToShaderProgram} from './activation_util';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport function makeMatMulPackedSource(workPerThread: number[]): string {\n  return `\n    float mm_readA(int row, int col);\n    float mm_readB(int row, int col);\n    void mm_write(int row, int col, float value);\n    void mm_matMul(int dimAOuter, int dimInner, int dimBOuter);\n\n    const int RowPerThread = ${workPerThread[1]};\n    const int ColPerThread = ${workPerThread[0]};\n    const int TileAOuter = int(gl_WorkGroupSize.y) * RowPerThread;\n    const int TileBOuter = int(gl_WorkGroupSize.x) * ColPerThread;\n    const int TileInner = TileAOuter > TileBOuter ? TileAOuter : TileBOuter;\n\n    shared float mm_Asub[TileAOuter][TileInner];\n    shared float mm_Bsub[TileInner][TileBOuter];\n\n    void mm_matMul(int dimAOuter, int dimInner, int dimBOuter) {\n      int tileRow = int(gl_LocalInvocationID.y) * RowPerThread;\n      int tileCol = int(gl_LocalInvocationID.x) * ColPerThread;\n\n      int globalRow = int(gl_GlobalInvocationID.y) * RowPerThread;\n      int globalCol = int(gl_GlobalInvocationID.x) * ColPerThread;\n\n      int numTiles = (dimInner - 1) / TileInner + 1;\n\n      float acc[RowPerThread][ColPerThread];\n      float ACached;\n      float BCached[ColPerThread];\n\n      // Without this initialization strange values show up in acc.\n      for (int innerRow = 0; innerRow < RowPerThread; innerRow++) {\n        for (int innerCol = 0; innerCol < ColPerThread; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n\n      const int ColPerThreadA = TileInner / int(gl_WorkGroupSize.x);\n      int tileColA = int(gl_LocalInvocationID.x) * ColPerThreadA;\n      const int RowPerThreadB = TileInner / int(gl_WorkGroupSize.y);\n      int tileRowB = int(gl_LocalInvocationID.y) * RowPerThreadB;\n\n      // Loop over shared dimension.\n      for (int t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (int innerRow = 0; innerRow < RowPerThread; innerRow++) {\n          for (int innerCol = 0; innerCol < ColPerThreadA; innerCol++) {\n            int inputRow = tileRow + innerRow;\n            int inputCol = tileColA + innerCol;\n\n            mm_Asub[inputRow][inputCol] = mm_readA(\n                globalRow + innerRow,\n                t * TileInner + inputCol);\n          }\n        }\n        // Load one tile of B into local memory.\n        for (int innerRow = 0; innerRow < RowPerThreadB; innerRow++) {\n          for (int innerCol = 0; innerCol < ColPerThread; innerCol++) {\n            int inputRow = tileRowB + innerRow;\n            int inputCol = tileCol + innerCol;\n\n            mm_Bsub[inputRow][inputCol] = mm_readB(\n              t * TileInner + inputRow,\n              globalCol + innerCol);;\n          }\n        }\n\n        barrier();\n\n        // Compute acc values for a single thread.\n        for (int k = 0; k < TileInner; k++) {\n          for (int inner = 0; inner < ColPerThread; inner++) {\n            BCached[inner] = mm_Bsub[k][tileCol + inner];\n          }\n\n          for (int innerRow = 0; innerRow < RowPerThread; innerRow++) {\n            ACached = mm_Asub[tileRow + innerRow][k];\n            for (int innerCol = 0; innerCol < ColPerThread; innerCol++) {\n              acc[innerRow][innerCol] += ACached * BCached[innerCol];\n            }\n          }\n        }\n\n        barrier();\n      }\n\n      for (int innerRow = 0; innerRow < RowPerThread; innerRow++) {\n        for (int innerCol = 0; innerCol < ColPerThread; innerCol++) {\n\n          if ((globalCol + innerCol) < dimBOuter &&\n              (globalRow + innerRow) < dimAOuter) {\n            mm_write(globalRow + innerRow,\n                     globalCol + innerCol,\n                     acc[innerRow][innerCol]);\n          }\n        }\n      }\n    }\n  `;\n}\n\nexport function makeMatMulVectorSource(): string {\n  return `\n    float mm_readA(int row, int col);\n    float mm_readB(int row, int col);\n    void mm_write(int row, int col, float value);\n    void mm_matMul(int dimAOuter, int dimInner, int dimBOuter);\n\n    const int TileSize = int(gl_WorkGroupSize.x) * 4;\n\n    shared vec4 mm_Asub[TileSize / 4];\n\n    void mm_matMul(int dimAOuter, int dimInner, int dimBOuter) {\n      int tileCol = int(gl_LocalInvocationID.x);\n      int globalCol = int(gl_GlobalInvocationID.x);\n      int globalRow = int(gl_GlobalInvocationID.y);\n\n      int numTiles = (dimInner - 1) / TileSize + 1;\n\n      // Without this initialization strange values show up in acc.\n      float acc = 0.0;\n\n      // Loop over shared dimension.\n      for (int t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        int colA = t * TileSize + tileCol * 4;\n        mm_Asub[tileCol] = vec4(mm_readA(globalRow, colA),\n                                mm_readA(globalRow, colA + 1),\n                                mm_readA(globalRow, colA + 2),\n                                mm_readA(globalRow, colA + 3));\n        barrier();\n\n        // Compute acc values for a single thread.\n        for (int k = 0; k < TileSize / 4; k++) {\n          int rowB = t * TileSize + k * 4;\n          vec4 BCached = vec4(mm_readB(rowB, globalCol),\n                              mm_readB(rowB + 1, globalCol),\n                              mm_readB(rowB + 2, globalCol),\n                              mm_readB(rowB + 3, globalCol));\n\n          vec4 ACached = mm_Asub[k];\n          acc += dot(ACached, BCached);\n        }\n\n        barrier();\n      }\n\n      if (globalRow < dimAOuter && globalCol < dimBOuter) {\n        mm_write(globalRow, globalCol, acc);\n      }\n    }\n  `;\n}\n\nexport function makeMatMulPackedSourceWgsl(\n    workPerThread: number[], workGroupSize: [number, number, number]): string {\n  const tileAOuter = workGroupSize[1] * workPerThread[1];\n  const tileBOuter = workGroupSize[0] * workPerThread[0];\n  const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;\n  return `\n    var<workgroup> mm_Asub : array<array<f32, ${tileInner}>, ${tileAOuter}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${tileBOuter}>, ${tileInner}>;\n    ${getMainHeaderStringWgsl()} {\n      let tileRow = localId.y * ${workPerThread[1]}u;\n      let tileCol = localId.x * ${workPerThread[0]}u;\n\n      let globalRow = globalId.y * ${workPerThread[1]}u;\n      let globalCol = globalId.x * ${workPerThread[0]}u;\n\n      let numTiles = (uniforms.dimInner - 1u) / ${tileInner}u + 1u;\n\n      var acc : array<array<f32, ${workPerThread[0]}>, ${workPerThread[1]}>;\n      var ACached : f32;\n      var BCached : array<f32, ${workPerThread[0]}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0u; innerRow < ${\n      workPerThread[1]}u; innerRow = innerRow + 1u) {\n        for (var innerCol = 0u; innerCol < ${\n      workPerThread[0]}u; innerCol = innerCol + 1u) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n\n      let ColPerThreadA = ${tileInner}u / ${workGroupSize[0]}u;\n      let tileColA = localId.x * ColPerThreadA;\n      let RowPerThreadB = ${tileInner}u / ${workGroupSize[1]}u;\n      let tileRowB = localId.y * RowPerThreadB;\n\n      // Loop over shared dimension.\n      for (var t = 0u; t < numTiles; t = t + 1u) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0u; innerRow < ${\n      workPerThread[1]}u; innerRow = innerRow + 1u) {\n          for (var innerCol = 0u; innerCol < ColPerThreadA; innerCol = innerCol + 1u) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileColA + innerCol;\n\n            mm_Asub[inputRow][inputCol] = mm_readA(\n                globalRow + innerRow,\n                t * ${tileInner}u + inputCol, globalId);\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var innerRow = 0u; innerRow < RowPerThreadB; innerRow = innerRow + 1u) {\n          for (var innerCol = 0u; innerCol < ${\n      workPerThread[0]}u; innerCol = innerCol + 1u) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol + innerCol;\n\n            mm_Bsub[inputRow][inputCol] = mm_readB(\n              t * ${tileInner}u + inputRow,\n              globalCol + innerCol, globalId);\n          }\n        }\n\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0u; k < ${tileInner}u; k = k + 1u) {\n          for (var inner = 0u; inner < ${\n      workPerThread[0]}u; inner = inner + 1u) {\n            BCached[inner] = mm_Bsub[k][tileCol + inner];\n          }\n\n          for (var innerRow = 0u; innerRow < ${\n      workPerThread[1]}u; innerRow = innerRow + 1u) {\n            ACached = mm_Asub[tileRow + innerRow][k];\n            for (var innerCol = 0u; innerCol < ${\n      workPerThread[0]}u; innerCol = innerCol + 1u) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n            }\n          }\n        }\n\n        workgroupBarrier();\n      }\n\n      for (var innerRow = 0u; innerRow < ${\n      workPerThread[1]}u; innerRow = innerRow + 1u) {\n        for (var innerCol = 0u; innerCol < ${\n      workPerThread[0]}u; innerCol = innerCol + 1u) {\n\n          if ((globalCol + innerCol) < uniforms.dimBOuter &&\n              (globalRow + innerRow) < uniforms.dimAOuter) {\n            mm_write(globalRow + innerRow,\n                     globalCol + innerCol,\n                     acc[innerRow][innerCol], globalId);\n          }\n        }\n      }\n    }\n  `;\n}\n\nexport function makeMatMulVectorSourceWgsl(\n    workGroupSize: [number, number, number]): string {\n  return `\n    let TileSize = ${workGroupSize[0] * 4}u;\n    var<workgroup> mm_Asub : array<vec4<f32>, ${workGroupSize[0]}>;\n\n    ${getMainHeaderStringWgsl()} {\n      let tileCol = localId.x;\n      let globalCol = globalId.x;\n      let globalRow = globalId.y;\n\n      let numTiles = (uniforms.dimInner - 1u) / TileSize + 1u;\n\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0u; t < numTiles; t = t + 1u) {\n        // Load one tile of A into local memory.\n        let colA = t * TileSize + tileCol * 4u;\n        mm_Asub[tileCol] = vec4<f32>(mm_readA(globalRow, colA, globalId),\n                                mm_readA(globalRow, colA + 1u, globalId),\n                                mm_readA(globalRow, colA + 2u, globalId),\n                                mm_readA(globalRow, colA + 3u, globalId));\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0u; k < TileSize / 4u; k = k + 1u) {\n          let rowB = t * TileSize + k * 4u;\n          let BCached = vec4<f32>(mm_readB(rowB, globalCol, globalId),\n                              mm_readB(rowB + 1u, globalCol, globalId),\n                              mm_readB(rowB + 2u, globalCol, globalId),\n                              mm_readB(rowB + 3u, globalCol, globalId));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      if (globalRow < uniforms.dimAOuter && globalCol < uniforms.dimBOuter) {\n        mm_write(globalRow, globalCol, acc, globalId);\n      }\n    }\n  `;\n}\n\nexport class MatMulPackedProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  workPerThread: number;\n  variableNames = ['A', 'B'];\n  uniformsWgsl = `dimAOuter : u32; dimBOuter : u32; dimInner : u32;`;\n  workGroupSize: [number, number, number] = [16, 16, 1];\n  useWgsl: boolean;\n  aShape: [number, number, number];\n  transposeA: boolean;\n  transposeB: boolean;\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  fitA: boolean;\n  fitB: boolean;\n\n  constructor(\n      aShape: [number, number, number], outputShape: [number, number, number],\n      workPerThread: number, transposeA = false, transposeB = false,\n      bias: TensorInfo = null, activation: backend_util.Activation = null,\n      preluActivationWeights: TensorInfo = null) {\n    this.outputShape = outputShape;\n    this.dispatchLayout = {x: [2], y: [1], z: [0]};\n    const dimInner = transposeA ? aShape[1] : aShape[2];\n    this.workGroupSize =\n        computeWorkGroupSizeForMatMul(outputShape[1], dimInner, outputShape[2]);\n    if (outputShape[1] === 1 || outputShape[2] === 1) {\n      workPerThread = 1;\n    }\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [workPerThread, workPerThread, 1]);\n    // If dispaching number is one, it means only one work group is running.\n    // For modern GPUs, it supports multiple work groups running in parallel.\n    // So there may be some idle hardware threads.\n    // In this case, we prefer to reduce the work per thread and improve the\n    // thread utilization\n    if (util.arraysEqual(this.dispatch, [1, 1, 1])) {\n      workPerThread = 1;\n      this.dispatch = computeDispatch(\n          this.dispatchLayout, this.outputShape, this.workGroupSize,\n          [workPerThread, workPerThread, 1]);\n    }\n    const addBias = bias != null;\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.workPerThread = workPerThread;\n    this.aShape = aShape;\n    this.transposeA = transposeA;\n    this.transposeB = transposeB;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n    this.useWgsl = getUseWgsl();\n\n    const dimBOuter = this.outputShape[2];\n    const bShape = this.transposeB ?\n        [this.outputShape[0], dimBOuter, dimInner] :\n        [this.outputShape[0], dimInner, dimBOuter];\n\n    [this.fitA, this.fitB] = this.getShapeFit(bShape);\n    this.shaderKey = `matMulPacked_${this.workPerThread}_${transposeA}_${\n        transposeB}_${this.activation}_${this.fitA}_${this.fitB}_${\n        this.outputShape[1] > 1}`;\n  }\n\n  getShapeFit(bShape: number[]): boolean[] {\n    const tileAOuter = this.workGroupSize[1] * this.workPerThread;\n    const tileBOuter = this.workGroupSize[0] * this.workPerThread;\n    let tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;\n    if (this.outputShape[1] === 1) {\n      tileInner *= 4;\n    }\n    util.assert(\n        tileInner % this.workGroupSize[0] === 0 &&\n            tileInner % this.workGroupSize[1] === 0,\n        () => `tileInner must be multiple of workgroupsize.x ` +\n            `and workgroupsize.y`);\n    const tileSizeA = [tileAOuter, tileInner];\n    const tileSizeB = [tileInner, tileBOuter];\n\n    return [\n      tilesFitEvenlyIntoShape(tileSizeA, this.aShape.slice(1)),\n      tilesFitEvenlyIntoShape(tileSizeB, bShape.slice(1))\n    ];\n  }\n\n  getUserCode(): string {\n    let sampleA;\n\n    if (this.transposeA === false) {\n      sampleA = this.fitA ?\n          `A[batch * batchASize + row * dimInner + col]` :\n          `coordsInBounds(ivec2(row, col), ivec2(dimAOuter, dimInner)) ?\n            A[batch * batchASize + row * dimInner + col] : 0`;\n    } else {\n      sampleA = this.fitA ?\n          `A[batch * batchASize + col * dimAOuter + row]` :\n          `coordsInBounds(ivec2(row, col), ivec2(dimAOuter, dimInner)) ?\n            A[batch* batchASize + col * dimAOuter + row] : 0`;\n    }\n\n    let sampleB;\n    if (this.transposeB === false) {\n      sampleB = this.fitB ?\n          `B[batch * batchBSize + row * dimBOuter + col]` :\n          `coordsInBounds(ivec2(row, col), ivec2(dimInner, dimBOuter)) ?\n            B[batch * batchBSize + row * dimBOuter + col] : 0`;\n    } else {\n      sampleB = this.fitB ?\n          `B[batch * batchBSize + col * dimInner + row]` :\n          `coordsInBounds(ivec2(row, col), ivec2(dimInner, dimBOuter)) ?\n            B[batch * batchBSize + col * dimInner + row] : 0`;\n    }\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp =\n          mapActivationToShaderProgram(this.activation, false, this.useWgsl);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a, ivec3 outCoord) {\n              float b = getPreluActivationWeightsAtOutCoords(outCoord);\n              ${activationOp}\n            }`;\n      } else {\n        activationSnippet = `\n              float activation(float a, ivec3 outCoord) {\n                ${activationOp}\n              }\n            `;\n      }\n\n      applyActivationSnippet = 'value = activation(value, outCoord);';\n    }\n\n    const addBiasSnippet =\n        this.addBias ? 'value += getBiasAtOutCoords(outCoord);' : '';\n\n    const userCode = `\n      ${activationSnippet}\n\n      int dimAOuter = ${this.transposeA === true ? `aShape[2]` : `aShape[1]`};\n      int dimInner = ${this.transposeA === true ? `aShape[1]` : `aShape[2]`};\n      int dimBOuter = ${this.transposeB === true ? `bShape[1]` : `bShape[2]`};\n\n      int batch;\n\n      ${\n        this.outputShape[1] > 1 ?\n            makeMatMulPackedSource(\n                [this.workPerThread, this.workPerThread, 1]) :\n            makeMatMulVectorSource()}\n      float mm_readA(int row, int col) {\n        int batchASize = aShape[1] * aShape[2];\n        return ${sampleA};\n      }\n      float mm_readB(int row, int col) {\n        int batchBSize = bShape[1] * bShape[2];\n        return ${sampleB};\n      }\n      void mm_write(int row, int col, float value) {\n        ivec3 outCoord = ivec3(batch, row, col);\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(batch, row, col, value);\n      }\n      void main() {\n        batch = int(gl_GlobalInvocationID.z);\n        mm_matMul(dimAOuter, dimInner, dimBOuter);\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let sampleA;\n\n    if (this.transposeA === false) {\n      sampleA = this.fitA ?\n          `return A.numbers[batch * batchASize + row * uniforms.dimInner + col];` :\n          `if(coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimAOuter, uniforms.dimInner))) {\n             return A.numbers[batch * batchASize + row * uniforms.dimInner + col];\n           }\n           return 0.0;`;\n    } else {\n      sampleA = this.fitA ?\n          `return A.numbers[batch * batchASize + col * uniforms.dimAOuter + row];` :\n          `if(coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimAOuter, uniforms.dimInner))) {\n             return A.numbers[batch* batchASize + col * uniforms.dimAOuter + row];\n           }\n           return 0.0;`;\n    }\n\n    let sampleB;\n    if (this.transposeB === false) {\n      sampleB = this.fitB ?\n          `return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];` :\n          `if(coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col];\n           }\n           return 0.0;`;\n    } else {\n      sampleB = this.fitB ?\n          `return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];` :\n          `if(coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimInner, uniforms.dimBOuter))) {\n             return B.numbers[batch * batchBSize + col * uniforms.dimInner + row];\n           }\n           return 0.0;`;\n    }\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp =\n          mapActivationToShaderProgram(this.activation, false, this.useWgsl);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet =\n            `fn activation(a : f32, outCoord : vec3<u32>) -> f32 {\n               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n               ${activationOp}\n            }`;\n      } else {\n        activationSnippet = `\n              fn activation(a : f32, outCoord : vec3<u32>) -> f32 {\n                ${activationOp}\n              }\n            `;\n      }\n\n      applyActivationSnippet = 'value = activation(value, outCoord);';\n    }\n\n    const addBiasSnippet = this.addBias ?\n        'value = value + getBiasAtOutCoordsByCoords(outCoord);' :\n        '';\n\n    const userCode = `\n      ${activationSnippet}\n\n      fn mm_readA(row : u32, col : u32,  globalId : vec3<u32>) -> f32 {\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n        let batch = globalId.z;\n        ${sampleA}\n      }\n\n      fn mm_readB(row : u32, col : u32,  globalId : vec3<u32>) -> f32 {\n        let batch = globalId.z;\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n        ${sampleB}\n      }\n\n      fn mm_write(row : u32, col : u32, valueIn : f32, globalId : vec3<u32>) {\n        var value = valueIn;\n        let batch = globalId.z;\n        let outCoord = vec3<u32>(batch, row, col);\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        setOutput(batch, row, col, value);\n      }\n      ${\n        this.outputShape[1] > 1 ?\n            makeMatMulPackedSourceWgsl(\n                [this.workPerThread, this.workPerThread, 1],\n                this.workGroupSize) :\n            makeMatMulVectorSourceWgsl(this.workGroupSize)}\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, TensorInfo, util} from '@tensorflow/tfjs-core';\nimport {getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {mapActivationToShaderProgram} from './activation_util';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport function makeMatMulSmallOutputSizeSource(): string {\n  return `\n  float mm_readA(int row, int col);\n  float mm_readB(int row, int col);\n  void mm_write(int row, int col, float value);\n  const int TileAOuter = int(gl_WorkGroupSize.y / 2);\n  const int TileBOuter = int(gl_WorkGroupSize.x);\n  const int TileInner = TileAOuter > TileBOuter ? TileAOuter : TileBOuter;\n\n  shared float mm_Asub1[TileAOuter][TileInner];\n  shared float mm_Bsub1[TileInner][TileBOuter];\n  shared float mm_Asub2[TileAOuter][TileInner];\n  shared float mm_Bsub2[TileInner][TileBOuter];\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Introduces two shared memory buffers, some logical threads could handle\n  // arithmetic operations and others handle IO operations between barrier api,\n  // makes ALUs and load/store units work simultaneously, could improves\n  // the performance.\n  void mm_matMul(int dimAOuter, int dimInner, int dimBOuter) {\n    int tileRow = int(gl_LocalInvocationID.y);\n    int tileCol = int(gl_LocalInvocationID.x);\n    int globalRow = int(gl_GlobalInvocationID.y);\n    int globalCol = int(gl_GlobalInvocationID.x);\n\n    int numTiles = (dimInner - 1) / TileInner + 1;\n    float acc = 0.0;\n\n    int globalColA = tileCol;\n    int globalRowB = tileRow;\n    int tileColA = int(gl_LocalInvocationID.x);\n    int tileRowB = int(gl_LocalInvocationID.y);\n    for (int t = 0; t < numTiles; t++) {\n      if (t == 0) {\n        if (tileRow < TileAOuter) {\n          // Load one tile of A and B into local memory.\n          mm_Asub1[tileRow][tileColA] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA);\n          globalColA += TileInner;\n          mm_Bsub1[tileRowB][tileCol] = mm_readB(globalRowB, globalCol);\n          globalRowB += TileInner;\n        }\n      } else {\n        if (tileRow < TileAOuter) {\n          // Load one tile of A and B into local memory.\n          mm_Asub1[tileRow][tileColA] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA);\n          globalColA += TileInner;\n          mm_Bsub1[tileRowB][tileCol] = mm_readB(globalRowB, globalCol);\n          globalRowB += TileInner;\n        } else {\n          // Compute acc values for a single thread.\n          for (int k = 0; k < TileInner; k++) {\n            acc += mm_Asub2[tileRow - TileAOuter][k] * mm_Bsub2[k][tileCol];\n          }\n        }\n      }\n      barrier();\n      if (t != 0) {\n        t++;\n      }\n\n      if (t < numTiles) {\n        if (tileRow < TileAOuter) {\n          // Load one tile of A and B into local memory.\n          mm_Asub2[tileRow][tileColA] =\n              mm_readA((globalRow - tileRow) / 2 + tileRow, globalColA);\n          globalColA += TileInner;\n          mm_Bsub2[tileRowB][tileCol] = mm_readB(globalRowB, globalCol);\n          globalRowB += TileInner;\n        } else {\n          // Compute acc values for a single thread.\n          for (int k = 0; k < TileInner; k++) {\n            acc += mm_Asub1[tileRow - TileAOuter][k] * mm_Bsub1[k][tileCol];\n          }\n        }\n      }\n      barrier();\n    }\n    if (tileRow >= TileAOuter) {\n      mm_write((globalRow - tileRow) / 2 + tileRow - TileAOuter,\n          globalCol, acc);\n    }\n  }\n  `;\n}\n\nexport function makeMatMulSmallOutputSizeSourceWgsl(\n    workGroupSize: [number, number, number]): string {\n  const tileAOuter = workGroupSize[1] / 2;\n  const tileBOuter = workGroupSize[0];\n  const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;\n  return `\n  var<workgroup> mm_Asub1 : array<array<f32, ${tileInner}>, ${tileAOuter}>;\n  var<workgroup> mm_Bsub1 : array<array<f32, ${tileBOuter}>, ${tileInner}>;\n  var<workgroup> mm_Asub2 : array<array<f32, ${tileInner}>, ${tileAOuter}>;\n  var<workgroup> mm_Bsub2 : array<array<f32, ${tileBOuter}>, ${tileInner}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Introduces two shared memory buffers, some logical threads could handle\n  // arithmetic operations and others handle IO operations between barrier api,\n  // makes ALUs and load/store units work simultaneously, could improves\n  // the performance.\n  ${getMainHeaderStringWgsl()} {\n    let tileRow = localId.y;\n    let tileCol = localId.x;\n    let globalRow = globalId.y;\n    let globalCol = globalId.x;\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1u) / ${tileInner}u + 1u;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = tileRow;\n    for (var t = 0u; t < numTiles; t = t + 1u) {\n      if (t == 0u) {\n        if (tileRow < ${tileAOuter}u) {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub1[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2u + tileRow, globalColA, globalId);\n          globalColA = globalColA + ${tileInner}u;\n          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + ${tileInner}u;\n        }\n      } else {\n        if (tileRow < ${tileAOuter}u) {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub1[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2u + tileRow, globalColA, globalId);\n          globalColA = globalColA + ${tileInner}u;\n          mm_Bsub1[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + ${tileInner}u;\n        } else {\n          // Compute acc values for a single thread.\n          for (var k = 0u; k < ${tileInner}u; k = k + 1u) {\n            let subRow = i32(tileRow - ${tileAOuter}u);\n            if (subRow < 0) {\n              continue;\n            }\n            acc = acc + mm_Asub2[u32(subRow)][k] * mm_Bsub2[k][tileCol];\n          }\n        }\n      }\n      workgroupBarrier();\n      if (t != 0u) {\n        t = t + 1u;\n      }\n\n      if (t < numTiles) {\n        if (tileRow < ${tileAOuter}u) {\n          // Load one tile of A and B into local memory.\n          // globalRow is always greater than or equal tileRow.\n          mm_Asub2[tileRow][tileCol] =\n              mm_readA((globalRow - tileRow) / 2u + tileRow, globalColA, globalId);\n          globalColA = globalColA + ${tileInner}u;\n          mm_Bsub2[tileRow][tileCol] = mm_readB(globalRowB, globalCol, globalId);\n          globalRowB = globalRowB + ${tileInner}u;\n        } else {\n          // Compute acc values for a single thread.\n          for (var k = 0u; k < ${tileInner}u; k = k + 1u) {\n            let subRow = i32(tileRow - ${tileAOuter}u);\n            if (subRow < 0) {\n              continue;\n            }\n            acc = acc + mm_Asub1[u32(subRow)][k] * mm_Bsub1[k][tileCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    let writeCol = i32((globalRow - tileRow) / 2u + tileRow - ${tileAOuter}u);\n    if (tileRow >= ${tileAOuter}u && writeCol >= 0) {\n      mm_write(u32(writeCol), globalCol, acc, globalId);\n    }\n  }\n  `;\n}\n\nexport class MatMulSmallOutputSizeProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A', 'B'];\n  uniformsWgsl = `dimAOuter : u32; dimBOuter : u32; dimInner : u32;`;\n  workGroupSize: [number, number, number] = [8, 16, 1];\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  useWgsl: boolean;\n\n  constructor(\n      aShape: [number, number, number], bShape: [number, number, number],\n      outputShape: [number, number, number], bias: TensorInfo = null,\n      activation: backend_util.Activation = null,\n      preluActivationWeights: TensorInfo = null) {\n    util.assert(\n        aShape[1] <= 16 || bShape[2] <= 16,\n        () => 'This program can be only used when A width is small.');\n    this.outputShape = outputShape;\n\n    this.dispatchLayout = {x: [2], y: [1], z: [0]};\n    this.dispatch = [\n      Math.ceil(outputShape[2] / this.workGroupSize[0]),\n      Math.ceil(outputShape[1] * 2 / this.workGroupSize[1]), outputShape[0]\n    ];\n\n    const addBias = bias != null;\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    const hasPreluActivationWeights = preluActivationWeights != null;\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n    this.shaderKey = `matMulSmallOutputSize_${this.activation}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const sampleA =\n        `coordsInBounds(ivec2(row, col), ivec2(dimAOuter, dimInner)) ?\n            A[batch * batchASize + row * dimInner + col] : 0`;\n\n    const sampleB =\n        `coordsInBounds(ivec2(row, col), ivec2(dimInner, dimBOuter)) ?\n            B[batch * batchBSize + row * dimBOuter + col] : 0`;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(this.activation);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a, ivec3 outCoord) {\n            float b = getPreluActivationWeightsAtOutCoords(outCoord);\n            ${activationOp}\n            }`;\n      } else {\n        activationSnippet = `float activation(float a, ivec3 outCoord) {\n            ${activationOp}\n        }`;\n      }\n\n      applyActivationSnippet = 'value = activation(value, outCoord);';\n    }\n\n    const addBiasSnippet =\n        this.addBias ? 'value += getBiasAtOutCoords(outCoord);' : '';\n\n    const userCode = `\n      ${activationSnippet}\n\n      int dimAOuter = aShape[1];\n      int dimInner = aShape[2];\n      int dimBOuter = bShape[2];\n      int batch;\n      ${makeMatMulSmallOutputSizeSource()}\n      float mm_readA(int row, int col) {\n        int batchASize = aShape[1] * aShape[2];\n        return ${sampleA};\n      }\n      float mm_readB(int row, int col) {\n        int batchBSize = bShape[1] * bShape[2];\n        return ${sampleB};\n      }\n      void mm_write(int row, int col, float value) {\n        if (coordsInBounds(ivec2(row, col), ivec2(dimAOuter, dimBOuter))) {\n          ivec3 outCoord = ivec3(batch, row, col);\n          ${addBiasSnippet}\n          ${applyActivationSnippet}\n          setOutput(batch, row, col, value);\n        }\n      }\n      void main() {\n        batch = int(gl_GlobalInvocationID.z);\n        mm_matMul(dimAOuter, dimInner, dimBOuter);\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const sampleA =\n        `if (coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimAOuter, uniforms.dimInner))) {\n          return A.numbers[batch * batchASize + row * uniforms.dimInner + col]; \n        } \n        return 0.0;`;\n\n    const sampleB =\n        `if (coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return B.numbers[batch * batchBSize + row * uniforms.dimBOuter + col]; \n         }\n         return 0.0;`;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp =\n          mapActivationToShaderProgram(this.activation, false, true);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet =\n            `fn activation(a : f32, outCoord : vec3<u32>) -> f32 {\n            let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n            ${activationOp}\n            }`;\n      } else {\n        activationSnippet =\n            `fn activation(a : f32, outCoord : vec3<u32>) -> f32 {\n            ${activationOp}\n        }`;\n      }\n\n      applyActivationSnippet = 'value = activation(value, outCoord);';\n    }\n\n    const addBiasSnippet = this.addBias ?\n        'value = value + getBiasAtOutCoordsByCoords(outCoord);' :\n        '';\n\n    const userCode = `\n      ${activationSnippet}\n      \n      fn mm_readA(row : u32, col : u32,  globalId : vec3<u32>) -> f32 {\n        let batchASize = uniforms.aShape[1] * uniforms.aShape[2];\n        let batch = globalId.z;\n        ${sampleA}\n      }\n      fn mm_readB(row : u32, col : u32,  globalId : vec3<u32>) -> f32 {\n        let batch = globalId.z;\n        let batchBSize = uniforms.bShape[1] * uniforms.bShape[2];\n        ${sampleB}\n      }\n      fn mm_write(row : u32, col : u32, valueIn : f32, globalId : vec3<u32>) {\n        if (coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimAOuter, uniforms.dimBOuter))) {\n          let batch = globalId.z;\n          let outCoord = vec3<u32>(batch, row, col);\n          var value = valueIn;\n          ${addBiasSnippet}\n          ${applyActivationSnippet}\n          setOutput(batch, row, col, value);\n        }\n      }\n      ${makeMatMulSmallOutputSizeSourceWgsl(this.workGroupSize)}\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Reshape, ReshapeAttrs, ReshapeInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nexport function reshape(\n    args: {inputs: ReshapeInputs, backend: WebGPUBackend, attrs: ReshapeAttrs}):\n    TensorInfo {\n  const {inputs, attrs} = args;\n  const {x} = inputs;\n  const {shape} = attrs;\n\n  const xSize = util.sizeFromShape(x.shape);\n  const $shape = util.inferFromImplicitShape(shape, xSize);\n  const $xSize = util.sizeFromShape($shape);\n\n  util.assert(\n      xSize === $xSize,\n      () => `The new shape (${$shape}) has ${$xSize} elements and the old ` +\n          `shape (${x.shape}) has ${xSize} elements. The new shape and old ` +\n          `shape must have the same number of elements.`);\n\n  // Backend needs to track refCount for the dataId for reshape op\n  args.backend.incRef(x.dataId);\n  return {dataId: x.dataId, shape: $shape, dtype: x.dtype};\n}\n\nexport const reshapeConfig: KernelConfig = {\n  kernelName: Reshape,\n  backendName: 'webgpu',\n  kernelFunc: reshape as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {MatMulPackedVec4Program} from './matmul_packed_vec4_webgpu';\nimport {MatMulPackedProgram} from './matmul_packed_webgpu';\nimport {MatMulSmallOutputSizeProgram} from './matmul_small_output_size_webgpu';\nimport {reshape} from './Reshape';\nimport {WebGPUProgram} from './webgpu_program';\n\ntype BatchMatMulConfig = {\n  a: TensorInfo,\n  b: TensorInfo,\n  transposeA: boolean,\n  transposeB: boolean,\n  backend: WebGPUBackend,\n  bias?: TensorInfo,\n  preluActivationWeights?: TensorInfo,\n  leakyreluAlpha?: number,\n  activation?: backend_util.Activation\n};\n\nexport function batchMatMulImpl({\n  a,\n  b,\n  transposeA,\n  transposeB,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: BatchMatMulConfig): TensorInfo {\n  const aRank = a.shape.length;\n  const bRank = b.shape.length;\n\n  const innerShapeA = transposeA ? a.shape[aRank - 2] : a.shape[aRank - 1];\n  const innerShapeB = transposeB ? b.shape[bRank - 1] : b.shape[bRank - 2];\n\n  const outerShapeA = transposeA ? a.shape[aRank - 1] : a.shape[aRank - 2];\n  const outerShapeB = transposeB ? b.shape[bRank - 2] : b.shape[bRank - 1];\n\n  const outerDimsA = a.shape.slice(0, -2);\n  const outerDimsB = b.shape.slice(0, -2);\n\n  const batchDimA = util.sizeFromShape(outerDimsA);\n  const batchDimB = util.sizeFromShape(outerDimsB);\n\n  const batchDimsCompatible =\n      batchDimA === batchDimB || batchDimA === 1 || batchDimB === 1;\n\n  util.assert(\n      aRank >= 2 && bRank >= 2 && batchDimsCompatible,\n      () => `Error in matMul: the input batch dimensions must either be the ` +\n          `same or at least one input batch dimension must be 1. Got input ` +\n          `batch dimensions of (${outerDimsA}) and (${outerDimsB}).`);\n\n  const outShapeOuterDims =\n      batchDimA > batchDimB ? a.shape.slice(0, -2) : b.shape.slice(0, -2);\n  const outShape = outShapeOuterDims.concat([outerShapeA, outerShapeB]);\n\n  util.assert(\n      innerShapeA === innerShapeB,\n      () => `Error in matMul: inner shapes (${innerShapeA}) and (` +\n          `${innerShapeB}) of Tensors with shapes ${a.shape} and ` +\n          `${b.shape} and transposeA=${transposeA}` +\n          ` and transposeB=${transposeB} must match.`);\n\n  const a3dShape: [number, number, number] = transposeA ?\n      [batchDimA, innerShapeA, outerShapeA] :\n      [batchDimA, outerShapeA, innerShapeA];\n  const b3dShape: [number, number, number] = transposeB ?\n      [batchDimB, outerShapeB, innerShapeB] :\n      [batchDimB, innerShapeB, outerShapeB];\n\n  // The rest of the implementation is designed to operate on rank-3 tensors\n  const a3d = reshape({inputs: {x: a}, backend, attrs: {shape: a3dShape}});\n  const b3d = reshape({inputs: {x: b}, backend, attrs: {shape: b3dShape}});\n  const intermediates: TensorInfo[] = [a3d, b3d];\n\n  const batchDim = Math.max(batchDimA, batchDimB);\n\n  const useVec4 = a.shape[2] % 4 === 0 && b.shape[2] % 4 === 0 && !transposeA &&\n      !transposeB && outerShapeB >= 32;\n  let program: WebGPUProgram;\n  let dimensions = null;\n\n  // When the output size is absolutely small or relatively small, we may use\n  // MatMulSmallOutputSizeProgram to get better performance.\n  // Absolutely small size means that the output size is smaller than [16, 512].\n  // Relatively small size means that one demension size of the output is\n  // smaller than 16, and the output size is also more than or equal two times\n  // smaller than each of the two input sizes. For example, if input sizes are\n  // [12, 2048] and [2048, 1024], the output size is [12, 1024], which is\n  // relatively small compared to input sizes.\n  if (!transposeA && !transposeB &&\n      ((a.shape[1] <= 16 &&\n        (b.shape[2] <= 512 || b.shape[1] >= 2 * b.shape[2])) ||\n       (b.shape[2] <= 16 &&\n        (a.shape[1] <= 512 || a.shape[2] >= 2 * a.shape[1])))) {\n    program = new MatMulSmallOutputSizeProgram(\n        a3dShape, b3dShape, [batchDim, outerShapeA, outerShapeB], bias,\n        activation, preluActivationWeights);\n  } else if (useVec4) {\n    // TODO: Currently we need to make sure that a.shape[2] and b.shape[2]\n    // are divisible by 4 since we use vec4 to get data. In future, we can\n    // remove this limitation by insert 0 to pack data.\n    program = new MatMulPackedVec4Program(\n        a3dShape, [batchDim, outerShapeA, outerShapeB],\n        env().get('WEBGPU_MATMUL_WORK_PER_THREAD') as number, bias, activation,\n        preluActivationWeights);\n  } else {\n    program = new MatMulPackedProgram(\n        a3dShape, [batchDim, outerShapeA, outerShapeB],\n        env().get('WEBGPU_MATMUL_WORK_PER_THREAD') as number, transposeA,\n        transposeB, bias, activation, preluActivationWeights);\n  }\n  const inputs: TensorInfo[] = [a3d, b3d];\n  if (bias) {\n    inputs.push(bias);\n  }\n  if (preluActivationWeights) {\n    inputs.push(preluActivationWeights);\n  }\n  if (program.useWgsl) {\n    const dimAOuter = transposeA === true ? a3d.shape[2] : a3d.shape[1];\n    const dimInner = transposeA === true ? a3d.shape[1] : a3d.shape[2];\n    const dimBOuter = transposeB === true ? b3d.shape[1] : b3d.shape[2];\n    dimensions = [\n      {type: 'uint32', data: [dimAOuter]}, {type: 'uint32', data: [dimBOuter]},\n      {type: 'uint32', data: [dimInner]}\n    ];\n  }\n  const out = backend.runWebGPUProgram(program, inputs, a.dtype, dimensions);\n  const outReshaped =\n      reshape({inputs: {x: out}, backend, attrs: {shape: outShape}});\n  intermediates.push(out);\n  for (const i of intermediates) {\n    backend.disposeData(i.dataId);\n  }\n  return outReshaped;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {_FusedMatMul, _FusedMatMulAttrs, _FusedMatMulInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {batchMatMulImpl} from './BatchMatMul_impl';\n\nexport function _fusedMatMul(args: {\n  inputs: _FusedMatMulInputs,\n  attrs: _FusedMatMulAttrs,\n  backend: WebGPUBackend\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b, bias, preluActivationWeights} = inputs;\n  const {transposeA, transposeB, activation, leakyreluAlpha} = attrs;\n\n  return batchMatMulImpl({\n    a,\n    b,\n    transposeA,\n    transposeB,\n    backend,\n    bias,\n    preluActivationWeights,\n    leakyreluAlpha,\n    activation\n  });\n}\n\nexport const _fusedMatMulConfig: KernelConfig = {\n  kernelName: _FusedMatMul,\n  backendName: 'webgpu',\n  kernelFunc: _fusedMatMul as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\nimport {BinaryOpType, getBinaryOpString} from './binary_op_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class BinaryOpComplexProgram implements WebGPUProgram {\n  variableNames = ['AReal', 'AImag', 'BReal', 'BImag'];\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number] = [128, 1, 1];\n  op: BinaryOpType;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(op: BinaryOpType, aShape: number[], bShape: number[]) {\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.shaderKey = `binaryOpComplex_${op}`;\n    this.op = op;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const opStr = getBinaryOpString(this.op);\n    const userCode = `\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${opStr}\n      }\n\n      void main() {\n        int index = getGlobalIndex();\n        if(index < size) {\n          float areal = getARealAtOutCoords();\n          float aimag = getAImagAtOutCoords();\n          float breal = getBRealAtOutCoords();\n          float bimag = getBImagAtOutCoords();\n          setOutput(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const opStr = getBinaryOpString(this.op, false, true);\n    const userCode = `\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${opStr}\n      }\n\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if(index < uniforms.size) {\n          let areal = getARealAtOutCoordsByGlobalId(globalId, index);\n          let aimag = getAImagAtOutCoordsByGlobalId(globalId, index);\n          let breal = getBRealAtOutCoordsByGlobalId(globalId, index);\n          let bimag = getBImagAtOutCoordsByGlobalId(globalId, index);\n          setOutputFlat(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\nimport {BinaryOpType, getBinaryOpString} from './binary_op_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class BinaryOpSharedProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A', 'B'];\n  workPerThread: number;\n  workGroupSize: [number, number, number];\n  useSharedMemoryWithB: boolean;\n  lastDimensionSize: number;\n  op: BinaryOpType;\n  useWgsl: boolean;\n  size: number;\n  sizeFit: boolean;\n\n  constructor(\n      op: BinaryOpType, aShape: number[], bShape: number[],\n      useSharedMemoryWithB: boolean) {\n    // This is an experimental value when using shared memory.\n    // Note that the maximum of workgroup X dimension is 256.\n    const workGroupSizeX = 256;\n    this.workGroupSize = [workGroupSizeX, 1, 1];\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.lastDimensionSize = useSharedMemoryWithB ? bShape[0] : aShape[0];\n    if (this.lastDimensionSize < 256) {\n      this.workPerThread = 1;\n    } else if (this.lastDimensionSize < 512) {\n      this.workPerThread = 2;\n    } else {\n      this.workPerThread = 4;\n    }\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n\n    this.useSharedMemoryWithB = useSharedMemoryWithB;\n    this.op = op;\n    this.useWgsl = getUseWgsl();\n    this.size = util.sizeFromShape(this.outputShape);\n    this.sizeFit =\n        this.size % (this.workGroupSize[0] * this.workPerThread) === 0;\n    // this.lastDimensionSize is used as sharedBuf array size, so can not be\n    // used as uniform.\n    this.shaderKey = `binaryShared_${op}_${this.lastDimensionSize}_${\n        this.useSharedMemoryWithB}_${this.sizeFit}`;\n  }\n\n  getUserCode(): string {\n    const type = getCoordsDataType(this.outputShape.length);\n    const sharedIndexSnippet = this.lastDimensionSize > 1 ?\n        `coords[${this.outputShape.length - 1}]` :\n        '0';\n    const accessDataSnippet = this.useSharedMemoryWithB ?\n        `float a = getAAtOutCoords(coords);\n         float b = sharedBuf[${sharedIndexSnippet}];` :\n        `float a = sharedBuf[${sharedIndexSnippet}];\n         float b = getBAtOutCoords(coords);`;\n\n    const writeDataSnippet = this.sizeFit ?\n        `${type} coords = getCoordsFromFlatIndex(flatIndex);\n\n         ${accessDataSnippet}\n         setOutput(flatIndex, binaryOperation(a, b));` :\n        `if(flatIndex < size) {\n            ${type} coords = getCoordsFromFlatIndex(flatIndex);\n\n            ${accessDataSnippet}\n            setOutput(flatIndex, binaryOperation(a, b));\n          }`;\n    const opStr = getBinaryOpString(this.op);\n    const userCode = `\n        float binaryOperation(float a, float b) {\n          ${opStr}\n        }\n\n        shared float sharedBuf[${this.lastDimensionSize}];\n        void main() {\n          int index = getGlobalIndex();\n          int localIndex = int(gl_LocalInvocationIndex);\n\n          // Fill in the shared memory buffer. Here we need a loop to make sure\n          // that all data in A|B are uploaded when |sharedMemorySize| is larger\n          // than work group size.\n          while(localIndex < ${this.lastDimensionSize})\n          {\n            sharedBuf[localIndex] = ${\n        this.useSharedMemoryWithB ? 'B' : 'A'}[localIndex];\n            localIndex += int(gl_WorkGroupSize.x);\n          }\n          barrier();\n\n          for(int i = 0; i < ${this.workPerThread}; i++) {\n            int flatIndex = index * ${this.workPerThread} + i;\n\n            ${writeDataSnippet}\n          }\n        }\n        `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const sharedIndexSnippet = this.lastDimensionSize > 1 ?\n        `coords[${this.outputShape.length - 1}]` :\n        '0';\n    const accessDataSnippet = this.useSharedMemoryWithB ?\n        `let a = getAAtOutCoordsByCoords(coords);\n         let b = sharedBuf[${sharedIndexSnippet}];` :\n        `let a = sharedBuf[${sharedIndexSnippet}];\n         let b = getBAtOutCoordsByCoords(coords);`;\n\n    const writeDataSnippet = this.sizeFit ?\n        `let coords = getCoordsFromFlatIndex(flatIndex);\n\n         ${accessDataSnippet}\n         setOutputFlat(flatIndex, binaryOperation(a, b));` :\n        `if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(flatIndex);\n\n            ${accessDataSnippet}\n            setOutputFlat(flatIndex, binaryOperation(a, b));\n          }`;\n    const opStr = getBinaryOpString(this.op, false, this.useWgsl);\n    const userCode = `\n        fn binaryOperation(a : f32, b : f32) -> f32 {\n          ${opStr}\n        }\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${getMainHeaderStringWgsl()} {\n          ${getGlobalIndexStringWgsl()}\n\n          // Fill in the shared memory buffer. Here we need a loop to make sure\n          // that all data in A|B are uploaded when |sharedMemorySize| is larger\n          // than work group size.\n          for(var localIndex = localId.x; localIndex < ${\n        this.lastDimensionSize}u; localIndex = localIndex + ${\n        this.workGroupSize[0]}u) {\n            sharedBuf[localIndex] = f32(${\n        this.useSharedMemoryWithB ? 'B' : 'A'}.numbers[localIndex]);\n          }\n          workgroupBarrier();\n\n          for(var i = 0u; i < ${this.workPerThread}u; i = i + 1u) {\n            let flatIndex = index * ${this.workPerThread}u + i;\n\n            ${writeDataSnippet}\n          }\n        }\n        `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\nimport {BinaryOpType, getBinaryOpString} from './binary_op_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class BinaryOpVec4Program implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A', 'B'];\n  workPerThread = 4;\n  workGroupSize: [number, number, number];\n  isVec4 = true;\n  useWgsl: boolean;\n  op: BinaryOpType;\n  size: number;\n  fitShape: boolean;\n\n  constructor(op: BinaryOpType, aShape: number[], bShape: number[]) {\n    // TODO(jiajia.qin@intel.com): Heuristically select a good work group size.\n    const workGroupSizeX = 128;\n    this.workGroupSize = [workGroupSizeX, 1, 1];\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n    this.op = op;\n    this.fitShape = this.size % this.workGroupSize[0] === 0;\n    this.shaderKey = `binaryVec4_${op}_${this.fitShape}`;\n    this.size = util.sizeFromShape(this.outputShape) / this.workPerThread;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    let userCode: string;\n    const opStr = getBinaryOpString(this.op, this.isVec4);\n    if (this.fitShape) {\n      userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${opStr}\n      }\n\n      void main() {\n        int index = getGlobalIndex();\n        vec4 a = vec4(A[index]);\n        vec4 b = vec4(B[index]);\n        setOutput(index, binaryOperation(a, b));\n      }\n    `;\n    } else {\n      userCode = `\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${opStr}\n      }\n\n      void main() {\n        int index = getGlobalIndex();\n        if (index < size)\n        {\n          vec4 a = vec4(A[index]);\n          vec4 b = vec4(B[index]);\n          setOutput(index, binaryOperation(a, b));\n        }\n      }\n    `;\n    }\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let userCode: string;\n    const opStr = getBinaryOpString(this.op, this.isVec4, this.useWgsl);\n    const miscStr =\n        `fn binaryOperation(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {\n          ${opStr}\n        }`;\n\n    if (this.fitShape) {\n      userCode = `\n      ${miscStr}\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let a = vec4<f32>(A.numbers[index]);\n        let b = vec4<f32>(B.numbers[index]);\n        setOutputFlat(index, binaryOperation(a, b));\n      }\n    `;\n    } else {\n      userCode = `\n      ${miscStr}\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if (index < uniforms.size) {\n          let a = vec4<f32>(A.numbers[index]);\n          let b = vec4<f32>(B.numbers[index]);\n          setOutputFlat(index, binaryOperation(a, b));\n        }\n      }\n    `;\n    }\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\nimport {BinaryOpType, getBinaryOpString} from './binary_op_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class BinaryOpProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A', 'B'];\n  workPerThread: number;\n  workGroupSize: [number, number, number];\n  useWgsl: boolean;\n  op: BinaryOpType;\n  sizeFit: boolean;\n  shapesFit: boolean;\n  size: number;\n\n  constructor(op: BinaryOpType, aShape: number[], bShape: number[]) {\n    // TODO(jiajia.qin@intel.com): Heuristically select a good work group size.\n    const workGroupSizeX = 128;\n    this.workGroupSize = [workGroupSizeX, 1, 1];\n    this.outputShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.size = util.sizeFromShape(this.outputShape);\n    this.sizeFit = this.size % workGroupSizeX === 0;\n    this.shapesFit = util.arraysEqual(aShape, bShape) && this.sizeFit;\n    this.workPerThread = this.sizeFit || this.shapesFit ? 1 : 2;\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n    this.shaderKey = `binary_${op}_${this.sizeFit}_${this.shapesFit}`;\n    this.useWgsl = getUseWgsl();\n    this.op = op;\n  }\n\n  getUserCode(): string {\n    let userCode: string;\n    const opStr = getBinaryOpString(this.op);\n    if (this.shapesFit) {\n      userCode = `\n          float binaryOperation(float a, float b) {\n            ${opStr}\n          }\n\n          void main() {\n            int index = getGlobalIndex();\n\n            float a = float(A[index]);\n            float b = float(B[index]);\n            setOutput(index, binaryOperation(a, b));\n          }\n        `;\n    } else if (this.sizeFit) {\n      const type = getCoordsDataType(this.outputShape.length);\n      userCode = `\n      float binaryOperation(float a, float b) {\n        ${opStr}\n      }\n\n      void main() {\n        int index = getGlobalIndex();\n\n        ${type} coords = getCoordsFromFlatIndex(index);\n\n        float a = getAAtOutCoords(coords);\n        float b = getBAtOutCoords(coords);\n        setOutput(index, binaryOperation(a, b));\n      }\n      `;\n    } else {\n      const type = getCoordsDataType(this.outputShape.length);\n      userCode = `\n      float binaryOperation(float a, float b) {\n        ${opStr}\n      }\n\n      void main() {\n        int index = getGlobalIndex();\n\n        for(int i = 0; i < ${this.workPerThread}; i++) {\n          int flatIndex = index * ${this.workPerThread} + i;\n\n          if(flatIndex < size) {\n            ${type} coords = getCoordsFromFlatIndex(flatIndex);\n\n            float a = getAAtOutCoords(coords);\n            float b = getBAtOutCoords(coords);\n            setOutput(flatIndex, binaryOperation(a, b));\n          }\n        }\n      }\n      `;\n    }\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let userCode: string;\n    const opStr = getBinaryOpString(this.op, false, this.useWgsl);\n    const miscStr = `          fn binaryOperation(a : f32, b : f32) -> f32 {\n      ${opStr}\n    }`;\n    if (this.shapesFit) {\n      userCode = `\n          ${miscStr}\n          ${getMainHeaderStringWgsl()} {\n            ${getGlobalIndexStringWgsl()}\n\n            let a = f32(A[index]);\n            let b = f32(B[index]);\n            setOutputFlat(index, binaryOperation(a, b));\n          }\n        `;\n    } else if (this.sizeFit) {\n      userCode = `\n      ${miscStr}\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n\n        let coords = getCoordsFromFlatIndex(index);\n\n        let a = getAAtOutCoordsByCoords(coords);\n        let b = getBAtOutCoordsByCoords(coords);\n        setOutputFlat(index, binaryOperation(a, b));\n      }\n      `;\n    } else {\n      userCode = `\n      ${miscStr}\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        for (var i = 0u; i < ${this.workPerThread}u; i = i + 1u ) {\n          let flatIndex = index * ${this.workPerThread}u + i;\n\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(flatIndex);\n\n            let a = getAAtOutCoordsByCoords(coords);\n            let b = getBAtOutCoordsByCoords(coords);\n            setOutputFlat(flatIndex, binaryOperation(a, b));\n          }\n        }\n      }\n      `;\n    }\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\nimport {BinaryOpSharedProgram} from './binary_op_shared_webgpu';\nimport {BinaryOpVec4Program} from './binary_op_vec4_webgpu';\nimport {BinaryOpProgram} from './binary_op_webgpu';\nimport {BinaryOpType} from './binary_op_util';\n\nexport function getBinaryProgram(\n    op: BinaryOpType, aShape: number[], bShape: number[]) {\n  const useVec4 =\n      util.arraysEqual(aShape, bShape) && util.sizeFromShape(aShape) % 4 === 0;\n  if (useVec4) {\n    return new BinaryOpVec4Program(op, aShape, bShape);\n  }\n  const useSharedMemoryWithA =\n      aShape.length === 1 && bShape.length > 1 && aShape[0] < 1024;\n  const useSharedMemoryWithB =\n      bShape.length === 1 && aShape.length > 1 && bShape[0] < 1024;\n  if (useSharedMemoryWithA || useSharedMemoryWithB) {\n    return new BinaryOpSharedProgram(op, aShape, bShape, useSharedMemoryWithB);\n  } else {\n    return new BinaryOpProgram(op, aShape, bShape);\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Identity, IdentityInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\nimport {WebGPUBackend} from '../backend_webgpu';\n\nexport function identity(\n    args: {inputs: IdentityInputs, backend: WebGPUBackend}): TensorInfo {\n  const {inputs} = args;\n  const {x} = inputs;\n\n  args.backend.incRef(x.dataId);\n  return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};\n}\n\nexport const identityConfig: KernelConfig = {\n  kernelName: Identity,\n  backendName: 'webgpu',\n  kernelFunc: identity as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Complex, ComplexInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {identity} from './Identity';\n\n/**\n * Complex tensors share data with their real and imaginary components. Complex\n * tensors' reference to the components is tracked by refCount on the individual\n * component. The refCounts are increased by the identity call.\n *\n * When a complex tensor is disposed, it will reduce the refCount on the\n * components by calling disposeData on each.\n */\nexport function complex(args: {inputs: ComplexInputs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {real, imag} = inputs;\n\n  const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n  const complex = backend.tensorMap.get(complexInfo.dataId);\n\n  const realTensorInfo = identity({inputs: {x: real}, backend});\n\n  const imagTensorInfo = identity({inputs: {x: imag}, backend});\n\n  complex.complexTensorInfos = {real: realTensorInfo, imag: imagTensorInfo};\n\n  return complexInfo;\n}\n\nexport const complexConfig: KernelConfig = {\n  kernelName: Complex,\n  backendName: 'webgpu',\n  kernelFunc: complex as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUnaryOpString, UnaryOpType} from './unary_op_util';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class UnaryOpProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['A'];\n  workGroupSize: [number, number, number];\n  useWgsl: boolean;\n  op: UnaryOpType;\n  size: number;\n\n  constructor(outputShape: number[], op: UnaryOpType) {\n    // TODO(jiajia.qin@intel.com): Heuristically select a good work group size.\n    const workGroupSizeX = 128;\n    this.workGroupSize = [workGroupSizeX, 1, 1];\n    this.outputShape = outputShape;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n    this.useWgsl = getUseWgsl();\n    this.op = op;\n    this.shaderKey = `unary_${op}`;\n  }\n\n  getUserCode(): string {\n    return `\n      float unaryOperation(float a) {\n        ${getUnaryOpString(this.op)}\n      }\n\n      void main() {\n        int index = getGlobalIndex();\n        if (index < size)\n        {\n          float a = getAAtOutCoords();\n          setOutput(index, unaryOperation(a));\n        }\n      }\n      `;\n  }\n\n  getUserCodeWgsl(): string {\n    return `\n      fn unaryOperation(a : f32) -> f32 {\n        ${getUnaryOpString(this.op, false, true)}\n      }\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if (index < uniforms.size) {\n          let a = getAAtOutCoordsByGlobalId(globalId, index);\n          setOutputFlat(index, unaryOperation(a));\n        }\n      }\n      `;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, DataType, KernelFunc, TensorInfo, TypedArray, UnaryInputs, upcastType} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {BinaryOpComplexProgram} from '../kernels/binary_op_complex_webgpu';\nimport {getBinaryProgram} from '../kernels/binary_ops';\nimport {complex} from '../kernels/Complex';\nimport {BinaryOpType} from '../kernels/binary_op_util';\nimport {UnaryOpType} from '../kernels/unary_op_util';\nimport {UnaryOpProgram} from '../kernels/unary_op_webgpu';\n\nimport {SimpleBinaryKernelImplCPU, SimpleUnaryKernelImplCPU} from './shared';\n\ntype UnaryKernelFuncConfig = {\n  opType: UnaryOpType,\n  cpuKernelImpl?: SimpleUnaryKernelImplCPU,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param opSnippet Op snippet to create `UnaryOpProgram`.\n * @param cpuKernelImpl Optional. Shared functionality from tfjs-backend-cpu, it\n *     will be involved when necessary.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function unaryKernelFunc(\n    {opType, cpuKernelImpl, dtype}: UnaryKernelFuncConfig): KernelFunc {\n  return ({inputs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    const webgpuBackend = backend as WebGPUBackend;\n\n    const $dtype = dtype || x.dtype;\n    if (webgpuBackend.shouldExecuteOnCPU([x]) && cpuKernelImpl != null) {\n      const xData = webgpuBackend.tensorMap.get(x.dataId);\n      const outValues = cpuKernelImpl(xData.values as TypedArray, $dtype);\n      return webgpuBackend.makeTensorInfo(x.shape, $dtype, outValues);\n    }\n\n    const program: UnaryOpProgram = new UnaryOpProgram(x.shape, opType);\n    return webgpuBackend.runWebGPUProgram(program, [x], $dtype);\n  };\n}\n\ntype BinaryKernelFuncConfig = {\n  opSnippet: number,\n  cpuKernelImpl?: SimpleBinaryKernelImplCPU,\n  supportsComplex?: boolean,\n  dtype?: DataType\n};\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param opSnippet Op snippet to create `BinaryOpProgram`.\n * @param cpuKernelImpl Optional. Shared functionality from tfjs-backend-cpu, it\n *     will be involved when necessary.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(\n    {opSnippet, cpuKernelImpl, supportsComplex = false, dtype}:\n        BinaryKernelFuncConfig): KernelFunc {\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const webgpuBackend = backend as WebGPUBackend;\n\n    if (supportsComplex && a.dtype === 'complex64') {\n      const aData = webgpuBackend.tensorMap.get(a.dataId);\n      const bData = webgpuBackend.tensorMap.get(b.dataId);\n      let real: TensorInfo, imag: TensorInfo;\n      if (opSnippet !== BinaryOpType.MUL) {\n        [real, imag] = [\n          [aData.complexTensorInfos.real, bData.complexTensorInfos.real],\n          [aData.complexTensorInfos.imag, bData.complexTensorInfos.imag]\n        ].map(complexParts => {\n          const [aPart, bPart] = complexParts;\n\n          const aHandle = {\n            dataId: aPart.dataId,\n            dtype: aPart.dtype,\n            shape: a.shape\n          };\n          const bHandle = {\n            dataId: bPart.dataId,\n            dtype: bPart.dtype,\n            shape: b.shape\n          };\n\n          const program = getBinaryProgram(opSnippet, a.shape, b.shape);\n          return webgpuBackend.runWebGPUProgram(\n              program, [aHandle, bHandle],\n              upcastType(aPart.dtype, bPart.dtype));\n        });\n      } else {\n        const realProgram = new BinaryOpComplexProgram(\n            BinaryOpType.COMPLEX_MULTIPLY_REAL, a.shape, b.shape);\n        const imagProgram = new BinaryOpComplexProgram(\n            BinaryOpType.COMPLEX_MULTIPLY_IMAG, a.shape, b.shape);\n\n        const inputs = [\n          {\n            dataId: aData.complexTensorInfos.real.dataId,\n            dtype: aData.complexTensorInfos.real.dtype,\n            shape: a.shape\n          },\n          {\n            dataId: aData.complexTensorInfos.imag.dataId,\n            dtype: aData.complexTensorInfos.imag.dtype,\n            shape: a.shape\n          },\n          {\n            dataId: bData.complexTensorInfos.real.dataId,\n            dtype: bData.complexTensorInfos.real.dtype,\n            shape: b.shape\n          },\n          {\n            dataId: bData.complexTensorInfos.imag.dataId,\n            dtype: bData.complexTensorInfos.imag.dtype,\n            shape: b.shape\n          }\n        ];\n\n        real = webgpuBackend.runWebGPUProgram(realProgram, inputs, 'float32');\n        imag = webgpuBackend.runWebGPUProgram(imagProgram, inputs, 'float32');\n      }\n\n      const complexOutput =\n          complex({inputs: {real, imag}, backend: webgpuBackend});\n\n      webgpuBackend.disposeData(real.dataId);\n      webgpuBackend.disposeData(imag.dataId);\n\n      // TODO: Implement CPU forwarding for complex inputs.\n\n      return complexOutput;\n    }\n\n    const $dtype = dtype || upcastType(a.dtype, b.dtype);\n    if ((a.dtype === 'string' || b.dtype === 'string' ||\n         webgpuBackend.shouldExecuteOnCPU([a, b])) &&\n        cpuKernelImpl != null) {\n      const aData = webgpuBackend.tensorMap.get(a.dataId).values as TypedArray;\n      const bData = webgpuBackend.tensorMap.get(b.dataId).values as TypedArray;\n      const decodedAVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(aData as any as Uint8Array[]) :\n          aData;\n      const decodedBVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(bData as any as Uint8Array[]) :\n          bData;\n      const [outValues, outShape] =\n          cpuKernelImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);\n\n      return webgpuBackend.makeTensorInfo(outShape, $dtype, outValues);\n    }\n    const program = getBinaryProgram(opSnippet, a.shape, b.shape);\n    return webgpuBackend.runWebGPUProgram(program, [a, b], $dtype);\n  };\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Shared functionality among backends.\nexport {simpleAbsImpl} from './kernels/Abs';\nexport {addImpl} from './kernels/Add';\nexport {bincountImpl, bincountReduceImpl} from './kernels/Bincount_impl';\nexport {ceilImpl} from './kernels/Ceil';\nexport {concatImpl} from './kernels/Concat_impl';\nexport {equalImpl} from './kernels/Equal';\nexport {expImpl} from './kernels/Exp';\nexport {expm1Impl} from './kernels/Expm1';\nexport {floorImpl} from './kernels/Floor';\nexport {gatherNdImpl} from './kernels/GatherNd_Impl';\nexport {gatherV2Impl} from './kernels/GatherV2_impl';\nexport {greaterImpl} from './kernels/Greater';\nexport {greaterEqualImpl} from './kernels/GreaterEqual';\nexport {lessImpl} from './kernels/Less';\nexport {lessEqualImpl} from './kernels/LessEqual';\nexport {linSpaceImpl} from './kernels/LinSpace_impl';\nexport {logImpl} from './kernels/Log';\nexport {maxImpl} from './kernels/Max_impl';\nexport {maximumImpl} from './kernels/Maximum';\nexport {minimumImpl} from './kernels/Minimum';\nexport {multiplyImpl} from './kernels/Multiply';\nexport {negImpl} from './kernels/Neg';\nexport {notEqualImpl} from './kernels/NotEqual';\nexport {prodImpl} from './kernels/Prod';\nexport {rangeImpl} from './kernels/Range_impl';\nexport {rsqrtImpl} from './kernels/Rsqrt';\nexport {sigmoidImpl} from './kernels/Sigmoid';\nexport {sliceImpl} from './kernels/Slice';\nexport {sparseFillEmptyRowsImpl} from './kernels/SparseFillEmptyRows_impl';\nexport {sparseReshapeImpl} from './kernels/SparseReshape_impl';\nexport {sparseSegmentReductionImpl} from './kernels/SparseSegmentReduction_impl';\nexport {sqrtImpl} from './kernels/Sqrt';\nexport {squaredDifferenceImpl} from './kernels/SquaredDifference';\nexport {stridedSliceImpl} from './kernels/StridedSlice_impl';\nexport {stringNGramsImpl} from './kernels/StringNGrams_impl';\nexport {stringSplitImpl} from './kernels/StringSplit_impl';\nexport {stringToHashBucketFastImpl} from './kernels/StringToHashBucketFast_impl';\nexport {subImpl} from './kernels/Sub';\nexport {tileImpl} from './kernels/Tile_impl';\nexport {topKImpl} from './kernels/TopK_impl';\nexport {transposeImpl} from './kernels/Transpose_impl';\nexport {uniqueImpl} from './kernels/Unique_impl';\nexport {ComplexBinaryKernelImpl, SimpleBinaryKernelImpl} from './utils/binary_types';\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo, util} from '@tensorflow/tfjs-core';\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${\n              opName} does not support complex64 tensors in the CPU backend.`);\n    }\n  });\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Abs, AbsInputs, KernelConfig, KernelFunc, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function simpleAbsImpl(vals: TypedArray): Float32Array {\n  const resultValues = new Float32Array(vals.length);\n  for (let i = 0; i < vals.length; ++i) {\n    resultValues[i] = Math.abs(vals[i]);\n  }\n  return resultValues;\n}\n\nexport const abs = (args: {inputs: AbsInputs, backend: MathBackendCPU}) => {\n  const {x} = args.inputs;\n  const cpuBackend = args.backend;\n\n  assertNotComplex(x, 'abs');\n\n  let resultValues = new Float32Array(util.sizeFromShape(x.shape));\n  const values = cpuBackend.data.get(x.dataId).values as TypedArray;\n  resultValues = simpleAbsImpl(values);\n\n  return cpuBackend.makeOutput(resultValues, x.shape, 'float32');\n};\n\nexport const absConfig: KernelConfig = {\n  kernelName: Abs,\n  backendName: 'cpu',\n  kernelFunc: abs as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, DataValues, NumericDataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {SimpleBinaryKernelImpl, SimpleBinaryOperation} from './binary_types';\n\n/**\n * Template that creates implementation for binary ops. Supports broadcast.\n */\nexport function createSimpleBinaryKernelImpl(op: SimpleBinaryOperation):\n    SimpleBinaryKernelImpl {\n  return (aShape: number[], bShape: number[], aVals: DataValues,\n          bVals: DataValues, dtype: DataType): [TypedArray, number[]] => {\n    const newShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n\n    const resultRank = newShape.length;\n    const resultStrides = util.computeStrides(newShape);\n    const resultSize = util.sizeFromShape(newShape);\n\n    const result =\n        util.getTypedArrayFromDType(dtype as NumericDataType, resultSize);\n\n    const aRank = aShape.length;\n    const bRank = bShape.length;\n\n    const aStrides = util.computeStrides(aShape);\n    const bStrides = util.computeStrides(bShape);\n\n    const aBroadcastDims = backend_util.getBroadcastDims(aShape, newShape);\n    const bBroadcastDims = backend_util.getBroadcastDims(bShape, newShape);\n\n    if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n      for (let i = 0; i < result.length; ++i) {\n        result[i] = op(aVals[i % aVals.length], bVals[i % bVals.length]);\n      }\n    } else {\n      for (let i = 0; i < result.length; ++i) {\n        const loc = util.indexToLoc(i, resultRank, resultStrides);\n\n        const aLoc = loc.slice(-aRank);\n        aBroadcastDims.forEach(d => aLoc[d] = 0);\n        const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n\n        const bLoc = loc.slice(-bRank);\n        bBroadcastDims.forEach(d => bLoc[d] = 0);\n        const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n\n        result[i] = op(aVals[aIndex], bVals[bIndex]);\n      }\n    }\n\n    return [result, newShape];\n  };\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Complex, ComplexInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function complex(args: {inputs: ComplexInputs, backend: MathBackendCPU}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {real, imag} = inputs;\n\n  const realVals = backend.data.get(real.dataId).values as TypedArray;\n  const imagVals = backend.data.get(imag.dataId).values as TypedArray;\n\n  const complexInfo = backend.makeTensorInfo(real.shape, 'complex64');\n\n  const complex = backend.data.get(complexInfo.dataId);\n\n  // The complex tensor owns the underlying real and imag tensorInfos, only the\n  // complex tensor tracks refCount, when complexData is disposed the\n  // underlying tensorData will be disposed.\n  complex.complexTensorInfos = {\n    real: backend.makeTensorInfo(real.shape, 'float32', realVals),\n    imag: backend.makeTensorInfo(imag.shape, 'float32', imagVals)\n  };\n\n  return complexInfo;\n}\n\nexport const complexConfig: KernelConfig = {\n  kernelName: Complex,\n  backendName: 'cpu',\n  kernelFunc: complex as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TensorInfo, util} from '@tensorflow/tfjs-core';\nimport {MathBackendCPU} from '../backend_cpu';\nimport {complex} from '../kernels/Complex';\n\n/**\n * Generates a tensorInfo with all zeros value.\n * @param backend cpu backend.\n * @param shape Shape for the zeros tensor.\n * @param dtype Optional. If set, the result has this dtype.\n */\nexport function zeros(\n    backend: MathBackendCPU, shape: number[],\n    dtype: DataType = 'float32'): TensorInfo {\n  if (dtype === 'complex64') {\n    const real = zeros(backend, shape, 'float32');\n    const imag = zeros(backend, shape, 'float32');\n\n    return complex({inputs: {real, imag}, backend});\n  }\n\n  const values = util.makeZerosTypedArray(util.sizeFromShape(shape), dtype);\n\n  return backend.makeTensorInfo(shape, dtype, values);\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Identity, IdentityInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function identity(\n    args: {inputs: IdentityInputs, backend: MathBackendCPU}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  backend.incRef(x.dataId);\n\n  return {dataId: x.dataId, shape: x.shape, dtype: x.dtype};\n}\n\nexport const identityConfig: KernelConfig = {\n  kernelName: Identity,\n  backendName: 'cpu',\n  kernelFunc: identity as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Real, RealInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\n\nexport function real(args: {inputs: RealInputs, backend: MathBackendCPU}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n\n  const real = backend.data.get(input.dataId).complexTensorInfos.real;\n  const realVal = backend.data.get(real.dataId).values;\n\n  // When complex tensor is disposed, its underlying parts will be disposed too.\n  // Make new tensor out of the real value of the complex. This makes sure the\n  // value is still accessible even if complex tensor is disposed.\n  return backend.makeTensorInfo(real.shape, real.dtype, realVal);\n}\n\nexport const realConfig: KernelConfig = {\n  kernelName: Real,\n  backendName: 'cpu',\n  kernelFunc: real as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {Cast, CastAttrs, CastInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {zeros} from '../utils/zeros_impl';\n\nimport {complex} from './Complex';\nimport {identity} from './Identity';\nimport {real} from './Real';\n\nexport function cast(\n    args: {inputs: CastInputs, backend: MathBackendCPU, attrs: CastAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dtype} = attrs;\n\n  // Casting to complex64.\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({inputs: {x}, backend});\n    }\n\n    const zerosTensorInfo = zeros(backend, x.shape, x.dtype);\n    const floatX = cast({inputs: {x}, backend, attrs: {dtype: 'float32'}});\n\n    const result =\n        complex({inputs: {real: floatX, imag: zerosTensorInfo}, backend});\n\n    backend.disposeIntermediateTensorInfo(zerosTensorInfo);\n    backend.disposeIntermediateTensorInfo(floatX);\n\n    return result;\n  }\n\n  // Casting from complex64\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const result = cast({inputs: {x: realPart}, backend, attrs: {dtype}});\n\n    backend.disposeIntermediateTensorInfo(realPart);\n\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({inputs: {x}, backend});\n    return {dataId: result.dataId, shape: result.shape, dtype};\n  }\n\n  if (dtype === 'int32') {\n    const values = backend.data.get(x.dataId).values as TypedArray;\n    const resultValues = Int32Array.from(values);\n    return backend.makeTensorInfo(x.shape, 'int32', resultValues);\n  }\n\n  if (dtype === 'bool') {\n    // This is essentially the result of notEqual(x, 0). We avoid using\n    // kernel notEqual to avoid circular dependency, i.e. binary_utils ->\n    // cast -> notEqual -> binary_utils.\n    const xVals = backend.data.get(x.dataId).values as TypedArray;\n    const zero = util.toTypedArray([0], x.dtype);\n\n    const [resultData, resultShape] = createSimpleBinaryKernelImpl(\n        (a, b) => (a !== b) ? 1 : 0)(x.shape, [], xVals, zero, 'bool');\n\n    return backend.makeTensorInfo(resultShape, 'bool', resultData);\n  }\n\n  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\n\nexport const castConfig: KernelConfig = {\n  kernelName: Cast,\n  backendName: 'cpu',\n  kernelFunc: cast as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BinaryInputs, DataType, KernelFunc, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {cast} from '../kernels/Cast';\nimport {complex} from '../kernels/Complex';\n\nimport {ComplexBinaryKernelImpl, ComplexBinaryOperation, SimpleBinaryKernelImpl} from './binary_types';\n\n/**\n * Template that creates a `KernelFunc` for binary ops.\n * @param name Kernel name.\n * @param binaryKernelImpl A `SimpleBinaryKernelImpl` for the kernel.\n * @param binaryKernelComplexImpl Optional. If exists, represents a\n *     `ComplexBinaryKernelImpl` for the kernel, will be used when input dtype\n *     is `complex64`.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the first input. This is mainly used in\n *     comparison kernels, such as Equal, Less, Greater, etc.\n */\nexport function binaryKernelFunc(\n    name: string, simpleImpl: SimpleBinaryKernelImpl,\n    complexImpl?: ComplexBinaryKernelImpl, dtype?: DataType): KernelFunc {\n  if (complexImpl == null) {\n    return ({inputs, backend}) => {\n      const {a, b} = inputs as BinaryInputs;\n      const cpuBackend = backend as MathBackendCPU;\n\n      assertNotComplex([a, b], name);\n\n      const aVals = cpuBackend.data.get(a.dataId).values as TypedArray;\n      const bVals = cpuBackend.data.get(b.dataId).values as TypedArray;\n\n      const decodedAVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(aVals as any as Uint8Array[]) :\n          aVals;\n      const decodedBVals = a.dtype === 'string' ?\n          // tslint:disable-next-line: no-any\n          backend_util.fromUint8ToStringArray(bVals as any as Uint8Array[]) :\n          bVals;\n      const $dtype = dtype || a.dtype;\n\n      const [resultData, resultShape] =\n          simpleImpl(a.shape, b.shape, decodedAVals, decodedBVals, $dtype);\n\n      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n    };\n  }\n\n  return ({inputs, backend}) => {\n    const {a, b} = inputs as BinaryInputs;\n    const cpuBackend = backend as MathBackendCPU;\n\n    if (a.dtype === 'complex64' || b.dtype === 'complex64') {\n      const $aComplex = cast(\n          {inputs: {x: a}, backend: cpuBackend, attrs: {dtype: 'complex64'}});\n\n      const $aComplexVals = cpuBackend.data.get($aComplex.dataId);\n\n      const aReal = $aComplexVals.complexTensorInfos.real;\n      const aImag = $aComplexVals.complexTensorInfos.imag;\n\n      const aRealVals =\n          cpuBackend.data.get(aReal.dataId).values as Float32Array;\n      const aImagVals =\n          cpuBackend.data.get(aImag.dataId).values as Float32Array;\n\n      const $bComplex = cast(\n          {inputs: {x: b}, backend: cpuBackend, attrs: {dtype: 'complex64'}});\n\n      const $bComplexVals = cpuBackend.data.get($bComplex.dataId);\n\n      const bReal = $bComplexVals.complexTensorInfos.real;\n      const bImag = $bComplexVals.complexTensorInfos.imag;\n\n      const bRealVals =\n          cpuBackend.data.get(bReal.dataId).values as Float32Array;\n      const bImagVals =\n          cpuBackend.data.get(bImag.dataId).values as Float32Array;\n\n      const [resultRealData, resultImagData, resultShape] = complexImpl(\n          a.shape, b.shape, aRealVals, aImagVals, bRealVals, bImagVals);\n\n      const resultReal =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', resultRealData);\n\n      const resultImag =\n          cpuBackend.makeTensorInfo(resultShape, 'float32', resultImagData);\n\n      const result = complex(\n          {inputs: {real: resultReal, imag: resultImag}, backend: cpuBackend});\n\n      cpuBackend.disposeIntermediateTensorInfo($aComplex);\n      cpuBackend.disposeIntermediateTensorInfo($bComplex);\n      cpuBackend.disposeIntermediateTensorInfo(resultReal);\n      cpuBackend.disposeIntermediateTensorInfo(resultImag);\n\n      return result;\n    } else {\n      const aVals = cpuBackend.data.get(a.dataId).values as TypedArray;\n      const bVals = cpuBackend.data.get(b.dataId).values as TypedArray;\n\n      const $dtype = dtype || a.dtype;\n\n      const [resultData, resultShape] =\n          simpleImpl(a.shape, b.shape, aVals, bVals, $dtype);\n\n      return cpuBackend.makeTensorInfo(resultShape, $dtype, resultData);\n    }\n  };\n}\n\n/**\n * Template that creates the complex type implementation for binary ops.\n * Supports broadcast.\n */\nexport function createComplexBinaryKernelImpl(op: ComplexBinaryOperation):\n    ComplexBinaryKernelImpl {\n  return (aShape: number[], bShape: number[], aRealVals: Float32Array,\n          aImagVals: Float32Array, bRealVals: Float32Array,\n          bImagVals: Float32Array): [TypedArray, TypedArray, number[]] => {\n    const resultShape = backend_util.assertAndGetBroadcastShape(aShape, bShape);\n    const resultSize = util.sizeFromShape(resultShape);\n    const resultRank = resultShape.length;\n    const resultStrides = util.computeStrides(resultShape);\n\n    const resultRealVals = util.getTypedArrayFromDType('float32', resultSize);\n    const resultImagVals = util.getTypedArrayFromDType('float32', resultSize);\n\n    const aBroadcastDims = backend_util.getBroadcastDims(aShape, resultShape);\n    const bBroadcastDims = backend_util.getBroadcastDims(bShape, resultShape);\n\n    const aVals = backend_util.mergeRealAndImagArrays(aRealVals, aImagVals);\n    const bVals = backend_util.mergeRealAndImagArrays(bRealVals, bImagVals);\n\n    const aRank = aShape.length;\n    const aStrides = util.computeStrides(aShape);\n\n    const bRank = bShape.length;\n    const bStrides = util.computeStrides(bShape);\n\n    if (aBroadcastDims.length + bBroadcastDims.length === 0) {\n      for (let i = 0; i < resultRealVals.length; i++) {\n        const aIdx = i % aVals.length;\n        const bIdx = i % bVals.length;\n\n        const result =\n            op(aVals[aIdx * 2], aVals[aIdx * 2 + 1], bVals[bIdx * 2],\n               bVals[bIdx * 2 + 1]);\n\n        resultRealVals[i] = result.real;\n        resultImagVals[i] = result.imag;\n      }\n    } else {\n      for (let i = 0; i < resultRealVals.length; i++) {\n        const loc = util.indexToLoc(i, resultRank, resultStrides);\n\n        const aLoc = loc.slice(-aRank);\n        aBroadcastDims.forEach(d => aLoc[d] = 0);\n        const aIndex = util.locToIndex(aLoc, aRank, aStrides);\n\n        const bLoc = loc.slice(-bRank);\n        bBroadcastDims.forEach(d => bLoc[d] = 0);\n        const bIndex = util.locToIndex(bLoc, bRank, bStrides);\n\n        const opResult =\n            op(aVals[aIndex * 2], aVals[aIndex * 2 + 1], bVals[bIndex * 2],\n               bVals[bIndex * 2 + 1]);\n\n        resultRealVals[i] = opResult.real;\n        resultImagVals[i] = opResult.imag;\n      }\n    }\n    return [resultRealVals, resultImagVals, resultShape];\n  };\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Add, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc, createComplexBinaryKernelImpl} from '../utils/binary_utils';\n\nexport const addImpl =\n    createSimpleBinaryKernelImpl(((a: number, b: number) => a + b));\nexport const addComplexImpl =\n    createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n      return {real: aReal + bReal, imag: aImag + bImag};\n    }));\n\nexport const add = binaryKernelFunc(Add, addImpl, addComplexImpl);\n\nexport const addConfig: KernelConfig = {\n  kernelName: Add,\n  backendName: 'cpu',\n  kernelFunc: add\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function bincountImpl(\n    xVals: TypedArray, weightsVals: TypedArray, weightsDtype: DataType,\n    weightsShape: number[], size: number): TypedArray {\n  const weightsSize = util.sizeFromShape(weightsShape);\n  const outVals = util.makeZerosTypedArray(size, weightsDtype) as TypedArray;\n\n  for (let i = 0; i < xVals.length; i++) {\n    const value = xVals[i];\n    if (value < 0) {\n      throw new Error('Input x must be non-negative!');\n    }\n\n    if (value >= size) {\n      continue;\n    }\n\n    if (weightsSize > 0) {\n      outVals[value] += weightsVals[i];\n    } else {\n      outVals[value] += 1;\n    }\n  }\n\n  return outVals;\n}\n\nexport function bincountReduceImpl<R extends Rank>(\n    xBuf: TensorBuffer<R>, weightsBuf: TensorBuffer<R>, size: number,\n    binaryOutput = false): TensorBuffer<R> {\n  const numRows = xBuf.shape[0];\n  const numCols = xBuf.shape[1];\n\n  const outBuf = buffer([numRows, size], weightsBuf.dtype);\n\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      const value = xBuf.get(i, j);\n      if (value < 0) {\n        throw new Error('Input x must be non-negative!');\n      }\n\n      if (value >= size) {\n        continue;\n      }\n\n      if (binaryOutput) {\n        outBuf.set(1, i, value);\n      } else {\n        if (weightsBuf.size > 0) {\n          outBuf.set(outBuf.get(i, value) + weightsBuf.get(i, j), i, value);\n        } else {\n          outBuf.set(outBuf.get(i, value) + 1, i, value);\n        }\n      }\n    }\n  }\n\n  return outBuf as TensorBuffer<R>;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NumericDataType, util} from '@tensorflow/tfjs-core';\n\nimport {SimpleUnaryImpl, SimpleUnaryOperation} from './unary_types';\n\n/**\n * Template that creates implementation for unary op.\n */\nexport function createSimpleUnaryImpl(op: SimpleUnaryOperation):\n    SimpleUnaryImpl {\n  return (values, dtype, attrs) => {\n    const newValues =\n        util.getTypedArrayFromDType(dtype as NumericDataType, values.length);\n    for (let i = 0; i < values.length; ++i) {\n      newValues[i] = op(values[i], attrs);\n    }\n    return newValues;\n  };\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, KernelFunc, TypedArray, UnaryInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nimport {SimpleUnaryImpl, SimpleUnaryOperation} from './unary_types';\n\n/**\n * Template that creates a `KernelFunc` for unary ops.\n * @param name Kernel name.\n * @param op A `SimpleUnaryOperation` for the kernel.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFunc(\n    name: string, op: SimpleUnaryOperation, dtype?: DataType): KernelFunc {\n  return ({inputs, attrs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    assertNotComplex(x, name);\n    if (x.dtype === 'string' || dtype === 'string') {\n      throw new Error('unaryKernelFunc does not support string input/output');\n    }\n\n    const cpuBackend = backend as MathBackendCPU;\n    const values = cpuBackend.data.get(x.dataId).values as TypedArray;\n    const xSize = util.sizeFromShape(x.shape);\n    const $dtype = dtype || x.dtype;\n    const newValues = util.getArrayFromDType($dtype, xSize);\n    for (let i = 0; i < xSize; ++i) {\n      newValues[i] = op(values[i], attrs);\n    }\n    return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n  };\n}\n\n/**\n * Template that creates a `KernelFunc` for unary ops from the given\n * `SimpleUnaryImpl`..\n * @param name Kernel name.\n * @param unaryImpl A `SimpleUnaryImpl` that implements the op.\n * @param dtype Optional. If set, the result has this dtype. Otherwise, the\n *     result has the same dtype as the input. This is mainly used in certain\n *     kernels that return bool type, such as isFinite, isInf, etc.\n */\nexport function unaryKernelFuncFromImpl(\n    name: string, unaryImpl: SimpleUnaryImpl, dtype?: DataType): KernelFunc {\n  return ({inputs, attrs, backend}) => {\n    const {x} = inputs as UnaryInputs;\n    assertNotComplex(x, name);\n    if (x.dtype === 'string' || dtype === 'string') {\n      throw new Error('unaryKernelFunc does not support string input/output');\n    }\n\n    const cpuBackend = backend as MathBackendCPU;\n    const values = cpuBackend.data.get(x.dataId).values as TypedArray;\n    const $dtype = dtype || x.dtype;\n    const newValues = unaryImpl(values, $dtype, attrs);\n    return cpuBackend.makeTensorInfo(x.shape, $dtype, newValues);\n  };\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Ceil, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const ceilImpl = createSimpleUnaryImpl((xi) => Math.ceil(xi));\nexport const ceil = unaryKernelFuncFromImpl(Ceil, ceilImpl);\n\nexport const ceilConfig: KernelConfig = {\n  kernelName: Ceil,\n  backendName: 'cpu',\n  kernelFunc: ceil,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BackendValues, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function concatImpl(\n    inputs: Array<{vals: BackendValues, shape: number[]}>, outShape: number[],\n    dtype: DataType, simplyConcat: boolean): TypedArray|string[] {\n  const outVals = util.getArrayFromDType(dtype, util.sizeFromShape(outShape));\n\n  if (simplyConcat && dtype !== 'string') {\n    // Use built-in TypedArray.set() method for speed.\n    let offset = 0;\n    inputs.forEach(input => {\n      const size = util.sizeFromShape(input.shape);\n\n      (outVals as TypedArray).set(input.vals as TypedArray, offset);\n      offset += size;\n    });\n  } else {\n    let colOffset = 0;\n\n    inputs.forEach(input => {\n      const decodedData = dtype === 'string' ?\n          backend_util.fromUint8ToStringArray(input.vals as Uint8Array[]) :\n          input.vals as TypedArray;\n\n      let tIdx = 0;\n\n      for (let row = 0; row < input.shape[0]; ++row) {\n        const resIdx = row * outShape[1] + colOffset;\n        for (let col = 0; col < input.shape[1]; ++col) {\n          outVals[resIdx + col] = decodedData[tIdx++];\n        }\n      }\n\n      colOffset += input.shape[1];\n    });\n  }\n\n  return outVals;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Equal, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const equalImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a === b) ? 1 : 0);\nexport const equal =\n    binaryKernelFunc(Equal, equalImpl, null /* complexImpl */, 'bool');\n\nexport const equalConfig: KernelConfig = {\n  kernelName: Equal,\n  backendName: 'cpu',\n  kernelFunc: equal\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Exp, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const expImpl = createSimpleUnaryImpl((xi) => Math.exp(xi));\nexport const exp = unaryKernelFuncFromImpl(Exp, expImpl);\n\nexport const expConfig: KernelConfig = {\n  kernelName: Exp,\n  backendName: 'cpu',\n  kernelFunc: exp,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Expm1, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const expm1Impl = createSimpleUnaryImpl((xi) => Math.expm1(xi));\nexport const expm1 = unaryKernelFuncFromImpl(Expm1, expm1Impl);\n\nexport const expm1Config: KernelConfig = {\n  kernelName: Expm1,\n  backendName: 'cpu',\n  kernelFunc: expm1,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Floor, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const floorImpl = createSimpleUnaryImpl((xi) => Math.floor(xi));\nexport const floor = unaryKernelFuncFromImpl(Floor, floorImpl);\n\nexport const floorConfig: KernelConfig = {\n  kernelName: Floor,\n  backendName: 'cpu',\n  kernelFunc: floor,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer, TypedArray} from '@tensorflow/tfjs-core';\n\nexport function gatherNdImpl<R extends Rank>(\n    indicesData: TypedArray, paramsBuf: TensorBuffer<R>, dtype: DataType,\n    numSlices: number, sliceRank: number, sliceSize: number, strides: number[],\n    paramsShape: number[], paramsSize: number): TensorBuffer<R> {\n  const outBuf = buffer([numSlices, sliceSize], dtype);\n\n  for (let i = 0; i < numSlices; i++) {\n    const index = [];\n    let flattenIndex = 0;\n    for (let j = 0; j < sliceRank; j++) {\n      const dim = indicesData[i * sliceRank + j];\n      flattenIndex += dim * strides[j];\n      index.push(dim);\n    }\n    if (flattenIndex < 0 || flattenIndex >= paramsSize / sliceSize) {\n      throw new Error(\n          `Invalid indices: ${index} does not index into ${paramsShape}`);\n    }\n\n    for (let k = 0; k < sliceSize; k++) {\n      outBuf.values[i * sliceSize + k] =\n          paramsBuf.get(...paramsBuf.indexToLoc(flattenIndex * sliceSize + k));\n    }\n  }\n\n  return outBuf as TensorBuffer<R>;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer} from '@tensorflow/tfjs-core';\n\nexport function gatherV2Impl<R extends Rank, D extends DataType>(\n    xBuf: TensorBuffer<R, D>, indicesBuf: TensorBuffer<R, D>,\n    flattenOutputShape: number[]): TensorBuffer<R, D> {\n  const outBuf = buffer(flattenOutputShape, xBuf.dtype);\n  for (let i = 0; i < outBuf.size; ++i) {\n    const newLoc = outBuf.indexToLoc(i);\n\n    const originalLoc: number[] = newLoc.slice();\n    const batchIdx = originalLoc[0];\n    const indicesIdx = originalLoc[2];\n    const indicesIndex = indicesBuf.locToIndex([batchIdx, indicesIdx]);\n    originalLoc[2] = indicesBuf.values[indicesIndex] as number;\n\n    const originalIndex = xBuf.locToIndex(originalLoc);\n    outBuf.values[i] = xBuf.values[originalIndex];\n  }\n\n  return outBuf as TensorBuffer<R, D>;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Greater, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const greaterImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a > b) ? 1 : 0);\nexport const greater =\n    binaryKernelFunc(Greater, greaterImpl, null /* complexImpl */, 'bool');\n\nexport const greaterConfig: KernelConfig = {\n  kernelName: Greater,\n  backendName: 'cpu',\n  kernelFunc: greater\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GreaterEqual, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const greaterEqualImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a >= b) ? 1 : 0);\nexport const greaterEqual = binaryKernelFunc(\n    GreaterEqual, greaterEqualImpl, null /* complexImpl */, 'bool');\n\nexport const greaterEqualConfig: KernelConfig = {\n  kernelName: GreaterEqual,\n  backendName: 'cpu',\n  kernelFunc: greaterEqual\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Less} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const lessImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a < b) ? 1 : 0);\nexport const less =\n    binaryKernelFunc(Less, lessImpl, null /* complexImpl */, 'bool');\n\nexport const lessConfig: KernelConfig = {\n  kernelName: Less,\n  backendName: 'cpu',\n  kernelFunc: less\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, LessEqual} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const lessEqualImpl =\n    createSimpleBinaryKernelImpl((a: number, b: number) => (a <= b) ? 1 : 0);\nexport const lessEqual =\n    binaryKernelFunc(LessEqual, lessEqualImpl, null /* complexImpl */, 'bool');\n\nexport const lessEqualConfig: KernelConfig = {\n  kernelName: LessEqual,\n  backendName: 'cpu',\n  kernelFunc: lessEqual\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function linSpaceImpl(\n    start: number, stop: number, num: number): TypedArray {\n  const step = (stop - start) / (num - 1);\n\n  const values = util.makeZerosTypedArray(num, 'float32');\n  values[0] = start;\n  for (let i = 1; i < values.length; i++) {\n    values[i] = values[i - 1] + step;\n  }\n\n  return values;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Log} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const logImpl = createSimpleUnaryImpl((xi) => Math.log(xi));\nexport const log = unaryKernelFuncFromImpl(Log, logImpl);\n\nexport const logConfig: KernelConfig = {\n  kernelName: Log,\n  backendName: 'cpu',\n  kernelFunc: log,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, NumericDataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function maxImpl(\n    aVals: TypedArray, reduceSize: number, outShape: number[],\n    dtype: DataType): TypedArray {\n  const vals = util.getTypedArrayFromDType(\n      dtype as NumericDataType, util.sizeFromShape(outShape));\n\n  for (let i = 0; i < vals.length; ++i) {\n    const offset = i * reduceSize;\n    let max = aVals[offset];\n    for (let j = 0; j < reduceSize; ++j) {\n      const value = aVals[offset + j];\n      if (Number.isNaN(value) ||\n          value > max) {  // comparison with NaN always return false\n        max = value;\n      }\n    }\n    vals[i] = max;\n  }\n  return vals;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Maximum} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const maximumImpl = createSimpleBinaryKernelImpl(\n    ((aValue, bValue) => Math.max(aValue as number, bValue as number)));\nexport const maximum = binaryKernelFunc(Maximum, maximumImpl);\n\nexport const maximumConfig: KernelConfig = {\n  kernelName: Maximum,\n  backendName: 'cpu',\n  kernelFunc: maximum\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Minimum} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const minimumImpl = createSimpleBinaryKernelImpl(\n    ((aValue, bValue) => Math.min(aValue as number, bValue as number)));\nexport const minimum = binaryKernelFunc(Minimum, minimumImpl);\n\nexport const minimumConfig: KernelConfig = {\n  kernelName: Minimum,\n  backendName: 'cpu',\n  kernelFunc: minimum\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Multiply} from '@tensorflow/tfjs-core';\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc, createComplexBinaryKernelImpl} from '../utils/binary_utils';\n\nexport const multiplyImpl = createSimpleBinaryKernelImpl(\n    ((aValue: number, bValue: number) => aValue * bValue));\nexport const multiplyComplexImpl =\n    createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n      return {\n        real: aReal * bReal - aImag * bImag,\n        imag: aReal * bImag + aImag * bReal\n      };\n    }));\n\nexport const multiply =\n    binaryKernelFunc(Multiply, multiplyImpl, multiplyComplexImpl);\n\nexport const multiplyConfig: KernelConfig = {\n  kernelName: Multiply,\n  backendName: 'cpu',\n  kernelFunc: multiply\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, KernelConfig, KernelFunc, Neg, TensorInfo, TypedArray, UnaryInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {multiplyImpl} from './Multiply';\n\nexport function negImpl(xVals: TypedArray, xShape: number[], xDtype: DataType):\n    [TypedArray, number[]] {\n  const minusOne =\n      util.createScalarValue(-1 as {} as 'float32', xDtype) as TypedArray;\n  return multiplyImpl([], xShape, minusOne, xVals, xDtype);\n}\n\nexport function neg(args: {inputs: UnaryInputs, backend: MathBackendCPU}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  assertNotComplex(x, 'neg');\n\n  const xVals = backend.data.get(x.dataId).values as TypedArray;\n  const [res, newShape] = negImpl(xVals, x.shape, x.dtype);\n\n  return backend.makeTensorInfo(newShape, x.dtype, res);\n}\n\nexport const negConfig: KernelConfig = {\n  kernelName: Neg,\n  backendName: 'cpu',\n  kernelFunc: neg as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, NotEqual} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const notEqualImpl =\n    createSimpleBinaryKernelImpl(((a, b) => (a !== b) ? 1 : 0));\nexport const notEqual =\n    binaryKernelFunc(NotEqual, notEqualImpl, null /* complexOp */, 'bool');\n\nexport const notEqualConfig: KernelConfig = {\n  kernelName: NotEqual,\n  backendName: 'cpu',\n  kernelFunc: notEqual\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, NumericDataType, TypedArray} from '@tensorflow/tfjs-core';\nimport {util} from '@tensorflow/tfjs-core';\n\nexport function transposeImpl(\n    xVals: TypedArray, xShape: number[], dtype: DataType, perm: number[],\n    newShape: number[]): TypedArray {\n  const xRank = xShape.length;\n  const xSize = util.sizeFromShape(xShape);\n  const xStrides = util.computeStrides(xShape);\n  const newStrides = util.computeStrides(newShape);\n\n  const result = util.getTypedArrayFromDType(\n      dtype as NumericDataType, util.sizeFromShape(newShape));\n\n  for (let i = 0; i < xSize; ++i) {\n    const loc = util.indexToLoc(i, xRank, xStrides);\n\n    // Permute location.\n    const newLoc: number[] = new Array(loc.length);\n    for (let i = 0; i < newLoc.length; i++) {\n      newLoc[i] = loc[perm[i]];\n    }\n\n    const newIndex = util.locToIndex(newLoc, xRank, newStrides);\n    result[newIndex] = xVals[i];\n  }\n  return result;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Transpose, TransposeAttrs, TransposeInputs, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nimport {transposeImpl} from './Transpose_impl';\n\nexport function transpose(args: {\n  inputs: TransposeInputs,\n  attrs: TransposeAttrs,\n  backend: MathBackendCPU\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {x} = inputs;\n  const {perm} = attrs;\n\n  assertNotComplex(x, 'transpose');\n\n  const xRank = x.shape.length;\n\n  const newShape: number[] = new Array(xRank);\n  for (let i = 0; i < newShape.length; i++) {\n    newShape[i] = x.shape[perm[i]];\n  }\n\n  const values = backend.data.get(x.dataId).values as TypedArray;\n  const result = transposeImpl(values, x.shape, x.dtype, perm, newShape);\n\n  const dataId = backend.write(result, newShape, x.dtype);\n  return {dataId, shape: newShape, dtype: x.dtype};\n}\n\nexport const transposeConfig: KernelConfig = {\n  kernelName: Transpose,\n  backendName: 'cpu',\n  kernelFunc: transpose as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, TensorInfo, TypedArray, upcastType, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\nimport {transpose} from './Transpose';\n\nexport function prodImpl(\n    xShape: number[], xDtype: DataType, xVals: TypedArray,\n    reductionAxes: number[]):\n    {outVals: TypedArray, outShape: number[], outDtype: DataType} {\n  const [outShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(xShape, reductionAxes);\n  const outDtype = upcastType(xDtype, 'int32');\n  const outVals = util.makeZerosTypedArray(\n                      util.sizeFromShape(outShape), outDtype) as TypedArray;\n  const reduceSize = util.sizeFromShape(reduceShape);\n\n  for (let i = 0; i < outVals.length; ++i) {\n    const offset = i * reduceSize;\n    let prod = 1;\n    for (let j = 0; j < reduceSize; ++j) {\n      prod *= xVals[offset + j];\n    }\n    outVals[i] = prod;\n  }\n\n  return {outVals, outShape, outDtype};\n}\n\nexport function prod(\n    args: {inputs: ProdInputs, backend: MathBackendCPU, attrs: ProdAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  assertNotComplex(x, 'prod');\n\n  const xRank = x.shape.length;\n  const axes = util.parseAxisParam(axis, x.shape);\n\n  const permutation = backend_util.getAxesPermutation(axes, xRank);\n  let reductionAxes = axes;\n  let permutedX = x;\n  const intermediateTensorInfos = [];\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    intermediateTensorInfos.push(permutedX);\n    reductionAxes = backend_util.getInnerMostAxes(reductionAxes.length, xRank);\n  }\n\n  const xVals = backend.data.get(permutedX.dataId).values as TypedArray;\n  const {outVals, outShape, outDtype} =\n      prodImpl(permutedX.shape, permutedX.dtype, xVals, reductionAxes);\n\n  let resultShape = outShape;\n  if (keepDims) {\n    resultShape = backend_util.expandShapeToKeepDim(outShape, axes);\n  }\n\n  intermediateTensorInfos.forEach(\n      t => backend.disposeIntermediateTensorInfo(t));\n\n  return backend.makeTensorInfo(resultShape, outDtype, outVals);\n}\n\nexport const prodConfig: KernelConfig = {\n  kernelName: Prod,\n  backendName: 'cpu',\n  kernelFunc: prod as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataTypeMap, util} from '@tensorflow/tfjs-core';\n\nexport function rangeImpl(\n    start: number, stop: number, step: number,\n    dtype: 'float32'|'int32'): DataTypeMap['float32' | 'int32'] {\n  const sameStartStop = start === stop;\n  const increasingRangeNegativeStep = start < stop && step < 0;\n  const decreasingRangePositiveStep = stop < start && step > 1;\n\n  if (sameStartStop || increasingRangeNegativeStep ||\n      decreasingRangePositiveStep) {\n    return util.makeZerosTypedArray(0, dtype);\n  }\n\n  const numElements = Math.abs(Math.ceil((stop - start) / step));\n  const values = util.makeZerosTypedArray(numElements, dtype);\n\n  if (stop < start && step === 1) {\n    // Auto adjust the step's sign if it hasn't been set\n    // (or was set to 1)\n    step = -1;\n  }\n\n  values[0] = start;\n  for (let i = 1; i < values.length; i++) {\n    values[i] = values[i - 1] + step;\n  }\n  return values;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Rsqrt} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFuncFromImpl} from '../utils/unary_utils';\n\nexport const rsqrtImpl = createSimpleUnaryImpl((xi) => 1 / Math.sqrt(xi));\nexport const rsqrt = unaryKernelFuncFromImpl(Rsqrt, rsqrtImpl);\n\nexport const rsqrtConfig: KernelConfig = {\n  kernelName: Rsqrt,\n  backendName: 'cpu',\n  kernelFunc: rsqrt,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sigmoid} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFunc} from '../utils/unary_utils';\n\nexport const sigmoidImpl =\n    createSimpleUnaryImpl((xi) => 1 / (1 + Math.exp(-xi)));\nexport const sigmoid =\n    unaryKernelFunc(Sigmoid, (xi) => 1 / (1 + Math.exp(-xi)));\n\nexport const sigmoidConfig: KernelConfig = {\n  kernelName: Sigmoid,\n  backendName: 'cpu',\n  kernelFunc: sigmoid,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BackendValues, buffer, DataType, KernelConfig, KernelFunc, Slice, slice_util, SliceAttrs, SliceInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendCPU} from '../backend_cpu';\nimport {assertNotComplex} from '../cpu_util';\n\nexport function sliceImpl(\n    vals: BackendValues, begin: number[], size: number[], shape: number[],\n    dtype: DataType): BackendValues {\n  const isContinous = slice_util.isSliceContinous(shape, begin, size);\n  const length = util.sizeFromShape(size);\n  const xStrides = util.computeStrides(shape);\n\n  if (isContinous) {\n    const flatOffset = slice_util.computeFlatOffset(begin, xStrides);\n\n    if (dtype === 'string') {\n      return (vals as Uint8Array[]).slice(flatOffset, flatOffset + length);\n    }\n\n    return (vals as TypedArray).subarray(flatOffset, flatOffset + length);\n  }\n\n  const decodedData = dtype === 'string' ?\n      backend_util.fromUint8ToStringArray(vals as Uint8Array[]) :\n      vals as TypedArray;\n\n  const inBuf = buffer(shape, dtype, decodedData);\n  const outBuf = buffer(size, dtype);\n  for (let i = 0; i < outBuf.size; ++i) {\n    const outLoc = outBuf.indexToLoc(i);\n    const inLoc = outLoc.map((idx: number, j) => idx + begin[j]);\n    outBuf.set(inBuf.get(...inLoc), ...outLoc);\n  }\n\n  if (dtype === 'string') {\n    return backend_util.fromStringArrayToUint8(outBuf.values as string[]);\n  }\n  return outBuf.values as TypedArray;\n}\n\nexport function slice(\n    args: {inputs: SliceInputs, backend: MathBackendCPU, attrs: SliceAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {begin, size} = attrs;\n\n  assertNotComplex(x, 'slice');\n\n  const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n  slice_util.assertParamsValid(x, $begin, $size);\n\n  const vals = backend.data.get(x.dataId).values;\n  const outVals = sliceImpl(vals, $begin, $size, x.shape, x.dtype);\n  return backend.makeTensorInfo($size, x.dtype, outVals);\n}\n\nexport const sliceConfig: KernelConfig = {\n  kernelName: Slice,\n  backendName: 'cpu',\n  kernelFunc: slice as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseFillEmptyRowsImpl(\n    indices: TypedArray, indicesShape: number[], indicesDType: DataType,\n    values: TypedArray, valuesDType: DataType, denseShape: TypedArray,\n    defaultValue: number):\n    [TypedArray, number[], TypedArray, boolean[], number[]] {\n  const indicesCount = indicesShape[0];\n  const denseRows = denseShape[0];\n\n  const emptyRowIndicator: boolean[] = new Array(denseRows);\n  const reverseIndexMap: number[] = new Array(indicesCount);\n\n  const rank = indicesShape[1];\n\n  if (denseRows === 0) {\n    if (indicesCount !== 0) {\n      throw new Error(`Received SparseTensor with denseShape[0] = 0 but\n         indices.shape[0] = ${indicesCount}`);\n    }\n    const outputIndices = util.getArrayFromDType(indicesDType, 0) as TypedArray;\n    const outputValues = util.getArrayFromDType(valuesDType, 0) as TypedArray;\n    return [\n      outputIndices, [0, rank], outputValues, emptyRowIndicator, reverseIndexMap\n    ];\n  }\n\n  let rowsAreOrdered = true;\n  let lastIndicesRow = 0;\n  const csrOffset: number[] = new Array(denseRows).fill(0);\n\n  for (let i = 0; i < indicesCount; ++i) {\n    // indices is a 2d tensor with shape of [N, rank]\n    const row = indices[i * rank];\n    if (row < 0) {\n      throw new Error(`indices(${i}, 0) is invalid: ${row} < 0`);\n    }\n    if (row >= denseRows) {\n      throw new Error(`indices(${i}, 0) is invalid: ${row} >= ${denseRows}`);\n    }\n    ++csrOffset[row];\n    rowsAreOrdered = rowsAreOrdered && (row >= lastIndicesRow);\n    lastIndicesRow = row;\n  }\n\n  let allRowsFull = true;\n  for (let row = 0; row < denseRows; ++row) {\n    // csrOffset here describes the number of elements in this dense row\n    const rowEmpty = (csrOffset[row] === 0);\n    emptyRowIndicator[row] = rowEmpty;\n    allRowsFull = allRowsFull && !rowEmpty;\n    // In filled version, each row has at least one element.\n    csrOffset[row] = Math.max(csrOffset[row], 1);\n    // Update csrOffset to represent the number of elements up to and\n    // including denseRows + 1:\n    //  csrOffset[0] == #{elements of row 0}\n    //  csrOffset[1] == #{elements of row 1} + #{elements of row 0}\n    //  ..\n    //  csrOffset[i] == starting index for elements in row i + 1.\n    if (row > 0) {\n      csrOffset[row] += csrOffset[row - 1];\n    }\n  }\n\n  if (allRowsFull && rowsAreOrdered) {\n    const outputIndices: TypedArray = indices;\n    const outputValues: TypedArray = values;\n    for (let i = 0; i < indicesCount; ++i) {\n      reverseIndexMap[i] = i;\n    }\n    return [\n      outputIndices, [indicesCount, rank], outputValues, emptyRowIndicator,\n      reverseIndexMap\n    ];\n  } else {\n    const fullIndicesCount = csrOffset[denseRows - 1];\n    const outputIndices =\n        util.getArrayFromDType(indicesDType, fullIndicesCount * rank) as\n        TypedArray;\n    const outputValues =\n        util.getArrayFromDType(valuesDType, fullIndicesCount) as TypedArray;\n    const filledCount: number[] = new Array(denseRows).fill(0);\n\n    // Fill in values for rows that are not missing\n    for (let i = 0; i < indicesCount; ++i) {\n      // indices is a 2d tensor with shape of [N, rank]\n      const row = indices[i * rank];\n      const offset = filledCount[row];\n      const outputI = ((row === 0) ? 0 : csrOffset[row - 1]) + offset;\n      filledCount[row]++;  // Increment the filled count for this row.\n      for (let j = 0; j < rank; ++j) {\n        // indices and outputIndices are 2d tensors with shape of [N, rank]\n        outputIndices[outputI * rank + j] = indices[i * rank + j];\n      }\n      outputValues[outputI] = values[i];\n      // We'll need this reverse index map to backprop correctly.\n      reverseIndexMap[i] = outputI;\n    }\n\n    // Fill in values for rows that are missing\n    for (let row = 0; row < denseRows; ++row) {\n      const rowCount = filledCount[row];\n      if (rowCount === 0) {  // We haven't filled this row\n        const startingIndex = (row === 0) ? 0 : csrOffset[row - 1];\n        // Remaining index values were set to zero already.\n        // Just need to set the row index in the right location.\n        // outputIndices is a 2d tensor with shape of [N, rank]\n        outputIndices[startingIndex * rank + 0] = row;\n        for (let col = 1; col < rank; ++col) {\n          outputIndices[startingIndex * rank + col] = 0;\n        }\n        outputValues[startingIndex] = defaultValue;\n      }\n    }\n    return [\n      outputIndices, [fullIndicesCount, rank], outputValues, emptyRowIndicator,\n      reverseIndexMap\n    ];\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseReshapeImpl(\n    inputIndices: TypedArray, inputIndicesShape: number[], inputDType: DataType,\n    inputShape: number[],\n    targetShape: number[]): [TypedArray, number[], number[]] {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length;\n\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  const outputShape: number[] = [];\n  let product = 1;\n  let unknownIndex = -1;\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(`only one output dimension may be -1, not both ${\n            unknownIndex} and ${d}`);\n      }\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(`size ${d} must be non-negative, not ${size}`);\n      }\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error(\n          'reshape cannot infer the missing ' +\n          'input size for an empty tensor unless all ' +\n          'specified input sizes are non-zero');\n    }\n    const missing = Math.trunc(denseSize / product);\n    if (product * missing !== denseSize) {\n      throw new Error(`Input to reshape is a SparseTensor with ${denseSize}\n          dense values, but the requested shape requires a multiple of ${\n          product}. inputShape=${inputShape} outputShape= ${outputShape}`);\n    }\n\n    outputShape[unknownIndex] = missing;\n  }\n  const outputSize = util.sizeFromShape(outputShape);\n  if (outputSize !== denseSize) {\n    throw new Error(`Input to reshape is a tensor with ${\n        denseSize} dense values, but the requested shape has ${\n        outputSize}. inputShape=${inputShape} outputShape=${outputShape}`);\n  }\n\n  const inputRank = inputShape.length;\n  const inputStrides: number[] = [];\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n\n  const outputStrides: number[] = [];\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n\n  const newIndices =\n      util.getArrayFromDType(inputDType, nnz * outputRank) as TypedArray;\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n  return [newIndices, [nnz, outputRank], outputShape];\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseSegmentReductionImpl(\n    input: TypedArray, inputShape: number[], inputDType: DataType,\n    indices: TypedArray, segmentIds: TypedArray, isMean = false,\n    defaultValue = 0): [TypedArray, number[]] {\n  const numIndices = indices.length;\n  if (numIndices !== segmentIds.length) {\n    throw new Error(`segmentIds and indices should have same size.`);\n  }\n\n  // Flatten the array to two dimensions\n  const inputFlat: number[] = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne =\n      numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n\n  const outputLength =\n      outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength) as TypedArray;\n\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(`segment ids must be >= 0`);\n  }\n\n  let start = 0, end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(`segment ids are not increasing`);\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(`Segment id ${outIndex} out of range [0, ${\n          outputRows}), possibly because segmentIds input is not sorted.`);\n    }\n\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(`Bad: indices[${i}] == ${indices[i]} out of range [0, ${\n            inputFlat[0]})`);\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sqrt} from '@tensorflow/tfjs-core';\n\nimport {createSimpleUnaryImpl} from '../utils/unary_impl';\nimport {unaryKernelFunc} from '../utils/unary_utils';\n\nexport const sqrtImpl = createSimpleUnaryImpl((xi) => Math.sqrt(xi));\nexport const sqrt = unaryKernelFunc(Sqrt, (xi) => Math.sqrt(xi));\n\nexport const sqrtConfig: KernelConfig = {\n  kernelName: Sqrt,\n  backendName: 'cpu',\n  kernelFunc: sqrt,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SquaredDifference} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc} from '../utils/binary_utils';\n\nexport const squaredDifferenceImpl =\n    createSimpleBinaryKernelImpl(((a: number, b: number) => {\n      const diff = a - b;\n      return diff * diff;\n    }));\nexport const squaredDifference =\n    binaryKernelFunc(SquaredDifference, squaredDifferenceImpl);\n\nexport const squaredDifferenceConfig: KernelConfig = {\n  kernelName: SquaredDifference,\n  backendName: 'cpu',\n  kernelFunc: squaredDifference\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, Rank, TensorBuffer} from '@tensorflow/tfjs-core';\n\nexport function stridedSliceImpl<R extends Rank>(\n    outShape: number[], xBuf: TensorBuffer<R>, strides: number[],\n    begin: number[]): TensorBuffer<R> {\n  const outBuf = buffer(outShape, xBuf.dtype);\n\n  for (let i = 0; i < outBuf.size; i++) {\n    const loc = outBuf.indexToLoc(i);\n\n    const newLoc: number[] = new Array(loc.length);\n    for (let j = 0; j < newLoc.length; j++) {\n      newLoc[j] = loc[j] * strides[j] + begin[j];\n    }\n    outBuf.set(xBuf.get(...newLoc), ...loc);\n  }\n\n  return outBuf as TensorBuffer<R>;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\n/**\n * The StringNGramsOp class creates ngrams from ragged string data.\n * The constructor contains all attributes related to the operation such as\n * padding widths and strings, and the compute function can be used to\n * compute the ngrams for different ragged tensor inputs.\n */\nclass StringNGramsOp {\n  private separator: Uint8Array;\n  private nGramWidths: number[];\n  private padWidth: number;\n  private leftPad: Uint8Array;\n  private rightPad: Uint8Array;\n  private preserveShort: boolean;\n\n  constructor(\n      separator: string, nGramWidths: number[], leftPad: string,\n      rightPad: string, padWidth: number, preserveShortSequences: boolean) {\n    this.separator = util.encodeString(separator);\n    this.nGramWidths = nGramWidths;\n    this.leftPad = util.encodeString(leftPad);\n    this.rightPad = util.encodeString(rightPad);\n    this.padWidth = padWidth;\n    this.preserveShort = preserveShortSequences;\n  }\n\n  private getPadWidth(nGramWidth: number) {\n    // Ngrams can be padded with either a fixed pad width or a dynamic pad\n    // width depending on the 'padWidth' arg, but in no case should the padding\n    // ever be wider than 'nGramWidth' - 1.\n    return Math.min(\n        this.padWidth < 0 ? nGramWidth - 1 : this.padWidth, nGramWidth - 1);\n  }\n\n  private getNumNGrams(length: number, nGramWidth: number) {\n    const padWidth = this.getPadWidth(nGramWidth);\n    return Math.max(0, ((length + 2 * padWidth) - nGramWidth) + 1);\n  }\n\n  private createNGrams(\n      data: Uint8Array[], splitIndex: number, output: Uint8Array[],\n      outputStartIndex: number, numNGrams: number, nGramWidth: number) {\n    for (let nGramIndex = 0; nGramIndex < numNGrams; ++nGramIndex) {\n      const padWidth = this.getPadWidth(nGramWidth);\n      const leftPadding = Math.max(0, padWidth - nGramIndex);\n      const rightPadding =\n          Math.max(0, padWidth - (numNGrams - (nGramIndex + 1)));\n      const numTokens = nGramWidth - (leftPadding + rightPadding);\n      const dataStartIndex =\n          splitIndex + (leftPadding > 0 ? 0 : nGramIndex - padWidth);\n\n      // Calculate the total expected size of the nGram so we can reserve the\n      // correct amount of space in the string.\n      let nGramSize = 0;\n      // Size of the left padding.\n      nGramSize += leftPadding * this.leftPad.length;\n      // Size of the tokens.\n      for (let n = 0; n < numTokens; ++n) {\n        nGramSize += data[dataStartIndex + n].length;\n      }\n      // Size of the right padding.\n      nGramSize += rightPadding * this.rightPad.length;\n      // Size of the separators.\n      const numSeparators = leftPadding + rightPadding + numTokens - 1;\n      nGramSize += numSeparators * this.separator.length;\n\n      // Build the nGram.\n      output[outputStartIndex + nGramIndex] = new Uint8Array(nGramSize);\n      const nGram = output[outputStartIndex + nGramIndex];\n\n      let nextNGramIndex = 0;\n      const appendToNGram = (str: Uint8Array) =>\n          str.forEach((value) => nGram[nextNGramIndex++] = value);\n\n      for (let n = 0; n < leftPadding; ++n) {\n        appendToNGram(this.leftPad);\n        appendToNGram(this.separator);\n      }\n      // Only output first numTokens - 1 pairs of data and separator\n      for (let n = 0; n < numTokens - 1; ++n) {\n        appendToNGram(data[dataStartIndex + n]);\n        appendToNGram(this.separator);\n      }\n      // Handle case when there are no tokens or no right padding as these\n      // can result in consecutive separators.\n      if (numTokens > 0) {\n        // If we have tokens, then output last and then pair each separator\n        // with the right padding that follows, to ensure nGram ends either with\n        // the token or with the right pad.\n        appendToNGram(data[dataStartIndex + numTokens - 1]);\n        for (let n = 0; n < rightPadding; ++n) {\n          appendToNGram(this.separator);\n          appendToNGram(this.rightPad);\n        }\n      } else {\n        // If we don't have tokens, then the last item inserted into the nGram\n        // has been the separator from the left padding loop above. Hence,\n        // output right pad and separator and make sure to finish with a\n        // padding, not a separator.\n        for (let n = 0; n < rightPadding - 1; ++n) {\n          appendToNGram(this.rightPad);\n          appendToNGram(this.separator);\n        }\n        appendToNGram(this.rightPad);\n      }\n    }\n  }\n\n  // Data and splits together form the definition of the ragged tensor,\n  // where data is 1 dimensional and contains the values of the tensor\n  // and splits denotes the indices at which each row starts.\n  public compute(data: Uint8Array[], splits: Int32Array):\n      [Uint8Array[], Int32Array] {\n    // Validate that the splits are valid indices into data, only if there are\n    // splits specified.\n    const inputDataSize = data.length;\n    const splitsSize = splits.length;\n    if (splitsSize > 0) {\n      let prevSplit = splits[0];\n      if (prevSplit !== 0) {\n        throw new Error(`First split value must be 0, got ${prevSplit}`);\n      }\n      for (let i = 1; i < splitsSize; ++i) {\n        let validSplits = splits[i] >= prevSplit;\n        validSplits = validSplits && (splits[i] <= inputDataSize);\n        if (!validSplits) {\n          throw new Error(`Invalid split value ${splits[i]}, must be in [${\n              prevSplit}, ${inputDataSize}]`);\n        }\n        prevSplit = splits[i];\n      }\n      if (prevSplit !== inputDataSize) {\n        throw new Error(`Last split value must be data size. Expected ${\n            inputDataSize}, got ${prevSplit}`);\n      }\n    }\n\n    const numBatchItems = splitsSize - 1;\n    const nGramsSplits = util.getArrayFromDType('int32', splitsSize);\n    // If there is no data or size, return an empty ragged tensor.\n    if (inputDataSize === 0 || splitsSize === 0) {\n      const empty: Uint8Array[] = new Array(inputDataSize);\n      for (let i = 0; i <= numBatchItems; ++i) {\n        nGramsSplits[i] = 0;\n      }\n      return [empty, nGramsSplits];\n    }\n\n    nGramsSplits[0] = 0;\n    for (let i = 1; i <= numBatchItems; ++i) {\n      const length = splits[i] - splits[i - 1];\n      let numNGrams = 0;\n      this.nGramWidths.forEach((nGramWidth) => {\n        numNGrams += this.getNumNGrams(length, nGramWidth);\n      });\n      if (this.preserveShort && length > 0 && numNGrams === 0) {\n        numNGrams = 1;\n      }\n      nGramsSplits[i] = nGramsSplits[i - 1] + numNGrams;\n    }\n\n    const nGrams: Uint8Array[] = new Array(nGramsSplits[numBatchItems]);\n\n    for (let i = 0; i < numBatchItems; ++i) {\n      const splitIndex = splits[i];\n      let outputStartIdx = nGramsSplits[i];\n      this.nGramWidths.forEach((nGramWidth) => {\n        const length = splits[i + 1] - splits[i];\n        const numNGrams = this.getNumNGrams(length, nGramWidth);\n        this.createNGrams(\n            data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);\n        outputStartIdx += numNGrams;\n      });\n      // If we're preserving short sequences, check to see if no sequence was\n      // generated by comparing the current output start idx to the original\n      // one (nGramSplitsdata). If no ngrams were generated, then they will\n      // be equal (since we increment outputStartIdx by numNGrams every\n      // time we create a set of ngrams.)\n      if (this.preserveShort && outputStartIdx === nGramsSplits[i]) {\n        const dataLength = splits[i + 1] - splits[i];\n        // One legitimate reason to not have any ngrams when this.preserveShort\n        // is true is if the sequence itself is empty. In that case, move on.\n        if (dataLength === 0) {\n          continue;\n        }\n        // We don't have to worry about dynamic padding sizes here: if padding\n        // was dynamic, every sequence would have had sufficient padding to\n        // generate at least one nGram.\n        const nGramWidth = dataLength + 2 * this.padWidth;\n        const numNGrams = 1;\n        this.createNGrams(\n            data, splitIndex, nGrams, outputStartIdx, numNGrams, nGramWidth);\n      }\n    }\n    return [nGrams, nGramsSplits];\n  }\n}\n\nexport function stringNGramsImpl(\n    data: Uint8Array[], dataSplits: Int32Array, separator: string,\n    nGramWidths: number[], leftPad: string, rightPad: string, padWidth: number,\n    preserveShortSequences: boolean): [Uint8Array[], Int32Array] {\n  return new StringNGramsOp(\n             separator, nGramWidths, leftPad, rightPad, padWidth,\n             preserveShortSequences)\n      .compute(data, dataSplits);\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray, util} from '@tensorflow/tfjs-core';\n\nfunction split(\n    str: Uint8Array, delimiters: Uint8Array, skipEmpty: boolean,\n    result: Uint8Array[]): void {\n  if (!str.length) {\n    return;\n  }\n  // When the delimiter is empty, the input is split into individual characters.\n  if (delimiters.length === 0) {\n    for (let i = 0; i < str.length; ++i) {\n      result.push(str.subarray(i, i + 1));\n    }\n    return;\n  }\n  // When there is one delimiter, the input is split only at that delimiter.\n  if (delimiters.length === 1) {\n    const delimiter = delimiters[0];\n    let f = str.indexOf(delimiter);\n    while (f !== -1) {\n      const token = str.subarray(0, f);\n      if (!skipEmpty || token.length !== 0) {\n        result.push(token);\n      }\n      str = str.subarray(f + 1);\n      f = str.indexOf(delimiter);\n    }\n    if (!skipEmpty || str.length !== 0) {\n      result.push(str);\n    }\n    return;\n  }\n  // When there are multiple delimiters, the input is split at every instance\n  // one of the delimiters appears.\n  let tokenStart = 0;\n  for (let i = 0; i < str.length + 1; i++) {\n    if ((i === str.length) || (delimiters.indexOf(str[i]) !== -1)) {\n      const token = str.subarray(tokenStart, i);\n      if (!skipEmpty || token.length !== 0) {\n        result.push(token);\n      }\n      tokenStart = i + 1;\n    }\n  }\n}\n\nexport function stringSplitImpl(\n    input: Uint8Array[], delimiter: Uint8Array,\n    skipEmpty: boolean): [TypedArray, Uint8Array[], [number, number]] {\n  const batchSize = input.length;\n\n  // Empty delimiter means split the input character by character.\n  const tokens: Uint8Array[] = [];\n\n  let outputSize = 0;\n  let maxNumEntries = 0;\n  const numIndices: number[] = new Array(batchSize);\n  for (let i = 0; i < batchSize; ++i) {\n    const prevTokensLength = tokens.length;\n    split(input[i], delimiter, skipEmpty, tokens);\n    const nEntries = tokens.length - prevTokensLength;\n    numIndices[i] = nEntries;\n    outputSize += nEntries;\n    maxNumEntries = Math.max(maxNumEntries, nEntries);\n  }\n\n  const indices = util.getArrayFromDType('int32', outputSize * 2) as TypedArray;\n  const values: Uint8Array[] = new Array(outputSize);\n  const shape: [number, number] = [batchSize, maxNumEntries];\n\n  let c = 0;\n  for (let i = 0; i < batchSize; ++i) {\n    for (let j = 0; j < numIndices[i]; ++j) {\n      // indices is a 2d tensor with shape of [outputSize, 2]\n      indices[c * 2] = i;\n      indices[c * 2 + 1] = j;\n      values[c] = tokens[c];\n      ++c;\n    }\n  }\n\n  return [indices, values, shape];\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function stringToHashBucketFastImpl(\n    input: Uint8Array[], numBuckets: number): TypedArray {\n  const output = util.getArrayFromDType('int32', input.length) as TypedArray;\n\n  for (let i = 0; i < input.length; ++i) {\n    output[i] =\n        util.fingerPrint64(input[i]).modulo(numBuckets).getLowBitsUnsigned();\n  }\n\n  return output;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sub} from '@tensorflow/tfjs-core';\n\nimport {createSimpleBinaryKernelImpl} from '../utils/binary_impl';\nimport {binaryKernelFunc, createComplexBinaryKernelImpl} from '../utils/binary_utils';\n\nexport const subImpl = createSimpleBinaryKernelImpl(\n    ((aValue: number, bValue: number) => aValue - bValue));\nexport const subComplexImpl =\n    createComplexBinaryKernelImpl(((aReal, aImag, bReal, bImag) => {\n      return {real: aReal - bReal, imag: aImag - bImag};\n    }));\nexport const sub = binaryKernelFunc(Sub, subImpl, subComplexImpl);\n\nexport const subConfig: KernelConfig = {\n  kernelName: Sub,\n  backendName: 'cpu',\n  kernelFunc: sub\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, DataType, Rank, TensorBuffer} from '@tensorflow/tfjs-core';\n\n/**\n * An implementation of the tile kernel shared between webgl and cpu for string\n * tensors only.\n */\n\nexport function tileImpl<R extends Rank>(\n    xBuf: TensorBuffer<R, DataType>,\n    reps: number[]): TensorBuffer<R, DataType> {\n  const newShape: number[] = new Array(xBuf.rank);\n  for (let i = 0; i < newShape.length; i++) {\n    newShape[i] = xBuf.shape[i] * reps[i];\n  }\n  const result = buffer(newShape, xBuf.dtype);\n  for (let i = 0; i < result.values.length; ++i) {\n    const newLoc = result.indexToLoc(i);\n\n    const originalLoc: number[] = new Array(xBuf.rank);\n    for (let j = 0; j < originalLoc.length; j++) {\n      originalLoc[j] = newLoc[j] % xBuf.shape[j];\n    }\n\n    const originalIndex = xBuf.locToIndex(originalLoc);\n\n    result.values[i] = xBuf.values[originalIndex];\n  }\n  return result as TensorBuffer<R, DataType>;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/** An implementation of the TopK kernel shared between webgl and cpu. */\n\nimport {buffer, NumericDataType, Rank, ShapeMap, Tensor, TensorBuffer, TypedArray, util} from '@tensorflow/tfjs-core';\n\ntype Pair = {\n  value: number,\n  index: number\n};\n\nconst comparePair = (a: Pair, b: Pair) => {\n  const valueDiff = b.value - a.value;\n  return valueDiff === 0 ? a.index - b.index : valueDiff;\n};\n\n/**\n * Partitions array where all elements smaller than the (k+1) smallest element\n * are found to the left of it, and all larger to the right of it.\n * Based on the Floyd-Rivest Algorithm, ref:\n * https://en.wikipedia.org/wiki/Floyd%E2%80%93Rivest_algorithm\n * @param array: Array to partition\n * @param left: Left index for the interval\n * @param right: Right index for the interval\n * @param k: Desired index value, where array[k] is the (k+1)th smallest element\n *           when left = 0\n */\nfunction select(array: Pair[], k: number, left = 0, right = array.length - 1) {\n  while (right > left) {\n    // Use select recursively to sample a smaller set of size s\n    // the arbitrary constants 600 and 0.5 are used in the original\n    // version to minimize execution time.\n    if (right - left > 600) {\n      const n = right - left + 1;\n      const i = k - left + 1;\n      const z = Math.log(n);\n      const s = 0.5 * Math.exp(2 * z / 3);\n      const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * Math.sign(i - n / 2);\n      const newLeft = Math.max(left, Math.floor(k - i * s / n + sd));\n      const newRight = Math.min(right, Math.floor(k + (n - i) * s / n + sd));\n      select(array, k, newLeft, newRight);\n    }\n    // partition the elements between left and right around t\n    const t = array[k];\n    let i = left;\n    let j = right;\n\n    util.swap(array, left, k);\n\n    if (comparePair(array[right], t) > 0) {\n      util.swap(array, left, right);\n    }\n    while (i < j) {\n      util.swap(array, i, j);\n      i++;\n      j--;\n      while (comparePair(array[i], t) < 0) {\n        i = i + 1;\n      }\n      while (comparePair(array[j], t) > 0) {\n        j = j - 1;\n      }\n    }\n    if (comparePair(array[left], t) === 0) {\n      util.swap(array, left, j);\n    } else {\n      j = j + 1;\n      util.swap(array, j, right);\n    }\n    // Adjust left and right towards the boundaries of the subset\n    // containing the (k - left + 1)th smallest element.\n    if (j <= k) {\n      left = j + 1;\n    }\n    if (k <= j) {\n      right = j - 1;\n    }\n  }\n}\n\nexport function topKImpl<T extends Tensor, R extends Rank>(\n    x: TypedArray, xShape: number[], xDtype: NumericDataType, k: number,\n    sorted: boolean):\n    [TensorBuffer<R, NumericDataType>, TensorBuffer<R, 'int32'>] {\n  // Reshape into a 2d tensor [batch, lastDim] and compute topk along lastDim.\n  const lastDim = xShape[xShape.length - 1];\n  const [batch, size] = [x.length / lastDim, lastDim];\n  const allTopKVals = util.getTypedArrayFromDType(xDtype, batch * k);\n  const allTopKIndices = util.getTypedArrayFromDType('int32', batch * k);\n\n  for (let b = 0; b < batch; b++) {\n    const offset = b * size;\n    const vals = x.subarray(offset, offset + size);\n\n    let valAndInd: Pair[] = new Array(vals.length);\n    vals.forEach(\n        (value: number, index: number) => valAndInd[index] = {value, index});\n\n    if (k < valAndInd.length) {\n      select(valAndInd, k);\n      valAndInd = valAndInd.slice(0, k);\n    }\n\n    if (sorted) {\n      valAndInd.sort(comparePair);\n    }\n    \n    const outOffset = b * k;\n    const topKVals = allTopKVals.subarray(outOffset, outOffset + k);\n    const topKIndices = allTopKIndices.subarray(outOffset, outOffset + k);\n    for (let i = 0; i < k; i++) {\n      topKVals[i] = valAndInd[i].value;\n      topKIndices[i] = valAndInd[i].index;\n    }\n  }\n  // Reshape back to the original input shape, except that the last\n  // dimension is k.\n  const outputShape = xShape.slice();\n  outputShape[outputShape.length - 1] = k;\n\n  return [\n    buffer(outputShape as ShapeMap[R], xDtype, allTopKVals),\n    buffer(outputShape as ShapeMap[R], 'int32', allTopKIndices)\n  ];\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BackendValues, DataType, TensorBuffer, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function uniqueImpl(\n    values: BackendValues, axis: number, shape: number[], dtype: DataType): {\n  outputValues: BackendValues,\n  outputShape: number[],\n  indices: BackendValues\n} {\n  // Normalize and validate axis.\n  const $axis = util.parseAxisParam(axis, shape)[0];\n\n  // Calculate the new shape that is suitable for extracting data along the\n  // given axis.\n  //\n  // The rank is 3.\n  // The size of the 1st dimension is the size of all the axes < the given axis.\n  // The size of the 2nd dimension is the same as the size of the given axis.\n  // The size of the 3rd dimension is the size of all the axes > the given axis.\n  //\n  // For example, for a 4D tensor with shape=[2, 3, 5, 4] and axis=2, the\n  // newShape would be: [2*3, 5, 4].\n  //\n  // Note that this is not the final output shape. This will be the shape for an\n  // intermediate TensorBuffer (see inputBuffer below) to allow us to extract\n  // values along the given axis. To demonstrate how it works, consider the\n  // following example:\n  //\n  // Input: a 3D tensor, with shape [1, 2, 3]\n  // [\n  //   [\n  //      [1,2,3],\n  //      [4,5,6]\n  //   ]\n  // ]\n  // Axis: 2 (the last axis).\n  // Along axis 2, we expect to extract 3 tensors: [1,4], [2,5], [3,6].\n  //\n  // For this example, newShape would be: [2, 3, 1], where 2 is calculated from\n  // 1*2. The re-shaped data would look like:\n  //\n  // [\n  //   [\n  //     [1], [2], [3]\n  //   ],\n  //   [\n  //     [4], [5], [6]\n  //   ]\n  // ]\n  //\n  // Then, we can construct a 3-level nested loop by the following dimension\n  // order to extract the values along the axis (dimension1):\n  // i: dimension1       // 0,1,2 (newShape[1])\n  //   m: dimension0     // 0,1   (newShape[0])\n  //     n: dimension2   // 0     (newShape[2])\n  //\n  //                       m, i, n\n  //                      ---------\n  // Iteration 0: data at [0, 0, 0] => \"1\"\n  // Iteration 1: data at [1, 0, 0] => \"4\"\n  // We got [1,4].\n  // Iteration 2: data at [0, 1, 0] => \"2\"\n  // Iteration 3: data at [1, 1, 0] => \"5\"\n  // We got [2,5].\n  // Iteration 4: data at [0, 2, 0] => \"3\"\n  // Iteration 5: data at [1, 2, 0] => \"6\"\n  // We got [3,6].\n  const newShape = [1, shape[0], 1];\n  for (let i = 0; i < $axis; i++) {\n    newShape[0] *= shape[i];\n  }\n  newShape[1] = shape[$axis];\n  for (let i = $axis + 1; i < shape.length; i++) {\n    newShape[2] *= shape[i];\n  }\n\n  // A map from unique elements (their string representations) to their values\n  // in \"indices\" (below).\n  const uniqueElements: {[key: string]: number} = {};\n  // The indices of each unique element in the original tensor along the given\n  // axis. It is 1D and has the same size as the given axis.\n  const indices = new Int32Array(shape[$axis]);\n  // Create a buffer so we can easily extract value at a given location.\n  const inputBuffer = new TensorBuffer(newShape, dtype, values as TypedArray);\n  // The indices along the given axis that have unique elements. This is a\n  // de-duped version of \"indices\" above.\n  const uniqueIndices: number[] = [];\n  const is1DTensor = newShape[0] === 1 && newShape[2] === 1;\n  for (let i = 0; i < shape[$axis]; i++) {\n    // Extract values along the axis.\n    let element: string;\n    if (is1DTensor) {\n      // Fast path for 1D tensor input.\n      element = values[i].toString();\n    } else {\n      const axisValues = [];\n      for (let m = 0; m < newShape[0]; m++) {\n        for (let n = 0; n < newShape[2]; n++) {\n          axisValues.push(inputBuffer.get(m, i, n));\n        }\n      }\n      element = axisValues.join(',');\n    }\n\n    // Dedup and update various indices.\n    if (uniqueElements[element] !== undefined) {\n      indices[i] = uniqueElements[element];\n    } else {\n      const uniqueIndex = Object.keys(uniqueElements).length;\n      uniqueElements[element] = uniqueIndex;\n      indices[i] = uniqueIndex;\n      uniqueIndices.push(i);\n    }\n  }\n\n  // Now we know where each of the unique elements are located along the axis\n  // (uniqueIndices). Extract them from input buffer and store them in the\n  // output buffer.\n  const outputTmpShape = newShape.slice();\n  outputTmpShape[1] = Object.keys(uniqueElements).length;\n  const outputBuffer = new TensorBuffer(outputTmpShape, dtype);\n  uniqueIndices.forEach((uniqueElementIndex, i) => {\n    for (let m = 0; m < newShape[0]; m++) {\n      for (let n = 0; n < newShape[2]; n++) {\n        outputBuffer.set(inputBuffer.get(m, uniqueElementIndex, n), m, i, n);\n      }\n    }\n  });\n\n  // The output shape can be calculated from the input shape with the size of\n  // the given axis replaced by the number of unique elements along that axis.\n  const outputShape = shape.slice();\n  outputShape[$axis] = outputTmpShape[1];\n\n  return {\n    outputValues: outputBuffer.values as BackendValues,\n    outputShape,\n    indices,\n  };\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray} from '@tensorflow/tfjs-core';\n\nexport type SimpleBinaryOperation = (a: number|string, b: number|string) =>\n    number;\nexport type SimpleBinaryKernelImpl =\n    (aShape: number[], bShape: number[], aVals: TypedArray|string[],\n     bVals: TypedArray|string[], dtype: DataType) => [TypedArray, number[]];\nexport type ComplexBinaryOperation =\n    (aReal: number, aImag: number, bReal: number, bImag: number) => {\n      real: number, imag: number\n    };\nexport type ComplexBinaryKernelImpl =\n    (aShape: number[], bShape: number[], aRealVals: Float32Array,\n     aImagVals: Float32Array, bRealVals: Float32Array,\n     bImagVals: Float32Array) => [TypedArray, TypedArray, number[]];\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n// Import shared functionality from tfjs-backend-cpu without triggering\n// side effects.\n// tslint:disable-next-line: no-imports-from-dist\nimport * as shared from '@tensorflow/tfjs-backend-cpu/dist/shared';\n// tslint:disable-next-line: no-imports-from-dist\nimport {SimpleBinaryKernelImpl} from '@tensorflow/tfjs-backend-cpu/dist/shared';\n// tslint:disable-next-line: no-imports-from-dist\nimport {SimpleUnaryImpl} from '@tensorflow/tfjs-backend-cpu/dist/utils/unary_types';\n\nexport type SimpleBinaryKernelImplCPU = SimpleBinaryKernelImpl;\nexport type SimpleUnaryKernelImplCPU = SimpleUnaryImpl;\nconst {\n  addImpl: addImplCPU,\n  ceilImpl: ceilImplCPU,\n  concatImpl: concatImplCPU,\n  equalImpl: equalImplCPU,\n  expImpl: expImplCPU,\n  expm1Impl: expm1ImplCPU,\n  floorImpl: floorImplCPU,\n  gatherNdImpl: gatherNdImplCPU,\n  gatherV2Impl: gatherV2ImplCPU,\n  greaterEqualImpl: greaterEqualImplCPU,\n  greaterImpl: greaterImplCPU,\n  lessEqualImpl: lessEqualImplCPU,\n  lessImpl: lessImplCPU,\n  logImpl: logImplCPU,\n  maxImpl: maxImplCPU,\n  maximumImpl: maximumImplCPU,\n  minimumImpl: minimumImplCPU,\n  multiplyImpl: multiplyImplCPU,\n  negImpl: negImplCPU,\n  notEqualImpl: notEqualImplCPU,\n  prodImpl: prodImplCPU,\n  rangeImpl: rangeImplCPU,\n  rsqrtImpl: rsqrtImplCPU,\n  simpleAbsImpl: simpleAbsImplCPU,\n  sliceImpl: sliceImplCPU,\n  stridedSliceImpl: stridedSliceImplCPU,\n  stringNGramsImpl: stringNGramsImplCPU,\n  subImpl: subImplCPU,\n  tileImpl: tileImplCPU,\n  transposeImpl: transposeImplCPU,\n  uniqueImpl: uniqueImplCPU,\n} = shared;\n\nexport {\n  addImplCPU,\n  ceilImplCPU,\n  concatImplCPU,\n  equalImplCPU,\n  expImplCPU,\n  expm1ImplCPU,\n  floorImplCPU,\n  gatherNdImplCPU,\n  gatherV2ImplCPU,\n  greaterEqualImplCPU,\n  greaterImplCPU,\n  lessEqualImplCPU,\n  lessImplCPU,\n  logImplCPU,\n  maxImplCPU,\n  maximumImplCPU,\n  minimumImplCPU,\n  multiplyImplCPU,\n  prodImplCPU,\n  negImplCPU,\n  notEqualImplCPU,\n  simpleAbsImplCPU,\n  sliceImplCPU,\n  stridedSliceImplCPU,\n  stringNGramsImplCPU,\n  subImplCPU,\n  rangeImplCPU,\n  rsqrtImplCPU,\n  tileImplCPU,\n  transposeImplCPU,\n  uniqueImplCPU,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Abs, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {simpleAbsImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const abs =\n    unaryKernelFunc({opType: UnaryOpType.ABS, cpuKernelImpl: simpleAbsImplCPU});\n\nexport const absConfig: KernelConfig = {\n  kernelName: Abs,\n  backendName: 'webgpu',\n  kernelFunc: abs\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Add, KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {addImplCPU as cpuAdd} from '../kernel_utils/shared';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const addKernelFunc = binaryKernelFunc({\n  opSnippet: BinaryOpType.ADD,\n  cpuKernelImpl: cpuAdd,\n  supportsComplex: true\n});\n\nexport const addConfig: KernelConfig = {\n  kernelName: Add,\n  backendName: 'webgpu',\n  kernelFunc: addKernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class AddNPackedProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames: string[];\n  workPerThread = 4;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  size: number;\n  useWgsl: boolean;\n\n  constructor(shapes: number[][]) {\n    this.outputShape = shapes[0];\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n    this.shaderKey = 'addN';\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(`float v${variable} = get${variable}AtOutCoords(coords);`);\n    });\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    const type = getCoordsDataType(this.outputShape.length);\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n        for (int i = 0; i < ${this.workPerThread}; i++) {\n          int flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < size) {\n            ${type} coords = getCoordsFromFlatIndex(flatIndex);\n            ${snippets.join('\\n        ')}\n            setOutput(flatIndex, ${operation});\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const snippets: string[] = [];\n    // Get target elements from every input tensor.\n    this.variableNames.forEach(variable => {\n      snippets.push(\n          `let v${variable} = get${variable}AtOutCoordsByCoords(coords);`);\n    });\n    // Calculate the sum of all elements.\n    const operation = this.variableNames\n                          .map(variable => {\n                            return `v${variable}`;\n                          })\n                          .join(' + ');\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        for (var i = 0u; i < ${this.workPerThread}u; i = i + 1u) {\n          let flatIndex = index * ${this.workPerThread}u + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(flatIndex);\n            ${snippets.join('\\n        ')}\n            setOutputFlat(flatIndex, ${operation});\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {AddN, AddNInputs, KernelConfig, KernelFunc, TensorInfo, upcastType} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {AddNPackedProgram} from './addn_packed_webgpu';\nimport {identity} from './Identity';\n\nexport function addN(args: {inputs: AddNInputs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend} = args;\n\n  const tensors = inputs;\n  if (tensors.length === 1) {\n    return identity({inputs: {x: tensors[0]}, backend});\n  }\n\n  const dtype =\n      tensors.map(t => t.dtype).reduce((d1, d2) => upcastType(d1, d2));\n  const shapes = tensors.map(t => t.shape);\n  const program = new AddNPackedProgram(shapes);\n  return backend.runWebGPUProgram(program, tensors, dtype);\n}\n\nexport const addNConfig: KernelConfig = {\n  kernelName: AddN,\n  backendName: 'webgpu',\n  kernelFunc: addN as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class ArgMinMaxProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'int axis;';\n  uniformsWgsl = 'axis : u32;';\n  inputShape: number[];\n  reductionFactor: number;\n  op: string;\n  useWgsl: boolean;\n\n  constructor(inputShape: number[], axis: number, reduceType: 'min'|'max') {\n    const axes = [axis];\n    backend_util.assertAxesAreInnerMostDims(\n        'arg' + reduceType.charAt(0).toUpperCase() + reduceType.slice(1), axes,\n        inputShape.length);\n\n    this.op = reduceType === 'min' ? '<' : '>';\n\n    // |outShape| is the shape with the removed axis\n    // |reduceShape| is the shape we are reducing. i.e. [ inputShape[axis] ]\n    const [outputShape, reduceShape] =\n        backend_util.computeOutAndReduceShapes(inputShape, axes);\n\n    this.outputShape = outputShape.length === 0 ? [1] : outputShape;\n\n    // Length of the axis we're reducing on.\n    const reduceSize = util.sizeFromShape(reduceShape);\n\n    // The number of comparisons each thread will do\n    this.reductionFactor = 2;\n    // Note that the maximum of workgroup X dimension is 256.\n    const xMaxThreads = 256;  // gl_MaxComputeWorkGroupSize.\n    const xThreads =\n        Math.min(Math.ceil(reduceSize / this.reductionFactor), xMaxThreads);\n\n    this.workGroupSize = [xThreads, 1, 1];\n\n    this.dispatchLayout = {x: [], y: this.outputShape.map((d, i) => i)};\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.inputShape = inputShape;\n    this.shaderKey = `argMinMax${this.op}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    // When this.workGroupSize[0] > 1, each thread reduces Length /\n    // this.workGroupSize[0] values. Thes results are stored in shared memory\n    // and iteratively reduced.\n    const reduceInSharedMemory = this.workGroupSize[0] > 1;\n    const sharedMemorySnippet = `\n      shared int xBestIndices[WorkGroupSize];\n      shared float xBestValues[WorkGroupSize];\n    `;\n\n    const sharedMemoryReduceSnippet = `\n      xBestIndices[gl_LocalInvocationID.x] = bestIndex;\n      xBestValues[gl_LocalInvocationID.x] = bestValue;\n\n      int currentSize = WorkGroupSize;\n      while (currentSize > 1) {\n        barrier();\n\n        for (int w = 0; w < ${this.reductionFactor}; ++w) {\n          int i = int(gl_LocalInvocationID.x) * ${this.reductionFactor} + w;\n          if (i < currentSize) {\n            int candidateIndex = xBestIndices[i];\n            float candidate = xBestValues[i];\n            if (candidate ${this.op} bestValue && !isnan(candidate)) {\n              bestValue = candidate;\n              bestIndex = candidateIndex;\n            }\n          }\n        }\n\n        xBestIndices[gl_LocalInvocationID.x] = bestIndex;\n        xBestValues[gl_LocalInvocationID.x] = bestValue;\n\n        currentSize = DIV_CEIL(currentSize, ${this.reductionFactor});\n      }\n\n      if (gl_LocalInvocationID.x == 0) {\n        setOutput(flatOutputIndex, int(bestIndex));\n      }\n    `;\n\n    const outputCoordsType = getCoordsDataType(this.outputShape.length);\n\n    const indexOutputCoords = (outputCoords: string, index: string) => {\n      if (this.outputShape.length === 1) {\n        return outputCoords;\n      } else {\n        return `${outputCoords}[${index}]`;\n      }\n    };\n\n    const indexInputShape = (index: string) => {\n      if (this.inputShape.length === 1) {\n        return 'xShape';\n      } else {\n        return `xShape[${index}]`;\n      }\n    };\n\n    const userCode = `\n      #define DIV_CEIL(x, y) (((x) - 1) / (y) + 1)\n\n      const int WorkGroupSize = int(gl_WorkGroupSize.x);\n\n      ${reduceInSharedMemory ? sharedMemorySnippet : ''}\n\n      // In order to get a flattened index into the input tensor, we need to\n      // add back the index along the reduced dimension to |outputCoords|.\n      // This function outputs the offset to the first value along\n      // |axis| and the stride to get the next value of the input along |axis|.\n      ivec2 getInputCoordInfo() {\n        const ${outputCoordsType} outputCoords = getOutputCoords();\n        int i = ${this.outputShape.length - 1};\n\n        int stride = 1;\n        int inputStride = 1;\n        int offset = 0;\n\n        for (int r = 1; r <= ${this.inputShape.length}; ++r) {\n          int length = ${indexInputShape(`${this.inputShape.length} - r`)};\n          if (${this.inputShape.length} - r == axis) {\n            inputStride = stride;\n          } else {\n            offset += ${indexOutputCoords('outputCoords', 'i--')} * stride;\n          }\n          stride *= length;\n        }\n\n        return ivec2(offset, inputStride);\n      }\n\n      int getInputIndex(ivec2 coordInfo, int index) {\n        return coordInfo[0] + coordInfo[1] * index;\n      }\n\n      void main() {\n        const ivec2 coordInfo = getInputCoordInfo();\n\n        int bestIndex = 0;\n        float bestValue = float(x[getInputIndex(coordInfo, bestIndex)]);\n\n        const int Length = ${indexInputShape('axis')};\n        const int WorkPerThread = DIV_CEIL(Length, WorkGroupSize);\n\n        for (int w = 0; w < WorkPerThread; ++w) {\n          int i = int(gl_GlobalInvocationID.x) * WorkPerThread + w;\n          if (i < Length) {\n            float candidate = float(x[getInputIndex(coordInfo, i)]);\n            if (candidate ${this.op} bestValue && !isnan(candidate)) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n        }\n\n        const int flatOutputIndex = int(gl_GlobalInvocationID.y);\n        ${\n        reduceInSharedMemory ? sharedMemoryReduceSnippet :\n                               'setOutput(flatOutputIndex, int(bestIndex));'}\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    // When this.workGroupSize[0] > 1, each thread reduces Length /\n    // this.workGroupSize[0] values. Thes results are stored in shared memory\n    // and iteratively reduced.\n    const reduceInSharedMemory = this.workGroupSize[0] > 1;\n    const sharedMemorySnippet = `\n      var<workgroup> xBestIndices : array<u32, ${this.workGroupSize[0]}>;\n      var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n    `;\n\n    const sharedMemoryReduceSnippet = `\n      xBestIndices[localId.x] = bestIndex;\n      xBestValues[localId.x] = bestValue;\n\n      for(var currentSize = WorkGroupSize; currentSize > 1u; currentSize = DIV_CEIL(currentSize, ${\n        this.reductionFactor}u)) {\n        workgroupBarrier();\n\n        for (var w = 0u; w < ${this.reductionFactor}u; w = w + 1u) {\n          let i = localId.x * ${this.reductionFactor}u + w;\n          if (i < currentSize) {\n            let candidateIndex = xBestIndices[i];\n            let candidate = xBestValues[i];\n            if(candidate ${this.op} bestValue && !isNanCustom(candidate)) {\n              bestValue = candidate;\n              bestIndex = candidateIndex;\n            }\n          }\n        }\n\n        xBestIndices[localId.x] = bestIndex;\n        xBestValues[localId.x] = bestValue;\n      }\n\n      if (localId.x == 0u) {\n        setOutputFlatI32(flatOutputIndex, i32(bestIndex));\n      }\n    `;\n\n    const outputCoordsType = getCoordsDataTypeWgsl(this.outputShape.length);\n\n    const indexOutputCoords = (outputCoords: string, index: string) => {\n      if (this.outputShape.length === 1) {\n        return outputCoords;\n      } else {\n        return `${outputCoords}[${index}]`;\n      }\n    };\n\n    const indexInputShape = (index: string) => {\n      if (this.inputShape.length === 1) {\n        return 'uniforms.xShape';\n      } else {\n        return `uniforms.xShape[${index}]`;\n      }\n    };\n\n    const userCode = `\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      let WorkGroupSize = ${this.workGroupSize[0]}u;\n\n      ${reduceInSharedMemory ? sharedMemorySnippet : ''}\n\n      // In order to get a flattened index into the input tensor, we need to\n      // add back the index along the reduced dimension to |outputCoords|.\n      // This function outputs the offset to the first value along\n      // |axis| and the stride to get the next value of the input along |axis|.\n      fn getInputCoordInfo(globalId : vec3<u32>, globalIndex : u32) -> vec2<u32>{\n        let outputCoords : ${\n        outputCoordsType} = getOutputCoords(globalId, globalIndex);\n        var i = ${this.outputShape.length - 1}u;\n\n        var stride = 1u;\n        var inputStride = 1u;\n        var offset = 0u;\n\n        for (var r = 1u; r <= ${this.inputShape.length}u; r = r + 1u) {\n          let length = ${indexInputShape(`${this.inputShape.length}u - r`)};\n          if (${this.inputShape.length}u - r == uniforms.axis) {\n            inputStride = stride;\n          } else {\n            offset = offset + ${\n        indexOutputCoords('outputCoords', 'i')} * stride;\n            i = i - 1u;\n          }\n          stride = stride * length;\n        }\n\n        return vec2<u32>(offset, inputStride);\n      }\n\n      fn getInputIndex(coordInfo : vec2<u32>, index : u32) -> u32{\n        return coordInfo[0] + coordInfo[1] * index;\n      }\n\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coordInfo = getInputCoordInfo(globalId, index);\n\n        var bestIndex = 0u;\n        var bestValue = x.numbers[getInputIndex(coordInfo, bestIndex)];\n\n        let Length = ${indexInputShape('uniforms.axis')};\n        let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);\n\n        for (var w = 0u; w < WorkPerThread; w = w + 1u) {\n          let i = globalId.x * WorkPerThread + w;\n          if (i < Length) {\n            let candidate = x.numbers[getInputIndex(coordInfo, i)];\n            if (candidate ${\n        this.op} bestValue && !isNanCustom(f32(candidate))) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n        }\n\n        let flatOutputIndex = globalId.y;\n        ${\n        reduceInSharedMemory ?\n            sharedMemoryReduceSnippet :\n            'setOutputFlatI32(flatOutputIndex, i32(bestIndex));'}\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class TransposeSharedProgram implements WebGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[]};\n  dispatch: [number, number, number];\n  // Note that the maximum number of workgroup invocations by webgpu is 256.\n  workGroupSize: [number, number, number] = [16, 16, 1];\n  useWgsl: boolean;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.dispatchLayout = {x: [0], y: [1]};\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize, [1, 1, 1]);\n\n    this.shaderKey = 'transposeShared';\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    const int TILE_DIM = ${this.workGroupSize[0]};\n    shared float tile[TILE_DIM][TILE_DIM + 1];\n    void main() {\n        int index = int(gl_GlobalInvocationID.x);\n        int x = int(gl_WorkGroupID.x) * TILE_DIM + int(gl_LocalInvocationID.x);\n        int y = int(gl_WorkGroupID.y) * TILE_DIM + int(gl_LocalInvocationID.y);\n        int width = outShape[0];\n        int height = outShape[1];\n        if (x < width && y < height) {\n          tile[gl_LocalInvocationID.y][gl_LocalInvocationID.x] =\n              A[y * width + x];\n        }\n        barrier();\n\n        x = int(gl_WorkGroupID.y) * TILE_DIM + int(gl_LocalInvocationID.x);\n        y = int(gl_WorkGroupID.x) * TILE_DIM + int(gl_LocalInvocationID.y);\n        if (x < height && y < width) {\n          setOutput((y * height + x), tile[gl_LocalInvocationID.x]\n            [gl_LocalInvocationID.y]);\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const userCode = `\n      let TILE_DIM = ${this.workGroupSize[0]}u;\n      var<workgroup> tile : array<array<f32, ${this.workGroupSize[0] + 1}>, ${\n        this.workGroupSize[0]}>;\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let workGroupID = (globalId - localId)/vec3<u32>(${\n        this.workGroupSize[0]}u, ${this.workGroupSize[1]}u, ${\n        this.workGroupSize[2]}u);\n        var x = workGroupID.x * TILE_DIM + localId.x;\n        var y = workGroupID.y * TILE_DIM + localId.y;\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] =\n              A.numbers[y * width + x];\n        }\n        workgroupBarrier();\n\n        x = workGroupID.y * TILE_DIM + localId.x;\n        y = workGroupID.x * TILE_DIM + localId.y;\n        if (x < height && y < width) {\n          setOutputFlat((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class TransposeProgram implements WebGPUProgram {\n  variableNames = ['A'];\n  shaderKey: string;\n  outputShape: number[];\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workPerThread = 4;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  newDim: number[];\n  size: number;\n  useWgsl: boolean;\n\n  constructor(aShape: number[], newDim: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[newDim[i]];\n    }\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n\n    this.newDim = newDim;\n    this.shaderKey = `transpose_${newDim}`;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const dtype = getCoordsDataType(this.outputShape.length);\n    const switched = getSwitchedCoords(this.newDim);\n\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n\n        for(int i = 0; i < ${this.workPerThread}; i++) {\n          int flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < size) {\n            ${dtype} resRC = getCoordsFromFlatIndex(flatIndex);\n            setOutput(flatIndex, A[getFlatIndex(\n              ${dtype}(${switched}), aShape)]);\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const dtype = getCoordsDataTypeWgsl(this.outputShape.length);\n    const switched = getSwitchedCoords(this.newDim);\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n\n        for(var i = 0u; i < ${this.workPerThread}u; i = i + 1u) {\n          let flatIndex = index * ${this.workPerThread}u + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromFlatIndex(flatIndex);\n            setOutputFlat(flatIndex, A.numbers[getFlatIndex${\n        this.outputShape.length}D(\n              ${dtype}(${switched}), uniforms.aShape)]);\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n\nfunction getSwitchedCoords(newDim: number[]): string {\n  const rank = newDim.length;\n  if (rank > 4) {\n    throw Error(`Transpose for rank ${rank} is not yet supported`);\n  }\n  const switchedCoords = new Array(rank);\n  for (let i = 0; i < newDim.length; i++) {\n    switchedCoords[newDim[i]] = `resRC[${i}]`;\n  }\n\n  return switchedCoords.join();\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Transpose, TransposeAttrs, TransposeInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {transposeImplCPU as cpuTranspose} from '../kernel_utils/shared';\n\nimport {TransposeSharedProgram} from './transpose_shared_webgpu';\nimport {TransposeProgram} from './transpose_webgpu';\n\nexport function transpose(args: {\n  inputs: TransposeInputs,\n  attrs: TransposeAttrs,\n  backend: WebGPUBackend\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {perm} = attrs;\n  const webgpuBackend = backend;\n\n  const xRank = x.shape.length;\n  const newShape: number[] = new Array(xRank);\n  for (let i = 0; i < newShape.length; i++) {\n    newShape[i] = x.shape[perm[i]];\n  }\n  if (backend.shouldExecuteOnCPU([x])) {\n    const xData = webgpuBackend.tensorMap.get(x.dataId);\n    const values = xData.values as TypedArray;\n    const outValues = cpuTranspose(values, x.shape, x.dtype, perm, newShape);\n    return backend.makeTensorInfo(newShape, x.dtype, outValues);\n  }\n  if (x.shape.length === 2 && util.arraysEqual(perm, [1, 0])) {\n    const program = new TransposeSharedProgram(x.shape, perm);\n    return webgpuBackend.runWebGPUProgram(program, [x], x.dtype);\n  }\n  const program = new TransposeProgram(x.shape, perm);\n  return webgpuBackend.runWebGPUProgram(program, [x], x.dtype);\n}\n\nexport const transposeConfig: KernelConfig = {\n  kernelName: Transpose,\n  backendName: 'webgpu',\n  kernelFunc: transpose as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ArgMax, ArgMaxAttrs, ArgMaxInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {ArgMinMaxProgram} from './argminmax_webgpu';\nimport {transpose} from './Transpose';\n\nexport function argMax(\n    args: {inputs: ArgMaxInputs, backend: WebGPUBackend, attrs: ArgMaxAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis} = attrs;\n\n  let axes = util.parseAxisParam(axis, x.shape);\n  const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n  let $x = x;\n  const intermediateTensorInfos = [];\n  if (permutedAxes != null) {\n    $x = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    intermediateTensorInfos.push($x);\n    axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('argMax', [axes[0]], $x.shape.length);\n  const program = new ArgMinMaxProgram($x.shape, axes[0], 'max');\n  const uniformData = [{type: 'int32', data: [axes[0]]}];\n  const out = backend.runWebGPUProgram(program, [$x], 'int32', uniformData);\n  intermediateTensorInfos.forEach(t => backend.disposeData(t.dataId));\n  return out;\n}\n\nexport const argMaxConfig: KernelConfig = {\n  kernelName: ArgMax,\n  backendName: 'webgpu',\n  kernelFunc: argMax as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ArgMin, ArgMinAttrs, ArgMinInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {ArgMinMaxProgram} from './argminmax_webgpu';\nimport {transpose} from './Transpose';\n\nexport function argMin(\n    args: {inputs: ArgMinInputs, backend: WebGPUBackend, attrs: ArgMinAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis} = attrs;\n\n  let axes = util.parseAxisParam(axis, x.shape);\n  const permutedAxes = backend_util.getAxesPermutation(axes, x.shape.length);\n  let $x = x;\n  const intermediateTensorInfos = [];\n  if (permutedAxes != null) {\n    $x = transpose({inputs: {x}, backend, attrs: {perm: permutedAxes}});\n    intermediateTensorInfos.push($x);\n    axes = backend_util.getInnerMostAxes(axes.length, $x.shape.length);\n  }\n\n  backend_util.assertAxesAreInnerMostDims('argMin', [axes[0]], $x.shape.length);\n  const program = new ArgMinMaxProgram($x.shape, axes[0], 'min');\n  const uniformData = [{type: 'int32', data: [axes[0]]}];\n  const out = backend.runWebGPUProgram(program, [$x], 'int32', uniformData);\n  intermediateTensorInfos.forEach(t => backend.disposeData(t.dataId));\n  return out;\n}\n\nexport const argMinConfig: KernelConfig = {\n  kernelName: ArgMin,\n  backendName: 'webgpu',\n  kernelFunc: argMin as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class Pool2DProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'ivec2 stride, pad, dilation, convDims, filterDims;';\n  uniformsWgsl =\n      `stride : vec2<i32>; pad : vec2<i32>; dilation : vec2<i32>; convDims : vec2<i32>; filterDims : vec2<i32>;`;\n  // TODO(jiajia.qin@intel.com): Dynamically choose different workGroupSize for\n  // different output shapes.\n  workGroupSize: [number, number, number] = [128, 1, 1];\n  poolType: 'max'|'avg';\n  useWgsl: boolean;\n\n  constructor(convInfo: backend_util.Conv2DInfo, poolType: 'max'|'avg') {\n    this.outputShape = convInfo.outShape;\n\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.shaderKey = `pool2D_${poolType}`;\n    this.poolType = poolType;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    let updateSnippet = `resultValue = max(value, resultValue);`;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue += value; count += 1.0;`;\n    }\n\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / count`;\n    }\n\n    const userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        if (coordsInBounds(coords, outShape)) {\n          int batch = coords[0];\n          ivec2 xRCCorner = coords.yz * stride - pad;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          float resultValue = ${\n        this.poolType === 'avg' ? '0.0' : '-1.0 / 1e-20'};\n          float count = 0.0;\n\n          for (int wR = 0; wR < filterDims.x; wR += dilation.x) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= convDims.x) {\n              continue;\n            }\n\n            for (int wC = 0; wC < filterDims.y; wC += dilation.y) {\n              int xC = xCCorner + wC;\n              if (xC < 0 || xC >= convDims.y) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, coords[3]);\n              ${updateSnippet}\n            }\n          }\n\n          setOutput(batch, coords[1], coords[2], coords[3], ${returnValue});\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let updateSnippet = `resultValue = max(value, resultValue);`;\n    if (this.poolType === 'avg') {\n      updateSnippet = `resultValue = resultValue + value; count = count + 1.0;`;\n    }\n\n    let returnValue = `resultValue`;\n    if (this.poolType === 'avg') {\n      returnValue = `resultValue / count`;\n    }\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coords = getOutputCoords(globalId, index);\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${\n        this.poolType === 'avg' ? '0.0' : '-1.0 / pow(10.0, -20.0)'};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, u32(xR), u32(xC), coords[3]);\n              ${updateSnippet}\n            }\n          }\n\n          setOutput(batch, coords[1], coords[2], coords[3], ${returnValue});\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class PoolWithFilterSizeEqualsOneProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'ivec2 stride;';\n  uniformsWgsl = `stride : vec2<i32>;`;\n  workGroupSize: [number, number, number] = [256, 1, 1];\n  useWgsl: boolean;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.shaderKey = 'poolWithFilterSizeEqualsOne';\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        if (all(lessThan(coords, outShape))) {\n          ivec2 xRCCorner = coords.yz * stride;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          float value = getX(batch, xRCorner, xCCorner, d);\n          setOutput(batch, coords[1], coords[2], d, value);\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coords = getOutputCoords(globalId, index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        if (all(coords < uniforms.outShape)) {\n          let xRCCorner = coords.yz * vec2<u32>(uniforms.stride);\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutput(batch, coords[1], coords[2], d, value);\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {AvgPool, AvgPoolAttrs, AvgPoolInputs, backend_util, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {identity} from './Identity';\nimport {Pool2DProgram} from './pool2d_webgpu';\nimport {PoolWithFilterSizeEqualsOneProgram} from './pool_filtersizeone_webgpu';\n\nexport function avgPool(\n    args: {inputs: AvgPoolInputs, backend: WebGPUBackend, attrs: AvgPoolAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  if (convInfo.filterWidth === 1 && convInfo.filterHeight === 1 &&\n      util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n    return identity({inputs: {x}, backend});\n  }\n\n  let program: Pool2DProgram|PoolWithFilterSizeEqualsOneProgram;\n  const dimensions =\n      [{type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]}];\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1) {\n    program = new PoolWithFilterSizeEqualsOneProgram(convInfo);\n  } else {\n    program = new Pool2DProgram(convInfo, 'avg');\n    dimensions.push(\n        {type: 'int32', data: [convInfo.padInfo.top, convInfo.padInfo.left]}, {\n          type: 'int32',\n          data: [convInfo.dilationHeight, convInfo.dilationWidth]\n        },\n        {type: 'int32', data: [convInfo.inHeight, convInfo.inWidth]}, {\n          type: 'int32',\n          data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]\n        });\n  }\n\n  return backend.runWebGPUProgram(program, [x], x.dtype, dimensions);\n}\n\nexport const avgPoolConfig: KernelConfig = {\n  kernelName: AvgPool,\n  backendName: 'webgpu',\n  kernelFunc: avgPool as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {BatchMatMul, BatchMatMulAttrs, BatchMatMulInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {batchMatMulImpl} from './BatchMatMul_impl';\n\nexport function batchMatMul(args: {\n  inputs: BatchMatMulInputs,\n  attrs: BatchMatMulAttrs,\n  backend: WebGPUBackend\n}) {\n  const {inputs, backend, attrs} = args;\n  const {a, b} = inputs;\n  const {transposeA, transposeB} = attrs;\n\n  return batchMatMulImpl({a, b, transposeA, transposeB, backend});\n}\n\nexport const batchMatMulConfig: KernelConfig = {\n  kernelName: BatchMatMul,\n  backendName: 'webgpu',\n  kernelFunc: batchMatMul as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class SliceProgram implements WebGPUProgram {\n  variableNames = ['source'];\n  uniforms: string;\n  uniformsWgsl: string;\n  outputShape: number[];\n  shaderKey: string;\n  rank: number;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workPerThread = 1;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  start: number[];\n  size: number;\n  useWgsl: boolean;\n\n  constructor(start: number[], destSize: number[]) {\n    this.outputShape = destSize;\n    this.rank = destSize.length;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n\n    this.start = start;\n    this.uniforms = `${getCoordsDataType(start.length)} start; `;\n    this.uniformsWgsl = `start : ${getCoordsDataTypeWgsl(start.length)}; `;\n    this.shaderKey = 'slice';\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getCoords(this.rank);\n    let coordSum;\n    if (this.start.length === 1) {\n      coordSum = this.outputShape.map((_, i) => {\n        return `sourceLoc.${coords[i]} = start + coords.${coords[i]};`;\n      });\n    } else {\n      coordSum = this.outputShape.map((_, i) => {\n        return `sourceLoc.${coords[i]} = start[${i}] + coords.${coords[i]};`;\n      });\n    }\n\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n        if (index < size)\n        {\n          ${dtype} sourceLoc;\n          ${dtype} coords = getOutputCoords();\n          ${coordSum.join('\\n')}\n          setOutput(index, getSource(${sourceCoords}));\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const dtype = getCoordsDataTypeWgsl(this.rank);\n    const sourceCoords = getCoords(this.rank);\n    let coordSum;\n    if (this.start.length === 1) {\n      coordSum = this.outputShape.map((_, i) => {\n        return `sourceLoc = uniforms.start + coords;`;\n      });\n    } else {\n      coordSum = this.outputShape.map((_, i) => {\n        return `sourceLoc.${coords[i]} = uniforms.start[${i}] + coords.${\n            coords[i]};`;\n      });\n    }\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if (index < uniforms.size)\n        {\n          var sourceLoc : ${dtype};\n          let coords = getOutputCoords(globalId, index);\n          ${coordSum.join('\\n')}\n          setOutputFlat(index, getSource(${sourceCoords}));\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n\nconst coords = ['x', 'y', 'z', 'w', 'u', 'v'];\n\nfunction getCoords(rank: number): string {\n  if (rank === 1) {\n    return 'sourceLoc';\n  } else if (rank <= 6) {\n    return coords.slice(0, rank).map(coord => `sourceLoc.${coord}`).join(',');\n  } else {\n    throw Error(`Slicing for rank ${rank} is not yet supported`);\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Slice, slice_util, SliceAttrs, SliceInputs, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {sliceImplCPU} from '../kernel_utils/shared';\nimport {SliceProgram} from './slice_webgpu';\n\nexport function slice(\n    args: {inputs: SliceInputs, backend: WebGPUBackend, attrs: SliceAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {begin, size} = attrs;\n\n  const [$begin, $size] = slice_util.parseSliceParams(x, begin, size);\n  slice_util.assertParamsValid(x, $begin, $size);\n\n  if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string') {\n    const xBufferInfo = backend.tensorMap.get(x.dataId);\n    const outValues = sliceImplCPU(\n        xBufferInfo.values as TypedArray, $begin, $size, x.shape, x.dtype);\n    return backend.makeTensorInfo($size, x.dtype, outValues);\n  }\n\n  if (util.sizeFromShape($size) === 0) {\n    return backend.makeTensorInfo($size, x.dtype, []);\n  }\n\n  // TODO(xing.xu): Add shadow slice support.\n  const program = new SliceProgram($begin, $size);\n  const uniformData = [{type: 'int32', data: $begin}];\n  return backend.runWebGPUProgram(program, [x], x.dtype, uniformData);\n}\n\nexport const sliceConfig: KernelConfig = {\n  kernelName: Slice,\n  backendName: 'webgpu',\n  kernelFunc: slice as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, BatchToSpaceND, BatchToSpaceNDAttrs, BatchToSpaceNDInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\nimport {transpose} from './Transpose';\n\nexport const batchToSpaceND = (args: {\n  inputs: BatchToSpaceNDInputs,\n  backend: WebGPUBackend,\n  attrs: BatchToSpaceNDAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockShape, crops} = attrs;\n\n  util.assert(\n      x.shape.length <= 4,\n      () => 'batchToSpaceND for rank > 4 with a WebGPU backend not ' +\n          'implemented yet');\n  const prod = blockShape.reduce((a, b) => a * b);\n\n  const reshaped = backend_util.getReshaped(x.shape, blockShape, prod);\n  const permuted = backend_util.getPermuted(reshaped.length, blockShape.length);\n  const reshapedPermuted =\n      backend_util.getReshapedPermuted(x.shape, blockShape, prod);\n  const sliceBeginCoords =\n      backend_util.getSliceBeginCoords(crops, blockShape.length);\n  const sliceSize =\n      backend_util.getSliceSize(reshapedPermuted, crops, blockShape.length);\n\n  const toDispose = [];\n\n  const reshapedIntermediate =\n      reshape({inputs: {x}, backend, attrs: {shape: reshaped}});\n  const transposedIntermediate = transpose(\n      {inputs: {x: reshapedIntermediate}, backend, attrs: {perm: permuted}});\n  const reshapedIntermediate2 = reshape({\n    inputs: {x: transposedIntermediate},\n    backend,\n    attrs: {shape: reshapedPermuted}\n  });\n  const sliced = slice({\n    inputs: {x: reshapedIntermediate2},\n    backend,\n    attrs: {begin: sliceBeginCoords, size: sliceSize}\n  });\n\n  toDispose.push(reshapedIntermediate);\n  toDispose.push(transposedIntermediate);\n  toDispose.push(reshapedIntermediate2);\n\n  toDispose.forEach(t => backend.disposeData(t.dataId));\n\n  return sliced;\n};\n\nexport const batchToSpaceNDConfig: KernelConfig = {\n  kernelName: BatchToSpaceND,\n  backendName: 'webgpu',\n  kernelFunc: batchToSpaceND as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, NotEqual} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {notEqualImplCPU as cpuNotEqual} from '../kernel_utils/shared';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const notEqual = binaryKernelFunc({\n  opSnippet: BinaryOpType.NOT_EQUAL,\n  dtype: 'bool',\n  cpuKernelImpl: cpuNotEqual\n});\n\nexport const notEqualConfig: KernelConfig = {\n  kernelName: NotEqual,\n  backendName: 'webgpu',\n  kernelFunc: notEqual\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Real, RealInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {identity} from './Identity';\n\nexport function real(args: {inputs: RealInputs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.tensorMap.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.real}, backend});\n}\n\nexport const realConfig: KernelConfig = {\n  kernelName: Real,\n  backendName: 'webgpu',\n  kernelFunc: real as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {TensorInfo} from '@tensorflow/tfjs-core';\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {UnaryOpProgram} from '../kernels/unary_op_webgpu';\nimport {UnaryOpType} from '../kernels/unary_op_util';\n\nexport function int(input: TensorInfo, backend: WebGPUBackend): TensorInfo {\n  const program = new UnaryOpProgram(input.shape, UnaryOpType.TO_INT);\n  const output = backend.runWebGPUProgram(program, [input], 'int32');\n  return {dataId: output.dataId, shape: output.shape, dtype: output.dtype};\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as tf from '@tensorflow/tfjs-core';\nimport {BinaryInputs, Cast, CastAttrs, CastInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {complex} from './Complex';\nimport {identity} from './Identity';\nimport {notEqual} from './NotEqual';\nimport {real} from './Real';\n\nimport {int} from '../kernel_utils/int';\n\nexport function cast(\n    args: {inputs: CastInputs, backend: WebGPUBackend, attrs: CastAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {dtype} = attrs;\n\n  // Casting to complex64.\n  if (dtype === 'complex64') {\n    if (x.dtype === 'complex64') {\n      return identity({inputs: {x}, backend});\n    }\n\n    // TODO: Import kernel function once zeros is modularized.\n    const zerosTensor = tf.zeros(x.shape);\n    const floatX = cast({inputs: {x}, backend, attrs: {dtype: 'float32'}});\n\n    const result =\n        complex({inputs: {real: floatX, imag: zerosTensor}, backend});\n\n    zerosTensor.dispose();\n    backend.disposeData(floatX.dataId);\n\n    return result;\n  }\n\n  // Casting from complex64\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const result = cast({inputs: {x: realPart}, backend, attrs: {dtype}});\n    backend.disposeData(realPart.dataId);\n    return result;\n  }\n\n  if (!util.hasEncodingLoss(x.dtype, dtype)) {\n    // We don't change the underlying data, since we cast to higher\n    // precision.\n    const result = identity({inputs: {x}, backend});\n    return {dataId: result.dataId, shape: result.shape, dtype};\n  }\n\n  if (dtype === 'int32') {\n    return int(x, backend);\n  }\n\n  if (dtype === 'bool') {\n    const zerosTensorInfo = backend.makeTensorInfo(\n        [], 'bool', util.getTypedArrayFromDType('bool', 1));\n\n    const binaryInputs: BinaryInputs = {a: x, b: zerosTensorInfo};\n\n    const result = notEqual({inputs: binaryInputs, backend}) as TensorInfo;\n    backend.disposeData(zerosTensorInfo.dataId);\n    return result;\n  }\n\n  throw new Error(`Error in Cast: failed to cast ${x.dtype} to ${dtype}`);\n}\n\nexport const castConfig: KernelConfig = {\n  kernelName: Cast,\n  backendName: 'webgpu',\n  kernelFunc: cast as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Ceil, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {ceilImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const ceil =\n    unaryKernelFunc({opType: UnaryOpType.CEIL, cpuKernelImpl: ceilImplCPU});\n\nexport const ceilConfig: KernelConfig = {\n  kernelName: Ceil,\n  backendName: 'webgpu',\n  kernelFunc: ceil\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class ClipVec4Program implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  variableNames = ['A'];\n  uniforms = 'float minVal; float maxVal;';\n  uniformsWgsl = 'minVal : f32; maxVal : f32;';\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workPerThread = 4;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  isVec4 = true;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(outputShape: number[]) {\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n    this.shaderKey = 'clipVec4';\n    this.size = util.sizeFromShape(this.outputShape) / 4;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n          if(index < size) {\n            vec4 value = getAAtOutCoords();\n            vec4 clampedValue;\n            for (int i = 0; i < 4; ++i) {\n              if (isnan(value[i])) {\n                clampedValue[i] = value[i];\n              } else {\n                clampedValue[i] = clamp(value[i], minVal, maxVal);\n              }\n            }\n\n            setOutput(index, clampedValue);\n          }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if(index < uniforms.size) {\n          let value = getAAtOutCoordsByGlobalId(globalId, index);\n          var clampedValue : vec4<f32>;\n          for (var i = 0u; i < 4u; i = i + 1u) {\n            if (isNanCustom(value[i])) {\n              clampedValue[i] = value[i];\n            } else {\n              clampedValue[i] = clamp(value[i], uniforms.minVal, uniforms.maxVal);\n            }\n          }\n\n          setOutputFlat(index, clampedValue);\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class ClipProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  variableNames = ['A'];\n  uniforms = 'float minVal; float maxVal;';\n  uniformsWgsl = 'minVal : f32; maxVal : f32;';\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  minVal: number;\n  maxVal: number;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(outputShape: number[]) {\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.shaderKey = 'clip';\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n        if(index < size) {\n          float value = getAAtOutCoords();\n          if (isnan(value)) {\n            setOutput(index, value);\n            return;\n          }\n          setOutput(index, clamp(value, minVal, maxVal));\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if(index < uniforms.size) {\n          let value = getAAtOutCoordsByGlobalId(globalId, index);\n          if (isNanCustom(value)) {\n            setOutputFlat(index, value);\n            return;\n          }\n          setOutputFlat(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ClipByValue, ClipByValueAttrs, ClipByValueInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {ClipVec4Program} from './clip_vec4_webgpu';\nimport {ClipProgram} from './clip_webgpu';\n\nexport function clipByValue(args: {\n  inputs: ClipByValueInputs,\n  backend: WebGPUBackend,\n  attrs: ClipByValueAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {clipValueMin, clipValueMax} = attrs;\n\n  let program: ClipProgram|ClipVec4Program;\n  const uniformData = [\n    {type: 'float32', data: [clipValueMin]},\n    {type: 'float32', data: [clipValueMax]}\n  ];\n  if (util.sizeFromShape(x.shape) % 4 === 0) {\n    program = new ClipVec4Program(x.shape);\n  } else {\n    program = new ClipProgram(x.shape);\n  }\n  return backend.runWebGPUProgram(program, [x], x.dtype, uniformData);\n}\n\nexport const clipByValueConfig: KernelConfig = {\n  kernelName: ClipByValue,\n  backendName: 'webgpu',\n  kernelFunc: clipByValue as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class ConcatProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames: string[];\n  workPerThread = 4;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  shapes: Array<[number, number]>;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(shapes: Array<[number, number]>) {\n    this.outputShape =\n        backend_util.computeOutShape(shapes, 1 /* axis */) as [number, number];\n    this.variableNames = shapes.map((_, i) => `T${i}`);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n\n    this.shapes = shapes;\n    // shapes is used by const snippets.\n    this.shaderKey = `concat${shapes}`;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const offsets: number[] = new Array(this.shapes.length - 1);\n    const snippets: string[] = [];\n    if (offsets.length > 0) {\n      offsets[0] = this.shapes[0][1];\n      for (let i = 1; i < offsets.length; i++) {\n        offsets[i] = offsets[i - 1] + this.shapes[i][1];\n      }\n\n      snippets.push(`if (yC < ${\n          offsets[0]}) setOutput(coords.x, coords.y, getT0(yR, yC));`);\n      for (let i = 1; i < offsets.length; i++) {\n        const shift = offsets[i - 1];\n        snippets.push(\n            `else if (yC < ${offsets[i]}) ` +\n            `setOutput(coords.x, coords.y, getT${i}(yR, yC-${shift}));`);\n      }\n      const lastIndex = offsets.length;\n      const lastShift = offsets[offsets.length - 1];\n      snippets.push(`else setOutput(coords.x, coords.y, getT${\n          lastIndex}(yR, yC-${lastShift}));`);\n    } else {\n      snippets.push(`setOutput(coords.x, coords.y, getT0(yR, yC));`);\n    }\n\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n\n        for(int i = 0; i < ${this.workPerThread}; i++) {\n          int flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < size) {\n            ivec2 coords = getCoordsFromFlatIndex(flatIndex);\n            int yR = coords.x;\n            int yC = coords.y;\n\n            ${snippets.join('\\n        ')}\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const offsets: number[] = new Array(this.shapes.length - 1);\n    const snippets: string[] = [];\n    if (offsets.length > 0) {\n      offsets[0] = this.shapes[0][1];\n      for (let i = 1; i < offsets.length; i++) {\n        offsets[i] = offsets[i - 1] + this.shapes[i][1];\n      }\n\n      snippets.push(`if (yC < ${\n          offsets[0]}u){ setOutput(coords.x, coords.y, getT0(yR, yC)); }`);\n      for (let i = 1; i < offsets.length; i++) {\n        const shift = offsets[i - 1];\n        snippets.push(\n            `elseif (yC < ${offsets[i]}u){ ` +\n            `setOutput(coords.x, coords.y, getT${i}(yR, yC - ${shift}u)); }`);\n      }\n      const lastIndex = offsets.length;\n      const lastShift = offsets[offsets.length - 1];\n      snippets.push(`else { setOutput(coords.x, coords.y, getT${\n          lastIndex}(yR, yC - ${lastShift}u)); }`);\n    } else {\n      snippets.push(`setOutput(coords.x, coords.y, getT0(yR, yC));`);\n    }\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        for(var i = 0u; i < ${this.workPerThread}u; i = i + 1u) {\n          let flatIndex = index * ${this.workPerThread}u + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromFlatIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${snippets.join('\\n        ')}\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Imag, ImagInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {identity} from './Identity';\n\nexport function imag(args: {inputs: ImagInputs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {input} = inputs;\n  const inputData = backend.tensorMap.get(input.dataId);\n\n  return identity({inputs: {x: inputData.complexTensorInfos.imag}, backend});\n}\n\nexport const imagConfig: KernelConfig = {\n  kernelName: Imag,\n  backendName: 'webgpu',\n  kernelFunc: imag as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, ConcatInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {concatImplCPU} from '../kernel_utils/shared';\n\nimport {complex} from './Complex';\nimport {ConcatProgram} from './concat_webgpu';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {reshape} from './Reshape';\n\nexport function concatImpl(\n    inputs: ConcatInputs, axis: number, backend: WebGPUBackend): TensorInfo {\n  const dtype = inputs[0].dtype;\n  if (dtype === 'complex64') {\n    const reals = inputs.map((t) => real({inputs: {input: t}, backend}));\n    const imags = inputs.map((t) => imag({inputs: {input: t}, backend}));\n\n    const realConcated = concatImpl(reals, axis, backend);\n    const imagConcated = concatImpl(imags, axis, backend);\n\n    const result =\n        complex({inputs: {real: realConcated, imag: imagConcated}, backend});\n\n    reals.forEach(r => backend.disposeData(r.dataId));\n    imags.forEach(i => backend.disposeData(i.dataId));\n    backend.disposeData(realConcated.dataId);\n    backend.disposeData(imagConcated.dataId);\n\n    return result;\n  }\n\n  let runOnCpu = backend.shouldExecuteOnCPU(inputs);\n\n  // Run on cpu if dtype is string. For string, the backend represents it\n  // as Uint8Array[], where each Uint8Array is a character. Given that the\n  // computation is only on the outer array, uploading the whole data onto\n  // gpu is wasteful. Also, currently webgpu doesn't have a design to\n  // upload and retrieve Uint8Array[] between cpu and gpu. Therefore, we\n  // just run the kernel on cpu if dtype is string.\n  if (dtype === 'string') {\n    runOnCpu = true;\n  }\n\n  if (runOnCpu) {\n    // Any concat of n-dimensional tensors across any axis can be reduced to\n    // a concatenation of two-dimensional tensors across the axis 1 by first\n    // partitioning the axes of the original tensors into those less than the\n    // axis to be concatenated and the rest. Then reshape the tensors\n    // into a two-dimensional tensor by collapsing these two sets of axes and\n    // concatenate the resulting matrices across the axis 1, finally reshaping\n    // the result to have the proper shape.\n    const tensors2D = inputs.map(t => {\n      const innerSize = util.sizeFromShape(t.shape.slice(axis));\n      const shape = [-1, innerSize];\n      return reshape({inputs: {x: t}, backend, attrs: {shape}});\n    });\n\n    const inputsValShapes = tensors2D.map(t => {\n      return {vals: backend.readSync(t.dataId), shape: t.shape};\n    });\n\n    // Concats 2d tensors along axis=1.\n    const outShape =\n        backend_util.computeOutShape(tensors2D.map(t => t.shape), 1 /* axis */);\n    const simplyConcat = tensors2D[0].shape[0] === 1;\n    const outVals =\n        concatImplCPU(inputsValShapes, outShape, dtype, simplyConcat);\n\n    const finalOutShape =\n        backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n\n    const outInfo = backend.makeTensorInfo(finalOutShape, dtype, outVals);\n\n    tensors2D.forEach(t => backend.disposeData(t.dataId));\n\n    return outInfo;\n  }\n\n  const {tensors2D, outShape} = computeTensors2D(inputs, axis, backend);\n  const program =\n      new ConcatProgram((tensors2D).map(t => t.shape as [number, number]));\n  const res = backend.runWebGPUProgram(program, tensors2D, tensors2D[0].dtype);\n  tensors2D.forEach(r => backend.disposeData(r.dataId));\n\n  const reshapedResult =\n      reshape({inputs: {x: res}, backend, attrs: {shape: outShape}});\n  backend.disposeData(res.dataId);\n  return reshapedResult;\n}\n\nfunction computeTensors2D(\n    inputs: ConcatInputs, axis: number, backend: WebGPUBackend) {\n  const outShape = backend_util.computeOutShape(inputs.map(t => t.shape), axis);\n  const tensors2D = inputs.map(t => reshape({\n                                 inputs: {x: t},\n                                 backend,\n                                 attrs: {\n                                   shape: [\n                                     util.sizeFromShape(t.shape.slice(0, axis)),\n                                     util.sizeFromShape(t.shape.slice(axis))\n                                   ]\n                                 }\n                               }));\n\n  return {tensors2D, outShape};\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Concat, ConcatAttrs, ConcatInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {concatImpl} from './Concat_impl';\nimport {identity} from './Identity';\n\nexport function concat(\n    args: {inputs: ConcatInputs, attrs: ConcatAttrs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  const $axis = util.parseAxisParam(axis, inputs[0].shape)[0];\n  const outShape =\n      backend_util.computeOutShape(inputs.map(t => t.shape), $axis);\n  if (util.sizeFromShape(outShape) === 0) {\n    return backend.makeTensorInfo(outShape, inputs[0].dtype, []);\n  }\n\n  // Keep only non-empty tensors (ignore tensors with 0 in their shape).\n  const $inputs = inputs.filter(t => util.sizeFromShape(t.shape) > 0);\n  if ($inputs.length === 1) {\n    return identity({inputs: {x: $inputs[0]}, backend});\n  }\n\n  const shapes = $inputs.map(t => t.shape);\n  backend_util.assertParamsConsistent(shapes, $axis);\n\n  return concatImpl($inputs, $axis, backend);\n}\n\nexport const concatConfig: KernelConfig = {\n  kernelName: Concat,\n  backendName: 'webgpu',\n  kernelFunc: concat as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getWorkGroupSizeStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class Im2ColProgram implements WebGPUProgram {\n  variableNames = ['A'];\n  uniforms = `ivec2 pad, stride, dilation; int outWidth, itemsPerBlockRow,\n      inChannels;`;\n  uniformsWgsl = `pad : vec2<u32>; stride : vec2<u32>; dilation : vec2<u32>; outWidth : u32; itemsPerBlockRow : u32;\n      inChannels : u32;`;\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workPerThread = 4;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  isChannelsLast: boolean;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(outputShape: number[], isChannelsLast: boolean) {\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n    this.isChannelsLast = isChannelsLast;\n    this.shaderKey = `im2col_${this.isChannelsLast}`;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const rowDim = this.isChannelsLast ? 0 : 1;\n    const colDim = this.isChannelsLast ? 1 : 2;\n\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n\n        for(int i=0; i<${this.workPerThread}; i++) {\n          int flatIndex = index * ${this.workPerThread} + i;\n\n          ivec2 rc = getCoordsFromFlatIndex(flatIndex);\n\n          if(flatIndex < size) {\n            int blockIndex = rc[0];\n            int pos = rc[1];\n\n            int offsetY = int(blockIndex / outWidth) * stride[1] - pad[1];\n            int d0 = offsetY + dilation[1] * (pos / itemsPerBlockRow);\n            float value = 0.0;\n            if(d0 < aShape[${rowDim}] && d0 >= 0) {\n              int offsetX = int(mod(blockIndex, outWidth) * stride[0] -\n                pad[0]);\n              int d1 = offsetX + dilation[0] * (int(mod(pos,\n                itemsPerBlockRow) / inChannels));\n              int ch = int(mod(pos, inChannels));\n              if(d1 < aShape[${colDim}] && d1 >= 0) {\n                value = getA(d0, d1, ch);\n              }\n            }\n            setOutput(flatIndex, value);\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const rowDim = this.isChannelsLast ? 0 : 1;\n    const colDim = this.isChannelsLast ? 1 : 2;\n\n    const userCode = `\n    ${getWorkGroupSizeStringWgsl()}\n    fn main([[builtin(global_invocation_id)]] globalId : vec3<u32>) {\n      let index = globalId.x;\n\n      for(var i = 0u; i<${this.workPerThread}u; i = i + 1u) {\n        let flatIndex = index * ${this.workPerThread}u + i;\n\n        let rc = getCoordsFromFlatIndex(flatIndex);\n\n        if(flatIndex < uniforms.size) {\n          let blockIndex = rc[0];\n          let pos = rc[1];\n\n          let offsetY = i32(u32(blockIndex / uniforms.outWidth) * uniforms.stride[1] - uniforms.pad[1]);\n          let d0 = offsetY + i32(uniforms.dilation[1] * (pos / uniforms.itemsPerBlockRow));\n          var value = 0.0;\n          if(d0 < i32(uniforms.aShape[${rowDim}]) && d0 >= 0) {\n            let offsetX = i32((blockIndex % uniforms.outWidth) * uniforms.stride[0] -\n              uniforms.pad[0]);\n            let d1 = offsetX + i32(uniforms.dilation[0]) * (i32((pos %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels));\n            let ch = u32(pos % uniforms.inChannels);\n            if(d1 < i32(uniforms.aShape[${colDim}]) && d1 >= 0) {\n              value = getA(u32(d0), u32(d1), ch);\n            }\n          }\n          setOutputFlat(flatIndex, value);\n        }\n      }\n    }\n  `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {batchMatMulImpl} from './BatchMatMul_impl';\nimport {Im2ColProgram} from './im2col_webgpu';\nimport {MatMulPackedProgram} from './matmul_packed_webgpu';\nimport {reshape} from './Reshape';\n\ntype Conv2DConfig = {\n  x: TensorInfo,\n  filter: TensorInfo,\n  convInfo: backend_util.Conv2DInfo,\n  backend: WebGPUBackend,\n  bias?: TensorInfo,\n  preluActivationWeights?: TensorInfo,\n  leakyreluAlpha?: number,\n  activation?: backend_util.Activation\n};\n\n// For 1x1 kernels that iterate through every point in the input, convolution\n// can be expressed as matrix multiplication (without need for memory\n// remapping).\nexport function conv2dByMatMul({\n  x,\n  filter,\n  convInfo,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: Conv2DConfig) {\n  const xShape = x.shape;\n  const isChannelsLast = convInfo.dataFormat === 'channelsLast';\n  const transposeA = false;\n  const transposeB = false;\n\n  const targetShape = isChannelsLast ? xShape[0] * xShape[1] * xShape[2] :\n                                       xShape[0] * xShape[2] * xShape[3];\n  const xReshaped = reshape({\n    inputs: {x},\n    backend,\n    attrs: {shape: [1, targetShape, convInfo.inChannels]}\n  });\n  const filterReshaped = reshape({\n    inputs: {x: filter},\n    backend,\n    attrs: {shape: [1, convInfo.inChannels, convInfo.outChannels]}\n  });\n\n  const result = batchMatMulImpl({\n    a: xReshaped,\n    b: filterReshaped,\n    transposeA,\n    transposeB,\n    backend,\n    bias,\n    activation,\n    preluActivationWeights,\n    leakyreluAlpha\n  });\n  const out = reshape(\n      {inputs: {x: result}, backend, attrs: {shape: convInfo.outShape}});\n\n  backend.disposeData(xReshaped.dataId);\n  backend.disposeData(filterReshaped.dataId);\n  backend.disposeData(result.dataId);\n\n  return out;\n}\n\n// Implements the im2row algorithm as outlined in \"High Performance\n// Convolutional Neural Networks for Document Processing\" (Suvisoft, 2006)\nexport function conv2dWithIm2Col({\n  x,\n  filter,\n  convInfo,\n  backend,\n  bias = null,\n  preluActivationWeights = null,\n  leakyreluAlpha = 0,\n  activation = null\n}: Conv2DConfig) {\n  // Rearranges conv2d input so each block to be convolved over forms the\n  // column of a new matrix with shape [filterWidth * filterHeight *\n  // inChannels, outHeight * outWidth]. The filter is also rearranged so each\n  // output channel forms a row of a new matrix with shape [outChannels,\n  // filterWidth * filterHeight * inChannels]. The convolution is then\n  // computed by multiplying these matrices and reshaping the result.\n  const {\n    filterWidth,\n    filterHeight,\n    inChannels,\n    strideWidth,\n    strideHeight,\n    padInfo,\n    outWidth,\n    outHeight,\n    dilationWidth,\n    dilationHeight,\n    dataFormat\n  } = convInfo;\n\n  const isChannelsLast = dataFormat === 'channelsLast';\n\n  const sharedDim = filterWidth * filterHeight * inChannels;\n  const numCols = outHeight * outWidth;\n  const x2ColShape = [numCols, sharedDim];\n  const transposeA = false;\n  const transposeB = false;\n\n  const intermediates: TensorInfo[] = [];\n\n  const xSqueezed =\n      reshape({inputs: {x}, backend, attrs: {shape: x.shape.slice(1)}});\n  const w2Row = reshape(\n      {inputs: {x: filter}, backend, attrs: {shape: [1, sharedDim, -1]}});\n\n  intermediates.push(xSqueezed);\n  intermediates.push(w2Row);\n\n  const im2ColProgram = new Im2ColProgram(x2ColShape, isChannelsLast);\n  const dimensions = [\n    {type: 'int32', data: [padInfo.left, padInfo.top]},      // Padding.\n    {type: 'int32', data: [strideWidth, strideHeight]},      // Stride.\n    {type: 'int32', data: [dilationWidth, dilationHeight]},  // Dilation.\n    {type: 'int32', data: [outWidth]},\n    {type: 'int32', data: [inChannels * filterWidth]},  // itemsPerBlockRow.\n    {type: 'int32', data: [inChannels]}\n  ];\n  const im2Col = backend.runWebGPUProgram(\n      im2ColProgram, [xSqueezed], xSqueezed.dtype, dimensions);\n  const im2Col3D = reshape({\n    inputs: {x: im2Col},\n    backend,\n    attrs: {shape: [1, x2ColShape[0], x2ColShape[1]]}\n  });\n  intermediates.push(im2Col);\n  intermediates.push(im2Col3D);\n  const a3dShape: [number, number, number] = [1, x2ColShape[0], x2ColShape[1]];\n  const matMulProgram = new MatMulPackedProgram(\n      a3dShape, [1, numCols, convInfo.outChannels],\n      env().get('WEBGPU_MATMUL_WORK_PER_THREAD') as number, transposeA,\n      transposeB);\n  let matmulDimensions = null;\n  if (matMulProgram.useWgsl) {\n    const dimAOuter = a3dShape[1];\n    const dimInner = a3dShape[2];\n    const dimBOuter = convInfo.outChannels;\n    matmulDimensions = [\n      {type: 'uint32', data: [dimAOuter]}, {type: 'uint32', data: [dimBOuter]},\n      {type: 'uint32', data: [dimInner]}\n    ];\n  }\n\n  const result: TensorInfo = backend.runWebGPUProgram(\n      matMulProgram, [im2Col3D, w2Row], im2Col3D.dtype, matmulDimensions);\n\n  const outShape = isChannelsLast ?\n      [1, outHeight, outWidth, convInfo.outChannels] :\n      [1, convInfo.outChannels, outHeight, outWidth];\n  const out = reshape({inputs: {x: result}, backend, attrs: {shape: outShape}});\n\n  intermediates.push(result);\n  for (const i of intermediates) {\n    backend.disposeData(i.dataId);\n  }\n\n  return out;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {computeDispatch, tilesFitEvenlyIntoShape} from '../webgpu_util';\nimport {mapActivationToShaderProgram} from './activation_util';\n\nimport {makeMatMulPackedVec4Source, makeMatMulPackedVec4SourceWgsl} from './matmul_packed_vec4_webgpu';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class Conv2DMMVec4Program implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  uniforms = 'ivec2 filterDims, pad, stride, dilation;';\n  uniformsWgsl =\n      `filterDims : vec2<u32>; pad : vec2<u32>; stride : vec2<u32>; dilation : vec2<u32>;\n      dimAOuter : u32; dimBOuter : u32; dimInner : u32;`;\n  workGroupSize: [number, number, number];\n  useWgsl: boolean;\n  isVec4 = true;\n  convInfo: backend_util.Conv2DInfo;\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  hasLeakyreluAlpha: boolean;\n  fitA: boolean;\n  fitB: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: backend_util.Activation = null,\n      hasPreluActivationWeights = false, hasLeakyreluAlpha = false) {\n    this.outputShape = convInfo.outShape;\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n    this.dispatchLayout = {x: [3], y: [1, 2], z: [0]};\n    this.workGroupSize = [8, 8, 1];\n    const elementsPerThread: [number, number, number] = [4, 4, 1];\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        elementsPerThread);\n    this.convInfo = convInfo;\n    this.addBias = addBias;\n    this.useWgsl = getUseWgsl();\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n    this.hasLeakyreluAlpha = hasLeakyreluAlpha;\n    if (this.addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (this.hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    if (this.hasLeakyreluAlpha) {\n      this.variableNames.push('leakyreluAlpha');\n    }\n\n    [this.fitA, this.fitB] = this.getShapeFit(elementsPerThread);\n    this.shaderKey =\n        `conv2DMMVec4_${this.activation}_${this.fitA}_${this.fitB}`;\n  }\n\n  getShapeFit(elementsPerThread: [number, number, number]): boolean[] {\n    const tileAOuter = this.workGroupSize[1] * elementsPerThread[1];\n    const tileBOuter = this.workGroupSize[0] * elementsPerThread[0];\n    const tileInner = tileBOuter;\n\n    const tileSizeA = [tileAOuter, tileInner];\n    const tileSizeB = [tileInner, tileBOuter];\n    const dimAOuter = this.outputShape[1] * this.outputShape[2];\n    const dimBOuter = this.outputShape[3];\n    const dimInner = this.convInfo.filterHeight * this.convInfo.filterWidth *\n        this.convInfo.inChannels;\n    return [\n      tilesFitEvenlyIntoShape(tileSizeA, [dimAOuter, dimInner]),\n      tilesFitEvenlyIntoShape(tileSizeB, [dimInner, dimBOuter])\n    ];\n  }\n  getUserCode(): string {\n    const elementsPerThread: [number, number, number] = [4, 4, 1];\n    const matMulSource = makeMatMulPackedVec4Source(elementsPerThread);\n\n    // Below code only applys to valid padding type.\n    const sampleAWithRemainder = `int flatIndex = getFlatIndex(coord, xShape);\n        int divBy4Remainder = flatIndex % 4;\n        int divBy4Index = flatIndex / 4;\n        vec4 curData = x[divBy4Index];\n        if (divBy4Remainder == 0) {\n          temp = curData;\n        } else {\n          // TODO: This could end up being a redundant load with another one in\n          // the same shader invocation. Perhaps there's an opportunity for\n          // optimization\n          vec4 nextData = x[divBy4Index + 1];\n          if (divBy4Remainder == 1) {\n            temp = vec4(curData.yzw, nextData.x);\n          } else if (divBy4Remainder == 2) {\n            temp = vec4(curData.zw, nextData.xy);\n          } else if (divBy4Remainder == 3) {\n            temp = vec4(curData.w, nextData.xyz);\n          }\n        }\n        `;\n\n    const remainder = this.convInfo.inChannels % 4;\n    const remainderSnippet = remainder === 0 ?\n        `// The bounds checking is always needed since we use it to pad zero for\n        // the 'same' padding type.\n        resData = coordsInBounds(coord, xShape) ?\n        x[getFlatIndex(coord, xShape) / 4] : vec4(0.0);` :\n        `vec4 temp = vec4(0.0);\n        ${sampleAWithRemainder}\n        resData = temp;\n        if (WCol == (filterDims[1] - 1)) {\n          coord = ivec4(\n            coord.x, coord.y + 1, coord.z + 1 - filterDims[1], 0);\n          ${sampleAWithRemainder}\n          if (inChCoord == 0) {\n            resData = vec4(resData.xyz, temp.x);\n          } else if (inChCoord == 1) {\n            resData = vec4(resData.xy, temp.xy);\n          } else {\n            resData = vec4(resData.x, temp.xyz);\n          }\n        }\n        `;\n\n    const readASnippet = `int outRow = r / outShape[2];\n        int outCol = r % outShape[2];\n        int WRow = c / (filterDims[1] * xShape[3]);\n        int WCol = (c / xShape[3]) % filterDims[1];\n        int inChCoord = c % xShape[3];\n        ivec4 coord = ivec4(\n            batch,\n            outRow * stride[0] + dilation[0] * WRow - pad[0],\n            outCol * stride[1] + dilation[1] * WCol - pad[1],\n            inChCoord);\n        vec4 resData = vec4(0.0);\n        ${remainderSnippet}\n        return resData;`;\n\n    const sampleA =\n        this.fitA ? `${readASnippet}` : `if (r < dimAOuter && c < dimInner) {\n          ${readASnippet}\n        } else {\n          return vec4(0.0);\n        }`;\n\n    const sampleB = this.fitB ?\n        `W[row * dimBOuter / 4 + col]` :\n        `coordsInBounds(ivec2(row, col * 4), ivec2(dimInner, dimBOuter)) ?\n            W[row * dimBOuter / 4 + col] : vec4(0.0)`;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(\n          this.activation, this.isVec4, this.useWgsl);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet = `vec4 activation(vec4 a, ivec4 outCoord) {\n          vec4 b = getPreluActivationWeightsAtOutCoords(outCoord);\n          ${activationOp}\n        }`;\n      } else if (this.hasLeakyreluAlpha) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${activationOp}\n        }`;\n        throw new Error('Leakyrelu is not supported.');\n      } else {\n        activationSnippet = `\n        vec4 activation(vec4 a, ivec4 outCoord) {\n          ${activationOp}\n        }`;\n      }\n\n      applyActivationSnippet = `value = activation(value, outCoord);`;\n    }\n\n    const addBiasSnippet = this.addBias ? 'ivec4 coords = getOutputCoords(); ' +\n            'value += getBiasAtOutCoords(outCoord);' :\n                                          '';\n\n    const userCode = `\n        ${activationSnippet}\n        ${matMulSource}\n\n        int batch;\n        int dimAOuter = outShape[1] * outShape[2];\n        int dimBOuter = outShape[3];\n        int dimInner = filterDims[0] * filterDims[1] * xShape[3];\n        vec4 mm_readA(int row, int col) {\n          int r = int(row), c = int(col * 4);\n          ${sampleA};\n        }\n\n        vec4 mm_readB(int row, int col) {\n          return ${sampleB};\n        }\n\n        void mm_write(int row, int col, vec4 value) {\n          if (row < dimAOuter && col * 4 < dimBOuter)\n          {\n            ivec4 outCoord = ivec4(\n              batch,\n              row / outShape[2],\n              row % outShape[2],\n              col * 4);\n            ${addBiasSnippet}\n            ${applyActivationSnippet}\n            setOutput(outCoord[0], outCoord[1], outCoord[2], outCoord[3],\n              value);\n          }\n        }\n\n        void main() {\n          batch = int(gl_GlobalInvocationID.z);\n\n          mm_matMul(dimAOuter, dimInner, dimBOuter);\n        }\n      `;\n    return userCode;\n  }\n\n  // index is used to avoid repeated definition error.\n  getSampleAWithRemainderWgsl(index: number): string {\n    return `let flatIndex${index} = getFlatIndex4D(coord, uniforms.xShape);\n    let divBy4Remainder${index} = flatIndex${index} % 4u;\n    let divBy4Index${index} = flatIndex${index} / 4u;\n    let curData${index} = x.numbers[divBy4Index${index}];\n    if (divBy4Remainder${index} == 0u) {\n      temp = curData${index};\n    } else {\n      // TODO: This could end up being a redundant load with another one in\n      // the same shader invocation. Perhaps there's an opportunity for\n      // optimization\n      let nextData${index} = x.numbers[divBy4Index${index} + 1u];\n      if (divBy4Remainder${index} == 1u) {\n        temp = vec4<f32>(curData${index}.yzw, nextData${index}.x);\n      } elseif (divBy4Remainder${index} == 2u) {\n        temp = vec4<f32>(curData${index}.zw, nextData${index}.xy);\n      } elseif (divBy4Remainder${index} == 3u) {\n        temp = vec4<f32>(curData${index}.w, nextData${index}.xyz);\n      }\n    }\n    `;\n  }\n\n  getUserCodeWgsl(): string {\n    const elementsPerThread: [number, number, number] = [4, 4, 1];\n    const matMulSource =\n        makeMatMulPackedVec4SourceWgsl(elementsPerThread, this.workGroupSize);\n\n    const remainder = this.convInfo.inChannels % 4;\n    // Below code only applys to valid padding type.\n    const remainderSnippet = remainder === 0 ?\n        `// The bounds checking is always needed since we use it to pad zero for\n          // the 'same' padding type.\n          if (coordsInBounds4D(coord, uniforms.xShape)) {\n            resData = x.numbers[getFlatIndex4D(coord, uniforms.xShape) / 4u];\n          } else {\n            resData = vec4<f32>(0.0); }` :\n        `var temp = vec4<f32>(0.0);\n          ${this.getSampleAWithRemainderWgsl(1)}\n          resData = temp;\n          if (WCol == (uniforms.filterDims[1] - 1u)) {\n            let coordZ = i32(coord.z + 1u - uniforms.filterDims[1]);\n            if (coordZ < 0) {\n              resData = vec4<f32>(0.0);\n            } else {\n              coord = vec4<u32>(\n                coord.x, coord.y + 1u, u32(coordZ), 0u);\n                ${this.getSampleAWithRemainderWgsl(2)}\n              if (inChCoord == 0u) {\n                resData = vec4<f32>(resData.xyz, temp.x);\n              } elseif (inChCoord == 1u) {\n                resData = vec4<f32>(resData.xy, temp.xy);\n              } else {\n                resData = vec4<f32>(resData.x, temp.xyz);\n              }\n            }\n          }\n          `;\n\n    const readASnippet = `let outRow = r / uniforms.outShape[2];\n        let outCol = r % uniforms.outShape[2];\n        let WRow = c / (uniforms.filterDims[1] * uniforms.xShape[3]);\n        let WCol = (c / uniforms.xShape[3]) % uniforms.filterDims[1];\n        let inChCoord = c % uniforms.xShape[3];\n        let coordRow = i32(outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0]);\n        if (coordRow < 0) {\n          return vec4<f32>(0.0);\n        }\n        let coordCol = i32(outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1]);\n        if (coordCol < 0) {\n          return vec4<f32>(0.0);\n        }\n        var coord = vec4<u32>(\n            batch,\n            u32(coordRow),\n            u32(coordCol),\n            inChCoord);\n        var resData = vec4<f32>(0.0);\n        ${remainderSnippet}\n        return resData;`;\n\n    const sampleA = this.fitA ?\n        `${readASnippet}` :\n        `if (r < uniforms.dimAOuter && c < uniforms.dimInner) {\n          ${readASnippet}\n         }\n         return vec4<f32>(0.0);\n        `;\n\n    const sampleB = this.fitB ?\n        `return W.numbers[row * uniforms.dimBOuter / 4u + col];` :\n        `if(coordsInBounds2D(vec2<u32>(row, col * 4u), vec2<u32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return W.numbers[row * uniforms.dimBOuter / 4u + col];\n         }\n         return vec4<f32>(0.0);\n        `;\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(\n          this.activation, this.isVec4, this.useWgsl);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet =\n            `fn activation(a : vec4<f32>, outCoord : vec4<u32>) -> vec4<f32> {\n          let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n          ${activationOp}\n        }`;\n      } else if (this.hasLeakyreluAlpha) {\n        activationSnippet = `fn activation(a: vec4<f32>) -> vec4<f32> {\n          let b = getLeakyreluAlphaAtOutCoords();\n          ${activationOp}\n        }`;\n        throw new Error('Leakyrelu is not supported.');\n      } else {\n        activationSnippet = `\n        fn activation(a : vec4<f32>, outCoord : vec4<u32>) -> vec4<f32> {\n          ${activationOp}\n        }`;\n      }\n\n      applyActivationSnippet = `value = activation(value, outCoord);`;\n    }\n\n    const addBiasSnippet = this.addBias ?\n        'value = value + getBiasAtOutCoordsByCoords(outCoord);' :\n        '';\n\n    const userCode = `\n        ${activationSnippet}\n        fn mm_readA(row : u32, col : u32, globalId : vec3<u32>) -> vec4<f32> {\n          let r = row;\n          let c = col * 4u;\n          var batch = globalId.z;\n          ${sampleA}\n        }\n\n        fn mm_readB(row : u32, col : u32, globalId : vec3<u32>) -> vec4<f32> {\n          ${sampleB}\n        }\n\n        fn mm_write(row : u32, col : u32, valueInput : vec4<f32>, globalId : vec3<u32>) {\n          var batch = globalId.z;\n          var value = valueInput;\n          if (row < uniforms.dimAOuter && col * 4u < uniforms.dimBOuter)\n          {\n            let outCoord = vec4<u32>(\n              batch,\n              row / uniforms.outShape[2],\n              row % uniforms.outShape[2],\n              col * 4u);\n            ${addBiasSnippet}\n            ${applyActivationSnippet}\n            setOutput(outCoord[0], outCoord[1], outCoord[2], outCoord[3],\n              value);\n          }\n        }\n        ${matMulSource}\n      `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {computeDispatch, computeWorkGroupSizeForConv2d, computeWorkPerThreadForConv2d, tilesFitEvenlyIntoShape} from '../webgpu_util';\nimport {mapActivationToShaderProgram} from './activation_util';\n\nimport {makeMatMulPackedSource, makeMatMulPackedSourceWgsl} from './matmul_packed_webgpu';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class Conv2DMMProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  uniforms = 'ivec2 filterDims, pad, stride, dilation;';\n  uniformsWgsl =\n      `filterDims : vec2<u32>; pad : vec2<u32>; stride : vec2<u32>; dilation : vec2<u32>; dimAOuter : u32; dimBOuter : u32; dimInner : u32;`;\n  workGroupSize: [number, number, number];\n  elementsPerThread: [number, number, number];\n  convInfo: backend_util.Conv2DInfo;\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  fitA: boolean;\n  fitB: boolean;\n  useWgsl: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: backend_util.Activation = null,\n      hasPreluActivationWeights = false) {\n    this.outputShape = convInfo.outShape;\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n    this.dispatchLayout = {x: [3], y: [1, 2], z: [0]};\n    this.workGroupSize =\n        computeWorkGroupSizeForConv2d(this.dispatchLayout, this.outputShape);\n    this.elementsPerThread =\n        computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        this.elementsPerThread);\n\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n    this.convInfo = convInfo;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n\n    [this.fitA, this.fitB] = this.getShapeFit();\n    this.shaderKey = `conv2DMM_${this.elementsPerThread}_${this.activation}_${\n        this.fitA}_${this.fitB}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getShapeFit(): boolean[] {\n    const tileAOuter = this.workGroupSize[1] * this.elementsPerThread[1];\n    const tileBOuter = this.workGroupSize[0] * this.elementsPerThread[0];\n    const tileInner = tileAOuter > tileBOuter ? tileAOuter : tileBOuter;\n    util.assert(\n        tileInner % this.workGroupSize[0] === 0 &&\n            tileInner % this.workGroupSize[1] === 0,\n        () =>\n            // tslint:disable-next-line: max-line-length\n        'tileInner must be multiple of workgroupsize.x and workgroupsize.y');\n    const tileSizeA = [tileAOuter, tileInner];\n    const tileSizeB = [tileInner, tileBOuter];\n    const dimAOuter = this.outputShape[1] * this.outputShape[2];\n    const dimBOuter = this.outputShape[3];\n    const dimInner = this.convInfo.filterHeight * this.convInfo.filterWidth *\n        this.convInfo.inChannels;\n\n    return [\n      tilesFitEvenlyIntoShape(tileSizeA, [dimAOuter, dimInner]),\n      tilesFitEvenlyIntoShape(tileSizeB, [dimInner, dimBOuter])\n    ];\n  }\n\n  getUserCode(): string {\n    const matMulSource = makeMatMulPackedSource(this.elementsPerThread);\n\n    const readASnippet = `\n    int outRow = row / outShape[2];\n    int outCol = row % outShape[2];\n\n    int WRow = col / (filterDims[1] * xShape[3]);\n    int WCol = (col / xShape[3]) % filterDims[1];\n\n    ivec4 coord = ivec4(\n        batch,\n        outRow * stride[0] + dilation[0] * WRow - pad[0],\n        outCol * stride[1] + dilation[1] * WCol - pad[1],\n        col % xShape[3]);\n    // The bounds checking is always needed since we use it to pad zero for the\n    // 'same' padding type.\n    return coordsInBounds(coord, xShape) ? x[getFlatIndex(coord, xShape)] : 0;`;\n\n    const sampleA = this.fitA ? `${readASnippet}` :\n                                `if (row < dimAOuter && col < dimInner) {\n      ${readASnippet}\n    } else {\n      return 0;\n    }`;\n\n    const sampleB = this.fitB ?\n        `W[row * dimBOuter + col]` :\n        `coordsInBounds(ivec2(row, col), ivec2(dimInner, dimBOuter)) ?\n        W[row * dimBOuter + col] : 0`;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(this.activation);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a, ivec4 outCoord) {\n                  float b = getPreluActivationWeightsAtOutCoords(outCoord);\n                  ${activationOp}\n                }`;\n      } else {\n        activationSnippet = `\n                  float activation(float a, ivec4 outCoord) {\n                    ${activationOp}\n                  }\n                `;\n      }\n\n      applyActivationSnippet = `value = activation(value, outCoord);`;\n    }\n\n    const addBiasSnippet =\n        this.addBias ? 'value += getBiasAtOutCoords(outCoord);' : '';\n\n    const userCode = `\n    ${activationSnippet}\n    ${matMulSource}\n\n    int batch;\n    int dimAOuter = outShape[1] * outShape[2];\n    int dimBOuter = outShape[3];\n    int dimInner = filterDims[0] * filterDims[1] * xShape[3];\n    float mm_readA(int row, int col) {\n      ${sampleA}\n    }\n\n    float mm_readB(int row, int col) {\n      return ${sampleB};\n    }\n\n    void mm_write(int row, int col, float value) {\n      ivec4 outCoord = ivec4(\n          batch,\n          row / outShape[2],\n          row % outShape[2],\n          col);\n      ${addBiasSnippet}\n      ${applyActivationSnippet}\n      result[getFlatIndex(outCoord, outShape)] = value;\n    }\n\n    void main() {\n      batch = int(gl_GlobalInvocationID.z);\n\n      mm_matMul(dimAOuter, dimInner, dimBOuter);\n    }\n  `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const matMulSource =\n        makeMatMulPackedSourceWgsl(this.elementsPerThread, this.workGroupSize);\n\n    const readASnippet = `\n    let outRow = row / uniforms.outShape[2];\n    let outCol = row % uniforms.outShape[2];\n\n    let WRow = col / (uniforms.filterDims[1] * uniforms.xShape[3]);\n    let WCol = (col / uniforms.xShape[3]) % uniforms.filterDims[1];\n    let coordRow = i32(outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0]);\n    if (coordRow < 0) {\n      return 0.0;\n    }\n    let coordCol = i32(outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1]);\n    if (coordCol < 0) {\n      return 0.0;\n    }\n    let coord = vec4<u32>(\n        batch,\n        u32(coordRow),\n        u32(coordCol),\n        col % uniforms.xShape[3]);\n    // The bounds checking is always needed since we use it to pad zero for the\n    // 'same' padding type.\n    if(coordsInBounds4D(coord, uniforms.xShape)) {\n      return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];\n    }\n    return 0.0;`;\n\n    const sampleA = this.fitA ?\n        `${readASnippet}` :\n        `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${readASnippet}\n    }\n    return 0.0;\n    `;\n\n    const sampleB = this.fitB ?\n        `return W.numbers[row * uniforms.dimBOuter + col];` :\n        `if(coordsInBounds2D(vec2<u32>(row, col), vec2<u32>(uniforms.dimInner, uniforms.dimBOuter))) {\n           return W.numbers[row * uniforms.dimBOuter + col];\n\t }\n\t return 0.0;\n\t `;\n\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp =\n          mapActivationToShaderProgram(this.activation, false, this.useWgsl);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet =\n            `fn activation(a: f32, outCoord : vec4<u32>) -> f32 {\n                  let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n                  ${activationOp}\n                }`;\n      } else {\n        activationSnippet = `\n                  fn activation(a : f32, outCoord : vec4<u32>) -> f32 {\n                    ${activationOp}\n                  }\n                `;\n      }\n\n      applyActivationSnippet = `value = activation(value, outCoord);`;\n    }\n\n    const addBiasSnippet = this.addBias ?\n        'value = value + getBiasAtOutCoordsByCoords(outCoord);' :\n        '';\n\n    const userCode = `\n    ${activationSnippet}\n    fn mm_readA(row : u32, col : u32, globalId : vec3<u32>) -> f32 {\n      var batch = globalId.z;\n      ${sampleA}\n    }\n\n    fn mm_readB(row : u32, col : u32, globalId : vec3<u32>) -> f32 {\n      ${sampleB}\n    }\n\n    fn mm_write(row : u32, col : u32, valueInput : f32, globalId : vec3<u32>) {\n      var batch = globalId.z;\n      var value = valueInput;\n      let outCoord = vec4<u32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      ${addBiasSnippet}\n      ${applyActivationSnippet}\n      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;\n    }\n    ${matMulSource}\n  `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {mapActivationToShaderProgram} from './activation_util';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class Conv2DNaiveProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  uniforms = 'ivec2 filterDims, pad, stride, dilation;';\n  uniformsWgsl =\n      `filterDims : vec2<u32>; pad : vec2<u32>; stride : vec2<u32>; dilation : vec2<u32>;`;\n  workGroupSize: [number, number, number] = [128, 1, 1];\n  convInfo: backend_util.Conv2DInfo;\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivationWeights: boolean;\n  useWgsl: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: backend_util.Activation = null,\n      hasPreluActivationWeights = false) {\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n\n    if (hasPreluActivationWeights) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.convInfo = convInfo;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivationWeights = hasPreluActivationWeights;\n\n    this.shaderKey = `conv2DNaive_${this.activation}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(this.activation);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet = `float activation(float a) {\n                  float b = getPreluActivationWeightsAtOutCoords();\n                  ${activationOp}\n                }`;\n      } else {\n        activationSnippet = `\n                  float activation(float a) {\n                    ${activationOp}\n                  }\n                `;\n      }\n\n      applyActivationSnippet = `value = activation(value);`;\n    }\n\n    const addBiasSnippet = this.addBias ? 'value += getBiasAtOutCoords();' : '';\n\n    const userCode = `\n      ${activationSnippet}\n      float readInp(int batch, int row, int col, int chan) {\n        ivec4 coord = ivec4(batch, row, col, chan);\n        return coordsInBounds(coord, xShape) ?\n          getX(batch, row, col, chan) : 0;\n      }\n\n      float readFilt(int row, int col, int xChannel, int outChannel) {\n        ivec4 coord = ivec4(row, col, xChannel, outChannel);\n        return coordsInBounds(coord, wShape) ?\n          getW(row, col, xChannel, outChannel) : 0;\n      }\n\n      void writeResult(int batch, int row, int col, int chan, float value) {\n        ivec4 coord = ivec4(batch, row, col, chan);\n        if (coordsInBounds(coord, outShape)) {\n          ${addBiasSnippet}\n          ${applyActivationSnippet}\n          setOutput(batch, row, col, chan, value);\n        }\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int outChannel = coords[3];\n\n        float acc = 0.0;\n\n        for (int row = 0; row < filterDims[0]; ++row) {\n          for (int col = 0; col < filterDims[1]; ++col) {\n            for (int xChannel = 0; xChannel < xShape[3]; ++xChannel) {\n              float v = readInp(batch,\n                  coords[1] * stride[0] + dilation[0] * row - pad[0],\n                  coords[2] * stride[1] + dilation[1] * col - pad[1],\n                  xChannel);\n              float f = readFilt(row, col, xChannel, outChannel);\n              acc += v * f;\n            }\n          }\n        }\n\n        writeResult(batch, coords[1], coords[2], outChannel, acc);\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(this.activation);\n      if (this.hasPreluActivationWeights) {\n        activationSnippet =\n            `fn activation(a : f32, outCoord : vec4<u32>) -> f32{\n               let b = getPreluActivationWeightsAtOutCoordsByCoords(outCoord);\n               ${activationOp}\n             }`;\n      } else {\n        activationSnippet = `\n                  fn activation(a : f32, outCoord : vec4<u32>) -> f32{\n                    ${activationOp}\n                  }\n                `;\n      }\n\n      applyActivationSnippet = `value = activation(value, outCoord);`;\n    }\n\n    const addBiasSnippet = this.addBias ?\n        'value = value + getBiasAtOutCoordsByCoords(outCoord);' :\n        '';\n\n    const userCode = `\n      ${activationSnippet}\n      fn readInp(batch : u32, row : u32, col : u32, chan : u32) -> f32 {\n        let coord = vec4<u32>(batch, row, col, chan);\n        if(coordsInBounds4D(coord, uniforms.xShape)) {\n          return getX(batch, row, col, chan);\n        }\n        return 0.0;\n      }\n\n      fn readFilt(row : u32, col : u32, xChannel : u32, outChannel : u32) -> f32{\n        let coord = vec4<u32>(row, col, xChannel, outChannel);\n        if(coordsInBounds4D(coord, uniforms.wShape)) {\n          return getW(row, col, xChannel, outChannel);\n        }\n        return 0.0;\n      }\n\n      fn writeResult(batch : u32, row : u32, col : u32, chan : u32, value : f32) {\n        let coord = vec4<u32>(batch, row, col, chan);\n        if (coordsInBounds4D(coord, uniforms.outShape)) {\n          ${addBiasSnippet}\n          ${applyActivationSnippet}\n          setOutput(batch, row, col, chan, value);\n        }\n      }\n\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coords = getOutputCoords(globalId, index);\n        let batch = coords[0];\n        let outChannel = coords[3];\n\n        var acc = 0.0;\n\n        for (var row = 0u; row < uniforms.filterDims[0]; row = row + 1u) {\n          for (var col = 0u; col < uniforms.filterDims[1]; col = col + 1u) {\n            for (var xChannel = 0u; xChannel < uniforms.xShape[3]; xChannel = xChannel + 1u) {\n              let coordRow = i32(coords[1] * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0]);\n              if (coordRow < 0) {\n                continue;\n              }\n              let coordCol = i32(coords[2] * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1]);\n              if (coordCol < 0) {\n                continue;\n              }\n              let v = readInp(batch, u32(coordRow), u32(coordCol), xChannel);\n              let f = readFilt(row, col, xChannel, outChannel);\n              acc = acc + v * f;\n            }\n          }\n        }\n\n        writeResult(batch, coords[1], coords[2], outChannel, acc);\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2D, Conv2DAttrs, Conv2DInputs, env, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {conv2dByMatMul, conv2dWithIm2Col} from './Conv2D_impl';\nimport {Conv2DMMVec4Program} from './conv2d_mm_vec4_webgpu';\nimport {Conv2DMMProgram} from './conv2d_mm_webgpu';\nimport {Conv2DNaiveProgram} from './conv2d_naive_webgpu';\n\nexport function conv2d(\n    args: {inputs: Conv2DInputs, attrs: Conv2DAttrs, backend: WebGPUBackend}) {\n  const {inputs, attrs, backend} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dataFormat, dilations, dimRoundingMode} = attrs;\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, dilations, pad,\n      dimRoundingMode, false /* depthwise */, $dataFormat);\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n      convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n      convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n      (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n    return conv2dByMatMul({x, filter, convInfo, backend});\n  }\n\n  if (env().getBool('WEBGPU_CONV_SEPARATE_IM2COL_SHADER') && x.shape[0] === 1) {\n    return conv2dWithIm2Col({x, filter, convInfo, backend});\n  }\n\n  let program: Conv2DMMProgram|Conv2DNaiveProgram|Conv2DMMVec4Program;\n\n  const padInfo = [convInfo.padInfo.top, convInfo.padInfo.left];\n  const dimensions = [\n    {type: 'int32', data: [convInfo.filterHeight, convInfo.filterWidth]},\n    {type: 'int32', data: [...padInfo]},\n    {type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]},\n    {type: 'int32', data: [convInfo.dilationHeight, convInfo.dilationWidth]}\n  ];\n  const useNaive = env().getBool('WEBGPU_USE_NAIVE_CONV2D');\n  if (useNaive) {\n    // TODO(kainino0x): This may be obsolete, but is kept for reference.\n    program = new Conv2DNaiveProgram(convInfo);\n  } else if (\n      // TODO(jiajia.qin@intel.com): It seems that the vec4 version is not\n      // good if convInfo.outChannels is too small. For example, input = [1,\n      // 128, 128, 4], filter = [25, 25, 4, 4]. In this case, lots of theads\n      // will run idle. So temporarily, use 64 as the threshold.\n      (convInfo.inChannels % 4 === 0 ||\n       (convInfo.inChannels === 3 && convInfo.padInfo.type === 'VALID')) &&\n      convInfo.outChannels % 4 === 0 && convInfo.outChannels >= 64) {\n    program = new Conv2DMMVec4Program(convInfo);\n  } else {\n    program = new Conv2DMMProgram(convInfo);\n  }\n  if (!useNaive && program.useWgsl) {\n    const dimAOuter = convInfo.outShape[1] * convInfo.outShape[2];\n    const dimBOuter = convInfo.outShape[3];\n    const dimInner =\n        convInfo.filterHeight * convInfo.filterWidth * convInfo.inShape[3];\n    dimensions.push(\n        {type: 'uint32', data: [dimAOuter]},\n        {type: 'uint32', data: [dimBOuter]},\n        {type: 'uint32', data: [dimInner]});\n  }\n\n  return backend.runWebGPUProgram(program, [x, filter], x.dtype, dimensions);\n}\n\nexport const conv2DConfig: KernelConfig = {\n  kernelName: Conv2D,\n  backendName: 'webgpu',\n  kernelFunc: conv2d as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {computeDispatch, computeWorkGroupSizeForConv2d, computeWorkPerThreadForConv2d} from '../webgpu_util';\n\nimport {makeMatMulPackedSource, makeMatMulPackedSourceWgsl} from './matmul_packed_webgpu';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class Conv2DDerInputMMProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  uniforms = 'ivec2 filterDims, pads, stride; ivec4 outBackprop;';\n  uniformsWgsl =\n      'filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>; dimAOuter : u32; dimBOuter : u32; dimInner : u32;';\n  workGroupSize: [number, number, number];\n  elementsPerThread: [number, number, number];\n  useWgsl: boolean;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n    this.dispatchLayout = {x: [3], y: [1, 2], z: [0]};\n    this.workGroupSize =\n        computeWorkGroupSizeForConv2d(this.dispatchLayout, this.outputShape);\n    this.elementsPerThread =\n        computeWorkPerThreadForConv2d(this.dispatchLayout, this.outputShape);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        this.elementsPerThread);\n\n    this.shaderKey = `conv2DDerInputMM_${this.elementsPerThread}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const matMulSource = makeMatMulPackedSource(this.elementsPerThread);\n\n    const readASnippet = `\n    int outRow = row / outShape[2];\n    int outCol = row % outShape[2];\n\n    int WRow = col / (filterDims[1] * outBackprop[3]);\n    int WCol = (col / outBackprop[3]) % filterDims[1];\n    float xR = float(outRow - pads[0] + WRow) / float(stride[0]);\n    float xC = float(outCol - pads[1] + WCol) / float(stride[1]);\n    if (xR < 0.0 || xR >= float(outBackprop[1]) || fract(xR) > 0.0) {\n      return 0;\n    }\n    if (xC < 0.0 || xC >= float(outBackprop[2]) || fract(xC) > 0.0) {\n      return 0;\n    }\n    ivec4 coord = ivec4(\n        batch,\n        int(xR),\n        int(xC),\n        col % outBackprop[3]);\n    return x[getFlatIndex(coord, xShape)];`;\n\n    const sampleA = `if (row < dimAOuter && col < dimInner) {\n      ${readASnippet}\n    } else {\n      return 0;\n    }`;\n\n    const userCode = `\n    ${matMulSource}\n\n    int batch;\n    int dimAOuter = outShape[1] * outShape[2];\n    int dimBOuter = outShape[3];\n    int dimInner = filterDims[0] * filterDims[1] * outBackprop[3];\n\n    float mm_readA(int row, int col) {\n      ${sampleA}\n    }\n\n    float mm_readB(int row, int col) {\n      if (row < dimInner && col < dimBOuter)\n      {\n        int WRow = row / (filterDims[1] * outBackprop[3]);\n        int WCol = (row / outBackprop[3]) % filterDims[1];\n        ivec4 coord = ivec4(\n            filterDims.x - 1 - WRow,\n            filterDims.y - 1 - WCol,\n            col,\n            row % outBackprop[3]);\n        return W[getFlatIndex(coord, wShape)];\n      } else\n      {\n        return 0;\n      }\n    }\n\n    void mm_write(int row, int col, float value) {\n      ivec4 outCoord = ivec4(\n          batch,\n          row / outShape[2],\n          row % outShape[2],\n          col);\n      result[getFlatIndex(outCoord, outShape)] = value;\n    }\n\n    void main() {\n      batch = int(gl_GlobalInvocationID.z);\n\n      mm_matMul(dimAOuter, dimInner, dimBOuter);\n    }\n  `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const matMulSource =\n        makeMatMulPackedSourceWgsl(this.elementsPerThread, this.workGroupSize);\n\n    const readASnippet = `\n    let outRow = row / uniforms.outShape[2];\n    let outCol = row % uniforms.outShape[2];\n\n    let WRow = i32(col) / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let WCol = i32(col) / uniforms.outBackprop[3] % uniforms.filterDims[1];\n    let xR = (f32(outRow) - f32(uniforms.pads[0]) + f32(WRow)) / f32(uniforms.stride[0]);\n    let xC = (f32(outCol) - f32(uniforms.pads[1]) + f32(WCol)) / f32(uniforms.stride[1]);\n    if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n      return 0.0;\n    }\n    if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n      return 0.0;\n    }\n    let coord = vec4<u32>(\n        batch,\n        u32(xR),\n        u32(xC),\n        col % u32(uniforms.outBackprop[3]));\n    return x.numbers[getFlatIndex4D(coord, uniforms.xShape)];`;\n\n    const sampleA = `if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n      ${readASnippet}\n    }\n    return 0.0;`;\n\n    const userCode = `\n    fn mm_readA(row : u32, col : u32, globalId : vec3<u32>) -> f32 {\n      var batch = globalId.z;\n      ${sampleA}\n    }\n\n    fn mm_readB(row : u32, col : u32, globalId : vec3<u32>) -> f32 {\n      let coordX = uniforms.filterDims.x - 1 -\n          i32(row) / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let coordY = uniforms.filterDims.y - 1 -\n          (i32(row) / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n          coordX >= 0 && coordY >= 0) {\n        let coord = vec4<u32>(u32(coordX), u32(coordY), col,\n            row % u32(uniforms.outBackprop[3]));\n        return W.numbers[getFlatIndex4D(coord, uniforms.wShape)];\n      }\n      return 0.0;\n    }\n\n    fn mm_write(row : u32, col : u32, valueInput : f32, globalId : vec3<u32>) {\n      var batch = globalId.z;\n      var value = valueInput;\n      let outCoord = vec4<u32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result.numbers[getFlatIndex4D(outCoord, uniforms.outShape)] = value;\n    }\n\n    ${matMulSource}\n  `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class Conv2DDerInputProgram implements WebGPUProgram {\n  variableNames = ['dy', 'W'];\n  uniforms = 'ivec2 filterDims, pads, stride; ivec4 outBackprop;';\n  uniformsWgsl =\n      'filterDims : vec2<i32>; pads : vec2<i32>; stride : vec2<i32>; outBackprop : vec4<i32>;';\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  isChannelsLast: boolean;\n  useWgsl: boolean;\n\n  constructor(convInfo: backend_util.Conv2DInfo) {\n    this.outputShape = convInfo.inShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n    this.isChannelsLast = convInfo.dataFormat === 'channelsLast';\n    this.shaderKey = `conv2DDerInput_${this.isChannelsLast}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const rowDim = this.isChannelsLast ? 1 : 2;\n    const colDim = this.isChannelsLast ? 2 : 3;\n    const channelDim = this.isChannelsLast ? 3 : 1;\n    return `\n    void main() {\n      ivec4 coords = getOutputCoords();\n      if (coordsInBounds(coords, outShape)) {\n        int batch = coords[0];\n        int d1 = coords[${channelDim}];\n\n        ivec2 dyCorner = ivec2(coords[${rowDim}], coords[${colDim}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < filterDims.x; wR++) {\n          float dyR = float(dyRCorner + wR) / float(stride.x);\n\n          if (dyR < 0.0 || dyR >= float(outBackprop[1]) || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = filterDims.x - 1 - wR;\n\n          for (int wC = 0; wC < filterDims.y; wC++) {\n            float dyC = float(dyCCorner + wC) / float(stride.y);\n\n            if (dyC < 0.0 || dyC >= float(outBackprop[2]) ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = filterDims.y - 1 - wC;\n\n            for (int d2 = 0; d2 < outBackprop[3]; d2++) {\n\n              if (${this.isChannelsLast}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(coords[0], coords[1], coords[2], coords[3], dotProd);\n      }\n    }\n  `;\n  }\n\n  getUserCodeWgsl(): string {\n    const rowDim = this.isChannelsLast ? 1 : 2;\n    const colDim = this.isChannelsLast ? 2 : 3;\n    const channelDim = this.isChannelsLast ? 3 : 1;\n    return `\n    ${getMainHeaderStringWgsl()} {\n      ${getGlobalIndexStringWgsl()}\n      let coords = getOutputCoords(globalId, index);\n      if (coordsInBounds4D(coords, uniforms.outShape)) {\n        let batch = coords[0];\n        let d1 = coords[${channelDim}];\n\n        let dyCorner = vec2<i32>(i32(coords[${rowDim}]), i32(coords[${\n        colDim}])) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0u; wR < uniforms.filterDims.x; wR = wR + 1u) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - i32(wR);\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = u32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = u32(dyC);\n\n            for (var d2 = 0u; d2 < u32(uniforms.outBackprop[3]); d2 = d2 + 1u) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(u32(wRPerm), u32(wCPerm), d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(u32(wRPerm), u32(wCPerm), d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(coords[0], coords[1], coords[2], coords[3], dotProd);\n      }\n    }\n  `;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Conv2DBackpropInput, Conv2DBackpropInputAttrs, Conv2DBackpropInputInputs, env, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {Conv2DDerInputMMProgram} from './conv_backprop_mm_webgpu';\nimport {Conv2DDerInputProgram} from './conv_backprop_webgpu';\n\nexport function conv2DBackpropInput(args: {\n  inputs: Conv2DBackpropInputInputs,\n  attrs: Conv2DBackpropInputAttrs,\n  backend: WebGPUBackend\n}) {\n  const {inputs, backend, attrs} = args;\n  const {dy, filter} = inputs;\n  const {inputShape, strides, pad, dataFormat, dimRoundingMode} = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      inputShape, filter.shape as [number, number, number, number], strides,\n      1 /* dilations */, pad, dimRoundingMode, false, $dataFormat);\n\n  const dimensions = [\n    {type: 'int32', data: [convInfo.filterHeight, convInfo.filterWidth]},\n    {\n      type: 'int32',\n      data: [\n        convInfo.filterHeight - 1 - convInfo.padInfo.top,\n        convInfo.filterWidth - 1 - convInfo.padInfo.left\n      ]\n    },\n    {type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]},\n    {\n      type: 'int32',\n      data: [\n        convInfo.batchSize, convInfo.outHeight, convInfo.outWidth,\n        convInfo.outChannels\n      ]\n    },\n  ];\n  let program: Conv2DDerInputProgram|Conv2DDerInputMMProgram;\n  if (env().getBool('WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE')) {\n    // Keep Conv2DDerInputProgram for reference.\n    program = new Conv2DDerInputProgram(convInfo);\n  } else {\n    program = new Conv2DDerInputMMProgram(convInfo);\n    if (program.useWgsl) {\n      const dimAOuter = convInfo.inShape[1] * convInfo.inShape[2];\n      const dimBOuter = convInfo.inShape[3];\n      const dimInner =\n          convInfo.filterHeight * convInfo.filterWidth * convInfo.outChannels;\n      dimensions.push(\n          {type: 'uint32', data: [dimAOuter]},\n          {type: 'uint32', data: [dimBOuter]},\n          {type: 'uint32', data: [dimInner]});\n    }\n  }\n  return backend.runWebGPUProgram(program, [dy, filter], 'float32', dimensions);\n}\n\nexport const conv2DBackpropInputConfig: KernelConfig = {\n  kernelName: Conv2DBackpropInput,\n  backendName: 'webgpu',\n  kernelFunc: conv2DBackpropInput as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class CropAndResizeProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['Image', 'Boxes', 'BoxInd'];\n  uniforms = 'float extrapolationValue;';\n  uniformsWgsl = 'extrapolationValue : f32;';\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  methodId: number;\n  cropHeightBiggerThan1: boolean;\n  cropWidthBiggerThan1: boolean;\n  useWgsl: boolean;\n\n  constructor(\n      channnel: number, boxShape: [number, number], cropSize: [number, number],\n      method: 'bilinear'|'nearest') {\n    const [numBoxes, ] = boxShape;\n    this.outputShape = [numBoxes, cropSize[0], cropSize[1], channnel];\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.methodId = method === 'bilinear' ? 1 : 0;\n    this.cropHeightBiggerThan1 = this.outputShape[1] > 1;\n    this.cropWidthBiggerThan1 = this.outputShape[2] > 1;\n    this.shaderKey = `cropAndResize_${this.methodId}_${\n        this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const [inputHeightFloat, inputWidthFloat] =\n        [`float(imageShape[1] - 1)`, `float(imageShape[2] - 1)`];\n\n    const [heightRatio, heightScale, inY] = this.cropHeightBiggerThan1 ?\n        [\n          `(${inputHeightFloat} / float(outShape[1] - 1))`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + float(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = this.cropWidthBiggerThan1 ?\n        [\n          `(${inputWidthFloat} / float(outShape[2] - 1))`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + float(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    const userCode = `\n      void writeResult(ivec4 coords,float value) {\n        if (coordsInBounds(coords, outShape)) {\n          setOutput(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n      void main() {\n        const float height_ratio = float(${heightRatio});\n        const float width_ratio = float(${widthRatio});\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n        // get image in batch index\n        int bInd = int(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= outShape[0]) {\n          return;\n        }\n        float height_scale = ${heightScale};\n        float width_scale = ${widthScale};\n        float in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          writeResult(coords,extrapolationValue);\n          return;\n        }\n        float in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          writeResult(coords,extrapolationValue);\n          return;\n        }\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n          float topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          writeResult(coords,newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          writeResult(coords,newValue);\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const [inputHeightFloat, inputWidthFloat] = [\n      `f32(uniforms.imageShape[1] - 1u)`, `f32(uniforms.imageShape[2] - 1u)`\n    ];\n\n    const [heightRatio, heightScale, inY] = this.cropHeightBiggerThan1 ?\n        [\n          `(${inputHeightFloat} / f32(uniforms.outShape[1] - 1u))`,\n          '(y2-y1) * height_ratio',\n          `y1*${inputHeightFloat} + f32(y)*(height_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (y1+y2) * ${inputHeightFloat}`,\n        ];\n    const [widthRatio, widthScale, inX] = this.cropWidthBiggerThan1 ?\n        [\n          `(${inputWidthFloat} / f32(uniforms.outShape[2] - 1u))`,\n          '(x2-x1) * width_ratio',\n          `x1*${inputWidthFloat} + f32(x)*(width_scale)`,\n        ] :\n        [\n          '0.0',\n          '0.0',\n          `0.5 * (x1+x2) * ${inputWidthFloat}`,\n        ];\n\n    // Reference implementation\n    // tslint:disable-next-line:max-line-length\n    // https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/kernels/crop_and_resize_op_gpu.cu.cc\n    const userCode = `\n      fn writeResult(coords : vec4<u32>, value : f32) {\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutput(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let height_ratio = f32(${heightRatio});\n        let width_ratio = f32(${widthRatio});\n        let coords = getOutputCoords(globalId, index);\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0u);\n        let x1 = getBoxes(b, 1u);\n        let y2 = getBoxes(b, 2u);\n        let x2 = getBoxes(b, 3u);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= i32(uniforms.outShape[0])) {\n          return;\n        }\n        let height_scale = ${heightScale};\n        let width_scale = ${widthScale};\n        let in_y = ${inY};\n        if( in_y < 0.0 || in_y > ${inputHeightFloat} ) {\n          writeResult(coords, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${inX};\n        if( in_x < 0.0 || in_x > ${inputWidthFloat} ) {\n          writeResult(coords, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(u32(bInd), u32(sourceFloorCR.y), u32(sourceFloorCR.x), d);\n          let bottomLeft = getImage(u32(bInd), u32(sourceCeilCR.y), u32(sourceFloorCR.x), d);\n          let topRight = getImage(u32(bInd), u32(sourceFloorCR.y), u32(sourceCeilCR.x), d);\n          let bottomRight = getImage(u32(bInd), u32(sourceCeilCR.y), u32(sourceCeilCR.x), d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          writeResult(coords, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            u32(bInd), u32(sourceNearestCR.y), u32(sourceNearestCR.x), d);\n          writeResult(coords,newValue);\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {CropAndResize, CropAndResizeAttrs, CropAndResizeInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {CropAndResizeProgram} from './crop_and_resize_webgpu';\n\nexport const cropAndResize = (args: {\n  inputs: CropAndResizeInputs,\n  backend: WebGPUBackend,\n  attrs: CropAndResizeAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {image, boxes, boxInd} = inputs;\n  const {cropSize, method, extrapolationValue} = attrs;\n\n  const program = new CropAndResizeProgram(\n      image.shape[3], boxes.shape as [number, number], cropSize, method);\n  const uniformData = [{type: 'float32', data: [extrapolationValue]}];\n  return backend.runWebGPUProgram(\n      program, [image, boxes, boxInd], 'float32', uniformData);\n};\n\nexport const cropAndResizeConfig: KernelConfig = {\n  kernelName: CropAndResize,\n  backendName: 'webgpu',\n  kernelFunc: cropAndResize as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch} from '../webgpu_util';\n\nimport {mapActivationToShaderProgram} from './activation_util';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class DepthwiseConv2D3x3Program implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[], z: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  uniforms = 'ivec2 pad, stride, dilation, inDims;';\n  uniformsWgsl =\n      'pad : vec2<u32>; stride : vec2<u32>; dilation : vec2<u32>; inDims : vec2<u32>;';\n  workGroupSize: [number, number, number] = [4, 4, 4];\n  convInfo: backend_util.Conv2DInfo;\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivation: boolean;\n  isVec4 = true;\n  useWgsl: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: backend_util.Activation = null, hasPreluActivation = false) {\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = {x: [0, 1], y: [2], z: [3]};\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize, [1, 4, 4]);\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.convInfo = convInfo;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivation = hasPreluActivation;\n\n    this.shaderKey = `depthwise3x3_${activation}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp =\n          mapActivationToShaderProgram(this.activation, this.isVec4);\n      if (this.hasPreluActivation) {\n        activationSnippet = `vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords(coords);\n          ${activationOp}\n        }`;\n      } else {\n        activationSnippet = `\n        vec4 activation(vec4 a) {\n            ${activationOp}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `dotProd[i] = activation(dotProd[i]);`;\n    }\n\n    const addBiasSnippet =\n        this.addBias ? 'dotProd[i] += getBiasAtOutCoords(coords);' : '';\n\n    const userCode = `\n      ${activationSnippet}\n\n      void main() {\n        int batch = 0;\n        int r = int(gl_GlobalInvocationID.x);\n        int c = int(gl_GlobalInvocationID.y) * 4;\n        int d2= int(gl_GlobalInvocationID.z) * 4;\n        ivec2 xRCCorner = ivec2(r, c) * stride - pad;\n        int d1 = d2;\n        int q = 0;\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        vec4 wVals[9];\n        wVals[0] = getW(0, 0, d1, q);\n        wVals[1] = getW(0, 1, d1, q);\n        wVals[2] = getW(0, 2, d1, q);\n        wVals[3] = getW(1, 0, d1, q);\n        wVals[4] = getW(1, 1, d1, q);\n        wVals[5] = getW(1, 2, d1, q);\n        wVals[6] = getW(2, 0, d1, q);\n        wVals[7] = getW(2, 1, d1, q);\n        wVals[8] = getW(2, 2, d1, q);\n\n        vec4 xVals[3][6];\n        for (int wR = 0; wR < 3; wR++) {\n          int xR = xRCorner + wR * dilation[0];\n          for (int wC = 0; wC < 6; wC++) {\n            int xC = xCCorner + wC * dilation[1];\n            if (xR < 0 || xR >= inDims[0] || xC < 0 || xC >= inDims[1]) {\n              xVals[wR][wC] = vec4(0.0, 0.0, 0.0, 0.0);\n            } else {\n              xVals[wR][wC] = getX(batch, xR, xC, d1);\n            }\n          }\n        }\n\n        vec4 dotProd[4];\n        dotProd[0] = vec4(0.0, 0.0, 0.0, 0.0);\n        dotProd[1] = vec4(0.0, 0.0, 0.0, 0.0);\n        dotProd[2] = vec4(0.0, 0.0, 0.0, 0.0);\n        dotProd[3] = vec4(0.0, 0.0, 0.0, 0.0);\n\n        for (int wR = 0; wR < 3; wR++) {\n          for (int wC = 0; wC < 3; wC++) {\n            int indexW = wR * 3 + wC;\n            dotProd[0] += xVals[wR][0 + wC] * wVals[indexW];\n            dotProd[1] += xVals[wR][1 + wC] * wVals[indexW];\n            dotProd[2] += xVals[wR][2 + wC] * wVals[indexW];\n            dotProd[3] += xVals[wR][3 + wC] * wVals[indexW];\n          }\n        }\n\n        for (int i = 0; i < 4; i++)\n        {\n          ivec4 coords = ivec4(batch, r, c + i, d2);\n          if (coordsInBounds(coords, outShape)) {\n            ${addBiasSnippet}\n            ${applyActivationSnippet}\n            setOutput(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(\n          this.activation, this.isVec4, this.useWgsl);\n      if (this.hasPreluActivation) {\n        activationSnippet =\n            `fn activation(a : vec4<f32>, globalId : vec3<u32>, globalIndex : u32) -> vec4<f32> {\n          let b = getPreluActivationWeightsAtOutCoordsByGlobalId(globalId, globalIndex);\n          ${activationOp}\n        }`;\n      } else {\n        activationSnippet = `\n        fn activation(a : vec4<f32>, globalId : vec3<u32>, globalIndex : u32) -> vec4<f32> {\n            ${activationOp}\n          }\n        `;\n      }\n\n      applyActivationSnippet =\n          `dotProd[i] = activation(dotProd[i], globalId, index);`;\n    }\n\n    const addBiasSnippet = this.addBias ?\n        'dotProd[i] = dotProd[i] + getBiasAtOutCoordsByCoords(coords);' :\n        '';\n\n    const userCode = `\n      ${activationSnippet}\n\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let batch = 0u;\n        let r = globalId.x;\n        let c = globalId.y * 4u;\n        let d2 = globalId.z * 4u;\n        let xRCCorner = vec2<i32>(vec2<u32>(r, c) * uniforms.stride - uniforms.pad);\n        let d1 = d2;\n        let q = 0u;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n\n        var wVals : array<vec4<f32>, 9>;\n        wVals[0] = getW(0u, 0u, d1, q);\n        wVals[1] = getW(0u, 1u, d1, q);\n        wVals[2] = getW(0u, 2u, d1, q);\n        wVals[3] = getW(1u, 0u, d1, q);\n        wVals[4] = getW(1u, 1u, d1, q);\n        wVals[5] = getW(1u, 2u, d1, q);\n        wVals[6] = getW(2u, 0u, d1, q);\n        wVals[7] = getW(2u, 1u, d1, q);\n        wVals[8] = getW(2u, 2u, d1, q);\n\n        var xVals : array<array<vec4<f32>, 6>, 3>;\n        for (var wR = 0u; wR < 3u; wR = wR + 1u) {\n          let xR = xRCorner + i32(wR * uniforms.dilation[0]);\n          for (var wC = 0u; wC < 6u; wC = wC + 1u) {\n            let xC = xCCorner + i32(wC * uniforms.dilation[1]);\n            if (xR < 0 || xR >= i32(uniforms.inDims[0]) || xC < 0 || xC >= i32(uniforms.inDims[1])) {\n              xVals[wR][wC] = vec4<f32>(0.0);\n            } else {\n              xVals[wR][wC] = getX(batch, u32(xR), u32(xC), d1);\n            }\n          }\n        }\n\n        var dotProd : array<vec4<f32>, 4>;\n        dotProd[0] = vec4<f32>(0.0);\n        dotProd[1] = vec4<f32>(0.0);\n        dotProd[2] = vec4<f32>(0.0);\n        dotProd[3] = vec4<f32>(0.0);\n\n        for (var wR = 0u; wR < 3u; wR = wR + 1u) {\n          for (var wC = 0u; wC < 3u; wC = wC + 1u) {\n            let indexW = wR * 3u + wC;\n            dotProd[0] = dotProd[0] + xVals[wR][0u + wC] * wVals[indexW];\n            dotProd[1] = dotProd[1] + xVals[wR][1u + wC] * wVals[indexW];\n            dotProd[2] = dotProd[2] + xVals[wR][2u + wC] * wVals[indexW];\n            dotProd[3] = dotProd[3] + xVals[wR][3u + wC] * wVals[indexW];\n          }\n        }\n\n        for (var i = 0u; i < 4u; i = i + 1u) {\n          let coords = vec4<u32>(batch, r, c + i, d2);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            ${addBiasSnippet}\n            ${applyActivationSnippet}\n            setOutput(coords[0], coords[1], coords[2], coords[3], dotProd[i]);\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {mapActivationToShaderProgram} from './activation_util';\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class DepthwiseConv2DProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y?: number[], z?: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x', 'W'];\n  uniforms = 'ivec2 pad, stride, dilation, inDims;';\n  uniformsWgsl =\n      `pad : vec2<u32>; stride : vec2<u32>; dilation : vec2<u32>; inDims : vec2<u32>;`;\n  // This is an experimental value.\n  workGroupSize: [number, number, number] = [256, 1, 1];\n  convInfo: backend_util.Conv2DInfo;\n  addBias: boolean;\n  activation: backend_util.Activation;\n  hasPreluActivation: boolean;\n  useWgsl: boolean;\n\n  constructor(\n      convInfo: backend_util.Conv2DInfo, addBias = false,\n      activation: backend_util.Activation = null, hasPreluActivation = false) {\n    this.outputShape = convInfo.outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    util.assert(\n        convInfo.dataFormat === 'channelsLast',\n        () => 'TODO: NCHW is unimplemented');\n\n    if (addBias) {\n      this.variableNames.push('bias');\n    }\n    if (hasPreluActivation) {\n      this.variableNames.push('preluActivationWeights');\n    }\n\n    this.convInfo = convInfo;\n    this.addBias = addBias;\n    this.activation = activation;\n    this.hasPreluActivation = hasPreluActivation;\n    this.useWgsl = getUseWgsl();\n\n    this.shaderKey = `depthwise_${this.convInfo.filterHeight}_${\n        this.convInfo.filterWidth}_${this.activation}_${\n        this.convInfo.outChannels / this.convInfo.inChannels}`;\n  }\n\n  getUserCode(): string {\n    const channelMul = this.convInfo.outChannels / this.convInfo.inChannels;\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp = mapActivationToShaderProgram(this.activation);\n      if (this.hasPreluActivation) {\n        activationSnippet = `float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${activationOp}\n        }`;\n      } else {\n        activationSnippet = `\n          float activation(float a) {\n            ${activationOp}\n          }\n        `;\n      }\n\n      applyActivationSnippet = `dotProd = activation(dotProd);`;\n    }\n\n    const addBiasSnippet =\n        this.addBias ? 'dotProd += getBiasAtOutCoords();' : '';\n\n    const userCode = `\n      ${activationSnippet}\n\n      void writeResult(int batch, int row, int col, int chan, float value) {\n        ivec4 coord = ivec4(batch, row, col, chan);\n        if (coordsInBounds(coord, outShape)) {\n          setOutput(batch, row, col, chan, value);\n        }\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        ivec2 xRCCorner = coords.yz * stride - pad;\n        int d2 = coords[3];\n        int d1 = d2 / ${channelMul};\n        int q = d2 - d1 * ${channelMul};\n\n        int inputRowStart = xRCCorner.x;\n        int inputColStart = xRCCorner.y;\n        int inputRowEnd = inputRowStart + ${\n        this.convInfo.filterHeight} * dilation[0];\n        int inputColEnd = inputColStart + ${\n        this.convInfo.filterWidth} * dilation[1];\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < inDims[0] && inputColEnd < inDims[1])\n          {\n            // Here using a constant value |this.convInfo.filterHeight| instead\n            // of uniform value is in order to loop unrolling.\n            for (int wR = 0; wR < ${this.convInfo.filterHeight}; wR++) {\n              int xR = inputRowStart + wR * dilation[0];\n\n              for (int wC = 0; wC < ${this.convInfo.filterWidth}; wC++) {\n                int xC = inputColStart + wC * dilation[1];\n\n                float xVal = getX(batch, xR, xC, d1);\n                float wVal = getW(wR, wC, d1, q);\n                dotProd += xVal * wVal;\n              }\n            }\n          } else {\n            for (int wR = 0; wR < ${this.convInfo.filterHeight}; wR++) {\n              int xR = inputRowStart + wR * dilation[0];\n\n              if (xR < 0 || xR >= inDims[0]) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${this.convInfo.filterWidth}; wC++) {\n                int xC = inputColStart + wC * dilation[1];\n\n                if (xC < 0 || xC >= inDims[1]) {\n                  continue;\n                }\n\n                float xVal = getX(batch, xR, xC, d1);\n                float wVal = getW(wR, wC, d1, q);\n                dotProd += xVal * wVal;\n              }\n            }\n          }\n\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        writeResult(batch, coords[1], coords[2], d2, dotProd);\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const channelMul = this.convInfo.outChannels / this.convInfo.inChannels;\n    let activationSnippet = '', applyActivationSnippet = '';\n    if (this.activation) {\n      const activationOp =\n          mapActivationToShaderProgram(this.activation, false, this.useWgsl);\n      if (this.hasPreluActivation) {\n        activationSnippet =\n            `fn activation(a : f32, globalId : vec3<u32>, index : u32) -> f32 {\n          let b = getPreluActivationWeightsAtOutCoordsByGlobalId(globalId, index);\n          ${activationOp}\n        }`;\n      } else {\n        activationSnippet = `\n          fn activation(a : f32, globalId : vec3<u32>, index : u32) -> f32 {\n            ${activationOp}\n          }\n        `;\n      }\n\n      applyActivationSnippet =\n          `dotProd = activation(dotProd, globalId, index);`;\n    }\n\n    const addBiasSnippet = this.addBias ?\n        'dotProd = dotProd + getBiasAtOutCoordsByGlobalId(globalId, index);' :\n        '';\n\n    const userCode = `\n      ${activationSnippet}\n\n      fn writeResult(batch : u32, row : u32, col : u32, chan : u32, value : f32) {\n        let coord = vec4<u32>(batch, row, col, chan);\n        if (coordsInBounds4D(coord, uniforms.outShape)) {\n          setOutput(batch, row, col, chan, value);\n        }\n      }\n\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coords = getOutputCoords(globalId, index);\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.yz * uniforms.stride - uniforms.pad);\n        let d2 = coords[3];\n        let d1 = d2 / ${channelMul}u;\n        let q = d2 - d1 * ${channelMul}u;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n        let inputRowEnd = inputRowStart + i32(${\n        this.convInfo.filterHeight}u * uniforms.dilation[0]);\n        let inputColEnd = inputColStart + i32(${\n        this.convInfo.filterWidth}u * uniforms.dilation[1]);\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n\n        // Extract if checking out of for loop for performance.\n        if (inputRowStart >= 0 && inputColStart >= 0 &&\n          inputRowEnd < i32(uniforms.inDims[0]) && inputColEnd < i32(uniforms.inDims[1])) {\n            // Here using a constant value |this.convInfo.filterHeight| instead\n            // of uniform value is in order to loop unrolling.\n            for (var wR = 0u; wR < ${\n        this.convInfo.filterHeight}u; wR = wR + 1u) {\n              let xR = inputRowStart + i32(wR * uniforms.dilation[0]);\n\n              for (var wC = 0u; wC < ${\n        this.convInfo.filterWidth}u; wC = wC + 1u) {\n                let xC = inputColStart + i32(wC * uniforms.dilation[1]);\n\n                let xVal = getX(batch, u32(xR), u32(xC), d1);\n                let wVal = getW(wR, u32(wC), d1, q);\n                dotProd = dotProd + xVal * wVal;\n              }\n            }\n          } else {\n            for (var wR = 0u; wR < ${\n        this.convInfo.filterHeight}u; wR = wR + 1u) {\n              let xR = inputRowStart + i32(wR * uniforms.dilation[0]);\n\n              if (xR < 0 || xR >= i32(uniforms.inDims[0])) {\n                continue;\n              }\n\n              for (var wC = 0u; wC < ${\n        this.convInfo.filterWidth}u; wC = wC + 1u) {\n                let xC = inputColStart + i32(wC * uniforms.dilation[1]);\n\n                if (xC < 0 || xC >= i32(uniforms.inDims[1])) {\n                  continue;\n                }\n\n                let xVal = getX(batch, u32(xR), u32(xC), d1);\n                let wVal = getW(wR, wC, d1, q);\n                dotProd = dotProd + xVal * wVal;\n              }\n            }\n          }\n\n        ${addBiasSnippet}\n        ${applyActivationSnippet}\n        writeResult(batch, coords[1], coords[2], d2, dotProd);\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DepthwiseConv2dNative, DepthwiseConv2dNativeAttrs, DepthwiseConv2dNativeInputs, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {DepthwiseConv2D3x3Program} from './depthwise_conv2d_3x3_webgpu';\nimport {DepthwiseConv2DProgram} from './depthwise_conv2d_webgpu';\n\nexport function depthwiseConv2dNative(args: {\n  inputs: DepthwiseConv2dNativeInputs,\n  attrs: DepthwiseConv2dNativeAttrs,\n  backend: WebGPUBackend\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter} = inputs;\n  const {strides, pad, dilations, dimRoundingMode} = attrs;\n\n  let $dilations = dilations;\n  if ($dilations == null) {\n    $dilations = [1, 1];\n  }\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, $dilations,\n      pad, dimRoundingMode, true /* depthwise */);\n\n  let program: DepthwiseConv2DProgram|DepthwiseConv2D3x3Program;\n  // TODO: To see if we need to relax the limitation. Currently, it's only for\n  // filter size 3x3.\n  if (convInfo.batchSize === 1 && convInfo.inHeight === convInfo.outHeight &&\n      convInfo.inWidth === convInfo.outWidth && convInfo.strideHeight === 1 &&\n      convInfo.strideWidth === 1 &&\n      convInfo.filterHeight === convInfo.filterWidth &&\n      convInfo.inChannels === convInfo.outChannels &&\n      convInfo.filterHeight === 3 && convInfo.inChannels % 4 === 0) {\n    program = new DepthwiseConv2D3x3Program(convInfo);\n  } else {\n    program = new DepthwiseConv2DProgram(convInfo);\n  }\n\n  const dimensions = [\n    {type: 'int32', data: [convInfo.padInfo.top, convInfo.padInfo.left]},\n    {type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]},\n    {type: 'int32', data: [convInfo.dilationHeight, convInfo.dilationWidth]},\n    {type: 'int32', data: [convInfo.inHeight, convInfo.inWidth]}\n  ];\n\n  return backend.runWebGPUProgram(program, [x, filter], x.dtype, dimensions);\n}\n\nexport const depthwiseConv2dNativeConfig: KernelConfig = {\n  kernelName: DepthwiseConv2dNative,\n  backendName: 'webgpu',\n  kernelFunc: depthwiseConv2dNative as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Multiply} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {multiplyImplCPU as cpuMultiply} from '../kernel_utils/shared';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const multiplyKernelFunc = binaryKernelFunc({\n  opSnippet: BinaryOpType.MUL,\n  cpuKernelImpl: cpuMultiply,\n  supportsComplex: true\n});\n\nexport const multiplyConfig: KernelConfig = {\n  kernelName: Multiply,\n  backendName: 'webgpu',\n  kernelFunc: multiplyKernelFunc\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType} from '@tensorflow/tfjs-core';\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class ReduceProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'int reduceSize;';\n  uniformsWgsl = 'reduceSize : u32;';\n  reduceType: 'max'|'mean'|'min'|'prod'|'sum';\n  inputShape: number[];\n  reductionFactor: number;\n  useWgsl: boolean;\n\n  constructor(\n      reduceInfo: backend_util.ReduceInfo,\n      reduceType: 'max'|'mean'|'min'|'prod'|'sum', outputDtype: DataType) {\n    this.inputShape = [reduceInfo.batchSize, reduceInfo.inSize];\n    const [outputShape, ] =\n        backend_util.computeOutAndReduceShapes(this.inputShape, [1]);\n    this.outputShape = outputShape.length === 0 ? [1] : outputShape;\n\n    this.reductionFactor = 2;\n    // Note that the maximum of workgroup X dimension is 256.\n    const xMaxThreads = 256;\n    const xThreads = Math.min(\n        Math.ceil(reduceInfo.inSize / this.reductionFactor), xMaxThreads);\n\n    this.workGroupSize = [xThreads, 1, 1];\n    this.dispatchLayout = {x: [], y: this.outputShape.map((d, i) => i)};\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.reduceType = reduceType;\n    this.shaderKey = `reduce_${reduceType}_${outputDtype}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const reduceInSharedMemory = this.workGroupSize[0] > 1;\n\n    let reduceOp = ``;\n    let initValue = '0.0';\n    if (this.reduceType === 'min' || this.reduceType === 'max') {\n      reduceOp = `\n         if (isnan(candidate)) {\n          bestValue = float(NAN);\n         } else if (candidate ${this.reduceType === 'min' ? '<' : '>'}\n           bestValue)\n           {  bestValue = candidate; }`;\n      initValue = 'float(x[offset])';\n    } else if (this.reduceType === 'sum' || this.reduceType === 'mean') {\n      reduceOp = ' bestValue += candidate; ';\n    } else if (this.reduceType === 'prod') {\n      reduceOp = ' bestValue *= candidate; ';\n      initValue = '1.0';\n    }\n\n    const outputSnippet = this.reduceType === 'mean' ?\n        `setOutput(flatOutputIndex, bestValue / float(reduceSize));` :\n        `setOutput(flatOutputIndex, bestValue);`;\n\n    const sharedMemorySnippet = `\n         shared float xBestValues[WorkGroupSize];\n       `;\n    const sharedMemoryReduceSnippet = `\n       xBestValues[gl_LocalInvocationID.x] = bestValue;\n       ${\n        this.reduceType === 'sum' || this.reduceType === 'mean' ||\n                this.reduceType === 'prod' ?\n            `bestValue=${initValue};` :\n            ' '}\n       int currentSize = WorkGroupSize;\n       while (currentSize > 1) {\n         barrier();\n         for (int w = 0; w < ${this.reductionFactor}; ++w) {\n           int i = int(gl_LocalInvocationID.x) * ${this.reductionFactor} + w;\n           if (i < currentSize) {\n             float candidate = xBestValues[i];\n             ${reduceOp}\n           }\n         }\n         barrier();\n         xBestValues[gl_LocalInvocationID.x] = bestValue;\n         currentSize = DIV_CEIL(currentSize, ${this.reductionFactor});\n         ${\n        this.reduceType === 'sum' || this.reduceType === 'mean' ||\n                this.reduceType === 'prod' ?\n            `if(currentSize > 1) bestValue=${initValue};` :\n            ''}\n       }\n       if (gl_LocalInvocationID.x == 0) {\n         ${outputSnippet}\n       }\n     `;\n\n    const outputCoordsType = getCoordsDataType(this.outputShape.length);\n\n    const userCode = `\n       #define DIV_CEIL(x, y) (((x) - 1) / (y) + 1)\n       const int WorkGroupSize = int(gl_WorkGroupSize.x);\n       ${reduceInSharedMemory ? sharedMemorySnippet : ''}\n       int getOffset() {\n         const ${outputCoordsType} outputCoords = getOutputCoords();\n         int offset = ${\n        this.outputShape.length === 1 ? 'outputCoords' :\n                                        'outputCoords[0]'} * reduceSize;\n         return offset;\n       }\n       void main() {\n         const int offset= getOffset();\n         float bestValue = ${initValue};\n         const int Length = reduceSize;\n         const int WorkPerThread = DIV_CEIL(Length, WorkGroupSize);\n         for (int w = 0; w < WorkPerThread; ++w) {\n           int i = int(gl_GlobalInvocationID.x) * WorkPerThread + w;\n           if (i < Length) {\n             float candidate = float(x[offset + i]);\n             ${reduceOp}\n           }\n         }\n         const int flatOutputIndex = int(gl_GlobalInvocationID.y);\n         ${reduceInSharedMemory ? sharedMemoryReduceSnippet : outputSnippet}\n       }\n     `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const reduceInSharedMemory = this.workGroupSize[0] > 1;\n\n    let reduceOp = ``;\n    let initValue = '0.0';\n    if (this.reduceType === 'min' || this.reduceType === 'max') {\n      reduceOp = `\n         if (isNanCustom(candidate)) {\n          bestValue = uniforms.NAN;\n         } elseif (candidate ${this.reduceType === 'min' ? '<' : '>'}\n           bestValue)\n           {  bestValue = candidate; }`;\n      initValue = 'f32(x.numbers[offset])';\n    } else if (this.reduceType === 'sum' || this.reduceType === 'mean') {\n      reduceOp = ' bestValue = bestValue + candidate; ';\n    } else if (this.reduceType === 'prod') {\n      reduceOp = ' bestValue = bestValue * candidate; ';\n      initValue = '1.0';\n    }\n\n    const outputSnippet = this.reduceType === 'mean' ?\n        // tslint:disable-next-line:max-line-length\n        `setOutputFlat(flatOutputIndex, bestValue / f32(uniforms.reduceSize));` :\n        `setOutputFlat(flatOutputIndex, bestValue);`;\n\n    const sharedMemorySnippet = `\n         var<workgroup> xBestValues : array<f32, ${this.workGroupSize[0]}>;\n       `;\n    const sharedMemoryReduceSnippet = `\n       xBestValues[localId.x] = bestValue;\n       ${\n        this.reduceType === 'sum' || this.reduceType === 'mean' ||\n                this.reduceType === 'prod' ?\n            `bestValue = ${initValue};` :\n            ' '}\n       var currentSize = WorkGroupSize;\n       for(; currentSize > 1u;) {\n         workgroupBarrier();\n         for (var w = 0u; w < ${this.reductionFactor}u; w = w + 1u) {\n           let i = localId.x * ${this.reductionFactor}u + w;\n           if (i < currentSize) {\n             let candidate = xBestValues[i];\n             ${reduceOp}\n           }\n         }\n         workgroupBarrier();\n         xBestValues[localId.x] = bestValue;\n         currentSize = DIV_CEIL(currentSize, ${this.reductionFactor}u);\n         ${\n        this.reduceType === 'sum' || this.reduceType === 'mean' ||\n                this.reduceType === 'prod' ?\n            `if(currentSize > 1u) { bestValue = ${initValue}; }` :\n            ''}\n       }\n       if (localId.x == 0u) {\n         ${outputSnippet}\n       }\n     `;\n\n    const userCode = `\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n       let WorkGroupSize = ${this.workGroupSize[0]}u;\n       ${reduceInSharedMemory ? sharedMemorySnippet : ''}\n       fn getOffset(globalId : vec3<u32>, index : u32) -> u32 {\n         let outputCoords = getOutputCoords(globalId, index);\n         let offset = ${\n        this.outputShape.length === 1 ?\n            'outputCoords' :\n            'outputCoords[0]'} * uniforms.reduceSize;\n         return offset;\n       }\n       ${getMainHeaderStringWgsl()} {\n         ${getGlobalIndexStringWgsl()}\n         let offset= getOffset(globalId, index);\n         var bestValue = ${initValue};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(Length, WorkGroupSize);\n         for (var w = 0u; w < WorkPerThread; w = w + 1u) {\n           let i = globalId.x * WorkPerThread + w;\n           if (i < Length) {\n             let candidate = f32(x.numbers[offset + i]);\n             ${reduceOp}\n           }\n         }\n         let flatOutputIndex = globalId.y;\n         ${reduceInSharedMemory ? sharedMemoryReduceSnippet : outputSnippet}\n       }\n     `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, sumOutType, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {maxImplCPU} from '../kernel_utils/shared';\nimport {prodImplCPU} from '../kernel_utils/shared';\nimport {ReduceProgram} from '../kernels/reduce_webgpu';\nimport {reshape} from '../kernels/Reshape';\nimport {transpose} from '../kernels/Transpose';\n\ntype ReduceTypes = 'max'|'mean'|'min'|'prod'|'sum';\n\nexport function reduce(\n    x: TensorInfo, axis: number|number[], keepDims: boolean,\n    reduceType: ReduceTypes, backend: WebGPUBackend): TensorInfo {\n  const xRank = x.shape.length;\n  const toDispose = [];\n\n  const origAxes = util.parseAxisParam(axis, x.shape);\n  let axes = origAxes;\n  const permutedAxes = backend_util.getAxesPermutation(axes, xRank);\n\n  let input = x;\n  if (permutedAxes != null) {\n    input = transpose({inputs: {x}, attrs: {perm: permutedAxes}, backend});\n    axes = backend_util.getInnerMostAxes(axes.length, xRank);\n    toDispose.push(input);\n  }\n\n  backend_util.assertAxesAreInnerMostDims(reduceType, axes, xRank);\n\n  const [reduceOutShape, reduceShape] =\n      backend_util.computeOutAndReduceShapes(input.shape, axes);\n  let resOutShape = reduceOutShape;\n  if (keepDims) {\n    // rather than reshape at the end, set the target shape here.\n    resOutShape = backend_util.expandShapeToKeepDim(reduceOutShape, origAxes);\n  }\n\n  let res;\n  if ((reduceType === 'max' || reduceType === 'prod') &&\n      backend.shouldExecuteOnCPU([input])) {\n    const xVals = backend.tensorMap.get(input.dataId).values as TypedArray;\n    switch (reduceType) {\n      case 'max':\n        const outValues = maxImplCPU(\n            xVals, util.sizeFromShape(reduceShape), resOutShape, x.dtype);\n        res = backend.makeTensorInfo(resOutShape, x.dtype, outValues);\n        break;\n      case 'prod':\n        const {outVals, outShape, outDtype} =\n            prodImplCPU(input.shape, input.dtype, xVals, axes);\n        res = backend.makeTensorInfo(outShape, outDtype, outVals);\n        break;\n      default:\n        throw new Error(\n            `${reduceType} CPU implementation is not yet supported.`);\n    }\n  } else {\n    const inSize = util.sizeFromShape(reduceShape);\n    const xSize = util.sizeFromShape(input.shape);\n    const batchSize = xSize / inSize;\n\n    const reduceInfo = {windowSize: inSize, inSize, batchSize, outSize: 1};\n    const dtype = reduceType === 'mean' ? 'float32' : sumOutType(x.dtype);\n    const uniformData = [\n      {type: 'int32', data: [inSize]},\n    ];\n    const program = new ReduceProgram(reduceInfo, reduceType, dtype);\n    const reduced =\n        backend.runWebGPUProgram(program, [input], dtype, uniformData);\n    toDispose.push(reduced);\n\n    res = reshape({inputs: {x: reduced}, attrs: {shape: resOutShape}, backend});\n  }\n\n  toDispose.forEach(t => backend.disposeData(t.dataId));\n\n  return res;\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Sum, SumAttrs, SumInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {reduce} from '../kernel_utils/reduce';\n\nexport function sum(\n    args: {inputs: SumInputs, backend: WebGPUBackend, attrs: SumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  return reduce(x, axis, keepDims, 'sum', backend);\n}\n\nexport const sumConfig: KernelConfig = {\n  kernelName: Sum,\n  backendName: 'webgpu',\n  kernelFunc: sum as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, Einsum, EinsumAttrs, EinsumInputs, KernelConfig, KernelFunc, Tensor, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {multiplyKernelFunc} from './Multiply';\nimport {reshape} from './Reshape';\nimport {sum} from './Sum';\nimport {transpose} from './Transpose';\n\nexport function einsum(\n    args: {inputs: EinsumInputs, backend: WebGPUBackend, attrs: EinsumAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {equation} = attrs;\n  const tensors = inputs as Tensor[];\n\n  const {allDims, summedDims, idDims} =\n      backend_util.decodeEinsumEquation(equation, tensors.length);\n  backend_util.checkEinsumDimSizes(allDims.length, idDims, tensors);\n  const {path, steps} = backend_util.getEinsumComputePath(summedDims, idDims);\n\n  const nSteps = steps.length;\n  let out: TensorInfo|null = null;\n  let numDimsRemaining = allDims.length;\n  const tensorsToDispose: TensorInfo[] = [];\n  for (let i = 0; i < nSteps; ++i) {\n    for (const idTerm of steps[i]) {\n      const {permutationIndices: perm, expandDims: dimsToExpand} =\n          backend_util.getEinsumPermutation(numDimsRemaining, idDims[idTerm]);\n      let x: TensorInfo;\n      if (backend_util.isIdentityPermutation(perm)) {\n        x = tensors[idTerm];\n      } else {\n        x = transpose({inputs: {x: tensors[idTerm]}, backend, attrs: {perm}});\n        tensorsToDispose.push(x);\n      }\n      const targetShape: number[] = x.shape.slice();\n      for (let k = 0; k < dimsToExpand.length; ++k) {\n        targetShape.splice(dimsToExpand[k], 0, 1);\n      }\n\n      if (!util.arraysEqual(x.shape, targetShape)) {\n        x = reshape({inputs: {x}, backend, attrs: {shape: targetShape}});\n        tensorsToDispose.push(x);\n      }\n      if (out === null) {\n        out = x;\n      } else {\n        // tslint:disable-next-line: no-unnecessary-type-assertion\n        out =\n            multiplyKernelFunc({inputs: {a: x, b: out}, backend}) as TensorInfo;\n        tensorsToDispose.push(out);\n      }\n    }\n    if (i < nSteps - 1) {\n      if (path[i] >= 0) {\n        out = sum({\n          inputs: {x: out},\n          backend,\n          attrs: {\n            axis: path[i] - (allDims.length - numDimsRemaining),\n            keepDims: false\n          }\n        });\n        tensorsToDispose.push(out);\n      }\n      numDimsRemaining--;\n    }\n  }\n\n  // Clean up intermediate tensors.\n  for (const tensorInfo of tensorsToDispose) {\n    if (tensorInfo === out) {\n      continue;\n    }\n    backend.disposeData(tensorInfo.dataId);\n  }\n\n  return out;\n}\n\nexport const einsumConfig: KernelConfig = {\n  kernelName: Einsum,\n  backendName: 'webgpu',\n  kernelFunc: einsum as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Elu, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const elu = unaryKernelFunc({opType: UnaryOpType.ELU});\n\nexport const eluConfig: KernelConfig = {\n  kernelName: Elu,\n  backendName: 'webgpu',\n  kernelFunc: elu\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Equal, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {equalImplCPU as cpuEqual} from '../kernel_utils/shared';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const equal = binaryKernelFunc(\n    {opSnippet: BinaryOpType.EQUAL, dtype: 'bool', cpuKernelImpl: cpuEqual});\n\nexport const equalConfig: KernelConfig = {\n  kernelName: Equal,\n  backendName: 'webgpu',\n  kernelFunc: equal\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Exp, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {expImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const exp =\n    unaryKernelFunc({opType: UnaryOpType.EXP, cpuKernelImpl: expImplCPU});\n\nexport const expConfig: KernelConfig = {\n  kernelName: Exp,\n  backendName: 'webgpu',\n  kernelFunc: exp\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the License);\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an AS IS BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ExpandDims, ExpandDimsAttrs, ExpandDimsInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {reshape} from './Reshape';\n\nexport function expandDims(args: {\n  inputs: ExpandDimsInputs,\n  attrs: ExpandDimsAttrs,\n  backend: WebGPUBackend\n}): TensorInfo {\n  const {inputs, attrs, backend} = args;\n  const {dim} = attrs;\n  const {input} = inputs;\n\n  const inputRank = input.shape.length;\n  const newShape = input.shape.slice();\n  let $dim = dim;\n  if (dim < 0) {\n    // Negative value is counted from the tail of rank.\n    util.assert(\n        -(inputRank + 1) <= dim,\n        () => `Axis must be in the interval [${- (inputRank + 1)}, ${\n            inputRank}]`);\n    $dim = inputRank + dim + 1;\n  }\n  newShape.splice($dim, 0, 1);\n\n  return reshape({inputs: {x: input}, backend, attrs: {shape: newShape}});\n}\n\nexport const expandDimsConfig: KernelConfig = {\n  kernelName: ExpandDims,\n  backendName: 'webgpu',\n  kernelFunc: expandDims as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Expm1, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {expm1ImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const expm1 =\n    unaryKernelFunc({opType: UnaryOpType.EXPM1, cpuKernelImpl: expm1ImplCPU});\n\nexport const expm1Config: KernelConfig = {\n  kernelName: Expm1,\n  backendName: 'webgpu',\n  kernelFunc: expm1\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class FillProgram implements WebGPUProgram {\n  variableNames: string[] = [];\n  outputShape: number[] = [];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  uniforms = 'float value;';\n  uniformsWgsl = 'value : f32;';\n  workPerThread = 4;\n  workGroupSize: [number, number, number] = [16, 1, 1];\n  size: number;\n  useWgsl: boolean;\n\n  constructor(shape: number[]) {\n    this.outputShape = shape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n\n    this.shaderKey = 'fill';\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    void main() {\n      int index = getGlobalIndex();\n      for (int i = 0; i < ${this.workPerThread}; i++) {\n        int flatIndex = index * ${this.workPerThread} + i;\n        if (flatIndex < size) {\n          setOutput(flatIndex, float(value));\n        }\n      }\n    }\n  `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const userCode = `\n    ${getMainHeaderStringWgsl()} {\n      ${getGlobalIndexStringWgsl()}\n      for (var i = 0u; i < ${this.workPerThread}u; i = i + 1u) {\n        let flatIndex = index * ${this.workPerThread}u + i;\n        if (flatIndex < uniforms.size) {\n          setOutputFlat(flatIndex, uniforms.value);\n        }\n      }\n    }\n  `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Fill, FillAttrs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {FillProgram} from './fill_webgpu';\n\nexport function fill(args: {backend: WebGPUBackend, attrs: FillAttrs}):\n    TensorInfo {\n  const {backend, attrs} = args;\n  const {shape, value} = attrs;\n  let {dtype} = attrs;\n\n  dtype = dtype || util.inferDtype(value);\n\n  if (dtype === 'string') {\n    // String type should be handled in CPU memory.\n    const values = util.getArrayFromDType(dtype, util.sizeFromShape(shape));\n    values.fill(value as string);\n    return backend.makeTensorInfo(shape, dtype, values);\n  } else {\n    const program = new FillProgram(shape);\n    const uniformData = [{type: 'float32', data: [value as number]}];\n    return backend.runWebGPUProgram(program, [], dtype, uniformData);\n  }\n}\n\nexport const fillConfig: KernelConfig = {\n  kernelName: Fill,\n  backendName: 'webgpu',\n  kernelFunc: fill as {} as KernelFunc\n};\n", "\n/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Floor, KernelConfig} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {floorImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const floor =\n    unaryKernelFunc({opType: UnaryOpType.FLOOR, cpuKernelImpl: floorImplCPU});\n\nexport const floorConfig: KernelConfig = {\n  kernelName: Floor,\n  backendName: 'webgpu',\n  kernelFunc: floor\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FloorDiv, KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const floorDiv =\n    binaryKernelFunc({opSnippet: BinaryOpType.INT_DIV, dtype: 'int32'});\n\nexport const floorDivConfig: KernelConfig = {\n  kernelName: FloorDiv,\n  backendName: 'webgpu',\n  kernelFunc: floorDiv\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use backend file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FromPixelsAttrs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport * as webgpu_program from './webgpu_program';\n\ntype ExternalImage = HTMLCanvasElement|ImageBitmap|OffscreenCanvas;\n\nexport function fromPixelsExternalImage(args: {\n  externalImage: ExternalImage|HTMLVideoElement,\n  backend: WebGPUBackend,\n  attrs: FromPixelsAttrs,\n  outShape: number[],\n  useImport: boolean\n}): TensorInfo {\n  const {externalImage, backend, attrs, outShape, useImport} = args;\n  const {numChannels} = attrs;\n\n  const size = util.sizeFromShape(outShape);\n  const strides = util.computeStrides(outShape);\n  const output = backend.makeTensorInfo(outShape, 'int32');\n  const program =\n      backend.getFromPixelsProgram(useImport ? 'import' : 'copyExternal');\n\n  program.updateOutputShape(outShape);\n\n  // Different outShape will affect preprocessor result,\n  // e.g. getCoordsFromFlatIndex. FromPixelsImageExternalImage needs\n  // to recompile the pipeline to get the correct result.\n  // FromPixelsExternalImage leverages webgpu backend pipeline\n  // cache system to avoid useless recompile.\n  const outputShapes = [output.shape];\n  const outputTypes = [output.dtype, useImport ? 'import' : 'copyExternal'];\n  const key = webgpu_program.makeShaderKey(program, outputShapes, outputTypes);\n\n  const layout = program.getLayout(backend.device);\n\n  const pipeline = backend.getAndSavePipeline(key, () => {\n    return webgpu_program.compileProgram(\n        backend.glslang, backend.device, program, layout.pipelineLayout, [],\n        output, true);\n  });\n\n  program.setPipeline(pipeline);\n\n  if (!useImport) {\n    backend.queue.copyExternalImageToTexture(\n        {source: externalImage as ExternalImage, origin: {x: 0, y: 0}}, {\n          texture:\n              program.makeInputTexture(backend.device, outShape[1], outShape[0])\n        },\n        [outShape[1], outShape[0]]);\n  }\n\n  const info = backend.tensorMap.get(output.dataId);\n\n  info.bufferInfo.buffer = backend.acquireBuffer(info.bufferInfo.byteSize);\n\n  const uniformData = [size, numChannels, ...strides, ...program.dispatch];\n  program.setUniform(backend.device, uniformData);\n\n  let externalResource: GPUExternalTexture|GPUTextureView;\n  if (useImport) {\n    const externalTextureDescriptor = {\n      source: externalImage as HTMLVideoElement\n    };\n    externalResource =\n        backend.device.importExternalTexture(externalTextureDescriptor);\n  } else {\n    externalResource = program.inputTexture.createView();\n  }\n\n  backend.runFromPixelsProgram(\n      program, info.bufferInfo.buffer, layout, externalResource, output.dataId);\n  return output;\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use backend file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, KernelConfig, KernelFunc} from '@tensorflow/tfjs-core';\nimport {FromPixels, FromPixelsAttrs, FromPixelsInputs} from '@tensorflow/tfjs-core';\nimport {backend_util, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {fromPixelsExternalImage} from './FromPixelsExternalImage';\n\nexport const fromPixelsConfig: KernelConfig = {\n  kernelName: FromPixels,\n  backendName: 'webgpu',\n  kernelFunc: fromPixels as {} as KernelFunc,\n};\n\nlet fromPixels2DContext: CanvasRenderingContext2D;\n\nexport function fromPixels(args: {\n  inputs: FromPixelsInputs,\n  backend: WebGPUBackend,\n  attrs: FromPixelsAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  let {pixels} = inputs;\n  const {numChannels} = attrs;\n\n  if (pixels == null) {\n    throw new Error('pixels passed to tf.browser.fromPixels() can not be null');\n  }\n\n  const isVideo = typeof (HTMLVideoElement) !== 'undefined' &&\n      pixels instanceof HTMLVideoElement;\n  const isImage = typeof (HTMLImageElement) !== 'undefined' &&\n      pixels instanceof HTMLImageElement;\n  const isCanvas = typeof (HTMLCanvasElement) !== 'undefined' &&\n      pixels instanceof HTMLCanvasElement;\n  const isImageBitmap =\n      typeof (ImageBitmap) !== 'undefined' && pixels instanceof ImageBitmap;\n\n  const [width, height] = isVideo ?\n      [\n        (pixels as HTMLVideoElement).videoWidth,\n        (pixels as HTMLVideoElement).videoHeight\n      ] :\n      [pixels.width, pixels.height];\n  const outShape = [height, width, numChannels];\n\n  if (env().getBool('WEBGPU_USE_IMPORT')) {\n    if (isVideo) {\n      return fromPixelsExternalImage({\n        externalImage: pixels as HTMLVideoElement,\n        backend,\n        attrs,\n        outShape,\n        useImport: true\n      });\n    }\n  }\n\n  if (isVideo || isImage) {\n    if (fromPixels2DContext == null) {\n      fromPixels2DContext = document.createElement('canvas').getContext('2d');\n    }\n    fromPixels2DContext.canvas.width = width;\n    fromPixels2DContext.canvas.height = height;\n    fromPixels2DContext.drawImage(\n        pixels as HTMLVideoElement | HTMLImageElement, 0, 0, width, height);\n    pixels = fromPixels2DContext.canvas;\n  }\n\n  if (isImageBitmap || isCanvas || isVideo || isImage) {\n    return fromPixelsExternalImage({\n      externalImage: pixels as HTMLCanvasElement | ImageBitmap,\n      backend,\n      attrs,\n      outShape,\n      useImport: false\n    });\n  }\n\n  // TODO: Encoding should happen on GPU once we no longer have to download\n  // image data to the CPU.\n  const imageData = (pixels as ImageData | backend_util.PixelData).data;\n  let pixelArray = imageData;\n  if (numChannels != null && numChannels !== 4) {\n    pixelArray = new Uint8Array(pixels.width * pixels.height * numChannels);\n\n    const dataLength = imageData.length;\n    let j = 0;\n    for (let i = 0; i < dataLength; i++) {\n      if (i % 4 < numChannels) {\n        pixelArray[j++] = imageData[i];\n      }\n    }\n  }\n\n  const output = backend.makeTensorInfo(outShape, 'int32');\n\n  const info = backend.tensorMap.get(output.dataId);\n  info.values = new Int32Array(pixelArray);\n  backend.maybeReleaseBuffer(output.dataId);\n\n  backend.uploadToGPU(output.dataId);\n  return output;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class BatchNormProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[], y?: number[], z?: number[]};\n  dispatch: [number, number, number];\n  variableNames: string[];\n  uniforms = 'float varianceEpsilon;';\n  uniformsWgsl = 'varianceEpsilon : f32;';\n  // This is an experimental value.\n  workGroupSize: [number, number, number] = [128, 1, 1];\n  offsetShape: number[]|null;\n  scaleShape: number[]|null;\n  varianceEpsilon: number;\n  useWgsl: boolean;\n\n  constructor(\n      xShape: number[], meanShape: number[], varianceShape: number[],\n      offsetShape: number[]|null, scaleShape: number[]|null) {\n    this.variableNames = ['x', 'mean', 'variance'];\n    backend_util.assertAndGetBroadcastShape(xShape, meanShape);\n    backend_util.assertAndGetBroadcastShape(xShape, varianceShape);\n    this.outputShape = xShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    if (offsetShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, offsetShape);\n      this.variableNames.push('offset');\n    }\n    if (scaleShape != null) {\n      backend_util.assertAndGetBroadcastShape(xShape, scaleShape);\n      this.variableNames.push('scale');\n    }\n    this.offsetShape = offsetShape;\n    this.scaleShape = scaleShape;\n    this.shaderKey = 'batchNorm';\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    let offsetSnippet = '0.0';\n    if (this.offsetShape != null) {\n      offsetSnippet = 'getOffsetAtOutCoords()';\n    }\n\n    let scaleSnippet = '1.0';\n    if (this.scaleShape != null) {\n      scaleSnippet = 'getScaleAtOutCoords()';\n    }\n\n    const dim = this.outputShape.length;\n    const coordsDataType = getCoordsDataType(dim);\n    let setOutput =\n        'setOutput(coords[0], coords[1], coords[2], coords[3], value);';\n    if (dim === 2) {\n      setOutput = 'setOutput(coords[0], coords[1], value);';\n    }\n    if (dim === 3) {\n      setOutput = 'setOutput(coords[0], coords[1], coords[2], value);';\n    }\n    const userCode = `\n      void writeResult(${coordsDataType} coords,float value) {\n        if (coordsInBounds(coords, outShape)) {\n          ${setOutput}\n        }\n      }\n      void main() {\n        ${coordsDataType} coords = getOutputCoords();\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${offsetSnippet};\n        float scale = ${scaleSnippet};\n        float inv = scale * inversesqrt(variance + float(varianceEpsilon));\n        writeResult(coords,dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n  `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let offsetSnippet = '0.0';\n    if (this.offsetShape != null) {\n      offsetSnippet = 'getOffsetAtOutCoordsByGlobalId(globalId, index)';\n    }\n\n    let scaleSnippet = '1.0';\n    if (this.scaleShape != null) {\n      scaleSnippet = 'getScaleAtOutCoordsByGlobalId(globalId, index)';\n    }\n\n    const dim = this.outputShape.length;\n    const coordsDataType = getCoordsDataTypeWgsl(dim);\n    let setOutput =\n        'setOutput(coords[0], coords[1], coords[2], coords[3], value);';\n    if (dim === 2) {\n      setOutput = 'setOutput(coords[0], coords[1], value);';\n    }\n    if (dim === 3) {\n      setOutput = 'setOutput(coords[0], coords[1], coords[2], value);';\n    }\n    const userCode = `\n      fn writeResult(coords : ${coordsDataType}, value : f32) {\n        if (coordsInBounds${dim}D(coords, uniforms.outShape)) {\n          ${setOutput}\n        }\n      }\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coords = getOutputCoords(globalId, index);\n        let xValue = getXAtOutCoordsByGlobalId(globalId, index);\n        let meanValue = getMeanAtOutCoordsByGlobalId(globalId, index);\n        let varianValue = getVarianceAtOutCoordsByGlobalId(globalId, index);\n        let offsetValue = ${offsetSnippet};\n        let scaleValue = ${scaleSnippet};\n        let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n        writeResult(coords,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n      }\n  `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {FusedBatchNorm, FusedBatchNormAttrs, FusedBatchNormInputs, KernelConfig, Tensor} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {BatchNormProgram} from './batchnorm_webgpu';\n\nexport const fusedBatchNormConfig: KernelConfig = {\n  kernelName: FusedBatchNorm,\n  backendName: 'webgpu',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x, scale, offset, mean, variance} = inputs as FusedBatchNormInputs;\n    const {varianceEpsilon} = attrs as unknown as FusedBatchNormAttrs;\n    const webGPUBackend = backend as WebGPUBackend;\n    const batchNormInputs = [x as Tensor, mean as Tensor, variance as Tensor];\n    let offsetShape = null;\n    if (offset != null) {\n      offsetShape = offset.shape;\n      batchNormInputs.push(offset as Tensor);\n    }\n    let scaleShape = null;\n    if (scale != null) {\n      scaleShape = scale.shape;\n      batchNormInputs.push(scale as Tensor);\n    }\n    const program = new BatchNormProgram(\n        x.shape, mean.shape, variance.shape, offsetShape, scaleShape);\n    const uniformData = [{type: 'float32', data: [varianceEpsilon]}];\n    return webGPUBackend.runWebGPUProgram(\n        program, batchNormInputs, x.dtype, uniformData);\n  }\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, env, FusedConv2D, FusedConv2DAttrs, FusedConv2DInputs, KernelConfig, KernelFunc, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {conv2dByMatMul} from './Conv2D_impl';\nimport {Conv2DMMVec4Program} from './conv2d_mm_vec4_webgpu';\nimport {Conv2DMMProgram} from './conv2d_mm_webgpu';\nimport {Conv2DNaiveProgram} from './conv2d_naive_webgpu';\n\nexport function fusedConv2d(args: {\n  inputs: FusedConv2DInputs,\n  attrs: FusedConv2DAttrs,\n  backend: WebGPUBackend\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter, bias, preluActivationWeights} = inputs;\n  const {\n    strides,\n    pad,\n    dataFormat,\n    dilations,\n    dimRoundingMode,\n    activation,\n    leakyreluAlpha\n  } = attrs;\n\n  const $dataFormat = backend_util.convertConv2DDataFormat(dataFormat);\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, dilations, pad,\n      dimRoundingMode, false /* depthwise */, $dataFormat);\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n\n  let program: Conv2DMMProgram|Conv2DNaiveProgram|Conv2DMMVec4Program;\n\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1 &&\n      convInfo.dilationHeight === 1 && convInfo.dilationWidth === 1 &&\n      convInfo.strideHeight === 1 && convInfo.strideWidth === 1 &&\n      (convInfo.padInfo.type === 'SAME' || convInfo.padInfo.type === 'VALID')) {\n    return conv2dByMatMul({\n      x,\n      filter,\n      convInfo,\n      backend,\n      bias,\n      activation,\n      preluActivationWeights,\n      leakyreluAlpha\n    });\n  }\n\n  const useNaive = env().getBool('WEBGPU_USE_NAIVE_CONV2D');\n\n  const useVec4 =\n      convInfo.inChannels % 4 === 0 && convInfo.outChannels % 4 === 0;\n\n  const padInfo = [convInfo.padInfo.top, convInfo.padInfo.left];\n  const dimensions = [\n    {type: 'int32', data: [convInfo.filterHeight, convInfo.filterWidth]},\n    {type: 'int32', data: [...padInfo]},\n    {type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]},\n    {type: 'int32', data: [convInfo.dilationHeight, convInfo.dilationWidth]}\n  ];\n  if (useNaive) {\n    // TODO(kainino0x): This may be obsolete, but is kept for reference.\n    program = new Conv2DNaiveProgram(\n        convInfo, hasBias, activation, hasPreluActivationWeights);\n  } else {\n    if (useVec4) {\n      program = new Conv2DMMVec4Program(\n          convInfo, hasBias, activation, hasPreluActivationWeights);\n    } else {\n      program = new Conv2DMMProgram(\n          convInfo, hasBias, activation, hasPreluActivationWeights);\n    }\n    const dimAOuter = convInfo.outShape[1] * convInfo.outShape[2];\n    const dimBOuter = convInfo.outShape[3];\n    const dimInner =\n        convInfo.filterHeight * convInfo.filterWidth * convInfo.inShape[3];\n    if (program.useWgsl) {\n      dimensions.push(\n          {type: 'uint32', data: [dimAOuter]},\n          {type: 'uint32', data: [dimBOuter]},\n          {type: 'uint32', data: [dimInner]});\n    }\n  }\n\n  const inputVar: TensorInfo[] = [x, filter];\n  if (hasBias) {\n    inputVar.push(bias);\n  }\n  if (hasPreluActivationWeights) {\n    inputVar.push(preluActivationWeights);\n  }\n\n  return backend.runWebGPUProgram(program, inputVar, x.dtype, dimensions);\n}\n\nexport const fusedConv2DConfig: KernelConfig = {\n  kernelName: FusedConv2D,\n  backendName: 'webgpu',\n  kernelFunc: fusedConv2d as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, FusedDepthwiseConv2D, FusedDepthwiseConv2DAttrs, FusedDepthwiseConv2DInputs, KernelConfig, KernelFunc, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {DepthwiseConv2D3x3Program} from './depthwise_conv2d_3x3_webgpu';\nimport {DepthwiseConv2DProgram} from './depthwise_conv2d_webgpu';\n\nexport function fusedDepthwiseConv2D(args: {\n  inputs: FusedDepthwiseConv2DInputs,\n  attrs: FusedDepthwiseConv2DAttrs,\n  backend: WebGPUBackend\n}) {\n  const {inputs, backend, attrs} = args;\n  const {x, filter, bias, preluActivationWeights} = inputs;\n  const {strides, pad, dilations, dimRoundingMode, activation} = attrs;\n\n  let $dilations = dilations;\n  if ($dilations == null) {\n    $dilations = [1, 1];\n  }\n\n  util.assert(\n      backend_util.eitherStridesOrDilationsAreOne(strides, $dilations),\n      () => 'Error in depthwiseConv2d: Either strides or dilations must be ' +\n          `1. Got strides ${strides} and dilations '${$dilations}'`);\n\n  const convInfo = backend_util.computeConv2DInfo(\n      x.shape as [number, number, number, number],\n      filter.shape as [number, number, number, number], strides, $dilations,\n      pad, dimRoundingMode, true /* depthwise */);\n\n  const programInputs: TensorInfo[] = [x, filter];\n\n  const hasBias = bias != null;\n  const hasPreluActivationWeights = preluActivationWeights != null;\n\n  if (hasBias) {\n    programInputs.push(bias);\n  }\n  if (hasPreluActivationWeights) {\n    programInputs.push(preluActivationWeights);\n  }\n\n  let program: DepthwiseConv2DProgram|DepthwiseConv2D3x3Program;\n  // TODO: To see if we need to relax the limitation. Currently, it's only for\n  // filter size 3x3.\n  if (convInfo.batchSize === 1 && convInfo.inHeight === convInfo.outHeight &&\n      convInfo.inWidth === convInfo.outWidth && convInfo.strideHeight === 1 &&\n      convInfo.strideWidth === 1 &&\n      convInfo.filterHeight === convInfo.filterWidth &&\n      convInfo.inChannels === convInfo.outChannels &&\n      convInfo.filterHeight === 3 && convInfo.inChannels % 4 === 0) {\n    program = new DepthwiseConv2D3x3Program(\n        convInfo, hasBias, activation, hasPreluActivationWeights);\n  } else {\n    program = new DepthwiseConv2DProgram(\n        convInfo, hasBias, activation, hasPreluActivationWeights);\n  }\n\n  const dimensions = [\n    {type: 'int32', data: [convInfo.padInfo.top, convInfo.padInfo.left]},\n    {type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]},\n    {type: 'int32', data: [convInfo.dilationHeight, convInfo.dilationWidth]},\n    {type: 'int32', data: [convInfo.inHeight, convInfo.inWidth]}\n  ];\n\n  const result =\n      backend.runWebGPUProgram(program, programInputs, 'float32', dimensions);\n\n  return result;\n}\n\nexport const fusedDepthwiseConv2DConfig: KernelConfig = {\n  kernelName: FusedDepthwiseConv2D,\n  backendName: 'webgpu',\n  kernelFunc: fusedDepthwiseConv2D as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class GatherNDProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames: string[] = ['A', 'indices'];\n  uniforms: string;\n  uniformsWgsl: string;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  size: number;\n  sliceDim: number;\n  useWgsl: boolean;\n  constructor(sliceDim: number, shape: number[]) {\n    this.outputShape = shape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n    this.shaderKey = `gathernd_${sliceDim}`;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.sliceDim = sliceDim;\n    this.uniforms = `int sliceDim; ${getCoordsDataType(sliceDim)} strides;`;\n    this.uniformsWgsl =\n        `sliceDim : u32; strides : ${getCoordsDataTypeWgsl(sliceDim)};`;\n    this.useWgsl = getUseWgsl();\n  }\n  getUserCode(): string {\n    const dtype = getCoordsDataType(this.outputShape.length);\n    let strideString;\n    if (this.sliceDim > 1) {\n      strideString = 'strides[j]';\n    } else {\n      strideString = 'strides';\n    }\n    const userCode = `\n         void main() {\n          int currentIndex = getGlobalIndex();\n          ${dtype} coords = getOutputCoords();\n          int flattenIndex = 0;\n          for (int j = 0; j < sliceDim; j++) {\n            int index = int(round(getIndices(coords[0], j)));\n            int strideNum = ${strideString};\n            flattenIndex += index * strideNum;\n          }\n          if (currentIndex < size) {\n            setOutput(currentIndex, getA(flattenIndex, coords[1]));\n          }\n        }\n      `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    let strideString;\n    if (this.sliceDim > 1) {\n      strideString = 'uniforms.strides[j]';\n    } else {\n      strideString = 'uniforms.strides';\n    }\n    const userCode = `\n        ${getMainHeaderStringWgsl()} {\n          ${getGlobalIndexStringWgsl()}\n          let coords = getOutputCoords(globalId, index);\n          var flattenIndex = 0u;\n          for (var j = 0u; j < uniforms.sliceDim; j = j + 1u) {\n            let indexTemp = u32(round(getIndices(coords[0], j)));\n            let strideNum = ${strideString};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n          if (index < uniforms.size) {\n            setOutputFlat(index, getA(flattenIndex, coords[1]));\n          }\n        }\n      `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, GatherNd, GatherNdInputs, KernelConfig, KernelFunc, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {gatherNdImplCPU} from '../kernel_utils/shared';\n\nimport {GatherNDProgram} from './gather_nd_webgpu';\nimport {reshape} from './Reshape';\n\nexport function gatherNd(\n    args: {inputs: GatherNdInputs, backend: WebGPUBackend}): TensorInfo {\n  const {inputs, backend} = args;\n  const {params, indices} = inputs;\n\n  const indicesShape = indices.shape;\n  const sliceRank = indicesShape[indicesShape.length - 1];\n  const paramsSize = util.sizeFromShape(params.shape);\n\n  const [resultShape, numSlices, sliceSize, strides] =\n      backend_util.prepareAndValidate(params, indices);\n\n  const flattenIndices = reshape(\n      {inputs: {x: indices}, backend, attrs: {shape: [numSlices, sliceRank]}});\n  const flattenX = reshape({\n    inputs: {x: params},\n    backend,\n    attrs: {shape: [(util.sizeFromShape(params.shape) / sliceSize), sliceSize]}\n  });\n  if (backend.shouldExecuteOnCPU([params, indices]) ||\n      params.dtype === 'string') {\n    const indicesData = backend.readSync(indices.dataId) as TypedArray;\n    const paramsBuf = backend.bufferSync(params);\n    const outValue = gatherNdImplCPU(\n        indicesData, paramsBuf, params.dtype, numSlices, sliceRank, sliceSize,\n        strides, params.shape, paramsSize);\n\n    return backend.makeTensorInfo(resultShape, params.dtype, outValue.values);\n  }\n  const program = new GatherNDProgram(sliceRank, [numSlices, sliceSize]);\n  const uniformData =\n      [{type: 'int32', data: [sliceRank]}, {type: 'int32', data: strides}];\n  const res = backend.runWebGPUProgram(\n      program, [flattenX, flattenIndices], flattenX.dtype, uniformData);\n\n  const reshaped =\n      reshape({inputs: {x: res}, backend, attrs: {shape: resultShape}});\n\n  backend.disposeData(flattenIndices.dataId);\n  backend.disposeData(flattenX.dataId);\n  backend.disposeData(res.dataId);\n\n  return reshaped;\n}\n\nexport const gatherNdConfig: KernelConfig = {\n  kernelName: GatherNd,\n  backendName: 'webgpu',\n  kernelFunc: gatherNd as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class GatherProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames: string[] = ['A', 'indices'];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  aShape: number[];\n  size: number;\n  useWgsl: boolean;\n\n  constructor(aShape: number[], outputShape: number[]) {\n    this.outputShape = aShape.slice();\n    this.aShape = aShape;\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n    this.shaderKey = `gather`;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n  getUserCode(): string {\n    const sourceCoords = getSourceCoords(this.aShape);\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n        ivec4 resRC = getOutputCoords();\n        if (index < size) {\n          setOutput(index, getA(${sourceCoords}));\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const sourceCoords = getSourceCoords(this.aShape, 'u32');\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let resRC = getOutputCoords(globalId, index);\n        if (index < uniforms.size) {\n          setOutputFlat(index, getA(${sourceCoords}));\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n\n// The input and output are always flattened into rank 4 tensors.\nfunction getSourceCoords(aShape: number[], typePrefix = 'int'): string {\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n  const sourceCoords = [];\n  for (let i = 0; i < aShape.length; i++) {\n    if (i === 2) {\n      sourceCoords.push(`${typePrefix}(getIndices(resRC.x, resRC.z))`);\n    } else {\n      sourceCoords.push(`${currentCoords[i]}`);\n    }\n  }\n  return sourceCoords.join();\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, buffer, GatherV2, GatherV2Attrs, GatherV2Inputs, KernelConfig, KernelFunc, Rank, TensorBuffer, TensorInfo, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {gatherV2ImplCPU} from '../kernel_utils/shared';\n\nimport {GatherProgram} from './gather_webgpu';\nimport {reshape} from './Reshape';\n\nexport function gatherV2(\n    args:\n        {inputs: GatherV2Inputs, backend: WebGPUBackend, attrs: GatherV2Attrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, indices} = inputs;\n  const {axis, batchDims} = attrs;\n\n  // Throw error when any index is out of bound.\n  const parsedAxis = util.parseAxisParam(axis, x.shape)[0];\n  const indicesVals = backend.readSync(indices.dataId) as TypedArray;\n  const axisDim = x.shape[parsedAxis];\n  for (let i = 0; i < indicesVals.length; ++i) {\n    const index = indicesVals[i];\n    util.assert(\n        index <= axisDim - 1 && index >= 0,\n        () =>\n            `GatherV2: the index value ${index} is not in [0, ${axisDim - 1}]`);\n  }\n\n  const shapeInfo = backend_util.segment_util.collectGatherOpShapeInfo(\n      x, indices, parsedAxis, batchDims);\n\n  const indicesSize = util.sizeFromShape(indices.shape);\n\n  const toDispose = [];\n\n  const flattenX = reshape({\n    inputs: {x},\n    backend,\n    attrs: {\n      shape: [\n        shapeInfo.batchSize, shapeInfo.outerSize, shapeInfo.dimSize,\n        shapeInfo.sliceSize\n      ]\n    }\n  });\n\n  const flattenIndex = reshape({\n    inputs: {x: indices},\n    backend,\n    attrs: {shape: [shapeInfo.batchSize, indicesSize / shapeInfo.batchSize]}\n  });\n\n  toDispose.push(flattenX);\n  toDispose.push(flattenIndex);\n\n  const flattenOutputShape = [\n    shapeInfo.batchSize, shapeInfo.outerSize, indicesSize / shapeInfo.batchSize,\n    shapeInfo.sliceSize\n  ];\n\n  if (backend.shouldExecuteOnCPU([x, indices])) {\n    const indicesBufferInfo = backend.tensorMap.get(flattenIndex.dataId);\n    const indicesValues = indicesBufferInfo.values as TypedArray;\n    const indicesBuf =\n        buffer(flattenIndex.shape, flattenIndex.dtype, indicesValues) as\n        TensorBuffer<Rank>;\n    const xBufferInfo = backend.tensorMap.get(flattenX.dataId);\n    const xValues = xBufferInfo.values as TypedArray;\n    const xBuf =\n        buffer(flattenX.shape, flattenX.dtype, xValues) as TensorBuffer<Rank>;\n    const outBuf = gatherV2ImplCPU(xBuf, indicesBuf, flattenOutputShape);\n\n    toDispose.forEach(t => backend.disposeData(t.dataId));\n\n    return backend.makeTensorInfo(\n        shapeInfo.outputShape, outBuf.dtype, outBuf.values as TypedArray);\n  }\n\n  const program = new GatherProgram(flattenX.shape, flattenOutputShape);\n  const res = backend.runWebGPUProgram(\n      program, [flattenX, flattenIndex], flattenX.dtype);\n  toDispose.push(res);\n\n  const reshaped = reshape(\n      {inputs: {x: res}, backend, attrs: {shape: shapeInfo.outputShape}});\n  toDispose.forEach(t => backend.disposeData(t.dataId));\n  return reshaped;\n}\n\nexport const gatherV2Config: KernelConfig = {\n  kernelName: GatherV2,\n  backendName: 'webgpu',\n  kernelFunc: gatherV2 as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Greater, KernelConfig} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {greaterImplCPU as cpuGreater} from '../kernel_utils/shared';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const greater = binaryKernelFunc({\n  opSnippet: BinaryOpType.GREATER,\n  cpuKernelImpl: cpuGreater,\n  dtype: 'bool',\n});\n\nexport const greaterConfig: KernelConfig = {\n  kernelName: Greater,\n  backendName: 'webgpu',\n  kernelFunc: greater\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GreaterEqual, KernelConfig} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {greaterEqualImplCPU as cpuGreaterEqual} from '../kernel_utils/shared';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const greaterEqual = binaryKernelFunc({\n  opSnippet: BinaryOpType.GREATER_EQUAL,\n  dtype: 'bool',\n  cpuKernelImpl: cpuGreaterEqual\n});\n\nexport const greaterEqualConfig: KernelConfig = {\n  kernelName: GreaterEqual,\n  backendName: 'webgpu',\n  kernelFunc: greaterEqual\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Less} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {lessImplCPU as cpuLess} from '../kernel_utils/shared';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const less = binaryKernelFunc(\n    {opSnippet: BinaryOpType.LESS, dtype: 'bool', cpuKernelImpl: cpuLess});\n\nexport const lessConfig: KernelConfig = {\n  kernelName: Less,\n  backendName: 'webgpu',\n  kernelFunc: less\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, LessEqual} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {lessEqualImplCPU as cpuLessEqual} from '../kernel_utils/shared';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const lessEqual = binaryKernelFunc({\n  opSnippet: BinaryOpType.LESS_EQUAL,\n  dtype: 'bool',\n  cpuKernelImpl: cpuLessEqual\n});\n\nexport const lessEqualConfig: KernelConfig = {\n  kernelName: LessEqual,\n  backendName: 'webgpu',\n  kernelFunc: lessEqual\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Log} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {logImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const log =\n    unaryKernelFunc({opType: UnaryOpType.LOG, cpuKernelImpl: logImplCPU});\n\nexport const logConfig: KernelConfig = {\n  kernelName: Log,\n  backendName: 'webgpu',\n  kernelFunc: log\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, LogicalAnd} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const logicalAnd = binaryKernelFunc({\n  opSnippet: BinaryOpType.LOGICAL_AND,\n  dtype: 'bool'\n});\n\nexport const logicalAndConfig: KernelConfig = {\n  kernelName: LogicalAnd,\n  backendName: 'webgpu',\n  kernelFunc: logicalAnd\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Max, MaxAttrs, MaxInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {reduce} from '../kernel_utils/reduce';\n\nexport function max(\n    args: {inputs: MaxInputs, backend: WebGPUBackend, attrs: MaxAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {reductionIndices, keepDims} = attrs;\n\n  return reduce(x, reductionIndices, keepDims, 'max', backend);\n}\n\nexport const maxConfig: KernelConfig = {\n  kernelName: Max,\n  backendName: 'webgpu',\n  kernelFunc: max as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Maximum} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {maximumImplCPU as cpuMaximum} from '../kernel_utils/shared';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const maximum = binaryKernelFunc({\n  opSnippet: BinaryOpType.MAX,\n  cpuKernelImpl: cpuMaximum,\n});\n\nexport const maximumConfig: KernelConfig = {\n  kernelName: Maximum,\n  backendName: 'webgpu',\n  kernelFunc: maximum\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {backend_util, KernelConfig, KernelFunc, MaxPool, MaxPoolAttrs, MaxPoolInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {identity} from './Identity';\nimport {Pool2DProgram} from './pool2d_webgpu';\nimport {PoolWithFilterSizeEqualsOneProgram} from './pool_filtersizeone_webgpu';\n\nexport function maxPool(\n    args: {inputs: MaxPoolInputs, backend: WebGPUBackend, attrs: MaxPoolAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {filterSize, strides, pad, dimRoundingMode} = attrs;\n  const dilations = 1;\n  const convInfo = backend_util.computePool2DInfo(\n      x.shape as [number, number, number, number], filterSize, strides,\n      dilations, pad, dimRoundingMode);\n  let program: Pool2DProgram|PoolWithFilterSizeEqualsOneProgram;\n  const dimensions = [];\n  if (convInfo.filterHeight === 1 && convInfo.filterWidth === 1) {\n    if (util.arraysEqual(convInfo.inShape, convInfo.outShape)) {\n      return identity({inputs: {x}, backend});\n    }\n    program = new PoolWithFilterSizeEqualsOneProgram(convInfo);\n    dimensions.push(\n        {type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]});\n  } else {\n    program = new Pool2DProgram(convInfo, 'max');\n    dimensions.push(\n        {type: 'int32', data: [convInfo.strideHeight, convInfo.strideWidth]},\n        {type: 'int32', data: [convInfo.padInfo.top, convInfo.padInfo.left]}, {\n          type: 'int32',\n          data: [convInfo.dilationHeight, convInfo.dilationWidth]\n        },\n        {type: 'int32', data: [convInfo.inHeight, convInfo.inWidth]}, {\n          type: 'int32',\n          data: [convInfo.effectiveFilterHeight, convInfo.effectiveFilterWidth]\n        });\n  }\n\n  return backend.runWebGPUProgram(program, [x], x.dtype, dimensions);\n}\n\nexport const maxPoolConfig: KernelConfig = {\n  kernelName: MaxPool,\n  backendName: 'webgpu',\n  kernelFunc: maxPool as {} as KernelFunc\n};\n", "/**\r\n * @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\nimport {KernelConfig, KernelFunc, Mean, MeanAttrs, MeanInputs, TensorInfo} from '@tensorflow/tfjs-core';\r\n\r\nimport {WebGPUBackend} from '../backend_webgpu';\r\nimport {reduce} from '../kernel_utils/reduce';\r\n\r\nexport function mean(\r\n    args: {inputs: MeanInputs, attrs: MeanAttrs, backend: WebGPUBackend}):\r\n    TensorInfo {\r\n  const {inputs, backend, attrs} = args;\r\n  const {x} = inputs;\r\n  const {keepDims, axis} = attrs;\r\n\r\n  return reduce(x, axis, keepDims, 'mean', backend);\r\n}\r\n\r\nexport const meanConfig: KernelConfig = {\r\n  kernelName: Mean,\r\n  backendName: 'webgpu',\r\n  kernelFunc: mean as {} as KernelFunc\r\n};\r\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Min, MinAttrs, MinInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {reduce} from '../kernel_utils/reduce';\n\nexport function min(\n    args: {inputs: MinInputs, backend: WebGPUBackend, attrs: MinAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {axis, keepDims} = attrs;\n\n  return reduce(x, axis, keepDims, 'min', backend);\n}\n\nexport const minConfig: KernelConfig = {\n  kernelName: Min,\n  backendName: 'webgpu',\n  kernelFunc: min as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Minimum} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {minimumImplCPU as cpuMinimum} from '../kernel_utils/shared';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const minimum = binaryKernelFunc({\n  opSnippet: BinaryOpType.MIN,\n  cpuKernelImpl: cpuMinimum,\n});\n\nexport const minimumConfig: KernelConfig = {\n  kernelName: Minimum,\n  backendName: 'webgpu',\n  kernelFunc: minimum\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class MirrorPadProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  uniforms = '';\n  uniformsWgsl = '';\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  xShape: number[];\n  offset: number;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(\n      xShape: number[], paddings: Array<[number, number]>,\n      mode: 'reflect'|'symmetric') {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.xShape = xShape;\n    paddings.map((_, i) => {\n      this.uniforms += ` ivec2 pad${i};`;\n      this.uniformsWgsl += ` pad${i} : vec2<u32>;`;\n    });\n    this.offset = mode === 'reflect' ? 0 : 1;\n    this.shaderKey = `mirrorPad_${mode}`;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const rank = this.xShape.length;\n    // The length of paddings are same with the rank of the input tensor.\n    const start = this.xShape.map((_, i) => `pad${i}[0]`).join(',');\n    const end =\n        this.xShape\n            .map((_, i) => `pad${i}[0] + xShape${rank > 1 ? `[${i}]` : ''}`)\n            .join(',');\n\n    const shaderStart = rank === 1 ? 'start' : 'start[i]';\n    const shaderEnd = rank === 1 ? 'end' : 'end[i]';\n    const shaderOutC = rank === 1 ? 'outC' : 'outC[i]';\n    const dtype = getCoordsDataType(rank);\n    const unpackedCoords = rank > 1 ?\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank) :\n        'coords';\n\n    return `\n      ${dtype} start = ${dtype}(${start});\n      ${dtype} end = ${dtype}(${end});\n\n      void main() {\n        ${dtype} outC = getOutputCoords();\n        int index = getGlobalIndex();\n        if (index < size)\n        {\n          for (int i = 0; i < ${rank}; i++) {\n            if (${shaderOutC} < ${shaderStart}) {\n              ${shaderOutC} = ${shaderStart} * 2 - ${shaderOutC} - ${\n        this.offset};\n            } else if(${shaderOutC} >= ${shaderEnd}) {\n              ${shaderOutC} = (${shaderEnd} - 1) * 2 - ${shaderOutC} + ${\n        this.offset};\n            }\n          }\n          ${dtype} coords = outC - start;\n          setOutput(index, getX(${unpackedCoords}));\n        }\n      }\n    `;\n  }\n\n  getUserCodeWgsl(): string {\n    const rank = this.xShape.length;\n    // The length of paddings are same with the rank of the input tensor.\n    const start = this.xShape.map((_, i) => `uniforms.pad${i}[0]`).join(',');\n    const end = this.xShape\n                    .map(\n                        (_, i) => `uniforms.pad${i}[0] + uniforms.xShape${\n                            rank > 1 ? `[${i}]` : ''}`)\n                    .join(',');\n\n    const shaderStart = rank === 1 ? 'start' : 'start[i]';\n    const shaderEnd = rank === 1 ? 'end' : 'end[i]';\n    const shaderOutC = rank === 1 ? 'outC' : 'outC[i]';\n    const dtype = getCoordsDataTypeWgsl(rank);\n    const unpackedCoords = rank > 1 ?\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank) :\n        'coords';\n\n    return `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let start = ${dtype}(${start});\n        let end = ${dtype}(${end});\n        var outC = getOutputCoords(globalId, index);\n        if (index < uniforms.size)\n        {\n          for (var i = 0u; i < ${rank}u; i = i + 1u) {\n            if (${shaderOutC} < ${shaderStart}) {\n              ${shaderOutC} = ${shaderStart} * 2u - ${shaderOutC} - ${\n        this.offset}u;\n            } elseif(${shaderOutC} >= ${shaderEnd}) {\n              ${shaderOutC} = (${shaderEnd} - 1u) * 2u - ${shaderOutC} + ${\n        this.offset}u;\n            }\n          }\n          let coords = outC - start;\n          setOutputFlat(index, getX(${unpackedCoords}));\n        }\n      }\n    `;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, MirrorPad, MirrorPadAttrs, MirrorPadInputs} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {MirrorPadProgram} from './mirror_pad_webgpu';\n\nexport const mirrorPadConfig: KernelConfig = {\n  kernelName: MirrorPad,\n  backendName: 'webgpu',\n  kernelFunc: ({inputs, attrs, backend}) => {\n    const {x} = inputs as MirrorPadInputs;\n    const {paddings, mode} = attrs as unknown as MirrorPadAttrs;\n    const webGPUBackend = backend as WebGPUBackend;\n\n    const uniformData = paddings.map(p => {\n      return {type: 'int32', data: [p[0], p[1]]};\n    });\n    const program = new MirrorPadProgram(x.shape, paddings, mode);\n    const output =\n        webGPUBackend.runWebGPUProgram(program, [x], x.dtype, uniformData);\n\n    return output;\n  }\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Neg, NegInputs, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {negImplCPU} from '../kernel_utils/shared';\n\nimport {UnaryOpType} from './unary_op_util';\nimport {UnaryOpProgram} from './unary_op_webgpu';\n\n// This doesn't use unaryKernelFunc because negImplCPU is not of type\n// SimpleUnaryKernelImplCPU.\nexport function neg(args: {inputs: NegInputs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (backend.shouldExecuteOnCPU([x])) {\n    const xData = backend.tensorMap.get(x.dataId);\n    const [outValues, newShape] =\n        negImplCPU(xData.values as TypedArray, x.shape, x.dtype);\n    return backend.makeTensorInfo(newShape, x.dtype, outValues);\n  }\n\n  const program = new UnaryOpProgram(x.shape, UnaryOpType.NEG);\n\n  return backend.runWebGPUProgram(program, [x], x.dtype);\n}\n\nexport const negConfig: KernelConfig = {\n  kernelName: Neg,\n  backendName: 'webgpu',\n  kernelFunc: neg as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV3, NonMaxSuppressionV3Attrs, NonMaxSuppressionV3Inputs, TypedArray} from '@tensorflow/tfjs-core';\nimport {WebGPUBackend} from '../backend_webgpu';\n\nexport function nonMaxSuppressionV3(args: {\n  inputs: NonMaxSuppressionV3Inputs,\n  backend: WebGPUBackend,\n  attrs: NonMaxSuppressionV3Attrs\n}) {\n  console.warn(\n      'tf.nonMaxSuppression() in webgpu locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold} = attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const {selectedIndices} = kernel_impls.nonMaxSuppressionV3Impl(\n      boxesVals, scoresVals, maxOutputSize, iouThreshold, scoreThreshold);\n\n  return backend.makeTensorInfo(\n      [selectedIndices.length], 'int32', new Int32Array(selectedIndices));\n}\n\nexport const nonMaxSuppressionV3Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV3,\n  backendName: 'webgpu',\n  kernelFunc: nonMaxSuppressionV3 as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {kernel_impls, KernelConfig, KernelFunc, NonMaxSuppressionV5, NonMaxSuppressionV5Attrs, NonMaxSuppressionV5Inputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nexport type TypedArray = Float32Array|Int32Array|Uint8Array;\n\nexport function nonMaxSuppressionV5(args: {\n  inputs: NonMaxSuppressionV5Inputs,\n  backend: WebGPUBackend,\n  attrs: NonMaxSuppressionV5Attrs\n}): [TensorInfo, TensorInfo] {\n  console.warn(\n      'tf.nonMaxSuppression() in webgpu locks the UI thread. ' +\n      'Call tf.nonMaxSuppressionAsync() instead');\n\n  const {inputs, backend, attrs} = args;\n  const {boxes, scores} = inputs;\n  const {maxOutputSize, iouThreshold, scoreThreshold, softNmsSigma} = attrs;\n\n  const boxesVals = backend.readSync(boxes.dataId) as TypedArray;\n  const scoresVals = backend.readSync(scores.dataId) as TypedArray;\n\n  const maxOutputSizeVal = maxOutputSize;\n  const iouThresholdVal = iouThreshold;\n  const scoreThresholdVal = scoreThreshold;\n  const softNmsSigmaVal = softNmsSigma;\n\n  const {selectedIndices, selectedScores} =\n      kernel_impls.nonMaxSuppressionV5Impl(\n          boxesVals, scoresVals, maxOutputSizeVal, iouThresholdVal,\n          scoreThresholdVal, softNmsSigmaVal);\n\n  return [\n    backend.makeTensorInfo(\n        [selectedIndices.length], 'int32', new Int32Array(selectedIndices)),\n    backend.makeTensorInfo(\n        [selectedScores.length], 'float32', new Float32Array(selectedScores))\n  ];\n}\n\nexport const nonMaxSuppressionV5Config: KernelConfig = {\n  kernelName: NonMaxSuppressionV5,\n  backendName: 'webgpu',\n  kernelFunc: nonMaxSuppressionV5 as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, ZerosLike, ZerosLikeInputs} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {complex} from './Complex';\nimport {fill} from './Fill';\nimport {imag} from './Imag';\nimport {real} from './Real';\n\nexport function zerosLike(\n    args: {inputs: ZerosLikeInputs, backend: WebGPUBackend}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n  if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const r = zerosLike({inputs: {x: realPart}, backend});\n    const imagPart = imag({inputs: {input: x}, backend});\n    const i = zerosLike({inputs: {x: imagPart}, backend});\n\n    const result = complex({inputs: {real: r, imag: i}, backend});\n\n    backend.disposeData(realPart.dataId);\n    backend.disposeData(r.dataId);\n    backend.disposeData(imagPart.dataId);\n    backend.disposeData(i.dataId);\n\n    return result;\n  } else {\n    return fill({\n      attrs: {\n        shape: x.shape,\n        dtype: x.dtype,\n        value: x.dtype === 'string' ? '' : 0\n      },\n      backend\n    });\n  }\n}\n\nexport const zerosLikeConfig: KernelConfig = {\n  kernelName: ZerosLike,\n  backendName: 'webgpu',\n  kernelFunc: zerosLike as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, OnesLike, OnesLikeInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {complex} from './Complex';\nimport {fill} from './Fill';\nimport {imag} from './Imag';\nimport {real} from './Real';\nimport {zerosLike} from './ZerosLike';\n\nexport function onesLike(\n    args: {inputs: OnesLikeInputs, backend: WebGPUBackend}): TensorInfo {\n  const {inputs, backend} = args;\n  const {x} = inputs;\n\n  if (x.dtype === 'string') {\n    throw new Error('onesLike is not supported under string dtype');\n  } else if (x.dtype === 'complex64') {\n    const realPart = real({inputs: {input: x}, backend});\n    const r = onesLike({inputs: {x: realPart}, backend});\n    const imagPart = imag({inputs: {input: x}, backend});\n    const i = zerosLike({inputs: {x: imagPart}, backend});\n\n    const result = complex({inputs: {real: r, imag: i}, backend});\n\n    backend.disposeData(realPart.dataId);\n    backend.disposeData(r.dataId);\n    backend.disposeData(imagPart.dataId);\n    backend.disposeData(i.dataId);\n\n    return result;\n  } else {\n    return fill({attrs: {shape: x.shape, dtype: x.dtype, value: 1}, backend});\n  }\n}\n\nexport const onesLikeConfig: KernelConfig = {\n  kernelName: OnesLike,\n  backendName: 'webgpu',\n  kernelFunc: onesLike as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Pack, PackAttrs, PackInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {concat} from './Concat';\nimport {expandDims} from './ExpandDims';\n\nexport function pack(\n    args: {inputs: PackInputs, backend: WebGPUBackend, attrs: PackAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {axis} = attrs;\n\n  if (inputs.length === 1) {\n    return expandDims(\n        {inputs: {input: inputs[0]}, backend, attrs: {dim: axis}});\n  }\n\n  const shape = inputs[0].shape;\n  const dtype = inputs[0].dtype;\n\n  inputs.forEach(t => {\n    util.assertShapesMatch(\n        shape, t.shape,\n        'All tensors passed to stack must have matching shapes');\n    util.assert(\n        dtype === t.dtype,\n        () => 'All tensors passed to stack must have matching dtypes');\n  });\n\n  const intermediateTensorInfos: TensorInfo[] = [];\n  const expandedTensors = inputs.map(t => {\n    const expandedT =\n        expandDims({inputs: {input: t}, backend, attrs: {dim: axis}});\n    intermediateTensorInfos.push(expandedT);\n    return expandedT;\n  });\n\n  const result = concat({inputs: expandedTensors, backend, attrs: {axis}});\n\n  intermediateTensorInfos.forEach(t => backend.disposeData(t.dataId));\n\n  return result;\n}\n\nexport const packConfig: KernelConfig = {\n  kernelName: Pack,\n  backendName: 'webgpu',\n  kernelFunc: pack as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class PadProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  uniforms = 'float constantValue;';\n  uniformsWgsl = 'constantValue : f32;';\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  xShape: number[];\n  size: number;\n  useWgsl: boolean;\n\n  constructor(xShape: number[], paddings: Array<[number, number]>) {\n    this.outputShape = paddings.map(\n        (p, i) => p[0] /* beforePad */ + xShape[i] + p[1] /* afterPad */);\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n    paddings.map((_, i) => {\n      this.uniforms += ` ivec2 pad${i};`;\n      this.uniformsWgsl += ` pad${i} : vec2<u32>;`;\n    });\n    this.xShape = xShape;\n    this.shaderKey = 'pad';\n    this.useWgsl = getUseWgsl();\n    this.size = util.sizeFromShape(this.outputShape);\n  }\n\n  getUserCode(): string {\n    const rank = this.xShape.length;\n    const type = getCoordsDataType(rank);\n    // The length of paddings are same with the rank of the input tensor.\n    const start = this.xShape.map((_, i) => `pad${i}[0]`).join(',');\n    const end =\n        this.xShape\n            .map((_, i) => `pad${i}[0] + xShape${rank > 1 ? `[${i}]` : ''}`)\n            .join(',');\n    const startValue = rank > 1 ? `${type}(${start})` : `${start}`;\n    const endValue = rank > 1 ? `${type}(${end})` : `${end}`;\n\n    const leftPadCondition =\n        rank > 1 ? `any(lessThan(outC, start))` : `outC < start`;\n    const rightPadCondition =\n        rank > 1 ? `any(greaterThanEqual(outC, end))` : `outC >= end`;\n\n    const unpackedCoords = rank > 1 ?\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank) :\n        'coords';\n\n    const userCode = `\n      ${type} start = ${startValue};\n      ${type} end = ${endValue};\n\n      void main() {\n        int flatIndex = getGlobalIndex();\n\n          if (flatIndex < size) {\n            ${type} outC = getOutputCoords();\n\n            if (${leftPadCondition} || ${rightPadCondition}) {\n              setOutput(flatIndex, constantValue);\n            } else {\n              ${type} coords = outC - start;\n              setOutput(flatIndex, getX(${unpackedCoords}));\n            }\n          }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const rank = this.xShape.length;\n    const type = getCoordsDataTypeWgsl(rank);\n    // The length of paddings are same with the rank of the input tensor.\n    const start = this.xShape.map((_, i) => `uniforms.pad${i}[0]`).join(',');\n    const end = this.xShape\n                    .map(\n                        (_, i) => `uniforms.pad${i}[0] + uniforms.xShape${\n                            rank > 1 ? `[${i}]` : ''}`)\n                    .join(',');\n    const startValue = rank > 1 ? `${type}(${start})` : `${start}`;\n    const endValue = rank > 1 ? `${type}(${end})` : `${end}`;\n\n    const leftPadCondition = rank > 1 ? `any(outC < start)` : `outC < start`;\n    const rightPadCondition = rank > 1 ? `any(outC >= end)` : `outC >= end`;\n\n    const unpackedCoords = rank > 1 ?\n        ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank) :\n        'coords';\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let start = ${startValue};\n        let end = ${endValue};\n        if (index < uniforms.size) {\n          let outC = getOutputCoords(globalId, index);\n\n          if (${leftPadCondition} || ${rightPadCondition}) {\n            setOutputFlat(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputFlat(index, getX(${unpackedCoords}));\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, PadV2, PadV2Attrs, PadV2Inputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {identity} from './Identity';\nimport {PadProgram} from './pad_webgpu';\nimport {fill} from './Fill';\n\nexport const padV2 =\n    (args: {inputs: PadV2Inputs,\n            backend: WebGPUBackend,\n            attrs: PadV2Attrs}): TensorInfo => {\n      const {inputs, backend, attrs} = args;\n      const {x} = inputs;\n      const {paddings, constantValue} = attrs;\n      if (paddings.every(p => util.arraysEqual(p, [0, 0]))) {\n        return identity({inputs: {x}, backend});\n      }\n      if (util.sizeFromShape(x.shape) === 0) {\n        // Short-circuit the computation, since x doesn't have value, only\n        // the shape is used to compute output shape to pad.\n        const outputShape = paddings.map(\n            (p, i) =>\n                p[0] /* beforePad */ + x.shape[i] + p[1] /* afterPad */);\n        return fill({\n          backend,\n          attrs: {shape: outputShape, value: constantValue, dtype: x.dtype}\n        });\n      }\n      const uniformData = [{type: 'float32', data: [constantValue]}];\n      paddings.map(p => uniformData.push({type: 'int32', data: [p[0], p[1]]}));\n      const program = new PadProgram(x.shape, paddings);\n      return backend.runWebGPUProgram(program, [x], x.dtype, uniformData);\n    };\n\nexport const padV2Config: KernelConfig = {\n  kernelName: PadV2,\n  backendName: 'webgpu',\n  kernelFunc: padV2 as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Pow} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const pow = binaryKernelFunc({\n  opSnippet: BinaryOpType.POW,\n});\n\nexport const powConfig: KernelConfig = {\n  kernelName: Pow,\n  backendName: 'webgpu',\n  kernelFunc: pow\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Prelu, PreluInputs, TensorInfo} from '@tensorflow/tfjs-core';\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {BinaryOpProgram} from './binary_op_webgpu';\nimport {BinaryOpType} from './binary_op_util';\n\nexport function prelu(args: {inputs: PreluInputs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {x, alpha} = inputs;\n\n  const program = new BinaryOpProgram(BinaryOpType.PRELU, x.shape, alpha.shape);\n  return backend.runWebGPUProgram(program, [x, alpha], x.dtype);\n}\n\nexport const preluConfig: KernelConfig = {\n  kernelName: Prelu,\n  backendName: 'webgpu',\n  kernelFunc: prelu as {} as KernelFunc\n};\n", "/**\r\n * @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * =============================================================================\r\n */\r\n\r\nimport {KernelConfig, KernelFunc, Prod, ProdAttrs, ProdInputs, TensorInfo} from '@tensorflow/tfjs-core';\r\n\r\nimport {WebGPUBackend} from '../backend_webgpu';\r\nimport {reduce} from '../kernel_utils/reduce';\r\n\r\nexport function prod(\r\n    args: {inputs: ProdInputs, backend: WebGPUBackend, attrs: ProdAttrs}):\r\n    TensorInfo {\r\n  const {inputs, backend, attrs} = args;\r\n  const {x} = inputs;\r\n  const {axis, keepDims} = attrs;\r\n\r\n  return reduce(x, axis, keepDims, 'prod', backend);\r\n}\r\n\r\nexport const prodConfig: KernelConfig = {\r\n  kernelName: Prod,\r\n  backendName: 'webgpu',\r\n  kernelFunc: prod as {} as KernelFunc\r\n};\r\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Range, RangeAttrs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {rangeImplCPU} from '../kernel_utils/shared';\n\nexport const range =\n    (args: {backend: WebGPUBackend, attrs: RangeAttrs}): TensorInfo => {\n      const {backend, attrs} = args;\n      const {start, stop, step, dtype} = attrs;\n      const values = rangeImplCPU(start, stop, step, dtype);\n      return backend.makeTensorInfo([values.length], dtype, values);\n    };\n\nexport const rangeConfig: KernelConfig = {\n  kernelName: Range,\n  backendName: 'webgpu',\n  kernelFunc: range as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, RealDiv} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const realDiv = binaryKernelFunc({opSnippet: BinaryOpType.DIV});\n\nexport const realDivConfig: KernelConfig = {\n  kernelName: RealDiv,\n  backendName: 'webgpu',\n  kernelFunc: realDiv as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Relu} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const relu = unaryKernelFunc({opType: UnaryOpType.RELU});\n\nexport const reluConfig: KernelConfig = {\n  kernelName: Relu,\n  backendName: 'webgpu',\n  kernelFunc: relu\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Relu6} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const relu6 = unaryKernelFunc({opType: UnaryOpType.RELU6});\n\nexport const relu6Config: KernelConfig = {\n  kernelName: Relu6,\n  backendName: 'webgpu',\n  kernelFunc: relu6\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class ResizeBilinearProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  alignCorners: boolean;\n  halfPixelCenters: boolean;\n  useWgsl: boolean;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    this.outputShape = [inputShape[0], newHeight, newWidth, inputShape[3]];\n\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.alignCorners = alignCorners;\n    this.halfPixelCenters = halfPixelCenters;\n    this.shaderKey = `resizeBilinear_${alignCorners}_${halfPixelCenters}_${\n        this.outputShape[1] > 1}_${this.outputShape[2] > 1}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const adjustHeight = this.alignCorners && this.outputShape[1] > 1;\n    const adjustWidth = this.alignCorners && this.outputShape[2] > 1;\n\n    const userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        if (all(lessThan(coords, outShape))) {\n          int b = coords[0];\n          int d = coords[3];\n          ivec2 rc = coords.yz;\n\n          vec2 effectiveInSize = vec2(\n            ${adjustHeight ? `xShape.y - 1.0` : `xShape.y`},\n            ${adjustWidth ? `xShape.z - 1.0` : `xShape.z`});\n\n          vec2 effectiveOutSize = vec2(\n            ${adjustHeight ? `outShape.y - 1.0` : `outShape.y`},\n            ${adjustWidth ? `outShape.z - 1.0` : `outShape.z`});\n\n          vec2 effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          vec2 sourceFracIndexRC = ${\n        this.halfPixelCenters ?\n            '(vec2(rc) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)' :\n            'vec2(rc) * effectiveInputOverOutputRatioRC'};\n\n          // Compute the four integer indices.\n          ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n          ivec2 sourceCeilRC = ivec2(\n            min(xShape.yz - 1.0, ceil(sourceFracIndexRC)));\n\n          float topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          float bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          float topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          float bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n          float top = topLeft + (topRight - topLeft) * fracRC.y;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          float newValue = top + (bottom - top) * fracRC.x;\n\n          setOutput(b, coords[1], coords[2], d, newValue);\n        }\n      }\n    `;\n    return userCode;\n  }\n  getUserCodeWgsl(): string {\n    const adjustHeight = this.alignCorners && this.outputShape[1] > 1;\n    const adjustWidth = this.alignCorners && this.outputShape[2] > 1;\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coords = getOutputCoords(globalId, index);\n        if (all(coords < uniforms.outShape)) {\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            ${\n        adjustHeight ? `f32(uniforms.xShape.y) - 1.0` :\n                       `f32(uniforms.xShape.y)`},\n            ${\n        adjustWidth ? `f32(uniforms.xShape.z) - 1.0` :\n                      `f32(uniforms.xShape.z)`});\n\n          let effectiveOutSize = vec2<f32>(\n            ${\n        adjustHeight ? `f32(uniforms.outShape.y) - 1.0` :\n                       `f32(uniforms.outShape.y)`},\n            ${\n        adjustWidth ? `f32(uniforms.outShape.z) - 1.0` :\n                      `f32(uniforms.outShape.z)`});\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${\n        this.halfPixelCenters ?\n            '(vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC - vec2<f32>(0.5)' :\n            'vec2<f32>(rc) * effectiveInputOverOutputRatioRC'};\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<u32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<u32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutput(b, coords[1], coords[2], d, newValue);\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeBilinear, ResizeBilinearAttrs, ResizeBilinearInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {ResizeBilinearProgram} from './resize_bilinear_webgpu';\n\nexport function resizeBilinear(args: {\n  inputs: ResizeBilinearInputs,\n  backend: WebGPUBackend,\n  attrs: ResizeBilinearAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images} = inputs;\n  const {alignCorners, size, halfPixelCenters} = attrs;\n\n  const [newHeight, newWidth] = size;\n  const program = new ResizeBilinearProgram(\n      images.shape as [number, number, number, number], newHeight, newWidth,\n      alignCorners, halfPixelCenters);\n\n  return backend.runWebGPUProgram(program, [images], 'float32');\n}\n\nexport const resizeBilinearConfig: KernelConfig = {\n  kernelName: ResizeBilinear,\n  backendName: 'webgpu',\n  kernelFunc: resizeBilinear as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class ResizeNearestNeighborProgram implements WebGPUProgram {\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  variableNames = ['x'];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  alignCorners: boolean;\n  halfPixelCenters: boolean;\n  useWgsl: boolean;\n\n  constructor(\n      inputShape: [number, number, number, number], newHeight: number,\n      newWidth: number, alignCorners: boolean, halfPixelCenters: boolean) {\n    this.outputShape = [inputShape[0], newHeight, newWidth, inputShape[3]];\n\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.alignCorners = alignCorners;\n    this.halfPixelCenters = halfPixelCenters;\n    this.shaderKey =\n        `resizeNearest_${alignCorners}_${this.outputShape[1] > 1}_${\n            this.outputShape[2] > 1}_${halfPixelCenters}`;\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = this.alignCorners ? '0.5' : '0.0';\n    let sourceFracIndexRC: string;\n    if (this.halfPixelCenters) {\n      sourceFracIndexRC =\n          `max((vec2(rc) + vec2(0.5)) * effectiveInputOverOutputRatioRC` +\n          `, vec2(0.0))`;\n    } else {\n      sourceFracIndexRC = `vec2(rc) * effectiveInputOverOutputRatioRC`;\n    }\n\n    const adjustHeight = this.alignCorners && this.outputShape[1] > 1;\n    const adjustWidth = this.alignCorners && this.outputShape[2] > 1;\n\n    const userCode = `\n      void main() {\n        ivec4 coords = getOutputCoords();\n        if (all(lessThan(coords, outShape))) {\n          int b = coords[0];\n          int d = coords[3];\n          ivec2 rc = coords.yz;\n\n          vec2 effectiveInSize = vec2(\n            ${adjustHeight ? `xShape.y - 1.0` : `xShape.y`},\n            ${adjustWidth ? `xShape.z - 1.0` : `xShape.z`});\n\n          vec2 effectiveOutSize = vec2(\n            ${adjustHeight ? `outShape.y - 1.0` : `outShape.y`},\n            ${adjustWidth ? `outShape.z - 1.0` : `outShape.z`});\n\n          vec2 effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          vec2 sourceFracIndexRC = ${sourceFracIndexRC};\n\n          // Compute the coordinators of nearest neighbor point.\n          const vec2 inputShapeRC = vec2(xShape.y, xShape.z);\n          ivec2 sourceNearestRC = ivec2(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n          float newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutput(b, coords[1], coords[2], d, newValue);\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    // When align corners is false, we rounds the value with floor.\n    const roundBase = this.alignCorners ? '0.5' : '0.0';\n    let sourceFracIndexRC: string;\n    if (this.halfPixelCenters) {\n      sourceFracIndexRC =\n          `max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC` +\n          `, vec2<f32>(0.0))`;\n    } else {\n      sourceFracIndexRC = `vec2<f32>(rc) * effectiveInputOverOutputRatioRC`;\n    }\n\n    const adjustHeight = this.alignCorners && this.outputShape[1] > 1;\n    const adjustWidth = this.alignCorners && this.outputShape[2] > 1;\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let coords = getOutputCoords(globalId, index);\n        if (all(coords < uniforms.outShape)) {\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            ${\n        adjustHeight ? `f32(uniforms.xShape.y) - 1.0` :\n                       `f32(uniforms.xShape.y)`},\n            ${\n        adjustWidth ? `f32(uniforms.xShape.z) - 1.0` :\n                      `f32(uniforms.xShape.z)`});\n\n          let effectiveOutSize = vec2<f32>(\n            ${\n        adjustHeight ? `f32(uniforms.outShape.y) - 1.0` :\n                       `f32(uniforms.outShape.y)`},\n            ${\n        adjustWidth ? `f32(uniforms.outShape.z) - 1.0` :\n                      `f32(uniforms.outShape.z)`});\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${sourceFracIndexRC};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<u32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${roundBase})));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutput(b, coords[1], coords[2], d, newValue);\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, ResizeNearestNeighbor, ResizeNearestNeighborAttrs, ResizeNearestNeighborInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {ResizeNearestNeighborProgram} from './resize_nearest_neighbor_webgpu';\n\nexport function resizeNearestNeighbor(args: {\n  inputs: ResizeNearestNeighborInputs,\n  backend: WebGPUBackend,\n  attrs: ResizeNearestNeighborAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {images} = inputs;\n  const {alignCorners, halfPixelCenters, size} = attrs;\n\n  const [newHeight, newWidth] = size;\n\n  const program = new ResizeNearestNeighborProgram(\n      images.shape as [number, number, number, number], newHeight, newWidth,\n      alignCorners, halfPixelCenters);\n  return backend.runWebGPUProgram(program, [images], images.dtype);\n}\n\nexport const resizeNearestNeighborConfig: KernelConfig = {\n  kernelName: ResizeNearestNeighbor,\n  backendName: 'webgpu',\n  kernelFunc: resizeNearestNeighbor as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Rsqrt} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {rsqrtImplCPU} from '../kernel_utils/shared';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const rsqrt =\n    unaryKernelFunc({opType: UnaryOpType.RSQRT, cpuKernelImpl: rsqrtImplCPU});\n\nexport const rsqrtConfig: KernelConfig = {\n  kernelName: Rsqrt,\n  backendName: 'webgpu',\n  kernelFunc: rsqrt\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class SelectProgram implements WebGPUProgram {\n  variableNames = ['c', 'a', 'b'];\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  cRank: number;\n  rank: number;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(cRank: number, shape: number[], rank: number) {\n    this.outputShape = shape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n\n    this.cRank = cRank;\n    this.rank = rank;\n    this.shaderKey = 'select';\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    let cCoords;\n    let abCoords;\n    if (this.rank > 4) {\n      throw Error(`Where for rank ${this.rank} is not yet supported`);\n    }\n\n    if (this.rank === 1) {\n      abCoords = `resRC`;\n      cCoords = `resRC`;\n    } else {\n      const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n      const cCoordVars = [];\n      const abCoordVars = [];\n      for (let i = 0; i < this.outputShape.length; i++) {\n        abCoordVars.push(`${currentCoords[i]}`);\n        if (i < this.cRank) {\n          cCoordVars.push(`${currentCoords[i]}`);\n        }\n      }\n      cCoords = cCoordVars.join();\n      abCoords = abCoordVars.join();\n    }\n\n    const dtype = getCoordsDataType(this.rank);\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n        if (index < size) {\n          ${dtype} resRC = getOutputCoords();\n\n          float cVal = getC(${cCoords});\n          if (cVal >= 1.0) {\n            setOutput(index, getA(${abCoords}));\n          } else {\n            setOutput(index, getB(${abCoords}));\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    // TODO(WGSL): below code can be merged with getUserCode.\n    let cCoords;\n    let abCoords;\n    if (this.rank > 4) {\n      throw Error(`Where for rank ${this.rank} is not yet supported`);\n    }\n\n    if (this.rank === 1) {\n      abCoords = `resRC`;\n      cCoords = `resRC`;\n    } else {\n      const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n      const cCoordVars = [];\n      const abCoordVars = [];\n      for (let i = 0; i < this.outputShape.length; i++) {\n        abCoordVars.push(`${currentCoords[i]}`);\n        if (i < this.cRank) {\n          cCoordVars.push(`${currentCoords[i]}`);\n        }\n      }\n      cCoords = cCoordVars.join();\n      abCoords = abCoordVars.join();\n    }\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if (index < uniforms.size) {\n          let resRC = getOutputCoords(globalId, index);\n          let cVal = getC(${cCoords});\n          if (cVal >= 1.0) {\n            setOutputFlat(index, getA(${abCoords}));\n          } else {\n            setOutputFlat(index, getB(${abCoords}));\n          }\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, Select, SelectInputs, TensorInfo, upcastType} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {SelectProgram} from './select_webgpu';\n\nexport function select(args: {inputs: SelectInputs, backend: WebGPUBackend}):\n    TensorInfo {\n  const {inputs, backend} = args;\n  const {condition, t, e} = inputs;\n\n  const program =\n      new SelectProgram(condition.shape.length, t.shape, t.shape.length);\n  return backend.runWebGPUProgram(\n      program, [condition, t, e], upcastType(t.dtype, e.dtype));\n}\n\nexport const selectConfig: KernelConfig = {\n  kernelName: Select,\n  backendName: 'webgpu',\n  kernelFunc: select as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sigmoid} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const sigmoid = unaryKernelFunc({opType: UnaryOpType.SIGMOID});\n\nexport const sigmoidConfig: KernelConfig = {\n  kernelName: Sigmoid,\n  backendName: 'webgpu',\n  kernelFunc: sigmoid,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sub} from '@tensorflow/tfjs-core';\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {subImplCPU as cpuSub} from '../kernel_utils/shared';\nimport {BinaryOpType} from './binary_op_util';\n\nexport const sub = binaryKernelFunc({\n  opSnippet: BinaryOpType.SUB,\n  cpuKernelImpl: cpuSub,\n  supportsComplex: true\n});\n\nexport const subConfig: KernelConfig = {\n  kernelName: Sub,\n  backendName: 'webgpu',\n  kernelFunc: sub\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, Softmax, SoftmaxAttrs, SoftmaxInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {exp} from './Exp';\nimport {max} from './Max';\nimport {realDiv} from './RealDiv';\nimport {reshape} from './Reshape';\nimport {sub} from './Sub';\nimport {sum} from './Sum';\n\nexport function softmax(\n    args: {inputs: SoftmaxInputs, backend: WebGPUBackend, attrs: SoftmaxAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {logits} = inputs;\n  const {dim} = attrs;\n\n  const axes = util.parseAxisParam([dim], logits.shape);\n\n  const maxLogit = max({\n    inputs: {x: logits},\n    backend,\n    attrs: {reductionIndices: axes, keepDims: false}\n  });\n\n  const expandedShape = backend_util.expandShapeToKeepDim(maxLogit.shape, axes);\n\n  const maxLogitsReshaped =\n      reshape({inputs: {x: maxLogit}, backend, attrs: {shape: expandedShape}});\n  const a =\n      sub({inputs: {a: logits, b: maxLogitsReshaped}, backend}) as TensorInfo;\n  const b = exp({inputs: {x: a}, backend}) as TensorInfo;\n  const sumExp =\n      sum({inputs: {x: b}, backend, attrs: {axis: axes, keepDims: false}});\n  const sumExpReshaped =\n      reshape({inputs: {x: sumExp}, backend, attrs: {shape: expandedShape}});\n  const res =\n      realDiv({inputs: {a: b, b: sumExpReshaped}, backend}) as TensorInfo;\n\n  backend.disposeData(maxLogit.dataId);\n  backend.disposeData(maxLogitsReshaped.dataId);\n  backend.disposeData(a.dataId);\n  backend.disposeData(b.dataId);\n  backend.disposeData(sumExp.dataId);\n  backend.disposeData(sumExpReshaped.dataId);\n\n  return res;\n}\n\nexport const softmaxConfig: KernelConfig = {\n  kernelName: Softmax,\n  backendName: 'webgpu',\n  kernelFunc: softmax as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, KernelConfig, KernelFunc, SpaceToBatchND, SpaceToBatchNDAttrs, SpaceToBatchNDInputs, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {padV2} from './PadV2';\nimport {reshape} from './Reshape';\nimport {transpose} from './Transpose';\n\nexport const spaceToBatchND = (args: {\n  inputs: SpaceToBatchNDInputs,\n  backend: WebGPUBackend,\n  attrs: SpaceToBatchNDAttrs\n}): TensorInfo => {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {blockShape, paddings} = attrs;\n\n  util.assert(\n      x.shape.length <= 4,\n      () => 'spaceToBatchND for rank > 4 with a WebGPU backend not ' +\n          'implemented yet');\n\n  const prod = blockShape.reduce((a, b) => a * b);\n\n  const completePaddings: Array<[number, number]> = [[0, 0]];\n  completePaddings.push(...paddings as Array<[number, number]>);\n  for (let i = 1 + blockShape.length; i < x.shape.length; ++i) {\n    completePaddings.push([0, 0]);\n  }\n\n  const toDispose = [];\n\n  const paddedX = padV2({\n    inputs: {x},\n    backend,\n    attrs: {paddings: completePaddings, constantValue: 0}\n  });\n\n  const reshapedPaddedShape =\n      backend_util.getReshaped(paddedX.shape, blockShape, prod, false);\n\n  const permutedReshapedPaddedPermutation = backend_util.getPermuted(\n      reshapedPaddedShape.length, blockShape.length, false);\n\n  const flattenShape =\n      backend_util.getReshapedPermuted(paddedX.shape, blockShape, prod, false);\n\n  const reshapedPaddedX = reshape(\n      {inputs: {x: paddedX}, backend, attrs: {shape: reshapedPaddedShape}});\n\n  const paddedXT = transpose({\n    inputs: {x: reshapedPaddedX},\n    backend,\n    attrs: {perm: permutedReshapedPaddedPermutation}\n  });\n\n  const result =\n      reshape({inputs: {x: paddedXT}, backend, attrs: {shape: flattenShape}});\n\n  toDispose.push(paddedX);\n  toDispose.push(reshapedPaddedX);\n  toDispose.push(paddedXT);\n\n  toDispose.forEach(t => backend.disposeData(t.dataId));\n\n  return result;\n};\n\nexport const spaceToBatchNDConfig: KernelConfig = {\n  kernelName: SpaceToBatchND,\n  backendName: 'webgpu',\n  kernelFunc: spaceToBatchND as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Sqrt} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const sqrt = unaryKernelFunc({opType: UnaryOpType.SQRT});\n\nexport const sqrtConfig: KernelConfig = {\n  kernelName: Sqrt,\n  backendName: 'webgpu',\n  kernelFunc: sqrt\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Square, SquareInputs} from '@tensorflow/tfjs-core';\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {UnaryOpProgram} from './unary_op_webgpu';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const squareConfig: KernelConfig = {\n  kernelName: Square,\n  backendName: 'webgpu',\n  kernelFunc: ({inputs, backend}) => {\n    const {x} = inputs as SquareInputs;\n    const webGPUBackend = backend as WebGPUBackend;\n    const program = new UnaryOpProgram(x.shape, UnaryOpType.SQUARE);\n    return webGPUBackend.runWebGPUProgram(program, [x], x.dtype);\n  }\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, SquaredDifference} from '@tensorflow/tfjs-core';\n\nimport {binaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\n\nimport {BinaryOpType} from './binary_op_util';\n\nexport const squaredDifference = binaryKernelFunc({\n  opSnippet: BinaryOpType.SQUARED_DIFFERENCE,\n});\n\nexport const squaredDifferenceConfig: KernelConfig = {\n  kernelName: SquaredDifference,\n  backendName: 'webgpu',\n  kernelFunc: squaredDifference\n};\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getCoordsDataTypeWgsl, getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class StridedSliceProgram implements WebGPUProgram {\n  variableNames = ['x'];\n  uniforms: string;\n  uniformsWgsl: string;\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  // TODO(xing.xu): Increase the workPerThread.\n  workPerThread = 1;\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  dtype: string;\n  dtypeWgsl: string;\n  size: number;\n  useWgsl: boolean;\n\n  constructor(destSize: number[]) {\n    this.outputShape = destSize;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n\n    this.dtype = getCoordsDataType(this.outputShape.length);\n    this.dtypeWgsl = getCoordsDataTypeWgsl(this.outputShape.length);\n    this.uniforms = `${this.dtype} begin; ${this.dtype} strides; `;\n    this.uniformsWgsl =\n        `begin : ${this.dtypeWgsl};  strides : ${this.dtypeWgsl}; `;\n    this.shaderKey = 'stridedSlice';\n    this.size = util.sizeFromShape(this.outputShape);\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const rank = this.outputShape.length;\n    let newCoords = '';\n    if (rank === 1) {\n      newCoords = 'coords * strides + begin';\n    } else {\n      let outputAxis = 0;\n      newCoords =\n          this.outputShape\n              .map((_, i) => {\n                outputAxis++;\n                return this.outputShape.length === 1 ?\n                    `coords * strides[${i}] + begin[${i}]` :\n                    `coords[${outputAxis - 1}] * strides[${i}] + begin[${i}]`;\n              })\n              .join(',');\n    }\n\n    const userCode = `\n       void main() {\n         int index = getGlobalIndex();\n         if (index < size)\n         {\n           ${this.dtype} coords = getOutputCoords();\n           setOutput(index, getX(${newCoords}));\n         }\n       }\n     `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const rank = this.outputShape.length;\n    let newCoords = '';\n    if (rank === 1) {\n      newCoords = 'coords * uniforms.strides + uniforms.begin';\n    } else {\n      let outputAxis = 0;\n      newCoords =\n          this.outputShape\n              .map((_, i) => {\n                outputAxis++;\n                return this.outputShape.length === 1 ?\n                    `coords * uniforms.strides[${i}] + uniforms.begin[${i}]` :\n                    `coords[${outputAxis - 1}] * uniforms.strides[${\n                        i}] + uniforms.begin[${i}]`;\n              })\n              .join(',');\n    }\n\n    const userCode = `\n       ${getMainHeaderStringWgsl()} {\n         ${getGlobalIndexStringWgsl()}\n         if (index < uniforms.size)\n         {\n           let coords = getOutputCoords(globalId, index);\n           setOutputFlat(index, getX(${newCoords}));\n         }\n       }\n     `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, KernelConfig, KernelFunc, Rank, slice_util, StridedSlice, StridedSliceAttrs, StridedSliceInputs, TensorBuffer, TensorInfo, TypedArray} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {stridedSliceImplCPU} from '../kernel_utils/shared';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\nimport {StridedSliceProgram} from './strided_slice_webgpu';\n\nexport function stridedSlice(args: {\n  inputs: StridedSliceInputs,\n  backend: WebGPUBackend,\n  attrs: StridedSliceAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x} = inputs;\n  const {\n    begin,\n    end,\n    strides,\n    beginMask,\n    endMask,\n    ellipsisMask,\n    newAxisMask,\n    shrinkAxisMask\n  } = attrs;\n\n  const {nonStrided, $begin, $strides, size, newShape, outShape} =\n      slice_util.sliceInfo(\n          x.shape, begin, end, strides, beginMask, endMask, ellipsisMask,\n          newAxisMask, shrinkAxisMask);\n\n  const $x = reshape({inputs: {x}, backend, attrs: {shape: newShape}});\n\n  let result;\n  if (nonStrided) {\n    const sliced =\n        slice({inputs: {x: $x}, backend, attrs: {begin: $begin, size}});\n    result = reshape({inputs: {x: sliced}, backend, attrs: {shape: outShape}});\n    backend.disposeData(sliced.dataId);\n\n  } else if (outShape.some(axis => axis === 0)) {\n    result = backend.makeTensorInfo(outShape, x.dtype, []);\n  } else {\n    const shouldExecuteOnCPU = backend.shouldExecuteOnCPU([$x]);\n    if (shouldExecuteOnCPU) {\n      const xBufferInfo = backend.tensorMap.get($x.dataId);\n      const values = xBufferInfo.values as TypedArray;\n      const xBuf = buffer($x.shape, $x.dtype, values) as TensorBuffer<Rank>;\n      const resultValues =\n          stridedSliceImplCPU(outShape, xBuf, $strides, $begin);\n      result = backend.makeTensorInfo(outShape, $x.dtype, resultValues.values);\n    } else {\n      const program = new StridedSliceProgram(outShape);\n      const uniformData =\n          [{type: 'int32', data: $begin}, {type: 'int32', data: $strides}];\n      result = backend.runWebGPUProgram(program, [$x], $x.dtype, uniformData);\n    }\n  }\n\n  const resultReshaped =\n      reshape({inputs: {x: result}, backend, attrs: {shape: outShape}});\n\n  backend.disposeData($x.dataId);\n  backend.disposeData(result.dataId);\n\n  return resultReshaped;\n}\n\nexport const stridedSliceConfig: KernelConfig = {\n  kernelName: StridedSlice,\n  backendName: 'webgpu',\n  kernelFunc: stridedSlice as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, StringNGrams, StringNGramsAttrs, StringNGramsInputs, TensorInfo} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {stringNGramsImplCPU} from '../kernel_utils/shared';\n\nexport function stringNGrams(args: {\n  inputs: StringNGramsInputs,\n  backend: WebGPUBackend,\n  attrs: StringNGramsAttrs\n}): [TensorInfo, TensorInfo] {\n  const {inputs, backend, attrs} = args;\n  const {\n    separator,\n    nGramWidths,\n    leftPad,\n    rightPad,\n    padWidth,\n    preserveShortSequences\n  } = attrs;\n  const {data, dataSplits} = inputs;\n  const $data = backend.readSync(data.dataId) as Uint8Array[];\n  const $dataSplits = backend.readSync(dataSplits.dataId) as Int32Array;\n\n  const [nGrams, nGramsSplits] = stringNGramsImplCPU(\n      $data, $dataSplits, separator, nGramWidths, leftPad, rightPad, padWidth,\n      preserveShortSequences);\n  return [\n    backend.makeTensorInfo([nGrams.length], 'string', nGrams),\n    backend.makeTensorInfo(dataSplits.shape, 'int32', nGramsSplits),\n  ];\n}\n\nexport const stringNGramsConfig: KernelConfig = {\n  kernelName: StringNGrams,\n  backendName: 'webgpu',\n  kernelFunc: stringNGrams as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, Tanh} from '@tensorflow/tfjs-core';\nimport {unaryKernelFunc} from '../kernel_utils/kernel_funcs_utils';\nimport {UnaryOpType} from './unary_op_util';\n\nexport const tanh = unaryKernelFunc({opType: UnaryOpType.TANH});\n\nexport const tanhConfig: KernelConfig = {\n  kernelName: Tanh,\n  backendName: 'webgpu',\n  kernelFunc: tanh\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {util} from '@tensorflow/tfjs-core';\n\nimport {getCoordsDataType} from '../shader_preprocessor';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class TileProgram implements WebGPUProgram {\n  variableNames = ['A'];\n  outputShape: number[];\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  dtype: string;\n  size: number;\n  rank: number;\n  useWgsl: boolean;\n\n  constructor(aShape: number[], reps: number[]) {\n    const outputShape: number[] = new Array(aShape.length);\n    for (let i = 0; i < outputShape.length; i++) {\n      outputShape[i] = aShape[i] * reps[i];\n    }\n    this.outputShape = outputShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n    this.rank = this.outputShape.length;\n    this.size = util.sizeFromShape(this.outputShape);\n    this.shaderKey = 'tile';\n    this.useWgsl = getUseWgsl();\n  }\n\n  getUserCode(): string {\n    const dtype = getCoordsDataType(this.rank);\n    const sourceCoords = getSourceCoords(this.rank);\n\n    const userCode = `\n      void main() {\n        int index = getGlobalIndex();\n        if (index < size) {\n          ${dtype} resRC = getOutputCoords();\n          setOutput(index, getA(${sourceCoords}));\n        }\n      }\n    `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const sourceCoords = getSourceCoords(this.rank, 'uniforms.');\n\n    const userCode = `\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        if (index < uniforms.size) {\n          let resRC = getOutputCoords(globalId, index);\n          setOutputFlat(index, getA(${sourceCoords}));\n        }\n      }\n    `;\n    return userCode;\n  }\n}\n\nfunction getSourceCoords(rank: number, uniformPrefix = ''): string {\n  if (rank >= 5) {\n    throw Error(`Tile for rank ${rank} is not yet supported`);\n  }\n  if (rank === 1) {\n    return `(resRC % ${uniformPrefix}aShape)`;\n  }\n\n  const currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];\n  const sourceCoords = [];\n  for (let i = 0; i < rank; i++) {\n    sourceCoords.push(`(${currentCoords[i]} % ${uniformPrefix}aShape[${i}])`);\n  }\n  return sourceCoords.join();\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {buffer, KernelConfig, KernelFunc, TensorInfo, Tile, TileAttrs, TileInputs, TypedArray, util} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {tileImplCPU} from '../kernel_utils/shared';\nimport {TileProgram} from './tile_webgpu';\n\nexport function tile(\n    params: {inputs: TileInputs, backend: WebGPUBackend, attrs: TileAttrs}):\n    TensorInfo {\n  const {inputs, backend, attrs} = params;\n  const {x} = inputs;\n  const {reps} = attrs;\n\n  // tile gpu program cannot handle rank >= 5 case.\n  if (backend.shouldExecuteOnCPU([x]) || x.dtype === 'string' ||\n      x.shape.length >= 5) {\n    // Even thought string tensor is always on CPU, just to be consistent on how\n    // to access tensor data.\n    const data = backend.readSync(x.dataId);\n    const value = x.dtype === 'string' ?\n        (data as Uint8Array[]).map(d => util.decodeString(d)) :\n        data as TypedArray;\n    const buf = buffer(x.shape, x.dtype, value);\n    const outBuf = tileImplCPU(buf, reps);\n    return backend.makeTensorInfo(outBuf.shape, outBuf.dtype, outBuf.values);\n  }\n\n  const program = new TileProgram(x.shape, reps);\n  const output = backend.runWebGPUProgram(program, [x], x.dtype);\n\n  return output;\n}\n\nexport const tileConfig: KernelConfig = {\n  kernelName: Tile,\n  backendName: 'webgpu',\n  kernelFunc: tile as {} as KernelFunc,\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../shader_preprocessor_wgsl';\nimport {computeDispatch, flatDispatchLayout} from '../webgpu_util';\n\nimport {getUseWgsl, WebGPUProgram} from './webgpu_program';\n\nexport class TransformProgram implements WebGPUProgram {\n  variableNames = ['Image', 'Transforms'];\n  outputShape: number[];\n  uniforms = 'int interpolationModeId; int fillModeId; float fillValue;';\n  uniformsWgsl =\n      'interpolationModeId : i32; fillModeId : i32; fillValue : f32;';\n  shaderKey: string;\n  dispatchLayout: {x: number[]};\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number] = [64, 1, 1];\n  useWgsl: boolean;\n\n  constructor(outShape: [number, number, number, number]) {\n    this.outputShape = outShape;\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize);\n    this.shaderKey = 'transform';\n    this.useWgsl = getUseWgsl();\n  }\n  getUserCode(): string {\n    const userCode = `\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(fillModeId == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (fillModeId == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (fillModeId == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < imageShape[1] && 0 <= coordX && coordX < imageShape[2]) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = fillValue;\n              }\n              return outputValue;\n            }\n\n          void main() {\n            ivec4 coords = getOutputCoords();\n            if (coordsInBounds(coords, outShape)) {\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = fillValue;\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(imageShape[2]));\n                float mapY = mapCoord(inY, float(imageShape[1]));\n\n                if (interpolationModeId == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(coords[0], coords[1], coords[2], coords[3], outputValue);\n            }\n          }\n        `;\n    return userCode;\n  }\n\n  getUserCodeWgsl(): string {\n    const userCode = `\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } elseif (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } elseif (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } elseif (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } elseif (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < i32(uniforms.imageShape[1]) && 0 <= coordX && coordX < i32(uniforms.imageShape[2])) {\n                outputValue = getImage(u32(batch), u32(coordY), u32(coordX), u32(channel));\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${getMainHeaderStringWgsl()} {\n            ${getGlobalIndexStringWgsl()}\n            let coords = getOutputCoords(globalId, index);\n            if (coordsInBounds4D(coords, uniforms.outShape)) {\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0u);\n              let a2 = getTransforms(batch, 1u);\n              let a3 = getTransforms(batch, 2u);\n              let b1 = getTransforms(batch, 3u);\n              let b2 = getTransforms(batch, 4u);\n              let b3 = getTransforms(batch, 5u);\n              let c1 = getTransforms(batch, 6u);\n              let c2 = getTransforms(batch, 7u);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(i32(batch), coordY, coordX,\n                    i32(channel));\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(i32(batch), i32(yFloor), i32(xFloor), i32(channel)) +\n                  (mapX - xFloor) *\n                  readWithFillValue(i32(batch), i32(yFloor), i32(xCeil), i32(channel));\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(i32(batch), i32(yCeil), i32(xFloor), i32(channel)) +\n                  (mapX - xFloor) *\n                  readWithFillValue(i32(batch), i32(yCeil), i32(xCeil), i32(channel));\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(coords[0], coords[1], coords[2], coords[3], outputValue);\n            }\n          }\n        `;\n    return userCode;\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Transform, TransformAttrs, TransformInputs} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\nimport {TransformProgram} from './transform_webgpu';\n\nexport function transform(args: {\n  inputs: TransformInputs,\n  backend: WebGPUBackend,\n  attrs: TransformAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {image, transforms} = inputs;\n  const {interpolation, fillMode, fillValue, outputShape} = attrs;\n\n  const [batch, imageHeight, imageWidth, numChannels] = image.shape;\n  const [outHeight, outWidth] =\n      outputShape != null ? outputShape : [imageHeight, imageWidth];\n  const outShape =\n      [batch, outHeight, outWidth,\n       numChannels] as [number, number, number, number];\n\n  const program = new TransformProgram(outShape);\n  const interpolationModeId = interpolation === 'nearest' ? 1 : 2;\n  let fillModeId: number;\n  switch (fillMode) {\n    case 'constant':\n      fillModeId = 1;\n      break;\n    case 'reflect':\n      fillModeId = 2;\n      break;\n    case 'wrap':\n      fillModeId = 3;\n      break;\n    case 'nearest':\n      fillModeId = 4;\n      break;\n    default:\n      fillModeId = 1;\n      break;\n  }\n  const uniformData = [\n    {type: 'int32', data: [interpolationModeId]},\n    {type: 'int32', data: [fillModeId]}, {type: 'float32', data: [fillValue]}\n  ];\n  return backend.runWebGPUProgram(\n      program, [image, transforms], 'float32', uniformData);\n}\n\nexport const transformConfig: KernelConfig = {\n  kernelName: Transform,\n  backendName: 'webgpu',\n  kernelFunc: transform as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {KernelConfig, KernelFunc, TensorInfo, Unpack, UnpackAttrs, UnpackInputs} from '@tensorflow/tfjs-core';\n\nimport {WebGPUBackend} from '../backend_webgpu';\n\nimport {reshape} from './Reshape';\nimport {slice} from './Slice';\n\nexport function unpack(\n    args:\n        {inputs: UnpackInputs, backend: WebGPUBackend, attrs: UnpackAttrs}):\n    TensorInfo[] {\n  const {inputs, backend, attrs} = args;\n  const {value} = inputs;\n  let {axis} = attrs;\n\n  if (axis < 0) {\n    axis += value.shape.length;\n  }\n\n  const x = value;\n  const xRank = x.shape.length;\n\n  const num = value.shape[axis];\n  const outShape: number[] = new Array(xRank - 1);\n  let outIndex = 0;\n  for (let i = 0; i < xRank; i++) {\n    if (i !== axis) {\n      outShape[outIndex++] = x.shape[i];\n    }\n  }\n\n  const toDispose = [];\n\n  const begin = new Array(xRank).fill(0);\n  const size = x.shape.slice();\n  size[axis] = 1;\n  const res: TensorInfo[] = new Array(num);\n  for (let i = 0; i < res.length; i++) {\n    begin[axis] = i;\n    const sliced = slice({inputs: {x}, backend, attrs: {begin, size}});\n    const reshaped =\n        reshape({inputs: {x: sliced}, backend, attrs: {shape: outShape}});\n    res[i] = reshaped;\n\n    toDispose.push(sliced);\n  }\n\n  toDispose.forEach(t => backend.disposeData(t.dataId));\n  return res;\n}\n\nexport const unpackConfig: KernelConfig = {\n  kernelName: Unpack,\n  backendName: 'webgpu',\n  kernelFunc: unpack as {} as KernelFunc\n};\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {KernelConfig, registerKernel} from '@tensorflow/tfjs-core';\n\nimport {_fusedMatMulConfig} from './kernels/_FusedMatMul';\nimport {absConfig} from './kernels/Abs';\nimport {addConfig} from './kernels/Add';\nimport {addNConfig} from './kernels/AddN';\nimport {argMaxConfig} from './kernels/ArgMax';\nimport {argMinConfig} from './kernels/ArgMin';\nimport {avgPoolConfig} from './kernels/AvgPool';\nimport {batchMatMulConfig} from './kernels/BatchMatMul';\nimport {batchToSpaceNDConfig} from './kernels/BatchToSpaceND';\nimport {castConfig} from './kernels/Cast';\nimport {ceilConfig} from './kernels/Ceil';\nimport {clipByValueConfig} from './kernels/ClipByValue';\nimport {complexConfig} from './kernels/Complex';\nimport {concatConfig} from './kernels/Concat';\nimport {conv2DConfig} from './kernels/Conv2D';\nimport {conv2DBackpropInputConfig} from './kernels/Conv2DBackpropInput';\nimport {cropAndResizeConfig} from './kernels/CropAndResize';\nimport {depthwiseConv2dNativeConfig} from './kernels/DepthwiseConv2dNative';\nimport {einsumConfig} from './kernels/Einsum';\nimport {eluConfig} from './kernels/Elu';\nimport {equalConfig} from './kernels/Equal';\nimport {expConfig} from './kernels/Exp';\nimport {expandDimsConfig} from './kernels/ExpandDims';\nimport {expm1Config} from './kernels/Expm1';\nimport {fillConfig} from './kernels/Fill';\nimport {floorConfig} from './kernels/Floor';\nimport {floorDivConfig} from './kernels/FloorDiv';\nimport {fromPixelsConfig} from './kernels/FromPixels';\nimport {fusedBatchNormConfig} from './kernels/FusedBatchNorm';\nimport {fusedConv2DConfig} from './kernels/FusedConv2D';\nimport {fusedDepthwiseConv2DConfig} from './kernels/FusedDepthwiseConv2D';\nimport {gatherNdConfig} from './kernels/GatherNd';\nimport {gatherV2Config} from './kernels/GatherV2';\nimport {greaterConfig} from './kernels/Greater';\nimport {greaterEqualConfig} from './kernels/GreaterEqual';\nimport {identityConfig} from './kernels/Identity';\nimport {imagConfig} from './kernels/Imag';\nimport {lessConfig} from './kernels/Less';\nimport {lessEqualConfig} from './kernels/LessEqual';\nimport {logConfig} from './kernels/Log';\nimport {logicalAndConfig} from './kernels/LogicalAnd';\nimport {maxConfig} from './kernels/Max';\nimport {maximumConfig} from './kernels/Maximum';\nimport {maxPoolConfig} from './kernels/MaxPool';\nimport {meanConfig} from './kernels/Mean';\nimport {minConfig} from './kernels/Min';\nimport {minimumConfig} from './kernels/Minimum';\nimport {mirrorPadConfig} from './kernels/MirrorPad';\nimport {multiplyConfig} from './kernels/Multiply';\nimport {negConfig} from './kernels/Neg';\nimport {nonMaxSuppressionV3Config} from './kernels/NonMaxSuppressionV3';\nimport {nonMaxSuppressionV5Config} from './kernels/NonMaxSuppressionV5';\nimport {notEqualConfig} from './kernels/NotEqual';\nimport {onesLikeConfig} from './kernels/OnesLike';\nimport {packConfig} from './kernels/Pack';\nimport {padV2Config} from './kernels/PadV2';\nimport {powConfig} from './kernels/Pow';\nimport {preluConfig} from './kernels/Prelu';\nimport {prodConfig} from './kernels/Prod';\nimport {rangeConfig} from './kernels/Range';\nimport {realConfig} from './kernels/Real';\nimport {realDivConfig} from './kernels/RealDiv';\nimport {reluConfig} from './kernels/Relu';\nimport {relu6Config} from './kernels/Relu6';\nimport {reshapeConfig} from './kernels/Reshape';\nimport {resizeBilinearConfig} from './kernels/ResizeBilinear';\nimport {resizeNearestNeighborConfig} from './kernels/ResizeNearestNeighbor';\nimport {rsqrtConfig} from './kernels/Rsqrt';\nimport {selectConfig} from './kernels/Select';\nimport {sigmoidConfig} from './kernels/Sigmoid';\nimport {sliceConfig} from './kernels/Slice';\nimport {softmaxConfig} from './kernels/Softmax';\nimport {spaceToBatchNDConfig} from './kernels/SpaceToBatchND';\nimport {sqrtConfig} from './kernels/Sqrt';\nimport {squareConfig} from './kernels/Square';\nimport {squaredDifferenceConfig} from './kernels/SquaredDifference';\nimport {stridedSliceConfig} from './kernels/StridedSlice';\nimport {stringNGramsConfig} from './kernels/StringNGrams';\nimport {subConfig} from './kernels/Sub';\nimport {sumConfig} from './kernels/Sum';\nimport {tanhConfig} from './kernels/Tanh';\nimport {tileConfig} from './kernels/Tile';\nimport {transformConfig} from './kernels/Transform';\nimport {transposeConfig} from './kernels/Transpose';\nimport {unpackConfig} from './kernels/Unpack';\nimport {zerosLikeConfig} from './kernels/ZerosLike';\n\n// List all kernel configs here\nconst kernelConfigs: KernelConfig[] = [\n  _fusedMatMulConfig,\n  absConfig,\n  addConfig,\n  addNConfig,\n  argMaxConfig,\n  argMinConfig,\n  avgPoolConfig,\n  batchMatMulConfig,\n  batchToSpaceNDConfig,\n  castConfig,\n  ceilConfig,\n  clipByValueConfig,\n  complexConfig,\n  concatConfig,\n  conv2DConfig,\n  conv2DBackpropInputConfig,\n  cropAndResizeConfig,\n  depthwiseConv2dNativeConfig,\n  einsumConfig,\n  eluConfig,\n  equalConfig,\n  expandDimsConfig,\n  expConfig,\n  expm1Config,\n  fillConfig,\n  fromPixelsConfig,\n  floorConfig,\n  floorDivConfig,\n  fusedBatchNormConfig,\n  fusedConv2DConfig,\n  fusedDepthwiseConv2DConfig,\n  gatherNdConfig,\n  gatherV2Config,\n  greaterConfig,\n  greaterEqualConfig,\n  identityConfig,\n  imagConfig,\n  lessConfig,\n  lessEqualConfig,\n  logConfig,\n  logicalAndConfig,\n  maxConfig,\n  maximumConfig,\n  maxPoolConfig,\n  meanConfig,\n  minConfig,\n  minimumConfig,\n  mirrorPadConfig,\n  multiplyConfig,\n  negConfig,\n  nonMaxSuppressionV3Config,\n  nonMaxSuppressionV5Config,\n  notEqualConfig,\n  onesLikeConfig,\n  packConfig,\n  padV2Config,\n  preluConfig,\n  prodConfig,\n  powConfig,\n  rangeConfig,\n  realConfig,\n  realDivConfig,\n  reluConfig,\n  relu6Config,\n  reshapeConfig,\n  resizeBilinearConfig,\n  resizeNearestNeighborConfig,\n  rsqrtConfig,\n  selectConfig,\n  sigmoidConfig,\n  sliceConfig,\n  stridedSliceConfig,\n  stringNGramsConfig,\n  softmaxConfig,\n  spaceToBatchNDConfig,\n  sqrtConfig,\n  squareConfig,\n  squaredDifferenceConfig,\n  subConfig,\n  sumConfig,\n  tanhConfig,\n  tileConfig,\n  transformConfig,\n  transposeConfig,\n  unpackConfig,\n  zerosLikeConfig\n];\n\nfor (const kernelConfig of kernelConfigs) {\n  registerKernel(kernelConfig);\n}\n", "const wasmuri = 'data:application/octet-stream;base64,AGFzbQEAAAABggRCYAN/f38Bf2AGf3x/f39/AX9gAn9/AGADf39/AGABfwF/YAJ/fwF/YAZ/f39/f38Bf2AFf39/f38Bf2ABfwBgBH9/f38Bf2AIf39/f39/f38Bf2AAAGAEf39/fwBgBn9/f39/fwBgBX9/f39/AGAHf39/f39/fwBgBX9/fn9/AGADf35/AX5gAnx/AXxgB39/f39/f38Bf2ACfn8Bf2ADfn9/AX9gAn9+AGAEf39/fgF+YAV/fn5+fgBgBH9+fn8AYAJ+fgF8YAN8fH8BfGABfAF8YAJ8fwF/YAJ8fAF8YAJ/fQBgAn98AGAEfn5+fgF/YAJ/fwF+YAJ+fgF9YAN/f34AYAR/f39/AX5gAn9/AX1gAn9/AXxgA39/fwF9YAN/f38BfGAKf39/f39/f39/fwF/YAx/f39/f39/f39/f38Bf2AFf39/f34Bf2AFf39/f3wBf2AGf39/f35+AX9gC39/f39/f39/f39/AX9gCn9/f39/f39/f38AYAd/f39/f35+AX9gD39/f39/f39/f39/f39/fwBgCH9/f39/f39/AGABfgF/YAR8f39/AX9gAXwBf2ACfHwBf2ADf3x/AGACf34Bf2ADf31/AX9gA398fwF/YAN/fn8Bf2AEf39+fwF/YAN/fn4AYAJ+fgF/YAABf2ALf39/f39/f39/f38AAokCGQNlbnYBYQADA2VudgFiAA4DZW52AWMACwNlbnYBZAAIA2VudgFlAAMDZW52AWYAAgNlbnYBZwAFDXdhc2lfdW5zdGFibGUBaAAFDXdhc2lfdW5zdGFibGUBaQAFA2VudgFqAAgNd2FzaV91bnN0YWJsZQFrAAkNd2FzaV91bnN0YWJsZQFsAAQNd2FzaV91bnN0YWJsZQFtAAcDZW52AW4AAANlbnYBbwAEA2VudgFwAAUDZW52AXEAAgNlbnYBcgADA2VudgFzAA4DZW52AXQAAgNlbnYBdQAHA2VudgF2AAUDZW52AXcABANlbnYGbWVtb3J5AgCAAgNlbnYFdGFibGUBcADdBgP1GfMZBQUFBQQFAwMEBAwDDAQFBAQEAgUEBAUNCQgFBQUFIAQEBAUEAgUEBAIABQQFBQgECBMCBQICAgQNAgkFBAUDDAQFAwQIDBYWBQQCBAUEAgICBQ4NBAICAAACCAICBAICDAIFBAQC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CAIEAAQCBQIECAMEAgQFBxweABwcPwAFBQQLCwsLCwsLCwsLCwsLCwseCwQEDQ0NDg4ODAwMBBwAAAsLJBYcAwMDAxwDAwMDAgICAg4JAAACAwgIAgwIAgkEBQAIBAgECAQIBAgECAQIBAgECAsECAsECAsECAsECAsECAsEAgICAgICBAQECAgABwYKBgoABwYKBgoECQcEBAcGCgcKCAcHAAkABQAFCAcACQAFBAUABQkJCQAIBQIIQAgIBQgLBQsLCwUMDA0NAAAGMQYxAAMTMBMAAxMwEwQABw0TABMEDg4ODQwODg4ODg4MCgYGBgYGDg4ODQwODg4ODg4MCgYGBgYGCAIIBEAMAwwEBAIMQAwFAAgICAMAAgIOAwACBAgJAgMMBQ4NAgIMQAcCBQICAgIuCAgICAIIAgICAActCQIFCCwIAgICAgYHAAkEBAwFLAQCBAUAAAICAggCCAIICAgICAUEBAwFAAgCAwIHBQUFDAwMBQIDAgUFAAwFBQAMBAICAgIICQcCAwICAgcMAgIMAgIuA0ACCQUCCAIMBQUDQAIJBQUADgwCAggNAgIFBwkHAgUKBQUEAwQELQgDAywCDAUFBwQRAAUsAAMMAgQGAAIDAwIDAwcEAggCAgIHCAgDMwUCAAgADgAEAAYJCQUCAgICAAgIBAAHBgUABQcACQQOAwMFBgcIAAYCBQMFAggIAggICAIIBwIJBQYDAgUFCAkFBwIOAggMDAYDAAUDBQwMBwAAAAACAggAAgIFAgcFBQIGDAwFAgAAAAcCCAgIBgMCAwIHAwwDAAIMBQUEBQUFAwIJAgIABQQHCAIIBgIICAgIBAUFBAwQCAMCAwQICAgCDAwDAwMDCAUFBQMCAgUCBQQDBggCCAgCCAgEBQgCCAMMCAQFAgwNEQUFBQQFBAQFCAICA0ACCQUIBQYCCQIFBAQFBQUFBQUFBwUFBQUFBQUGBAUFBQAFAAMDBQIHAwACAwIIBgMMBQUFBQIDAgUCCAcCAAQFDAAHDAUDCQICBgUHAwICBQUCAwUIBAICBwICAgIEAwwGAwMDAwADDAIDDAI0AgMAAwwHBAQEBAwMDAMMDAMDDAMMAwMDAAAFAgAABwAAAAAAAjgCAAYAAAADAwMDDAwMDAwMDAwMDAcMDAwMDAQEBAwDBgMDAwwCAwwABQUODgcODgMCAwwI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QdjiESAEIAdyNgIAIAEgAzYCACADIAM2AgwgAyABNgIYIAMgAzYCCAwBCyAAQQBBGSACQQF2ayACQR9GG3QhAiABKAIAIQECQANAIAEiBCgCBEF4cSAARg0BIAJBHXYhASACQQF0IQIgBCABQQRxaiIHQRBqKAIAIgENAAsgByADNgIQIAMgAzYCDCADIAQ2AhggAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtB9OIRQfTiESgCAEF/aiIANgIAIAANAEGc5hEhAwNAIAMoAgAiAEEIaiEDIAANAAtB9OIRQX82AgALCzoBAX8jAEEQayICJAAgAiABELMCNgIAIAJBCGogACABIAIQhxYgAkEIahBaIQAgAkEQaiQAIABBEGoLIgEBfyABEJwBIgIgABAmRgR/IABBfyABIAIQiQZFBUEACwsLACAAIAE2AgAgAAsKACAAIAFBA3RqCxAAIABBAjYCCCAAIAE5AwALCwAgAEH/AXFBAEcLCgAgABDlAxogAAsHACAAQQRqCygBAX8gASABQX9qIgJxRQRAIAAgAnEPCyAAIAFPBH8gACABcAUgAAsLBwAgAEEMagscAQF/IAAoAgAhAiAAIAEoAgA2AgAgASACNgIACw4AIAAoAhAgARAaKAIACw0AIABBpPsONgIAIAALBwAgAEEIRgs7AQF/IwBBEGsiAiQAIAIgATYCDCAAQRBqIAJBDGoQcCACQQE6AAsgAEEcaiACQQtqEMkKIAJBEGokAAuDBAEDfyACQYDAAE8EQCAAIAEgAhANGiAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIAJBAUgEQCAAIQIMAQsgAEEDcUUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA08NASACQQNxDQALCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiABKAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJBEAgACECDAELIANBfGoiBCAASQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAALJwEBfyMAQRBrIgIkACACIAE2AgwgACACQQxqENICIAJBEGokACAACxAAIAAoAgQgACgCAGtBFG0LPQEBfyMAQRBrIgIkACACIAEQswI2AgAgAkEIaiAAIAEoAgAgAhDyCiACKAIIECchACACQRBqJAAgAEEEagsKACAAIAFBFGxqCwwAIAAQ0AkgABDVAQsJACAAEDgoAgALCQAgAEEAEMgKC5EBACAAQaT7DjYCACAAQQA2AlAgAEIANwI8IABCADcCRCAAIAAoAgRBgICAfnEgBUEQdEGAgDxxIARBDHRBgOADcSADQQh0QYAecSABQf8BcXJyckGAgMAAQQAgBhtBACADQQFGG3JyNgIEIABBzABqEP4CIABBCGoQ/QIgACACQT9xrSAAKQIMQkCDhDcCDCAACzEBAX8jAEEgayICJAAgAkEIaiAAQSxqIAJBEGogARBoIgAQgAwgABAoGiACQSBqJAALBwAgACABcgsJACAAIAEQGRoLMQAgACgCBCAAECcoAgBJBEAgACgCBCABEJgBIAAgACgCBEEEajYCBA8LIAAgARCFCwsJACAAIAEQ0A8LDgAgABDlAiAAELUEIAALTQAgABD+AiAAIAAoAgBBgICgf3EgAUH/AXEgAkEIdEGA/gNxckGAgARBACADG3JBgIAIQQAgBBtyQYCAEEEAIAUbcnJBgIDAAHI2AgALOwEBfyMAQRBrIgIkACACIAE2AgwgAEEQaiACQQxqEHAgAkEAOgALIABBHGogAkELahDJCiACQRBqJAALOgAgACADNgIMIAAgAjYCCCAAIAE2AgQgAEHMwRE2AgAgAEEQahA3GiAAQRxqENUHGiAAQQA2AiggAAsJACAAEBsgAWoLCAAgAEHoAGoLbAECf0F/IQICQCAAKALAASAA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EJgZIAAgA0EIahDKBCADQRBqJAALEAAgAEF/IAEgARCcARCJBgsfACABRSACQf////8HRnJFBEAgACABIAJBfxB3CyABCwoAIAAoAgQQyQILDwAgACABEBsgARAmEPoGCyYBAX8jAEEQayIBJAAgAUEIaiAAEDgQMygCACEAIAFBEGokACAACwcAIABBfGoLMgEBfyAAKAIEIgIgABAnKAIARwRAIAIgARCYASAAIAAoAgRBBGo2AgQPCyAAIAEQrQwLDgAgACgCACABKAIAECULBwAgAEEUagsMACAAIAEtAAA6AAALDQAgAC0AAkEEcUECdgsxAQF/IwBBEGsiAyQAIAMgATYCDCAAIANBDGoQswMgACACKQIANwIEIANBEGokACAACzABAX8gASgCBCICIABBEGoiABAfTwRAIAAgAkEQahDhEQsgACgCACACEBogATYCAAueCwIFfw9+IwBB4ABrIgUkACAEQi+GIANCEYiEIQ8gAkIghiABQiCIhCENIARC////////P4MiDkIPhiADQjGIhCEQIAIgBIVCgICAgICAgICAf4MhCiAOQhGIIREgAkL///////8/gyILQiCIIRIgBEIwiKdB//8BcSEHAkACfyACQjCIp0H//wFxIglBf2pB/f8BTQRAQQAgB0F/akH+/wFJDQEaCyABUCACQv///////////wCDIgxCgICAgICAwP//AFQgDEKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgDEKAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAyEIQJCACEBIAJQBEBCgICAgICA4P//ACEKDAMLIApCgICAgICAwP//AIQhCgwCCyABIAyEUARAQgAhAQwCCyACIAOEUARAQgAhAQwCCyAMQv///////z9YBEAgBUHQAGogASALIAEgCyALUCIGG3kgBkEGdK18pyIGQXFqEIECIAUpA1giC0IghiAFKQNQIgFCIIiEIQ0gC0IgiCESQRAg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TgRAQQAhAANAIAEgAygCACAAEBoQcCAAQQFqIgAgAxAfSA0ACwsgAkEQaiQAC3EBA38jAEEQayIDJAAgAyABNgIMIAIEQCAAQThqIgQgBCABEGMgAhCwASEFQQAhASADEDchACACQQBKBEADQCAAIANBDGoQcCABQQFqIgEgAkcNAAsLIAQgBSAAQQAQ9AMhASAAEEULIANBEGokACABCwsAIAAgAUEBEO0HCxAAIAAoAhwgARAaKAIAEBsLMgEBfyAAKAIEIgIgABAnKAIASQRAIAIgARCYASAAIAAoAgRBBGo2AgQPCyAAIAEQrQwLDwAgAEKAgICAxgGDQgBSCyMAIAEtAARBDkYEQCAAIAFBzABqEIgGDwsgACABEKANECoaC8gJAgR/BH4jAEHwAGsiBSQAIARC////////////AIMhCgJAAkAgAUJ/fCILQn9RIAJC////////////AIMiCSALIAFUrXxCf3wiC0L///////+///8AViALQv///////7///wBRG0UEQCADQn98IgtCf1IgCiALIANUrXxCf3wiC0L///////+///8AVCALQv///////7///wBRGw0BCyABUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhBCABIQMMAgsgA1AgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQQMAgsgASAJQoCAgICAgMD//wCFhFAEQEKAgICAgIDg//8AIAIgASADhSACIASFQoCAgICAgICAgH+FhFAiBhshBEIAIAEgBhshAwwCCyADIApCgICAgICAwP//AIWEUA0BIAEgCYRQBEAgAyAKhEIAUg0CIAEgA4MhAyACIASDIQQMAgsgAyAKhFBFDQAgASEDIAIhBAwBCyADIAEgAyABViAKIAlWIAkgClEbIgcbIQogBCACIAcbIgtC////////P4MhCSACIAQgBxsiAkIwiKdB//8BcSEIIAtCMIinQf//AXEiBkUEQCAFQeAAaiAKIAkgCiAJIAlQIgYbeSAGQQZ0rXynIgZBcWoQgQIgBSkDaCEJIAUpA2AhCkEQIAZrIQYLIAEgAyAHGyEDIAJC////////P4MhASAIBH4gAQUgBUHQAGogAyABIAMgASABUCIHG3kgB0EG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AiAAECcoAgBJBEAgAiABEIoFIAAgACgCBEEIajYCBA8LIAAgARDMDAsxAQF/IAAoAgAoAgAiAQR/IAEFIAAoAgggACgCBCgCACIAIAAoAgAoAngRBAAQwwELCysAIAAoAgwQJCAAKAIQECQgARDwESAAKAIQECQQWARAIABBDGogARCmDAsLoAEBBH8jAEEQayIHJAACQCAARQ0AIAQoAgwhBiACIAFrIghBAU4EQCAAIAEgCBCXBSAIRw0BCyAGIAMgAWsiAWtBACAGIAFKGyIBQQFOBEAgACAHIAEgBRCXDCIFEBsgARCXBSEGIAUQKBogASAGRw0BCyADIAJrIgFBAU4EQCAAIAIgARCXBSABRw0BCyAEEMELIAAhCQsgB0EQaiQAIAkLCQAgACABENQECy4AAkAgACgCBEHKAHEiAARAIABBwABGBEBBCA8LIABBCEcNAUEQDwtBAA8LQQoLFAAgACgCAEEQaiABEJ0BEC0oAgALIgEBfyAAKAIABEAgABCYAyAAKAIAIQEgABCBCRogARAwCwsRACAAKAIUQYDgAXFBgIABRwsSACAAQoCAgPgPg0KAgID4D1ILEwAgAEUEQEEADwsgABCHAUEBSguBAgICfwR+IwBBEGsiAiQAIAG9IgVCgICAgICAgICAf4MhBwJ+IAVC////////////AIMiBEKAgICAgICAeHxC/////////+//AFgEQCAEQjyGIQYgBEIEiEKAgICAgICAgDx8DAELIARCgICAgICAgPj/AFoEQCAFQjyGIQYgBUIEiEKAgICAgIDA//8AhAwBCyAEUARAQgAMAQsgAiAEQgAgBEKAgICAEFoEfyAEQiCIp2cFIAWnZ0EgagsiA0ExahCBAiACKQMAIQYgAikDCEKAgICAgIDAAIVBjPgAIANrrUIwhoQLIQQgACAGNwMAIAAgBCAHhDcDCCACQRBqJAALCQAgACABELkNCwwAIAAgASgCADYCAAuBAgEBfwJAIAEgASgCACgCcBEEAEUNAAJ/AkAgACgCFCICQQNGBH9BASABIAEoAgAoAiwRBAApAgRCP4NCA1ENAhogACgCFAUgAgtBAUcNACABIAEoAgAoAiwRBAApAgRCP4NCBFINAEEBIAEgASgCACgCLBEEAC0ACUEBcUUNARoLIAAoAhQiAkEERgR/IAEgASgCACgC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KAJoELcORQ0AIAAgACgCACgCfBEEACIBIAEoAgAoAigRBAAiASABKQIEQoCAgIAQhDcCBAsgACEHCyAFQdABaiQAIAcLSgEBfyMAQRBrIgIkACACIAE2AgwgACAAKAIIQQFqNgIIIAAgAEEMaiAAQQhqEJ8BKAIANgIMIABBEGogAkEMahDwASACQRBqJAALMQEBfyMAQRBrIgEkACAAQgA3AgAgAUEANgIMIABBCGogAUEMahDPCSABQRBqJAAgAAsSACAAEDooAgAgACgCAGtBAnULDwAgACAAKAIAKAIkEQQACxEAIAAgASABKAIAKAIgEQIACxEAIAAgASABKAIAKAIsEQIACw8AIAAgACgCAEEBajYCAAsMACAAQYKGgCA2AAALBwAgABBOGgswAQF/IAEQH0EBTgRAA0AgASgCACACEBooAgAgABCqAiACQQFqIgIgARAfSA0ACwsLKAEBfyMAQRBrIgIkACACIAE2AgwgAEFAayACQQxqEIsBIAJBEGokAAuPAQECfyMAQRBrIgMkACAAQYTDETYCACAAQQRqEDchBCAAQRBqEDcaIABBHGoQNxogAEEoahA3GiAAQQA6ADggACACNgI0IAQgA0EIakEsECsgAUEAQfgBEFEQQSIBEH8gARBHIAAoAggQigEoAgAgABCMBiACKAIEIAAoAggQigEoAgAQkQEgA0EQaiQAIAALLgEBfyMAQRBrIgEkACABQQhqIAAQGyAAECZBAnRqEDMoAgAhACABQRBqJAAgAAsTACAAIABBwAAQzQEgASACEM4KC1kBAn8jAEEQayIFJABBLBArQeABEMIBIgQgACABQQAQbxA/IAQgACACQQAQbxA/IAQgACADQQAQbxA/IAAoAoQBIAVBCGogBBBBIgAQfCAAEEcgBUEQaiQAC48BAQF/IANBgBBxBEAgAEErOgAAIABBAWohAAsgA0GABHEEQCAAQSM6AAAgAEEBaiEACwNAIAEtAAAiBARAIAAgBDoAACAAQQFqIQAgAUEBaiEBDAELCyAAAn9B7wAgA0HKAHEiAUHAAEYNABpB2ABB+AAgA0GAgAFxGyABQQhGDQAaQeQAQfUAIAIbCzoAAAvDAgEDfyMAQRBrIgQkACAEIAE2AgwCQAJAAkACQAJAIAAgARClAyIGQWlqIgVBB0sEQCAGQe4pRw0BDAML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AWoiA0EDRw0ACwJAIAIoAgxBf0YNAAJAIAAoAhQiA0F/aiIEQQJLBEAgA0ENRw0CDAELAkAgBEEBaw4CAgEACyAAIAFB6MUKQbn+CUHcvxFBACAAKAIAKAKgARENAAwBCyAAIAFB6MUKQeH+CUHcvxFBACAAKAIAKAKgARENAAsgAi0AOARAIAAgAUHoxQpBwcYKQdy/EUEAIAAoAgAoAqABEQ0ACyACLQA5BEAgACABQejFCkHWxgpB3L8RQQAgACgCACgCoAERDQALAkAgAigCUEF/Rg0AIAAoAhRBDUcNACAAIAFB6MUKQdL+CUHcvxFBACAAKAIAKAKgARENAAsgAkFAay0AABA2BEAgACABQejFCkHqxgpB3L8RQQAgACgCACgCoAERDQALIAIoAkRBf0cEQCAAIAFB6MUKQfnGCkHcvxFBACAAKAIAKAKgARENAAsgAigCSCICBEAgACABQejFCiACEOwFQdy/EUEAIAAoAgAoAqABEQ0ACwuXAQACQCAAKAJMECwNACACEO4FBEAgACABQaS/CiACEBtB3L8RQQAgACgCACgCoAERDQALIAJB0pgPELQNQX9GDQACQCAAKAIIED5FDQAgACgCEEGsAkoNACAAIAFB0b8KIAIQG0HcvxFBACAAKAIAKAKgARENAA8LIAAgAUG0wAogAhAbQdy/EUEAIAAoAgAoAqQBEQ0ACwvbAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAEC8ABAQd/IwBBEGsiBCQAIAQQ0gEhBQJAIABByKsBaiIGEB8iB0F/akEAIAIbIgIgB08NAEEBIQgDQCAGKAIAIAIQGigCACIDIAMoAgAoAjQRBAAhAwJAIAhFBEAgACgCFEENRw0BCyAAIAMgAygCACgCKBEEACAFEO8IIglFDQILIAAgASAJIAUQGyADIAYo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ACgCACABQQJ0ajYCAAuEAQECfyAARQRAIAEQmwEPCyABQUBPBEBB2MkRQTA2AgBBAA8LIABBeGpBECABQQtqQXhxIAFBC0kbEJ0PIgIEQCACQQhqDwsgARCbASICRQRAQQAPCyACIAAgAEF8aigCACIDQXhxQQRBCCADQQNxG2siAyABIAMgAUkbEEAaIAAQMCACC0kBAn8gACgCBCIFQQh1IQYgACgCACIAIAEgBUEBcQR/IAIoAgAgBmooAgAFIAYLIAJqIANBAiAFQQJxGyAEIAAoAgAoAhgRDgALtgEBA38jAEEQayICJAAgAiABNgIMAkACQAJAAn8gABDLASIERQRAQQEhASAALQALDAELIAAQ3gRBf2ohASAAKAIECyIDIAFGBEAgACABQQEgASABEOEJIAAQywFFDQEMAgsgBA0BCyAAIQEgACADQQFqENYBDAELIAAoAgAhASAAIANBAWoQqQELIAEgA0ECdGoiACACQQxqEKcCIAJBADYCCCAAQQRqIAJBCGoQpwIgAkEQaiQAC3kBA38jAEEQayIDJABBbyACTwRAAkAgAkEKTQRAIAAgAhDWASAAIQQMAQsgACAAIAIQ7wJBAWoiBRD9AyIEEMEBIAAgBRDnASAAIAIQqQELIAQgASACEOsBIANBADoADyACIARqIANBD2oQjgEgA0EQaiQADwsQfQAL2QMCAn8CfiMAQSBrIgIkAAJAIAFC////////////AIMiBUKAgICAgIDA/0N8IAVCgICAgICAwIC8f3xUBEAgAUIEhiAAQjyIhCEEIABC//////////8PgyIAQoGAgICAgICACFoEQCAEQoGAgICAgICAwAB8IQQMAgsgBEKAgICAgICAgEB9IQQgAEKAgICAgICAgAiFQgBSDQEgBEIBgyAEfCEEDAELIABQIAVCgICAgICAwP//AFQgBUKAgICAgIDA//8AURtFBEAgAUIEhiAAQjyIhEL/////////A4NCgICAgICAgPz/AIQhBAwBC0KAgICAgICA+P8AIQQgBUL///////+//8MAVg0AQgAhBCAFQjCIpyIDQZH3AEkNACACIAAgAUL///////8/g0KAgICAgIDAAIQiBEGB+AAgA2sQ3QQgAkEQaiAAIAQgA0H/iH9qEIECIAIpAwhCBIYgAikDACIAQjyIhCEEIAIpAxAg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BgsgBCAGIAMgASAAa2ogASACRhs2AgAgChAoGiAKQRBqJAALOgEBfyMAQRBrIgIkACACIAEQswI2AgAgAkEIaiAAIAEgAhClEiACKAIIECchACACQRBqJAAgAEEMagvhAQECfyMAQSBrIgMkACADIAI2AhggAyABNgIcIANBHjYCCAJAAkAgAEHcAmoiBCADQQhqEEMQH0EBTgRAQQAhAQNAIANBHjYCCAJAIAQgA0EIahBDKAIAIAEQGigCACICELsCQQJHDQAgAkEAEDwgAygCHEcNACACQQEQPCADKAIYRg0DCyADQR42AgggAUEBaiIBIAQgA0EIahBDEB9IDQALCyADQQhqEDciASADQRxqEHAgASADQRhqEHAgACABQczCERDmByECIAEQRQwBCyACKAIEIQILIANBIGokACACCxQAIABB6ABqIAAgARBjEDxBARA8C7QBAQN/IwBBMGsiBSQAAkAgAC0AkAEEQCAFQSBqQQMQygciBigCACIHQQAQGiACNgIAIAdBARAaIAM2AgAgB0ECEBogBDYCACAAQakBIAEgBiAFQRBqEDciARCdBCEAIAEQRSAGEEUMAQtBLBArIgYgABBXIAFBqQEQUSIBIAIQPyABIAMQPyABIAQQPyAAKAKEASAFQQhqIAEQQSIAEHwgABBHIAYoAgQhAAsgBUEwaiQAIAALDwAgAEHoAGogARA8KAIMC1wBAn9BASECAkAgAEHoAGoiAyABEDwiACgCDEFpaiIBQQdLDQACQAJAAkAgAUECaw4GAwMDAQMCAAsgAEEBEDwPCyADIABBARA8EDxBABA8DwsgABC7AiECCyACCysBAX8gACgCBCECA0AgAhCjDiAAIAAoAgRBBGoiAjYCBCABQX9qIgENAAsLYwECfyMAQRBrIgUkAEEsECtB+gEQwgEiBCABED8gBCACEMECED8gBCADEMECED8gACgChAEgBUEIaiAEEEEiARB8IAEQRyACIAAoAoQBELkFIAMgACgChAEQuQUgBUEQaiQAC7QHAQd/IwBBEGsiCiQAIAogBTYCCCAKIAQ2AgwgBhDiAyEMIAYQjQUhC0GQASEIQQEhDQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACfwJAAkACQAJAAkACQAJAIAFB6X5qIg5BGUsEQCABQcl7aiIGQQ1NDQEg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BzoANCAAIAY2AiAgACAFNgIcIABCADcCECAAIAM2AgwgACACNgIIIAAgATYCBCAAQaifDzYCACAAQX8gAUEEdCABQf////8AcSABRxsQKyIDNgIYAkAgAUEBSA0AIANBACAFaxC2CCAAKAIEIgVBAUoEQEEBIQEDQCAAKAIYIAFBBHRqIAEgACgCHGsQtgggAUEBaiIBIAAoAgQiBUgNAAsLIARFIAVBAExyRQRAQQAhAQNAAkAgBCABQQJ0aigCACICRQRAQQAhAgwBCyACEL8BIQIgACgCBCEFCyAAKAIYIgMgAUEEdGogAjYCACABQQFqIgEgBUgNAAsMAQsgACgCGCEDCyADIAAoAhBBBHRqQQE2AgggAEEkakEBELYIIAAgACgCGCgCADYCJCAACwcAIAAQKBoLBwAgABDeBgsnACABBEAgACABKAIAEOAGIAAgASgCBBDgBiABQRBqEN4GIAEQMAsLBwAgABC0BAthAQJ/IAAoAhgiAQRAIAEhAgNAIAIoAgAhAiABBEAgARAwCyAAIAI2AhggAiIBDQALCyAAKAIUIgEEQANAIAEoAgAhAiABEDAgACACNgIUIAIiAQ0ACwsgAEEcahCtAyAAC0ABAn8gACgCACAAQQRqIgIoAgAgAUEEaiIDEIoGIAAgAxA7IAIgAUEIahA7IAAQJyABEDoQOyABIAEoAgQ2AgALCgAgACABa0EDdQsOACAALQABQQh0QYAORguDAQECfwJAIAAQRiIDBEAgABA4IQACQANAIAIgA0EQaiIEENUEBEAgAygCACIERQ0EIAMhACAEIQMMAQsgBCACENUERQ0BIANBBGohACADKAIEIgQEQCAEIQMMAQsLIAEgAzYCACAADwsgASADNgIAIAAPCyAAEDghAwsgASADNgIAIAMLCwAgACABIAIQ6gwLzgIBA38jAEFAaiIDJAACfyABIAEoAgAoAgwRBAAiBUHcvxEQMgRAIAEgASgCACgCJBEEACECIAAgACgCFCIEQQFqNgIUIAIgBCACKAIAKAJwEQIAIAMgASABKAIAKAIkEQQAIgIgAigCACgCdBEEADYCBCADQcCLETYCACADQSBqQRRBpfoOIAMQLxogASADQSBqEL8BIAEoAgAoAhARAgAgACABENYXDAELIAEgASgCACgCGBEEACEEIAEgASgCACgCHBEEAARAIAJFBEAgAyAAIAUQ+gU2AiAgAyAAEH42AhBBACADQSBqIANBEGoQjAENAhoLIAMgATYCHCADQRBqIAAgA0EgaiAEIANBHGoQyQgQyAhBAQwBCyADIAE2AhwgA0EQaiAAIANBIGogBCADQRxqEMkIEMgIIAMtABRBAEcLIQIgA0FAayQAIAILMgEBfyAAKAIEIgIgABAnKAIARwRAIAIgARDLCCAAIAAoAgRBFGo2AgQPCyAAIAEQ3xcLIAEBfyMAQRBrIgIkACAAIAEgAhD8BRD9DCACQRBqJAALqQoBBX8jAEGwAWsiByQAAkAgAyADKAIAKAIYEQQAIgRFDQAgBCgCaA0AIAIgAigCACgCcBEEAARAQQAhAyAHQdgAakEAQQBBAUEAQQBBABBIIgUgAhCVASAFIAIgAigCACgCTBEEABCBDSAEIAQoAgAoArwBEQQAIQIgBSgCPCACEB8QsgMgBCAEKAIAKAK8AREEACgCAEEAEBooAgAiAiACKAIAKAIMEQQAIQYCQCAFKAI8ELADRQ0AIAYgBigCACgCeBEEACICIAIoAgAoAnARBABFDQBBASECIAUoAjwQhwEgBiAGKAIAKAJ4EQQAIgggCCgCACgCTBEEABCHAUEBakcNACAFKAI8EIcBQQJIDQADQCAFKAI8IgggAhD7AUUEQCAIIAIgBiAGKAIAKAJ4EQQAIgggCCgCACgCTBEEACACQX9qEPsBEMYECyACQQFqIgIgBSgCPBCHAUgNAAsLIAcgBUEAQQAQ3AEhAgJ/AkAgBCAEKAIAKAK8AREEABAfRQ0AA0ACQCAAIAEgAiAEIAQoAgAoArwBEQQAKAIAIAMQGigCACIGIAYoAgAoAgwRBAAQ6wYhBiAEIAQoAgAoArwBEQQAKAIAIAMQGiAGNgIAIAQgBCgCACgCvAERBAAoAgAgAxAaKAIARQ0AIANBAWoiAyAEIAQoAgAoArwBEQQAEB9JDQEMAgsLQQAMAQsgACABIAQgBRD8BgshAyACED0aIAUQPRoMAQsCQAJAIAIgAigCACgCiAERBAAEQAJAIAJBQGsiAygCABBCIAQgBCgCACgCvAERBAAQH0YEQCADKAIAIgUQQkUNA0EAIQMgAkFAayEGDAELQQAhAyAAIAFBoq4LQcSuC0HcvxFBACAAKAIAKAKgARENAAwECwNAIAAgASAFKAIAIAMQRCgCACAEIAQoAgAoArwBEQQAKAIAIAMQGigCACIFIAUoAgAoAgwRBAAQ6wYhBSAEIAQoAgAoArwBEQQAKAIAIAMQGiAFNgIAIAQgBCgCACgCvAERBAAoAgAgAxAaKAIARQ0DIANBAWoiAyAGKAIAIgUQQkkNAAsMAQsgAiACKAIAKAJsEQQABEAgAiACKAIAKAI0EQQAIAQgBCgCACgCvAERBAAQH0cEQCAHQdgAaiACEM8BQQAhAyAAIAFB1a4LQcSuCyAHQdgAahAbQQAgACgCACgCoAERDQAMBAtBACEDIAdB2ABqIAJBAEEAENwBIQUCQCACIAIoAgAoAjQRBABBAEoEQANAIAAgASAFIAQgBCgCACgCvAERBAAoAgAgAxAaKAIAIgYgBigCACgCDBEEABDrBiEGIAQgBCgCACgCvAERBAAoAgAgAxAaIAY2AgAgBCAEKAIAKAK8AREEACgCACADEBooAgBFDQIgA0EBaiIDIAIgAigCACgCNBEEAEgNAAsLIAUQPRoMAgsgBRA9GgwCCyACIAIoAgAoAmgRBAAEQCACIAIoAgAoAjARBAAgBCAEKAIAKAK8AREEABAfRg0BIAdB2ABqIAIQzwFBACEDIAAgAUH1rgtBxK4LIAdB2ABqEBtBACAAKAIAKAKgARENAAwDCyAHQdgAaiACEM8BQQAhAyAAIAFBpa8LQcSuCyAHQdgAahAbQQAgACgCACgCoAERDQAMAgsgACABIAQgBCgCACgCvAERBAAQH0EBRgR/IAQgBCgCACgCvAERBAAoAgBBABAaKAIABSAECyACEPwGIQMMAQtBACEDCyAHQbABaiQAIAMLIwEBfyABBEAgACgCPCICRQRAIAAgARCBDQ8LIAIgARCaFwsLLwAgAiACKAIAKALMAREEAARAIAAgAUH4jgsgA0HcvxFBACAAKAIAKAKgARENAAsLnAEBBX8gABCcASEEAkACQEGs0hEoAgBFDQAgAC0AAEUNACAAQT0QhwoNAEGs0hEoAgAoAgAiAkUNAANAAkAgACACIAQQtwUhA0Gs0hEoAgAhAiADRQRAIAIgAUECdGooAgAiAyAEaiIFLQAAQT1GDQELIAIgAUEBaiIBQQJ0aigCACICDQEMAwsLIANFDQEgBUEBaiEBCyABDwtBAAuxBQEJfyMAQeAAayIEJAACQCAAIAAoAgAoAnARBAAEQCAEQQhqIABBAEEAENwBIQIgACAAKAIAKAI8EQQAIQAgAiABIAMgAxDvBiEBIAIQPRogACABbCEFDAELIAAgACgCACgCiAERBAAEQCAEQQA2AgQCQCAAQUBrIggoAgAQQkEBSA0AA0AgBEEIaiAAIAVBABDcASEGIARBADoAAyAEQQA6AAIgBEEAOgABIAYgBEEDaiAEQQJqIARBAWoQ7wYhCQJAIARBBGoCfyAELQADBEBBASEKQQgMAQsgBC0AAgRAQQEhC0EEDAELIAQtAAFFDQFBASEMQQILEJcCIAQoAgQhBwsgBCAHIAlqIgc2AgQgBhA9GiAFQQFqIgUgCCgCABBCSA0ACyAKBEAgAUEBOgAAIARBBGpBCBCXAgwBCyALBEAgAkEBOgAAIARBBGpBBBCXAgwBCyAMRQ0AIANBAToAACAEQQRqQQIQlwILIAQoAgQhBQwBC0EBIQUCQCAAIAAoAgAoAmARBAANACAAIAAoAgAoAmgRBAAEQCAAIAAoAgAoAjARBAAhBQwBCyAAIAAoAgAoAmwRBABFDQAgACAAKAIAKAI0EQQAIAAgACgCACgCOBEEAGwhBQsCQAJAIAAgACgCACgCHBEEAEECRg0AIAAgACgCACgCHBEEAEEKRg0AIAAgACgCACgCHBEEAEELRw0BCyABQQE6AAAgBUEDdCEFDAELAkACQCAAIAAoAgAoAhwRBABBA0YNACAAIAAoAgAoAhwRBABBBkYNACAAIAAoAgAoAhwRBABBB0cNAQsgA0EBOgAAIAVBAXQhBQwBCyAAIAAoAgAoAhwRBABBBEYNACAAIAAoAgAoAhwRBABBBUYNACACQQE6AAAgBUECdCEFCyAEQeAAaiQAIAULDQACfyAAEPEGC0EARwsNACAAKAIEKAIAKAIACxAAIABFBEBBAA8LIAAQ7QEL6gIBAX8gA0EANgIEAkACQCADAn8gAiACKAIAKAIUEQQAIgUEQCAFEFNBABAXKAIADAELAkAgAiACKAIAKAKEAREEACkCBBDvAQRAIAMgAjYCBCACIAIoAgAoAjARBAAiA0UNAUEBIAMQvwMiAygCBBDyBkEBSA0CGiADQQAQFygCAAwCCwJAIAIgAigCACgCHBEEAEUNACACIAIoAgAoAhwRBAAoAmhBxQRHDQAgAiACKAIAKAIcEQQAIgUgBSgCACgCvAERBAAiBSAFKAIAKAJ4EQQAEIIBRQ0AIAMgAiACKAIAKAIcEQQANgIEDAELIANBATYCAAwCC0EBCyIDNgIAIAIgAigCACgCgAERBABBCEcEQCACIAIoAgAoAoABEQQAQQlHDQELIANBAEoNASAAIAEgBEHcvxFB6twKQQAgACgCACgCoAERDQAPCyAAIAEgBEHcvxFBxNwKQQAgACgCACgCoAERDQALC+QBAQF/IwBBEGsiBCQAAkAgAkEBckEPRw0AIAMgAygCACgClAERBABFDQAgBCADELACIAAgAUGO3AogBBAbQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAAtAKQBDQAgAxDIAgRAIAQgAxCwAiAAIAEgBBAbQayPCiAAKAIAKAJQEQwACyAALQCkAQ0AIAMQxwIEQCAEIAMQsAIgACABIAQQG0HpjwogACgCACgCXBEMAAsgAC0ApAENACADENoCRQ0AIAQgAxCwAiAAIAEgBBAbQaeQCiAAKAIAKAJoEQwACyAEQRBqJAALxAUCAX8BfgJ+IAEpAgQiBBC/BARAIAAgACkCBEL/////////R4MgBEKAgICAgICAOIOENwIEIAEpAgQhBAsgBAsQjwMEQCAAIAApAgRC/////////794gyAEQoCAgICAgIDAB4OENwIECyABKQIYIgQQrwMEQCAAIARCGIg8ABsLIAEtACQiAxA2BEAgACADOgAkCyABKQIYIgQQmAIEQCAAIAApAhhC/////49+gyAEQoCAgIDwAYOENwIYCyABKAIgIgMQ3ggEQCAAIAAoAiBB//+fcHEgA0GAgOAPcXI2AiALIAEoAhAiAxC0AQRAIAAgAzYCEAsCQCACDQAgARCGAgRAIAAgACgCFEGAYHEgASgCFEH/H3FyNgIUCyABKAIMIgIQtAEEQCAAIAI2AgwLIAEQkQUEQCAAIAAoAhRB//+BfnEgASgCFEGAgP4BcXI2AhQLIAEzARgiBEL//wNSBEAgACAEPQEYCyABKAIgIgIQkAUEQCAAIAAoAiBB/4FgcSACQYD+H3FyNgIgCyABEK4DBEAgACAAKAIUQf+ffnEgASgCFEGA4AFxcjYCFAsCfgJ+IAEpAhgiBBC+BARAIAAgBEIQiDwAGiABKQIYIQQLIAQLEOoFBEAgACAAKQIYQv//////gYB+gyAEQoCAgICA/v8Bg4Q3AhggASkCGCEECyAECxCOAwRAIAAgACkCGEL/////////gYB/gyAEQoCAgICAgID+/wCDhDcCGAsgASgCICICEL0EBEAgACACOgAgCyABLQAlBEAgAEEBOgAlCyABLQAmBEAgAEEBOgAmCyABLQAnBEAgAEEBOgAnCyABLQAoBEAgAEEBOgAoCyABKAIsIgJBgHBHBEAgACACNgIsCyABLQAwBEAgAEEBOgAwCyABLQAIQRBxRQ0AIAAgACkCBEKAgICAgAKENwIECwscACAAQQNNBEAgAEECdEG4mQ9qKAIADwtByJkPC+ITAgF/GX4CQCADKQIEIgYQ+gFFDQAgAikCBBD6AUUNACAAIAFBkNQKQdy/EUHcvxFBACAAKAIAKAKgARENACADKQIEIQYLAkAgBhCvAkUNACACKQIEEK8CRQ0AIAAgAUHU1ApB3L8RQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAQNACAAKAIQIQUCQCAAKAIIED5FBEAgBUGkA0gNAQwCCyAFQbUCSg0BCyAAQbu2DyAAKAIAKAIgEQUADQACQCADKQIEIgYQ3wNFDQACQCACKQIEIgdCgICAwACDQgBSDQAgBxCvAg0AIAcQ+gEhBSAHQr+AgDiDQgBSDQAgBUUNAQsgACABQbHVCkHcvxFB3L8RQQAgACgCACgCoAERDQAgAykCBCEGCwJAAkAgBkKAgIDAAINQDQACQCACKQIEIgcQrwINACAHEPoBIQUgB0K/gIA4g0IAUg0AIAVFDQELIAAgAUHV1QpB3L8RQdy/EUEAIAAoAgAoAqABEQ0ADAELAkAgBhCvAkUNACACKQIEIgcQ+gEhBUEAIAdCv4CAOINQIAUbDQAgACABQa7WCkHcvxFB3L8RQQAgACgCACgCoAERDQAMAQsCQCAGEPoBRQ0AIAIoAgRBv4CAOHFFDQAgACABQfvWCkHcvxFB3L8RQQAgACgCACgCoAERDQAMAQsgBkI/g1ANACACLQAHQQdxRQ0AIAAgAUHi1wpB3L8RQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAMpAgQiBhDfA0UNACACKAIEQT9xIgVBDktBASAFdEGEwAFxRXINACAAIAFBsdUKQdy/EUHcvxFBACAAKAIAKAKgARENACADKQIEIQYLIAZCP4NCAlINACACKAIEQT9xQXNqQQFLDQAgACABQZTYCkHcvxFB3L8RQQAgACgCACgCoAERDQALAkACQAJAAkACQAJAIAIpAgQiBqdBP3EiBUECTwRAIAVBDUYEQCADKQIEQj+DQg5RDQULIAZCP4MiB0JzfCIIQgFYDQEgB0ICUgRAIAMpAgQhBwwGCyADKQIEIgdCP4NCDVINBQwCCyACIAMpAgRCP4MgBkJAg4Q3AgQMBQsgCKdBAWtFDQEgAykCBCIHQj+DQgJSDQMLIAIgBkJAg0IQhDcCBAwDCyADKQIEIgdCP4NCDVINAQsgAiAGQkCDQg+ENwIEDAELIAenQT9xIgVBAkkNACAAIAFBtNgKIAUQ8gJB3L8RQQAgACgCACgCoAERDQALAkAgBA0AIAMtAAdBB3EiBUUNACACLQAHQQdxRQ0AIAAgAUHQ2AogBRD2BkHcvxFBACAAKAIAKAKgARENAAsCQAJAIAIpAgQiBkKAgIA4g1BFBEAgBEUNASADKQIEQoCAgDiDIgdQDQIgAiAHIAZC////R4OENwIEDAILIAIgAykCBEKAgIA4gyAGQv///0eDhCIGNwIEIAQNAQsgAykCBCIHQoCAgICAgAiDUEVBACAGQoCAgICAgOADg0IAUhsgB0KAgICAgIAgg1BFQQAgBkKAgICAgIDIA4NCAFIbciAHQoCAgICAgMAAg1BFQQAgBkKAgICAgICoA4NCAFIbIAdCgICAgICAgAGDUEVBACAGQoCAgICAgOgCg0IAUhtyckUEQCAHQoCAgICAgIACg1AgBkKAgICAgIDoAYNQcg0BCyAAIAFB9dgKIAenQRh2QQdxEPYGQdy/EUEAIAAoAgAoAqABEQ0ACyACIANBABD1BiACIAIpAgQiBiADKQIEIgdCgICAwACDhCIINwIEIAIgCCADKQIEIghCgICAgAGDhCIJNwIEIAIgCSADKQIEIglCgICAgAKDhCIKNwIEIAIgCiADKQIEIgpCgICAgASDhCILNwIEIAIgCyADKQIEIgtCgICAgAiDhCIMNwIEIAIgDCADKQIEIgxCgICAgCCDhCINNwIEIAIgDSADKQIEIg1CgICAgMAAg4QiDjcCBCACIA4gAykCBCIOQoCAgICAAYOEIg83AgQgAiAPIAMpAgQiD0KAgICAgASDhCIQNwIEIAIgECADKQIEIhBCgICAgIAIg4QiETcCBCACIBEgAykCBCIRQoCAgICAEIOEIhI3AgQgAiASIAMpAgQiEkKAgICAgCCDhCITNwIEIAIgEyADKQIEIhNCgICAgIDAAIOEIhQ3AgQgAiAUIAMpAgQiFEKAgICAgIAIg4QiFTcCBCACIBUgAykCBCIVQoCAgICAgCCDhCIWNwIEIAIgFiADKQIEIhZCgICAgICAwACDhCIXNwIEIAIgFyADKQIEIhdCgICAgICAgAGDhCIYNwIEIAIgGCADKQIEIhhCgICAgICAgAKDhCIZNwIEIAIgGSADKQIEIhlCgICAgICAgASDhCIaNwIEIAIgGiADKQIEIhpCgICAgICAEIOEIhs3AgQgAiAbIAMpAgQiG0KAgICAgIABg4QiHDcCBCACIBwgAykCBCIcQoCAgICAgAKDhCIdNwIEIAIgHSADKQIEIh1CgICAgICABIOEIh43AgQgAiAeIAMpAgQiHkKAgICAEIOENwIEQQAgCKdBHHZBAXEgBkKAgICAAYNQG0EAIAenQRt2QQFxIAZCgICAwACDUBtyQQAgCadBHXZBAXEgBkKAgICAAoNQG3JBACAKp0EedkEBcSAGQoCAgIAEg1AbciAGIAuDp0EfdnJBACAMQiGIp0EBcSAGQoCAgIAgg1AbckEAIA1CIoinQQFxIAZCgICAgMAAg1AbckEAIA5CI4inQQFxIAZCgICAgIABg1AbckEAIA9CJYinQQFxIAZCgICAgIAEg1AbckEAIBBCJoinQQFxIAZCgICAgIAIg1AbckEAR0EAIBFCJ4inQQFxIAZCgICAgIAQg1AbckEAIBJCKIinQQFxIAZCgICAgIAgg1AbckEAIBNCKYinQQFxIAZCgICAgIDAAINQG3JBACAUQi2Ip0EBcSAGQoCAgICAgAiDUBtyQQAgFUIviKdBAXEgBkKAgICAgIAgg1AbckEAR0EAIBZCMIinQQFxIAZCgICAgICAwACDUBtyQQAgF0IxiKdBAXEgBkKAgICAgICAAYNQG3JBACAYQjKIp0EBcSAGQoCAgICAgIACg1AbckEAIBlCM4inQQFxIAZCgICAgICAgASDUBtyQQAgGkIuiKdBAXEgBkKAgICAgIAQg1AbckEAIBtCKoinQQFxIAZCgICAgICAAYNQG3JBACAcQiuIp0EBcSAGQoCAgICAgAKDUBtyQQAgHUIsiKdBAXEgBkKAgICAgIAEg1AbckEAIB5CIIinQQFxIAZCgICAgBCDUBtyBEAgACABQd/ZCkHcvxFB3L8RQQAgACgCACgCoAERDQALC2oAAkACQCACIAIoAgAoAoABEQQAQQxHDQAgAiACKAIAKAKgAREEAA0AIAIgAigCACgCnAERBAANACACIAIoAgAoAqQBEQQARQ0BCyAAIAFB98AKQdy/EUHcvxFBACAAKAIAKAKgARENAAsLFAAgAkUEQEEADwsgACABIAIQwgcLfAEDfyMAQRBrIgUkAAJAIAAQYCIEIAAQJiIDayACTwRAIAJFDQEgABAbIgQgA2ogASACEOsBIAAgAiADaiIBEIADIAVBADoADyABIARqIAVBD2oQjgEMAQsgACAEIAIgA2ogBGsgAyADQQAgAiABEJwHCyAFQRBqJAAgAAvGAQECfyMAQTBrIgUkAAJAIAAoAihBsAQgAiABIAEoAgAoAgwRBAAQ0AQiBgRAIAYgBigCACgCeBEEACACEMgBRQ0BCyAFQSBqIAEgASgCACgCDBEEACIBIAEoAgAoAngRBAAQzwEgBUEgahAbIQEgBUEQaiACEM8BIAVBEGoQGyECIAAoAgAoAqABIQYgBSACNgIIIAUgATYCBCAFIAM2AgAgACAEQdy/EUH+hwpBw4oKIAUgBhENAEEAIQYLIAVBMGokACAGC4oHAQp/IwBB4AFrIgQkAAJAIAJFDQAgAiACKAIAKAIMEQQARQ0AIAAgAUH+hwogAiACKAIAKAIMEQQAIAAoAgAoAvABEQwAIAIgAigCACgCGBEEACEFIAMQiQkiCEGxBEYEQCAFIAUoAgAoArwBEQQAKAIAQQEQGigCACIAIAAoAgAoAgwRBAAiACAAKAIAKAJ4EQQAIgAgACgCACgCIBEEAC0AAkECcQRAIAUgBSgCACgCvAERBAAoAgBBABAaKAIAIgAgACgCACgCDBEEACIAIAAoAgAoAnwRBAAiACAAKAIAKAIkEQQAIgAgACgCAEGAgAhyNgIACyAEIAEpAgg3AwggBCABKQIANwMAIAVBsQQgAyAEELcCIQUMAQsgCEGwBEYEQCADQUBrKAIAKAIAECQhCgsgBEGIAWpBAEEAQQFBAEEAQQAQSCEJAkAgAyADKAIAKAJwEQQABEAgCSAEQTBqIANBAEEAENwBIgYQlQEgBhA9GgwBCyAJIAMQlQELAkACQAJAIAUEQCAFKAJoRQ0BCwJ/IAMgAygCACgCcBEEAARAIAAgAiAJQQEgAiACKAIAKAIAEQQAEPsGDAELIAhBsARGBEAgACACIAooAgBBASACIAIoAgAoAgARBAAQ+wYMAQsgACADIAggAiACKAIAKAIMEQQAIAIgAigCACgCABEEAEEAEOsICyIFRQ0BQQAgCEGwBEcgAyADKAIAKAJwEQQAGw0CIAQgASkCCDcDGCAEIAEpAgA3AxAgBUGwBCADIARBEGoQtwIhBQwCCyAEIAUgBSgCACgCvAERBAAiCygCABAkNgIwIAsoAgQQJCEGIAQoAjAgBhAlBEBBACEGIAhBsARHIQwDQCADIAMoAgAoAnARBAAhDSAEKAIwKAIAIQcCfyANBEAgACAHIAkgBkEBaiACIAIoAgAoAgARBAAQ+wYMAQsgDEUEQCAAIAcgCiAGEEQoAgAgBkEBaiACIAIoAgAoAgARBAAQ+wYMAQsgACADIAggByAHKAIAKAIMEQQAIAIgAigCACgCABEEAEEBEOsICyIHRQ0CIAQoAjAgBzYCACAGQQFqIQYgBEEwahD7AiALKAIEECQhByAEKAIwIAcQJQ0ACwsgBCABKQIINwMoIAQgASkCADcDICAFIAggAyAEQSBqELcCIQUMAQtBACEFCyAJED0aCyAEQeABaiQAIAUL5AIBBn8jAEEQayIHJAAgA0Go0hEgAxsiBSgCACEDAkACQAJAIAFFBEAgAw0BDAMLQX4hBCACRQ0CIAAgB0EMaiAAGyEGAkAgAwRAIAIhAAwBCyABLQAAIgBBGHRBGHUiA0EATgRAIAYgADYCACADQQBHIQQMBAsgASwAACEAQZTJESgCACgCAEUEQCAGIABB/78DcTYCAEEBIQQMBAsgAEH/AXFBvn5qIgBBMksNASAAQQJ0QdAtaigCACEDIAJBf2oiAEUNAiABQQFqIQELIAEtAAAiCEEDdiIJQXBqIANBGnUgCWpyQQdLDQADQCAAQX9qIQAgCEGAf2ogA0EGdHIiA0EATgRAIAVBADYCACAGIAM2AgAgAiAAayEEDAQLIABFDQIgAUEBaiIBLQAAIghBwAFxQYABRg0ACwsgBUEANgIAQdjJEUEZNgIAQX8hBAwBCyAFIAM2AgALIAdBEGokACAEC4YBAQN/IwBBEGsiAyQAAkACQCAAKAJEIgItADUQNgRAIABBQGsoAgANAQsgAhDbASECIAAoAgAoAqABIQQgA0HcvxE2AgAgACACQdy/EUHcvxEgASADIAQRDQAMAQsgACACENsBQeP4CUHcvxFB3L8RQQAgACgCACgCoAERDQALIANBEGokAAsiAQF/IAAoAoQEIgJBf0cEQCABIAJGDwsgACABNgKEBEEBCx8BAX8gACgCjAQiAgRAIAEgAkYPCyAAIAE2AowEQQELEAAgAEKAgICAgAGDQiOIpwsOACAAQcCpAWotAAAQNgsXACAAQQE6ANoDIABB9AZqQYrsCRCaAgsRACAAQoCAgICAgAKDQiuIpws6AQJ/QYUqIQEgAC0AACICBEADQCABQSFsIAJBGHRBGHVqIQEgAC0AASECIABBAWohACACDQALCyABC7sCAQV/AkAgAC0ANQ0AAkACQAJAIAAoAhQiAUUEQCAAKAIMIQMgACgCECEBA0AgAyABQX9qIgFBAnRqKAIAIQIgAUEBSA0CIAJFDQALIAAgATYCEAwCCyAAIAFBf2oiAjYCFCAAKAIYIAAoAhAiAUEEdGoiBCAEKAIMQX9qNgIMIAAgACgCMEF/ajYCMCAEKAIMQX9KDQICQCACRQ0AIAAoAgggAUECdGooAgAhBSACIQEDQCABIAVqLQAAQQpGBEAgASEDDAILIAFBf2oiAQ0ACwsgACACIANrIgE2AjAgBCABNgIMDAILIAAgATYCECACDQAgAEEANgIUDAELIAAgAkF/ajYCFAsgABDjAUEKRw0AIAAoAhggACgCEEEEdGoiASABKAIIQX9qNgIIIAAgACgCLEF/ajYCLAsLHQEBfyAAKAIERQRAEPEBIgEQmgEaIAAgATYCBAsLPAICfwF8IAAoAgQQ7QEiAwRAA0AgBCAAIAIQFysDACABIAIQFysDAKKgIQQgAkEBaiICIANHDQALCyAEC5cCAQJ/AkAgASgCCCIDIAAoAghHDQACQCADQX5qIgJBCksNAAJAAkACQAJAAkACQAJAAkACQAJAIAJBAWsOCgoGBwQFAAEICQIDC0EBIQIgASgCACAAKAIARw0JDAoLQQEhAiABKAIAIAAoAgBHDQgMCQtBASECIAEtAAAgAC0AAEcNBwwIC0EBIQIgASsDACAAKwMAYg0GDAcLQQEhAiABLwEAIAAvAQBHDQUMBgtBASECIAEvAQAgAC8BAEcNBAwFC0EBIQIgAS0AACAALQAARw0DDAQLQQEhAiABLQAAIAAtAABHDQIMAwtBASECIAEpAwAgACkDAFINAQwCC0EBIQIgASkDACAAKQMAUQ0BC0EAIQILIAIL7QEBAX8gABDdAiEAAkAgASgCCEF+aiIDQQlLDQACQAJAAkACQAJAAkACQAJAAkAgA0EBaw4JCQMGBAcAAQUIAgsgACABKAIAIAIoAgBrEGYPCyAAIAEoAgAgAigCAGsQbA8LIAAgASsDACACKwMAoRA1DwsgACABLQAAIAItAABrQRh0QRh1EG0PCyAAIAEvAQAgAi8BAGtBEHRBEHUQcw8LIAAgASkDACACKQMAfRBdDwsgACABLQAAIAItAABrQf8BcRB2DwsgACABLwEAIAIvAQBrQf//A3EQcg8LIAAgASkDACACKQMAfRBeCwuxAQECfwJAIAAoAghBfmoiA0EJSw0AAkACQAJAAkACQAJAAkACQAJAIANBAWsOCQkDBAUGAAEHCAILIAAoAgAgASgCAEoPCyAAKAIAIAEoAgBLDwsgACsDACABKwMAZA8LIAAsAAAgASwAAEoPCyAALQAAIAEtAABLDwsgAC4BACABLgEASg8LIAAvAQAgAS8BAEsPCyAAKQMAIAEpAwBVDwsgACkDACABKQMAViECCyACC7EBAQJ/AkAgACgCCEF+aiIDQQlLDQACQAJAAkACQAJAAkACQAJAAkAgA0EBaw4JCQABAgMHCAQFBgsgACwAACABLAAASA8LIAAtAAAgAS0AAEkPCyAALgEAIAEuAQBIDwsgAC8BACABLwEASQ8LIAApAwAgASkDAFMPCyAAKQMAIAEpAwBUDwsgACsDACABKwMAYw8LIAAoAgAgASgCAEgPCyAAKAIAIAEoAgBJIQILIAILDQAgACABQQJ0aigCBAsfAQF/QQEhASABQQAgAEHKe2pBD0kgAEF2akEESXIbCwsAIAAtAAJBKHFFCzsBAn9BHBB0IgQiAxD+BSADIAE2AhggAyAANgIUIANB3LQJNgIAIAMhACAEIAIgBCgCACgCBBECACAAC40BAQF/AkAgACgCBCIBIAEoAgBBdGooAgBqKAIYRQ0AIAAoAgQiASABKAIAQXRqKAIAahCUB0UNACAAKAIEIgEgASgCAEF0aigCAGooAgRBgMAAcUUNACAAKAIEIgEgASgCAEF0aigCAGooAhgQqw5Bf0cNACAAKAIEIgAgACgCAEF0aigCAGpBARD8AwsL6AIBA38jAEEgayIFJAACQANAIAIgAigCACgCeBEEACIGIAYoAgAoAhwRBABBEEYNASADIAMoAgAoAngRBAAiBiAGKAIAKAIcEQQAQRBGDQECQCABQcl7akEBSw0AIAIQ/gFFDQAgAEHewA8QlAFFDQAgAyADKAIAKAJ4EQQAIgYgBigCACgCYBEEAEUNAiADIAMoAgAoAngRBAAiBiAGKAIAKAKQAREEAEUNAiAFIAQpAgg3AwggBSAEKQIANwMAIABBlwFBmAEgAUG3BEYbIAIgAyAFEOMDIgNFDQIgAiACKAIAKAIwEQQAEPwZIQJBtgQhAQwBCwsgACABIAIgAigCACgCeBEEACADENAEIgNFDQAgAiACKAIAKAJ4EQQAGiAFIAQpAgg3AxggBSAEKQIANwMQIAAgASACIAMgBUEQahCYCSIAEJcJRQ0AIAAgACgCACgCyAERCAAgACEHCyAFQSBqJAAgBwtVACAAIAE2AgQgAEEAOgAAIAEgASgCAEF0aigCAGoQlAcEQCABIAEoAgBBdGooAgBqKAJIBEAgASABKAIAQXRqKAIAaigCSBC7DgsgAEEBOgAACyAACwgAIAAoAhBFCyAAIABBARCzDiAAQQA2AmwgACABNgJoIABB1L4JNgIACycAIAAgAhCFBiAAQdi1CTYCACAAQegAaiABEIwEGiAAQQA6AHAgAAscAQF/IAEtAAQgAC0ABHMEfyACBSAAIAEQiwkLCx8AIAAoAgAEQCAAEJgDIAAQJ0EANgIAIABCADcCAAsLLgEBf0EBIQECQCAAQf+pERCUAQ0AIABB56kREJQBDQAgAEGnqhEQlAEhAQsgAQsgAQF/QQEhASAAQf+pERCUAQR/IAEFIABBns0PEJQBCwsYACAAQXxqIgBBBk0EQCAAQQFxRQ8LQQAL4wEBA38jAEEQayIIJABBbiABayACTwRAIAAQGyEKQW8hCSABQeb///8HTQRAIAggAUEBdDYCCCAIIAEgAmo2AgwgCEEMaiAIQQhqEF8oAgAQ7wJBAWohCQsgABA6KAIAIAkQ5wUhASAEBEAgASAKIAQQ6wELIAYEQCABIARqIAcgBhDrAQsgAyAFayICIARrIgMEQCABIARqIAZqIAQgCmogBWogAxDrAQsgACABEMEBIAAgCRDnASAAIAIgBmoiABCpASAIQQA6AAcgACABaiAIQQdqEI4BIAhBEGokAA8LEH0ACzUBAX9BiAEQdCIGIAAgASACEM4OIQAgBiAFIAYoAgAoAgQRAgAgACADEKQJIAAgBBDeASAACw0AIABBCGoQ1wQaIAALBwAgABC1AQsIACAAENIEGgsHACAAKAJoCxEAIAAgACgCAEF8ajYCACAACy0BAX8jAEEQayIBJAAgASAAKAIENgIIIAFBCGoQogcoAgAhACABQRBqJAAgAAsUACAAIAEQJCIBNgIEIAAgATYCAAsPACAAIAAoAgRBfGoQowILdwAgAEGk+w42AgAgAEEANgJQIABCADcCPCAAQgA3AkQgACAAKAIEQYCAgH5xIARBCHRBgB5xIAFB/wFxcnI2AgQgAEHMAGoQ/gIgAEEIahD9AiAAIANBGHRBgICAOHEgAkE/cXKtIAApAgxCwP//R4OENwIMIAALQwEBfyACKAIABEADQCACKAIUIAAoAgAoAgAgACgCBCgCABD3DgRAIAEgAhD2DgsgAigCGCEDIAJBGGohAiADDQALCwsTACAAQfgpNgIAIABBBGoQWyAAC7EBAgJ/AX4CQCABQX9qIgNBA0sEQCABQQ1HDQEgACkCBCIEQoCAgICAEINCAFINASAEEOQCDwsCQAJAAkACQCADQQFrDgMCAAMBCyAAKQIEEM4CDwsgACkCBCIEQoCAgICAIINCAFINAkEBIQIgBBDOAg0CIAQQ5AIPCyAAKQIEIgRCgICAgIAgg0IAUg0BIAQQzgIPCyAAKQIEIgRCgICAgIACg1ANACAEEM4CIQILIAILWQECfyAAKAIEIQJBASEDIAAoAgAoAgAQJygCBBDYBEEBTgR/IAIgACgCCCgCACIAIAAoAgAoAgARBABBs5oBIAFB3L8RQQAgAigCACgCpAERDQBBAAUgAwsLNgAgAEGYKzYCACAAQQAQwAkgAEEcahBbIAAoAiAQMCAAKAIkEDAgACgCMBAwIAAoAjwQMCAACwkAIAAQhQ8gAAscACAAEIkPIgBFBEBBAA8LIAEgACgCADYCAEEBCyUAIAAQYCAAECYgAWpBAmpJBEAgACAAEGAgABBgQQF2ahDNDwsLDQAgACgCACABKAIASQslAQF/IAIgADYCBCABIAAoAgAiAzYCACADIAE2AgQgACACNgIAC1MBAX8jAEEQayICJAAgAiAAECcQjA8gAigCAEEIaiABEJgBIAAgAigCACIBIAEQsAcgABAnIgAgACgCAEEBajYCACACEMABIAIQ2QQgAkEQaiQAC2EBAX8gAEHQrQ82AgAgACgCFCIBBEAgARC0CBAwCyAAKAIMIgEEQCABIAEoAgAoAgQRCAALIAAoAhAiAQRAIAEQvggQMAsgACgCBCIBBEAgARDiBhAwCyAAQSxqECgaIAALpwEBAn8gAEHorg82AgAgACgC+AEiAQRAIAEQtAgQMAsgACgC/AEiAQRAIAEgASgCACgCBBEIAAtBACEBA0ACQCAAIAFqLQDoAUUNACAAIAFBAnRqKAKwASICRQ0AIAIQvggQMAsgAUEBaiIBQQ5HDQALIAAoAgQiAQRAIAEQ4gYQMAsgAEGwAWohASAAQQhqIQIDQCABQXRqIgEQvQggASACRw0ACyAAC4IEAwF/AX4DfAJAIAC9IgJCIIinQf////8HcSIBQYCAwKAETwRAIAJC////////////AINCgICAgICAgPj/AFYNAUQYLURU+yH5v0QYLURU+yH5PyACQgBTGw8LAn8gAUH//+/+A00EQEF/IAFBgICA8gNPDQEaDAILIACZIQAgAUH//8v/A00EQCABQf//l/8DTQRAIAAgAKBEAAAAAAAA8L+gIABEAAAAAAAAAECgoyEAQQAMAgsgAEQAAAAAAADwv6AgAEQAAAAAAADwP6CjIQBBAQwBCyABQf//jYAETQRAIABEAAAAAAAA+L+gIABEAAAAAAAA+D+iRAAAAAAAAPA/oKMhAEECDAELRAAAAAAAAPC/IACjIQBBAwshASAAIACiIgQgBKIiAyADIAMgAyADRC9saixEtKK/okSa/d5SLd6tv6CiRG2adK/ysLO/oKJEcRYj/sZxvL+gokTE65iZmZnJv6CiIQUgBCADIAMgAyADIANEEdoi4zqtkD+iROsNdiRLe6k/oKJEUT3QoGYNsT+gokRuIEzFzUW3P6CiRP+DAJIkScI/oKJEDVVVVVVV1T+goiEDIAFBf0wEQCAAIAAgBSADoKKhDwsgAUEDdCIBQfAlaisDACAAIAUgA6CiIAFBkCZqKwMAoSAAoaEiAJogACACQgBTGyEACyAAC0sBAn8gACgCBCIGQQh1IQcgACgCACIAIAEgAiAGQQFxBH8gAygCACAHaigCAAUgBwsgA2ogBEECIAZBAnEbIAUgACgCACgCFBENAAsgAAJAIAAoAgQgAUcNACAAKAIcQQFGDQAgACACNgIcCwuiAQAgAEEBOgA1AkAgACgCBCACRw0AIABBAToANCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0BIAAoAjBBAUcNASAAQQE6ADYPCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRyACQQFHcg0BIABBAToANg8LIABBAToANiAAIAAoAiRBAWo2AiQLC10BAX8gACgCECIDRQRAIABBATYCJCAAIAI2AhggACABNgIQDwsCQCABIANGBEAgACgCGEECRw0BIAAgAjYCGA8LIABBAToANiAAQQI2AhggACAAKAIkQQFqNgIkCwsOACAAEE4iACAAEGAQTQsnAQF/IwBBEGsiAiQAIAIQuQcgACACIAEQxQ8gAhAoGiACQRBqJAALuQkDBH8BfgR8IwBBMGsiBCQAAkACQAJAIAC9IgZCIIinIgVB/////wdxIgNB+tS9gARNBEAgBUH//z9xQfvDJEYNASADQfyyi4AETQRAIAZCAFkEQCABIABEAABAVPsh+b+gIgdEMWNiGmG00L2gIgA5AwAgASAHIAChRDFjYhphtNC9oDkDCEEBIQIMBQsgASAARAAAQFT7Ifk/oCIHRDFjYhphtNA9oCIAOQMAIAEgByAAoUQxY2IaYbTQPaA5AwhBfyECDAQLIAZCAFkEQCABIABEAABAVPshCcCgIgdEMWNiGmG04L2gIgA5AwAgASAHIAChRDFjYhphtOC9oDkDCEECIQIMBAsgASAARAAAQFT7IQlAoCIHRDFjYhphtOA9oCIAOQMAIAEgByAAoUQxY2IaYbTgPaA5AwhBfiECDAMLIANBu4zxgARNBEAgA0G8+9eABE0EQCADQfyyy4AERg0CIAZCAFkEQCABIABEAAAwf3zZEsCgIgdEypSTp5EO6b2gIgA5AwAgASAHIAChRMqUk6eRDum9oDkDCEEDIQIMBQsgASAARAAAMH982RJAoCIHRMqUk6eRDuk9oCIAOQMAIAEgByAAoUTKlJOnkQ7pPaA5AwhBfSECDAQLIANB+8PkgARGDQEgBkIAWQRAIAEgAEQAAEBU+yEZwKAiB0QxY2IaYbTwvaAiADkDACABIAcgAKFEMWNiGmG08L2gOQMIQQQhAgwECyABIABEAABAVPshGUCgIgdEMWNiGmG08D2gIgA5AwAgASAHIAChRDFjYhphtPA9oDkDCEF8IQIMAwsgA0H6w+SJBEsNAQsgASAAIABEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiCEQAAEBU+yH5v6KgIgkgCEQxY2IaYbTQPaIiCqEiADkDACADQRR2IgMgAL1CNIinQf8PcWtBEUghBQJ/IAiZRAAAAAAAAOBBYwRAIAiqDAELQYCAgIB4CyECAkAgBQ0AIAEgCSAIRAAAYBphtNA9oiIAoSIHIAhEc3ADLooZozuiIAkgB6EgAKGhIgqhIgA5AwAgAyAAvUI0iKdB/w9xa0EySARAIAchCQwBCyABIAcgCEQAAAAuihmjO6IiAKEiCSAIRMFJICWag3s5oiAHIAmhIAChoSIKoSIAOQMACyABIAkgAKEgCqE5AwgMAQsgA0GAgMD/B08EQCABIAAgAKEiADkDACABIAA5AwgMAQsgBkL/////////B4NCgICAgICAgLDBAIS/IQADQCAEQRBqIAJBA3RqAn8gAJlEAAAAAAAA4EFjBEAgAKoMAQtBgICAgHgLtyIHOQMAIAAgB6FEAAAAAAAAcEGiIQAgAkEBaiICQQJHDQALIAQgADkDIAJAIABEAAAAAAAAAABiBEBBAiECDAELQQEhBQNAIAUiAkF/aiEFIARBEGogAkEDdGorAwBEAAAAAAAAAABhDQALCyAEQRBqIAQgA0EUdkHqd2ogAkEBahDSDyECIAQrAwAhACAGQn9XBEAgASAAmjkDACABIAQrAwiaOQMIQQAgAmshAgwBCyABIAA5AwAgASAEKQMINwMICyAEQTBqJAAgAgu2AQEDfyMAQRBrIgUkAEFvIgYgAWsgAk8EQCAAEBshByAAAn8gBkEBdkFwaiABSwRAIAUgAUEBdDYCCCAFIAEgAmo2AgwgBUEMaiAFQQhqEF8oAgAQ7wIMAQsgBkF/agtBAWoiBhD9AyECIAQEQCACIAcgBBDrAQsgAyAEayIDBEAgAiAEaiAEIAdqIAMQ6wELIAFBCkcEQCAHEDALIAAgAhDBASAAIAYQ5wEgBUEQaiQADwsQfQALZwECfyMAQRBrIgQkAAJAIAAQYCIDIAJPBEAgABAbIgMgASACEKsFIARBADoADyACIANqIARBD2oQjgEgACACEIADDAELIAAgAyACIANrIAAQJiIAQQAgACACIAEQ5QkLIARBEGokAAsJACAAIAEQogoLGAAgACgCCBCAAUcEQCAAKAIIEPAMCyAACzoBAX8jAEEQayIDJAAgAyACNgIMIANBCGogA0EMahCLAyECIAAgARCbBCEAIAIQigMgA0EQaiQAIAALCwAgBCACNgIAQQMLQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIAFBAWohASAAQQFqIQAgAkF/aiICDQEMAgsLIAQgBWshAwsgAwsLACAAIAEQ6AkgAAsUACAABEAgACAAKAIAKAIEEQgACwsQACAAEJ4BIABBgNoANgIAC3wBAX8jAEGQAWsiBCQAIAQgADYCLCAEIAA2AgQgBEEANgIAIARBfzYCTCAEQX8gAEH/////B2ogAEEASBs2AgggBEIAEOYCIAQgAkEBIAMQlwohAyABBEAgASAAIAQoAgQgBCgCeGogBCgCCGtqNgIACyAEQZABaiQAIAMLtwEBBH8CQCACKAIQIgMEfyADBSACELsLDQEgAigCEAsgAigCFCIFayABSQRAIAIgACABIAIoAiQRAAAPCwJAIAIsAEtBAEgNACABIQQDQCAEIgNFDQEgACADQX9qIgRqLQAAQQpHDQALIAIgACADIAIoAiQRAAAiBCADSQ0BIAEgA2shASAAIANqIQAgAigCFCEFIAMhBgsgBSAAIAEQQBogAiACKAIUIAFqNgIUIAEgBmohBAsgBAsxACAAKAIEIAAQjQEoAgAgACgCEGpBf2oiAEEGdkH8//8fcWooAgAgAEH/AXFBBHRqC1YBAX8jAEEQayICJAAgAiABNgIMAkAgACgCACgCAEECTwRAIAAoAgQgAkEMahBwDAELIAAoAgggATYCAAsgACgCDCIAIAAoAgBBAWo2AgAgAkEQaiQACxgAIAAQ5QMaIAAgARDHBSAAIAEQtwYgAAsXACAAKAIIEIoBKAIAKAIMQYd+akEHSQsVACABIAB0IAFBACAAa3YgAEF/ShsLCgAgAEH///8DcQuoAQEDfyMAQRBrIgUkACAFIAE2AgwCfwJAIABBtAJqIgcgBUEMahBDEB9BAUgNAEEAIQADQAJAIAUgATYCCAJAIAIgByAFQQhqEEMoAgAgABAaKAIAIgYoAgxHDQAgAyAGKAIIRw0AIAZBABA8IARGDQELIAUgATYCDCAAQQFqIgAgByAFQQxqEEMQH0gNAQwCCwsgBigCBAwBC0EACyEAIAVBEGokACAACx8AIAEEQCAAIAEoAgAQzwcgACABKAIEEM8HIAEQMAsLHwAgAQRAIAAgASgCABDQByAAIAEoAgQQ0AcgARAwCwsdACAAQcTCETYCACAAQRBqENUBIABBBGoQ1QEgAAtAAQJ/IAAoAgAgAEEEaiICKAIAIAFBBGoiAxDzESAAIAMQOyACIAFBCGoQOyAAECcgARA6EDsgASABKAIENgIAC6ABAQR/IwBBIGsiAiQAIAIgAEGgA2oiBCABEPYRNgIYIAIQigQ2AggCQCACQRhqIAJBCGoQjAEEQCACQRhqELcDKAIMIQMMAQsgABBXIQNBLBArIANBAEEHEFEiBSABEBsiARCeAyAAQcgBaiACQQhqIAUQQSIAEH8gABBHIAQgAkEIaiABEGgiABCxBiADNgIAIAAQKBoLIAJBIGokACADCxwAIAAoAgQgACgCACABKAIAa0EDdGogASgCBGsLMQEBfyMAQRBrIgEkACAAQgA3AgAgAUEANgIMIABBCGogAUEMahDSAiABQRBqJAAgAAsMACAAECcoAgBBBXQLhwEBBH8gACgCACAAKAIcEOcCIAAoAgAgACgCEBDeASAAKAIAIAAoAhwgACgCCBC4CiAAKAIUIQEgACgCBCECIAAoAgAhAwJAIAAoAhgiBARAIAMgAiABIAQQuAYMAQsgAyACIAEgACgCHBC4BgsgACgCDCAAKAIcEO4DIAAoAgAgACgCHBDeAQuNAQAgAEEANgIYIAAgAjYCCCAAIAE2AgQgACADNgIAIAAgAygChAEoAjQ2AgxBPBArIgEgAxBXIAAoAgwQ7wMaIAAgATYCFEE8ECsiASAAKAIAEFcgACgCDBDvAxogACABNgIcIAAgACgCACgChAE2AhAgACgCDCAAKAIUEO4DIAAoAgAgACgCFBDeASAACwkAIAAgARCaEgsRACAAQoCAgICAgAGDQiqIpwvtDgEBfwJAAkAgAUF/aiIDQfYASw0AQQAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCADQQFrDnYKCwwODSgpISIjJCUmJyorLC0uLzABAgMEFhcYYQBgDxBgYGBgYGBgYGBgYGBgYGBgGxkVER8dHGAeYGAHBQZgYAgaEhMUIDEyMzQ1Njc5ODo7PD0+P0BBQkNERUxGR0hJSktNTk9QUVJTVFVWV1hZWltcXV5fCQtBASEBIAINYCAAKAKMBCgCAEF/aiICQQJLDWAgAkECa0UEQCAAQThqQRgQKUEBDwsgAEE4akEXEClBAQ8LQQUPC0EGDwtBKg8LQSsPC0EPDwtBEA8LQREPC0EWDwtBGA8LQRkPC0EaDwtBGw8LQR0PC0EcDwtBAyEBIAINUSAAQThqQSAQKUEDDwtBBCEBIAINUCAAQThqQSEQKUEEDwsgAEE4aiICQTkQKUEKIQEgACgCjAQoAgBBAksNTyACQdq1EUGAigQQsgEgAkGGKRApQQoPCyAAQThqQSMQKUESDwsgAEE4akEjEClBEw8LQRQPC0EJIQEgACgCjAQoAgBBDUYNSyAAQThqIgJBAhApIAAoAowEKAIAQQJLDUsgAkHatRFBgIoEELIBIAJBhikQKUEJDwsgAEE4aiIAQf61EUGAhgQQsgEgAEHLIhApQcgiDwsgAEE4aiIAQf61EUGAhgQQsgEgAEHLIhApQckiDwsgAEE4aiIAQf61EUGAhgQQsgEgAEHLIhApQcoiDwtBByEBIAAoAowEKAIAQQRHDUcgAEE4akECEClBBw8LIABBOGoiAEGdthEQSSAAQZUnEClBlicPC0EIDwtBDA8LQQsPC0ENDwtBDg8LQRcPCyAAQThqIgBBnbMREEkgAEHHIhApQSQPCyAAQThqIgBBnbMREEkgAEHHIhApQSkPCyAAQThqIgBBnbMREEkgAEHHIhApQcAiDwsgAEE4aiIAQZ2zERBJIABBxyIQKUHBIg8LIABBOGoiAEGdsxEQSSAAQcciEClBwiIPCyAAQThqIgBBnbMREEkgAEHHIhApQcMiDwsgAEE4aiIAQZ2zERBJIABBxyIQKUHEIg8LIABBOGpBPRApQSYPCyAAQThqQT0QKUEoDwsgAEE4akE9EClBJA8LIABBOGpBPRApQSkPCyAAQThqIgBBPRApIABBwAAQKUHAIg8LIABBOGoiAEE9ECkgAEHAABApQcEiDwsgAEE4aiIAQT0QKSAAQcAAEClBwiIPCyAAQThqIgBBPRApIABBwAAQKUHDIg8LIABBOGoiAEE9ECkgAEHAABApQcQiDwsgAEE4akH0shEQSUGAJw8LIABBOGpB9LIREElBgScPCyAAQThqQfSyERBJQYInDwsgAEE4akH0shEQSUGDJw8LIABBOGpB9LIREElBhCcPCyAAQThqQfSyERBJQYUnDwsgAEE4akH0shEQSUGGJw8LIABBOGoiAEG7thFBgIYEELIBIABB1SIQKUHWIg8LIABBOGoiAEHQthFBgIYEELIBIABB1yIQKUHYIg8LIABBOGoiAEHithEQSSAAQaspEClBrCkPCyAAQThqIgBB4rYREEkgAEGrKRApQa0pDwtBhSkhASACDSQgAEE4aiIAQYO1ERBJIABBhykQKUGFKQ8LQYkpIQEgAg0jIABBOGoiAEGatREQSSAAQYspEClBiSkPC0GKKSEBIAINIiAAQThqIgBBmrUREEkgAEGLKRApQYopDwtBjSkhASACDSEgAEE4aiIAQYa3ERBJIABBjCkQKUGNKQ8LQY4pIQEgAg0gIABBOGoiAEGGtxEQSSAAQYwpEClBjikPCyAAQThqIgBBrLcREEkgAEGRKRApQZApDwsgAEE4aiIAQcu3ERBJIABBqykQKUGsKQ8LIABBOGoiAEHLtxEQSSAAQaspEClBrSkPC0HHKQ8LQcgpDwtBySkPC0HKKQ8LQcspDwtBzCkPC0HNKQ8LQc4pDwtBzykPC0HUKQ8LQdUpDwtB0ikPC0HTKQ8LQecpDwsgAEE4aiIAQd+3ERBJIABBpCkQKUGmKQ8LIABBOGoiAEHftxEQSSAAQaQpEClBpykPC0GaKQ8LQZspDwtBnCkPC0GdKQ8LQZ4pDwtBnykPC0GgKQ8LQaEpDwsgAEE4aiIAQYK4ERBJIABB/SkQKUH+KQ8LIABBOGoiAEGCuBEQSSAAQf0pEClB/ykPCyAAQThqIgBBgrgREEkgAEH9KRApQYAqDwsgAEE4aiIAQYK4ERBJIABB/SkQKUGBKg8LQf////8HIQELIAEL3wECAX8BfiMAQRBrIgMkAAJAIAINACAAKQIEIgRCgICAgICACINCLYinBH4gA0EXNgIMIAEgA0EMahCuAiAAKQIEBSAEC0KAgICAgIAQg0IuiKdFDQAgA0EVNgIMIAEgA0EMahCuAiADQRc2AgwgASADQQxqEK4CCwJ+IAApAgQiBBDaBwRAIANBEzYCDCABIANBDGoQrgIgACkCBCEECyAECxCEBwR+IANBGDYCDCABIANBDGoQrgIgACkCBAUgBAsQyAQEQCADQRk2AgwgASADQQxqEK4CCyADQRBqJAALBwAgACgCCAs9AQF/IwBBEGsiAiQAIAIgARCzAjYCACACQQhqIAAgASgCACACEOkKIAJBCGoQWiEAIAJBEGokACAAQQRqC70BAQN/IwBBEGsiASQAIAFBEzYCDAJAIABB3AJqIgIgAUEMahBDEB9FBEBBLBArIgMgABBXQQBBExBRGiABIAM2AgwgAUETNgIIIAIgAUEIahBDIAFBDGoQiwEgAEGQAmogAUEIaiABKAIMEEEiAhB/IAIQRyAAQegAaiABKAIMEJEBIAEoAgwhAAwBCyABQRM2AgggASACIAFBCGoQQygCBBCKASgCACIANgIMCyAAKAIEIQAgAUEQaiQAIAALFgEBfyAAEB8hAiAAIAEQqQEgABDtCgsZACAAIAFHBEAgACABKAIAIAEoAgQQxhILCwwAIAAgARClA0EYRgvaCAEHfyMAQTBrIgckAAJAAkAgAUG+fWoiBUHHAEsNAAJAAkACQAJAAkACQAJAAkACQCAFQQFrDkcBAQECAgICAgICAgICAwMEBAUFBQUFBQUFBQUFBQUFBQUFBQUFBQYGBgYGBgYHBwcHCQgICAgICAgICAgICAgICAgICAgICAALIABBOGpBPRApQf////8HIQhBzQIhBgwJCyAAQThqIgVBPRApIAVBPhApDAcLIABBOGoiBUE9ECkgBUHAABApDAYLIABBOGoiBUE9ECkgBUHBABApDAULIABBOGoiBUE9ECkgBUHCABApDAQLIABBOGoiBUE9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AgQQ5xYgACgCACIBBEAgABCpDBogARAwCwsgAQF/IAAoAgAhASAAQQA2AgAgAQRAIAEEQCABEDALCwsRACAAQRBqELMEIAAQswQgAAsRACAAEKcMIABBEGoQpwwgAAsOACAAEKoFIAAgATYCBAtVAQF/IAEQHwRAA0AgACABKAIAIAIQGhCLASAAIAAoAhRBAWo2AhQgAkEBaiICIAEQH0kNAAsLIAAgASgCDDYCDCAAIAEtABA6ABAgACABLQAROgARCycAIAEEQCAAIAEoAgAQuAggACABKAIEELgIIAFBEGoQwwwgARAwCwsfACABBEAgACABKAIAELkIIAAgASgCBBC5CCABEDALCxIAIAAQJygCACAAKAIAa0EMbQsfACABBEAgACABKAIAELsIIAAgASgCBBC7CCABEDALCxIAIAAQJygCACAAKAIAa0EYbQtJAQJ/AkAgABCvBQ0AIAAoAgQiASgCACAAIgIoAgAQsAUgABAnQQA2AgAgACABRg0AA0AgASIAKAIEIQEgABAwIAEgAkcNAAsLC4oCAQR/IABB9AZqEMcMIABB6AZqIgEgARBGELgIIABB3AZqECgaIABB0AZqECgaIABBxAZqIgEQyAwgAEGUBmohAwNAIAFBdGoiASICKAIABEAgAhCYAyACKAIAIQQgAhC8CBogBBAwCyABIANHDQALIABBiAZqIgEoAgAEQCABEJgDIAEoAgAhAiABEMQMGiACEDALIABB9AVqELQEIABB3AVqEIkFIABByAVqEMgMIABBtAVqEMcMIABB7ARqIgJByABqIQEDQCABQXRqIgEgARBGELsIIAEgAkcNAAsgAEG0BGoQghcgAEHEAGoQxgwgAEEcahC9CCAAQRBqECgaIABBBGoQKBogAAsJACAAEOQWIAALigQBAX8jAEEQayIEJAAgACABNgIAIABBBGoQThogAEEQahBOGiAAQRxqEL8IGiAAIAI2AiwgACADNgIoIABBMGoQyQwaIABBADYCQCAAQcQAahCTAxogAEIANwLMAyAAQQA6APwDIABCADcC1AMgAEEAOgDcAyAAQQA6ALAEIABBADYCrAQgAEEAOgCoBCAAQQA2AqQEIABCfzcCgAQgAEIANwKIBCAAQQA7AZAEIABCADcClAQgAEIANwCbBCAAQbQEahA3IQIgAEL/////DzcCzAQgAEIANwLEBCAAQQA6AMIEIABBADsBwAQgAEHsBGoiAUHIAGohAwNAIAEQkwNBDGoiASADRw0ACyAAQbQFahA3GiAAQQA2AMMFIABBADYCwAUgAEHIBWoQkwMaIABBADYA1wUgAEEANgLUBSAAQdwFahCkARogAEEANgLwBSAAQfQFahCkARogAEGIBmoQNxogAEHEBmohASAAQZQGaiEDA0AgAxA3QQxqIgMgAUcNAAsgAEHEBmoQkwMaIABB0AZqEE4aIABB3AZqEE4aIABB6AZqEJMDGiAAQfQGahA3GiAAQX82AvgDIABCfzcC8AMgAEEAOgDuAyAAQQA7AewDIABBATYC6AMgAEKBgICAEDcC4AMgAhCGFyAEQQA2AgwgAEHUBGogBEEMahDiFiAEQRBqJAAgAAssACAAEB8gACgCFEsEQANAIABBABC5BCAAEB8gACgCFEsNAAsLIAAQ1QEgAAs/AQF/IwBBEGsiASQAIAEgACgCEDYCCCABIAAoAhg2AgwgAEEcaiABQQhqEIMBIAAgACgCADYCECABQRBqJAALCwAgACABIAIQ0wwLGAAgASAAayIBBEAgAiABayAAIAEQmQMLC58BAgF/A34jAEGgAWsiBCQAIARBEGpBAEGQARDgARogBEF/NgJcIAQgATYCPCAEQX82AhggBCABNgIUIARBEGpCABDmAiAEIARBEGogA0EBEKUNIAQpAwghBSAEKQMAIQYgAgRAIAIgASABIAQpA4gBIAQoAhQgBCgCGGusfCIHp2ogB1AbNgIACyAAIAY3AwAgACAFNwMIIARBoAFqJAALDQAgACABIAJCfxDGBwsJACAAQSQQyQELLAEBfyMAQRBrIgMkACADQQhqIAEgAiACENQXIAAgA0EIahCVBSADQRBqJAALFgAgACABEIACGiAAIAIoAgA2AhAgAAu0AQEEfwJAAkAgAS0AAEEiRw0AIAEhBANAAkAgBEEBaiEFAkAgBCwAASIDQdsATARAIANBIkYNAiADQSdGDQQgA0EsRw0BDAQLIANB3ABHDQBB3AAhAyAELQACQdwARw0DIARBAmohBQsgAARAIAAgAmogAzoAAAsgAkEBaiECIAUhBAwBCwsgAEUNASAAIAJqQQA6AAAgAg8LIABFBEAgARDpDA8LIAAgARDdFyAAayECCyACCyAAIAAg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ACkCBCICEIQHBEAgASABKQIEQv///////32DIAJCgICAgICAAoOENwIEIAApAgQhAgsgAgsQyAQEQCABIAEpAgRC////////e4MgAkKAgICAgIAEg4Q3AgQgACkCBCECCyACQoCAgICAgAiDUEULBEAgASABKQIEQoCAgICAgAiENwIEIAApAgQhAgsgAkKAgICAgIAQg1BFCwR+IAEgASkCBEKAgICAgIAQhDcCBCAAKQIEBSACC0KAgICAgIABg1BFBEAgASABKQIEQoCAgICAgAGENwIECwuDAQECfwJAIAAQRiIDBEAgABA4IQACQANAIAIgA0EQaiIEEJcDBEAgAygCACIERQ0EIAMhACAEIQMMAQsgBCACEJcDRQ0BIANBBGohACADKAIEIgQEQCAEIQMMAQsLIAEgAzYCACAADwsgASADNgIAIAAPCyAAEDghAwsgASADNgIAIAMLHwAgAQRAIAAgASgCABDyCCAAIAEoAgQQ8gggARAwCwsLACAAIAEQ5RggAAsXACAAQQE6APwDIABB9AZqQf/0CRCaAgsSACAAIAEgAiADIAAoAggRCQALlAEBAn8CQCAAKAIAIgMgAygCACgCkAERBABBAUgNAEEAIQMDQCAAKAIEIAAoAgAiBCADIAQoAgAoAqABEQUAKAIEIAEgAyABKAIAKAKgAREFACgCBCACIAMgAigCACgCoAERBQAoAgQQ9QhFBEAgA0EBaiIDIAAoAgAiBCAEKAIAKAKQAREEAEgNAQwCCwtBAQ8LQQALIwEBfyAAp0E/cUFzaiIBQQNNBEBBDSABQQ9xdkEBcQ8LQQALuwMBA38jAEFAaiIEJAAgBCACNgI4AkAgAygCACIFQX9MBEAgACgCACgCoAEhAiAEIAU2AgAgACABQdy/EUGl+glBp+UJIAQgAhENACADQQA2AgAMAQsgAiACKAIAKAJwEQQAIQYgAigCACEFIAYEQCACIAUoAnQRBABFDQEgBEE4ahCMGQ0BIAMoAgAgAiACKAIAKAI8EQQASA0BIAAoAgAoAqABIQUgBCADKAIANgIQIAAgAUHcvxFBpfoJQb/lCSAEQRBqIAURDQAgAyACIAIoAgAoAjwRBABBf2o2AgAMAQsgAiAFKAJoEQQABEAgAygCACACIAIoAgAoAjARBABIDQEgACgCACgCoAEhBSAEIAMo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D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEMYJIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLVAEBfyMAQRBrIgIkACACIAAQtgEQhg8gAigCAEEIaiABEMYDIAAgAigCACIBIAEQsAcgABAnIgAgACgCAEEBajYCACACEMABIAIQwAEgAkEQaiQACw0AEM8CQRAQyQEQrAcLuAEBAX9BAiEBAkAgAEHrlgEQMg0AIABB8pYBEDINAEEHIQEgAEH/lgEQMg0AQRIhASAAQYeXARAyDQBBEyEBIABBjpcBEDINACAAQZOXARAyDQBBGyEBIABBn5cBEDINAEEcIQEgAEGzlwEQMg0AQR0hASAAQcWXARAyDQBBHiEBIABB1JcBEDINAEEfIQEgAEHjlwEQMg0AQSAhASAAQfaXARAyDQBBIUEAIABBgZgBEDIbIQELIAELfAEBfyMAQSBrIgMkACADIAE2AhAgAyAANgIYIAMgAjYCCCADQRhqIANBEGoQvAIEQANAIAMoAgggAygCGCwAACIAQSByIAAgAEG/f2pBGkkbOgAAIANBGGoQ6gMgA0EIahDqAyADQRhqIANBEGoQvAINAAsLIANBIGokAAtAAQF/IAAoAgwiAkEEcQR/IAAgARAmEK4HIAAgARAbELoCGiAAKAIMBSACC0ECcQRAIAEQG0GoDCgCABDcBhoLCwoAIAEgAGtBAnULBABBAAsWACAAQdCWATYCACAAQbSWATYCACAACwkAIAAgARDJAwsOACAAENACGiAAENACGgsTACAAQQA6AAQgAEGAAjYAACAAC50DAwN/AX4CfAJAAkACQAJAIAC9IgRCAFkEQCAEQiCIpyIBQf//P0sNAQsgBEL///////////8Ag1AEQEQAAAAAAADwvyAAIACiow8LIARCf1UNASAAIAChRAAAAAAAAAAAow8LIAFB//+//wdLDQJBgIDA/wMhAkGBeCEDIAFBgIDA/wNHBEAgASECDAILIASnDQFEAAAAAAAAAAAPCyAARAAAAAAAAFBDor0iBEIgiKchAkHLdyEDCyADIAJB4r4laiIBQRR2arciBUQAAOD+Qi7mP6IgBEL/////D4MgAUH//z9x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ASAGIAEgByAGIAaiIgEgASABIAEgAURzU2Dby3XzvqJEppI3oIh+FD+gokQBZfLy2ERDP6CiRCgDVskibW0/oKJEN9YGhPRklj+gokR6/hARERHBP6AgBiABIAEgASABIAFE1Hq/dHAq+z6iROmn8DIPuBI/oKJEaBCNGvcmMD+gokQVg+D+yNtXP6CiRJOEbunjJoI/oKJE/kGzG7qhqz+goqCioKKgoCIGoCEBIARFBEBBASACQQF0a7ciByAAIAYgASABoiABIAego6GgIgAgAKChIgCaIAAgAxsPCyACBHxEAAAAAAAA8L8gAaMiByABvUKAgICAcIO/IgggB71CgICAgHCDvyIBokQAAAAAAADwP6AgBiAIIAChoSABoqCiIAGgBSABCwsJACAAIAEQMxoLCgAgABCAATYCAAssAQF/IAAoAgQhAgNAIAEgAkcEQCAAEJoEGiACQXxqIQIMAQsLIAAgATYCBAsaAAJAIAAgAUYEQCAAQQA6AHAMAQsgARAwCwsJACAAQQA2AgALOABB0OARKAIAGkHQ4BEoAgBB0OAREJkEQQJ0ahpB0OARKAIAQdDgERCZBEECdGoaQdDgESgCABoLCQAgACABEN8PC0YBAn8jAEEQayIAJABB0OAREJoEGiAAQf////8DNgIMIABB/////wc2AgggAEEMaiAAQQhqENMBKAIAIQEgAEEQaiQAIAELCQAgABC/BxAwCxYAIABFBEBBAA8LQdjJESAANgIAQX8LEgAgAEUEQEEADwsgACABEJsECxUAIABBwNMANgIAIABBEGoQKBogAAsVACAAQZjTADYCACAAQQxqECgaIAALBABBBAtCAQJ/IwBBEGsiASQAIAEgADYCDCABQQhqIAFBDGoQiwMhAEEEQQFBlMkRKAIAKAIAGyECIAAQigMgAUEQaiQAIAILPgEBfyMAQRBrIgUkACAFIAQ2AgwgBUEIaiAFQQxqEIsDIQQgACABIAIgAxD9BiEAIAQQigMgBUEQaiQAIAALEgAgBCACNgIAIAcgBTYCAEEDCygBAX8gAEG00gA2AgACQCAAKAIIIgFFDQAgAC0ADEUNACABEDALIAALBAAgAQscACABKAIAEJkGIAAoAgAQuAUgACABKAIANgIACxQAIAAQvxAoAgAiADYCACAAEJkGCzQAIAAoAgAaIAAoAgAg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CigCADYAACAKIAAQ7AILIAggChDYASAKECgaIAQgABDWAjoAACAFIAAQkgI6AAAgCiAAEJECIAYgChDYASAKECgaIAogABDtAiAHIAoQ2AEgChAoGiAAEOcDDAELIAIQmgohAAJAIAEEQCAKIAAQ6QMgAyAKKAIANgAAIAogABDoAwwBCyAKIAAQmwYgAyAKKAIANgAAIAogABDsAgsgCCAKENgBIAoQKBogBCAAENYCOgAAIAUgABCSAjoAACAKIAAQkQIgBiAKENgBIAoQKBogCiAAEO0CIAcgChDYASAKECgaIAAQ5wMLNgIAIApBEGokAAsKACAAEIwKQQFzCzIBAX8jAEEQayICJAAgAiAAKAIANgIIIAJBCGogARCaBhogAigCCCEAIAJBEGokACAACwsAIABBoNMREKwDCwsAIABBqNMREKwDC1gBAn8jAEEQayIBJAACQCAAEMsBBEAgACgCACECIAFBADYCDCACIAFBDGoQpwIgAEEAEKkBDAELIAFBADYCCCAAIAFBCGoQpwIgAEEAENYBCyABQRBqJAALFQAgACABKAIAEO8NIAEoAgAQygEaC/UNAQh/IwBBsARrIgskACALIAo2AqQEIAsgATYCqAQgC0ElNgJgIAsgC0GIAWogC0GQAWogC0HgAGoQowEiDygCACIBNgKEASALIAFBkANqNgKAASALQeAAahBOIREgC0HQAGoQ0wIhDiALQUBrENMCIQwgC0EwahDTAiENIAtBIGoQ0wIhECACIAMgC0H4AGogC0H0AGogC0HwAGogESAOIAwgDSALQRxqENcQIAkgCCgCADYCACAEQYAEcSESQQAhAUEAIQQDQCAEIQoCQAJAAkAgAUEERg0AIAAgC0GoBGoQhwJFDQACQAJAAkAgC0H4AGogAWosAAAiAkEESw0AQQAhBAJAAkACQAJAAkAgAkEBaw4EAAQDBwELIAFBA0YNBCAHQYDAACAAEKgBEPcCBEAgC0EQaiAAEJUKIBAgCygCEBCTBgwCCyAFIAUoAgBBBHI2AgBBACEADAgLIAFBA0YNAwsDQCAAIAtBqARqEIcCRQ0DIAdBgMAAIAAQqAEQ9wJFDQMgC0EQaiAAEJUKIBAgCygCEBCTBgwAAAsACyAMECZBACANECZrRg0BAkAgDBAmBEAgDRAmDQELIAwQJiEDIAAQqAEh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AEEERhsgAEEBRhsPCyAAIAAoAgAoAiwRBAApAgQQwwJFDQBBCEEJQf////8HIAAgACgCACgCLBEEACkCBEI3iKdBD3EiAEEERhsgAEEBRhshAQsgAQsLACAAIAFBOBBAGguRBwECfiAAKQIEIgJCgICAgICAgDiDUARAIAAgASkCBEKAgICAgICAOIMgAkL/////////R4OEIgI3AgQLAn8CfwJ/An8CfwJ/An8CfwJ/An8CfwJ/An8CfwJ/An8CfwJ/IAEpAgQiA0KAgIDAAINQRQRAIAAgAkKAgIDAAIQiAjcCBCABKQIEIQMLIANCgICAgASDUEULBEAgACACQoCAgIAEhCICNwIEIAEpAgQhAwsgA0KAgICAAYNQRQsEQCAAIAJCgICAgAGEIgI3AgQgASkCBCEDCyADQoCAgIDAAINQRQsEQCAAIAJCgICAgMAAhCICNwIEIAEpAgQhAwsgA0KAgICAgAGDUEULBEAgACACQoCAgICAAYQiAjcCBCABKQIEIQMLIANCgICAgIAEg1BFCwRAIAAgAkKAgICAgASEIgI3AgQgASkCBCEDCyADQoCAgICACINQRQsEQCAAIAJCgICAgIAIhCICNwIEIAEpAgQhAwsgA0KAgICAgBCDUEULBEAgACACQoCAgICAEIQiAjcCBCABKQIEIQMLIANCgICAgIAgg1BFCwRAIAAgAkKAgICAgCCEIgI3AgQgASkCBCEDCyADQoCAgICAwACDUEULBEAgACACQoCAgICAwACEIgI3AgQgASkCBCEDCyADQoCAgICAgAiDUEULBEAgACACQoCAgICAgAiEIgI3AgQgASkCBCEDCyADQoCAgICAgCCDUEULBEAgACACQoCAgICAgCCEIgI3AgQgASkCBCEDCyADQoCAgICAgMAAg1BFCwRAIAAgAkKAgICAgIDAAIQiAjcCBCABKQIEIQMLIANCgICAgICAgAGDUEULBEAgACACQoCAgICAgIABhCICNwIEIAEpAgQhAwsgA0KAgICAgICAAoNQRQsEQCAAIAJCgICAgICAgAKEIgI3AgQgASkCBCEDCyADQoCAgICAgIAEg1BFCwRAIAAgAkKAgICAgICABIQiAjcCBCABKQIEIQMLIANCgICAgICAEINQRQsEQCAAIAJCgICAgICAEIQiAjcCBCABKQIEIQMLIANC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ACgCUBEEACIFIAUoAgAoAsQBEQQAIgUgBSgCACgCGBEEACAEEJILIABBOGogASAAIAIgAigCACgCeBEEABDDASADIAQQrAYhACAEEEUgBkEQaiQAIAAL6wsBBn8jAEEQayIJJAAgCSAENgIMIAUQjQUhC0F/IQoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQcl+aiIMQfwCSwRAIAFBemoiBkEITQ0BIAFB4HpqIgFBC0sNSQJAAkACQAJAAkAgAUEBaw4LAgMETk5OTk5OTgABC0GeASEBDEsLQcwBIQEMSgtBzQEhAQxJC0HJACEHDEULQcsAQcoAIAUQ4gMbIQcMRAtBISEHIAxBAWsO/AJBQD8+PD07NTY3OTo4SDIxMC8uLRUULCsIBiopSEhISEhISCgnSEhIAwMDAwMDAwMDAwMDJiUkIyAfHh0iIRwbAwMDAwMDAwMDAwMDAwMDAwMDAwM0SEhIM0hISEhISBoZGBMSERAPDg1ISEhISEMBREhISEhISEhISEhISEgLSAsLCwtISEhISEhICgoKSAoKCkgKCgoKCkhISEgKCgoKCgoKCgoKCgoKCgoKCgoKCgpISEhISEhISAoKCgRISEhISEhISEhISEhISEhISEhISEhICwsLCwsLCwsLCwsLCwsLCwsLSEhICQcFSEhISEhISEhISEgMDAxISEhISEhISEgXFkhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhIA0ILQagBIQECQCAGQQFrDghGRgBISEhIAkULQcgBIQEMRQtBIiEHDEELQdMAIQEMQwtB/AAhAQxCC0GwKSEBDEELIABBnbQREIMDIQoLQQIhBww8CyAAQZ20ERCDAyEKC0EBIQcMOgsgAEHAshEQgwMhCkEEIQcMOQsgCRA3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RiAGQoCAgIB4U3JFQQAgBkL/////B1cbRQRAIAJBBDYCAEH/////ByAGQgFZDQMaQYCAgIB4DAMLIAanDAILCyACQQQ2AgBBAAshACAEQRBqJAAgAAspAQF/IAAoAhQiASABKAIAKAIwEQQAQUBrKAIAKAIAIAAoAhgQRCgCAAsfACAAIAEgAkEDdkH8////AXFqQQEgAkEfcXQQygEaCzwBAX9B/////wcgAUkEQBB9AAsgAUF/akEFdkEBaiIBEM0CIQIgAEEANgIEIAAgAjYCACAAECcgATYCAAsmAQF/IwBBEGsiAiQAIAIgATYCDCAAQZqWASABEJsMIAJBEGokAAtJAQF/IwBBEGsiAyQAIABCADcCACADQQA2AgwgAEEIaiADQQxqENICIAEEQCAAIAEQhQwgACABIAItAAAQkBYLIANBEGokACAACwgAIAAQmgEaC2wBAn8jAEEQayIEJAAgBEEANgIMIABBDGogBEEMaiADEKYCIAEEQCAAKAIQKAIAIAEQgw4hBQsgACAFNgIAIAAgBSACQQR0aiICNgIIIAAgAjYCBCAAEDogBSABQQR0ajYCACAEQRBqJAAgAAsVACAAQdyyDzYCACAAQRRqED0aIAALMQAgAEG0+g42AgAgACABKAIEEBsQvwE2AgQgASgCCCEBIABBAToAECAAIAE2AgggAAs7AQF/IAAgAUcEQCACKAIAIQMDQCADQXRqIAFBdGoiARCBBCACIAIoAgBBdGoiAzYCACAAIAFHDQALCwsMACAAKAIUIAEQjAMLMgEBfyAAKAIEIgIgABAnKAIARwRAIAIgARCBBCAAIAAoAgRBDGo2AgQPCyAAIAEQqxYLBwAgAEEkagsOACAAIAEgARCcARCoFguFAQEEfyMAQRBrIgIkACAAQbCxDzYCACACIABBFGoiAygCABAkIgE2AgggASAAKAIYECQQJQRAA0AgASgCBCIBBEAgASABKAIAKAIEEQgACyACQQhqEIAFIAAoAhgQJCEEIAIoAggiASAEECUNAAsLIABBJGoQPRogAxC1ASACQRBqJAAgAAtoAQJ/IAAgACgCACgCRBEEACICBEAgAUEQakH2sA8QGCEDIAJBAU4EQEEAIQEDQCADIAAgACgCACgCSBEEACABQQJ0aigCABAYQfuwDxAYGiABQQFqIgEgAkcNAAsL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FBEOACACIAIpAgxC/////////794g0KAgICAgICAwAKENwIMDwsgACABQQFB7JYLQfCWCyAAKAIAKAIUEQ4AIAJBAToAiAEPCyAAIAFBAkHMlQtB1JULIAAoAgAoAhQRDgAgAEGSuw8gACgCACgCIBEFAARAIAJBAToAdAsgAkEBOgB1C0MBAX8jAEEQayIDJAAgARA4IQEgAEEUECsgA0EIaiABEOQBEJABIgAoAgBBEGogAhCYASAAEDhBAToABCADQRBqJAALLwEBfyMAQRBrIgMkACADQQhqIAEgAigCACACEIIYIAAgA0EIahCVBSADQRBqJAALSAAgABDKFyAAQQA6ADAgAEGAcDYCLCAAQQA2ACUgAEEAOgAkIAAgACgCIEGAgOAPcjYCICAAEMkXIAAgACgCIEGA/h9yNgIgCygAIAJBEhCQAwRAIAAgAUHZjgsgA0HcvxFBACAAKAIAKAKgARENAAsLPwEBfyAAIAAoAlgiAkEBTgR/IAAgAUHjjQtB3L8RQdy/EUEAIAAoAgAoAqABEQ0AIAAoAlgFIAILQQFqNgJYC9YGAgJ/AX4jAEEQayIFJAACQAJ+IAIpAgQiBhDYAgRAIAMgAygCACgCKBEEACIEIAQpAgRC////////b4MgBkKAgICAgIAQg4Q3AgQgAikCBCEGIAMgAygCACgCKBEEACIEIAQpAgRC////////d4MgBkKAgICAgIAIg4Q3AgQgAikCBCEGIAMgAygCACgCKBEEACIEIAQpAgRC////////X4MgBkKAgICAgIAgg4Q3AgQgAikCBCEGIAMgAygCACgCKBEEACIEIAQpAgRC////////v3+DIAZCgICAgICAwACDhDcCBCACKQIEIQYgAyADKAIAKAIoEQQAIgQgBCkCBEL/////////foMgBkKAgICAgICAAYOENwIEIAIpAgQhBiADIAMoAgAoAigRBAAiBCAEKQIEQv////////99gyAGQoCAgICAgIACg4Q3AgQgAikCBCEGIAMgAygCACgCKBEEACIEIAQpAgRC/////////3uDIAZCgICAgICAgASDhDcCBCACKQIEIQYgAyADKAIAKAIoEQQAIgQgBCkCBEL///////99gyAGQoCAgICAgAKDhDcCBCACKQIEIQYgAyADKAIAKAIoEQQAIgQgBCkCBEL///////97gyAGQoCAgICAgASDhDcCBCACKQIEIQYgAyADKAIAKAIoEQQAIgQgBCkCBEL///////9+gyAGQoCAgICAgAGDhDcCBCACKQIEIQYLIAYLEPoBRQRAIAYQrwJFDQELIAAgAUHCiwtB3L8RQdy/EUEAIAAoAgAoAqABEQ0ACyACEPECBEAgACABQYuMC0HcvxFB3L8RQQAgACgCACgCoAERDQALAkACfiACKQIEIgZCgICAwACDUEUEQCAAIAFBwIwLQdy/EUHcvxFBACAAKAIAKAKgARENACACKQIEIQYLIAYLEN8DRQ0AIAYQlgUEQCADIAMoAgAoAigRBAAQ7AgMAQsgACABQfeMC0Hkmw5B3L8RQQAgACgCACgCpAERDQALIAUgAikCBCIGEPoCBH4gAyADKAIAKAIoEQQAIgQgBCkCBEL/////b4MgBkKAgICAEIOENwIEIAIpAgQFIAYLp0E/cTYCDCAAIAEgBUEMaiADENcIIAVBEGokAAsiAQF/QQEhAQJAIAAQmAINACAAEOoFDQAgABCOAyEBCyABCysAIAAoArQEIAEQswEiACgCDCIBQf//AEcEQCABIAJGDwsgACACNgIMQQELmAoCAn8CfiMAQRBrIgMkAAJAIAIpAgRCP4NCB1INACACEPECRQ0AIAAgAUHQhQtB3ZsOQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAIQrgNFDQAgAhCGAg0AIAAgAUGEhgtBs/cKQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAIQhQRFDQACQCACKAIEQT9xQX1qIgRBA0sNAAJAAkACQCAEQQFrDgMBAgIACwJAAkAgACgCCBA+RQ0AIAAoAhBBtQJKDQAgACABQQBBr4YLEMICDAELIAAgAUFfQa+GCxDZAQsgACgCFEUEQCADQdCGCykDADcDCCAAIAFBd0HKAkECIANBCGpBr4YLENoBIAAgAUEIQawCQQBBr4YLEC4MAwsgACABQXdBmgNBhLcPQa+GCxAuIAAgAUEIQbYCQQBBr4YLEC4MAgsCQAJAIAAoAggQPkUNACAAKAIQQbUCSg0AIAAgAUEEQdiGCxDCAgwBCyAAIAFBX0HYhgsQ2QELIAAoAhRBBEYEQCADQdCGCykDADcDCCAAIAFBd0HKAkECIANBCGpB2IYLENoBIAAgAUEIQawCQQBB2IYLEC4MAgsgACABQXdBmgNBhLcPQdiGCxAuIAAgAUEIQbYCQQBB2IYLEC4MAQsgACABQQ9B9YYLEFwgACABQXdBygJBpLgPQfWGCxAuIAAgAUF3Qa4DQcS4D0H1hgsQLiAAIAFBCEG2AkEAQfWGCxAuCyACKQIYEL4ERQ0AIAIpAgRCP4NCBFIEQCAAIAFBnYcLQbuHC0HcvxFBACAAKAIAKAKgARENAAsgAhCGAg0AIAAgAUHBhwtBu4cLQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAIpAhgiBRDwAkUNACACKQIEIgYQuAINACAGEMMCDQAgACABQeyHC0Gk/QpB3L8RQQAgACgCACgCoAERDQAgAikCGCEFCwJAIAUQrwNFDQAgAikCBBDkAg0AIAAgAUGdhwtBmYgLQdy/EUEAIAAoAgAoAqABEQ0AIAIpAhghBQsCQCAFEI4NRQ0AIAIpAgQQ5AINACAAIAFBnYcLQaCIC0HcvxFBACAAKAIAKAKgARENAAsCQCACENgIRQ0AIAIpAgQiBRC4Ag0AIAUQwwINAAJAIAUQvwRFBEAgBRCPA0UNAQsgACABQbWIC0Gg9QpB3L8RQQAgACgCACgCoAERDQALIAIoAgwQtAFFBEAgAigCEBC0AUUNAQsgACABQfqIC0Gg9QpB3L8RQQAgACgCACgCoAERDQALAkAgAi0AJRA2RQ0AIAIpAgRCP4NCBVIEQCAAIAFBr4kLQav2CkHcvxFBACAAKAIAKAKgARENAAsgAhCRBUUNACAAIAFBz4kLQfGJC0HcvxFBACAAKAIAKAKgARENAAsCQCACLQAmEDZFDQAgAikCBEI/g0IGUQ0AIAAgAUH1iQtB2YMLQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAItADAQNkUNACACKQIEQj+DQgZSBEAgACABQZKKC0Hc9gpB3L8RQQAgACgCACgCoAERDQALIAIpAhgQ8AIEQCAAIAFBsYoLQaT9CkHcvxFBACAAKAIAKAKgARENAAsgAhCRBUUNACAAIAFBsYoLQfGJC0HcvxFBACAAKAIAKAKgARENAAsCQCACKQIEQj+DQgpSDQAgAhDxAkUNACAAIAFB1IoLQbicDkHcvxFBACAAKAIAKAKgARENAAsgA0EQaiQAC0kBAX9BASEBAkAgABDYCA0AIAAQhQQNACAAKQIYEK8DDQAgAC0AJBA2DQAgAC0AMBA2DQAgAC0AJRA2DQAgAC0AJhA2IQELIAELzgICBn8BfiMAQRBrIgIkAAJAIAApAhgiCBCYAkUNACAIEI4DRQ0AIAIgCEIyiKdB/z9xIgM2AgwgACABEEIEfgNAIAEoAgAgBRBEKAIAIgQgBCgCACgCKBEEACEEIAJBADoACyACQQA6AAogAkEAOgAJIAEoAgAgBRBEKAIAIAJBC2ogAkEKaiACQQlqEO8GIQcCQCAEKQIYIggQjgNFBEBBCCEGAkACQCACLQALDQBBBCEGIAItAAoNAEECIQYgAi0ACUUNAQsgAkEMaiAGEJcCIAQpAhghCCACKAIMIQMLIAQgCEL/////////gYB/gyADQf8/ca1CMoaENwIYDAELIAIgCEIyiKdB/z9xIgM2AgwLIAIgAyAHaiIDNgIMIAVBAWoiBSABEEJJDQALIAApAhgFIAgLQoCAgICAgID+/wCENwIYCyACQRBqJAALogEBAX8gACAAKAIAKAIkEQQABEAgACAAKAIAKAIAEQQAIgEgACAAKAIAKAI8EQQAIAEoAgAoAjgRAgAgAQ8LIAAgACgCACgCLBEEACIBIAEoAgAoAlgRBAAiACAAKAIAKAIAEQQAIgBB3L8REL8BIAAoAgAoAhARAgAgACABIAEoAgAoAlgRBAAiASABKAIAKAI8EQQAIAAoAgAoAjgRAgAgAAtJAQF/IwBBkAFrIgMkACADQQBBkAEQ4AEiA0F/NgJMIAMgADYCLCADQSM2AiAgAyAANgJUIAMgASACEJgYIQAgA0GQAWokACAAC9cBAQJ/AkACQCACIAIoAgAoAigRBAApAgQQ8wJFDQACQCADBEAgAiACKAIAKAJwEQQADQEMAwsgAigCPBCwA0UNAgtBBCEEIAAtAKQBRQRAIABBqAlqKAIAIQQLIAIgAigCACgCUBEEACADQQFzIgUQ+wEiA0UgAyAERnJFBEAgACABQankCkHelg5B3L8RQQAgACgCACgCoAERDQAPCyADDQAgAiACKAIAKAJQEQQAIAUgBBDGBAsPCyAAIAFB9+QKQcybDkHcvxFBACAAKAIAKAKgARENAAtFAQJ/QQEhASAAKAIEIgIQyQJBAUoEQANAIAAgARCSBUUEQCAAIAFBARDGBCAAKAIEIQILIAFBAWoiASACEMkCSA0ACwsLbwEBfgJAIAIpAgQiA0I/g0ICUQR+IAAgAUEBQfgAQaa2D0GF3QoQLiAAIAFBCEGsAkEAQYXdChAuIAIpAgQFIAMLQj+DQgNSDQAgACgCFA0AIAAgAUF3Qb3NChBcIAAgAUEBQZYBQQBBvc0KEC4LC04AAkAgAEUNACABQQJqIgFBBUsNAAJAAkACQAJAIAFBAWsOBQECAgQDAAsgACACPAAADwsgACACPQEADwsgACACPgIADwsgACACNwMACws3AQF/An8gASgCACICQQ5GBEAgACABQQRqEPkFQQJ0akG8CWoMAQsgACACQQJ0akHsBWoLKAIAC/4NAgF/An4CQAJAIAAoAkwQIEUNAAJAIAMoApgBIgQEQCAEEIkCDQELAkAgAikCBCIFQoCAgICAgP8Dg1ANACADIgQoAgBBDkYEfyAEQQRqEJUEBUEACw0AIAMpAgxCP4NCBlENACAAIAFBg8sKQdy/EUHcvxFBACAAKAIAKAKgARENAAwBCyAFENgCRQ0AIAMoAgBBDkYNACADKQIMELgCDQAgACABQYPLCkHcvxFB3L8RQQAgACgCACgCoAERDQALAkAgAikCBCIFQj+DQgZSDQAgAygCAEEQRg0AIAItACYQNg0AIAAgAUGxywpBkpwOQdy/EUEAIAAoAgAoAqABEQ0AIAIpAgQhBQsgBadBP3FBfWpBAUsNACADLQB8EDYEQCAAIAFB2MsKQerGCkHcvxFBACAAKAIAKAKgARENAAsCfyADKAIAIgRBDEcEQCAEEKECDAELIAAtAKQBRQ0CQQwQoQILRUEAIARBAkcbRQRAIAAgAUEIQawCQQBBkcwKEC4LAkAgAikCBCIFQoCAgIAEg0IAUg0AIAUQgQcgBUKAgICAgAKDQiSIp3INAAJAIAMoAgAiBBChAiAEQQJGcg0AIAMoApgBIgRFDQEgBEEIIAQoAgAoArABEQUADQAgAygCmAEiBEEJIAQoAgAoArABEQUADQAgAygCmAEQxwINACADKAKYARDaAg0AIAMoApgBEJkYDQAgAygCmAEiBEECIAQoAgAoArABEQUARQ0BCyACKQIEIgVCP4NCfXwiBkIBVg0AIAanQQFrBEAgACgCFEEERw0BIAAgAUGlzAogAygCABCUBCAFp0E/cRDyAkEAIAAoAgAoAqABEQ0ADAELIAAoAhQNACAAKAIQQawCRw0AIAAgAUGlzAogAygCABCUBCAFp0E/cRDyAkEAIAAoAgAoAqABEQ0ACwJAIAIpAgQiBRDrBUUNACAFEK8CRQ0AIAAgAUG/zApBq5wOQdy/EUEAIAAoAgAoAqABEQ0AIAIpAgQhBQsgBRDDAkUgAygCAEEQRnJFBEAgACABQe7MCkHWmw5B3L8RQQAgACgCACgCoAERDQAgAikCBCEFCyAAKAIUIQQgBUI/g0IDUQRAIARBBUsNAQJAAkACQAJAIARBAWsOBQMFBQECAAsgAygCACIEQQ9GBEAgACABQZ7NCkEDEPICQdy/EUEAIAAoAgAoAqABEQ0ADwsgAygClAEEfyAAIAFBd0G9zQoQXCAAIAFBAUGWAUEAQb3NChAuIAMoAgAFIAQLQQJGBEAgACABQXdBmgNBAEHRzQoQLgsCQCACKQIEIgUQ+gENACAFEK8CDQAgBRDYAiECIAVCgICAwACDQgBSDQAgAkUNBQsgACABQfPNCkHcvxFB3L8RQQAgACgCACgCoAERDQAPCyADKAKYAUUNAyAAIAFBCEGsAkEAQZzOChAuIAAgAUF3QZYBQQBBnM4KEC4gAygCmAEiAiACKAIAKAK4AREEAARAIAAgAUF3QbnOChBcCyADKAKYASICIAIoAgAoArQBEQQARQ0DIAAgAUF3QevOChBcDwsgACgCTBAsDQIgACABQZzPCkH6mw5B3L8RQQAgACgCACgCoAERDQAPCyAFQoCAgICAIINQDQEgACABQd7PCkGrnA5B3L8RQQAgACgCACgCoAERDQAPCyAEQQVLDQACQAJAAkACQCAEQQFrDgUEAwQBAgALIAMoApgBRQ0DIAAgAUEIQawCQQBBlNAKEC4gACABQXdBlgFBAEGU0AoQLiADKAKYASICIAIoAgAoArgBEQQABEAgACABQXdBsNAKEFwLIAMoApgBIgIgAigCACgCtAERBABFDQMgACABQXdB4dAKEFwPCyAAIAFBCEGsAkEAQZHRChAuIAMoAgBBD0YEQCAAIAFBqNEKIAIoAgRBP3EQ8gJB3L8RQQAgACgCACgCoAERDQAPCyACKQIEIQUgAy8BkAFBFHRBEHVBgCBOBEAgACABQb7RCiAFp0E/cRDyAkHcvxFBACAAKAIAKAKgARENAA8LIAUQ+gEEfiAAIAFB0dEKQYTSCkHcvxFBACAAKAIAKAKgARENACACKQIEBSAFCxCvAgRAIAAgAUGa0gpB0dIKQdy/EUEAIAAoAgAoAqABEQ0ACyADKAIAIgNBC0tBASADdEGEGHFFcg0CIAAgAUHr0gogAigCBEE/cRDyAkHcvxFBACAAKAIAKAKgARENAA8LIAAgAUGV0wpB/ZsOQdy/EUEAIAAoAgAoAqABEQ0ADwsgBUKAgICAgCCDUA0AIAAgAUHY0wpBq5wOQdy/EUEAIAAoAgAoAqABEQ0ACw8LIAAgAUGCzAogAigCBEE/cRDyAkHcvxFBACAAKAIAKAKgARENAAu2AwIDfwF+IwBBIGsiAyQAAkAgAUL///////////8AgyIFQoCAgICAgMC/QHwgBUKAgICAgIDAwL9/fFQEQCABQhmIpyECIABQIAFC////D4MiBUKAgIAIVCAFQoCAgAhRG0UEQCACQYGAgIAEaiECDAILIAJBgICAgARqIQIgACAFQoCAgAiFhEIAUg0BIAJBAXEgAmohAgwBCyAAUCAFQoCAgICAgMD//wBUIAVCgICAgICAwP//AFEbRQRAIAFCGYinQf///wFxQYCAgP4HciECDAELQYCAgPwHIQIgBUL///////+/v8AAVg0AQQAhAiAFQjCIpyIEQZH+AEkNACADIAAgAUL///////8/g0KAgICAgIDAAIQiBUGB/wAgBGsQ3QQgA0EQaiAAIAUgBEH/gX9qEIECIAMpAwgiAEIZiKchAiADKQMAIAMpAxAgAykDGIRCAFKthCIFUCAAQv///w+DIgBCgICACFQgAEKAgIAIURtFBEAgAkEBaiECDAELIAUgAEKAgIAIhYRCAFINACACQQFxIAJqIQILIANBIGokACACIAFCIIinQYCAgIB4cXK+C4YBAQJ/AkAgAkKAgIDAAINQDQAgAhDkAiEDIAIQzgIhBCAAKAIQQawCTgRAIAMNASAAIAFBpMoKQcCaDkHcvxFBACAAKAIAKAKgARENAA8LIAMgBHJBAUYEQCAAKAIUIARBAXNyDQELIAAgAUHAygpBwJoOQdy/EUEAIAAoAgAoAqABEQ0ACwv9AwIDfwF+AkACfyAAKAIEIgIgACgCaEkEQCAAIAJBAWo2AgQgAi0AAAwBCyAAEHsLIgNBVWoiAkECTUEAIAJBAWsbRQRAIANBUGohAQwBCyADQS1GIQQCQCABRQJ/IAAoAgQiAiAAKAJoSQRAIAAgAkEBajYCBCACLQAADAELIAAQewsiAkFQaiIBQQpJcg0AIAAoAmhFDQAgACAAKAIEQX9qNgIECyACIQMLAkAgAUEKSQRAQQAhAQNAIAMgAUEKbGohAQJ/IAAoAgQiAiAAKAJoSQRAIAAgAkEBajYCBCACLQAADAELIAAQewsiA0FQaiICQQlNQQAgAUFQaiIBQcyZs+YASBsNAAsgAawhBQJAIAJBCk8NAANAIAOtIAVCCn58QlB8IQUCfyAAKAIEIgEgACgCaEkEQCAAIAFBAWo2AgQgAS0AAAwBCyAAEHsLIgNBUGoiAkEJSw0BIAVCro+F18fC66MBUw0ACwsgAkEKSQRAA0ACfyAAKAIEIgEgACgCaEkEQCAAIAFBAWo2AgQgAS0AAAwBCyAAEHsLQVBqQQpJDQALCyAAKAJoBEAgACAAKAIEQX9qNgIEC0IAIAV9IAUgBBshBQwBC0KAgICAgICAgIB/IQUgACgCaEUNACAAIAAoAgRBf2o2AgRCgICAgICAgICAfw8LIAULQQAgASABKAIAKAKEAREEACkCBBCgAkUEQCAAIAEgASgCACgCABEEAEHIvgogAkHcvxFBACAAKAIAKAKgARENAAsLTgECfyMAQRBrIgUkACAEEBshBCADEBshAyAAKAIAKAKgASEGIAUgAzYCBCAFIAQ2AgAgACABQdy/ESACQae+CiAFIAYRDQAgBUEQaiQACwoAIAAtAAQQlAQLzQEBAn8jAEGwAWsiBCQAIARB2ABqIAIQ3gMiAhAnIgMgAykCBEL///9HgzcCBCACEIIGBEAgACABQQFB+ABBprYPQey8ChAuIAAgAUEIQawCQQBB7LwKEC4LIAIQiQkiA0UEQCAAIAFBgL0KIAIQoA1B3L8RQQAgACgCACgCoAERDQAgAiAEQQFBAEEBQQBBAEEAEEgiABCVASAAED0aQdMDIQMLIARB3L8RECohAEGYARB0IAAgAiADEO8FIQAgAhA9GiAEQbABaiQAIAALqAQAAkAgAiACKAIAKAIcEQQAQQ9HDQAgAkEDEJADRQ0AIAAgASADQd25CiAAKAIAKAJQEQwACwJAIAIgAigCACgCcBEEAEUNACACIAIoAgAoAhwRBABBA0cNACAAIAEgA0GHugogACgCACgCUBEMAAsCQCACIAIoAgAoAhwRBABBD0cNACACQQYQkANFDQAgACABIANBsLoKIAAoAgAoAlwRDAALAkAgAiACKAIAKAJwEQQARQ0AIAIgAigCACgCHBEEAEEGRw0AIAAgASADQdi6CiAAKAIAKAJcEQwACwJAIAIgAigCACgCHBEEAEEPRw0AIAJBBxCQA0UNACAAIAEgA0H/ugogACgCACgCXBEMAAsCQCACIAIoAgAoAnARBABFDQAgAiACKAIAKAIcEQQAQQdHDQAgACABIANBqLsKIAAoAgAoAlwRDAALAkAgAiACKAIAKAIcEQQAQQ9HDQAgAkEEEJADRQ0AIAAgASADQdC7CiAAKAIAKAJoEQwACwJAIAIgAigCACgCcBEEAEUNACACIAIoAgAoAhwRBABBBEcNACAAIAEgA0H3uwogACgCACgCaBEMAAsCQCACIAIoAgAoAhwRBABBD0cNACACQQUQkANFDQAgACABIANBnbwKIAAoAgAoAmgRDAALAkAgAiACKAIAKAJwEQQARQ0AIAIgAigCACgCHBEEAEEFRw0AIAAgASADQcW8CiAAKAIAKAJoEQwACwsRACAAIAEgAhAbIAIQJhCJBgsJACAAIAEQphgLhQgCBX8CfiMAQTBrIgUkAAJAIAJBAk0EQCACQQJ0IgJB7C9qKAIAIQcgAkHgL2ooAgAhCANAAn8gASgCBCICIAEoAmhJBEAgASACQQFqNgIEIAItAAAMAQsgARB7CyICEJwEDQALAkAgAkFVaiIEQQJLBEBBASEGDAELQQEhBiAEQQFrRQ0AQX9BASACQS1GGyEGIAEoAgQiAiABKAJoSQRAIAEgAkEBajYCBCACLQAAIQIMAQsgARB7IQILQQAhBAJAAkADQCAEQZwvaiwAACACQSByRgRAAkAgBEEGSw0AIAEoAgQiAiABKAJoSQRAIAEgAkEBajYCBCACLQAAIQIMAQsgARB7IQILIARBAWoiBEEIRw0BDAILCyAEQQNHBEAgBEEIRg0BIANFIARBBElyDQIgBEEIRg0BCyABKAJoIgIEQCABIAEoAgRBf2o2AgQLIANFIARBBElyDQADQCACBEAgASABKAIEQX9qNgIECyAEQX9qIgRBA0sNAAsLIAUgBrJDAACAf5QQ3xggBSkDCCEJIAUpAwAhCgwCCwJAAkACQCAEDQBBACEEA0AgBEGlL2osAAAgAkEgckcNAQJAIARBAUsNACABKAIEIgIgASgCaEkEQCABIAJBAWo2AgQgAi0AACECDAELIAEQeyECCyAEQQFqIgRBA0cNAAsMAQsCQAJAIARBA0sNACAEQQFrDgMAAAIBCyABKAJoBEAgASABKAIEQX9qNgIECwwCCwJAIAJBMEcNAAJ/IAEoAgQiBCABKAJoSQRAIAEgBEEBajYCBCAELQAADAELIAEQewtBIHJB+ABGBEAgBUEQaiABIAggByAGIAMQpBggBSkDGCEJIAUpAxAhCgwFCyABKAJoRQ0AIAEgASgCBEF/ajYCBAsgBUEgaiABIAIgCCAHIAYgAxChGCAFKQMoIQkgBSkDICEKDAMLAkACfyABKAIEIgIgASgCaEkEQCABIAJBAWo2AgQgAi0AAAwBCyABEHsLQShGBEBBASEEDAELQoCAgICAgOD//wAhCSABKAJoRQ0DIAEgASgCBEF/ajYCBAwDCwNAAn8gASgCBCICIAEoAmhJBEAgASACQQFqNgIEIAItAAAMAQsgARB7CyICQVBqQQpJIAJBv39qQRpJciACQd8ARnJFQQAgAkGff2pBGk8bRQRAIARBAWohBAwBCwtCgICAgICA4P//ACEJIAJBKUYNAiABKAJoIgIEQCABIAEoAgRBf2o2AgQLIAMEQCAERQ0DA0AgBEF/aiEEIAIEQCABIAEoAgRBf2o2AgQLIAQNAAsMAwsLQdjJEUEcNgIAIAFCABDmAgtCACEJCyAAIAo3AwAgACAJNwMIIAVBMGokAAu3EAIFfwx+IwBBwAFrIgUkACAEQv///////z+DIRIgAkL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhESAEQjCIp0H//wFxIQgCQAJAAkAgAkIwiKdB//8BcSIJQX9qQf3/AU0EQCAIQX9qQf7/AUkNAQsgAVAgAkL///////////8AgyIKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhEQwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCERIAMhAQwCCyABIApCgICAgICAwP//AIWEUARAIAMgAkKAgICAgIDA//8AhYRQBEBCACEBQoCAgICAgOD//wAhEQwDCyARQoCAgICAgMD//wCEIRFCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEBCACEBDAILIAEgCoRQDQIgAiADhFAEQCARQoCAgICAgMD//wCEIRFCACEBDAILIApC////////P1gEQCAFQbABaiABIAwgASAMIAxQIgYbeSAGQQZ0rXynIgZBcWoQgQJBECAGayEGIAUpA7gBIQwgBSkDsAEhAQsgAkL///////8/Vg0AIAVBoAFqIAMgEiADIBIgElAiBxt5IAdBBnStfKciB0FxahCBAiAGIAdqQXBqIQYgBSkDqAEhEiAFKQOgASEDCyAFQZABaiASQoCAgICAgMAAhCIUQg+GIANCMYiEIgJChMn5zr/mvIL1ACACfSIEEIEDIAVBgAFqQgAgBSkDmAF9IAQQgQMgBUHwAGogBSkDiAFCAYYgBSkDgAFCP4iEIgQgAhCBAyAFQeAAaiAEQgAgBSkDeH0QgQMgBUHQAGogBSkDaEIBhiAFKQNgQj+IhCIEIAIQgQMgBUFAayAEQgAgBSkDWH0QgQMgBUEwaiAFKQNIQgGGIAUpA0BCP4iEIgQgAhCBAyAFQSBqIARCACAFKQM4fRCBAyAFQRBqIAUpAyhCAYYgBSkDIEI/iIQiBCACEIEDIAUgBEIAIAUpAxh9EIEDIAYgCSAIa2ohBgJ+QgAgBSkDCEIBhiAFKQMAQj+IhEJ/fCIKQv////8PgyIEIAJCIIgiDn4iECAKQiCIIgogAkL/////D4MiC358IgJCIIYiDSAEIAt+fCILIA1UrSAKIA5+IAIgEFStQiCGIAJCIIiEfHwgCyAEIANCEYhC/////w+DIg5+IhAgCiADQg+GQoCA/v8PgyINfnwiAkIghiIPIAQgDX58IA9UrSAKIA5+IAIgEFStQiCGIAJCIIiEfHx8IgIgC1StfCACQgBSrXx9IgtC/////w+DIg4gBH4iECAKIA5+Ig0gBCALQiCIIg9+fCILQiCGfCIOIBBUrSAKIA9+IAsgDVStQiCGIAtCIIiEfHwgDkIAIAJ9IgJCIIgiCyAEfiIQIAJC/////w+DIg0gCn58IgJCIIYiDyAEIA1+fCAPVK0gCiALfiACIBBUrUIghiACQiCIhHx8fCICIA5UrXwgAkJ+fCIQIAJUrXxCf3wiC0L/////D4MiAiAMQgKGIAFCPoiEQv////8PgyIEfiIOIAFCHohC/////w+DIgogC0IgiCILfnwiDSAOVK0gDSAQQiCIIg4gDEIeiEL//+//D4NCgIAQhCIMfnwiDyANVK18IAsgDH58IAIgDH4iEyAEIAt+fCINIBNUrUIghiANQiCIhHwgDyANQiCGfCINIA9UrXwgDSAKIA5+IhMgEEL/////D4MiECAEfnwiDyATVK0gDyACIAFCAoZC/P///w+DIhN+fCIVIA9UrXx8Ig8gDVStfCAPIAsgE34iCyAMIBB+fCIMIAQgDn58IgQgAiAKfnwiAkIgiCACIARUrSAMIAtUrSAEIAxUrXx8QiCGhHwiDCAPVK18IAwgFSAOIBN+IgQgCiAQfnwiCkIgiCAKIARUrUIghoR8IgQgFVStIAQgAkIghnwgBFStfHwiBCAMVK18IgJC/////////wBYBEAgAUIxhiAEQv////8PgyIBIANC/////w+DIgp+IgxCAFKtfUIAIAx9IhAgBEIgiCIMIAp+Ig0gASADQiCIIgt+fCIOQiCGIg9UrX0gAkL/////D4MgCn4gASASQv////8Pg358IAsgDH58IA4gDVStQiCGIA5CIIiEfCAEIBRCIIh+IAMgAkIgiH58IAIgC358IAwgEn58QiCGfH0hEiAGQX9qIQYgECAPfQwBCyAEQiGIIQsgAUIwhiACQj+GIARCAYiEIgRC/////w+DIgEgA0L/////D4MiCn4iDEIAUq19QgAgDH0iDiABIANCIIgiDH4iECALIAJCH4aEIg1C/////w+DIg8gCn58IgtCIIYiE1StfSAMIA9+IAogAkIBiCIKQv////8Pg358IAEgEkL/////D4N+fCALIBBUrUIghiALQiCIhHwgBCAUQiCIfiADIAJCIYh+fCAKIAx+fCANIBJ+fEIghnx9IRIgCiECIA4gE30LIQEgBkH//wBqIgZB//8BTgRAIBFCgICAgICAwP//AIQhEUIAIQEMAQsgBkEATARAQgAhAQwBCyAEIAFCAYYgA1ogEkIBhiABQj+IhCIBIBRaIAEgFFEbrXwiASAEVK0gAkL///////8/gyAGrUIwhoR8IBGEIRELIAAgATcDACAAIBE3AwggBUHAAWokAA8LIABCADcDACAAIBFCgICAgICA4P//ACACIAOEQgBSGzcDCCAFQcABaiQACy8BAX8jAEEQayIFJAAgBSAENgIIIAUgAzYCDCAAIAEgAhCwGCEAIAVBEGokACAACxUAIAEQswIhASACEJMFIAAgARCxGAsKACAAQbYCNgIAC8gCAQJ/IwBB0ABrIgQkAAJAIANBgIABTgRAIARBIGogASACQgBCgICAgICAgP//ABCSASAEKQMoIQIgBCkDICEBIANBgYB/aiIFQYCAAUgEQCAFIQMMAgsgBEEQaiABIAJCAEKAgICAgICA//8AEJIBIANB/f8CIANB/f8CSBtBgoB+aiEDIAQpAxghAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEFAayABIAJCAEKAgICAgIDAABCSASAEKQNIIQIgBCkDQCEBIANB/v8AaiIFQYGAf0oEQCAFIQMMAQsgBEEwaiABIAJCAEKAgICAgIDAABCSASADQYaAfSADQYaAfUobQfz/AWohAyAEKQM4IQIgBCkDMCEBCyAEIAEgAkIAIANB//8Aaq1CMIYQkgEgACAEKQMINwMIIAAgBCkDADcDACAEQdAAaiQACwoAIABBtAI2AgALrAEBA38jAEEwayIDJAAgA0EYaiAAIANBIGogASABEOYFIgRBAWogA0EYahDDCRCtGCIBEPAFEIgEIQUgASAEEFJBKToAACADQRBqIAAgARCsGBCIBCEAIAMgBSgCADYCCCADQQhqIAAQjAEEQANAIAMgA0EIahBaKAIQIgEgASgCACgCHBEEADYCBCACIANBBGoQzgQgA0EIahCRAyAAEIwBDQALCyADQTBqJAALCgAgAEEBOgDABAsfAQF/IAAoApwEIgIEQCABIAJGDwsgACABNgKcBEEBCxoAIAFFBEBBAA8LIAAgAiwAABC7ASABEJcGCzYAQQAgAU0EfyADRQRAQQAPC0F/IAAgACABaiIBIAIgAiADahC/GCICIABrIAEgAkYbBUF/CwsKACAAKAJQQQBHC0IBAX8gARC/ASEDQYABEHQiASADIAJBABDjAiECIAAoAkwiACAAKAIMQQFqIgA2AgwgASAAIAEoAgAoAjgRAgAgAgtHAAJAIAMgAygCACgCEBEEAEUNACADIAMoAgAoAhARBAAoAmhBsQRHDQAgACABQfySCiACQdy/EUEAIAAoAgAoAqABEQ0ACwsUACAAEBsgABAmIAEgARCcARCwDQs1ACAAIAE3AwAgACACQv///////z+DIARCMIinQYCAAnEgAkIwiKdB//8BcXKtQjCGhDcDCAsOACAAp0EYdkEHcRD2BguZBgIFfwF+IwBBIGsiByQAAkAgACgCTCIFECAEfyAFBSAAIAFBd0HxigoQXCAAKAJMCyACIAIoAgAoAhgRBAAgB0EfakEAEKsBIghFDQACQCAIIAgoAgAoAhwRBABFDQAgBy0AH0UNACAAIAFBd0GMiwoQXAsgCCAIKAIAKAIcEQQAIgVFDQAgBSAFKAIAKAJ8EQQARSADRXJFBEAgACABQQhBrAJBAEGuiwoQLgsgBSAFKAIAKAIwEQQAIAIgAigCACgCMBEEABDIAQRAIAAgAUHUiwogAiACKAIAKAIMEQQAEBtB3L8RQQAgACgCACgCoAERDQALQQEhBCAFIAUoAgAoApABEQQAQQFIDQBBACEEA0AgBSAEIAUoAgAoAqABEQUAKAIEIgYgBigCACgCKBEEACkCBCACIAQgAigCACgCnAERBQAoAgQiBiAGKAIAKAIoEQQAKQIEhUI/g1BFBEAgAiAEIAIoAgAoApwBEQUAKAIEKQIMIQkgACgCACgCoAEhBiAHIARBAWo2AhAgACABQYiMCiAJEMUEQdiTESAHQRBqIAYRDQALAkAgBSAEIAUoAgAoAqABEQUAKAIEIgYgBigCACgCKBEEACkCBCACIAQgAigCACgCnAERBQAoAgQiBiAGKAIAKAIoEQQAKQIEhUKAgIA4g1AEQCAEQQFqIQQMAQsgAiAEIAIoAgAoApwBEQUAKAIEKQIMIQkgACgCACgCoAEhBiAHIARBAWoiBDYCACAAIAFB2owKIAkQtg1B2JMRIAcgBhENAAsgBCAFIAUoAgAoApABEQQASA0AC0EBIQQLIAAgASACIAIoAgAoAjARBABBro0KEPMFAkAgA0UNACAAKAJMECwEQCACIAIoAgAoAnARCAAMAQsgBEEBcyAHLQAfQQBHckUEQCAIIAgoAgAoAhwRBAAiAyADKAIAKAJ4EQgACyACIAIoAgAoAngRCAALIAAoAkwgAhDiAkUEQCAAIAFBzI0KIAIgAigCACgCDBEEABAbQdy/EUEAIAAoAgAoAqABEQ0ACyAHQSBqJAAgAgtpAAJAIAIgAigCACgCcBEEAA0AIAAoAkwQLA0AIAIgAigCACgCLBEEACAAKAIUEKkHRQ0AIAIgAigCACgCLBEEAC0AJw0AIAAgAUHOgQogAikCDBDFBCADEBtBACAAKAIAKAKgARENAAsLDwAgACgCBCgCACABNgIACx8AIABBf2oiAEEFTQRAIABBAnRB+P8JaigCAA8LQQALuwEBAX8Cf0EAIAAgACgCACgCeBEEACIBIAEoAgAoAiwRBAApAgRCP4NCBlINABoCQCAAIAAoAgAoAlARBAAiAEUNACAAKAJoQbMBRw0AIAAgACgCACgCxAERBAAiASABKAIAKAIUEQQAEFNBABAXKAIAIQFBACAAIAAoAgAoAsABEQQAEP4BDQEaQQEgASAAIAAoAgAoAsABEQQAIgAgACgCACgCeBEEAEFAaygCABBCQX9qRg0BGgtBAAsLRAEBfyMAQRBrIgMkACABEDghASAAQSAQKyADQQhqIAEQ5AEQkAEiACgCAEEQaiACEIACGiAAEDhBAToABCADQRBqJAALJAEBfyMAQRBrIgIkACACQQhqIABBxAZqIAEQ4hggAkEQaiQACykBAX8gAKdBP3FBfWoiAUEXTQRAQY+A/wcgAUH///8HcXZBAXEPC0EAC0EBAn8CQCAAEK8FDQAgACgCBCIBKAIAIAAiAigCABCwBSAAECdBADYCACAAIAFGDQADQCABKAIEIgEgAkcNAAsLCw0AIABB9IIQNgIAIAALCQAgAEH/AXFFC0IBAX8jAEEQayIEJAAgBCACNgIIIAQgATYCDCAEIAM2AgQgACAEKAIMIAQoAgggBCgCBCAAKAIIEQwAIARBEGokAAsrAQF/IAAoAgAiAQRAIAEQ9g1BfxBYRQRAIAAoAgBFDwsgAEEANgIAC0EBCysBAX8gACgCACIBBEAgARCoDkF/EFhFBEAgACgCAEUPCyAAQQA2AgALQQELWwAgAEGw5wk2AgAgAEGQBWoQxAIgAEGABWoQxAIgAEHwBGoQxAIgAEHgBGoQxAIgAEHQBGoQxAIgAEGoAWoQtQEgAEH4AGoQvw0gAEHoAGoQvw0gABDADRogAAtJAQF/IABB0OkJNgIAIAAoAqSrASIBBEAgARAwCyAAQcirAWoQtQEgAEG4qwFqELUBIABBrKsBaiIBIAEQRhDyCCAAEMUNGiAAC5QBAQN/IwBBEGsiASQAIAAtAKQBRQRAQagBEHQiAhCPBBogASACNgIMIAEgACgCqAEQJCICNgIIIAIgACgCrAEQJBAlBEADQCABQQxqIAIoAgAQnw4gAUEIahBiGiAAKAKsARAkIQMgASgCCCICIAMQJQ0ACwsgACgCKCABQQxqIAAoAhQgACgCTBDaGQsgAUEQaiQACz4BAX8jAEEQayIFJAAgBSAENgIIIAUgAzYCDCAAIAEgAiAFKAIMIAUoAgggACgCCBEHACEAIAVBEGokACAAC6cGAQd/IwBBMGsiBSQAIARBADoAACAFQSBqEJoBIQcgBSAAKAIAECQ2AhAgACIKKAIEECQhBiAFKAIQIgAgBhAlBEADQCAAKAIAIQACQCABIAEoAgAoApABEQQAIAAgACgCACgCmAERBABIDQAgASABKAIAKAKQAREEACAAIAAoAgAoApABEQQASg0AIAUgASABKAIAKAKQAREEADYCCCAFIAAgACgCACgCkAERBAA2AhggBUEIaiAFQRhqEJUDKAIAIgtBAU4EQEEAIQYDQCAAIAYgACgCACgCoAERBQAoAgQiCSAJKAIAKAIoEQQAKQIEEPcIBEAgAiABIAYgASgCACgCoAERBQAoAgQgACAGIAAoAgAoAqABEQUAKAIEIAAgACgCACgCbBEEACAGEMgNRQ0DCyAAIAYgACgCACgCoAERBQAoAgQiCSAJKAIAKAIoEQQAKQIEEJYFBEAgAiAAIAYgACgCACgCoAERBQAoAgQgASAGIAEoAgAoAqABEQUAKAIEIAAgACgCACgCbBEEACAGEMgNRQ0DCyAGQQFqIgYgC0cNAAsLIAUgADYCCCAHIAVBCGoQzgQLIAVBEGoQYhogCigCBBAkIQYgBSgCECIAIAYQJQ0ACwsCQAJAAkAgBxAfIgBBAU0EQCAAQQFrDQMMAQsgBSADNgIUIAUgATYCECAFIAM2AgwgBSABNgIIIAcoAgAiACgCACEIIAUgABAkNgIAIAUgBRCKGTYCGCAHKAIEECQhASAFKAIYIgAgARAlRQ0BA0AgBUEQaiAIIAAoAgAiABD2CARAIAggACAFQRBqIAAgCBD2CBshCAsgBUEYahBiGiAHKAIEECQhASAFKAIYIgAgARAlDQALDAELIAcoAgAoAgAhCAwBCyAFIAcoAgAQJDYCGCAHKAIEECQhASAFKAIYIgAgARAlRQ0AA0ACQCAIIAAoAgAiAEYNACAFQRBqIAggABD2CEUEQCAFQQhqIAggABCJGUUNAQsgBEEBOgAACyAFQRhqEGIaIAcoAgQQJCEBIAUoAhgiACABECUNAAsLIAcQtQEgBUEwaiQAIAgLUQEBfyABEJMNIQIgACgCAEEDEBooAgAgAiAALQAREOgGGiABIAEoAgAoAiQRBAAEfyACBSAAKAIAQQMQGigCACABIAEoAgAoAgwRBAAQ3Q0LCysAIAEgACgCTCABKAIAEMoNIgE2AgAgAQRAIAAgASAAKAIAKAKIAhECAAsLqQEBAX8CQCADRQ0AIAMgAygCACgCIBEEACIEBEAgBCgCaCIDQc9+akEET0EAIANB6AVHGw0BIAAgASACIAQgBCgCACgCwAERBAAgACgCACgC8AERDAAPCyADIAMoAgAoAjARBAAiA0UNACADIAMoAgAoAoQBEQQAKQIEEMgERQ0AIAAgAUGE5QkgAiADIAMoAgAoAsABEQQAEBtBACAAKAIAKAKgARENAAsL0QQBBn8jAEFAaiIFJAACfwJAIAMgAygCACgCIBEEACIEBEAgBCgCaCIDQc9+akEET0EAIANB6AVHG0UEQCAAIAEgAiAEIAQoAgAoAsABEQQAIAAoAgAoAuwBEQkADAMLIAAoAgAoAqABIQMgBUHcvxE2AjAgACABQZTvCSACQdy/ESAFQTBqIAMRDQAMAQsCf0EAIAMgAygCACgCMBEEACIHRQ0AGiAHIAcoAgAoAsABEQQAEBsLIQlB7uMJIQQCQAJAAkACQAJAIAMgAygCACgChAERBAAoAgRBP3EiBkF+aiIIQQhLBEAgBkEQRg0FDAELAkACQAJAIAhBAWsOCAMDAgEDAwMABwtBAEHD4wkgACgCFEEHRhshBgwDC0GU4wlB9eIJQQAgAyADKAIAKAKEAREEACkCBBCEBxsgAyADKAIAKAKEAREEAC0AMBA2GyEGDAILQYPkCSEEDAQLQQAhBiADIAMoAgAoAoABEQQAIgNBc2oiCEEESwRAIAMNAUGa5AkhBAwEC0Ht5AkhBCAIQQFrDgQDAAABAgsgBiAHckUEQCAAKAIAKAKgASEDIAVB3L8RNgIAIAAgAUGU7wkgAkHcvxEgBSADEQ0ADAQLIAYiBA0CQQAMBAtByOQJIQQMAQtBrOQJIQQLIAAoAgAoAqABIQMgBwRAIAUgBDYCFCAFIAk2AhAgACABQZTvCSACQcPwCSAFQRBqIAMRDQAMAQsgBSAENgIgIAAgAUGU7wkgAkHN8AkgBUEgaiADEQ0AC0EBCyEAIAVBQGskACAACyYBAX8CQCAAKAIAIgJFDQAgAiABELMZQX8QWEUNACAAQQA2AgALCwoAIABBAnFBAXYLEwAgAEEBOgA1IAAgACgCBDYCEAsMACAAIAEoAgAQkxkLJgEBfwJAIAAoAgAiAkUNACACIAEQuQtBfxBYRQ0AIABBADYCAAsLDwAgACgCACABKAIAEJgFC6oCAQd/AkAgAQRAIAAgARDNAhD0AiAAEDggATYCAANAIAAgAxAtQQA2AgAgA0EBaiIDIAFHDQALIABBCGoiAigCACIERQ0BIAAgBCgCBCABEDkiBxAtIAI2AgAgBCgCACICRQ0BA0ACQCAHIAIoAgQgARA5IgVGBEAgAiEEDAELAkACQCAAIAUQLSgCAARAIAIhBiACKAIAIgNFDQIgAkEIaiIIIANBCGoQ0w0NAQwCCyAAIAUQLSAENgIAIAIhBCAFIQcMAgsDQCADIgYoAgAiA0UNASAIIANBCGoQ0w0NAAsLIAQgBigCADYCACAGIAAgBRAtKAIAKAIANgIAIAAgBRAtKAIAIAI2AgALIAQoAgAiAg0ACwwBCyAAQQAQ9AIgABA4QQA2AgALCwkAIAAgARDRDQsMACAAKAIAGiABEDALoAIBB38CQCABBEAgACABEM0CEPQCIAAQOCABNgIAA0AgACADEC1BADYCACADQQFqIgMgAUcNAAsgAEEIaiICKAIAIgRFDQEgACAEKAIEIAEQOSIHEC0gAjYCAANAIAQoAgAiAkUNAiAHIAIoAgQgARA5IgVGBEAgAiEEDAELAkACQCAAIAUQLSgCAARAIAIhBiACKAIAIgNFDQIgAigCCCIIIAMoAggQmAUNAQwCCyAAIAUQLSAENgIAIAIhBCAFIQcMAgsDQCADIgYoAgAiA0UNASAIIAMoAggQmAUNAAsLIAQgBigCADYCACAGIAAgBRAtKAIAKAIANgIAIAAgBRAtKAIAIAI2AgAMAAALAAsgAEEAEPQCIAAQOEEANgIACwsLACAAQeDSERCsAwsMACAAKAIAIAEQmAULUAECfyMAQRBrIgMkACABBEADQCACIAEgAUEQaiAAENUEIgQbIQIgAUEEQQAgBBtqKAIAIgENAAsLIANBCGogAhAzKAIAIQAgA0EQaiQAIAALBwAgAEEESAsHACAAQQNIC0kBAX8jAEEQayICJAAgAiAAIAEQ+gU2AgggAiAAEH42AgBBACEAIAJBCGogAhCUA0UEQCACQQhqEFooAhAhAAsgAkEQaiQAIAALYQEBfyMAQUBqIgIkACACIAEoAgg2AgAgAkEgakEYQaTGCSACEC8aIAJBEGogAUEAEP0IIAAgAkEQahAbEMcDIAJBEGoQKBogACACQSBqEMcDIABB6IAQEMcDIAJBQGskAAsJACAAEP8IEDALRQAgAQRAIAAQ9gJBAA8LIAAoAgQiAS0ABBA2BEAgASAAQQxqQdvHCSAAKAIkQdy/EUEAIAEoAgAoAqQBEQ0ACyAAEPwBC/ACAQR/IwBBEGsiAyQAIAFBIGohBQJAAkADQAJAIAAgACABEFQgARDaCyICQSNHBEAgAkF/Rw0BDAMLIAAoAmxBCkYEQCAAIAEQlBRBf0cNAgwDCyAAKAJwIgAgAUGbqxFB1qsRQdy/EUEAIAAoAgAoAqgBEQ0AQX8hAgwDCyAAIAI2AmwgAkEKRg0AAkAgAkHofmoiBEEKSwRAIAJBJ0cNASAAKAJwIgIgAUH5qxFBzaYRQdy/EUEAIAIoAgAoAqgBEQ0ADAILAkACQAJAIARBCWsOAgIAAQsgACABQQBBARCaCEF/aiIEQQJLDQBBfyECIARBAWsOAgMDBQsgBS0AAEUNAgwECyAAKAJ0BEBBoQEhAgwECyAAKAJwIgIgAUHYqxFB9qsRQdy/EUEAIAIoAgAoAqgBEQ0ADAELCyADIABBFGogAhCtAjYCACAFQYEIQa+uESADEC8aDAELIAAQ9RNBfyECCyADQRBqJAAgAgsUACAAIAAoAgAgAUEDdGo2AgAgAAv6AQEFfyMAQSBrIgUkACAAKAIAIgQgASAEECQQ5AZBA3RqIQECQCACIAMQ1QwiBEEBSA0AIAQgABAnKAIAIAAoAgQiBmtBA3VMBEAgBSADNgIIIAQgBiABayIHQQN1IghKBEAgBSACNgIIIAVBCGogCBDUDCAFKAIIIAMgAEEEahCVFyAHQQFIDQILIAAgASAGIAEgBEEDdGoQmBcgAiAFKAIIIAEQ0wwaDAELIAAQtgEhBiAFQQhqIAAgABCfAiAEahCbBSABIAAoAgBrQQN1IAYQgAkiBCACIAMQlxcgACAEIAEQlhchASAEENQBCyABECQaIAVBIGokAAttAQN/IABBlPsONgIAEPEBIgQgAxCIDiAAIAQ2AgQCQCADQQFIDQADQCABIAIgBWoQFyEGIAQoAgAgBRDdASIEIAYoAgg2AgggBCAGKQMANwMAIAVBAWoiBSADRg0BIAAoAgQhBAwAAAsACyAAC5sCAQV/IwBB4ABrIgQkACAEQQhqIAAgACgCACgCeBEEACABQQAQ3AEiBRAnIgMgAykCBEJAg0IChDcCBCAFENEBIQZBACEDAkAgACAAKAIAKAJ4EQQAEIIBDQACQAJAIAAgACgCACgCoAERBAANACAAIAAoAgAoAqwBEQQARQ0AIAFBAEoNAQwCCyABIAZsIQMMAQsDQCAAIAAoAgAoAngRBABBQGsoAgAoAgAgBxBEKAIAENEBIANqIQMgB0EBaiIHIAFHDQALCyAEIAAgACgCACgCFBEEABBTIAMgBhDkDSAAIAAoAgAoAngRBAAgAkEAEOACIgEEQCABIAUgASgCACgCdBECACABIQALIAUQPRogBEHgAGokACAACwwAIAAgAUEDdBDJAQs+AQJ/IwBBEGsiACQAIABB/////wE2AgwgAEH/////BzYCCCAAQQxqIABBCGoQ0wEoAgAhASAAQRBqJAAgAQujAgACQAJAIAFBFEsNACABQXdqIgFBCUsNAAJAAkACQAJAAkACQAJAAkAgAUEBaw4JAQIJAwQFBgkHAAsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgACACIAMRAgALDwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMACwcAIAAgAWMLEwAgAEEYdEEYdSABQRh0QRh1SAsPACAAQf8BcSABQf8BcUkLEwAgAEEQdEEQdSABQRB0QRB1SAsRACAAQf//A3EgAUH//wNxSQsHACAAIAFTCzEBAX8gACgCDCIBIAAoAhBGBEAgACAAKAIAKAIoEQQADwsgACABQQRqNgIMIAEoAgALBwAgACABVAtQAQF/IwBB0ABrIgUkACAABH8gACAFIAEgBCACIAMQ/RQiASAAKAIAKAIIEQIAIAEtADkhACABEJ8IGiAAQQBHBUEACyEAIAVB0ABqJAAgAAsUACABIAAgACkDACABKQMAEPANGwsUACABIAAgACkDACABKQMAEO4NGwsUACABIAAgAC8BACABLwEAEO0NGwsUACABIAAgAC8BACABLwEAEOwNGwsnAQF/IAAoAgwiASAAKAIQRgRAIAAgACgCACgCJBEEAA8LIAEoAgALFAAgASAAIAAtAAAgAS0AABDrDRsLFAAgASAAIAAtAAAgAS0AABDqDRsLFAAgASAAIAArAwAgASsDABDpDRsLFAAgASAAIAEpAwAgACkDABDwDRsLFAAgASAAIAEpAwAgACkDABDuDRsLFAAgASAAIAEvAQAgAC8BABDtDRsLFAAgASAAIAEvAQAgAC8BABDsDRsLFAAgASAAIAEtAAAgAC0AABDrDRsLFAAgASAAIAEtAAAgAC0AABDqDRsLEAAgABDDDSABEMMNc0EBcwsUACABIAAgASgCACAAKAIAEJwFGwsUACABIAAgASsDACAAKwMAEOkNGwsMACAAIAFBBHQQyQELPgECfyMAQRBrIgAkACAAQf////8ANgIMIABB/////wc2AgggAEEMaiAAQQhqENMBKAIAIQEgAEEQaiQAIAELOgEBfxCEDiABSQRAEH0ACyAAIAAQtgEoAgAgARCDDiICNgIAIAAgAjYCBCAAECcgAiABQQR0ajYCAAsPACAAIAAoAgBBEGo2AgALNQEDf0EBIQIgACgCBBDJAiIDQQBKBEADQCAAIAEQkgUgAmwhAiABQQFqIgEgA0cNAAsLIAILGgAgABCHCSABBEAgACABEIUOIAAgARC+GQsLCAAgAC8BAEULCAAgAC0AAEULIwEBfyAAIAFGBEBBAQ8LIABFIAFFcgR/IAIFIAAgARDCGQsLDAAgACABEIsOQQFzCzUBAn8gAEGU+w42AgAQ8QEiBCIDEIcJIAEEQCADIAEQhQ4gAyABIAIQvxkLIAAgBDYCBCAACzoAIABBARCVByAAQfyxCTYCACAAQfAAahCaARogAEGAAWoQmgEaIABBkAFqENIBGiAAQQA2AqQBIAALGgAgAEEFTQRAIABBAnRB4MIJaigCAA8LQQALDwAgABCDCSAAQQRqEI8GCzkBAX8jAEEQayIBJAAgAEEEahCQDiABQQA2AgwgAEEMaiABQQxqENICIAAgABA4NgIAIAFBEGokAAsUAQF/A0AgACIBKAIAIgANAAsgAQuOAgEBfyABIAAgAUYiAjoADAJAIAINAANAIAEoAggtAAwNAQJAAn8gASgCCCICELQCBEACQCACKAIIKAIEIgJFDQAgAi0ADA0AIAJBDGohAiABKAIIIgFBAToADCABKAIIDAILIAEQtAJFBEAgASgCCCIBEOIFCyABKAIIIgBBAToADCAAKAIIIgBBADoADCAAEOEFDwsgAigCCCgCACICRQ0BIAItAAwNASACQQxqIQIgASgCCCIBQQE6AAwgASgCCAsiASAAIAFGOgAMIAJBAToAACAAIAFHDQEMAgsLIAEQtAIEQCABKAIIIgEQ4QULIAEoAggiAEEBOgAMIAAoAggiAEEAOgAMIAAQ4gULC1wBAX8CQCAAEEYiAwRAA0ACQCACIANBEGoQ1QQEQCADKAIAIgBFDQQMAQsgAygCBCIADQAgASADNgIAIANBBGoPCyAAIQMMAAALAAsgABA4IQMLIAEgAzYCACADCx0BAX8DQCAAIgEoAgAiAA0AIAEoAgQiAA0ACyABC1EBAX8gACgCCCIBRQRAQQAPCwJAIAAQtAIEQCABQQA2AgAgASgCBCIARQ0BIAAQlQ4PCyAAKAIIQQA2AgQgASgCACIARQ0AIAAQlQ4hAQsgAQsQACAAIAAoAhhFIAFyNgIQC0QBA38gACgCACwAABDRAgRAA0AgACgCACICLAAAIQMgACACQQFqNgIAIAMgAUEKbGpBUGohASACLAABENECDQALCyABCwoAIAAQ/AUaIAALDAAgAEG2fGpB6wBJCyMBAX8gACgCACECIAAgATYCACACBEAgABA4KAIEGiACEDALCwkAIABBABCbDgsxAQJ/IwBBEGsiAiQAQTAQKyIDQQA2AgAgACADIAJBCGogARDaBBCQARogAkEQaiQAC8wBAQR/IwBBQGoiAyQAIAMgAEEcaiIEEI4CNgI4IANBCGogA0E4ahDlASEAIAMgBBAkNgIwIANBOGogA0EwahDlASEFAkACQCAAKAIAIgYgBSgCABAlRQ0AA0AgBhAnIAEQigkNASAAKAIAECdBEGogAhCLAg0CIAAQ8wEaIAMgBBAkNgIwIAUgA0EwahDlARogACgCACIGIAUoAgAQJQ0ACwsgBAJ/IANBCGoiACABEIACGiAAQRBqIAIQgAIaIAALENkZCyADQUBrJAALRwEBfyABIAEoAgAoAigRBAAiAgR/IAIFIAEgASgCACgCLBEEACIBIAEoAgAoAlgRBAALEPsZIQEgACAAKAIAIAEQuwM2AgALJAAgASACQQBBABCrASIBBEAgACABIAEoAgAoAiQRBAAQnw4LCzsBAX8gACABRwRAIAIoAgAhAwNAIANBfGogAUF8aiIBEKAFIAIgAigCAEF8aiIDNgIAIAAgAUcNAAsLCzQBAX8gACgCDCIBIAAoAhBGBEAgACAAKAIAKAIoEQQADwsgACABQQFqNgIMIAEsAAAQuwELBwAgABDAAQtAAQJ/IAAoAgAgAEEEaiICKAIAIAFBBGoiAxChDiAAIAMQOyACIAFBCGoQOyAAECcgARA6EDsgASABKAIENgIACysBAX8gACgCCCECA0AgAhDAASAAIAAoAghBBGoiAjYCCCABQX9qIgENAAsLKwEBfyAAKAIEIQIDQCACEMABIAAgACgCBEEEaiICNgIEIAFBf2oiAQ0ACwsdACAAIAAoAgBB//+/f3FBgIDAAEEAIAEbcjYCAAsqAQF/IAAoAgwiASAAKAIQRgRAIAAgACgCACgCJBEEAA8LIAEsAAAQuwELEAAgABDEDSABEMQNc0EBcwsnAQF/QfgAEHQiBCAAIAEgAhDsGSEAIAQgAyAEKAIAKAIEEQIAIAALDwAgACAAKAIAKAIYEQQAC+UGAQR/IwBB8ABrIgUkAAJAIAJFDQAgAiACKAIAKAJ4EQQAIgQgBCgCACgCHBEEAEEQRg0AAkACQAJAIAFBtnxqIgdBCksEQCABQXpqIgRBB0sEQCABQaMERw0DQQMhBAwCCwJAAkAgBEEBaw4DAAQEAQsgAiACKAIAKAJ4EQQAIgQgBCgCACgCHBEEAEEMRw0FIAIgAigCACgCeBEEACIEIAQoAgAoAmwRBAANBSACIAIoAgAoAngRBAAiBCAEKAIAKAJwEQQADQUgAiACKAIAKAJ4EQQAIgQgBCgCACgCaBEEAEUNBAwFCyACIAIoAgAoAngRBAAiBCAEKAIAKAIcEQQAQQ9GDQQgAiACKAIAKAJ4EQQAIgQgBCgCACgCcBEEAEUNAgwEC0EMIQQCQAJAAkACQAJAAkACQAJAAkACQCAHQQFrDgoHBgUEAwIBCgkACAtBAiEEDAkLQQshBAwIC0EKIQQMBwtBByEEDAYLQQYhBAwFC0EFIQQMBAtBBCEEDAMLQQkhBAwCC0EIIQQMAQtBASEECyAAIAEgBUEYaiAEQQAgAiACKAIAKAKQAREEACACIAIoAgAoApQBEQQAIAIgAigCACgCmAERBAAgAiACKAIAKAKkAREEABBIIgQgAhDQBCECIAQQPRogAkUNAgsgAUG2fGpBC0kEQCACIQYMAgsgAiEGIAFBowRGDQELIAUgAykCCDcDECAFIAMpAgA3AwhBACEGIAAgASACIAVBCGoQrg4iABCXCUUNACAAIAAoAgAoAsQBEQgAIAAgACgCACgCvAERBAAiAiACKAIAKAIUEQQAIQMgACAAKAIAKAK8AREEACECIAMEQCACIAIoAgAoAhQRBAAiAiABIAAgACgCACgCeBEEACACKAIAKAK8AREAACEGDAELAkAgAiACKAIAKAJ4EQQAIgEgASgCACgCLBEEACkCBBDvAUUNACAAEJYJRQ0AIAAgACgCACgCfBEEACIBIAEoAgAoAigRBAAQvQMLAkAgACAAKAIAKAK8AREEACIBIAEoAgAoAoQBEQQAKQIEEPoCRQ0AIAAoAmgQtw5FDQAgACAAKAIAKAJ8EQQAIgEgASgCACgCKBEEACIBIAEpAgRCgICAgBCENwIECyAAIQYLIAVB8ABqJAAgBgtPAQJ/IwBBEGsiAiQAIAIgASAAEEYgABA4EO4ZIgM2AggCQCADIAAQiQEQJQRAIAEgAkEIahBaEJcDRQ0BCyAAEIkBIQMLIAJBEGokACADC3EBAn9B9AAQdCIEIgMgABCVByADQQA2AnAgA0H0uAk2AgAgAyEAIAIoAghFBEAgAiABIAEoAgAoAgARBAAiAykCADcCACACIAMpAgg3AggLIAQgAiAEKAIAKAIEEQIAIAAgASAEKAIAKAK4ARECACAACx8AIABBfGoiAEEGTQRAIABBAnRBvMEJaigCAA8LQRQLbQACQCAAQXpqIgBBBEsNAAJAAkACQCAAQQFrDgQDAQMCAAsgAUF7aiIAQQdPDQIgAEH/AHFFDwsgAUF7aiIAQQVPDQFBBSAAQR9xdkEBcQ8LIAFBe2oiAEEHTw0AQRUgAEH/AHF2QQFxDwtBAAs7AQF/IAAgAUcEQCACKAIAIQMDQCADQXxqIAFBfGoiARCYASACIAIoAgBBfGoiAzYCACAAIAFHDQALCwtYAQJ/IwBBIGsiAyQAIAAQtgEhAiADQQhqIAAgABAfQQFqEPIBIAAQHyACEM0EIgIoAgggARCYASACIAIoAghBBGo2AgggACACEIgJIAIQ1AEgA0EgaiQAC1QBAX8jAEHgAGsiAiQAIAAQ/gUgAEGUvQk2AgAgAEEUakEAQQBBAUEAQQBBABBIIAJBCGogAUEAQQFBAEEAQQAQSCIAEJUBIAAQPRogAkHgAGokAAtpAAJAIAEoAgAgACgCAHNB//8PcQ0AIAAQjwEgARCPAUcNACAAEKYFIAEQpgVHDQAgABCkAiABEKQCRw0AIAAQzwQgARDPBEcNACAAEKUFIAEQpQVHDQAgABD/BSABEP8Fc0EBcw8LQQALIAEBfyAAIAFyRSECIABFIAFFcgR/IAIFIAAgARD1GQsLEgAgACgCBCABKAIEELUOQQFzCzABAX8gAEF6akEISSAAQel+aiIBQR1NQQBBASABdEH/n+//A3EbckUEQEEADwtBAQuVAQEBfwJ/IAAgACgCACgCeBEEACICIAIoAgAoAiwRBAApAgQQ7wEEQEEBIAEgASgCACgCeBEEACICIAIoAgAoAiwRBAApAgQQoAINARoLQQAgASABKAIAKAJ4EQQAIgEgASgCACgCLBEEACkCBBDvAUUNABogACAAKAIAKAJ4EQQAIgAgACgCACgCLBEEACkCBBCgAgsLxgkBA38jAEEwayIFJAAgBSAENgIoIAUgAzYCLAJAAkAgAiADEJMJBEAgAiAEEJMJDQELIAVBADYCECAFQQA2AhwgBUEgaiAFQRBqIAVBHGoQqAUgACAFQSBqEKcFDAELAkAgAyADKAIAKAJ4EQQAIAQgBCgCACgCeBEEABDIAUUNAAJAIAMgAygCACgCrAERBABFBEAgBCAEKAIAKAKsAREEAEUNAQsgBUEANgIQIAVBADYCHCAFQSBqIAVBEGogBUEcahCoBSAAIAVBIGoQpwUMAgsCQCADIAMoAgAoAngRBAAiBiAGKAIAKAJwEQQARQRAIAQgBCgCACgCeBEEACIGIAYoAgAoAnARBABFDQELIAVBADYCECAFQQA2AhwgBUEgaiAFQRBqIAVBHGoQqAUgACAFQSBqEKcFDAILIAMgAygCACgCeBEEABCCAUUEQCAEIAQoAgAoAngRBAAQggFFDQELIAAgBUEsaiAFQShqEJEEDAELIAVBFDYCECAFQRQ2AhwgBUEgaiAFQRBqIAVBHGoQkQQCQAJAAkACQCACQel+aiIDQRlLDQBBASADdCIEQZ+f7wNxDQECQCAEQYCAgBxxRQRAQQEgA3RB4ABxRQ0CIAUoAiwiASABKAIAKAKAAREEABChAkUNASAFKAIoIgEgASgCACgCgAERBAAQoQJFDQEgACAFQSxqIAVBKGoQkQQMBgsgACAFQSxqIAVBKGoQkQQMBQsgBUEANgIcIAVBADYCDCAFQRBqIAVBHGogBUEMahCoBSAAIAVBEGoQpwUMBAsgAkEBRw0BCyAFKAIsIgIgAigCACgCgAERBAAgBSgCKCICIAIoAgAoAoABEQQARgRAIAAgBUEsaiAFQShqEJEEDAMLIAVBEGogASAFKAIsIgIgAigCACgCgAERBAAgBSgCKCICIAIoAgAoAoABEQQAEPgZAn8gBUEgaiICIgMgBUEQaiIEELMDIANBBGogBEEEahCzAyACIgQoAgAiBkEURwsEQCACEDgiAygCAEEURw0CCyAFQQA2AhwgBUEANgIMIAVBEGogBUEcaiAFQQxqEKgFIAAgBUEQahCnBQwCCyAFKAIsIgEgASgCACgCeBEEACAFKAIoIgEgASgCACgCeBEEABC2AgRAIAAgBUEsaiAFQShqEJEEDAILIAVBADYCHCAFQQA2AgwgBUEQaiAFQRxqIAVBDGoQqAUgACAFQRBqEKcFDAELIAUoAiwiAiACKAIAKAJ4EQQAIgIgAigCACgCHBEEACEHIAUoAiwhAgJAIAYgB0cEQCACIAIoAgAoAhQRBAAhBiAEKAIAIQQgBSgCLCECIAYEQCAFIAQgAiACKAIAKAIUEQQAEJIJNgIQDAILIAUgASAEIAIQqQU2AhAMAQsgBSACNgIQCyADKAIAIQQgBSgCKCICIAIoAgAoAngRBAAiAiACKAIAKAIcEQQAIQYgBSgCKCECAkAgBCAGRwRAIAIgAigCACgCFBEEACEEIAMoAgAhAyAFKAIoIQIgBARAIAUgAyACIAIoAgAoAhQRBAAQkgk2AhwMAgsgBSABIAMgAhCpBTYCHAwBCyAFIAI2AhwLIAAgBUEQaiAFQRxqEJEECyAFQTBqJAALTwECfyMAQeAAayICJAAgAkHYAGpBARCIAiIDQQAQFyAAEF0gAyACQQpBAkEBQQBBAEEAEEgiAyABQQEQ4AIhASADED0aIAJB4ABqJAAgAQtuAQJ/IwBBEGsiASQAIAAgACgCAEF0aigCAGooAhgEQAJAIAFBCGogABCTByICLQAARQ0AIAAgACgCAEF0aigCAGooAhgQqw5Bf0cNACAAIAAoAgBBdGooAgBqQQEQ/AMLIAIQkQcLIAFBEGokAAsKACAAIAEQ5QEaCzgBAX8gACABRwRAIAIoAgAhAwNAIAMgABCYASACIAIoAgBBBGoiAzYCACAAQQRqIgAgAUcNAAsLCwoAIAAgARDlARoLIgAgAC0ABEF8akH/AXEiAEEJTQRAQf8FIAB2QQFxDwtBAAsNACAALQAEQX9qQQNJCw0AIAAtAARBcWpBAkkLSQEBfwJAIAAgACgCACgCaBEEAA0AIAAgACgCACgCbBEEAA0AIAAgACgCACgCiAERBAANACAAIAAoAgAoAnARBABBAXMhAQsgAQsfACAAKAIEIgBBFHRB/////wFKIABBgIDAAHFBFHZyCw4AIAAtAAVB8AFxQQBHCwoAIABBFGoQxA4LCgAgAEEUahCfCQsKACAAQRRqEKAJCwoAIABBFGoQoQkLlAQBA38jAEEQayIEJAACQCAAIAAoAgAoAoQBEQQALQAHQQdxDQACQCAAIAAoAgAoAoABEQQAQQhGDQAgACAAKAIAKAKAAREEAEEJRg0AIAAgACgCACgCgAERBABBAUYNACAAIAAoAgAoAoABEQQAQQNHDQELIAAgACgCACgChAERBAAiAiABQRh0QYCAgDhxrSACKQIEQv///0eDhDcCBCAAIAAoAgAoAiARBAAiAgRAIAIgAigCACgCwAERBAAiACABIAAoAgAoAowBEQIAIAIgAigCACgCxAERBAAiACABIAAoAgAoAowBEQIADAELIAAgACgCACgCHBEEACICBEAgAiACKAIAKAK8AREEACIAIAEgACgCACgCjAERAgAMAQsgACAAKAIAKAIYEQQAIgIEQAJAIAQgAiACKAIAKAK8AREEABCDBiICEB9FDQBBACEAA0AgAigCACAAEBooAgAiAyADKAIAKAIMEQQAIgNFDQEgAyABIAMoAgAoAowBEQIAIABBAWoiACACEB9JDQALCyACELUBDAELIAAgACgCACgCJBEEACIARQ0AIAAgACgCACgCvAERBAAiAiACKAIAKAIMEQQAIgJFDQAgAiABIAIoAgAoAowBEQIAIAAgACgCACgCwAERBAAiACAAKAIAKAIMEQQAIgBFDQAgACABIAAoAgAoAowBEQIACyAEQRBqJAALBwAgAC0ABAsHACAALQAYCwwAIABBFGogARCVAQsTACAAIAAoAgBBdGooAgBqEJ4HC0AAIAAgAxCFBiAAIAE2AmggAEGssAk2AgAgAEHsAGoQ0gEhASAAQfwAahCEBhogAEEANgKEASABIAIQ4QIaIAALBwAgACgCbAsIACAALQCgAQsKACAAQQE6AKABCwgAIABBkAFqCw4AIABBkAFqIAEQ4QIaCwgAIAAQqQkaCwgAIAAQrQkaCwgAIAAQrgkaC68BAQR/IwBBEGsiBSQAA0ACQCAEIAJODQAgACgCGCIDIAAoAhwiBk8EQCAAIAEsAAAQuwEgACgCACgCNBEFAEF/Rg0BIARBAWohBCABQQFqIQEFIAUgBiADazYCDCAFIAIgBGs2AgggBUEMaiAFQQhqEOUEIQMgACgCGCABIAMoAgAiAxDrASAAIAMgACgCGGo2AhggAyAEaiEEIAEgA2ohAQsMAQsLIAVBEGokACAECwgAIAAQrwkaC6YBAQF/AkAgAS0ABARAIAFBACAAIAEoAgAoAigRAABFDQELIAEgABDkAwJAIAEtAAcEQCAAKAIYIgIgASACKAIAKAIIEQIAIAAoAhQiAiABIAIoAgAoAggRAgAMAQsgACgCFCICIAEgAigCACgCCBECACAAKAIYIgIgASACKAIAKAIIEQIACyABEPwCIAEtAAZFDQAgAUECIAAgASgCACgCKBEAABoLC2UBAX8CQCABLQAEBEAgAUEAIAAgASgCACgCJBEAAEUNAQsgACgCGARAIAEgABDkAyAAKAIYIgIgASACKAIAKAIIEQIAIAEQ/AILIAEtAAZFDQAgAUECIAAgASgCACgCJBEAABoLC+wBAQF/AkAgAS0ABARAIAFBACAAIAEoAgAoAiAR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EMcJIAJBEGokACADCy0BAX8jAEEQayIBJAAgABDFCSABQQA2AgwgAEEIaiABQQxqEMQJIAFBEGokAAs3AQJ/IwBBEGsiAiQAIAEoAgBBEBDJASIDQQA2AgAgACADIAJBCGogARDaBBCQARogAkEQaiQACzoBAn8jAEEQayIBJAAQyAkhAiAAEMkJIQAgAUEANgIMIAEgADYCCCACIAFBCGoQxwkgAUEQaiQAIAILMwEBfyACBEAgACEDA0AgAyABKAIANgIAIANBBGohAyABQQRqIQEgAkF/aiICDQALCyAAC5QBAQJ/AkAgACgCBCIBRQ0AIAEgASgCACgCwAERBAAQH0EBSA0AIAAoAgQiASABKAIAKALAAREEACgCAEEAEBooAgAiASABKAIAKAIUEQQARQ0AIAAoAgQiACAAKAIAKALAAREEACgCAEEAEBooAgAiACAAKAIAKAIUEQQAEFNBABAXIgBBACAAKAIIQQhGGyECCyACCz0BAX8gACgCDCICQQRxBH8gACABECYQrgcgACABEJcEIAAoAgwFIAILQQJxBEAgARAbQagMKAIAENwGGgsLewECfyMAQRBrIgMkABCaDARAIAAoAgQQiwUgACgCJCICRQRAIABB3L8RNgIkQdy/ESECCyAAKAIMIAAoAhggACgCKCAAKAIcIAAoAiAgAiAAKAIQIAEgAyAAQSxqEPQBIgEgAEE4ahCFFyECIAEQKBoLIANBEGokACACCzEBAn8jAEEQayICJABBDBArIgNBADYCACAAIAMgAkEIaiABENoEEJABGiACQRBqJAALJQEBfyMAQRBrIgEkACAAIAFBCGoQzgkQiw8hACABQRBqJAAgAAsPACAABEAgABBFIAAQMAsLdwEDfyMAQcAIayIDJAAgAEFAaygCACIEBEAgA0G4CGoQ0QkhBRDPAhDCCCAEIANBCGogABDZAygCACAAIAIgBSACGxCrEyIAIAQoAgAoAggRAgAgABCqEyAAQThqIAEQnxMQzwIQjRcgABD+BxoLIANBwAhqJAALRgECfyAALQCAAgR/QQAFIABBAToAgAIgACgCBBCLBQNAIAIgACABEM0WQQFzciECIAFBAWoiAUEORw0ACyACQQFzC0EBcQsxAQF/IwBBEGsiAiQAIAIgATYCDCAAIAEoAghBDGxqQQhqIAJBDGoQsQcg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C40BAQN/IwBBEGsiBCQAQe////8DIAFPBEACQCABQQFNBEAgACABENYBIAAhBQwBCyAAIAEQtgVBAWoiAxC1BSIFEMEBIAAgAxDnASAAIAEQqQELIAUhAyABIgAEfyADIAIgABDUDwUgAwsaIARBADYCDCAFIAFBAnRqIARBDGoQpwIgBEEQaiQADwsQfQALgQEBA38jAEEQayIFJAACQCAAEJYGIgQgABAmIgNrIAJPBEAgAkUNASAAEBsiBCADQQJ0aiABIAIQkwQgACACIANqIgAQgAMgBUEANgIMIAQgAEECdGogBUEMahCnAgwBCyAAIAQgAiADaiAEayADIANBACACIAEQ4gkLIAVBEGokAAuEAQECfyMAQRBrIgEkAAJAIAC9QiCIp0H/////B3EiAkH7w6T/A00EQCACQYCAgPIDSQ0BIABEAAAAAAAAAABBABDnCSEADAELIAJBgIDA/wdPBEAgACAAoSEADAELIAAgARC7ByECIAErAwAgASsDCCACQQFxEOcJIQALIAFBEGokACAAC3oBBH8jAEEQayIEJAACQCAAEJYGIgMgAk8EQCAAEBsiBiEFIAIiAwR/IAUgASADENMPBSAFCxogBEEANgIMIAYgAkECdGogBEEMahCnAiAAIAIQgAMMAQsgACADIAIgA2sgABAmIgBBACAAIAIgARDiCQsgBEEQaiQAC34BA38jAEEQayIDJABB7////wMgAk8EQAJAIAJBAU0EQCAAIAIQ1gEgACEEDAELIAAgAhC2BUEBaiIFELUFIgQQwQEgACAFEOcBIAAgAhCpAQsgBCABIAIQkwQgA0EANgIMIAQgAkECdGogA0EMahCnAiADQRBqJAAPCxB9AAt5AQN/IwBBEGsiAyQAQW8gAU8EQAJAIAFBCk0EQCAAIAEQ1gEgACEEDAELIAAgACABEO8CQQFqIgUQ/QMiBBDBASAAIAUQ5wEgACABEKkBCyAEIAEgAhDkCSADQQA6AA8gASAEaiADQQ9qEI4BIANBEGokAA8LEH0AC3kBAn8jAEEQayIDJABBbyACTwRAAkAgAkEKTQRAIABBARDWASAAIQIMAQsgACAAIAIQ7wJBAWoiBBD9AyICEMEBIAAgBBDnASAAQQEQqQELIAIgAUEBEOsBIANBADoADyACQQFqIANBD2oQjgEgA0EQaiQADwsQfQAL7wEBBH8jAEEQayICJAAgAiABNgIMQW8gAU8EQCAAEGAhAyACIAAQJjYCCCACIAJBDGogAkEIahBfKAIAIgE2AgwgAiABEO8CIgE2AgwCQCABIANGDQACfyABQQpGBEAgACEBQQEhAyAAKAIADAELQQEhBUEAIAEgA00gACACKAIMQQFqEP0DIgEbDQEgABDLASEDIAAQGwshBCABIAQgABAmQQFqEOsBIAMEQCAEEDALAkAgBQRAIAAgAigCDEEBahDnASAAIAIoAggQqQEgACABEMEBDAELIAAgAigCCBDWAQsLIAJBEGokAA8LEH0AC14BAn8jAEEQayICJAACQCAAEMsBBEAgACgCACEDIAJBADoADyABIANqIAJBD2oQjgEgACABEKkBDAELIAJBADoADiAAIAFqIAJBDmoQjgEgACABENYBCyACQRBqJAALcAEEfyMAQRBrIgQkACABBEAgABBgIQIgABAmIgMgAWohBSACIANrIAFJBEAgACACIAUgAmsgAyADELwHCyADIAAQGyICaiABQQAQ5AkgACAFEIADIARBADoADyACIAVqIARBD2oQjgELIARBEGokAAsiAQF/IAAQJiICIAFJBEAgACABIAJrEM8PDwsgACABEM4PC1wBAX8jAEEQayIFJAAgBSADNgIMIAAgBBC0BRogARAmIgMgAkkEQBB9AAsgARAbIQEgBSADIAJrNgIIIAAgASACaiAFQQxqIAVBCGoQ0wEoAgAQlAYgBUEQaiQAC5UOAg9/AnwjAEGwBGsiBSQAIAIgAkF9akEYbSIEQQAgBEEAShsiDUFobGohC0HUDygCACIKIANBf2oiCGpBAE4EQCADIApqIQQgDSAIayECA0AgBUHAAmogBkEDdGogAkEASAR8RAAAAAAAAAAABSACQQJ0QeAPaigCALcLOQMAIAJBAWohAiAGQQFqIgYgBEcNAAsLIAtBaGohB0EAIQQgA0EBSCEGA0ACQCAGBEBEAAAAAAAAAAAhEwwBCyAEIAhqIQlBACECRAAAAAAAAAAAIRMDQCATIAAgAkEDdGorAwAgBUHAAmogCSACa0EDdGorAwCioCETIAJBAWoiAiADRw0ACwsgBSAEQQN0aiATOQMAIAQgCkghAiAEQQFqIQQgAg0AC0EXIAdrIRBBGCAHayEOIAohBAJAA0AgBSAEQQN0aisDACETQQAhAiAEIQYgBEEBSCIMRQRAA0AgBUHgA2ogAkECdGoCfyATAn8gE0QAAAAAAABwPqIiE5lEAAAAAAAA4EFjBEAgE6oMAQtBgICAgHgLtyITRAAAAAAAAHDBoqAiFJlEAAAAAAAA4EFjBEAgFKoMAQtBgICAgHgLNgIAIAUgBkF/aiIGQQN0aisDACAToCETIAJBAWoiAiAERw0ACwsCfyATIAcQyAMiEyATRAAAAAAAAMA/opxEAAAAAAAAIMCioCITmUQAAAAAAADgQWMEQCATqgwBC0GAgICAeAshCCATIAi3oSETAkACQAJAAn8gB0EBSCIRRQRAIARBAnQgBWoiAiACKALcAyICIAIgDnUiAiAOdGsiBjYC3AMgAiAIaiEIIAYgEHUMAQsgBw0BIARBAnQgBWooAtwDQRd1CyIJQQFIDQIMAQtBAiEJIBNEAAAAAAAA4D9mQQFzRQ0AQQAhCQwBC0EAIQJBACEGIAxFBEADQCAFQeADaiACQQJ0aiISKAIAIQxB////ByEPAkACQCAGRQRAIAxFDQFBgICACCEPQQEhBgsgEiAPIAxrNgIADAELQQAhBgsgAkEBaiICIARHDQALCwJAIBENACAHQX9qIgJBAUsNACACQQFrBEAgBEECdCAFaiICIAIoAtwDQf///wNxNgLcAwwBCyAEQQJ0IAVqIgIgAigC3ANB////AXE2AtwDCyAIQQFqIQggCUECRw0ARAAAAAAAAPA/IBOhIRNBAiEJIAZFDQAgE0QAAAAAAADwPyAHEMgDoSETCyATRAAAAAAAAAAAYQRAQQAhBgJAIAQiAiAKTA0AA0AgBUHgA2ogAkF/aiICQQJ0aigCACAGciEGIAIgCkoNAAsgBkUNACAHIQsDQCALQWhqIQsgBUHgA2ogBEF/aiIEQQJ0aigCAEUNAAsMAwtBASECA0AgAiIGQQFqIQIgBUHgA2ogCiAGa0ECdGooAgBFDQALIAQgBmohBgNAIAVBwAJqIAMgBGoiCEEDdGogBEEBaiIEIA1qQQJ0QeAPaigCALc5AwBBACECRAAAAAAAAAAAIRMgA0EBTgRAA0AgEyAAIAJBA3RqKwMAIAVBwAJqIAggAmtBA3RqKwMAoqAhEyACQQFqIgIgA0cNAAsLIAUgBEEDdGogEzkDACAEIAZIDQALIAYhBAwBCwsCQCATQQAgB2sQyAMiE0QAAAAAAABwQWZBAXNFBEAgBUHgA2ogBEECdGoCfyATAn8gE0QAAAAAAABwPqIiE5lEAAAAAAAA4EFjBEAgE6oMAQtBgICAgHgLIgK3RAAAAAAAAHDBoqAiE5lEAAAAAAAA4EFjBEAgE6oMAQtBgICAgHgLNgIAIARBAWohBAwBCwJ/IBOZRAAAAAAAAOBBYwRAIBOqDAELQYCAgIB4CyECIAchCwsgBUHgA2ogBEECdGogAjYCAAtEAAAAAAAA8D8gCxDIAyETAkAgBEF/TA0AIAQhAgNAIAUgAkEDdGogEyAFQeADaiACQQJ0aigCALeiOQMAIBNEAAAAAAAAcD6iIRMgAkEASiEAIAJBf2ohAiAADQALIARBf0wNACAEIQIDQCAEIAIiAGshA0QAAAAAAAAAACETQQAhAgNAAkAgEyACQQN0QbAlaisDACAFIAAgAmpBA3RqKwMAoqAhEyACIApODQAgAiADSSEHIAJBAWohAiAHDQELCyAFQaABaiADQQN0aiATOQMAIABBf2ohAiAAQQBKDQALC0QAAAAAAAAAACETIARBAE4EQCAEIQIDQCATIAVBoAFqIAJBA3RqKwMAoCETIAJBAEohACACQX9qIQIgAA0ACwsgASATmiATIAkbOQMAIAUrA6ABIBOhIRNBASECIARBAU4EQANAIBMgBUGgAWogAkEDdGorAwCgIRMgAiAERyEAIAJBAWohAiAADQALCyABIBOaIBMgCRs5AwggBUGwBGokACAIQQdxC2kBAX8CQCAAIAFrQQJ1IAJJBEADQCAAIAJBf2oiAkECdCIDaiABIANqKAIANgIAIAINAAwCAAsACyACRQ0AIAAhAwNAIAMgASgCADYCACADQQRqIQMgAUEEaiEBIAJBf2oiAg0ACwsgAAspAQF/IAIEQCAAIQMDQCADIAE2AgAgA0EEaiEDIAJBf2oiAg0ACwsgAAstAANAIAAoAgBBAUYNAAsgACgCAEUEQCAAQQE2AgAgAUEnEQgAIABBfzYCAAsLOgIBfwF+IwBBEGsiAyQAIAMgASACEIABEI4XIAMpAwAhBCAAIAMpAwg3AwggACAENwMAIANBEGokAAswAQF/IAAQlAogABDLAQRAIAAoAgAhASAAEJYGGiABEDAgAEEAEOcBIABBABDWAQsLOAECfyAAKAIAIAAoAggiAkEBdWohASAAKAIEIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRCAALJQADQCABIAAoAghHBEAgACgCEBogACAAKAIIQXxqNgIIDAELCwsnACADIAMoAgAgAiABayIAayICNgIAIABBAU4EQCACIAEgABBAGgsLYAEBf0HQ4BEQ/QlB0OAREJoEQdDgESgCAEHU4BEoAgAgAEEEaiIBENoPQdDgESABEPUBQdTgESAAQQhqEPUBQdDgERCXASAAEDoQ9QEgACAAKAIENgIAQdDgERAfEO0JCzEBAX8gACgCEBogACgCCCECA0AgAhDsCSAAIAAoAghBBGoiAjYCCCABQX9qIgENAAsLaQECfyMAQRBrIgQkACAEQQA2AgwgAEEMaiAEQQxqIAMQpgIgAQRAIAAoAhAgARDuCSEFCyAAIAU2AgAgACAFIAJBAnRqIgI2AgggACACNgIEIAAQOiAFIAFBAnRqNgIAIARBEGokACAAC1kBAn8jAEEQayIBJAAgASAANgIMEO8JIgIgAE8EQEHQ4BEQmQQiACACQQF2SQRAIAEgAEEBdDYCCCABQQhqIAFBDGoQXygCACECCyABQRBqJAAgAg8LEH0ACyQAAkAgAUEcSw0AIAAtAHANACAAQQE6AHAgAA8LIAFBAnQQKwu0AgEGfyMAQSBrIgMkACADIAAoAhwiBDYCECAAKAIUIQUgAyACNgIcIAMgATYCGCADIAUgBGsiATYCFCABIAJqIQZBAiEFIANBEGohAQNAAkACfyAGAn8gACgCPCABIAUgA0EMahAKEPEJBEAgA0F/NgIMQX8MAQsgAygCDAsiBEYEQCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgBEF/Sg0BIABBADYCHCAAQgA3AxAgACAAKAIAQSByNgIAQQAgBUECRg0AGiACIAEoAgRrCyEEIANBIGokACAEDwsgAUEIaiABIAQgASgCBCIHSyIIGyIBIAQgB0EAIAgbayIHIAEoAgBqNgIAIAEgASgCBCAHazYCBCAGIARrIQYgBSAIayEFDAAACwALCQBB5NURECgaCzEAAkBB8NURLQAAQQFxDQBB8NUREK4BRQ0AQeTVEUH01QAQ3wRB8NUREK0BC0Hk1RELCQBB1NURECgaCzEAAkBB4NURLQAAQQFxDQBB4NUREK4BRQ0AQdTVEUHo1QAQaBpB4NUREK0BC0HU1RELCQBBxNURECgaCzEAAkBB0NURLQAAQQFxDQBB0NUREK4BRQ0AQcTVEUGU1QAQ3wRB0NUREK0BC0HE1RELCQBBtNURECgaCzEAAkBBwNURLQAAQQFxDQBBwNUREK4BRQ0AQbTVEUH81AAQaBpBwNUREK0BC0G01RELCQBBpNURECgaCzEAAkBBsNURLQAAQQFxDQBBsNUREK4BRQ0AQaTVEUHY1AAQ3wRBsNUREK0BC0Gk1RELCQBBlNURECgaCzEAAkBBoNURLQAAQQFxDQBBoNUREK4BRQ0AQZTVEUHM1AAQaBpBoNUREK0BC0GU1RELCQBBhNURECgaCzEAAkBBkNURLQAAQQFxDQBBkNUREK4BRQ0AQYTVEUGo1AAQ3wRBkNUREK0BC0GE1RELCQBB9NQRECgaCzEAAkBBgNURLQAAQQFxDQBBgNUREK4BRQ0AQfTUEUGc1AAQaBpBgNUREK0BC0H01BELGwBB+N0RIQADQCAAQXRqECgiAEHg3RFHDQALC1IBAX8CQEH43REtAABBAXENAEH43REQrgFFDQBB4N0RIQADQCAAENMCQQxqIgBB+N0RRw0AC0H43REQrQELQeDdEUGo/wAQeEHs3RFBtP8AEHgLNwACQEHw1BEtAABBAXENAEHw1BEQrgFFDQAQ8g9B7NQRQeDdETYCAEHw1BEQrQELQezUESgCAAsbAEHY3REhAANAIABBdGoQKCIAQcDdEUcNAAsLUQEBfwJAQdjdES0AAEEBcQ0AQdjdERCuAUUNAEHA3REhAANAIAAQTkEMaiIAQdjdEUcNAAtB2N0REK0BC0HA3RFBoP8AEGdBzN0RQaP/ABBnCzcAAkBB6NQRLQAAQQFxDQBB6NQREK4BRQ0AEPUPQeTUEUHA3RE2AgBB6NQREK0BC0Hk1BEoAgALGwBBsN0RIQADQCAAQXRqECgiAEGQ2xFHDQALC64CAQF/AkBBsN0RLQAAQQFxDQBBsN0REK4BRQ0AQZDbESEAA0AgABDTAkEMaiIAQbDdEUcNAAtBsN0REK0BC0GQ2xFBmPsAEHhBnNsRQbj7ABB4QajbEUHc+wAQeEG02xFB9PsAEHhBwNsRQYz8ABB4QczbEUGc/AAQeEHY2xFBsPwAEHhB5NsRQcT8ABB4QfDbEUHg/AAQeEH82xFBiP0AEHhBiNwRQaj9ABB4QZTcEUHM/QAQeEGg3BFB8P0AEHhBrNwRQYD+ABB4QbjcEUGQ/gAQeEHE3BFBoP4AEHhB0NwRQYz8ABB4QdzcEUGw/gAQeEHo3BFBwP4AEHhB9NwRQdD+ABB4QYDdEUHg/gAQeEGM3RFB8P4AEHhBmN0RQYD/ABB4QaTdEUGQ/wAQeAs3AAJAQeDUES0AAEEBcQ0AQeDUERCuAUUNABD4D0Hc1BFBkNsRNgIAQeDUERCtAQtB3NQRKAIACxsAQYDbESEAA0AgAEF0ahAoIgBB4NgRRw0ACwutAgEBfwJAQYDbES0AAEEBcQ0AQYDbERCuAUUNAEHg2BEhAANAIAAQTkEMaiIAQYDbEUcNAAtBgNsREK0BC0Hg2BFBlPoAEGdB7NgRQZz6ABBnQfjYEUGl+gAQZ0GE2RFBq/oAEGdBkNkRQbH6ABBnQZzZEUG1+gAQZ0Go2RFBuvoAEGdBtNkRQb/6ABBnQcDZEUHG+gAQZ0HM2RFB0PoAEGdB2NkRQdj6ABBnQeTZEUHh+gAQZ0Hw2RFB6voAEGdB/NkRQe76ABBnQYjaEUHy+gAQZ0GU2hFB9voAEGdBoNoRQbH6ABBnQazaEUH6+gAQZ0G42hFB/voAEGdBxNoRQYL7ABBnQdDaEUGG+wAQZ0Hc2hFBivsAEGdB6NoRQY77ABBnQfTaEUGS+wAQZws3AAJAQdjUES0AAEEBcQ0AQdjUERCuAUUNABD7D0HU1BFB4NgRNgIAQdjUERCtAQtB1NQRKAIACxsAQdjYESEAA0AgAEF0ahAoIgBBsNcRRw0ACwvKAQEBfwJAQdjYES0AAEEBcQ0AQdjYERCuAUUNAEGw1xEhAANAIAAQ0wJBDGoiAEHY2BFHDQALQdjYERCtAQtBsNcRQcD3ABB4QbzXEUHc9wAQeEHI1xFB+PcAEHhB1NcRQZj4ABB4QeDXEUHA+AAQeEHs1xFB5PgAEHhB+NcRQYD5ABB4QYTYEUGk+QAQeEGQ2BFBtPkAEHhBnNgRQcT5ABB4QajYEUHU+QAQeEG02BFB5PkAEHhBwNgRQfT5ABB4QczYEUGE+gAQeAs3AAJAQdDUES0AAEEBcQ0AQdDUERCuAUUNABD+D0HM1BFBsNcRNgIAQdDUERCtAQtBzNQRKAIACxsAQajXESEAA0AgAEF0ahAoIgBBgNYRRw0ACwvJAQEBfwJAQajXES0AAEEBcQ0AQajXERCuAUUNAEGA1hEhAANAIAAQTkEMaiIAQajXEUcNAAtBqNcREK0BC0GA1hFB6PYAEGdBjNYRQe/2ABBnQZjWEUH29gAQZ0Gk1hFB/vYAEGdBsNYRQYj3ABBnQbzWEUGR9wAQZ0HI1hFBmPcAEGdB1NYRQaH3ABBnQeDWEUGl9wAQZ0Hs1hFBqfcAEGdB+NYRQa33ABBnQYTXEUGx9wAQZ0GQ1xFBtfcAEGdBnNcRQbn3ABBnCzcAAkBByNQRLQAAQQFxDQBByNQREK4BRQ0AEIEQQcTUEUGA1hE2AgBByNQREK0BC0HE1BEoAgALCwAgAEGE1AAQ3wQLCwAgAEH80wAQaBoLCwAgAEHo0wAQ3wQLCwAgAEHg0wAQaBoLDQAgACABQRBqEPQBGgsNACAAIAFBDGoQ9AEaCwcAIAAoAgwLBwAgACwACQsHACAALAAICwkAIAAQ8wkQMAsJACAAEPQJEDAL7QMBB38gACEDA0ACQCAHIAJPIAMgAU9yDQAgAywAACIEQf8BcSEFAn8gBEEATgRAIAVB///DAEsNAiADQQFqDAELIAVBwgFJDQEgBUHfAU0EQCABIANrQQJIDQIgAy0AASIEQcABcUGAAUcgBEE/cSAFQQZ0QcAPcXJB///DAEtyDQIgA0ECagwBCwJAAkAgBUHvAU0EQCABIANrQQNIDQQgAy0AAiEGIAMtAAEhBCAFQe0BRg0BIAVB4AFGBEAgBEHgAXFBoAFGDQMMBQsgBEHAAXFBgAFHDQQMAgsgASADa0EESCAFQfQBS3INAyADLQADIQYgAy0AAiEIIAMtAAEhBAJAAkAgBUGQfmoiCUEESw0AAkACQCAJQQFrDgQCAgIBAAsgBEHwAGpB/wFxQTBJDQIMBgsgBEHwAXFBgAFGDQEMBQsgBEHAAXFBgAFHDQQLIAhBwAFxQYABRyAGQcABcUGAAUdyIAZBP3EgCEEGdEHAH3EgBUESdEGAgPAAcSAEQT9xQQx0cnJyQf//wwBLcg0DIANBBGoMAgsgBEHgAXFBgAFHDQILIAZBwAFxQYABRyAGQT9xIAVBDHRBgOADcSAEQT9xQQZ0cnJB///DAEtyDQEgA0EDagshAyAHQQFqIQcMAQsLIAMgAGsLCwAgAiADIAQQjhALuQQBBn8gAiAANgIAIAUgAzYCAANAIAIoAgAiBiABTwRAQQAPC0EBIQkCQAJAAkAgBSgCACILIARPDQAgBiwAACIAQf8BcSEDIABBAE4EQCADQf//wwBLDQNBASEADAILIANBwgFJDQIgA0HfAU0EQCABIAZrQQJIDQFBAiEJIAYtAAEiB0HAAXFBgAFHDQFBAiEAIAdBP3EgA0EGdEHAD3FyIgNB///DAE0NAgwBCwJAIANB7wFNBEAgASAGa0EDSA0CIAYtAAIhCCAGLQABIQcCQAJAIANB7QFHBEAgA0HgAUcNASAHQeABcUGgAUYNAgwHCyAHQeABcUGAAUYNAQwGCyAHQcABcUGAAUcNBQsgCEHAAXFBgAFGDQEMBAsgA0H0AUsNAyABIAZrQQRIDQEgBi0AAyEIIAYtAAIhCiAGLQABIQcCQAJAIANBkH5qIgBBBEsNAAJAAkAgAEEBaw4EAgICAQALIAdB8ABqQf8BcUEwTw0GDAILIAdB8AFxQYABRw0FDAELIAdBwAFxQYABRw0ECyAKQcABcUGAAUcgCEHAAXFBgAFHcg0DQQQhAEECIQkgCEE/cSAKQQZ0QcAfcSADQRJ0QYCA8ABxIAdBP3FBDHRycnIiA0H//8MASw0BDAILQQMhAEECIQkgCEE/cSADQQx0QYDgA3EgB0E/cUEGdHJyIgNB///DAE0NAQsgCQ8LIAsgAzYCACACIAAgBmo2AgAgBSAFKAIAQQRqNgIADAELC0ECC00AIwBBEGsiACQAIAAgAjYCDCAAIAU2AgggAiADIABBDGogBSAGIABBCGoQkBAhASAEIAAoAgw2AgAgByAAKAIINgIAIABBEGokACABC9YDAQF/IAIgADYCACAFIAM2AgAgAigCACEDAkADQCADIAFPBEBBACEGDAILQQIhBiADKAIAIgBB///DAEsgAEGAcHFBgLADRnINAQJAAkAgAEH/AE0EQEEBIQYgBCAFKAIAIgNrQQFIDQQgBSADQQFqNgIAIAMgADoAAAwBCyAAQf8PTQRAIAQgBSgCACIDa0ECSA0CIAUgA0EBajYCACADIABBBnZBwAFyOgAAIAUgBSgCACIDQQFqNgIAIAMgAEE/cUGAAXI6AAAMAQsgBCAFKAIAIgNrIQYgAEH//wNNBEAgBkEDSA0CIAUgA0EBajYCACADIABBDHZB4AFyOgAAIAUgBSgCACIDQQFqNgIAIAMgAEEGdkE/cUGAAXI6AAAgBSAFKAIAIgNBAWo2AgAgAyAAQT9xQYABcjoAAAwBCyAGQQRIDQEgBSADQQFqNgIAIAMgAEESdkHwAXI6AAAgBSAFKAIAIgNBAWo2AgAgAyAAQQx2QT9xQYABcjoAACAFIAUoAgAiA0EBajYCACADIABBBnZBP3FBgAFyOgAAIAUgBSgCACIDQQFqNgIAIAMgAEE/cUGAAXI6AAALIAIgAigCAEEEaiIDNgIADAELC0EBDwsgBgtNACMAQRBrIgAkACAAIAI2AgwgACAFNgIIIAIgAyAAQQxqIAUgBiAAQQhqEJIQIQEgBCAAKAIMNgIAIAcgACgCCDYCACAAQRBqJAAgAQv5AwEHfyAAIQMDQAJAIAYgAk8gAyABT3INACADLQAAIgRB///DAEsNAAJ/IANBAWogBEEYdEEYdUEATg0AGiAEQcIBSQ0BIARB3wFNBEAgASADa0ECSA0CIAMtAAEiBUHAAXFBgAFHIAVBP3EgBEEGdEHAD3FyQf//wwBLcg0CIANBAmoMAQsCQAJAIARB7wFNBEAgASADa0EDSA0EIAMtAAIhByADLQABIQUgBEHtAUYNASAEQeABRgRAIAVB4AFxQaABRg0DDAULIAVBwAFxQYABRw0EDAILIAIgBmtBAkkgBEH0AUtyIAEgA2tBBEhyDQMgAy0AAyEHIAMtAAIhCCADLQABIQUCQAJAIARBkH5qIglBBEsNAAJAAkAgCUEBaw4EAgICAQALIAVB8ABqQf8BcUEwSQ0CDAYLIAVB8AFxQYABRg0BDAULIAVBwAFxQYABRw0ECyAIQcABcUGAAUcgB0HAAXFBgAFHciAHQT9xIAhBBnRBwB9xIARBEnRBgIDwAHEgBUE/cUEMdHJyckH//8MAS3INAyAGQQFqIQYgA0EEagwCCyAFQeABcUGAAUcNAgsgB0HAAXFBgAFHIAdBP3EgBEEMdEGA4ANxIAVBP3FBBnRyckH//8MAS3INASADQQNqCyEDIAZBAWohBgwBCwsgAyAAawsLACACIAMgBBCUEAueBQEFfyACIAA2AgAgBSADNgIAAkADQCACKAIAIgAgAU8EQEEAIQkMAgtBASEJIAUoAgAiByAETw0BAkAgAC0AACIDQf//wwBLDQAgAgJ/IANBGHRBGHVBAE4EQCAHIAM7AQAgAEEBagwBCyADQcIBSQ0BIANB3wFNBEAgASAAa0ECSA0EIAAtAAEiBkHAAXFBgAFHDQJBAiEJIAZBP3EgA0EGdEHAD3FyIgNB///DAEsNBCAHIAM7AQAgAEECagwBCyADQe8BTQRAIAEgAGtBA0gNBCAALQACIQggAC0AASEGAkACQCADQe0BRwRAIANB4AFHDQEgBkHgAXFBoAFHDQUMAgsgBkHgAXFBgAFHDQQMAQsgBkHAAXFBgAFHDQMLIAhBwAFxQYABRw0CQQIhCSAIQT9xIAZBP3FBBnQgA0EMdHJyIgNB//8DcUH//8MASw0EIAcgAzsBACAAQQNqDAELIANB9AFLDQEgASAAa0EESA0DIAAtAAMhCCAALQACIQYgAC0AASEAAkACQCADQZB+aiIKQQRLDQACQAJAIApBAWsOBAICAgEACyAAQfAAakH/AXFBME8NBAwCCyAAQfABcUGAAUcNAwwBCyAAQcABcUGAAUcNAgsgBkHAAXFBgAFHIAhBwAFxQYABR3INASAEIAdrQQRIDQNBAiEJIAhBP3EiCCAGQQZ0IgpBwB9xIABBDHRBgOAPcSADQQdxIgNBEnRycnJB///DAEsNAyAHIABBAnQiAEHAAXEgA0EIdHIgBkEEdkEDcSAAQTxxcnJBwP8AakGAsANyOwEAIAUgB0ECajYCACAHIApBwAdxIAhyQYC4A3I7AQIgAigCAEEEags2AgAgBSAFKAIAQQJqNgIADAELC0ECDwsgCQtNACMAQRBrIgAkACAAIAI2AgwgACAFNgIIIAIgAyAAQQxqIAUgBiAAQQhqEJYQIQEgBCAAKAIMNgIAIAcgACgCCDYCACAAQRBqJAAgAQu/BQECfyACIAA2AgAgBSADNgIAIAIoAgAhBgJAAkADQCAGIAFPBEBBACEADAMLQQIhACAGLwEAIgNB///DAEsNAgJAAkAgA0H/AE0EQEEBIQAgBCAFKAIAIgZrQQFIDQUgBSAGQQFqNgIAIAYgAzoAAAwBCyADQf8PTQRAIAQgBSgCACIAa0ECSA0EIAUgAEEBajYCACAAIANBBnZBwAFyOgAAIAUgBSgCACIAQQFqNgIAIAAgA0E/cUGAAXI6AAAMAQsgA0H/rwNNBEAgBCAFKAIAIgBrQQNIDQQgBSAAQQFqNgIAIAAgA0EMdkHgAXI6AAAgBSAFKAIAIgBBAWo2AgAgACADQQZ2QT9xQYABcjoAACAFIAUoAgAiAEEBajYCACAAIANBP3FBgAFyOgAADAELIANB/7cDTQRAQQEhACABIAZrQQRIDQUgBi8BAiIHQYD4A3FBgLgDRw0CIAQgBSgCAGtBBEgNBSAHQf8HcSADQQp0QYD4A3EgA0HAB3EiAEEKdHJyQYCABGpB///DAEsNAiACIAZBAmo2AgAgBSAFKAIAIgZBAWo2AgAgBiAAQQZ2QQFqIgBBAnZB8AFyOgAAIAUgBSgCACIGQQFqNgIAIAYgAEEEdEEwcSADQQJ2QQ9xckGAAXI6AAAgBSAFKAIAIgBBAWo2AgAgACAHQQZ2QQ9xIANBBHRBMHFyQYABcjoAACAFIAUoAgAiAEEBajYCACAAIAdBP3FBgAFyOgAADAELIANBgMADSQ0EIAQgBSgCACIAa0EDSA0DIAUgAEEBajYCACAAIANBDHZB4AFyOgAAIAUgBSgCACIAQQFqNgIAIAAgA0EGdkE/cUGAAXI6AAAgBSAFKAIAIgBBAWo2AgAgACADQT9xQYABcjoAAAsgAiACKAIAQQJqIgY2AgAMAQsLQQIPC0EBDwsgAAtNACMAQRBrIgAkACAAIAI2AgwgACAFNgIIIAIgAyAAQQxqIAUgBiAAQQhqEJgQIQEgBCAAKAIMNgIAIAcgACgCCDYCACAAQRBqJAAgAQsVACAAKAIIIgBFBEBBAQ8LIAAQ9gkLRQEBfyMAQRBrIgQkACAEIAM2AgwgBEEIaiAEQQxqEIsDIQNBACAAIAEgAkG80hEgAhsQ/QYhACADEIoDIARBEGokACAAC1kBBH8DQAJAIAIgA0YgBiAET3INACACIAMgAmsgASAAKAIIEJsQIgdBAmoiCEECTQRAQQEhByAIQQJrDQELIAZBAWohBiAFIAdqIQUgAiAHaiECDAELCyAFC0UBAn8jAEEQayIBJAAgASAANgIMIAFBCGogAUEMahCLAyEAIwBBEGsiAiQAIAJBEGokAEEAIQIgABCKAyABQRBqJAAgAgstAQF/QX8hAQJAIAAoAggQnRAEfyABBSAAKAIIIgANAUEBCw8LIAAQ9glBAUYLkgEBAX8jAEEQayIFJAAgBCACNgIAAn9BAiAFQQxqQQAgACgCCBDAByIAQQFqQQJJDQAaQQEgAEF/aiIBIAMgBCgCAGtLDQAaIAVBDGohAgN/IAEEfyACLQAAIQAgBCAEKAIAIgNBAWo2AgAgAyAAOgAAIAFBf2ohASACQQFqIQIMAQVBAAsLCyECIAVBEGokACACC0ABAX8jAEEQayIGJAAgBiAFNgIMIAZBCGogBkEMahCLAyEFIAAgASACIAMgBBDGFyEAIAUQigMgBkEQaiQAIAALvwMBA38jAEEQayIJJAAgAiEIA0ACQCADIAhGBEAgAyEIDAELIAgtAABFDQAgCEEBaiEIDAELCyAHIAU2AgAgBCACNgIAA0ACQAJ/AkAgBSAGRiACIANGcg0AIAkgASkCADcDCAJAAkACQAJAIAUgBCAIIAJrIAYgBWtBAnUgASAAKAIIEKAQIgpBf0YEQANAAkAgByAFNgIAIAIgBCgCAEYNAAJAIAUgAiAIIAJrIAlBCGogACgCCBD3CSIFQQJqIgFBAksNAEEBIQUCQCABQQFrDgIAAQcLIAQgAjYCAAwECyACIAVqIQIgBygCAEEEaiEFDAELCyAEIAI2AgAMBQsgByAHKAIAIApBAnRqIgU2AgAgBSAGRg0DIAQoAgAhAiADIAhGBEAgAyEIDAgLIAUgAkEBIAEgACgCCBD3CUUNAQtBAgwECyAHIAcoAgBBBGo2AgAgBCAEKAIAQQFqIgI2AgAgAiEIA0AgAyAIRgRAIAMhCAwGCyAILQAARQ0FIAhBAWohCAwAAAsACyAEIAI2AgBBAQwCCyAEKAIAIQILIAIgA0cLIQggCUEQaiQAIAgPCyAHKAIAIQUMAAALAAs+AQF/IwBBEGsiBSQAIAUgBDYCDCAFQQhqIAVBDGoQiwMhBCAAIAEgAiADENIXIQAgBBCKAyAFQRBqJAAgAAvaAwEFfyMAQRBrIgkkACACIQgDQAJAIAMgCEYEQCADIQgMAQsgCCgCAEUNACAIQQRqIQgMAQsLIAcgBTYCACAEIAI2AgBBASEKA0ACQAJAIAUgBkYgAiADRnIEfyACBSAJIAEpAgA3AwgCQAJAAkAgBSAEIAggAmtBAnUgBiAFayAAKAIIEKIQIgtBAWoiDEEBTQRAIAxBAWtFDQUgByAFNgIAA0ACQCACIAQoAgBGDQAgBSACKAIAIAAoAggQwAciAUF/Rg0AIAcgBygCACABaiIFNgIAIAJBBGohAgwBCwsgBCACNgIADAELIAcgBygCACALaiIFNgIAIAUgBkYNAiADIAhGBEAgBCgCACECIAMhCAwHCyAJQQRqQQAgACgCCBDAByIIQX9HDQELQQIhCgwDCyAJQQRqIQUgCCAGIAcoAgBrSwRADAMLA0AgCARAIAUtAAAhAiAHIAcoAgAiC0EBajYCACALIAI6AAAgCEF/aiEIIAVBAWohBQwBCwsgBCAEKAIAQQRqIgI2AgAgAiEIA0AgAyAIRgRAIAMhCAwFCyAIKAIARQ0EIAhBBGohCAwAAAsACyAEKAIACyADRyEKCyAJQRBqJAAgCg8LIAcoAgAhBQwAAAsACwkAIAAQgwoQMAs3ACMAQRBrIgAkACAAIAQ2AgwgACADIAJrNgIIIABBDGogAEEIahDTASgCACEBIABBEGokACABCzQAA0AgASACRkUEQCAEIAEsAAAiACADIABBf0obOgAAIARBAWohBCABQQFqIQEMAQsLIAILDAAgASACIAFBf0obCyoAA0AgASACRkUEQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohAQwBCwsgAgtAAANAIAEgAkcEQCABIAEsAAAiAEEATgR/QfDDACgCACABLAAAQQJ0aigCAAUgAAs6AAAgAUEBaiEBDAELCyACCycAIAFBAE4Ef0HwwwAoAgAgAUH/AXFBAnRqKAIABSABC0EYdEEYdQs/AANAIAEgAkcEQCABIAEsAAAiAEEATgR/QeA3KAIAIAEsAABBAnRqKAIABSAACzoAACABQQFqIQEMAQsLIAILJgAgAUEATgR/QeA3KAIAIAFB/wFxQQJ0aigCAAUgAQtBGHRBGHULCQAgABD5CRAwCzUAA0AgASACRkUEQCAEIAEoAgAiACADIABBgAFJGzoAACAEQQFqIQQgAUEEaiEBDAELCyACCxMAIAEgAiABQYABSRtBGHRBGHULKgADQCABIAJGRQRAIAMgASwAADYCACADQQRqIQMgAUEBaiEBDAELCyACC0EAA0AgASACRwRAIAEgASgCACIAQf8ATQR/QfDDACgCACABKAIAQQJ0aigCAAUgAAs2AgAgAUEEaiEBDAELCyACC94GAQ5/IwBBoAhrIggkACAIQZgIakIANwMAIAhBkAhqQgA3AwAgCEIANwOICCAIQgA3A4AIAkACQAJAAkACQCABLQAAIgRFBEBBfyEJQQEhAgwBCwNAIAAgBWotAABFDQQgCCAEQf8BcSICQQJ0aiAFQQFqIgU2AgAgCEGACGogAkEDdkEccWoiAiACKAIAQQEgBEEfcXRyNgIAIAEgBWotAAAiBA0AC0EBIQJBfyEJIAVBAUsNAQtBfyEGQQEhAwwBC0EBIQpBASEEA0ACfyABIAQgCWpqLQAAIgYgASACai0AACIHRgRAIAQgCkYEQCADIApqIQNBAQwCCyAEQQFqDAELIAYgB0sEQCACIAlrIQogAiEDQQEMAQsgAyEJIANBAWohA0EBIQpBAQsiBCADaiICIAVJDQALQQEhA0F/IQYgBUEBTQRAIAohAgwBC0EAIQJBASEHQQEhBANAAn8gASAEIAZqai0AACINIAEgA2otAAAiC0YEQCAEIAdGBEAgAiAHaiECQQEMAgsgBEEBagwBCyANIAtJBEAgAyAGayEHIAMhAkEBDAELIAIhBiACQQFqIQJBASEHQQELIgQgAmoiAyAFSQ0ACyAKIQIgByEDCwJ/IAEgASADIAIgBkEBaiAJQQFqSyICGyIHaiAGIAkgAhsiDEEBaiIKEMIHBEAgBSAMIAUgDEF/c2oiAiAMIAJLG0EBaiIHayEOQQAMAQsgBSAHayIOCyELIAVBf2ohDSAFQT9yIQ9BACEGIAAhAgNAAkAgACACayAFTw0AIABBACAPEJcGIgMEQCADIgAgAmsgBUkNAwwBCyAAIA9qIQALAn8CfyAFIAhBgAhqIAIgDWotAAAiA0EDdkEccWooAgAgA0EfcXZBAXFFDQAaIAUgCCADQQJ0aigCAGsiAwRAIA4gAyADIAdJGyADIAYbIAMgCxsMAQsCQCABIAoiBCAGIAQgBksbIgNqLQAAIgkEQANAIAIgA2otAAAgCUH/AXFHDQIgASADQQFqIgNqLQAAIgkNAAsLA0AgBCAGTQ0GIAEgBEF/aiIEai0AACACIARqLQAARg0ACyAHIQQgCwwCCyADIAxrCyEEQQALIQYgAiAEaiECDAAACwALQQAhAgsgCEGgCGokACACCwkAIAAoAjwQCwseACABQf8ATQR/QfDDACgCACABQQJ0aigCAAUgAQsLQAADQCABIAJHBEAgASABKAIAIgBB/wBNBH9B4DcoAgAgASgCAEECdGooAgAFIAALNgIAIAFBBGohAQwBCwsgAgsdACABQf8ATQR/QeA3KAIAIAFBAnRqKAIABSABCwtEAAJAA0AgAiADRg0BAkAgAigCAEH/AEsNAEHcMSgCACACKAIAQQF0ai8BACABcUUNACACQQRqIQIMAQsLIAIhAwsgAwtEAANAAkAgAiADRwR/IAIoAgBB/wBLDQFB3DEoAgAgAigCAEEBdGovAQAgAXFFDQEgAgUgAwsPCyACQQRqIQIMAAALAAtFAANAIAEgAkcEQCADIAEoAgBB/wBNBH9B3DEoAgAgASgCAEEBdGovAQAFQQALOwEAIANBAmohAyABQQRqIQEMAQsLIAILIwAgAkH/AE0Ef0HcMSgCACACQQF0ai8BACABcUEARwVBAAsLDQAgACgCACgCABDYDwuqAQEEfyAAQQNqIQMgAC0AAyICQQBHIQQCQCACRSAALQABQRB0IAAtAABBGHRyIAAtAAJBCHRyIAJyIgIgASgAACIAQRh0IABBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiBUZyRQRAA0AgA0EBaiEAIAMtAAEiAUEARyEEIAJBCHQgAXIiAiAFRg0CIAAhAyABDQAMAgALAAsgAyEACyAAQX1qQQAgBBsLNQEBfyMAQRBrIgIkACAAKAIAQX9HBEAgAiACQQhqIAEQwwcQMxogACACENUPCyACQRBqJAALHwAgAAJ/QYDUEUGA1BEoAgBBAWoiADYCACAACzYCBAs+AAJAQfzTES0AAEEBcQ0AQfzTERCuAUUNAEH00xEQ/wkQmAZB+NMRQfTTETYCAEH80xEQrQELQfjTESgCAAuOAQECfyMAQSBrIgIkAAJAQdDgERCXASgCAEHU4BEoAgBrQQJ1IABPBEAgABCCCgwBC0HQ4BEQmgQhASACQQhqQdDgERAfIABqEN4PQdDgERAfIAEQ3Q8iASAAENwPIAEQ2w8gASABKAIEENkPIAEoAgAEQCABKAIQIAEoAgAgARDmAxDrCQsLIAJBIGokAAsJACAAEP4JEDALlwEBBH8gAEECaiEDIAAtAAIiAkEARyEEAkAgAkUgAC0AAUEQdCAALQAAQRh0ciACQQh0ciIAIAEtAAFBEHQgAS0AAEEYdHIgAS0AAkEIdHIiBUZyRQRAA0AgA0EBaiEBIAMtAAEiAkEARyEEIAAgAnJBCHQiACAFRg0CIAEhAyACDQAMAgALAAsgAyEBCyABQX5qQQAgBBsLTAEBf0HQ4BEQHyIBIABJBEAgACABaxDAEA8LIAEgAEsEQEHQ4BEoAgAgAEECdGohAEHQ4BEQHyEBQdDgESAAEOoJQdDgESABEIAKCwszAEGQ3hEQngFBnN4RQQA6AABBmN4RQQA2AgBBkN4RQbTSADYCAEGY3hFB3DEoAgA2AgALdwEEfyAALQABIgJBAEchAwJAIAJFDQAgAC0AAEEIdCACciICIAEtAAEgAS0AAEEIdHIiBUYNACAAQQFqIQEDQCABIgAtAAEiBEEARyEDIARFDQEgAEEBaiEBIAJBCHRBgP4DcSAEciICIAVHDQALCyAAQQAgAxsLQwEBfxDvCUEcSQRAEH0AC0HQ4BFB0OAREJoEQRwQ7gkiADYCAEHU4BEgADYCAEHQ4BEQlwEgAEHwAGo2AgBBABDtCQs5AQF/IwBBEGsiACQAQdDgEUIANwMAIABBADYCDEHg4BEgAEEMahDJA0Hg4RFBADoAACAAQRBqJAALlQgBAX9BwOAREJ4BQcDgEUGg0gA2AgAQxxAQxhBBHBCCCkHw4RFBldIAEGgaQdDgERAfIQBB0OAREIEKQdDgESAAEIAKQYDeERCeAUGA3hFB2N4ANgIAQYDeEUHA0hEQnQEQoAFBiN4REJ4BQYjeEUH43gA2AgBBiN4RQcjSERCdARCgARDEEEGQ3hFBjNQREJ0BEKABQaDeERCeAUGg3hFB5NYANgIAQaDeEUGE1BEQnQEQoAFBqN4REJ4BQajeEUH41wA2AgBBqN4RQZTUERCdARCgAUGw3hEQngFBsN4RQejSADYCAEG43hEQgAE2AgBBsN4RQZzUERCdARCgAUHA3hEQngFBwN4RQYzZADYCAEHA3hFBpNQREJ0BEKABQcjeERDFB0HI3hFBrNQREJ0BEKABQdDeERCeAUHY3hFBrtgAOwEAQdDeEUGY0wA2AgBB3N4REE4aQdDeEUG01BEQnQEQoAFB8N4REJ4BQfjeEUKugICAwAU3AgBB8N4RQcDTADYCAEGA3xEQThpB8N4RQbzUERCdARCgAUGQ3xEQngFBkN8RQZjfADYCAEGQ3xFB0NIREJ0BEKABQZjfERCeAUGY3xFBjOEANgIAQZjfEUHY0hEQnQEQoAFBoN8REJ4BQaDfEUHg4gA2AgBBoN8RQeDSERCdARCgAUGo3xEQngFBqN8RQcjkADYCAEGo3xFB6NIREJ0BEKABQbDfERCeAUGw3xFBoOwANgIAQbDfEUGQ0xEQnQEQoAFBuN8REJ4BQbjfEUG07QA2AgBBuN8RQZjTERCdARCgAUHA3xEQngFBwN8RQajuADYCAEHA3xFBoNMREJ0BEKABQcjfERCeAUHI3xFBnO8ANgIAQcjfEUGo0xEQnQEQoAFB0N8REJ4BQdDfEUGQ8AA2AgBB0N8RQbDTERCdARCgAUHY3xEQngFB2N8RQbTxADYCAEHY3xFBuNMREJ0BEKABQeDfERCeAUHg3xFB2PIANgIAQeDfEUHA0xEQnQEQoAFB6N8REJ4BQejfEUH88wA2AgBB6N8RQcjTERCdARCgAUHw3xEQngFB+N8RQYyAATYCAEHw3xFBkOYANgIAQfjfEUHA5gA2AgBB8N8RQfDSERCdARCgAUGA4BEQngFBiOARQbCAATYCAEGA4BFBmOgANgIAQYjgEUHI6AA2AgBBgOARQfjSERCdARCgAUGQ4BEQngFBmOAREOkJQZDgEUGE6gA2AgBBkOARQYDTERCdARCgAUGg4BEQngFBqOAREOkJQaDgEUGg6wA2AgBBoOARQYjTERCdARCgAUGw4BEQngFBsOARQaD1ADYCAEGw4BFB0NMREJ0BEKABQbjgERCeAUG44BFBmPYANgIAQbjgEUHY0xEQnQEQoAELhQEBAX8CQCABLAAAIgJFDQAgACACEIcKIQJBACEAIAJFDQAgAS0AAUUEQCACDwsgAi0AAUUNACABLQACRQRAIAIgARDFEA8LIAItAAJFDQAgAS0AA0UEQCACIAEQwhAPCyACLQADRQ0AIAEtAARFBEAgAiABELwQDwsgAiABELIQIQALIAAL2wEBA38jAEGgAWsiBCQAIAQgATYCmAEgBEGQAWohBQJAA0AgBkECRiACIANPckUEQCAEIAI2AgggACAEQZABaiACIAJBIGogAyADIAJrQSBKGyAEQQhqIARBEGogBSAEQQxqIAAoAgAoAhARCgAiBkECRg0CIARBEGohASAEKAIIIAJGDQIDQCABIAQoAgxPBEAgBCgCCCECDAMFIAQgASgCADYCBCAEKAKYASAEQQRqKAIAEJMGIAFBBGohAQwBCwAACwALCyAEKAKYARogBEGgAWokAA8LEKgCAAu2AQEDfyMAQUBqIgQkACAEIAE2AjggBEEwaiEFAkADQCAGQQJGIAIgA09yRQRAIAQgAjYCCCAAIARBMGogAiADIARBCGogBEEQaiAFIARBDGogACgCACgCDBEKACIGQQJGDQIgBEEQaiEBIAQoAgggAkYNAgNAIAEgBCgCDE8EQCAEKAIIIQIMAwUgBEE4aiABEIQKIAFBAWohAQwBCwAACwALCyAEKAI4GiAEQUBrJAAPCxCoAgALhQEAIwBBIGsiASQAIAFBEGoQTiEEAn8gAUEIaiICEMUHIAJB9NoANgIAIAILIAQQJCAFEBsgBRAbIAUQJkECdGoQyxAgBBAbIQIgABDTAiEDAn8gAUEIaiIAEMUHIABB1NsANgIAIAALIAMQJCACIAIQnAEgAmoQyhAgBBAoGiABQSBqJAALSwAjAEEgayIBJAAgAUEQahBOIgMQJCAFEBsgBRAbIAUQJmoQhQogAxAbIQIgABBOECQgAiACEJwBIAJqEIUKIAMQKBogAUEgaiQAC1IBAX8jAEEQayIDJAAgAyABNgIAIAMgADYCCANAIANBCGogAxC8AgRAIAIgAygCCCgCADYCACACQQRqIQIgA0EIahBiGgwBCwsgA0EQaiQAIAILUgEBfyMAQRBrIgMkACADIAE2AgAgAyAANgIIA0AgA0EIaiADELwCBEAgAiADKAIILQAAOgAAIAJBAWohAiADQQhqEOoDDAELCyADQRBqJAAgAguSAwEHfyMAQfADayIAJAAgAEHoA2ogAxBhIABB6ANqEJ0CIQogAgJ/IAUQJgRAIAVBABDCBigCACAKQS0QsgJGIQsLIAsLIABB6ANqIABB4ANqIABB3ANqIABB2ANqIABByANqEE4iDCAAQbgDahDTAiIIIABBqANqENMCIgcgAEGkA2oQigogAEEkNgIQIABBCGpBACAAQRBqEKMBIQkCfyAFECYgACgCpANKBEAgBRAmIQIgACgCpAMhBiAHECYgAiAGa0EBdGpBAWoMAQsgBxAmQQJqCyEGIABBEGohAgJAIAgQJiAGaiAAKAKkA2oiBkHlAEkNACAJIAZBAnQQmwEQzgEgCSgCACICDQAQ5gEACyACIABBBGogACADKAIEIAUQGyAFEBsgBRAmQQJ0aiAKIAsgAEHgA2ogACgC3AMgACgC2AMgDCAIIAcgACgCpAMQiQogASACIAAoAgQgACgCACADIAQQzAMhASAJEKIBIAcQKBogCBAoGiAMECgaIABB6ANqEFsgAEHwA2okACABC+IEAQt/IwBBsAhrIgAkACAAIAU3AxAgACAGNwMYIAAgAEHAB2o2ArwHIABBwAdqQeQAQY/SACAAQRBqEC8hByAAQSQ2AqAEIABBmARqQQAgAEGgBGoQowEhDiAAQSQ2AqAEIABBkARqQQAgAEGgBGoQowEhCiAAQaAEaiEIAkAgB0HkAE8EQBCAASEHIAAgBTcDACAAIAY3AwggAEG8B2ogB0GP0gAgABCfAyEHIAAoArwHIghFDQEgDiAIEM4BIAogB0ECdBCbARDOASAKEJAKDQEgCigCACEICyAAQYgEaiADEGEgAEGIBGoQnQIiESAAKAK8ByIJIAcgCWogCBDUAyACAn8gBwRAIAAoArwHLQAAQS1GIQ8LIA8LIABBiARqIABBgARqIABB/ANqIABB+ANqIABB6ANqEE4iECAAQdgDahDTAiILIABByANqENMCIgkgAEHEA2oQigogAEEkNgIwIABBKGpBACAAQTBqEKMBIQwCfyAHIAAoAsQDIgJKBEAgCRAmIAcgAmtBAXRBAXJqDAELIAkQJkECagshDSAAQTBqIQIgCxAmIA1qIAAoAsQDaiINQeUATwRAIAwgDUECdBCbARDOASAMKAIAIgJFDQELIAIgAEEkaiAAQSBqIAMoAgQgCCAIIAdBAnRqIBEgDyAAQYAEaiAAKAL8AyAAKAL4AyAQIAsgCSAAKALEAxCJCiABIAIgACgCJCAAKAIgIAMgBBDMAyEBIAwQogEgCRAoGiALECgaIBAQKBogAEGIBGoQWyAKEKIBIA4QogEgAEGwCGokACABDwsQ5gEAC4kDAQd/IwBBwAFrIgAkACAAQbgBaiADEGEgAEG4AWoQhQIhCiACAn8gBRAmBEAgBUEAEFItAAAgCkEtEOEBQf8BcUYhCwsgCwsgAEG4AWogAEGwAWogAEGvAWogAEGuAWogAEGgAWoQTiIMIABBkAFqEE4iCCAAQYABahBOIgcgAEH8AGoQjwogAEEkNgIQIABBCGpBACAAQRBqEKMBIQkCfyAFECYgACgCfEoEQCAFECYhAiAAKAJ8IQYgBxAmIAIgBmtBAXRqQQFqDAELIAcQJkECagshBiAAQRBqIQICQCAIECYgBmogACgCfGoiBkHlAEkNACAJIAYQmwEQzgEgCSgCACICDQAQ5gEACyACIABBBGogACADKAIEIAUQGyAFEBsgBRAmaiAKIAsgAEGwAWogACwArwEgACwArgEgDCAIIAcgACgCfBCOCiABIAIgACgCBCAAKAIAIAMgBBCpAyEBIAkQogEgBxAoGiAIECgaIAwQKBogAEG4AWoQWyAAQcABaiQAIAEL1wQBC38jAEHQA2siACQAIAAgBTcDECAAIAY3AxggACAAQeACajYC3AIgAEHgAmpB5ABBj9IAIABBEGoQLyEHIABBJDYC8AEgAEHoAWpBACAAQfABahCjASEOIABBJDYC8AEgAEHgAWpBACAAQfABahCjASEKIABB8AFqIQgCQCAHQeQATwRAEIABIQcgACAFNwMAIAAgBjcDCCAAQdwCaiAHQY/SACAAEJ8DIQcgACgC3AIiCEUNASAOIAgQzgEgCiAHEJsBEM4BIAoQkAoNASAKKAIAIQgLIABB2AFqIAMQYSAAQdgBahCFAiIRIAAoAtwCIgkgByAJaiAIEP8DIAICfyAHBEAgACgC3AItAABBLUYhDwsgDwsgAEHYAWogAEHQAWogAEHPAWogAEHOAWogAEHAAWoQTiIQIABBsAFqEE4iCyAAQaABahBOIgkgAEGcAWoQjwogAEEkNgIwIABBKGpBACAAQTBqEKMBIQwCfyAHIAAoApwBIgJKBEAgCRAmIAcgAmtBAXRBAXJqDAELIAkQJkECagshDSAAQTBqIQIgCxAmIA1qIAAoApwBaiINQeUATwRAIAwgDRCbARDOASAMKAIAIgJFDQELIAIgAEEkaiAAQSBqIAMoAgQgCCAHIAhqIBEgDyAAQdABaiAALADPASAALADOASAQIAsgCSAAKAKcARCOCiABIAIgACgCJCAAKAIgIAMgBBCpAyEBIAwQogEgCRAoGiALECgaIBAQKBogAEHYAWoQWyAKEKIBIA4QogEgAEHQA2okACABDwsQ5gEAC3MBAX8jAEEgayIDJAAgAyABNgIQIAMgADYCGCADIAI2AggDQAJAAn9BASADQRhqIANBEGoQvAJFDQAaIAMoAhgoAgAgAygCCCgCAEYNAUEACyEAIANBIGokACAADwsgA0EYahBiGiADQQhqEGIaDAAACwAL1AEBBH8jAEEQ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IAEQpwogBigCCCEAIAZBEGokACAACzEAIAAgASACIAMgBCAFIABBCGogACgCCCgCFBEEACIAEBsgABAbIAAQJkECdGoQygMLXgEBfyMAQSBrIgYkACAGQfjRACkDADcDGCAGQfDRACkDADcDECAGQejRACkDADcDCCAGQeDRACkDADcDACAAIAEgAiADIAQgBSAGIAZBIGoQygMhACAGQSBqJAAgAAsoACABIAIgAyAEQQQQnAMhASADLQAAQQRxRQRAIAAgAUGUcWo2AgALCzcAIAEgAiADIARBARCcAyEBIAMoAgAiAkEEcSABQQZKckUEQCAAIAE2AgAPCyADIAJBBHI2AgALNwAgASACIAMgBEECEJwDIQEgAygCACICQQRxIAFBPEpyRQRAIAAgATYCAA8LIAMgAkEEcjYCAAt7ACAAQQhqIAAoAggoAggRBAAiABAmQQAgAEEMahAma0YEQCAEIAQoAgBBBHI2AgAPCyACIAMgACAAQRhqIAUgBEEAENcGIABrIgIgASgCACIAQQxHckUEQCABQQA2AgAPCyACQQxHIABBC0pyRQRAIAEgAEEMajYCAAsLYQEBfyMAQRBrIgQkACAEIAE2AggDQAJAIAAgBEEIahD9AUUNACADQYDAACAAEKUBEN8CRQ0AIAAQvgEaDAELCyAAIARBCGoQxwEEQCACIAIoAgBBAnI2AgALIARBEGokAAs3ACABIAIgAyAEQQIQnAMhASADKAIAIgJBBHEgAUE7SnJFBEAgACABNgIADwsgAyACQQRyNgIACzoAIAEgAiADIARBAhCcAyEBIAMoAgAiAkEEcSABQQxKckUEQCAAIAFBf2o2AgAPCyADIAJBBHI2AgALOAAgASACIAMgBEEDEJwDIQEgAygCACICQQRxIAFB7QJKckUEQCAAIAE2AgAPCyADIAJBBHI2AgALOgAgASACIAMgBEECEJwDIQEgAygCACICQQRxIAFBf2pBC0tyRQRAIAAgATYCAA8LIAMgAkEEcjYCAAs3ACABIAIgAyAEQQIQnAMhASADKAIAIgJBBHEgAUEXSnJFBEAgACABNgIADwsgAyACQQRyNgIACzoAIAEgAiADIARBAhCcAyEBIAMoAgAiAkEEcSABQX9qQR5LckUEQCAAIAE2AgAPCyADIAJBBHI2AgALZQEBfyMAQRBrIgQk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IABBf2oiAEEzTQRAQoGAgICA4O8HIACtiKdBAXEPC0EAC0IBAn8gAEHoAGohAgN/IAIgARA8KAIMIgNBHEcEfyADQSBGBH8gACABEPYKQeUpRgVBAAsFIAAgARCxASEBDAELCwv8AgEHfyMAQRBrIgMkACADQSE2AggCQCAAQdwCaiIGIANBCGoQQxAfQQFOBEADQCADQSE2AgggAyAGIANBCGoQQygCACAHEBooAgAiBTYCDAJAIAVBABA8IAFHDQAgAhAfIgggBRC7AkF/akcNACACKAIAIQlBACEEA0AgBCAITg0EIAkgBBAaKAIAIAUgBEEBaiIEEDxGDQALCyADQSE2AgggB0EBaiIHIAYgA0EIahBDEB9IDQALC0EsECsiBSAAEFdBAEEhEFEhBCADIAU2AgwgBCABED8CQCACEB9BAUgNACAEIAIoAgBBABAaKAIAED9BASEEIAIQH0EBTA0AA0AgAygCDCACKAIAIAQQGigCABA/IARBAWoiBCACEB9IDQALCyADQSE2AgggBiADQQhqEEMgA0EMahCLASAAQZACaiADQQhqIAMoAgwQQSIBEH8gARBHIABB6ABqIAMoAgwQkQEgAygCDCEFCyAFKAIEIQAgA0EQaiQAIAALMwEBfyAAKAIUIgMgASACIAAoAhAgA2siASABIAJLGyIBEEAaIAAgACgCFCABajYCFCACCy8AAkAgAUUNACAAKAIgIAFGDQAgACABNgIgIAAtAChFDQAgACAAKAIQIAEQwgoLC2kBAn8jAEEgayIDJAACQCAAECcoAgAgACgCBGtBAnUgAU8EQCAAIAEQtwYMAQsgABAnIQIgA0EIaiAAIAAQHyABahDyASAAEB8gAhCNAiICIAEQ3AogACACEOMGIAIQjAILIANBIGokAAszAQF/IAAQHyICIAFJBEAgACABIAJrEOARDwsgAiABSwRAIAAgACgCACABQQJ0ahCjAgsLOwEBfyAAIAAoAgRBEGoiATYCBCABIAAoAgAiASgCAGtBgCBGBEAgACABQQRqNgIAIAAgASgCBDYCBAsLQgEDfyAAIAEoAgQiACABKAIQIgNBBnZB/P//H3FqIgQgACABKAIIEFgEfyACBSAEKAIAIANB/wFxQQR0agsQygEaC58BAQJ/IwBBEGsiASQAIAFBCGogABDjESABIAAQwwogASgCDCABKAIEECUEQANAIAFBCGoQ4hEgASgCDCABKAIEECUNAAsLIAAQjQFBADYCACAAEOIBQQNPBEADQCAAKAIEKAIAEDAgABCJAyAAEOIBQQJLDQALCyAAEOIBQX9qIgJBAU0EQCAAQYABQYACIAJBAWsbNgIQCyABQRBqJAALLAEBfyABIAAoAgQiAkcEQANAIAJBfGoiAhC4DCABIAJHDQALCyAAIAE2AgQLJwEBfyAAKAIABEAgACAAKAIAEOURIAAoAgAhASAAENACGiABEDALCzYBAn8gABDkESAAKAIEIgEgACgCCCICRwRAA0AgASgCABAwIAFBBGoiASACRw0ACwsgABCMAgsJACAAEPsHEDALCQAgABDRBxAwCxsAIABBBGoQNxogAEEUahA3GiAAQTBqEO8EGgujAQEFfyMAQRBrIgIkACABKAIAENYDIQMCQAJAIAAQRiIERQ0AIAAgAyAEEDkiBRAtKAIAIgBFDQAgACgCACIARQ0AIAEoAgAhAQNAAkAgACgCBCIGIANHBEAgBiAEEDkgBUcNAwwBCyAAKAIIIAEQWEUNACACQQhqIAAQMygCACEADAMLIAAoAgAiAA0ACwsgAhDFASIANgIICyACQRBqJAAgAAs5AQF/IwBBEGsiASQAIAEgACgCADYCCCABQQhqIgAgACgCAEF4ajYCACAAKAIAIQAgAUEQaiQAIAALTQECfyMAQRBrIgEkACAAQQRqEB9BAk8EQCABIAAoAggQJDYCCCABQQhqEOwRKAIAIgBBACAAKAIMQX5xQfYBRhshAgsgAUEQaiQAIAILSwEBfyMAQRBrIgQkACAEIAI2AgggBCABNgIMIAQgAzYCBCAAIARBDGooAgAgBEEIaigCACAEQQRqKAIAIAAoAggRDAAgBEEQaiQACycAIAAgARDzCBogAEEQahCkARogAEEkahCkARogAEE4ahCkARogAAtUAQF/IwBBEGsiAyQAIAMgADYCCAJAIAAgARAlRQ0AA0AgACACEIsCBEAgAygCCCEADAILIANBCGoQgAUgAygCCCIAIAEQJQ0ACwsgA0EQaiQAIAALCQAgABCCAxAwCzABAX8gASAAKAIIIgJHBEADQCAAIAJBfGoiAjYCCCACEEcgACgCCCICIAFHDQALCws7AQF/IAAgAUcEQCACKAIAIQMDQCAD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BSAFQRhqEPADNgIIIAVBEGogBUEIahC8AgRAIAVBKGogBSgCECgCABDODSAFQRBqEGIaDAEFIAUoAighAiAFQRhqECgaCwsLIAVBMGokACACCzEBAX8gASAAKAIIIgJHBEADQCAAIAJBdGoiAjYCCCACENUBIAAoAggiAiABRw0ACwsLOwEBfyAAIAFHBEAgAigCACEDA0AgA0F0aiABQXRqIgEQogwgAiACKAIAQXRqIgM2AgAgACABRw0ACwsLQAECfyAAKAIAIABBBGoiAigCACABQQRqIgMQkRIgACADEDsgAiABQQhqEDsgABAnIAEQOhA7IAEgASgCBDYCAAsrAQF/IAAoAgghAgNAIAIQ1AogACAAKAIIQQxqIgI2AgggAUF/aiIBDQALCysBAX8gACgCBCECA0AgAhDUCiAAIAAoAgRBDGoiAjYCBCABQX9qIgENAAsLvgEBA38jAEHgAGsiACQAIABBttAALwAAOwFcIABBstAAKAAANgJYEIABIQUgACAENgIAIABBQGsgAEFAa0EUIAUgAEHYAGogABD2ASIGIABBQGtqIgQgAhC9AiEFIABBEGogAhBhIABBEGoQhQIhByAAQRBqEFsgByAAQUBrIAQgAEEQahD/AyABIABBEGogBiAAQRBqaiIBIAUgAGsgAGpBUGogBCAFRhsgASACIAMQqQMhASAAQeAAaiQAIAEL1QMCBX8BfSMAQSBrIgQkACACIQUgARBGIQYgBEEAOgAfAkACQCAGRQ0AIAEgBSAGEDkiBxAtKAIAIgJFDQADQCACKAIAIgJFDQEgBSACKAIEIghHBEAgCCAGEDkgB0cNAgsgAigCCCAFEFhFDQALDAELIARBEGogASAFIAMQ7gsgARA6IgMoAgAhAgJAIAECfyAGQQAgARCXASoCACIJIAazlCACQQFqs11BAXMbRQRAIAQgBhDEAUEBcyAGQQF0cjYCDCAEAn8gAygCAEEBarMgCZWNIglDAACAT10gCUMAAAAAYHEEQCAJqQwBC0EACzYCCCABIARBDGogBEEIahBfKAIAENwFIAUgARBGIgYQOSEHCyAHCxAtKAIAIgJFBEAgBCgCECABQQhqIgIoAgA2AgAgAiAEKAIQNgIAIAEgBxAtIAI2AgAgBEEQaiEFIAQoAhAoAgBFDQEgBCgCECECIAEgBCgCECgC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IAAgBDkDECAAQZwBaiAFIABByAFqIABBEGoQnwMLIQUgACgCnAEiBkUNASAHIAYQzgELIAAoApwBIgYgBSAGaiIIIAIQvQIhCSAAQSQ2AlAgAEHIAGpBACAAQdAAahCjASEGAn8gACgCnAEgAEGgAWpGBEAgAEHQAGohBSAAQaABagwBCyAFQQF0EJsBIgVFDQEgBiAFEM4BIAAoApwBCyEKIABBOGogAhBhIAogCSAIIAUgAEHEAGogAEFAayAAQThqEN8KIABBOGoQWyABIAUgACgCRCAAKAJAIAIgAxCpAyEBIAYQogEgBxCiASAAQdABaiQAIAEPCxDmAQALMgEBfyAAKAIABEAgABDoBCAAKAIAIQEgABDQAhogARAwIAAQJ0EANgIAIABCADcCAAsLlwEBAn8jAEEQayIDJAACQCABIAIQ2wQiBCAAENACTQRAIAMgAjYCDCAEIAAQHyIESwRAIAMgATYCDCADQQxqIAQQkAYgASADKAIMIgEgACgCABDbAxogACABIAIQ6wcMAgsgACABIAIgACgCABDbAxDgBwwBCyAAEMUSIAAgACAEEPIBEMcFIAAgASACEOsHCyADQRBqJAALWQECfyMAQRBrIgMkACADIAA2AgggACABECUEQCACKAIAIQQDQCAEIAAQigUgA0EIahCQBCACIAIoAgBBCGoiBDYCACADKAIIIgAgARAlDQALCyADQRBqJAALxQEBBH8jAEEgayIAJAAgAEIlNwMYIABBGGpBAXJBptAAQQAgAigCBBDzAyACKAIEIQcgAEFgaiIFIgYkABCAASEIIAAgBDcDACAFIAUgB0EJdkEBcUEWckEBaiAIIABBGGogABD2ASAFaiIHIAIQvQIhCCAGQVBqIgYkACAAQQhqIAIQYSAFIAggByAGIABBFGogAEEQaiAAQQhqELAGIABBCGoQWyABIAYgACgCFCAAKAIQIAIgAxCpAyEBIABBIGokACABCzABAX8jAEEQayICJAAgAiABNgIIIAAgAigCCCgCADYCACAAQQRqEDcaIAJBEGokAAvbAwIGfwF9IwBBIGsiBCQAIAIoAgAQ1gMhByABEEYhBSAEQQA6AB8CQAJAIAVFDQAgASAHIAUQOSIIEC0oAgAiBkUNACACKAIAIQIDQCAGKAIAIgZFDQEgByAGKAIEIglHBEAgCSAF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EIMCBSADCyAEKAIAQQEQGigCAEEAQf////8HQQAQ1QIgASAFIApBABCvASEFDAELAkACQCADQQJrDgIBAQALIABBOGoiASABIAUgCkEBEK8BIAQoAgBBAhAaKAIAQQBB/////wdBABDVAiABIAUgCkEAEK8BIQUMAQsgAEE4aiIBIAEgBSAKQQAQrwEgBCgCAEEDEBooAgBBAEH/////B0EAENUCIAEgASAFIApBARCvASAEKAIAQQIQGigCAEEAQf////8HQQAQ1QILIABBOGogBSACEIYBIQkLIA1BIGokACAJC7oIAQR/IwBBIGsiBCQAIAAoAowEIgYtAPwDEDYhBQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCABQaUFTARAIAFB1X1qIgdBF00NBiABQcF8aiIFQQJLBEAgAUGjA0cNCiAEQRBqEDchBSAAQThqIgEgASADIABBnbQREIMDQQMgBRDkByACEIYBIQEgBRBFDCILIAVBAWsOAgIDAQsgAUHFemoiAkEETQ0GIAFB2npqIgJBAU0NByABQZN6aiIBQQFLDQggAUEBaw0DDAQLIABBOGpB9CkQpQQMHgsgAEE4akH1KRClBAwdCyAEQRBqEDchAiAAQThqIgBBjLEREEkgAEGDKhApIABBhSogAyACEPYDIQEgAhBFDB0LIARBEGoQNyECIAQgAEE4aiIAQQNBABBvNgIMIAIgBEEMahBMIABBsLQREEkgAEG/JxApIABBwCcgAyACEPYDIQEgAhBFDBwLIARBEGoQNyECIAQgAEE4aiIAQQFBABBvNgIMIAIgBEEMahBMIABBsLQREEkgAEG/JxApIABBwCcgAyACEPYDIQEgAhBFDBsLQQVBASAFGyEBIAdBAWsOFwYCAhgXExYSFRQCAgICAgICDAsKCQgFBwsgAkEBaw4EDw4NDBALIAJBAWsNAgwBCyAAKAI0IARBEGpBxbQREGgiABCoAyAAECgaDBYLIABBOGpB2CkQpQQMFQsgAEE4akHXKRClBAwUCyAAQcICIAMgBEEQahA3IgBBABDjByEBIAAQRQwUCyAAQThqQdsBEKUEDBILIABBOGpB2gEQpQQMEQsgAEE4akEDQYACQQgQShDUAgwQCyAA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IAcL3wMBBX8jAEEgayIEJAAgACgCCCECIAAoAgAoAgAiAyADKAIAKAKAAREEAARAIAJBOGpBByACIAAoAgAoAgAiAyADKAIAKAJ4EQQAEMMBQQBBABD1AyEDIAAoAgQgAzYCAAsgBCAAKAIMKAIAIAAoAgAoAgAQ0AogAkE4aiIDENgHIQUCQCAAKAIAKAIAIgEgASgCACgCvAERBABFDQAgACgCACgCACIBIAEoAgAoArwBEQQAIgEgAiABKAIAKAIIEQIAIAAoAgQoAgBFDQAgAyACIAAoAgAoAgAiASABKAIAKAK8AREEACIBIAEoAgAoAgwRBAAiASABKAIAKAJ4EQQAEKEBIAAoAgQoAgBBAEH/////B0EAENUCCwJAIAAoAgAoAgAiASABKAIAKALAAREEAEUNACAFEM8KIAAoAgAoAgAiASABKAIAKALAAREEACIBIAIgASgCACgCCBECACAAKAIEKAIARQ0AIAMgAiAAKAIAKAIAIgIgAigCACgCwAERBAAiAiACKAIAKAIMEQQAIgIgAigCACgCeBEEABChASAAKAIEKAIAQQBB/////wdBABDVAgsgBRDXByAAKAIEKAIABEAgAxBxIAMgACgCBCgCABCHAwsgBEEgaiQAC+sEAQZ/IwBBIGsiBSQAIAAoAgQhAiAAKAIAKAIAIgEgASgCACgCvAERBAAiASACIAEoAgAoAggRAgAgAiAAKAIAKAIAIgEgASgCACgCvAERBAAiASABKAIAKAIMEQQAIgEgASgCACgCeBEEABChASEEIAAoAgAoAgAiASABKAIAKALAAREEACIBIAIgASgCACgCCBECACACIAAoAgAoAgAiASABKAIAKAK8AREEACIBIAEoAgAoAgwRBAAiASABKAIAKAJ4EQQAEKEBIQYgAkE4aiIBIAAoAgAoAgAiAyADKAIAKAIAEQQAKAIIIAAoAgAoAgAiAyADKAIAKAIAEQQAKAIAEOkCEOgCAkAgACgCACgCACIDIAMoAgAoAoABEQQARQ0AIAAoAggQ0goEQAJAIAIoAowEENkDKAIAQf+HBEsNACABIAQQowRFDQAgAUH/////ByAAKAIMKAIAIAEgARCFAyABIAQQzAEQsAEQ5gQhAyAAKAIMIAM2AgALIAEgAiAAKAIAKAIAIgIgAigCACgCeBEEABDDASAAKAIMKAIAIAQgBhC0BiECIAAoAhAgAjYCACABEHEgASAAKAIQKAIAEJMCDAELIAFBByACIAAoAgAoAgAiAiACKAIAKAJ4EQQAEMMBQQBBABD1AyECIAAoAhAgAjYCACAFIAAoAgwoAgAgACgCACgCABDQCiABENgHIQIgASAEIAAoAhAoAgBBAEH/////B0EAENUCIAIQzwogASAGIAAoAhAoAgBBAEH/////B0EAENUCIAIQ1wcgARBxIAEgACgCECgCABCHAwsgBUEgaiQAC68BAQF/AkAgACgCACgCACIBIAEoAgAoArwBEQQARQ0AIAAoAgAoAgAiASABKAIAKALAAREEAEUNAAJ/QQEgACgCACgCAC0AdBA2RQ0AGiAAKAIEENIKRQ0BQQAgACgCACgCACIBIAEoAgAoArwBEQQAIgEgASgCACgCDBEEABDRCkUNABogACgCACgCACIAIAAoAgAoAsABEQQAIgAgACgCACgCDBEEABDRCgsPC0EAC8kCACMAQdAAayIBJAAgASACNgJMIAEgADYCRCABIAFBzABqNgJAIAEgAUFAazYCPCABIAFBzABqNgI4IAFBADYCNCACIAIoAgAoArgBEQQAIgIgACACKAIAKAIIEQIAIAEgACABKAJMIgIgAigCACgCuAERBAAiAiACKAIAKAJ4EQQAEKEBNgIwIAEgADYCHCABIAFBNGo2AiggASABQTBqNgIkIAEgAUFAazYCICABIAFBzABqNgIYIAEgADYCECABIAFBMGo2AhQgASABQTRqNgIMIAEgAUHMAGo2AggCQCABQThqEIATBEAgASAAQThqENAFIQAgASgCTCICIAIoAgAoAngRBAAiAiACKAIAKAIsEQQAKQIEEO8BBEAgACgCABCCBAsgAUEYahD/EiAAEM8FDAELIAFBCGoQ/hILIAFB0ABqJABBAAuwCgEEfyAAQThqIgUgAxDSAwRAIAUgAxDRAyEHCwJ/AkACQAJAAkACQAJAAkACQAJAIAFBcWoiCEGHAU0EQEHvACEGIAUCfwJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCEECaw6GAQgIAAAJCQsBCg4PEBECAwIDDRkMExMTBRUVFQUVFRUUFBQcHBwbGxsTExMVBRUVFQUV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IAQoAgAoAngRBAAQoQEhBCABQbgBaiACELEEEPIEIAIgAigCACgCeBEEACIGIAYoAgAoAiwRBAApAgQQzgUgACACIAIoAgAoAngRBAAiBiAGKAIAKAIsEQQAKQIEEPgDEM0FIQYgACACKAJoIAYgACACIAIoAgAoAngRBAAQwwEgBCADIAIgAigCACgCeBEEACIDIAMoAgAoAhwRBABBARC5BiEDCyAFIAFBgAFqIAFBgAJqEPkDIgQQqAQgBBC3ASAAIAIgAigCACgCwAERBAAiACAAKAIAKAJ4EQQAIAMQpwQgBRBxIAUgAxCTAiABQYACahC3AQwFCyACIAIoAgAoAsABEQQAIgMgACADKAIAKAIIEQIAIAIgAigCACgCxAERBAAiAyADKAIAKAIUEQQAEFNBABAXKAIAIQQCQCACIAIoAgAoAsABEQQAIgMgAygCACgCeBEEACIDIAMoAgAoAnARBAANACACIAIoAgAoAsABEQQAIgMgAygCACgCeBEEACIDIAMoAgAoAmgRBABFDQAgAigCaEGxAUcNACABQYACahA3IQMgASAENgK4ASADIAFBuAFqEEwgACACIAIoAgAoAsABEQQAIgAgACgCACgCeBEEABDDASEAIAFB+ABqIAIgAigCACgCwAERBAAiBCAEKAIAKAJ4EQQAEOkBIAIgAigCACgCwAERBAAiAiACKAIAKAJ4EQQAIAFBuAFqELAEIQIgASABKAJ4NgIQIAUgAyAAIAFBEGogAhCTCyADEEUMBQsCQCACIAIoAgAoAsABEQQAEP4BRQ0AIAIgAigCACgCwAERBAAiAyADKAIAKAJ4EQQAIgMgAygCACgCcBEEAA0AIAIoAmhBswFHDQAgACACIAIoAgAoAsABEQQAIgMgAygCACgCeBEEABChASEDIAUQcSAFIAMQhwMLQQAhAyAFAn8gBCACIAIoAgAoAsABEQQAIgYgBigCACgCgAERBABBEEcNABogBCACKAJoQbMBRw0AGiABIAIgAigCACgCwAERBAAiBiAGKAIAKAJ4EQQAQUBrKAIANgKAAiAAQdAHaiABQYACahCOEygCACAEEBooAgALQQAQvwIhBiABQfAAaiACIAIoAgAoAsABEQQAIgcgBygCACgCeBEEABDpASACIAIoAgAoAsABEQQAIgcgBygCACgCeBEEABCABCEHIAEgASgCcDYCDCAFIAYgAUEMaiAHEPEEIAIgAigCACgCwAERBAAiBSAFKAIAKAJ4EQQAIgUgBSgCACgCiAERBABFDQUgAiACKAIAKALAAREEACIFIAUoAgAoAngRBAAiBSAFKAIAKAJwEQQADQUgACACIAIoAgAoAsABEQQAIgAgACgCACgCeBEEAEFAaygCACAEEI0TDAULIAIgAigCACgCwAERBAAiAyAAIAMoAgAoAggRAgAgAUGAAmogBRDAAiAFEHEgAiACKAIAKALEAREEACIDIAAgAygCACgCCBECACAAIAIgAigCACgCxAERBAAiAyADKAIAKAJ4EQQAEKEBIQMgACACIAIoAgAoAsABEQQAIgQgBCgCACgCeBEEACACIAIoAgAoAsQBEQQAIgQgBCgCACgCeBEEABCMEyAFIAFBOGogAUGAAmoQ+QMiBBCoBCAEELcBAkACQCACIAIoAgAoAsABEQQAIgQgBCgCACgCeBEEACIEIAQoAgAoAnARBAANACACIAIoAgAoAsABEQQAIgQgBCgCACgCeBEEACIEIAQoAgAoAmgRBABFDQAgACACIAIoAgAoAsABEQQAIgAgACgCACgCeBEEABDDASEAIAFBMGogAiACKAIAKALAAREEACIEIAQoAgAoAngRBAAQ6QEgAiACKAIAKALAAREEACICIAIoAgAoAngRBAAgAUG4AWoQsAQhAiABIAEoAjA2AhggBSADIAAgAUEYaiACEIsTDAELIAFBKGogAiACKAIAKALAAREEACIAIAAoAgAoAngRBAAQ6QEgAiACKAIAKALAAREEACIAIAAoAgAoAngRBAAQgAQhACABIAEoAig2AhQgBSADIAFBFGogABDxBAsgAUGAAmoQtwEMAwsgAiACKAIAKALAAREEACIDIAAgAygCACgCCBECACABQYACahA3IQMgAiACKAIAKALEAREEACIEIAQoAgAoAhgRBAAgAxCSCyAAIAIgAigCACgCwAERBAAiACAAKAIAKAJ4EQQAEMMBIQAgAUEgaiACIAIoAgAoAsABEQQAIgQgBCgCACgCeBEEABDpASACIAIoAgAoAsABEQQAIgIgAigCACgCeBEEACABQbgBahCwBCECIAEgASgCIDYCHCAFIAMgACABQRxqIAIQkwsgAxBFDAILIAIgAigCACgCxAERBAAiAyADKAIAKAIMEQQAEIoTDQAgACACKAJoIAIgAigCACgCwAERBAAiACAAKAIAKAIMEQQAIAIgAigCACgCxAERBAAiACAAKAIAKAIMEQQAEIkTIQAgBRBxIAUgABCTAgwBCyAFEHEgAiACKAIAKALAAREEACIDIAAgAygCACgCCBECACAAIAIgAigCACgCwAERBAAiAyADKAIAKAJ4EQQAEKEBIQQgBRBxIAIgAigCACgCxAERBAAiAyAAIAMoAgAoAggRAgAgACACIAIoAgAoAsQBEQQAIgMgAygCACgCeBEEABChASEGIAFBgAJqIAIQsQQQ8gQgAiACKAIAKAJ4EQQAIgMgAygCACgCLBEEACkCBBDOBSAAIAIgAigCACgCeBEEACIDIAMoAgAoAiwRBAApAgQQ+AMQzQUhB0EBIQMgACACKAJoIAcgACACIAIoAgAoAngRBAAQwwEgBCAGIAIgAigCACgCwAERBAAiAiACKAIAKAJ4EQQAIgIgAigCACgCHBEEAEEBELkGIQIgBRBxIAJFBEAgACgCNCABQbgBakHHvhEQaCIAEKgDIAAQKBoMAgsgBSACEJMCC0EAIQMLIAgQzwUgAUHAAmokACADCw8AIAEgAiADIAQgBRCQEwtKAQF/IwBBEGsiAiQAIAJBADYCDCAAIAEgASgCACgCeBEEACABEFMgAkEMakEAEKkEIQEgAEE4aiIAEHEgACABEJMCIAJBEGokAAvVAgEEfyMAQSBrIgMkACADIABBnAhqIAEQzAo2AhggAxCKBDYCCAJAIANBGGogA0EIahCUAw0AIANBGGoQtwMoAgQhBQJAIABBOGoiAiACIAIgARBjELEBIgQQ0gNFDQAgAiACIAQQsQEQwAVBIEcNACACIAUQwAVBwABGBEAgAhBxIAIgARCHAyACQf////8HQf////8HIARBAEH/////B0EAEIcLIQEgA0EIahA3IQAgAyACIAEgAiAEELEBQQAQrwE2AgQgACADQQRqEEwgAyACIAEgAiAEELEBQQEQrwE2AgQgACADQQRqEEwgAkH8ACAFIAIgAiACIAQQsQFBAhCwASAAEKEDEIMCIQEgABBFDAILIAAoAjQgA0EIakHovhEQaCIAEKgDIAAQKBoMAQsgACgCNCADQQhqQZi/ERBoIgAQqAMgABAoGgsgA0EgaiQAIAELLwEBfyMAQRBrIgMkACADQQhqIAEgAigCACACEIMSIAAgA0EIahCVBSADQRBqJAALtA4BBX8jAEEwayICJAAgAiAAQawEaiIDIAEgASgCACgCuAERBAAQzAo2AiggAhCKBDYCCAJAIAJBCGogAkEoahCMAQRAIAIgAkEoahC3AygCBCIBNgIkDAELIAJBGGogACAAIAEgASgCACgCiAERBAAoAgRBBnZB/wNxQQAQ2wciBiABIAEoAgAoAngRBAAQhxIgAiAAIAEgAigCGBCGEiIENgIkIAIgASABKAIAKAK4AREEADYCCCADIAJBCGoQ+gogBDYCACACKAIcIgMEQCAAQZwIaiACQSRqEIUSIAM2AgALAkAgASABKAIAKAKAAREEAEEQRg0AIABBOGoiAyACKAIkIAEgASgCACgCeBEEABDrBEF/EHcgAyACKAIkIAAgASABKAIAKAJ4EQQAIgQgBCgCACgCLBEEACkCBBDjCkF/EHcgAyACKAIkIAAgASABKAIAKAJ4EQQAIgQgBCgCACgCLBEEACkCBBDiCkF/EHcgACACKAIkQX8gASABKAIAKAJ4EQQAIgQgBCgCACgCLBEEABDhCiABIAEoAgAoAogBEQQAEK4DBEAgAyACKAIkQR8gASABKAIAKAKIAREEACgCFEEMdkEHcRB3CyABIAEoAgAoAogBEQQAKQIYEL4EBEAgAyACKAIkQSAgASABKAIAKAKIAREEAC0AGhB3CyABIAEoAgAoAngRBAAiBCAEKAIAKAIsEQQAKAIgEJAFBEAgAyACKAIkQQEgASABKAIAKAJ4EQQAIgQgBCgCACgCLBEEACgCIEEIdkH/D3EQdwsgASABKAIAKAKIAREEACgCDBC0AUUNACADIAIoAiRBIyABIAEoAgAoAogBEQQAKAIMEHcLIAEgASgCACgCiAERBAAQhgIEQCAAQThqIAIoAiRBHiABIAEoAgAoAogBEQQAKAIUQf8fcRB3CyAAQThqIgMgAigCJCABIAEoAgAoAngRBAAiBCAEKAIAKAIsEQQAKQIEEOAKQX8QdwJAIAEgASgCACgCiAERBAApAhgQrwNFDQAgACgCjAQtAMAEEDZFDQAgA0E2ECkgAyACKAIkQR0gASABKAIAKAKIAREEAC0AGxB3CwJAIAEgASgCACgCiAERBAAQkQUEQCADIAIoAiRBIiABIAEoAgAoAogBEQQAKAIUQQ92Qf8AcRB3DAELIAEgASgCACgCeBEEABDLCkUNACADIAIoAiRBIkEAEHcLAkAgASABKAIAKAKIAREEACkCGBDwAgRAIAMgAigCJEEhIAEgASgCACgCiAERBAAvARgQdwwBCyABIAEoAgAoAngRBAAQywpFDQAgAyACKAIkQSFBABB3CyABIAEoAgAoAogBEQQAKAIgEL0EBEAgAyACKAIkQSsgASABKAIAKAKIAREEAC0AIBB3CwJAIAAoAowELQCwBBA2RQ0AIANBNRApAkAgASABKAIAKAKIAREEACkCGBCYAkUNACADIAIoAiRBJCABIAEoAgAoAogBEQQAKAIcQQ9xEHcgACgCjAQhBCABIAEoAgAoAogBEQQAKAIcQQ9xIQUgBCgCtAQgBRCzASgCDCIEQf//AEYNACADIAIoAiRBJSAEEHcLIAEgASgCACgCiAERBAApAhgQjgNFDQAgAyACKAIkQSMgASABKAIAKAKIAREEACkCGEIyiKdB/z9xEHcLIAZB/////wdHBEAgAyACKAIkQQsgBhB3CyABIAEoAgAoAngRBAAiBCAEKAIAKAKcAREEAARAIAJBCGoQNyEEIAEgASgCACgCeBEEACIFIAUoAgAoAiwRBAAgBCAAKAKMBC0A/AMQNhDcByAEEB8EQEEAIQUDQCADIAIoAiQgBCgCACAFEBooAgBBfxB3IAVBAWoiBSAEEB9JDQALCyAEENUBCyADIAIoAiQgACABIAEoAgAoAngRBAAiBCAEKAIAKAIsEQQAKQIEEPgDQX8QdwJAIAZBCUcEQCAGQRRHDQEgAyACKAIkQYApQf////8HIAAoAowELQDBBBA2IgAbQX8QdyAARQ0BIANBgSkQKSADQbe/ERBJDAELIAEgASgCACgCiAERBAAtACgEQCADIAIoAiRBhClBfxB3IANBhykQKSADQYO1ERBJCyABIAEoAgAoAogBEQQAKAIsQYBwRg0AIAMgAigCJEGIKSABIAEoAgAoAogBEQQAKAIsEHcgA0GLKRApIANBmrUREEkLIAEgASgCACgCiAERBAAtACcEQCADIAIoAiRBgilBfxB3IANBgykQKSADQbe1ERBJCyABIAEoAgAoAogBEQQALQAIQRBxBEAgAyACKAIkQaUpQX8QdyAD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ahDkBA0AIAEgAhA4IgQoAgAQJDYCICAEKAIEECQhBSABKAIgIgIgBRAlRQ0AA0AgASACKAIAKAIENgIcIAFBEGogCiABQRxqELEKIAFBIGoQYhogBCgCBBAkIQUgASgCICICIAUQJQ0ACwsgAUEwahD7AiADKAIEECQhBCABKAIwIgIgBBAlDQALCyABQcgAahD7AiAHKAIEECQhAyABKAJIIgIgAxAlDQALCyABIAkQhwg2AhAQ+wUhAyABKAIQIgIgAxAlBEADQCACECcoAgAQphEgAUEQahDTBRD7BSEDIAEoAhAiAiADECUNAAsLIAEgCBClETYCECABEIoENgJIIAFBEGogAUHIAGoQjAEEQANAIAFBEGoQtwMoAgAgAUEQahC3AygCBBCkESABQRBqEK8LIQIgARCKBDYCSCACIAFByABqEIwBDQALCyABQQhqIAAoAoQCECQgACgCiAIQJCAKEKMREDMhAiABIAAoAogCECQQMyEDIABBhAJqIAIoAgAgAygCABCiESABQSA2AhAgAEHcAmoiAyABQRBqEEMQH0EBTgRAQQAhAgNAIAFBIDYCEAJAIAMgAUEQahBDKAIAIAIQGigCACIEQQAQPEHlKUcNACAAIARBARA8QRVBCBCQAgRAIABBssQRQYCKBBCyASAAQeAiECkLIAAgBEEBEDwiBEEVQRAQkAJFBEAgACAEQRZBEBCQAkUNAQsgAEHHxBFBgIYEELIBIABB0SIQKQsgAUEgNgIQIAJBAWoiAiADIAFBEGoQQxAfSA0ACwsgASAHKAIAECQ2AkggBygCBBAkIQMgASgCSCICIAMQJQRAA0AgASACKAIAELIKIgMoAgAQJDYCMCADKAIEECQhBCABKAIwIgIgBBAlBEADQCABIAIoAgAiBRA4IgQoAgAQJDYCECAEKAIEECQhBiABKAIQIgIgBhAlBEADQCAAIAIoAgAQrhEgAUEQahD7AiAEKAIEECQhBiABKAIQIgIgBhAlDQALCyABIAUQnAYiBCgCABAkNgIoIAQoAgQQJCEFIAEoAigiAiAFECUEQANAIAEgAigCACgCBCICNgIgAkAgACAAIAIQswYQ3BFFDQAgAUEAOgAcIAFBEGogACgChAIQJCAAKAKIAhAkIAFBIGogAUEcahChESABLQAcDQAgACABKAIgQewpQX8Qdwsg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IAAgAigCACgCCBECACABQRBqECgaDAELIAQQqgsEQCAEQbMBRgRAIAIgAigCACgCxAERBAAiAiACKAIAKAIUEQQAEFNBABAXKAIAIQIgA0EvENwEIAEgAhDgCSADIAEQlwQgARAoGiABKAIcIQILIAAoAjghACABIAI2AgAgACABEKELIAMQjwIMAQsgAxCDBCACIAIoAgAoAsQBEQQAIgIgACACKAIAKAIIEQIACyABQSBqJABBAAt1AQF/IwBBMGsiAiQAIAIgASABKAIAKAK4AREEABC6ByACQRBqIAJBuLAREP8HIAJBIGogAkEQaiABIAEoAgAoAsABEQQAEBsQ/wcgACACQSBqQbqwERD/ByACQSBqECgaIAJBEGoQKBogAhAoGiACQTBqJAALRgECfyMAQRBrIgIkACACIAEQwRMgAEEsaiIDIAIQ2AEgAhAoGiAAKAI4IQAgAiABNgIAIAAgAhChCyADEI8CIAJBEGokAAsIACAAEIQIGgvgAQEBfyMAQRBrIgEkACACIAIoAgAoAsABEQQAIgMgACADKAIAKAIIEQIAIAAoAiAhAyABIAI2AgwCQCADIAFBDGoQowtFDQAgAiACKAIAKALAAREEABDVBQRAIAIgAigCACgCfBEEACIAIAAoAgAoAigRBAAiACAAKQIEQoCAgIAghDcCBAwBCyAAKAIgIQMgASACNgIIIAMgAUEIahD1BCAAKAIkEIsCRQ0AIAIgAigCACgCfBEEACIAIAAoAgAoAigRBAAiACAAKQIEQoCAgIAghDcCBAsgAUEQaiQAQQALYgECfyMAQRBrIgIkACAAKAIgIQMgAiABNgIMIAMgAkEMahD1BCAAKAIkEIsCBEAgASABKAIAKAJ8EQQAIgAgACgCACgCKBEEACIAIAApAgRCgICAgCCENwIECyACQRBqJAALNAEBfyMAQSBrIgIkACACQRhqIAEQMxDTBSACQQhqIAAgARCmCyACQQhqEJwCIAJBIGokAAujAQEFfyMAQRBrIgIkACABKAIAENYDIQMCQAJAIAAQRiIERQ0AIAAgAyAEEDkiBRAtKAIAIgBFDQAgACgCACIARQ0AIAEoAgAhAQNAAkAgAyAAKAIEIgZHBEAgBiAEEDkgBUcNAwwBCyAAKAIIIAEQWEUNACACQQhqIAAQMygCACEADAMLIAAoAgAi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IAIgATYCACACQRBqIAMgAhD1BBD0ASEDAkAgAEE4aiIEEIQCBEAgASABKAIAKAJ8EQQAIgEgASgCACgCKBEEACIBIAEpAgRCgICAgCCENwIEDAELIAIgBBCsCyADIAIQlgwgAhAoGgsgAEEkaiIBIAMQqwtFBEAgAiAAKAIgIAMQ9AQgAiABIAMQ9AQLIAMQKBogAkEgaiQACwgAIAAQhQgaCyUBAX8gAARAA0AgACgCACEBIABBCGoQ3gYgABAwIAEiAA0ACwsLJQEBfyAABEADQCAAKAIAIQEgAEEIahCtCyAAEDAgASIADQALCwsPACABIAIgAyAEIAUQ1RMLJQAgASACEIMIBEAgACABEPQBGg8LIAAgASACECZBAWpBfxC9Bgs/AQF/IwBBEGsiAiQAIAIgACABEMoTIgE2AgggARDFARBYRQRAIAAgAiACQQhqEOUBKAIAEMgTCyACQRBqJAALaAECfyMAQRBrIgMkACADIAEgAhClCyIBNgIIIAMgATYCAAJAIAEQxQEQJUUNABDFASEBA0AgAxDTBSADKAIAIgQgARAlRQ0BIAQQJyACEKoDDQALCyAAIANBCGogAxCkCyADQRBqJAALPwEBfyMAQRBrIgIkACACIAAgARDHEyIBNgIIIAEQxQEQWEUEQCAAIAIgAkEIahDlASgCABDGEwsgAkEQaiQACz8AIABBABDeAiAAIAQ2AiggACADNgIkIAAgATYCICAAQYywETYCACAAQSxqEE4aIABBADYCPCAAIAI2AjggAAvaAQAgAEE4aiACEI8CAkAgASABKAIAKAIgEQQAIgIEQCACIAIoAgAoAsQBEQQAIgEgACABKAIAKAIIEQIAIAIoAmgQvAZFDQEgAiACKAIAKAJ8EQQAIgAgACgCACgCKBEEACIAIAApAgRCgICAgCCENwIEDwsgASABKAIAKAIcEQQAIgFFDQAgASABKAIAKAK8AREEACICIAAgAigCACgCCBECACABKAJoELwGRQ0AIAEgASgCACgCfBEEACIAIAAoAgAoAigRBAAiACAAKQIEQoCAgIAghDcCBAsLtgMBA38jAEEgayIEJAAgASADNgIkIARBEGoQTiEGAkACQAJAIAIgAigCACgCIBEEACIFBEAgBSAFKAIAKALAAREEACICIAEgAigCACgCCBECACAFIAUoAgAo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ARDICwsJACAAEMkLEDALLQEBfyMAQRBrIgIkACACIAE2AgggACACKAIIENoDIABBDGoQThogAkEQaiQACzIBAX8gACgCACEBIABBADYCACABBEAgABA4LQAEBEAgAUEQahDDDAsgAQRAIAEQMAsLC0YBAX8jAEEQayIDJAAgARA4IQEgAEEoECsgA0EIaiABEOQBEJABIgAoAgBBEGogAigCABCqFCAAEDhBAToABCADQRBqJAALfAECfyMAQSBrIgQkACABIARBHGogAhDmBiIFKAIAIQIgBEEAOgAbIAJFBEAgBEEIaiABIAMQrBQgASAEKAIcIAUgBCgCCBCSAyAEQQhqEHohAiAEQQE6ABsgBEEIahCrFAsgACAEQQhqIAIQMyAEQRtqEKYBIARBIGokAAsTACAAIAAoAgBBdGooAgBqEMoLCxMAIAAgACgCAEF0aigCAGoQ2AULOgEBfyMAQRBrIgIkACACIAEQswI2AgAgAkEIaiAAIAEgAhCtFCACQQhqEFohACACQRBqJAAgAEEMagt/AQN/IwBBIGsiAyQAAkAgASgCMCICQRBxBEAgASgCLCICIAEoAhgiBEkEQCABIAQ2AiwgBCECCyAAIAEoAhQgAiADQRhqEJAIGgwBCyACQQhxBEAgACABKAIIIAEoAhAgA0EQahCQCBoMAQsgACADQQhqEMILGgsgA0EgaiQACzEBAX8jAEEQayIEJAAgAEHoBmogBCABEGgiABCwFCACIAMQvQcgABAoGiAEQRBqJAAL5AEBAX8gACAFEKwEIABBgJoRNgIAIABBDGogAhD0ASEGIABBGGogBBD0ASEEIAAgAzYCJCAAQUBrQQMgAEEoaiAAQTRqQQBBAEEAQQEQ3QYhAiAAQQA2AnggAEH8AGogBSACEM0LIAAgBhAbNgIoIAAgACgCJCgCDDYCLCAAIAQQGzYCMCAAIAYQJjYCNCAAIAAoAiQoAhA2AjggACAEECY2AjwgAiABKAIIEMwLIAIgASgCBBDLCyACIAEoAgAQlghBABCVCCACIAEoAgAQlghBARCVCCACIAEoAgAQlghBAhCVCAsEAEIAC+QBAQR/QX8hAgJAIAAoAsABIAAoAsQBEFgNACABQQA6ACACQCAAKALEARCKASgCACICIAIoAgAoAgwRBAAiBEE+RwRAA0BBfyECIARBf0YN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fyMAQRBrIgMkACADIAE2AgggASACECUEQANAIAAoAgggARCCBSAAIAAoAghBDGo2AgggA0EIahCABSADKAIIIgEgAhAlDQALCyADQRBqJAALVQEDfyABIAAoAgQiBCADa0EMbUEMbGoiBSACSQRAIAQhBiAFIQMDQCAGIAMQhQUgACAAKAIEQQxqIgY2AgQgA0EMaiIDIAJJDQALCyABIAUgBBCjFQuMAQECfyMAQRBrIgIkACABIAEoAgAoAngRBAAiAyADKAIAKAIsEQQALwEEQcD/AXEEQCABIAEoAgAoArgBEQQAIQMgACgCICABIAEoAgAoAsABEQQAEPcLIAM2AgALIAIgASABKAIAKAK4AREEADYCDCAAIABBJGogAkEMahCfASgCADYCJCACQRBqJAALSQEBfyMAQRBrIgMkACAAIAEQnwUiACgCABDHCCADQQhqIAAQ5AEQkAEiACgCAEEQaiACKAIAEPsOIAAQOEEBOgAEIANBEGokAAt8AQJ/IwBBIGsiBCQAIAEgBEEcaiACEOYGIgUoAgAhAiAEQQA6ABsgAkUEQCAEQQhqIAEgAxCrFSABIAQoAhwgBSAEKAIIEMsEIARBCGoQeiECIARBAToAGyAEQQhqEMABCyAAIARBCGogAhAzIARBG2oQpgEgBEEgaiQAC1UBAX8gASABKAIAKAJ4EQQAIgIgAigCACgCLBEEAC8BBEHA/wFxRQRAIAEgASgCACgCuAERBAAhAiAAKAIgIAEgASgCACgCwAERBAAQ9wsgAjYCAAsLJQEBfyAAp0E/cUF/aiIBQQZNBEBB/QAgAUH/AHF2QQFxDwtBAAu/AQICfwF+IwBBEGsiAiQAIAEgASgCACgCeBEEACIDIAMoAgAoAiwRBAApAgQiBBCuFSEDAkACQEEAIARCwP8Bg1AgAxsNACACIAAoAiAgASABKAIAKALAAREEABD6BTYCCCACIAAoAiAQfjYCACACQQhqIAIQjAFFDQAgASACQQhqEFooAhAgASgCACgCvAERAgAMAQsgASABIAEoAgAoArgBEQQAIAAoAiRqIAEoAgAoArwBEQIACyACQRBqJAALTQEBfyMAQRBrIgMkACADIAA2AgggACABECUEQANAIAIgACgCADYCACACQQRqIQIgA0EIahBiGiADKAIIIgAgARAlDQALCyADQRBqJAALVAEDfyABKAIEIQMgACgCACACIAFBBGoiBBCxDiACIABBBGoiAigCACABQQhqIgUQvQ4gACAEEDsgAiAFEDsgABAnIAEQOhA7IAEgASgCBDYCACADC1MBAX8jAEEQayIDJAAgAyABNgIIIAEgAhAlBEADQCAAKAIIIAEQmAEgACAAKAIIQQRqNgIIIANBCGoQYhogAygCCCIBIAIQJQ0ACwsgA0EQaiQAC08BA38gASAAKAIEIgQgA2tqIgUgAkkEQCAEIQYgBSEDA0AgBiADEJgBIAAgACgCBEEEaiIGNgIEIANBBGoiAyACSQ0ACwsgASAFIAQQxAgLmAMBAn8jAEGQAmsiBSQAIAUgATYCgAIgBSAANgKIAiACEKsDIQYgBUHQAWogAiAFQf8BahDfBSAFQcABahBOIgAgABBgEE0gBSAAQQAQUiIBNgK8ASAFIAVBEGo2AgwgBUEANgIIA0ACQCAFQYgCaiAFQYACahD9AUUNACAFKAK8ASAAECYgAWpGBEAgABAmIQIgACAAECZBAXQQTSAAIAAQYBBNIAUgAiAAQQAQUiIBajYCvAELIAVBiAJqEKUBIAYgASAFQbwBaiAFQQhqIAUsAP8BIAVB0AFqIAVBEGogBUEMakGA0AAQ/gQNACAFQYgCahC+ARoMAQsLAkAgBUHQAWoQJkUNACAFKAIMIgIgBUEQamtBnwFKDQAgBSACQQRqNgIMIAIgBSgCCDYCAAsgBCABIAUoArwBIAMgBhD2CzYCACAFQdABaiAFQRBqIAUoAgwgAxD5ASAFQYgCaiAFQYACahDHAQRAIAMgAygCAEECcjYCAAsgBSgCiAIhASAAECgaIAVB0AFqECgaIAVBkAJqJAAgAQsvAQF/IwBBEGsiASQAIAEgACgCADYCCCABQQhqQX8QmgYoAgAhACABQRBqJAAgAAstAQF/IwBBEGsiASQAIAEgACgCADYCCCABQQhqEKIHKAIAIQAgAUEQaiQAIAALOgEBfyAAKAIAIgEEQCABIQADQCAAIgEoAgQiAA0ACyABDwsDQCAAELQCIQEgACgCCCEAIAENAAsgAAstAQF/IwBBEGsiASQAIAEgADYCCCABQQhqEJ4CGiABKAIIIQAgAUEQaiQAIAALYQEBfyMAQSBrIgQkACAAIAEgBEEUaiAEQRBqIAIQ+gsiAigCACIBRQRAIAQgACADELwNIAAgBCgCFCACIAQoAgAQkgMgBBB6IQEgBBCcAgsgBEEYaiABEDMaIARBIGokAAuMDgEDfyMAQSBrIgYkAAJAIAIgAigCACgCeBEEACADIAMoAgAoAngRBAAQyAFFDQACQCACIAIoAgAoAngRBAAiBSAFKAIAKAJwEQQARQ0AIAMgAygCACgCeBEEACIFIAUoAgAoAnARBABFDQAgAiACKAIAKAJ4EQQAIAMgAygCACgCeBEEABCXB0UNACACIAIoAgAoAngRBAAiBSAFKAIAKAJ4EQQADQEgAyADKAIAKAJ4EQQAIgUgBSgCACgCeBEEAA0BCyAAIAFByvEQEFlBASEECyACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQj+DUEUEQCAAIAFB3PEQEFlBASEECyACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQoCAgDiDUEUEQCAAIAFB+/EQEFlBASEECyACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQoCAgMAAg1BFBEAgACABQZzyEBBZQQEhBAsgAiACKAIAKAKIAREEACkCBBDfAyADIAMoAgAoAogBEQQAKQIEEN8Dc0EBRgRAIAAgAUHI8hAQWUEBIQQLAkACQCACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQoCAgIABg0IAUg0AIAIgAigCACgCiAERBAApAgQgAyADKAIAKAKIAREEACkCBIVCgICAgAKDQgBSDQAgAiACKAIAKAKIAREEACkCBCADIAMoAgAoAogBEQQAKQIEhUKAgICABINCAFINACACIAIoAgAoAogBEQQAKQIEENIIIAMgAygCACgCiAERBAApAgQQ0ghHDQAgAiACKAIAKAKIAREEACkCBBDrBSADIAMoAgAoAogBEQQAKQIEEOsFRw0AIAIgAigCACgCiAERBAApAgQQpQggAyADKAIAKAKIAREEACkCBBClCHNBAUcNAQsgACABQfLyEBBZQQEhBAsCQAJAIAIgAigCACgCiAERBAApAgQgAyADKAIAKAKIAREEACkCBIVCgICAgICACINCAFINACACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQoCAgICAgCCDQgBSDQAgAiACKAIAKAKIAREEACkCBCADIAMoAgAoAogBEQQAKQIEhUKAgICAgIDAAINCAFINACACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQoCAgICAgIABg0IAUg0AIAIgAigCACgCiAERBAApAgQgAyADKAIAKAKIAREEACkCBIVCgICAgICAgAKDQgBSDQAgAiACKAIAKAKIAREEACkCBCADIAMoAgAoAogBEQQAKQIEhUKAgICAgICABINCAFINACACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQoCAgICAgBCDQgBSDQAgAiACKAIAKAKIAREEACkCBCADIAMoAgAoAogBEQQAKQIEhUKAgICAgIABg0IAUg0AIAIgAigCACgCiAERBAApAgQgAyADKAIAKAKIAREEACkCBIVCgICAgICAAoNCAFINACACIAIoAgAoAogBEQQAKQIEIAMgAygCACgCiAERBAApAgSFQoCAgICAgASDUA0BCyAAIAFBrfMQEFlBASEECwJAAkACQAJAIAIgAigCACgCiAERBAApAgQgAyADKAIAKAKIAREEACkCBIVCgICAgICAgDiDQgBSDQAgAiACKAIAKAKIAREEACkCBCADIAMoAgAoAogBEQQAKQIEhUKAgICAgICAwAeDQgBSDQAgAiACKAIAKAKIAREEACgCFCADIAMoAgAoAogBEQQAKAIUc0H/H3ENACACIAIoAgAoAogBEQQAKAIUIAMgAygCACgCiAERBAAoAhRzQYDgAXENACACIAIoAgAoAogBEQQAKQIYIAMgAygCACgCiAERBAApAhiFQoCA/AeDQgBSDQAgAiACKAIAKAKIAREEADMBGCADIAMoAgAoAogBEQQAMwEYhUIAUg0AIAIgAigCACgCiAERBAApAhgQ8AJFDQEgAiACKAIAKAKIAREEACgCDCADIAMoAgAoAogBEQQAKAIMRg0BCyAAIAFBy/MQEFkMAQsgBA0AIAIQvwMoAgQiBEUNASADEL8DKAIEIgNFDQEgBCADEIwORQ0BIAAgAUHs8xAQWSABQYX0EBAYIAIgAigCACgCwAERBAAQuQFBpcAREBgaDAELIAFBhfQQEBggAiACKAIAKALAAREEABC5AUGK9BAQGCEAIAZBEGogAiACKAIAKAJ4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ACAEKAIAKAIIEQIAIAEgAiAAKAIIEPgBAkAgAiACKAIAKAK8AREEAARAIANB2ecQEBgaIAIgAigCACgCvAERBAAiBCAAIAQoAgAoAggRAgAMAQsgA0Hk5xAQGBoLIAIgAigCACgCwAERBAAEQCABIAIgACgCCBD4ASADQffnEBAYGiACIAIoAgAoAsABEQQAIgEgACABKAIAKAIIEQIACyAAIAAoAghBf2o2AgggBUEQaiQAQQALDwAgASACIAMgBCAFEM0VC+o7AQF/IwBBEGsiAyQAIAAoAiAhAQJAIAIoAmhFBEAgAUEQakECQZ3EEBC9AQwBCyABIAIgACgCCBD4AQJAAkAgAigCaEF/aiIAQb4FSw0AAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEEBaw6+BQEEAwXdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QKGAd0Cdt0C3QLdAt0C3QLdAt0CdHVwcXJzAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QJ53QLdAt0C3QLdAt0CeN0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QJ3ent8fX5/3QLdAvcB+AH5Ad0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAoABgQGCAd0CgwGEAYUBlQGWAZcB3QLdAt0C3QLdAt0C3QLdAt0C3QL6AfsB/AHdAocB3QLdAt0C3QLdAogBiQHdAt0CigGLAYwBjQGOAY8BkAHdApEB3QLdAt0C3QLdAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLOAs8C0ALdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdAt0C3QLdApIBkwGUAd0C3QLdApgB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AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEEBaw6oBQEBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODw9Pj9AQUI5OjtDREVGR0hJSktMUFFSU1RVVk1OT1dYWVpbXF1eX2BkZWZnaGlqYWJja2xtbm9wcXJzdHV2d3p7fH1+f4ABgQF4eYQBhQGGAYcBiAGJAYoBiwGCAYMBjAGNAegC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugCjgGPAZABkQGSAZMBlAGVAZYBlwGYAZkBmgGbAegCnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAegC6ALoAugC6ALoAugCqgGrAegC6ALoAqwBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBxAHFAcYBxwG8Ab0ByAHJAcoBywHMAc0B1gHXAc4BzwHQAdEB0gHTAdQB1QG+Ab8BwAHBAcIBwwHYAegC6ALoAtkB6ALoAugC6ALoAugC2gHbAdwB3QHeAd8B4AHhAeIB4wHoAugC6ALoAugC5AHlAeYB6AL6AegC6ALqAesB6ALoAugC6ALoAugC6AL7AegC/AH9Af4B/wHoAugC6ALoAugC6AKAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLoAs4CzwLQAtEC0gLTAtQC1QLWAtcC2ALZAtoC2wLcAt0C3gLfAugC6ALoAuAC4wLkAugC6ALoAugC6ALoAugC6ALoAugC6ALsAe0B7gHoAugC6ALoAugC6ALoAugC6ALnAegB6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAucC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAukB6ALzAfQB9QHoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAuUC5gLoAugC6ALoAu8B8AHxAfIB6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALhAuIC6ALoAugC6ALoAugC6ALoAugC6ALoAugCzQLoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC9gH3AfgB+QHoAugC6ALoAugC6ALIAskCygLLAswCAAsgAUEQakGejBAQGBoM6AILIAFBEGpBq4wQEBga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AmokACABCz4BAX8jAEEQayIEJAAgA0UEQCAEQYCBECkDADcDCCAAIAFBAiAEQQhqIAIgACgCACgCFBEOAAsgBEEQaiQAC0cBAX8jAEEQayIEJAAgA0UEQCAEQfiAECkDADcDCCAEQfCAECkDADcDACAAIAFBBCAEIAIgACgCACgCFBEOAAsgBEEQaiQAC1UBAX8jAEEgayIEJAAgBEEQahDSASACEMQDQeiAEBCWASADEJYBIQIgBEHggBApAwA3AwggACABQQIgBEEIaiACEBsgACgCACgCFBEOACAEQSBqJAALXgEBfyMAQSBrIgQkACAEQRBqENIBIAIQxANB6IAQEJYBIAMQlgEhAiAEQdiAECgCADYCCCAEQdCAECkCADcDACAAIAFBAyAEIAIQGyAAKAIAKAIUEQ4AIARBIGokAAteAQF/IwBBIGsiBCQAIARBEGoQ0gEgAhDEA0HogBAQlgEgAxCWASECIARBzIAQKAIANgIIIARBxIAQKQIANwMAIAAgAUEDIAQgAhAbIAAoAgAoAhQRDgAgBEEgaiQACzgBAX8jAEEQayIBJAAgAUHggBApAwA3AwggAEECIAFBCGogACgCACgCJBEAACEAIAFBEGokACAAC0EBAX8jAEEQayIBJAAgAUHYgBAoAgA2AgggAUHQgBApAgA3AwAgAEEDIAEgACgCACgCJBEAACEAIAFBEGokACAAC0EBAX8jAEEQayIBJAAgAUHMgBAoAgA2AgggAUHEgBApAgA3AwAgAEEDIAEgACgCACgCJBEAACEAIAFBEGokACAAC0cBAX8jAEEQayIEJAAgA0UEQCAEQcyAECgCADYCCCAEQcSAECkCADcDACAAIAFBAyAEIAIgACgCACgCFBEOAAsgBEEQaiQACxsAIAAgAUEGIAIQXCAAIAFBBkGQA0EAIAIQLgsPACABIAIgAyAEIAUQ6RULIAAgACABQQFBggFBACACEC4gACABQQhBrAJBACACEC4LPwAgAkG8xg8QeUUEQCAAIAFBkOAAQaaAEBDZASAAIAFBAkHCA0EAQaaAEBAuIAAgAUEIQcACQQBBpoAQEC4LC0MBAX8jAEEQayIDJAAgARA4IQEgAEEcECsgA0EIaiABEOQBEJABIgAoAgBBEGogAhCFBSAAEDhBAToABCADQRBqJAALfAECfyMAQSBrIgQk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QYABEHQgABCmFgsFACAARQvEAgEEfyMAQRBrIgMkACAAIAEQiwwhAiAAQdyyDzYCACAAQRRqQQBBAEEBQQBBAEEAEEghBCAAQewAahCEBiEFIAQgAUEUahDqBiAAIAEtAGg6AGggAEIANwJ0IABBADYCDCABIAEoAgAoAkQRBABBAU4EQCACIAEgASgCACgCRBEEACABIAEoAgAoAkgRBAAgACgCACgCQBEDAAsCQCABIAEoAgAoAnwRBABFDQAgASgCVBBCQQFIDQBBACECA0AgASACIAEoAgAoAoABEQUAQQFOBEAgACACIAEgAiABKAIAKAKAAREFACABIAIgASgCACgChAERBQAgACgCACgCeBEMAAsgAkEBaiICIAEoAlQQQkgNAAsLIAEoAnAiAgRAIAUgA0EIaiABQewAakEAIAIQ8gYQ5A0Q0QQLIANBEGokACAACzcBAX8gAAJ/QQAgASgCACICRQ0AGiACEBsQvwELNgIAIAAgASgCBBD+DDYCBCAAIAEoAgg2AggLpQEBA38jAEEQayIFJAAgABAmIQQCQCAAEGAiAyAEayACTwRAIAJFDQEgABAbIgMgBAR/IAIgA2ogAyAEEKsFIAEgAmogASADIARqIAFLGyABIAMgAU0bBSABCyACEKsFIAAgAiAEaiIBEIADIAVBADoADyABIANqIAVBD2oQjgEMAQsgACADIAIgBGogA2sgBEEAQQAgAiABEJwHCyAFQRBqJAAgAAsPACABIAIgAyAEIAUQoBYLQAECfyAAKAIAIABBBGoiAigCACABQQRqIgMQjAwgACADEDsgAiABQQhqEDsgABAnIAEQOhA7IAEgASgCBDYCAAtaAQJ/IwBBIGsiAyQAIAAQtgEhAiADQQhqIAAgABDqAUEBahCEBSAAEOoBIAIQqggiAigCCCABEIEEIAIgAigCCEEMajYCCCAAIAIQqhYgAhDUASADQSBqJAALJgEBfyABIABrIgFBDG0hAyABBEAgAiAAIAEQmQMLIAIgA0EMbGoLOAEBfyAAIAFHBEAgAigCACEDA0AgAyAAEIEEIAIgAigCAEEMaiIDNgIAIABBDGoiACABRw0ACwsLVQEBfyMAQRBrIgMkACADIAE2AgggASACEOAFBEADQCAAKAIIIAEQgQQgACAAKAIIQQxqNgIIIANBCGoQgAUgAygC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AgAoAqABEQ0ACwJAIAItAHwQNkUNACACKQIMQj+DQgRRDQAgACABQZa+C0HqxgpB3L8RQQAgACgCACgCoAERDQALAkAgAigChAEiA0UNACACKQIMQj+DQgNRBEAgACgCKCADEK4NDQEgACABQZLCCyACKAKEARDsBUHcvxFBACAAKAIAKAKgARENAAwBCyAAIAFB2L4LIAMQ7AVB3L8RQQAgACgCACgCoAERDQALAkAgAi0AiQFFDQAgAi0AigEEQCAAIAFB0sILQevCC0HcvxFBACAAKAIAKAKgARENACACLQCJAUUNAQsgAikCDEI/g0IDUQRAAkAgACgCKCIDQQAQlgJBAXFFBEAgA0EBEJYCQQFxRQ0BCyAAIAFBosMLQd/DC0HcvxFBACAAKAIAKAKgARENAAwCCyADQQEQ9wwMAQsgACABQdi+C0HfwwtB3L8RQQAgACgCACgCoAERDQALAkAgAi0AigFFDQAgAikCDEI/g0IDUQRAIAAoAigiA0EAEJYCIANBARCWAmwgA0ECEJYCbEEDcQRAIAAgAUH4wwtBqcQLQdy/EUEAIAAoAgAoAqABEQ0ADAILIANBAhD3DAwBCyAAIAFB2L4LQanEC0HcvxFBACAAKAIAKAKgARENAAsCQCAAKAIUQQ1HDQAgACgCKCIDKAKEBEF/Rg0AIAMoAswEQX9GDQAgAygCjARFDQAgACABQQAQxAQLAkACQCACKQIMIhAQ+gENACAQENgCDQAgEBCvAiEDIBBCgICAOINCAFINACADRQ0BCyAAIAFBw8QLQcipC0HcvxFBACAAKAIAKAKgARENAAsgAkEIaiEDAkAgAigCFBC0AUUEQCACKAIYELQBRQ0BCyAAIAFBxcULQdaqC0HcvxFBACAAKAIAKAKgARENAAsgACABIAMQkA0CQCACKQIMIhCnQT9xQX1qIgRBA00EQAJAAkACQAJAIARBAWsOAwIAAQMLAn4gEBC/BARAIABB/KkBaiIEIAQpAgBC/////////0eDIBBCgICAgICAgDiDhDcCACACKQIMIRALIBALEI8DRQ0CIABB/KkBaiIEIAQpAgBC/////////794gyAQQoCAgICAgIDAB4OENwIADAILAn4gEBC/BARAIABByKkBaiIEIAQpAgBC/////////0eDIBBCgICAgICAgDiDhDcCACAC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B0EYakGu8gpB8/IKQdy/EUEAIAAoAgAoAqABEQ0ACwJAIAYgBigCACgCLBEEACkCGBCvA0UNACAGIAYoAgAoAiwRBAAhCSAAKQLQBSAJKQIYhUKAgID4D4NQDQAgACAHQRhqQa7yCkH+8gpB3L8RQQAgACgCACgCoAERDQALIAYgBigCACgCLBEEACkCBCEOIAggCCgCACgCKBEEACIJIAkpAgRC/////36DIA5CgICAgAGDhDcCBCAGIAYoAgAoAiwRBAApAgQhDiAIIAgoAgAoAigRBAAiCSAJKQIEQv//////v3+DIA5CgICAgIDAAIOENwIEIAYgBigCACgCLBEEACkCBCEOIAggCCgCACgCKBEEACIJIAkpAgRC////v3+DIA5CgICAwACDhDcCBCAGIAYoAgAoAiwRBAApAgQhDiAIIAgoAgAoAigRBAAiCSAJKQIEQv////9fgyAOQoCAgIAgg4Q3AgQgBiAGKAIAKAIsEQQAKQIEIQ4gCCAIKAIAKAIoEQQAIgkgCSkCBEL/////fYMgDkKAgICAAoOENwIEIAYgBigCACgCLBEEACkCBCEOIAggCCgCACgCKBEEACIJIAkpAgRC/////3uDIA5CgICAgASDhDcCBCAGIAYoAgAoAiwRBAApAgQhDiAIIAgoAgAoAigRBAAiCSAJKQIEQv////+/f4MgDkKAgICAwACDhDcCBCAGIAYoAgAoAiwRBAApAhghDiAIIAgoAgAoAigRBAAiCSAJKQIYQv////////+BgH+DIA5CgICAgICAgP7/AIOENwIYIAYgBigCACgCLBEEACkCGCEOIAggCCgCACgCKBEEACIJIAkpAhhC/////49+gyAOQoCAgIDwAYOENwIYIAYgBigCACgCLBEEACkCGCEOIAggCCgCACgCKBEEACIJIAkpAhhC//////+BgH6DIA5CgICAgID+/wGDhDcCGCAIIAgoAgAoAigRBAApAhhCgICAgICAgP7/AINCgICAgICAgB5SBEAgACkC0AUhDiAKIAooAgAoAigRBAAiCSAJKQIYQv////+PfoMgDkKAgICA8AGDhDcCGCAAKQLQBSEOIAggCCgCACgCKBEEACIJIAkpAhhC/////49+gyAOQoCAgIDwAYOENwIYCwJAIAggCCgCACgCeBEEAEUNACAGIAYoAgAoAnQR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EUEAIAAoAgAoAqABEQ0ACyAGIQMLIAhBCGoQYhogCSgCBBAkIQYgCCgCCCIEIAYQJQ0ACyADDQELQQAhAyAAIAFBi6oKIAIgAigCACgCDBEEABAbQdy/EUEAIAAoAgAoAqABEQ0ACyAJELUBCyAIQSBqJAAgAwtaACAAKAJMIAIgAigCACgCGBEEACADQQAQqwEiA0UEQCAAIAFBi6oKIAIgAigCACgCDBEEABAbQdy/EUEAIAAoAgAoAqABEQ0AQQAPCyADIAMoAgAoAhwRBAALYQEEfyMAQRBrIgIkAAJAIAAtABENACAAENwCIQMDQCAAKAIAIAMQGigCACABIAJBD2oQvRgiBUUEQCADIAVBAXNrIgNBf0oNAQwCCwsgAi0AD0EARyEECyACQRBqJAAgBAvYAQIBfwF+QX8hAgJAIABCAFIgAUL///////////8AgyIDQoCAgICAgMD//wBWIANCgICAgICAwP//AFEbDQAgACADQoCAgICAgID/P4SEUARAQQAPCyABQoCAgICAgID/P4NCAFkEQCAAQgBUIAFCgICAgICAgP8/UyABQoCAgICAgID/P1EbDQEgACABQoCAgICAgID/P4WEQgBSDwsgAEIAViABQoCAgICAgID/P1UgAUKAgICAgICA/z9RGw0AIAAgAUKAgICAgICA/z+FhEIAUiECCyACC9QEAQN/IwBBIGsiBCQAIARBEGogAiACKAIAKAIwEQQAELACIARBEGoQGyEFAn8CQCACIAIoAgAoApABEQQAQQJHBEAgACABQbCzCiAFQdy/EUEAIAAoAgAoAqABEQ0ADAELIAIgAigCACgCMBEEACIDIAMoAgAoAnARBAAEQCAAIAFB27MKIAVB3L8RQQAgACgCACgCoAERDQAMAQsCQAJAIAJBACACKAIAKAKgAREFACgCBCIDIAMoAgAoAhwRBABBDkcNACACQQAgAigCACgCoAERBQAoAgQiAyADKAIAKAIkEQQAEI8HRQ0AIAJBACACKAIAKAKgAREFACgCBCIDIAMoAgAoAnARBABFDQELIAAgAUGQtAogBUHcvxFBACAAKAIAKAKgARENAAwBCyAEIAIgAigCACgCMBEEACIDIAMoAgAoAiARBAAoAgA2AgggBEEIakEAEKcOIAQgBCgCCEH//3dxNgIIIARBCGogAkEAIAIo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AUHcpA4gBiAGKAIAKAIMEQQAEBtB3L8RQQAgACgCACgCoAERDQAMAgsgBUEANgIAIAMgCCABEL4DIAEQ+AIhAwwBCyADIAUoAgQgARD6GSABEPgCIQMLIAdBAWoiByACIAIoAgAoApABEQQASA0ACwsgBEEYakEAQQBBAUEAQQBBABBIIQIgBCABKQIINwMQIAQgASkCADcDCCADQQUgAiAEQQhqELcCGiACED0aIABBADoAZSAAQQA2AlwgAEIANwJQIARB8ABqJAAgAwveAQACQAJ/IAIgAigCACgCUBEEAEUEQCACIAIoAgAoAmARBAAMAQsgAiACKAIAKAJQEQQAIgIgAigCACgCwAERBAAiAiACKAIAKAIwEQQACyICRQ0AIAAoAkwgAiACKAIAKALAAREEAEEAQQAQqwEiAkUNACACIAIoAgAoAigRBAAiAkUNACACIAIoAgAoAnwRBABFDQAgAiADIAIoAgAoAoABEQUAQQFIDQAgACABIAIgAyACKAIAKAKAAREFACACIAMgAigCACgChAERBQAgBBAbIAAoAgAoAhQRDgALC4cQAQR/IwBBoAFrIgQkACAEIAI2ApwBIAAgBEGcAWoQ9gUgA0H6rRAQMiEGIAQoApwBIgIgAigCACgCoAERBAAhBQJAAkAgBgRAIAUEQCAAIAFBAUH4AEGmtg9BsYUKEC4gACABQQhBrAJBAEGxhQoQLgwCCwJAIAIgAigCACgCpAERBABFBEAgAiACKAIAKAKcAREEAEUNAQsgACABQXdBuYUKEFwgACABQXdBpANBu7YPQbmFChAuDAILIAIgAigCACgCeBEEABCCAQ0BIAMQGyEDIARByABqIAIgAigCACgCeBEEABDPASAAIAFB24UKIAMgBEHIAGoQG0EAIAAoAgAoAqABEQ0AIAQoApwBIQIMAgsgBQRAIAAgAUH6hQpBlIYKIAMQG0EAIAAoAgAoAqABEQ0ADAILIAIgAigCACgCeBEEABCCAQRAIAAgAUGWhgpBlIYKIAMQG0EAIAAoAgAoAqABEQ0ADAILAkACQCACIAIoAgAoAqQBEQQARQRAIAIgAigCACgCqAERBABFDQELAkAgAiACKAIAKAKwAREEAA0AIAIgAigCACgCtAERBAANACACIAIoAgAoAoABEQQAQQxHDQELIAIgAigCACgCqAER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IAIoAgAoAiwRBAApAgQQuAJFDQELIAAgAUEBQdT9CUHY/QkgACgCACgCFBEOAA8LIAAgAUHcvxFBpfoJQef9CUEAIAAoAgAoAqABEQ0ACwtzAQF/AkAgASABKAIAKAIwEQQAIgFFDQAgASABKAIAKAJ4EQQAIgIgAigCACgCeBEEAEUNACAAIAEgASgCACgCeBEEACIAIAAoAgAoAiwRBABBABDvCCIAQQFIDQAgASABKAIAKAJ8EQQAKAI8IAAQsgMLC8sBAgR/An4jAEEQayIDJAAgAbwiBEGAgICAeHEhBQJ+IARB/////wdxIgJBgICAfGpB////9wdNBEAgAq1CGYZCgICAgICAgMA/fAwBCyACQYCAgPwHTwRAIAStQhmGQoCAgICAgMD//wCEDAELIAJFBEBCAAwBCyADIAKtQgAgAmciAkHRAGoQgQIgAykDACEGIAMpAwhCgICAgICAwACFQYn/ACACa61CMIaECyEHIAAgBjcDACAAIAcgBa1CIIaENwMIIANBEGokAAunDwEEfyMAQZABayIEJAAgBCACNgKMASAEQQA2AogBIAMgAygCACgChAERBAApAgQQvAMEQCAEIAMgAygCACgCFBEEABBTQQAQFygCADYCiAELIAAgBEGMAWoQ9gUCQAJAIAQoAowBIgIgAigCACgCoAERBAANACACIAIoAgAoApwBEQQADQAgAiACKAIAKAKkAREEAA0AIAIgAigCACgCeBEEABCCAQ0AIAIQ/gENAAJAIAIgAigCACgCMBEEAARAIAAgAUHv+QkgAiACKAIAKAIwEQQAIgIgAigCACgCwAERBAAQG0HcvxFBACAAKAIAKAKgARENAAwBCyAAIAFB7/kJQZjvDkHcvxFBACAAKAIAKAKgARENAAtEAAAAAAAAAABBASABQQAQ/QUhAQwBCwJAIAIgAigCACgCoAERBAANACACIAIoAgAoAqQBEQQARQ0AIAIgAigCACgCeBEEABDIAgRAIAAgAUGl+glBp/oJIAAoAgAoAlARDAALIAIgAigCACgCeBEEABDHAgRAIAAgAUGl+glB1PoJIAAoAgAoAlwRDAALIAIgAigCACgCeBEEABDaAkUNACAAIAFBpfoJQYL7CSAAKAIAKAJoEQwACwJAIAIgAigCACgCeBEEACIFIAUoAgAoAiwRBAApAgQQvANFDQAgAyADKAIAKAKEAREEACkCBBC8A0UNACAAIAEgAiACKAIAKAJ4EQQAIARBiAFqEPgIIAIgBCgCiAEgARDlDSEBDAELAkAgAhD+AUUNACACIAIoAgAoAqABEQQADQAgACABQQFBsPsJQbT7CSAAKAIAKAIUEQ4AIAAoAighACAEIAEpAgg3AyggBCABKQIANwMgIABBlwEgAiADIARBIGoQ4wMiASAEKAKMASIAIAAoAgAoAngRBAAgASgCACgCdBECAAwBCwJAIAIgAigCACgCMBEEAEUNACAAIAIgAigCACgCeBEEABC0A0UNACAAIAIQ3hgLIAMgAygCACgChAERBAApAgQQvAMEQCAAIAEgAiACKAIAKAJ4EQQAIARBiAFqEPgICyADIAMoAgAoAoQBEQQAKQIEELwDIQYgAiACKAIAKAJ4EQQAIgUgBSgCACgCeBEEACEFAn8gBgRAIAIoAgAhBgJAIAUEQCACIAYoAnwRBAAiBSAEKAKIAUEBaiIGIAUoAgAoAoQBEQIAIAIgAigCACgChAERBAApAgQQ8wJFDQEgAiACKAIAKAKEAREEAC8BBEHA/wFxRQ0BIAIgAigCACgCIBEEACIFRQ0BIAQgBSAFKAIAKALAAREEACIFIAUoAgAoAnwRBAAiBSAFKAIAKAJQEQQAIgVBARD7ATYCMCAEIAY2AoQBIAVBASAEQTBqIARBhAFqEJ8BKAIAEMYEDAELIAAgASACIAYoAngRBAAgBEGIAWoQ+AgLIAQgASkCCDcDCCAEIAEpAgA3AwBBsQEgAiADIAQQowUMAQsgBQRAAkACQCACIAIoAgAoAjARBABFDQAgACACIAIoAgAoAngRBAAQtANFDQAgACABQdy/EUGl+glBzvsJQQAgACgCACgCoAERDQAMAQsgACABIAIQ3RgLIAIgAigCACgCfBEEACIFIAUoAgAoAoABEQgACwJAIAIgAigCACgCgAERBABBEEYEQCACIAIoAgAoAoQBEQQAKQIEQj+DQgZRBEAgACACIAIoAgAoAgARBABBd0Gu/AkQXAwCCyACIAIoAgAoAoQBEQQAKQIEQj+DQgVSDQEgACACIAIoAgAoAgARBABBCEHAAkECQdT8CUHc/AkQ2gEMAQsCQCAAKAIUQQRHDQAgAiACKAIAKAKEAREEACkCBBDkAkUNACAAIAIgAigCACgCABEEAEF3QYL9CRBcDAELIAIgAigCACgCgAERBABBDkcNACAAKAIQQYIBSA0AIAAgAiACKAIAKAIAEQQAQQ5Bsf0JEFwgACACIAIoAgAoAgARBABBCEHAAkECQdT8CUGx/QkQ2gEgACACIAIoAgAoAgARBABBBkGQA0EAQbH9CRAuCyAEIAEpAgg3AxggBCABKQIANwMQQbIBIAIgAyAEQRBqEKMFCyEBIARBMGogAiACKAIAKAJ4EQQAQQBBABDcASEFAkACQCACIAIoAgAoAngRBAAiBiAGKAIAKAIsEQQAKQIEEKACRQ0AIAMgAygCACgChAERBAApAgQQoAJFDQAgBRAnIgYgBikCBEJAg0IChDcCBCACIAIoAgAoAngRBAAiByAHKAIAKAIsEQQAKQIEEO8BRQRAIAMgAygCACgChAERBAApAgQQ7wFFDQILIAYQvQMMAQsgBRAnIgYgBikCBELA////d4M3AgQLIAEgBSABKAIAKAJ0EQIAIAIgAigCACgChAERBAAgASABKAIAKAJ8EQQAIgYgBigCACgCKBEEABDwCAJAIAIgAigCACgChAERBAApAgQQ+gJFBEAgAyADKAIAKAKEAREEACkCBBD6AkUNAQsgASABKAIAKAJ8EQQAIgYgBigCACgCKBEEACIGIAYpAgRCgICAgBCENwIECyAALQCoqwEEQCAAIAIgAxDbGAsgBRA9GgsgBEGQAWokACABC3wBAn8jAEEgayIEJAAgASAEQRxqIAIQ8QgiBSgCACECIARBADoAGyACRQRAIARBCGogASADELwNIAEgBCgCHCAFIAQoAggQkgMgBEEIahB6IQIgBEEBOgAbIARBCGoQnAILIAAgBEEIaiACEDMgBEEbahCmASAEQSBqJAALLAEBfyMAQRBrIgMkACADQQhqIAEgAiACEOEYIAAgA0EIahCVBSADQRBqJAALkQcBBH8jAEHwAGsiBiQAIAYgAjYCbAJAAkACQAJAIAJFDQAgAiACKAIAKAJEEQQABEAgACABIAIgAigCACgCRBEEACACIAIoAgAoAkgRBAAgAiACKAIAKAIMEQQAEBsgACgCACgCFBEOAAsCQCACIAIoAgAoAlARBABFDQAgAiACKAIAKAIwEQQAIgQgBCgCACgCqAERBAANACACIAIoAgAoAjARBAAi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DRshDUF+IQkMBwtBACAFayESDAELIAkhBCAHQbCFDmovAQAiEkUNAQsgAkHQA2ogAUEBIBJB4JAOai0AACIYa0HQAWxqQdABEEAaAkAgEkF+aiIEQcQESw0AAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIARBAWsOxAQBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AcMEwwS4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wGAAoECggKDAoQChQKGAocCiAKJAooCiwKMAo0CjgKPApACkQKSApMClAKVApYClwKYApkCmgKbApwCnQKeAp8CoAKhAqICowKkAqUCpgKnAqgCqQKqAqsCrAKtAq4CrwKwArECsgKzArQCtQK2ArcCuAK5AroCuwK8Ar0CvgK/AsACwQLCAsMCxALFAsYCxwLIAskCygLLAswCzQLO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AkEBNgLsAyADQQRBAhBVDOUCCyADIAEgACgCTBAgEB4gAkEBNgLsAyADQQRBAxBVDOQCCyADIAEgACgCTBAgEB4gAkEBNgLsAyADQQRBBBBVDOMCCyAAIAFBp54OIAAoAgAoAkARAwAgAyABIAAoAkwQIBAeIAJBAjYC7AMM4gILIAAgAUGung4gACgCTBAsIAAoAgAoAkgRDAAgAyABIAAoAkwQIBAeIAJBAzYC7AMM4QILIAAgAUG4ng4gACgCTBAsIAAoAgAoAoABEQwAIAMgASAAKAJMECAQHiACQQE2AuwDDOACCyAAIAFBwp4OIAAoAkwQLCAAKAIAKAKEAREMACADIAEgACgCTBAgEB4gAkECNgLsAwzfAgsgACABQcyeDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEENgLsAwzeAgsgACABQeGeDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEFNgLsAwzdAgsgACABQfieDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEGNgLsAwzcAgsgACABQY6fDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEHNgLsAwzbAgsgACABQaafDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEINgLsAwzaAgsgACABQbyfDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEJNgLsAwzZAgsgACABQdSfDiAAKAJMECwgACgCACgCcBEMACADIAEgACgCTBAgEB4gAkEKNgLsAwzYAgsgACABQeOfDiAAKAJMECwgACgCACgCcBEMACADIAEgACgCTBAgEB4gAkELNgLsAwzXAgsgACABQfufDiAAKAIAKAJAEQMAIAMgASAAKAJMECAQHiACQQI2AuwDIANBAhBlDNYCCyAAIAFB+58OIAAoAgAoAkARAwAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0EDEGUM1QILIAAgAUH7nw4gACgCACgCQBEDACADIAEgACgCTBAgEB4gAkECNgLsAyADQQQQZQzUAgsgACABQYmgDiAAKAJMECwgACgCACgCSBEMACADIAEgACgCTBAgEB4gAkEDNgLsAyADQQIQZQzTAgsgACABQYmgDiAAKAJMECwgACgCACgCSBEMACADIAEgACgCTBAgEB4gAkEDNgLsAyADQQMQZQzSAgsgACABQYmgDiAAKAJMECwgACgCACgCSBEMACADIAEgACgCTBAgEB4gAkEDNgLsAyADQQQQZQzRAgsgACABQZugDiAAKAJMECwgACgCACgCgAERDAAgAyABIAAoAkwQIBAeIAJBATYC7AMgA0ECEGUM0AILIAAgAUGboA4gACgCTBAsIAAoAgAoAoABEQwAIAMgASAAKAJMECAQHiACQQE2AuwDIANBAxBlDM8CCyAAIAFBm6AOIAAoAkwQLCAAKAIAKAKAAREMACADIAEgACgCTBAgEB4gAkEBNgLsAyADQQQQZQzOAgsgACABQaygDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0ECEGUMzQILIAAgAUGsoA4gACgCTBAsIAAoAgAoAoQBEQwAIAMgASAAKAJMECAQHiACQQI2AuwDIANBAxBlDMwCCyAAIAFBrKAOIAAoAkwQLCAAKAIAKAKEAREMACADIAEgACgCTBAgEB4gAkECNgLsAyADQQQQZQzLAgsgACABQb2gDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEENgLsAyADQQIQZQzKAgsgACABQb2gDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEENgLsAyADQQMQZQzJAgsgACABQb2gDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEENgLsAyADQQQQZQzIAgsgACABQdmgDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEGNgLsAyADQQIQZQzHAgsgACABQdmgDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEGNgLsAyADQQMQZQzGAgsgACABQdmgDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEGNgLsAyADQQQQZQzFAgsgACABQfagDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEINgLsAyADQQIQZQzEAgsgACABQfagDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEINgLsAyADQQMQZQzDAgsgACABQfagDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEINgLsAyADQQQQZQzCAgsgACABQZOhDiAAKAJMECwgACgCACgCcBEMACADIAEgACgCTBAgEB4gAkEKNgLsAyADQQIQZQzBAgsgACABQZOhDiAAKAJMECwgACgCACgCcBEMACADIAEgACgCTBAgEB4gAkEKNgLsAyADQQMQZQzAAgsgACABQZOhDiAAKAJMECwgACgCACgCcBEMACADIAEgACgCTBAgEB4gAkEKNgLsAyADQQQQZQy/AgsgACABQamhDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEFNgLsAyADQQIQZQy+AgsgACABQamhDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEFNgLsAyADQQMQZQy9AgsgACABQamhDiAAKAJMECwgACgCACgCYBEMACADIAEgACgCTBAgEB4gAkEFNgLsAyADQQQQZQy8AgsgACABQcehDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEHNgLsAyADQQIQZQy7AgsgACABQcehDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEHNgLsAyADQQMQZQy6AgsgACABQcehDiAAKAJMECwgACgCACgCVBEMACADIAEgACgCTBAgEB4gAkEHNgLsAyADQQQQZQy5AgsgACABQeahDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEJNgLsAyADQQIQZQy4AgsgACABQeahDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEJNgLsAyADQQMQZQy3AgsgACABQeahDiAAKAJMECwgACgCACgCfBEMACADIAEgACgCTBAgEB4gAkEJNgLsAyADQQQQZQy2AgsgACABQYWiDiAAKAJMECwgACgCACgCcBEMACADIAEgACgCTBAgEB4gAkELNgLsAyADQQIQZQy1AgsgACABQYWiDiAAKAJMECwgACgCACgCcBEMACADIAEgACgCTBAgEB4gAkELNgLsAyADQQMQZQy0AgsgACABQYWiDiAAKAJMECwgACgCACgCcBEMACAD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ACgCgAERDAAgAyABIAAoAkwQIBAeIAJBATYC7AMgA0EDQQMQVQyTAgsgACABQcSiDiAAKAJMECwgACgCACgCgAERDAAgAyABIAAoAkwQIBAeIAJBATYC7AMgA0EDQQQQVQySAgsgACABQcSiDiAAKAJMECwgACgCACgCgAERDAAgAyABIAAoAkwQIBAeIAJBATYC7AMgA0EEQQIQVQyRAgsgACABQcSiDiAAKAJMECwgACgCACgCgAERDAAgAyABIAAoAkwQIBAeIAJBATYC7AMgA0EEQQMQVQyQAgsgACABQcSiDiAAKAJMECwgACgCACgCgAERDAAgAyABIAAoAkwQIBAeIAJBATYC7AMgA0EEQQQQVQyPAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0ECQQIQVQyOAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0EDQQMQVQyNAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0EEQQQQVQyMAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0ECQQIQVQyLAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0ECQQMQVQyKAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0ECQQQQVQyJAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0EDQQIQVQyIAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0EDQQMQVQyHAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0EDQQQQVQyGAgsgACABQdWiDiAAKAJMECwgACgCACgChAERDAAgAyABIAAoAkwQIBAeIAJBAjYC7AMgA0EEQQIQVQyFAgsgACABQdWiDiAAKAJMECwgACgC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qAFqEJoBGiAAIABBsARqNgK8BCAAQgA3ArgBIABBwARqENIBIQEgAEGzAjYC2AQgAEHQrg82AtwEIABBsgI2AugEIABB0K4PNgLsBCAAQbECNgL4BCAAQdCuDzYC/AQgAEGwAjYCiAUgAEHQrg82AowFIABBrwI2ApgFIABB0K4PNgKcBSAAQT82AqgFIABCgICAgPD/PzcCoAUgCgRAIAEgChDhAhoLC6sEAQF+IAAgASACIAMgBCAFIAYgByAIIAkgChCFGSAAIABBrAlqNgK4CSAAQQA2ArQFIABBADoAsAUgAEHQ6Qk2AgAgAEG8qQFqIgFBADYCBCABQajsCTYCACAAQZSrAWoQ0gEaIABBADoAqKsBIABBADYCpKsBIABBrKsBahCTAxogAEG4qwFqEJoBGiAAQcirAWoQmgEaAkAgACgCCBA+RQRAIAYoAghBAUgNAQsgAUEBOgAEIAdBBEcgA3INACAAKAIIED4NACAGKAIIQQFIDQAgAUEBOgAFCyAAEIQZIABB+KkBahD9AiAAQfypAWoiASABKQIAQv////////9Hg0KAgICAgICAEIQiCzcCACABIAtC/////////5d4g0KAgICAgICAgAFCgICAgICAgMAAIAYoAgAbhDcCACAAQcSpAWoQ/QIgAEHIqQFqIgEgASkCAEL/////////R4NCgICAgICAgBCEIgs3AgAgASALQv////////+XeINCgICAgICAgMABQoCAgICAgIDAACAGKAIAG4Q3AgAgBigCAEGAhgRPBEAgACgCKBCDBwsgAEGsqgFqEP0CIABB4KoBahD9AiAHQQNNBEAgAEH4qgFqIgEgASkCAEL/////j36DNwIACyAHQQNGBEAgAEH4qgFqIgAgACkCAEL///+HcIM3AgALAkAgCkUNACAKECZFDQAgCkG4oA8QxwRFDQAgCEECQejrCRC9AQsLCQAgABCrBxAwC5oFAQR/IwBBEGsiBiQAIAIQJkEFTwRAIAAgAUGb5gkgAhAbQdy/EUEAIAAoAgAoAqABEQ0ACyAGIAIQJjYCAEG05gkgBhCVAygCACIHQQFOBEADQAJAAkAgAiAFEFIsAABBn39qIghBGUsNAAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAIQQFrDhkHDAwMDAQMDAwMDAwMDAgLAQIFDAwJAAMG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BDYCAEHU5hEoAgAhASAAQZHICTYCACABIAAQHEHmBDYCAEHU5hEoAgAhASAAQZfICTYCACABIAAQHEHnBDYCAEHU5hEoAgAhASAAQaDICTYCACABIAAQHEHoBDYCAEHU5hEoAgAhASAAQaPICTYCACABIAAQHEHqBDYCAEHU5hEoAgAhASAAQafICTYCACABIAAQHEHlBDYCAEHU5hEoAgAhASAAQazsEDYCACABIAAQHEHuBDYCAEHU5hEoAgAhASAAQdOlDjYCACABIAAQHEHvBDYCAEHU5hEoAgAhASAAQf2lDjYCACABIAAQHEHwBDYCAEHU5hEoAgAhASAAQbGiETYCACABIAAQHEHrBDYCAEHU5hEoAgAhASAAQbmiETYCACABIAAQHEHpBDYCAEHU5hEoAgAhASAAQc6nDjYCACABIAAQHEHsBDYCAEHU5hEoAgAhASAAQcenDjYCACABIAAQHEHtBDYCAEHU5hEoAgAhASAAQemZDjYCACABIAAQHEHkBDYCAEHU5hEoAgAhASAAQbmXDzYCACABIAAQHEGDAjYCAEHU5hEoAgAhASAAQfmWDzYCACABIAAQHEGGAjYCAEHU5hEoAgAhASAAQZ+XDzYCACABIAAQHEGEAjYCAEHU5hEoAgAhASAAQa3ICTYCACABIAAQHEGHAjYCAEHU5hEoAgAhASAAQbPICTYCACABIAAQHEGIAjYCAEHU5hEoAgAhASAAQbnICTYCACABIAAQHEGJAjYCAEHU5hEoAgAhASAAQb/ICTYCACABIAAQHEGQAjYCAEHU5hEoAgAhASAAQcTICTYCACABIAAQHEGRAjYCAEHU5hEoAgAhASAAQcnICTYCACABIAAQHEGSAjYCAEHU5hEoAgAhASAAQc7ICTYCACABIAAQHEGKAjYCAEHU5hEoAgAhASAAQdTICTYCACABIAAQHEGLAjYCAEHU5hEoAgAhASAAQdrICTYCACABIAAQHEGMAjYCAEHU5hEoAgAhASAAQeDICTYCACABIAAQHEGTAjYCAEHU5hEoAgAhASAAQeXICTYCACABIAAQHEGUAjYCAEHU5hEoAgAhASAAQerICTYCACABIAAQHEGVAjYCAEHU5hEoAgAhASAAQY7oEDYCACABIAAQHEHcBDYCAEHU5hEoAgAhASAAQZPoEDYCACABIAAQHEHc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BTYCAEHU5hEoAgAhASAAQfKcDjYCACABIAAQHEGFBTYCAEHU5hEoAgAhASAAQeiXDzYCACABIAAQHEGfAzYCAEHU5hEoAgAhASAAQbebDjYCACABIAAQHEGWBTYCAEHU5hEoAgAhASAAQcybDjYCACABIAAQHEGXBTYCAEHU5hEoAgAhASAAQdabDjYCACABIAAQHEGYBTYCAEHU5hEoAgAhASAAQdmjDjYCACABIAAQHEGgAzYCAEHU5hEoAgAhASAAQeSjDjYCACABIAAQHEGhAzYCAEHU5hEoAgAhASAAQe+jDjYCACABIAAQHEGiAzYCAEEUECsiARCkASECQdDmESABNgIAIABB9eAJNgIMIAAgAiAAQQxqEIQBQdDmESgCACEBIABB/OAJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBhuEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBjeEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBkeEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBl+EJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBneEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBouEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBquEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBs+EJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBuOEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBveEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBxOEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBzeEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABB1OEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABB2+EJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABB4uEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABB6+EJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABB9eEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABB+uEJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBgOIJNgIMIAAgASAAQQxqEIQBQdDmESgCACEBIABBheIJ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KQMAQoCAgICAgICAgH9SDQAgBCABEBdCgICAgICAgICAfxBdDAILIAQgARAXIAcgARAXKQMAIAggARAXKQMAfxBdDAELIAggARAXKQMAUCEGIAQgARAXIQIgBgRAIAJCfxBeDAELIAIgByABEBcpAwAgCCABEBcpAwCAEF4LIAFBAWoiASAFRw0ACwwMCyADQbABaiAAIAAoAgAoApgBEQQAEIgCIQEgA0HYAGpBDEECQQFBAEEAQQAQSBogACAAKAIAKAKYAREEAEEASgRAQQAhAgNAQQAhBUQAAAAAAAAAACENIAYgBigCACgCkAERBABBAEoEQANAIA0gByAAIAAoAgAoApgBEQQAIAVsIAJqEBcrAwAgCCAFEBcrAwCioCENIAVBAWoiBSAGIAYoAgAoApABEQQASA0ACwsgASACEBcgDRA1IAJBAWoiAiAAIAAoAgAoApgBEQQASA0ACwsgCiADIAAgACgCACgCgAERBABBAiAAIAAoAgAoApgBEQQAQQBBAEEAEEgiARCVASABED0aDAsLIAVBAUgNCkEAIQEDQAJAIAggARAXEJ4FBEAgByABEBchAiAEIAEQFyIGIAIoAgg2AgggBiACKQMANwMADAELAkAgACAAKAIAKAJ4EQQAIgIgAigCACgCHBEEAEF6aiICQQRLDQACQAJAAkAgAkEBaw4EAwADAQILIAggARAXKAIAQX9HDQIgByABEBcoAgBBgICAgHhHDQIgBCABEBdBABBmDAMLIAggARAXKQMAQn9SDQEgByABEBcpAwBCgICAgICAgICAf1INASAEIAEQF0IAEF0MAgsgCCABEBcoAgBBf0cNACAHIAEQFygCAEGAgH5HDQAgBCABEBdBABBmDAELIAMgByABEBcgCCABEBcQyhkgBCABEBciAiADKAIINgIIIAIgAykDADcDAAsgAUEBaiIBIAVHDQALDAoLIAVBAUgNCUEAIQEDQCADIAcgARAXIAggARAXEMkZIAQgARAXIgIgAygCCDYCCCACIAMpAwA3AwAgAUEBaiIBIAVHDQALDAkLIAVBAUgNCEEAIQEDQCADIAcgARAXIAggARAXEMgZIAQgARAXIgIgAygCCDYCCCACIAMpAwA3AwAgAUEBaiIBIAVHDQALDAgLIAVBAUgNB0EAIQEDQCADIAcgARAXIAggARAXEMcZIAQgARAXIgIgAygCCDYCCCACIAMpAwA3AwAgAUEBaiIBIAVHDQALDAcLIAVBAUgNBkEAIQEDQCADIAcgARAXIAggARAXEMYZIAQgARAXIgIgAygCCDYCCCACIAMpAwA3AwAgAUEBaiIBIAVHDQALDAYLIAVBAUgNBUEAIQEDQCADIAcgARAXIAggARAXEMUZIAQgARAXIgIgAygCCDYCCCACIAMpAwA3AwAgAUEBaiIBIAVHDQALDAULIAVBAUgNBEEAIQEDQCADIAcgARAXIAggARAXEMQZIAQgARAXIgIgAygCCDYCCCACIAMpAwA3AwAgAUEBaiIBIAVHDQALDAQLIAVBAUgNA0EAIQEDQCADIAcgARAXIAggARAXEMMZIAQgARAXIgIgAygCCDYCCCACIAMpAwA3AwAgAUEBaiIBIAVHDQALDAMLQQAhASAFQQBMDQIDQCAAIAAoAgAoAngRBAAiAiACKAIAKAIcEQQAQQxGBEAgBCABEBcgByABEBcgCCABEBcQiQdBAXMQdQsgAUEBaiIBIAVHDQALDAILIANBsAFqIAYgBigCACgClAERBAAQiAIhAUEAIQIgA0HYAGpBDEECQQFBAEEAQQAQSBogBiAGKAIAKAKUAREEAEEASgRAA0BBACEFRAAAAAAAAAAAIQ0gACAAKAIAKAKQAREEAEEASgRAA0AgDSAHIAUQFysDACAIIAYgBigCACgCmAERBAAgAmwgBWoQFysDAKKgIQ0gBUEBaiIFIAAgACgCACgCkAERBABIDQALCyABIAIQFyANEDUgAkEBaiICIAYgBigCACgClAERBABIDQALCyAKIAMgACAAKAIAKAKAAREEAEECIAYgBigCACgClAERBABBAEEAQQAQSCIBEJUBIAEQPRoMAQsgACAAKAIAKAKYAREEAEEASgRAQQAhBANAQQAhASAGIAYoAgAoApQBEQQAQQBKBEADQCAGIAYoAgAoApgBEQQAIQkgACAAKAIAKAKYAREEACECRAAAAAAAAAAAIQ1BACEFIAlBAEoEQANAIA0gByACIAVsIARqEBcrAwAgCCAGIAYoAgAoApgBEQQAIAFsIAVqEBcrAwCioCENIAYgBigCACgCmAERBAAhCSAAIAAoAgAoApgBEQQAIQIgBUEBaiIFIAlIDQALCyADQbABaiABIAJsIARqEBcgDRA1IAFBAWoiASAGIAYoAgAoApQBEQQASA0ACwsgBEEBaiIEIAAgACgCACgCmAERBABIDQALCyAKIAMgACAAKAIAKAJ4EQQAIgEgASgCACgCHBEEAEECQQAgBiAGKAIAKAKUAREEACAAIAAoAgAoApgBEQQAQQAQSCIBEJUBIAEQPRoLQfQAEHQiAiADQbABaiAKEJYHGiACIAAgACgCACgCABEEACACKAIAKAIEEQIACyADQdgAahA9GiAKED0aIANBoAJqJAAgAgtgAQN/QagBEHQiAxCODiECIAMgASADKAIAKAIEEQIAIAIgAygCACgCvAERBAAhBEEAIQIgACgCAEEASgRAA0AgBCAAIAIQjQcgARDlGSACQQFqIgIgACgCAEgNAAsLIAMLWQEBfyMAQRBrIgMkACAAIAEQnwUiACgCAEEwEMkBIANBCGogABDkARCQASIAKAIAQRBqIgEgAhCAAhogAUEQaiACQRBqEIACGiAAEDhBAToABCADQRBqJAALXAEBfyMAQSBrIgIkACACQQhqIAAgARDOGSAAIAJBBGogAigCCEEQahCUDiEBIAAgAigCBCABIAIoAggQywQgAkEYaiACQQhqEHoQMxogAkEIahDAASACQSBqJAALMwEBfyAAKAIEIgFFBEAgABC0AkUEQANAIAAoAggiABC0AkUNAAsLIAAoAggPCyABEJIOCz0BAn8jAEEQayICJAAgACACQQRqIAFBEGoQlA4hAyAAIAIoAgQgAyABEMsEIAJBCGogARAzGiACQRBqJAALPQEBfyMAQRBrIgIkACACQQhqIAAgAEEQahDKARogAigCCCABEOECGiACKAIMIAEQlwEQ4QIaIAJBEGokAAs8AQJ/IAAoAgAhASAAIAAQOCICNgIAIAIoAgBBADYCCCACQQA2AgAgABA6QQA2AgAgASgCBCIAIAEgABsLtgEBA38jAEEQayIDJAAgAyABNgIIAkAgABA6KAIARQ0AIAAQ0xkiBEUNAANAIAEgAhAlRQRAIAQoAggiBEUNAgNAIAQoAggiBA0ACwwCCyAEQRBqIANBCGoQWhDSGSAEEJYOIQUgACAEENEZIANBCGoQngIaIAMoAgghASAFIgQNAAsLIAEgAhAlBEADQCAAIANBCGoQWhDPGSADQQhqEJ4CGiADKAIIIAIQJQ0ACwsgA0EQaiQACy0BAn8Q8QEiAxCZDiECIAAgAzYCpAEgASACRwRAIAIgARCNBCABEIkBENQZCwvFAgICfwF+IwBBEGsiAiQAAkACQCAAIAAoAgAoAoABEQQAQQhGDQAgACAAKAIAKAKAAREEAEEJRg0AIAAgACgCACgCgAERBABBAUYNACAAIAAoAgAoAoABEQQAQQNHDQELIAIgACgCdCIBIAEoAgAoAoQBEQQALQAHQQdxNgIMIAIgACgCcCIBIAEoAgAoAoQBEQQALQAHQQdxNgIIIAJBDGogAkEIahCfATUCACEDIAAgACgCACgChAERBAAiASABKQIEQv///0eDIANCGIZCgICAOIOENwIEIAAgACgCACgChAERBAAtAAdBB3FFDQAgACgCcCIBIAAgACgCACgChAERBAAtAAdBB3EgASgCACgCjAERAgAgACgCdCIBIAAgACgCACgChAERBAAtAAdBB3EgASgCACgCjAERAgALIAJBEGokAAvHAQIBfwF+AkACQCAAIAAoAgAoAoABEQQAQQhGDQAgACAAKAIAKAKAAREEAEEJRg0AIAAgACgCACgCgAERBABBAUYNACAAIAAoAgAoAoABEQQAQQNHDQELIAAoAnAiASABKAIAKAKEAREEAC0AB0EHcSAAIAAoAgAoAoQBEQQALQAHQQdxTQ0AIAAoAnAiASABKAIAKAKEAREEACkCBCECIAAgACgCACgChAERBAAiACAAKQIEQv///0eDIAJCgICAOIOENwIECwurAQEEfyMAQSBrIgIkACACQRhqIAAQgRotAAAEQCACQQA2AhQgAkEQaiAAIAAoAgBBdGooAgBqEGEgAkEQakHQ0hEQrAMhAyACQQhqIAAQgQYhBCACEIAGIQUgAyAEKAIAIAUoAgAgACAAKAIAQXRqKAIAaiACQRRqIAEgAygCACgCLBEGABogAkEQahBbIAAgACgCAEF0aigCAGogAigCFBD8AwsgAkEgaiQAC4YBAQN/IwBBEGsiAiQAIAIgABAnEJ0OIAIoAgBBCGoiAyABELgDIANBEGogAUEQahC4AyADIAEpAiA3AiAgAigCACIBIgMgADYCACABIAAoAgQiBDYCBCAEIAE2AgAgACADNgIEIAAQJyIAIAAoAgBBAWo2AgAgAhDAASACEJwOIAJBEGokAAtfAQF/IwBBEGsiBCQAIAJFBEAgASADIARBkIAKECoQoA4gASADIARBnIAKECoQoA4LIAEoAgAiAkECIAIoAgAoArgBEQIAIAAgACgCQCABKAIAELsDNgJAIARBEGokAAtqAQJ/IwBBIGsiAyQAAkAgABAnKAIAIAAoAgRrQQJ1IAFPBEAgACABEKYODAELIAAQtgEhAiADQQhqIAAgABAfIAFqEPIBIAAQHyACEM0EIgIgARClDiAAIAIQpA4gAhDUAQsgA0EgaiQAC2oBAn8jAEEgayIDJAACQCAAECcoAgAgACgCBGtBAnUgAU8EQCAAIAEQpg4MAQsgABC2ASECIANBCGogACAAEB8gAWoQ8gEgABAfIAIQzQQiAiABEKUOIAAgAhCICSACENQBCyADQSBqJAALMwEBfyAAEB8iAiABSQRAIAAgASACaxDbGQ8LIAIgAUsEQCAAIAAoAgAgAUECdGoQowILC+MCAQR/IAIgAigCACgCvAERBAAhASACIAIoAgAoAtQBEQQAIQQCQCABEB9FBEBBACEADAELQQAhAEEAIQIDQAJAAkAgASgCACACEBooAgAiAyADKAIAKAIwEQQAIgNFDQAgAyADKAIAKAKAAREEAEEORw0AIAMgAygCACgCeBEEACIDIAMoAgAoAiARBAAQzwQNAQsCQCABKAIAIAIQGigCACIFIAUoAgAoAhgRBAAiA0UNACADKAJoQbEERw0AIAMgAygCACgCvAERBAAiBigCACAGKAIEEFgNACADIAMoAgAoArwBEQQAKAIAQQAQGigCACEFCyABKAIAIAAQGiAFNgIAIAQoAgAiAyAEKAIEEFhFBEAgAyACEBohBSADIAAQGiAFKAIANgIACyAAQQFqIQALIAJBAWoiAiABEB9JDQALCyABIAAQhAkgBCgCACAEKAIEEFhFBEAgBCAAEN0ZC0EBC1cAAkAgASABKAIAKAKAAREEAEEORw0AIAEgASgCACgCeBEEACIAIAAoAgAoAiARBAAQjwdFDQAgASABKAIAKAJ8EQQAIgAgACgCACgCJBEEAEEBEKcOCws+AQJ/IwBBIGsiASQAIAACfyABQQAQ3gIgAUG0wgk2AgAgASICCyAAKAIAKAIIEQIAIAIQtQIaIAFBIGokAAuwAwEHfyMAQYACayIBJAAgAUGwAWogABDkEyABQbABahCNASEDIAFBsAFqEJwGIQAgAUGwAWoQsQshAiABQYgBaiIFQQAQ3gIgBUEANgIkIAUgAzYCICAFQdivETYCACABQUBrIAAgAxDjEyEDIAIQvwZFBEADQCABIAIQhwgQJygCACIENgIAIANBOGpB3L8REGcgBCgCGCIEIAMgBCgCACgCCBECACACIAEQhgggAhC/BkUNAAsLIAFBsAFqIQYgABC/BkUEQCABQRhqQQRyIQQDQCABQSBqIAFBMGogABCHCBAnEPQBIgIQvgYgAUEYaiAGIAFBIGoQ4hMgASABKAIYNgIQIAFBEGogBBCMAQRAA0AgASAFIAFBEGoQtwMoAgwiByACEOETIAEtAAAEQCADIAcgARA4EOATCyABQQRqELMEIAFBEGoQrwsaIAFBEGogBBCMAQ0ACwsgACACENwTIAFBIGoQKBogAhAoGiAAEL8GRQ0ACwsgAxCFCBogBRC1AhogAUGwAWoiAEE8ahDhBiAAQShqEIIIIABBFGoQrgsgABCJBSABQYACaiQAC00BAX8CQCABRQ0AAkAgASABKAIAKAIYEQQAIgJFDQAgAigCaA0AIAJBASACKAIAKAK4ARECAAsgABDhGSAAKALUBUEBRw0AIAEQ4BkLC04AIAAQ/gUgAEIANwI0IABC/////x83AiwgAEIANwIkIABBADsAISAAIAQ6ACAgACADNgIcIAAgAjYCGCAAIAE2AhQgAEHgswk2AgAgAAuQAgEEfwJAIAAgACgCACgCUBEEACICRQ0AIAAhBANAQQAhACACKAJoIgNBz35qIgVBBE9BACADQegFRxsNAQJAIAENACADQbQBRiADQegFRnINAiAFQQFLDQAgAiACKAIAKALAAREEACIDIAMoAgAoAngRBAAiAyADKAIAKAJoEQQARQRAIAIgAigCACgCwAERBAAiAyADKAIAKAJ4EQQAIgMgAygCACgCYBEEAEUNAQsgAiACKAIAKALAAREEACICIAIoAgAoAngRBAAiAiACKAIAKAJwEQQARQ0CCyAEIAQoAgAoAlARBAAiACAAKAIAKALAAREEACIEIAQoAgAoAlARBAAiAg0ACyAEIQALIAALLAEBfyMAQRBrIgMkACADIAEgAkEAEKEFNgIMIAAgA0EMahDOBCADQRBqJAALTwECfyMAQeAAayICJAAgAkHYAGpBARCIAiIDQQAQFyAA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IABBQGsoAgAgAUFAaygCAEYNAgtBACEDIAAgACgCACgCiAERBABFDQAgASABKAIAKAKIAREEAEUNACAAQUBrKAIAEEIgAUFAaygCABBCRw0AIAAoAkggASgCSBCKCQ0AIABBQGsiBCgCACICEEJFDQFBACEAIAFBQGshAQNAQQAhAyACKAIAIAAQRCgCACICIAIoAgAoAhgRBAAgASgCACgCACAAEEQoAgAiAiACKAIAKAIYEQQAEIoJDQEgBCgCACgCACAAEEQoAgAgASgCACgCACAAEEQoAgAQyAENAUEBIQMgAEEBaiIAIAQoAgAiAhBCSQ0ACwsgAw8LQQELYgEBfwJAIAAgACgCACgCMBEEAEUNACABIAEoAgAoAjARBABFDQAgACAAKAIAKAIwEQQAIgAgACgCACgCuAERBAAgASABKAIAKAIwEQQAIgAgACgCACgCuAERBABGIQILIAILKwEBfyAAIAJGBH8CQCABBH8gAw0BQQAFIAMLIAFGDwsgASADEPIZBSAECwt+AQJ/IwBBEGsiAyQAIAMgAjYCACADIAA2AghBASEEAkAgACABECVFDQADQCAAKAIAIAAoAgQgAigCACACKAIEEPMZRQRAQQAhBAwCCyADQQhqEJAEIAMQkAQgAygCCCIAIAEQJUUNASADKAIAIQIMAAALAAsgA0EQaiQAIAQLKwAgABCfAiABEJ8CRgR/IAAoAgAQJCAAKAIEECQgASgCABAkEPQZBUEACwuWGgEHfyMAQeAAayIGJAAgACgCaCEFIAAgACgCACgCwAERBAAhASAAIAAoAgAoAsQBEQQAIQICQAJAAkAgASABKAIAKAKgAREEAA0AIAIgAigCACgCoAERBAANACABIAEoAgAoAoABEQQAQQ9GDQAgAiACKAIAKAKAAREEAEEPRw0BCyABIAEoAgAoAngRBAAgAiACKAIAKAJ4EQQAEMgBDQELIAAgASABKAIAKAJ4EQQAIAAoAgAoAnQRAgAgACAAKAIAKAJ8EQQAIgMgAygCACgCKBEEABD9AgJAAkAgASABKAIAKAKgAREEAA0AIAEgASgCACgCgAERBABBD0YNACABIAEoAgAoAoABEQQAQQ5HDQELIAVB335qQQJPBEBBASEDIAVBtgRGDQJBACEDDAILQQAhAyABIAEoAgAoAoABEQQAQQ5GDQFBASEDIAAgBkEIakEMQQBBAUEAQQBBABBIIgEgACgCACgCdBECACABED0aDAELAkACQAJAAkACQAJAIAVB6X5qIgNBGUsEQCAFQcl7aiIDQQ1LDQZBASADdCIDQYD+AHENASADQYcBcUUNBgwFCyADQQRrDhYAAAAAAAACAgUFAwMDAwUFBQUFAQEBBAsgASABKAIAKAKAAREEABChAkUEQEEAIQMgAiACKAIAKAKAAREEABChAkUNBgtBACEDIAEgASgCACgCnAERBAANBSACIAIoAgAoApwBEQQADQUMBAtBACEDIAEgASgCACgCgAERBABBDEcNBCABIAEoAgAoApwBEQQADQQgASABKAIAKAKkAREEAA0EIAAgBkEIakEMQQAgASABKAIAKAKQAREEAEEAQQBBABBIIgMgACgCACgCdBECACADED0aDAMLIAAgBkEIakEMQQBBAUEAQQBBABBIIgMgACgCACgCdBECACADED0aDAILQQAhAyABIAEoAgAoAoABEQQAQQxGDQIgACAGQQhqQQxBACABIAEoAgAoApABEQQAQQBBAEEAEEgiAyAAKAIAKAJ0EQIAIAMQPRoMAQtBACEDIAEgASgCACgCgAERBABBDEYNASACIAIoAgAoAoABEQQAQQxGDQELAkACQAJAAkAgBUHpfmoiA0EZSw0AQQEgA3QiBEGA+I8ccUUEQCAEQZsHcQ0CIANBAkcNAQwDCyABIAEoAgAoAngRBAAgAiACKAIAKAJ4EQQAELYCIQMMBAsgBUHJe2oiA0ELSw0CQQEgA3RBgx9xDQAgA0ECRg0BDAILQQEhAyABIAEoAgAoAngRBAAgAiACKAIAKAJ4EQQAELYCDQILQQAhAyABIAEoAgAoAoABEQQAIAIgAigCACgCgAERBABHDQELAkACQAJAAkACQAJAAkACQAJAAkACQCABIAEoAgAoAngRBAAQggFFBEAgAiACKAIAKAJ4EQQAEIIBRQ0BCwJAIAEgASgCACgCeBEEABCCAUUNACACIAIoAgAoAngRBAAQggFFDQBBACEDIAEgASgCACgCeBEEACIEIAQoAgAoAlgRBAAgAiACKAIAKAJ4EQQAIgQgBCgCACgCWBEEABC2Dg0MC0EAIQMgBUHpfmoiBEEDTQ0BIAVByntqIgRBA0sNCyAEQQFrDgMLCwoJCyABIAEoAgAoAqgBEQQABEBBASEDIAIgAigCACgCqAERBAANCwsCQCABIAEoAgAoAqQBEQQARQ0AIAIgAigCACgCpAERBABFDQAgASABKAIAKAKQAREEACACIAIoAgAoApABEQQARg0AQQAhAyACIAIoAgAoApABEQQAQQFKDQsLIAEgASgCACgCgAERBAAhBEEAIQMgBUHKe2oiB0EOTQ0BIAVB6X5qIgdBCUsNCkEBIAd0IgdBmwdxDQIgB0HgAHENAwJAIAEgASgCACgCnAERBAANACACIAIoAgAoApwBEQQARQ0AIAEgASgCACgCpAERBAAEQCABIAEoAgAoApABEQQAIAIgAigCACgCmAERBABHDQwgAEGrARCiAiAAIAZBCGogBEEAIAIgAigCACgClAERBABBAEEAQQAQSCIBIAAoAgAoAnQRAgAgARA9GgwJCyAAQa0BEKICIAAgBkEIaiAEQQBBACACIAIoAgAoApQBEQQAIAIgAigCACgCmAERBABBABBIIgEgACgCACgCdBECACABED0aDAgLAkAgASABKAIAKAKcAREEAEUNACACIAIoAgAoApwBEQQADQAgAiACKAIAKAKkAREEAARAIAEgASgCACgClAERBAAgAiACKAIAKAKQAREEAEcNDCAAQawBEKICIAAgBkEIaiAEQQAgASABKAIAKAKYAREEAEEAQQBBABBIIgEgACgCACgCdBECACABED0aDAkLIABBrQEQogIMCAsCQCABIAEoAgAoApwBEQQARQ0AIAIgAigCACgCnAERBABFDQAgASABKAIAKAKUAREEACACIAIoAgAoApgBEQQARw0LIABBpAIQogIgACAGQQhqIARBAEEAIAIgAigCACgClAERBAAgASABKAIAKAKYAREEAEEAEEgiASAAKAIAKAJ0EQIAIAEQPRoMCAsgASABKAIAKAKcAREEAA0KIAIgAigCACgCnAERBAANCiABIAEoAgAoAqQBEQQABEAgAiACKAIAKAKkAREEAA0ICyABIAEoAgAoAqQBEQQARQRAIAIgAigCACgCpAERBABFDQgLIABBqgEQogIgAiACKAIAKAKkAREEAEUNByAAIAZBCGogBEEAIAIgAigCACgCkAERBABBAEEAQQAQSCIBIAAoAgAoAnQRAgAgARA9GgwHCyAEQQJrDQcMCAsCQCAHQQFrDg4BAQQJCQkJAQEBAQECAgALIAEgASgCACgCkAERBAAgAiACKAIAKAKQAREEAEcNCCABIAEoAgAoApQBEQQAIAIgAigCACgClAERBABHDQggASABKAIAKAKYAREEACACIAIoAgAoApgBEQQARw0ICyABIAEoAgAoApwBEQQABEAgAiACKAIAKAKkAREEAA0ICyABIAEoAgAoAqQBEQQABEAgAiACKAIAKAKcAREEAA0ICyABIAEoAgAoAoABEQQAIAIgAigCACgCgAERBABHDQcCQCABIAEoAgAoApwBEQQARQ0AIAIgAigCACgCnAERBABFDQAgASABKAIAKAKUAREEACACIAIoAgAoApQBEQQARw0IIAEgASgCACgCmAERBAAgAiACKAIAKAKYAREEAEcNCAsCQCABIAEoAgAoAqQBEQQARQ0AIAIgAigCACgCpAERBABFDQAgASABKAIAKAKQAREEACACIAIoAgAoApABEQQARw0ICyACIAIoAgAoAqQBEQQARQRAIAIgAigCACgCnAERBABFDQILIAAgACgCACgCfBEEACACIAIoAgAoAngRBAAQlQEgACAAKAIAKAJ8EQQAIgIgAigCACgCKBEEABDLAgwBCyACIAIoAgAoAqQBEQQARQ0AIAEgASgCACgCpAERBABFDQYgAiACKAIAKAKQAREEACABIAEoAgAoApABEQQARw0GCyAFQcp7aiICQQ5LQQEgAnRBj/4BcUVyDQIMAQsCQCABIAEoAgAoApwBEQQADQAgAiACKAIAKAKcAREEAEUNACABIAEoAgAoAqQBEQQARQ0FIAEgASgCACgCkAERBAAgAiACKAIAKAKYAREEAEcNBSABIAEoAgAoApABEQQAIAIgAigCACgClAERBABHDQUgAEG6BBCiAgwCCwJAIAEgASgCACgCnAERBABFDQAgAiACKAIAKAKcAREEAA0AIAIgAigCACgCpAERBAANBSAAQbwEEKICDAILAkAgASABKAIAKAKcAREEAEUNACACIAIoAgAoApwBEQQARQ0AIAEgASgCACgClAERBAAgAiACKAIAKAKUAREEAEcNBSABIAEoAgAoApQBEQQAIAIgAigCACgCmAERBABHDQUgAEG9BBCiAgwCCyABIAEoAgAoApwBEQQADQQgAiACKAIAKAKcAREEAA0EIAEgASgCACgCpAERBAAEQCACIAIoAgAoAqQBEQQADQELIAEgASgCACgCpAERBABFBEAgAiACKAIAKAKkAREEAEUNAQsgASABKAIAKAKkAREEAEUNBCAAQbsEEKICDAELIAAgACgCACgCeBEEACABIAEoAgAoAngRBAAQyAENAwtBASEDDAILIAEgASgCACgCeBEEABCCAUUNASACIAIoAgAoAngRBAAQggEhACAGQeAAaiQAIAAPCyABIAEoAgAoAngRBAAQggEEQCACIAIoAgAoAngRBAAQggENAQsgBUG5BEYEQCACIAIoAgAoAngRBAAQggENAQsgAEG8BEGtASAFQbkERhsQogJBASEDIAIgAigCACgCeBEEABCCAUUNACAAIAIgAigCACgCeBEEACAAKAIAKAJ0EQIACyAGQeAAaiQAIAML6AIBA38jAEHgAGsiBCQAIAEoAmghAyABIAEoAgAoArwBEQQAIQICQAJAAkAgA0F6aiIDQQdLDQACQAJAAkAgA0EBaw4DAAMBAgsgAiACKAIAKAKAAREEAEEMRg0DQQAhAyAAQQcgBEEIakEMQQBBAUEAQQBBABBIIgAgAhDQBCECIAAQPRogAkUNBCABIAIgASgCACgCuAERAgAMAwtBACEDIAIgAigCACgCgAERBAAQoQINAgwDCyACIAIoAgAoAoABEQQAEKECDQEgAiACKAIAKAKAAREEAEEBRg0BIAIgAigCACgCgAERBABBA0YNAUEAIQMgAiACKAIAKAKAAREEAEECRg0BDAILQQAhAyACIAIoAgAoAoABEQQAQQFHDQELIAEgAiACKAIAKAJ4EQQAIAEoAgAoAnQRAgAgASABKAIAKAJ8EQQAIgAgACgCACgCKBEEABDLAkEBIQMLIARB4ABqJAAgAwv0AwEBfyMAQRBrIgQkACAEQRQ2AgwgBEEUNgIIAkAgASgCKBA+DQAgASgCLEHuAEYNAAJAAkAgAkECRgRAIAEgA0ECEPkCDQELIANBAkcNASABIAJBAhD5AkUNAQsgBEECNgIIIARBAjYCDAwBCwJAAkAgAkEBRgRAIAEgA0EBEPkCDQELIANBAUcNASABIAJBARD5AkUNAQsgBEEBNgIIIARBATYCDAwBCwJAAkAgAkEDRgRAIAEgA0EDEPkCDQELIANBA0cNASABIAJBAxD5AkUNAQsgBEED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KAIEEJwJCyACQRBqJAALCgAgAEEUahC/DgugAgEEfyMAQSBrIgMkACAAQQA6AAAgASABKAIAQXRqKAIAahCUByEEIAEgASgCAEF0aigCAGohAgJAIAQEQCACKAJIBEAgASABKAIAQXRqKAIAaigCSBC7DgsCQCABIAEoAgBBdGooAgBqKAIEQYAgcUUNACADQRhqIAEgASgCAEF0aigCAGoQYSADQRhqEIUCIQUgA0EYahBbIANBEGogARCBBiECIANBCGoQgAYhBANAAkAgAiAEEP0BRQ0AIAVBgMAAIAIQpQEQ3wJFDQAgAhC+ARoMAQsLIAIgBBDHAUUNACABIAEoAgBBdGooAgBqQQYQ/AMLIAAgASABKAIAQXRqKAIAahCUBzoAAAwBCyACQQQQ/AMLIANBIGokACAACwoAIABBFGoQwA4LCgAgAEEUahDBDgsKACAAQRRqEMIOCwoAIABBFGoQww4LCgAgAEEUahCCBgsTACAAIAAoAgBBdGooAgBqEKMJCyoBAX8jAEEQayIBJAAgASAANgIMQagMKAIAQfygDyAAEJsMIAFBEGokAAsQABCIGEHQ4hFBrgIRBAAaCwudkBG6AgBBgAgLFLhiBAAtKyAgIDBYMHgAKG51bGwpAEGgCAsYEQAKABEREQAAAAAFAAAAAAAACQAAAAALAEHACAshEQAPChEREQMKBwABEwkLCwAACQYLAAALAAYRAAAAERERAEHxCAsBCwBB+ggLGBEACgoREREACgAAAgAJCwAAAAkACwAACwBBqwkLAQwAQbcJCxUMAAAAAAwAAAAACQwAAAAAAAwAAAwAQeUJCwEOAEHxCQsVDQAAAAQNAAAAAAkOAAAAAAAOAAAOAEGfCgsBEABBqwoLHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB4goLDhIAAAASEhIAAAAAAAAJAEGTCwsBCwBBnwsLFQoAAAAACgAAAAAJCwAAAAAACwAACwBBzQsLAQwAQdkLC1IMAAAAAAwAAAAACQwAAAAAAAwAAAwAADAxMjM0NTY3ODlBQkNERUYtMFgrMFggMFgtMHgrMHggMHgAaW5mAElORgBuYW4ATkFOAC4AAAAASGMEAEHUDAsBCABB+wwLBf//////AEHADQvnF/////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAAAAAAAAAAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8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AAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAACAAAAAAAAABwFgAAFwAAABgAAAD4////+P///3AWAAAZAAAAGgAAADwVAABQFQAABAAAAAAAAAC4FgAAGwAAABwAAAD8/////P///7gWAAAdAAAAHgAAAGwVAACAFQAAAAAAALQVAAAfAAAAIAAAAE5TdDNfXzI4aW9zX2Jhc2VFAAAALEIAAKAVAAAAAAAA+BUAACEAAAAiAAAATlN0M19fMjliYXNpY19pb3NJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAABUQgAAzBUAALQVAABOU3QzX18yMTViYXNpY19zdHJlYW1idWZJY05TXzExY2hhcl90cmFpdHNJY0VFRUUAAAAALEIAAAQWAABOU3QzX18yMTNiYXNpY19pc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAACwQgAAQBYAAAAAAAABAAAA+BUAAAP0//9OU3QzX18yMTNiYXNpY19vc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAACwQgAAiBYAAAAAAAABAAAA+BUAAAP0//8CAADAAwAAwAQAAMAFAADABgAAwAcAAMAIAADACQAAwAoAAMALAADADAAAwA0AAMAOAADADwAAwBAAAMARAADAEgAAwBMAAMAUAADAFQAAwBYAAMAXAADAGAAAwBkAAMAaAADAGwAAwBwAAMAdAADAHgAAwB8AAMAAAACzAQAAwwIAAMMDAADDBAAAwwUAAMMGAADDBwAAwwgAAMMJAADDCgAAwwsAAMMMAADDDQAA0w4AAMMPAADDAAAMuwEADMMCAAzDAwAMwwQADNNpbmZpbml0eQBuYW4AQbAvC0jRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AQYAwCyPeEgSVAAAAAP///////////////wAYAAAUAAAAQy5VVEYtOABByDALAhQYAEHgMAsGTENfQUxMAEHwMAtuTENfQ1RZUEUAAAAATENfTlVNRVJJQwAATENfVElNRQAAAAAATENfQ09MTEFURQAATENfTU9ORVRBUlkATENfTUVTU0FHRVMATEFORwBDLlVURi04AFBPU0lYAE1VU0xfTE9DUEFUSAAAAAAA4BkAQeAzC/8BAgACAAIAAgACAAIAAgACAAIAAyACIAIgAiACIAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAFgBMAEwATABMAEwATABMAEwATABMAEwATABMAEwATACNgI2AjYCNgI2AjYCNgI2AjYCNgEwATABMAEwATABMAEwAjVCNUI1QjVCNUI1QjFCMUIxQjFCMUIxQjFCMUIxQjFCMUIxQjFCMUIxQjFCMUIxQjFCMUEwATABMAEwATABMAI1gjWCNYI1gjWCNYIxgjGCMYIxgjGCMYIxgjGCMYIxgjGCMYIxgjGCMYIxgjGCMYIxgjGBMAEwATABMACAEHgNwsC8B0AQfQ7C/kDAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAAKAAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAFAAAABRAAAAUgAAAFMAAABUAAAAVQAAAFYAAABXAAAAWAAAAFkAAABaAAAAWwAAAFwAAABdAAAAXgAAAF8AAABgAAAAQQAAAEIAAABDAAAARAAAAEUAAABGAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAATQAAAE4AAABPAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAAB7AAAAfAAAAH0AAAB+AAAAfwBB8cMACwEkAEGEyAAL+QMBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAYQAAAGIAAABjAAAAZAAAAGUAAABmAAAAZwAAAGgAAABpAAAAagAAAGsAAABsAAAAbQAAAG4AAABvAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAHoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABhAAAAYgAAAGMAAABkAAAAZQAAAGYAAABnAAAAaAAAAGkAAABqAAAAawAAAGwAAABtAAAAbgAAAG8AAABwAAAAcQAAAHIAAABzAAAAdAAAAHUAAAB2AAAAdwAAAHgAAAB5AAAAegAAAHsAAAB8AAAAfQAAAH4AAAB/AEGA0AALSDAxMjM0NTY3ODlhYmNkZWZBQkNERUZ4WCstcFBpSW5OACVwAGwAbGwAAEwAJQAAAAAAJXAAAAAAJUk6JU06JVMgJXAlSDolTQBB0NAAC4EBJQAAAG0AAAAvAAAAJQAAAGQAAAAvAAAAJQAAAHkAAAAlAAAAWQAAAC0AAAAlAAAAbQAAAC0AAAAlAAAAZAAAACUAAABJAAAAOgAAACUAAABNAAAAOgAAACUAAABTAAAAIAAAACUAAABwAAAAAAAAACUAAABIAAAAOgAAACUAAABNAEHg0QALvQQlAAAASAAAADoAAAAlAAAATQAAADoAAAAlAAAAUwAAACVMZgAwMTIzNDU2Nzg5ACUuMExmAEMAAAAAAACILgAANgAAADcAAAA4AAAAAAAAAOguAAA5AAAAOgAAADgAAAA7AAAAPAAAAD0AAAA+AAAAPwAAAEAAAABBAAAAQgAAAAAAAABQLgAAQwAAAEQAAAA4AAAARQAAAEYAAABHAAAASAAAAEkAAABKAAAASwAAAAAAAAAgLwAATAAAAE0AAAA4AAAATgAAAE8AAABQAAAAUQAAAFIAAAAAAAAARC8AAFMAAABUAAAAOAAAAFUAAABWAAAAVwAAAFgAAABZAAAAdHJ1ZQAAAAB0AAAAcgAAAHUAAABlAAAAAAAAAGZhbHNlAAAAZgAAAGEAAABsAAAAcwAAAGUAAAAAAAAAJW0vJWQvJXkAAAAAJQAAAG0AAAAvAAAAJQAAAGQAAAAvAAAAJQAAAHkAAAAAAAAAJUg6JU06JVMAAAAAJQAAAEgAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAAAAAAJWEgJWIgJWQgJUg6JU06JVMgJVkAAAAAJQAAAGEAAAAgAAAAJQAAAGIAAAAgAAAAJQAAAGQAAAAgAAAAJQAAAEgAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAgAAAAJQAAAFkAAAAAAAAAJUk6JU06JVMgJXAAJQAAAEkAAAA6AAAAJQAAAE0AAAA6AAAAJQAAAFMAAAAgAAAAJQAAAHAAQajWAAvWClArAABaAAAAWwAAADgAAABOU3QzX18yNmxvY2FsZTVmYWNldEUAAABUQgAAOCsAAHxAAAAAAAAA0CsAAFoAAABcAAAAOAAAAF0AAABeAAAAXwAAAGAAAABhAAAAYgAAAGMAAABkAAAAZQAAAGYAAABnAAAAaAAAAE5TdDNfXzI1Y3R5cGVJd0VFAE5TdDNfXzIxMGN0eXBlX2Jhc2VFAAAsQgAAsisAALBCAACgKwAAAAAAAAIAAABQKwAAAgAAAMgrAAACAAAAAAAAAGQsAABaAAAAaQAAADgAAABqAAAAawAAAGwAAABtAAAAbgAAAG8AAABwAAAATlN0M19fMjdjb2RlY3Z0SWNjMTFfX21ic3RhdGVfdEVFAE5TdDNfXzIxMmNvZGVjdnRfYmFzZUUAAAAALEIAAEIsAACwQgAAICwAAAAAAAACAAAAUCsAAAIAAABcLAAAAgAAAAAAAADYLAAAWgAAAHEAAAA4AAAAcgAAAHMAAAB0AAAAdQAAAHYAAAB3AAAAeAAAAE5TdDNfXzI3Y29kZWN2dElEc2MxMV9fbWJzdGF0ZV90RUUAALBCAAC0LAAAAAAAAAIAAABQKwAAAgAAAFwsAAACAAAAAAAAAEwtAABaAAAAeQAAADgAAAB6AAAAewAAAHwAAAB9AAAAfgAAAH8AAACAAAAATlN0M19fMjdjb2RlY3Z0SURpYzExX19tYnN0YXRlX3RFRQAAsEIAACgtAAAAAAAAAgAAAFArAAACAAAAXCwAAAIAAAAAAAAAwC0AAFoAAACBAAAAOAAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAfwAAAIAAAABOU3QzX18yMTZfX25hcnJvd190b191dGY4SUxtMzJFRUUAAABUQgAAnC0AAEwtAAAAAAAAIC4AAFoAAACCAAAAOAAAAHoAAAB7AAAAfAAAAH0AAAB+AAAAfwAAAIAAAABOU3QzX18yMTdfX3dpZGVuX2Zyb21fdXRmOElMbTMyRUVFAABUQgAA/C0AAEwtAABOU3QzX18yN2NvZGVjdnRJd2MxMV9fbWJzdGF0ZV90RUUAAACwQgAALC4AAAAAAAACAAAAUCsAAAIAAABcLAAAAgAAAE5TdDNfXzI2bG9jYWxlNV9faW1wRQAAAFRCAABwLgAAUCsAAE5TdDNfXzI3Y29sbGF0ZUljRUUAVEIAAJQuAABQKwAATlN0M19fMjdjb2xsYXRlSXdFRQBUQgAAtC4AAFArAABOU3QzX18yNWN0eXBlSWNFRQAAALBCAADULgAAAAAAAAIAAABQKwAAAgAAAMgrAAACAAAATlN0M19fMjhudW1wdW5jdEljRUUAAAAAVEIAAAgvAABQKwAATlN0M19fMjhudW1wdW5jdEl3RUUAAAAAVEIAACwvAABQKwAAAAAAAKguAACDAAAAhAAAADgAAACFAAAAhgAAAIcAAAAAAAAAyC4AAIgAAACJAAAAOAAAAIoAAACLAAAAjAAAAAAAAABkMAAAWgAAAI0AAAA4AAAAjgAAAI8AAACQAAAAkQAAAJIAAACTAAAAlAAAAJUAAACWAAAAlwAAAJgAAABOU3QzX18yN251bV9nZXRJY05TXzE5aXN0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzI5X19udW1fZ2V0SWNFRQBOU3QzX18yMTRfX251bV9nZXRfYmFzZUUAACxCAAAqMAAAsEIAABQwAAAAAAAAAQAAAEQwAAAAAAAAsEIAANAvAAAAAAAAAgAAAFArAAACAAAATDAAQYjhAAvKATgxAABaAAAAmQAAADgAAACaAAAAmwAAAJwAAACdAAAAngAAAJ8AAACgAAAAoQAAAKIAAACjAAAApAAAAE5TdDNfXzI3bnVtX2dldEl3TlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjlfX251bV9nZXRJd0VFAAAAsEIAAAgxAAAAAAAAAQAAAEQwAAAAAAAAsEIAAMQwAAAAAAAAAgAAAFArAAACAAAAIDEAQdziAAveASAyAABaAAAApQAAADgAAACmAAAApwAAAKgAAACpAAAAqgAAAKsAAACsAAAArQAAAE5TdDNfXzI3bnVtX3B1dEljTlNfMTlvc3RyZWFtYnVmX2l0ZXJhdG9ySWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFRUUATlN0M19fMjlfX251bV9wdXRJY0VFAE5TdDNfXzIxNF9fbnVtX3B1dF9iYXNlRQAALEIAAOYxAACwQgAA0DEAAAAAAAABAAAAADIAAAAAAACwQgAAjDEAAAAAAAACAAAAUCsAAAIAAAAIMgBBxOQAC74B6DIAAFoAAACuAAAAOAAAAK8AAACwAAAAsQAAALIAAACzAAAAtAAAALUAAAC2AAAATlN0M19fMjdudW1fcHV0SXdOU18xOW9zdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yOV9fbnVtX3B1dEl3RUUAAACwQgAAuDIAAAAAAAABAAAAADIAAAAAAACwQgAAdDIAAAAAAAACAAAAUCsAAAIAAADQMgBBjOYAC50H6DMAALcAAAC4AAAAOAAAALkAAAC6AAAAuwAAALwAAAC9AAAAvgAAAL8AAAD4////6DMAAMAAAADBAAAAwgAAAMMAAADEAAAAxQAAAMYAAABOU3QzX18yOHRpbWVfZ2V0SWNOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJY05TXzExY2hhcl90cmFpdHNJY0VFRUVFRQBOU3QzX18yOXRpbWVfYmFzZUUALEIAAKEzAABOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUljRUUAAAAsQgAAvDMAALBCAABcMwAAAAAAAAMAAABQKwAAAgAAALQzAAACAAAA4DMAAAAIAAAAAAAA1DQAAMcAAADIAAAAOAAAAMkAAADKAAAAywAAAMwAAADNAAAAzgAAAM8AAAD4////1DQAANAAAADRAAAA0gAAANMAAADUAAAA1QAAANYAAABOU3QzX18yOHRpbWVfZ2V0SXdOU18xOWlzdHJlYW1idWZfaXRlcmF0b3JJd05TXzExY2hhcl90cmFpdHNJd0VFRUVFRQBOU3QzX18yMjBfX3RpbWVfZ2V0X2Nfc3RvcmFnZUl3RUUAACxCAACpNAAAsEIAAGQ0AAAAAAAAAwAAAFArAAACAAAAtDMAAAIAAADMNAAAAAgAAAAAAAB4NQAA1wAAANgAAAA4AAAA2QAAAE5TdDNfXzI4dGltZV9wdXRJY05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRUVFAE5TdDNfXzIxMF9fdGltZV9wdXRFAAAALEIAAFk1AACwQgAAFDUAAAAAAAACAAAAUCsAAAIAAABwNQAAAAgAAAAAAAD4NQAA2gAAANsAAAA4AAAA3AAAAE5TdDNfXzI4dGltZV9wdXRJd05TXzE5b3N0cmVhbWJ1Zl9pdGVyYXRvckl3TlNfMTFjaGFyX3RyYWl0c0l3RUVFRUVFAAAAALBCAACwNQAAAAAAAAIAAABQKwAAAgAAAHA1AAAACAAAAAAAAIw2AABaAAAA3QAAADgAAADeAAAA3wAAAOAAAADhAAAA4gAAAOMAAADkAAAA5QAAAOYAAABOU3QzX18yMTBtb25leXB1bmN0SWNMYjBFRUUATlN0M19fMjEwbW9uZXlfYmFzZUUAAAAALEIAAGw2AACwQgAAUDYAAAAAAAACAAAAUCsAAAIAAACENgAAAgBBse0AC/UDNwAAWgAAAOcAAAA4AAAA6AAAAOkAAADqAAAA6wAAAOwAAADtAAAA7gAAAO8AAADwAAAATlN0M19fMjEwbW9uZXlwdW5jdEljTGIxRUVFALBCAADkNgAAAAAAAAIAAABQKwAAAgAAAIQ2AAACAAAAAAAAAHQ3AABaAAAA8QAAADgAAADyAAAA8wAAAPQAAAD1AAAA9gAAAPcAAAD4AAAA+QAAAPoAAABOU3QzX18yMTBtb25leXB1bmN0SXdMYjBFRUUAsEIAAFg3AAAAAAAAAgAAAFArAAACAAAAhDYAAAIAAAAAAAAA6DcAAFoAAAD7AAAAOAAAAPwAAAD9AAAA/gAAAP8AAAAAAQAAAQEAAAIBAAADAQAABAEAAE5TdDNfXzIxMG1vbmV5cHVuY3RJd0xiMUVFRQCwQgAAzDcAAAAAAAACAAAAUCsAAAIAAACENgAAAgAAAAAAAACMOAAAWgAAAAUBAAA4AAAABgEAAAcBAABOU3QzX18yOW1vbmV5X2dldEljTlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFRUUATlN0M19fMjExX19tb25leV9nZXRJY0VFAAAsQgAAajgAALBCAAAkOAAAAAAAAAIAAABQKwAAAgAAAIQ4AEGw8QALmgEwOQAAWgAAAAgBAAA4AAAACQEAAAoBAABOU3QzX18yOW1vbmV5X2dldEl3TlNfMTlpc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjExX19tb25leV9nZXRJd0VFAAAsQgAADjkAALBCAADIOAAAAAAAAAIAAABQKwAAAgAAACg5AEHU8gALmgHUOQAAWgAAAAsBAAA4AAAADAEAAA0BAABOU3QzX18yOW1vbmV5X3B1dEljTlNfMTlvc3RyZWFtYnVmX2l0ZXJhdG9ySWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFRUUATlN0M19fMjExX19tb25leV9wdXRJY0VFAAAsQgAAsjkAALBCAABsOQAAAAAAAAIAAABQKwAAAgAAAMw5AEH48wALmgF4OgAAWgAAAA4BAAA4AAAADwEAABABAABOU3QzX18yOW1vbmV5X3B1dEl3TlNfMTlvc3RyZWFtYnVmX2l0ZXJhdG9ySXdOU18xMWNoYXJfdHJhaXRzSXdFRUVFRUUATlN0M19fMjExX19tb25leV9wdXRJd0VFAAAsQgAAVjoAALBCAAAQOgAAAAAAAAIAAABQKwAAAgAAAHA6AEGc9QAL6hzwOgAAWgAAABEBAAA4AAAAEgEAABMBAAAUAQAATlN0M19fMjhtZXNzYWdlc0ljRUUATlN0M19fMjEzbWVzc2FnZXNfYmFzZUUAAAAALEIAAM06AACwQgAAuDoAAAAAAAACAAAAUCsAAAIAAADoOgAAAgAAAAAAAABIOwAAWgAAABUBAAA4AAAAFgEAABcBAAAYAQAATlN0M19fMjhtZXNzYWdlc0l3RUUAAAAAsEIAADA7AAAAAAAAAgAAAFArAAACAAAA6DoAAAIAAABTdW5kYXkATW9uZGF5AFR1ZXNkYXkAV2VkbmVzZGF5AFRodXJzZGF5AEZyaWRheQBTYXR1cmRheQBTdW4ATW9uAFR1ZQBXZWQAVGh1AEZyaQBTYXQAAAAAUwAAAHUAAABuAAAAZAAAAGEAAAB5AAAAAAAAAE0AAABvAAAAbgAAAGQAAABhAAAAeQAAAAAAAABUAAAAdQAAAGUAAABzAAAAZAAAAGEAAAB5AAAAAAAAAFcAAABlAAAAZAAAAG4AAABlAAAAcwAAAGQAAABhAAAAeQAAAAAAAABUAAAAaAAAAHUAAAByAAAAcwAAAGQAAABhAAAAeQAAAAAAAABGAAAAcgAAAGkAAABkAAAAYQAAAHkAAAAAAAAAUwAAAGEAAAB0AAAAdQAAAHIAAABkAAAAYQAAAHkAAAAAAAAAUwAAAHUAAABuAAAAAAAAAE0AAABvAAAAbgAAAAAAAABUAAAAdQAAAGUAAAAAAAAAVwAAAGUAAABkAAAAAAAAAFQAAABoAAAAdQAAAAAAAABGAAAAcgAAAGkAAAAAAAAAUwAAAGEAAAB0AAAAAAAAAEphbnVhcnkARmVicnVhcnkATWFyY2gAQXByaWwATWF5AEp1bmUASnVseQBBdWd1c3QAU2VwdGVtYmVyAE9jdG9iZXIATm92ZW1iZXIARGVjZW1iZXIASmFuAEZlYgBNYXIAQXByAEp1bgBKdWwAQXVnAFNlcABPY3QATm92AERlYwAAAEoAAABhAAAAbgAAAHUAAABhAAAAcgAAAHkAAAAAAAAARgAAAGUAAABiAAAAcgAAAHUAAABhAAAAcgAAAHkAAAAAAAAATQAAAGEAAAByAAAAYwAAAGgAAAAAAAAAQQAAAHAAAAByAAAAaQAAAGwAAAAAAAAATQAAAGEAAAB5AAAAAAAAAEoAAAB1AAAAbgAAAGUAAAAAAAAASgAAAHUAAABsAAAAeQAAAAAAAABBAAAAdQAAAGcAAAB1AAAAcwAAAHQAAAAAAAAAUwAAAGUAAABwAAAAdAAAAGUAAABtAAAAYgAAAGUAAAByAAAAAAAAAE8AAABjAAAAdAAAAG8AAABiAAAAZQAAAHIAAAAAAAAATgAAAG8AAAB2AAAAZQAAAG0AAABiAAAAZQAAAHIAAAAAAAAARAAAAGUAAABjAAAAZQAAAG0AAABiAAAAZQAAAHIAAAAAAAAASgAAAGEAAABuAAAAAAAAAEYAAABlAAAAYgAAAAAAAABNAAAAYQAAAHIAAAAAAAAAQQAAAHAAAAByAAAAAAAAAEoAAAB1AAAAbgAAAAAAAABKAAAAdQAAAGwAAAAAAAAAQQAAAHUAAABnAAAAAAAAAFMAAABlAAAAcAAAAAAAAABPAAAAYwAAAHQAAAAAAAAATgAAAG8AAAB2AAAAAAAAAEQAAABlAAAAYwAAAAAAAABBTQBQTQAAAEEAAABNAAAAAAAAAFAAAABNAAAAAAAAAGFsbG9jYXRvcjxUPjo6YWxsb2NhdGUoc2l6ZV90IG4pICduJyBleGNlZWRzIG1heGltdW0gc3VwcG9ydGVkIHNpemUAAAAAAOAzAADAAAAAwQAAAMIAAADDAAAAxAAAAMUAAADGAAAAAAAAAMw0AADQAAAA0QAAANIAAADTAAAA1AAAANUAAADWAAAAAAAAAHxAAAAZAQAAGgEAABsBAABOU3QzX18yMTRfX3NoYXJlZF9jb3VudEUAAAAALEIAAGBAAABiYXNpY19zdHJpbmcAJWQAJXUAJWxsZAB2ZWN0b3IAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAU3Q5dHlwZV9pbmZvAAAALEIAAMFAAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAABUQgAA2EAAANBAAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAABUQgAACEEAAPxAAAAAAAAAfEEAABwBAAAdAQAAHgEAAB8BAAAgAQAATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FAFRCAABUQQAA/EAAAHYAAABAQQAAiEEAAGIAAABAQQAAlEEAAGMAAABAQQAAoEEAAGgAAABAQQAArEEAAGEAAABAQQAAuEEAAHMAAABAQQAAxEEAAHQAAABAQQAA0EEAAGkAAABAQQAA3EEAAGoAAABAQQAA6EEAAGwAAABAQQAA9EEAAG0AAABAQQAAAEIAAGYAAABAQQAADEIAAGQAAABAQQAAGEIAAAAAAAAsQQAAHAEAACEBAAAeAQAAHwEAACIBAAAjAQAAJAEAACUBAAAAAAAAnEIAABwBAAAmAQAAHgEAAB8BAAAiAQAAJwEAACgBAAApAQAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAAFRCAAB0QgAALEEAAAAAAAD4QgAAHAEAACoBAAAeAQAAHwEAACIBAAArAQAALAEAAC0BAABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAAAAVEIAANBCAAAsQQAAdm9pZABib29sAGNoYXIAc2lnbmVkIGNoYXIAdW5zaWduZWQgY2hhcgBzaG9ydAB1bnNpZ25lZCBzaG9ydABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBmbG9hdABkb3VibGUAc3RkOjpzdHJpbmcAc3RkOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhcj4Ac3RkOjp3c3RyaW5nAGVtc2NyaXB0ZW46OnZhbABlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGZsb2F0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAE5TdDNfXzIyMV9fYmFzaWNfc3RyaW5nX2NvbW1vbklMYjFFRUUAAAAALEIAADtGAACwQgAA/EUAAAAAAAABAAAAZEYAAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAsEIAAIRGAAAAAAAAAQAAAGRGAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAALBCAADcRgAAAAAAAAEAAABkRgAAAAAAAE4xMGVtc2NyaXB0ZW4zdmFsRQAALEIAADRHAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAACxCAABQRwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAAAsQgAAeEcAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAALEIAAKBHAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAACxCAADIRwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAAAsQgAA8EcAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAALEIAABhIAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAACxCAABASAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAAAsQgAAaEgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAALEIAAJBIAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAACxCAAC4SAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAAAsQgAA4EgAQZaSAQsa4D8AAAAAAADgvwAAAAAAAPA/AAAAAAAA+D8AQbiSAQsIBtDPQ+v9TD4AQcuSAQveAUADuOI/SW5wdXQgcG9pbnRlciBudWxsCgBPdXRwdXQgcG9pbnRlciBudWxsCgBJbnZhbGlkIHNoYWRlciBz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AAAAYwIAACotBAAAAAAAZAIAADYtBAAAAAAAZQIAAEEtBAAAAAAAZgIAANFZAAAAAAAAZwIAADKKAgAAAAAAaAIAAG8tBAAAAAAAaQIAAIEtBAAAAAAAagIAAJItBAAAAAAAawIAAKEtBAAAAAAAbAIAALYtBAAAAAAAbQIAAMItBAAAAAAAbgIAANQtBAAAAAAAbwIAAOQtBABB5LIBC3diYXJyaWVyAG1lbW9yeUJhcnJpZXJTaGFyZWQAZ3JvdXBNZW1vcnlCYXJyaWVyAG1lbW9yeUJhcnJpZXIAbWVtb3J5QmFycmllckJ1ZmZlcgBtYXRyaXhDb21wTXVsdABvdXRlclByb2R1Y3QAdGV4ZWxGZXRjaABB5LMBCx5DAQAARAEAABsBAAAbAQAARQEAAEYBAAAbAQAAGwEAQYy0AQv7xQJDAQAARwEAAEgBAABJAQAARQEAAEYBAABKAQAASwEAADQAZ2xfTWF4VHJhbnNmb3JtRmVlZGJhY2tCdWZmZXJzAAAAANTbAwBnbF9NYXhUcmFuc2Zvcm1GZWVkYmFja0ludGVybGVhdmVkQ29tcG9uZW50cwBnbF9NaW5Qcm9ncmFtVGV4ZWxPZmZzZXQAAAA72wMAZ2xfTWF4UHJvZ3JhbVRleGVsT2Zmc2V0AGdsX01heFZpZXdwb3J0cwAAAAAX3QMASlwEALhcBAD95AMA5uUDAGdsX1ZlcnRleEluZGV4AGdsX0luc3RhbmNlSW5kZXgAZ2xfQmFzZVZlcnRleEFSQgAAAACi3AMAZ2xfQmFzZUluc3RhbmNlQVJCAGdsX0RyYXdJREFSQgBnbF9CYXNlVmVydGV4AGdsX0Jhc2VJbnN0YW5jZQBnbF9EcmF3SUQAZ2xfU3ViR3JvdXBTaXplQVJCAAAt3QMAZ2xfU3ViR3JvdXBJbnZvY2F0aW9uQVJCAGdsX1N1Ykdyb3VwRXFNYXNrQVJCAGdsX1N1Ykdyb3VwR2VNYXNrQVJCAGdsX1N1Ykdyb3VwR3RNYXNrQVJCAGdsX1N1Ykdyb3VwTGVNYXNrQVJCAGdsX1N1Ykdyb3VwTHRNYXNrQVJCAGJhbGxvdEFSQgByZWFkSW52b2NhdGlvbkFSQgByZWFkRmlyc3RJbnZvY2F0aW9uQVJCAGFueUludm9jYXRpb25BUkIAAADA3AMAYWxsSW52b2NhdGlvbnNBUkIAYWxsSW52b2NhdGlvbnNFcXVhbEFSQgBtaW5JbnZvY2F0aW9uc0FNRAAA7+ADAG1heEludm9jYXRpb25zQU1EAGFkZEludm9jYXRpb25zQU1EAG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRABtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQAYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EAHN3aXp6bGVJbnZvY2F0aW9uc0FNRABzd2l6emxlSW52b2NhdGlvbnNXaXRoUGF0dGVybkFNRAB3cml0ZUludm9jYXRpb25BTUQAbWJjbnRBTUQAbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EAG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRABhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQAbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRABtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EAGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQAbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EAG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRABhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQAbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRABtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EAGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQAAAThAwBnbF9TSU1ER3JvdXBTaXplQU1EAEnhAwBjdWJlRmFjZUluZGV4QU1EAGN1YmVGYWNlQ29vcmRBTUQAdGltZUFNRAAAAJvhAwB0ZXh0dXJlRm9vdHByaW50TlYAAB3jAwB0ZXh0dXJlRm9vdHByaW50Q2xhbXBOVgB0ZXh0dXJlRm9vdHByaW50TG9kTlYAdGV4dHVyZUZvb3RwcmludEdyYWROVgB0ZXh0dXJlRm9vdHByaW50R3JhZENsYW1wTlYAZ2xfTm9ybWFsAGdsX1ZlcnRleABnbF9NdWx0aVRleENvb3JkMABnbF9NdWx0aVRleENvb3JkMQBnbF9NdWx0aVRleENvb3JkMgBnbF9NdWx0aVRleENvb3JkMwBnbF9NdWx0aVRleENvb3JkNABnbF9NdWx0aVRleENvb3JkNQBnbF9NdWx0aVRleENvb3JkNgBnbF9NdWx0aVRleENvb3JkNwBnbF9Gb2dDb29yZAB0ZXh0dXJlMkRHcmFkRVhUAAAA3NoDAHRleHR1cmUyRFByb2pHcmFkRVhUAHRleHR1cmVDdWJlR3JhZEVYVACZ5AMAguUDAPjjAwBnbF9WaWV3SURfT1ZSAAAAe+YDAIzmAwBzaGFkb3cyREVYVAD22gMAc2hhZG93MkRQcm9qRVhUAGdsX0JvdW5kaW5nQm94RVhUAAAArOQDAGdsX0JvdW5kaW5nQm94T0VTAAAAleUDAGdsX0JvdW5kaW5nQm94AGdsX1ByaW1pdGl2ZUlESW4AZ2xfUHJpbWl0aXZlSUQAZ2xfSW52b2NhdGlvbklEAGdsX1ZpZXdwb3J0SW5kZXgArd0DAI1cBACNXAQAZ2xfUGF0Y2hWZXJ0aWNlc0luAGdsX1Rlc3NMZXZlbE91dGVyAGdsX1Rlc3NMZXZlbElubmVyAGdsX1Rlc3NDb29yZAB+5AMAZ+UDAGdsX0RldmljZUluZGV4AAA55gMAZ2xfVmlld0luZGV4AAAAAE3mAwBnbF9TdWJncm91cFNpemUABd4DAGdsX1N1Ymdyb3VwSW52b2NhdGlvbklEAGdsX1N1Ymdyb3VwRXFNYXNrAAAAYN4DAGdsX1N1Ymdyb3VwR2VNYXNrAGdsX1N1Ymdyb3VwR3RNYXNrAGdsX1N1Ymdyb3VwTGVNYXNrAGdsX1N1Ymdyb3VwTHRNYXNrAGdsX1dhcnBzUGVyU01OVgBn4wMAZ2xfU01Db3VudE5WAGdsX1dhcnBJRE5WAGdsX1NNSUROVgBnbF9GcmFnRGVwdGhFWFQAZ2xfSGVscGVySW52b2NhdGlvbgAAdd0DAGdsX1NhbXBsZUlEAGdsX1NhbXBsZVBvc2l0aW9uAGdsX1NhbXBsZU1hc2tJbgAAAODjAwBnbF9OdW1TYW1wbGVzAHRleHR1cmUyRExvZEVYVAB0ZXh0dXJlMkRQcm9qTG9kRVhUAHRleHR1cmVDdWJlTG9kRVhUAGLaAwAT5AMAdGV4dHVyZTFETG9kAAAAAArcAwB0ZXh0dXJlMkRMb2QAdGV4dHVyZTNETG9kAHRleHR1cmVDdWJlTG9kAHRleHR1cmUxRFByb2pMb2QAdGV4dHVyZTJEUHJvakxvZAB0ZXh0dXJlM0RQcm9qTG9kAHNoYWRvdzFETG9kAHNoYWRvdzJETG9kAHNoYWRvdzFEUHJvakxvZABzaGFkb3cyRFByb2pMb2QAdGV4dHVyZTFER3JhZEFSQgB0ZXh0dXJlMURQcm9qR3JhZEFSQgB0ZXh0dXJlMkRHcmFkQVJCAHRleHR1cmUyRFByb2pHcmFkQVJCAHRleHR1cmUzREdyYWRBUkIAdGV4dHVyZTNEUHJvakdyYWRBUkIAdGV4dHVyZUN1YmVHcmFkQVJCAHNoYWRvdzFER3JhZEFSQgBzaGFkb3cxRFByb2pHcmFkQVJCAHNoYWRvdzJER3JhZEFSQgBzaGFkb3cyRFByb2pHcmFkQVJCAHRleHR1cmUyRFJlY3RHcmFkQVJCAHRleHR1cmUyRFJlY3RQcm9qR3JhZEFSQgBzaGFkb3cyRFJlY3RHcmFkQVJCAHNoYWRvdzJEUmVjdFByb2pHcmFkQVJCAABl3AMAYXRvbWljQ291bnRlckluY3JlbWVudAAAhNwDAGF0b21pY0NvdW50ZXJEZWNyZW1lbnQAYXRvbWljQ291bnRlcgBkRmR4RmluZQAAANncAwBkRmR5RmluZQBkRmR4Q29hcnNlAGRGZHlDb2Fyc2UAc3BhcnNlVGV4dHVyZUFSQgBC3QMAc3BhcnNlVGV4dHVyZUxvZEFSQgBzcGFyc2VUZXh0dXJlT2Zmc2V0QVJCAHNwYXJzZVRleGVsRmV0Y2hBUkIAc3BhcnNlVGV4ZWxGZXRjaE9mZnNldEFSQgBzcGFyc2VUZXh0dXJlTG9kT2Zmc2V0QVJCAHNwYXJzZVRleHR1cmVHcmFkQVJCAHNwYXJzZVRleHR1cmVHcmFkT2Zmc2V0QVJCAHNwYXJzZVRleHR1cmVHYXRoZXJBUkIAc3BhcnNlVGV4dHVyZUdhdGhlck9mZnNldEFSQgBzcGFyc2VUZXh0dXJlR2F0aGVyT2Zmc2V0c0FSQgBzcGFyc2VJbWFnZUxvYWRBUkIAc3BhcnNlVGV4dHVyZUNsYW1wQVJCAAAAWd0DAHNwYXJzZVRleHR1cmVPZmZzZXRDbGFtcEFSQgBzcGFyc2VUZXh0dXJlR3JhZENsYW1wQVJCAHNwYXJzZVRleHR1cmVHcmFkT2Zmc2V0Q2xhbXBBUkIAdGV4dHVyZUNsYW1wQVJCAHRleHR1cmVPZmZzZXRDbGFtcEFSQgB0ZXh0dXJlR3JhZENsYW1wQVJCAHRleHR1cmVHcmFkT2Zmc2V0Q2xhbXBBUkIAZ2xfQmFyeUNvb3JkTm9QZXJzcEFNRAAAAAAh4QMAZ2xfQmFyeUNvb3JkTm9QZXJzcENlbnRyb2lkQU1EAGdsX0JhcnlDb29yZE5vUGVyc3BTYW1wbGVBTUQAZ2xfQmFyeUNvb3JkU21vb3RoQU1EAGdsX0JhcnlDb29yZFNtb290aENlbnRyb2lkQU1EAGdsX0JhcnlDb29yZFNtb290aFNhbXBsZUFNRABnbF9CYXJ5Q29vcmRQdWxsTW9kZWxBTUQAaW50ZXJwb2xhdGVBdFZlcnRleEFNRAB0ZXh0dXJlR2F0aGVyTG9kQU1EAIVeBAB0ZXh0dXJlR2F0aGVyTG9kT2Zmc2V0QU1EAHRleHR1cmVHYXRoZXJMb2RPZmZzZXRzQU1EAHNwYXJzZVRleHR1cmVHYXRoZXJMb2RBTUQAc3BhcnNlVGV4dHVyZUdhdGhlckxvZE9mZnNldEFNRABzcGFyc2VUZXh0dXJlR2F0aGVyTG9kT2Zmc2V0c0FNRABpbWFnZUxvYWRMb2RBTUQAeOEDAGltYWdlU3RvcmVMb2RBTUQAc3BhcnNlSW1hZ2VMb2FkTG9kQU1EAGdsX0ZyYWdGdWxseUNvdmVyZWROVgAAAAA64gMAZ2xfRnJhZ21lbnRTaXplTlYAAACv4gMAZ2xfSW52b2NhdGlvbnNQZXJQaXhlbE5WAGdsX0JhcnlDb29yZE5WANriAwBnbF9CYXJ5Q29vcmROb1BlcnNwTlYAZ2xfRnJhZ1NpemVFWFQAAAAAI+ADAGdsX0ZyYWdJbnZvY2F0aW9uQ291bnRFWFQAAAB+2gMAY2xvY2tBUkIAAAAA8d0DAGNsb2NrMngzMkFSQgBjbG9ja1JlYWx0aW1lRVhUAAAAXuYDAGNsb2NrUmVhbHRpbWUyeDMyRVhUAAAAAGfkAwBQ5QMAIt4DAH7eAwCd3gMAPt4DAMXeAwDm3gMAjeIDAGdsX1Njb3BlRGV2aWNlAAAC3wMAZ2xfU2NvcGVXb3JrZ3JvdXAAZ2xfU2NvcGVTdWJncm91cABnbF9TY29wZUludm9jYXRpb24AZ2xfU2VtYW50aWNzUmVsYXhlZABnbF9TZW1hbnRpY3NBY3F1aXJlAGdsX1NlbWFudGljc1JlbGVhc2UAZ2xfU2VtYW50aWNzQWNxdWlyZVJlbGVhc2UAZ2xfU2VtYW50aWNzTWFrZUF2YWlsYWJsZQBnbF9TZW1hbnRpY3NNYWtlVmlzaWJsZQBnbF9TZW1hbnRpY3NWb2xhdGlsZQBnbF9TdG9yYWdlU2VtYW50aWNzTm9uZQBnbF9TdG9yYWdlU2VtYW50aWNzQnVmZmVyAGdsX1N0b3JhZ2VTZW1hbnRpY3NTaGFyZWQAZ2xfU3RvcmFnZVNlbWFudGljc0ltYWdlAGdsX1N0b3JhZ2VTZW1hbnRpY3NPdXRwdXQAaGVscGVySW52b2NhdGlvbkVYVAAAleADAGdsX051bVdvcmtHcm91cHMAZ2xfV29ya0dyb3VwSUQAZ2xfTG9jYWxJbnZvY2F0aW9uSUQAZ2xfR2xvYmFsSW52b2NhdGlvbklEAGdsX0xvY2FsSW52b2NhdGlvbkluZGV4AACj2wMAZ2xfTWF4Q29tcHV0ZVdvcmtHcm91cENvdW50AGdsX01heENvbXB1dGVXb3JrR3JvdXBTaXplAGdsX01heENvbXB1dGVVbmlmb3JtQ29tcG9uZW50cwBnbF9NYXhDb21wdXRlVGV4dHVyZUltYWdlVW5pdHMAZ2xfTWF4Q29tcHV0ZUltYWdlVW5pZm9ybXMAZ2xfTWF4Q29tcHV0ZUF0b21pY0NvdW50ZXJzAGdsX01heENvbXB1dGVBdG9taWNDb3VudGVyQnVmZmVycwBtZW1vcnlCYXJyaWVyQXRvbWljQ291bnRlcgBtZW1vcnlCYXJyaWVySW1hZ2UAY29udHJvbEJhcnJpZXIAZ2xfTnVtU3ViZ3JvdXBzAGdsX1N1Ymdyb3VwSUQAAAAATuMDAIDjAwBjb29wTWF0TG9hZE5WAGNvb3BNYXRTdG9yZU5WAGNvb3BNYXRNdWxBZGROVgAAAAD84gMAZ2xfTGF1bmNoSUROVgAAAMjiAwBnbF9MYXVuY2hTaXplTlYAZ2xfSW5zdGFuY2VDdXN0b21JbmRleE5WAGdsX1dvcmxkUmF5T3JpZ2luTlYAZ2xfV29ybGRSYXlEaXJlY3Rpb25OVgBnbF9PYmplY3RSYXlPcmlnaW5OVgBnbF9PYmplY3RSYXlEaXJlY3Rpb25OVgBnbF9SYXlUbWluTlYAZ2xfUmF5VG1heE5WAGdsX0hpdFROVgBnbF9IaXRLaW5kTlYAZ2xfT2JqZWN0VG9Xb3JsZE5WAGdsX1dvcmxkVG9PYmplY3ROVgBnbF9JbmNvbWluZ1JheUZsYWdzTlYAAAA84wMAZ2xfUHJpbWl0aXZlQ291bnROVgBnbF9NZXNoVmlld0NvdW50TlYAZ2xfTWVzaFZpZXdJbmRpY2VzTlYAZ2xfTWF4TWVzaE91dHB1dFZlcnRpY2VzTlYAZ2xfTWF4TWVzaE91dHB1dFByaW1pdGl2ZXNOVgBnbF9NYXhNZXNoV29ya0dyb3VwU2l6ZU5WAGdsX01heE1lc2hWaWV3Q291bnROVgBnbF9UYXNrQ291bnROVgBnbF9NYXhUYXNrV29ya0dyb3VwU2l6ZU5WAGhhbGZCaXRzVG9JbnQxNgBoYWxmQml0c1RvVWludDE2AGludDE2Qml0c1RvSGFsZgB1aW50MTZCaXRzVG9IYWxmAHBhY2tTbm9ybTR4OAB1bnBhY2tTbm9ybTR4OABwYWNrVW5vcm00eDgAdW5wYWNrVW5vcm00eDgAcGFja0RvdWJsZTJ4MzIAdW5wYWNrRG91YmxlMngzMgBhdG9taWNMb2FkAGF0b21pY1N0b3JlAGF0b21pY0NvdW50ZXJBZGQAYXRvbWljQ291bnRlclN1YnRyYWN0AGF0b21pY0NvdW50ZXJNaW4AYXRvbWljQ291bnRlck1heABhdG9taWNDb3VudGVyQW5kAGF0b21pY0NvdW50ZXJPcgBhdG9taWNDb3VudGVyWG9yAGF0b21pY0NvdW50ZXJFeGNoYW5nZQBhdG9taWNDb3VudGVyQ29tcFN3YXAAdWFkZENhcnJ5AHVzdWJCb3Jyb3cAdW11bEV4dGVuZGVkAGltdWxFeHRlbmRlZABiaXRmaWVsZFJldmVyc2UAaW1hZ2VTaXplAG5vaXNlMQBub2lzZTIAbm9pc2UzAG5vaXNlNABmdHJhbnNmb3JtAHRleHR1cmUxRFByb2oAdGV4dHVyZTJEUmVjdFByb2oAc2hhZG93MkRSZWN0AHNoYWRvdzJEUmVjdFByb2oAdGV4dHVyZTJEUHJvagB0ZXh0dXJlM0RQcm9qAHNoYWRvdzFEAHNoYWRvdzJEAHNoYWRvdzFEUHJvagBzaGFkb3cyRFByb2oAc3BhcnNlVGV4ZWxzUmVzaWRlbnRBUkIAc3dpenpsZUludm9jYXRpb25zTWFza2VkQU1EAGJlZ2luSW52b2NhdGlvbkludGVybG9ja0FSQgBlbmRJbnZvY2F0aW9uSW50ZXJsb2NrQVJCAGNvbnN0IG1lZGl1bXAgaW50ICBnbF9NYXhWZXJ0ZXhBdHRyaWJzID0gJWQ7AGNvbnN0IG1lZGl1bXAgaW50ICBnbF9NYXhWZXJ0ZXhVbmlmb3JtVmVjdG9ycyA9ICVkOwBjb25zdCBtZWRpdW1wIGludCAgZ2xfTWF4VmVydGV4VGV4dHVyZUltYWdlVW5pdHMgPSAlZDsAY29uc3QgbWVkaXVtcCBpbnQgIGdsX01heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMgPSAlZDsAY29uc3QgbWVkaXVtcCBpbnQgIGdsX01heFRleHR1cmVJbWFnZVVuaXRzID0gJWQ7AGNvbnN0IG1lZGl1bXAgaW50ICBnbF9NYXhGcmFnbWVudFVuaWZvcm1WZWN0b3JzID0gJWQ7AGNvbnN0IG1lZGl1bXAgaW50ICBnbF9NYXhEcmF3QnVmZmVycyA9ICVkOwBjb25zdCBtZWRpdW1wIGludCAgZ2xfTWF4VmFyeWluZ1ZlY3RvcnMgPSAlZDsAY29uc3QgbWVkaXVtcCBpbnQgIGdsX01heFZlcnRleE91dHB1dFZlY3RvcnMgPSAlZDsAY29uc3QgbWVkaXVtcCBpbnQgIGdsX01heEZyYWdtZW50SW5wdXRWZWN0b3JzID0gJWQ7AGNvbnN0IG1lZGl1bXAgaW50ICBnbF9NaW5Qcm9ncmFtVGV4ZWxPZmZzZXQgPSAlZDsAY29uc3QgbWVkaXVtcCBpbnQgIGdsX01heFByb2dyYW1UZXhlbE9mZnNldCA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4R2VvbWV0cnlJbnB1dENvbXBvbmVudHMgPSAlZDsAY29uc3QgaW50IGdsX01heEdlb21ldHJ5T3V0cHV0Q29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4R2VvbWV0cnlJbWFnZVVuaWZvcm1zID0gJWQ7AGNvbnN0IGludCBnbF9NYXhHZW9tZXRyeVRleHR1cmVJbWFnZVVuaXRzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhHZW9tZXRyeU91dHB1dFZlcnRpY2VzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhHZW9tZXRyeVRvdGFsT3V0cHV0Q29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4R2VvbWV0cnlVbmlmb3JtQ29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4R2VvbWV0cnlBdG9taWNDb3VudGVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4R2VvbWV0cnlBdG9taWNDb3VudGVyQnVmZmVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4VGVzc0NvbnRyb2xJbnB1dENvbXBvbmVudHMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NDb250cm9sT3V0cHV0Q29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4VGVzc0NvbnRyb2xUZXh0dXJlSW1hZ2VVbml0cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4VGVzc0NvbnRyb2xVbmlmb3JtQ29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4VGVzc0NvbnRyb2xUb3RhbE91dHB1dENvbXBvbmVudHMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NFdmFsdWF0aW9uSW5wdXRDb21wb25lbnRzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhUZXNzRXZhbHVhdGlvbk91dHB1dENvbXBvbmVudHMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NFdmFsdWF0aW9uVGV4dHVyZUltYWdlVW5pdHMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NFdmFsdWF0aW9uVW5pZm9ybUNvbXBvbmVudHMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NQYXRjaENvbXBvbmVudHMgPSAlZDsAY29uc3QgaW50IGdsX01heFBhdGNoVmVydGljZXMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NHZW5MZXZlbCA9ICVkOwBpbiBnbF9QZXJWZXJ0ZXgge2hpZ2hwIHZlYzQgZ2xfUG9zaXRpb247aGlnaHAgZmxvYXQgZ2xfUG9pbnRTaXplO2hpZ2hwIHZlYzQgZ2xfU2Vjb25kYXJ5UG9zaXRpb25OVjtoaWdocCB2ZWM0IGdsX1Bvc2l0aW9uUGVyVmlld05WW107fSBnbF9pbltnbF9NYXhQYXRjaFZlcnRpY2VzXTsKAGNvbnN0IGludCAgZ2xfTWF4VmVydGV4QXR0cmlicyA9ICVkOwBjb25zdCBpbnQgIGdsX01heFZlcnRleFRleHR1cmVJbWFnZVVuaXRzID0gJWQ7AGNvbnN0IGludCAgZ2xfTWF4Q29tYmluZWRUZXh0dXJlSW1hZ2VVbml0cyA9ICVkOwBjb25zdCBpbnQgIGdsX01heFRleHR1cmVJbWFnZVVuaXRzID0gJWQ7AGNvbnN0IGludCAgZ2xfTWF4RHJhd0J1ZmZlcnMgPSAlZDsAY29uc3QgaW50ICBnbF9NYXhMaWdodHMgPSAlZDsAY29uc3QgaW50ICBnbF9NYXhDbGlwUGxhbmVzID0gJWQ7AGNvbnN0IGludCAgZ2xfTWF4VGV4dHVyZVVuaXRzID0gJWQ7AGNvbnN0IGludCAgZ2xfTWF4VGV4dHVyZUNvb3JkcyA9ICVkOwBjb25zdCBpbnQgIGdsX01heFZlcnRleFVuaWZvcm1Db21wb25lbnRzID0gJWQ7AGNvbnN0IGludCAgZ2xfTWF4VmFyeWluZ0Zsb2F0cyA9ICVkOwBjb25zdCBpbnQgIGdsX01heEZyYWdtZW50VW5pZm9ybUNvbXBvbmVudHMgPSAlZDsAdW5pZm9ybSBtYXQ0ICBnbF9UZXh0dXJlTWF0cml4W2dsX01heFRleHR1cmVDb29yZHNdO3VuaWZvcm0gbWF0NCAgZ2xfVGV4dHVyZU1hdHJpeEludmVyc2VbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSBtYXQ0ICBnbF9UZXh0dXJlTWF0cml4VHJhbnNwb3NlW2dsX01heFRleHR1cmVDb29yZHNdO3VuaWZvcm0gbWF0NCAgZ2xfVGV4dHVyZU1hdHJpeEludmVyc2VUcmFuc3Bvc2VbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9DbGlwUGxhbmVbZ2xfTWF4Q2xpcFBsYW5lc107dW5pZm9ybSBnbF9MaWdodFNvdXJjZVBhcmFtZXRlcnMgIGdsX0xpZ2h0U291cmNlW2dsX01heExpZ2h0c107dW5pZm9ybSBnbF9MaWdodFByb2R1Y3RzIGdsX0Zyb250TGlnaHRQcm9kdWN0W2dsX01heExpZ2h0c107dW5pZm9ybSBnbF9MaWdodFByb2R1Y3RzIGdsX0JhY2tMaWdodFByb2R1Y3RbZ2xfTWF4TGlnaHRzXTt1bmlmb3JtIHZlYzQgIGdsX1RleHR1cmVFbnZDb2xvcltnbF9NYXhUZXh0dXJlSW1hZ2VVbml0c107dW5pZm9ybSB2ZWM0ICBnbF9FeWVQbGFuZVNbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9FeWVQbGFuZVRbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9FeWVQbGFuZVJbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9FeWVQbGFuZVFbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9PYmplY3RQbGFuZVNbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9PYmplY3RQbGFuZVRbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9PYmplY3RQbGFuZVJbZ2xfTWF4VGV4dHVyZUNvb3Jkc107dW5pZm9ybSB2ZWM0ICBnbF9PYmplY3RQbGFuZVFbZ2xfTWF4VGV4dHVyZUNvb3Jkc107AGNvbnN0IGludCBnbF9NYXhDbGlwRGlzdGFuY2VzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhWYXJ5aW5nQ29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4R2VvbWV0cnlWYXJ5aW5nQ29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4VmVydGV4T3V0cHV0Q29tcG9uZW50cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4RnJhZ21lbnRJbnB1dENvbXBvbmVudHMgPSAlZDsAaW4gZ2xfUGVyVmVydGV4IHt2ZWM0IGdsX1Bvc2l0aW9uO2Zsb2F0IGdsX1BvaW50U2l6ZTtmbG9hdCBnbF9DbGlwRGlzdGFuY2VbXTsAdmVjNCBnbF9DbGlwVmVydGV4O3ZlYzQgZ2xfRnJvbnRDb2xvcjt2ZWM0IGdsX0JhY2tDb2xvcjt2ZWM0IGdsX0Zyb250U2Vjb25kYXJ5Q29sb3I7dmVjNCBnbF9CYWNrU2Vjb25kYXJ5Q29sb3I7dmVjNCBnbF9UZXhDb29yZFtdO2Zsb2F0IGdsX0ZvZ0ZyYWdDb29yZDsAZmxvYXQgZ2xfQ3VsbERpc3RhbmNlW107dmVjNCBnbF9TZWNvbmRhcnlQb3NpdGlvbk5WO3ZlYzQgZ2xfUG9zaXRpb25QZXJWaWV3TlZbXTsAfSBnbF9pbltnbF9NYXhQYXRjaFZlcnRpY2VzXTsKAGNvbnN0IGludCBnbF9NYXhWaWV3cG9ydHMgPSAlZDsAY29uc3QgaW50IGdsX01heENvbWJpbmVkSW1hZ2VVbml0c0FuZEZyYWdtZW50T3V0cHV0cyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4SW1hZ2VTYW1wbGVzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhUZXNzQ29udHJvbEltYWdlVW5pZm9ybXMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NFdmFsdWF0aW9uSW1hZ2VVbmlmb3JtcyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4VHJhbnNmb3JtRmVlZGJhY2tCdWZmZXJzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhUcmFuc2Zvcm1GZWVkYmFja0ludGVybGVhdmVkQ29tcG9uZW50cyA9ICVkOwBjb25zdCBpdmVjMyBnbF9NYXhDb21wdXRlV29ya0dyb3VwQ291bnQgPSBpdmVjMyglZCwlZCwlZCk7AGNvbnN0IGl2ZWMzIGdsX01heENvbXB1dGVXb3JrR3JvdXBTaXplID0gaXZlYzMoJWQsJWQsJWQpOwBjb25zdCBpbnQgZ2xfTWF4Q29tcHV0ZVVuaWZvcm1Db21wb25lbnRzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhDb21wdXRlVGV4dHVyZUltYWdlVW5pdHMgPSAlZDsAY29uc3QgaW50IGdsX01heEltYWdlVW5pdHMgPSAlZDsAY29uc3QgaW50IGdsX01heENvbWJpbmVkU2hhZGVyT3V0cHV0UmVzb3VyY2VzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhWZXJ0ZXhJbWFnZVVuaWZvcm1zID0gJWQ7AGNvbnN0IGludCBnbF9NYXhGcmFnbWVudEltYWdlVW5pZm9ybXMgPSAlZDsAY29uc3QgaW50IGdsX01heENvbWJpbmVkSW1hZ2VVbmlmb3JtcyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4Q29tcHV0ZUltYWdlVW5pZm9ybXMgPSAlZDsAY29uc3QgaW50IGdsX01heENvbXB1dGVBdG9taWNDb3VudGVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4Q29tcHV0ZUF0b21pY0NvdW50ZXJCdWZmZXJzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhWZXJ0ZXhBdG9taWNDb3VudGVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4RnJhZ21lbnRBdG9taWNDb3VudGVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4Q29tYmluZWRBdG9taWNDb3VudGVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4QXRvbWljQ291bnRlckJpbmRpbmdzID0gJWQ7AGNvbnN0IGludCBnbF9NYXhWZXJ0ZXhBdG9taWNDb3VudGVyQnVmZmVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4RnJhZ21lbnRBdG9taWNDb3VudGVyQnVmZmVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4Q29tYmluZWRBdG9taWNDb3VudGVyQnVmZmVycyA9ICVkOwBjb25zdCBpbnQgZ2xfTWF4QXRvbWljQ291bnRlckJ1ZmZlclNpemUgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NDb250cm9sQXRvbWljQ291bnRlcnMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NFdmFsdWF0aW9uQXRvbWljQ291bnRlcnMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NDb250cm9sQXRvbWljQ291bnRlckJ1ZmZlcnMgPSAlZDsAY29uc3QgaW50IGdsX01heFRlc3NFdmFsdWF0aW9uQXRvbWljQ291bnRlckJ1ZmZlcnMgPSAlZDsAY29uc3QgaW50IGdsX01heEN1bGxEaXN0YW5jZXMgPSAlZDsAY29uc3QgaW50IGdsX01heENvbWJpbmVkQ2xpcEFuZEN1bGxEaXN0YW5jZXMgPSAlZDsAY29uc3QgaW50IGdsX01heFNhbXBsZXMgPSAlZDsAY29uc3QgaW50IGdsX01heE1lc2hPdXRwdXRWZXJ0aWNlc05WID0gJWQ7AGNvbnN0IGludCBnbF9NYXhNZXNoT3V0cHV0UHJpbWl0aXZlc05WID0gJWQ7AGNvbnN0IGl2ZWMzIGdsX01heE1lc2hXb3JrR3JvdXBTaXplTlYgPSBpdmVjMyglZCwlZCwlZCk7AGNvbnN0IGl2ZWMzIGdsX01heFRhc2tXb3JrR3JvdXBTaXplTlYgPSBpdmVjMyglZCwlZCwlZCk7AGNvbnN0IGludCBnbF9NYXhNZXNoVmlld0NvdW50TlYgPSAlZDsAZmxvYXQgZEZkeEZpbmUoZmxvYXQgcCk7dmVjMiAgZEZkeEZpbmUodmVjMiAgcCk7dmVjMyAgZEZkeEZpbmUodmVjMyAgcCk7dmVjNCAgZEZkeEZpbmUodmVjNCAgcCk7ZmxvYXQgZEZkeUZpbmUoZmxvYXQgcCk7dmVjMiAgZEZkeUZpbmUodmVjMiAgcCk7dmVjMyAgZEZkeUZpbmUodmVjMyAgcCk7dmVjNCAgZEZkeUZpbmUodmVjNCAgcCk7ZmxvYXQgZndpZHRoRmluZShmbG9hdCBwKTt2ZWMyICBmd2lkdGhGaW5lKHZlYzIgIHApO3ZlYzMgIGZ3aWR0aEZpbmUodmVjMyAgcCk7dmVjNCAgZndpZHRoRmluZSh2ZWM0ICBwKTtmbG9hdCBkRmR4Q29hcnNlKGZsb2F0IHApO3ZlYzIgIGRGZHhDb2Fyc2UodmVjMiAgcCk7dmVjMyAgZEZkeENvYXJzZSh2ZWMzICBwKTt2ZWM0ICBkRmR4Q29hcnNlKHZlYzQgIHApO2Zsb2F0IGRGZHlDb2Fyc2UoZmxvYXQgcCk7dmVjMiAgZEZkeUNvYXJzZSh2ZWMyICBwKTt2ZWMzICBkRmR5Q29hcnNlKHZlYzMgIHApO3ZlYzQgIGRGZHlDb2Fyc2UodmVjNCAgcCk7ZmxvYXQgZndpZHRoQ29hcnNlKGZsb2F0IHApO3ZlYzIgIGZ3aWR0aENvYXJzZSh2ZWMyICBwKTt2ZWMzICBmd2lkdGhDb2Fyc2UodmVjMyAgcCk7dmVjNCAgZndpZHRoQ29hcnNlKHZlYzQgIHApOwBmbG9hdDE2X3QgZEZkeChmbG9hdDE2X3QpO2YxNnZlYzIgICBkRmR4KGYxNnZlYzIpO2YxNnZlYzMgICBkRmR4KGYxNnZlYzMpO2YxNnZlYzQgICBkRmR4KGYxNnZlYzQpO2Zsb2F0MTZfdCBkRmR5KGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGRGZHkoZjE2dmVjMik7ZjE2dmVjMyAgIGRGZHkoZjE2dmVjMyk7ZjE2dmVjNCAgIGRGZHkoZjE2dmVjNCk7ZmxvYXQxNl90IGRGZHhGaW5lKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGRGZHhGaW5lKGYxNnZlYzIpO2YxNnZlYzMgICBkRmR4RmluZShmMTZ2ZWMzKTtmMTZ2ZWM0ICAgZEZkeEZpbmUoZjE2dmVjNCk7ZmxvYXQxNl90IGRGZHlGaW5lKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGRGZHlGaW5lKGYxNnZlYzIpO2YxNnZlYzMgICBkRmR5RmluZShmMTZ2ZWMzKTtmMTZ2ZWM0ICAgZEZkeUZpbmUoZjE2dmVjNCk7ZmxvYXQxNl90IGRGZHhDb2Fyc2UoZmxvYXQxNl90KTtmMTZ2ZWMyICAgZEZkeENvYXJzZShmMTZ2ZWMyKTtmMTZ2ZWMzICAgZEZkeENvYXJzZShmMTZ2ZWMzKTtmMTZ2ZWM0ICAgZEZkeENvYXJzZShmMTZ2ZWM0KTtmbG9hdDE2X3QgZEZkeUNvYXJzZShmbG9hdDE2X3QpO2YxNnZlYzIgICBkRmR5Q29hcnNlKGYxNnZlYzIpO2YxNnZlYzMgICBkRmR5Q29hcnNlKGYxNnZlYzMpO2YxNnZlYzQgICBkRmR5Q29hcnNlKGYxNnZlYzQpO2Zsb2F0MTZfdCBmd2lkdGgoZmxvYXQxNl90KTtmMTZ2ZWMyICAgZndpZHRoKGYxNnZlYzIpO2YxNnZlYzMgICBmd2lkdGgoZjE2dmVjMyk7ZjE2dmVjNCAgIGZ3aWR0aChmMTZ2ZWM0KTtmbG9hdDE2X3QgZndpZHRoRmluZShmbG9hdDE2X3QpO2YxNnZlYzIgICBmd2lkdGhGaW5lKGYxNnZlYzIpO2YxNnZlYzMgICBmd2lkdGhGaW5lKGYxNnZlYzMpO2YxNnZlYzQgICBmd2lkdGhGaW5lKGYxNnZlYzQpO2Zsb2F0MTZfdCBmd2lkdGhDb2Fyc2UoZmxvYXQxNl90KTtmMTZ2ZWMyICAgZndpZHRoQ29hcnNlKGYxNnZlYzIpO2YxNnZlYzMgICBmd2lkdGhDb2Fyc2UoZjE2dmVjMyk7ZjE2dmVjNCAgIGZ3aWR0aENvYXJzZShmMTZ2ZWM0KTsAZmxvYXQ2NF90IGRGZHgoZmxvYXQ2NF90KTtmNjR2ZWMyICAgZEZkeChmNjR2ZWMyKTtmNjR2ZWMzICAgZEZkeChmNjR2ZWMzKTtmNjR2ZWM0ICAgZEZkeChmNjR2ZWM0KTtmbG9hdDY0X3QgZEZkeShmbG9hdDY0X3QpO2Y2NHZlYzIgICBkRmR5KGY2NHZlYzIpO2Y2NHZlYzMgICBkRmR5KGY2NHZlYzMpO2Y2NHZlYzQgICBkRmR5KGY2NHZlYzQpO2Zsb2F0NjRfdCBkRmR4RmluZShmbG9hdDY0X3QpO2Y2NHZlYzIgICBkRmR4RmluZShmNjR2ZWMyKTtmNjR2ZWMzICAgZEZkeEZpbmUoZjY0dmVjMyk7ZjY0dmVjNCAgIGRGZHhGaW5lKGY2NHZlYzQpO2Zsb2F0NjRfdCBkRmR5RmluZShmbG9hdDY0X3QpO2Y2NHZlYzIgICBkRmR5RmluZShmNjR2ZWMyKTtmNjR2ZWMzICAgZEZkeUZpbmUoZjY0dmVjMyk7ZjY0dmVjNCAgIGRGZHlGaW5lKGY2NHZlYzQpO2Zsb2F0NjRfdCBkRmR4Q29hcnNlKGZsb2F0NjRfdCk7ZjY0dmVjMiAgIGRGZHhDb2Fyc2UoZjY0dmVjMik7ZjY0dmVjMyAgIGRGZHhDb2Fyc2UoZjY0dmVjMyk7ZjY0dmVjNCAgIGRGZHhDb2Fyc2UoZjY0dmVjNCk7ZmxvYXQ2NF90IGRGZHlDb2Fyc2UoZmxvYXQ2NF90KTtmNjR2ZWMyICAgZEZkeUNvYXJzZShmNjR2ZWMyKTtmNjR2ZWMzICAgZEZkeUNvYXJzZShmNjR2ZWMzKTtmNjR2ZWM0ICAgZEZkeUNvYXJzZShmNjR2ZWM0KTtmbG9hdDY0X3QgZndpZHRoKGZsb2F0NjRfdCk7ZjY0dmVjMiAgIGZ3aWR0aChmNjR2ZWMyKTtmNjR2ZWMzICAgZndpZHRoKGY2NHZlYzMpO2Y2NHZlYzQgICBmd2lkdGgoZjY0dmVjNCk7ZmxvYXQ2NF90IGZ3aWR0aEZpbmUoZmxvYXQ2NF90KTtmNjR2ZWMyICAgZndpZHRoRmluZShmNjR2ZWMyKTtmNjR2ZWMzICAgZndpZHRoRmluZShmNjR2ZWMzKTtmNjR2ZWM0ICAgZndpZHRoRmluZShmNjR2ZWM0KTtmbG9hdDY0X3QgZndpZHRoQ29hcnNlKGZsb2F0NjRfdCk7ZjY0dmVjMiAgIGZ3aWR0aENvYXJzZShmNjR2ZWMyKTtmNjR2ZWMzICAgZndpZHRoQ29hcnNlKGY2NHZlYzMpO2Y2NHZlYzQgICBmd2lkdGhDb2Fyc2UoZjY0dmVjNCk7AGRvdWJsZSBzcXJ0KGRvdWJsZSk7ZHZlYzIgIHNxcnQoZHZlYzIpO2R2ZWMzICBzcXJ0KGR2ZWMzKTtkdmVjNCAgc3FydChkdmVjNCk7ZG91YmxlIGludmVyc2VzcXJ0KGRvdWJsZSk7ZHZlYzIgIGludmVyc2VzcXJ0KGR2ZWMyKTtkdmVjMyAgaW52ZXJzZXNxcnQoZHZlYzMpO2R2ZWM0ICBpbnZlcnNlc3FydChkdmVjNCk7ZG91YmxlIGFicyhkb3VibGUpO2R2ZWMyICBhYnMoZHZlYzIpO2R2ZWMzICBhYnMoZHZlYzMpO2R2ZWM0ICBhYnMoZHZlYzQpO2RvdWJsZSBzaWduKGRvdWJsZSk7ZHZlYzIgIHNpZ24oZHZlYzIpO2R2ZWMzICBzaWduKGR2ZWMzKTtkdmVjNCAgc2lnbihkdmVjNCk7ZG91YmxlIGZsb29yKGRvdWJsZSk7ZHZlYzIgIGZsb29yKGR2ZWMyKTtkdmVjMyAgZmxvb3IoZHZlYzMpO2R2ZWM0ICBmbG9vcihkdmVjNCk7ZG91YmxlIHRydW5jKGRvdWJsZSk7ZHZlYzIgIHRydW5jKGR2ZWMyKTtkdmVjMyAgdHJ1bmMoZHZlYzMpO2R2ZWM0ICB0cnVuYyhkdmVjNCk7ZG91YmxlIHJvdW5kKGRvdWJsZSk7ZHZlYzIgIHJvdW5kKGR2ZWMyKTtkdmVjMyAgcm91bmQoZHZlYzMpO2R2ZWM0ICByb3VuZChkdmVjNCk7ZG91YmxlIHJvdW5kRXZlbihkb3VibGUpO2R2ZWMyICByb3VuZEV2ZW4oZHZlYzIpO2R2ZWMzICByb3VuZEV2ZW4oZHZlYzMpO2R2ZWM0ICByb3VuZEV2ZW4oZHZlYzQpO2RvdWJsZSBjZWlsKGRvdWJsZSk7ZHZlYzIgIGNlaWwoZHZlYzIpO2R2ZWMzICBjZWlsKGR2ZWMzKTtkdmVjNCAgY2VpbChkdmVjNCk7ZG91YmxlIGZyYWN0KGRvdWJsZSk7ZHZlYzIgIGZyYWN0KGR2ZWMyKTtkdmVjMyAgZnJhY3QoZHZlYzMpO2R2ZWM0ICBmcmFjdChkdmVjNCk7ZG91YmxlIG1vZChkb3VibGUsIGRvdWJsZSk7ZHZlYzIgIG1vZChkdmVjMiAsIGRvdWJsZSk7ZHZlYzMgIG1vZChkdmVjMyAsIGRvdWJsZSk7ZHZlYzQgIG1vZChkdmVjNCAsIGRvdWJsZSk7ZHZlYzIgIG1vZChkdmVjMiAsIGR2ZWMyKTtkdmVjMyAgbW9kKGR2ZWMzICwgZHZlYzMpO2R2ZWM0ICBtb2QoZHZlYzQgLCBkdmVjNCk7ZG91YmxlIG1vZGYoZG91YmxlLCBvdXQgZG91YmxlKTtkdmVjMiAgbW9kZihkdmVjMiwgIG91dCBkdmVjMik7ZHZlYzMgIG1vZGYoZHZlYzMsICBvdXQgZHZlYzMpO2R2ZWM0ICBtb2RmKGR2ZWM0LCAgb3V0IGR2ZWM0KTtkb3VibGUgbWluKGRvdWJsZSwgZG91YmxlKTtkdmVjMiAgbWluKGR2ZWMyLCAgZG91YmxlKTtkdmVjMyAgbWluKGR2ZWMzLCAgZG91YmxlKTtkdmVjNCAgbWluKGR2ZWM0LCAgZG91YmxlKTtkdmVjMiAgbWluKGR2ZWMyLCAgZHZlYzIpO2R2ZWMzICBtaW4oZHZlYzMsICBkdmVjMyk7ZHZlYzQgIG1pbihkdmVjNCwgIGR2ZWM0KTtkb3VibGUgbWF4KGRvdWJsZSwgZG91YmxlKTtkdmVjMiAgbWF4KGR2ZWMyICwgZG91YmxlKTtkdmVjMyAgbWF4KGR2ZWMzICwgZG91YmxlKTtkdmVjNCAgbWF4KGR2ZWM0ICwgZG91YmxlKTtkdmVjMiAgbWF4KGR2ZWMyICwgZHZlYzIpO2R2ZWMzICBtYXgoZHZlYzMgLCBkdmVjMyk7ZHZlYzQgIG1heChkdmVjNCAsIGR2ZWM0KTtkb3VibGUgY2xhbXAoZG91YmxlLCBkb3VibGUsIGRvdWJsZSk7ZHZlYzIgIGNsYW1wKGR2ZWMyICwgZG91YmxlLCBkb3VibGUpO2R2ZWMzICBjbGFtcChkdmVjMyAsIGRvdWJsZSwgZG91YmxlKTtkdmVjNCAgY2xhbXAoZHZlYzQgLCBkb3VibGUsIGRvdWJsZSk7ZHZlYzIgIGNsYW1wKGR2ZWMyICwgZHZlYzIgLCBkdmVjMik7ZHZlYzMgIGNsYW1wKGR2ZWMzICwgZHZlYzMgLCBkdmVjMyk7ZHZlYzQgIGNsYW1wKGR2ZWM0ICwgZHZlYzQgLCBkdmVjNCk7ZG91YmxlIG1peChkb3VibGUsIGRvdWJsZSwgZG91YmxlKTtkdmVjMiAgbWl4KGR2ZWMyLCAgZHZlYzIsICBkb3VibGUpO2R2ZWMzICBtaXgoZHZlYzMsICBkdmVjMywgIGRvdWJsZSk7ZHZlYzQgIG1peChkdmVjNCwgIGR2ZWM0LCAgZG91YmxlKTtkdmVjMiAgbWl4KGR2ZWMyLCAgZHZlYzIsICBkdmVjMik7ZHZlYzMgIG1peChkdmVjMywgIGR2ZWMzLCAgZHZlYzMpO2R2ZWM0ICBtaXgoZHZlYzQsICBkdmVjNCwgIGR2ZWM0KTtkb3VibGUgbWl4KGRvdWJsZSwgZG91YmxlLCBib29sKTtkdmVjMiAgbWl4KGR2ZWMyLCAgZHZlYzIsICBidmVjMik7ZHZlYzMgIG1peChkdmVjMywgIGR2ZWMzLCAgYnZlYzMpO2R2ZWM0ICBtaXgoZHZlYzQsICBkdmVjNCwgIGJ2ZWM0KTtkb3VibGUgc3RlcChkb3VibGUsIGRvdWJsZSk7ZHZlYzIgIHN0ZXAoZHZlYzIgLCBkdmVjMik7ZHZlYzMgIHN0ZXAoZHZlYzMgLCBkdmVjMyk7ZHZlYzQgIHN0ZXAoZHZlYzQgLCBkdmVjNCk7ZHZlYzIgIHN0ZXAoZG91YmxlLCBkdmVjMik7ZHZlYzMgIHN0ZXAoZG91YmxlLCBkdmVjMyk7ZHZlYzQgIHN0ZXAoZG91YmxlLCBkdmVjNCk7ZG91YmxlIHNtb290aHN0ZXAoZG91YmxlLCBkb3VibGUsIGRvdWJsZSk7ZHZlYzIgIHNtb290aHN0ZXAoZHZlYzIgLCBkdmVjMiAsIGR2ZWMyKTtkdmVjMyAgc21vb3Roc3RlcChkdmVjMyAsIGR2ZWMzICwgZHZlYzMpO2R2ZWM0ICBzbW9vdGhzdGVwKGR2ZWM0ICwgZHZlYzQgLCBkdmVjNCk7ZHZlYzIgIHNtb290aHN0ZXAoZG91YmxlLCBkb3VibGUsIGR2ZWMyKTtkdmVjMyAgc21vb3Roc3RlcChkb3VibGUsIGRvdWJsZSwgZHZlYzMpO2R2ZWM0ICBzbW9vdGhzdGVwKGRvdWJsZSwgZG91YmxlLCBkdmVjNCk7Ym9vbCAgaXNuYW4oZG91YmxlKTtidmVjMiBpc25hbihkdmVjMik7YnZlYzMgaXNuYW4oZHZlYzMpO2J2ZWM0IGlzbmFuKGR2ZWM0KTtib29sICBpc2luZihkb3VibGUpO2J2ZWMyIGlzaW5mKGR2ZWMyKTtidmVjMyBpc2luZihkdmVjMyk7YnZlYzQgaXNpbmYoZHZlYzQpO2RvdWJsZSBsZW5ndGgoZG91YmxlKTtkb3VibGUgbGVuZ3RoKGR2ZWMyKTtkb3VibGUgbGVuZ3RoKGR2ZWMzKTtkb3VibGUgbGVuZ3RoKGR2ZWM0KTtkb3VibGUgZGlzdGFuY2UoZG91YmxlLCBkb3VibGUpO2RvdWJsZSBkaXN0YW5jZShkdmVjMiAsIGR2ZWMyKTtkb3VibGUgZGlzdGFuY2UoZHZlYzMgLCBkdmVjMyk7ZG91YmxlIGRpc3RhbmNlKGR2ZWM0ICwgZHZlYzQpO2RvdWJsZSBkb3QoZG91YmxlLCBkb3VibGUpO2RvdWJsZSBkb3QoZHZlYzIgLCBkdmVjMik7ZG91YmxlIGRvdChkdmVjMyAsIGR2ZWMzKTtkb3VibGUgZG90KGR2ZWM0ICwgZHZlYzQpO2R2ZWMzIGNyb3NzKGR2ZWMzLCBkdmVjMyk7ZG91YmxlIG5vcm1hbGl6ZShkb3VibGUpO2R2ZWMyICBub3JtYWxpemUoZHZlYzIpO2R2ZWMzICBub3JtYWxpemUoZHZlYzMpO2R2ZWM0ICBub3JtYWxpemUoZHZlYzQpO2RvdWJsZSBmYWNlZm9yd2FyZChkb3VibGUsIGRvdWJsZSwgZG91YmxlKTtkdmVjMiAgZmFjZWZvcndhcmQoZHZlYzIsICBkdmVjMiwgIGR2ZWMyKTtkdmVjMyAgZmFjZWZvcndhcmQoZHZlYzMsICBkdmVjMywgIGR2ZWMzKTtkdmVjNCAgZmFjZWZvcndhcmQoZHZlYzQsICBkdmVjNCwgIGR2ZWM0KTtkb3VibGUgcmVmbGVjdChkb3VibGUsIGRvdWJsZSk7ZHZlYzIgIHJlZmxlY3QoZHZlYzIgLCBkdmVjMiApO2R2ZWMzICByZWZsZWN0KGR2ZWMzICwgZHZlYzMgKTtkdmVjNCAgcmVmbGVjdChkdmVjNCAsIGR2ZWM0ICk7ZG91YmxlIHJlZnJhY3QoZG91YmxlLCBkb3VibGUsIGRvdWJsZSk7ZHZlYzIgIHJlZnJhY3QoZHZlYzIgLCBkdmVjMiAsIGRvdWJsZSk7ZHZlYzMgIHJlZnJhY3QoZHZlYzMgLCBkdmVjMyAsIGRvdWJsZSk7ZHZlYzQgIHJlZnJhY3QoZHZlYzQgLCBkdmVjNCAsIGRvdWJsZSk7ZG1hdDIgbWF0cml4Q29tcE11bHQoZG1hdDIsIGRtYXQyKTtkbWF0MyBtYXRyaXhDb21wTXVsdChkbWF0MywgZG1hdDMpO2RtYXQ0IG1hdHJpeENvbXBNdWx0KGRtYXQ0LCBkbWF0NCk7ZG1hdDJ4MyBtYXRyaXhDb21wTXVsdChkbWF0MngzLCBkbWF0MngzKTtkbWF0Mng0IG1hdHJpeENvbXBNdWx0KGRtYXQyeDQsIGRtYXQyeDQpO2RtYXQzeDIgbWF0cml4Q29tcE11bHQoZG1hdDN4MiwgZG1hdDN4Mik7ZG1hdDN4NCBtYXRyaXhDb21wTXVsdChkbWF0M3g0LCBkbWF0M3g0KTtkbWF0NHgyIG1hdHJpeENvbXBNdWx0KGRtYXQ0eDIsIGRtYXQ0eDIpO2RtYXQ0eDMgbWF0cml4Q29tcE11bHQoZG1hdDR4MywgZG1hdDR4Myk7ZG1hdDIgICBvdXRlclByb2R1Y3QoZHZlYzIsIGR2ZWMyKTtkbWF0MyAgIG91dGVyUHJvZHVjdChkdmVjMywgZHZlYzMpO2RtYXQ0ICAgb3V0ZXJQcm9kdWN0KGR2ZWM0LCBkdmVjNCk7ZG1hdDJ4MyBvdXRlclByb2R1Y3QoZHZlYzMsIGR2ZWMyKTtkbWF0M3gyIG91dGVyUHJvZHVjdChkdmVjMiwgZHZlYzMpO2RtYXQyeDQgb3V0ZXJQcm9kdWN0KGR2ZWM0LCBkdmVjMik7ZG1hdDR4MiBvdXRlclByb2R1Y3QoZHZlYzIsIGR2ZWM0KTtkbWF0M3g0IG91dGVyUHJvZHVjdChkdmVjNCwgZHZlYzMpO2RtYXQ0eDMgb3V0ZXJQcm9kdWN0KGR2ZWMzLCBkdmVjNCk7ZG1hdDIgICB0cmFuc3Bvc2UoZG1hdDIpO2RtYXQzICAgdHJhbnNwb3NlKGRtYXQzKTtkbWF0NCAgIHRyYW5zcG9zZShkbWF0NCk7ZG1hdDJ4MyB0cmFuc3Bvc2UoZG1hdDN4Mik7ZG1hdDN4MiB0cmFuc3Bvc2UoZG1hdDJ4Myk7ZG1hdDJ4NCB0cmFuc3Bvc2UoZG1hdDR4Mik7ZG1hdDR4MiB0cmFuc3Bvc2UoZG1hdDJ4NCk7ZG1hdDN4NCB0cmFuc3Bvc2UoZG1hdDR4Myk7ZG1hdDR4MyB0cmFuc3Bvc2UoZG1hdDN4NCk7ZG91YmxlIGRldGVybWluYW50KGRtYXQyKTtkb3VibGUgZGV0ZXJtaW5hbnQoZG1hdDMpO2RvdWJsZSBkZXRlcm1pbmFudChkbWF0NCk7ZG1hdDIgaW52ZXJzZShkbWF0Mik7ZG1hdDMgaW52ZXJzZShkbWF0Myk7ZG1hdDQgaW52ZXJzZShkbWF0NCk7YnZlYzIgbGVzc1RoYW4oZHZlYzIsIGR2ZWMyKTtidmVjMyBsZXNzVGhhbihkdmVjMywgZHZlYzMpO2J2ZWM0IGxlc3NUaGFuKGR2ZWM0LCBkdmVjNCk7YnZlYzIgbGVzc1RoYW5FcXVhbChkdmVjMiwgZHZlYzIpO2J2ZWMzIGxlc3NUaGFuRXF1YWwoZHZlYzMsIGR2ZWMzKTtidmVjNCBsZXNzVGhhbkVxdWFsKGR2ZWM0LCBkdmVjNCk7YnZlYzIgZ3JlYXRlclRoYW4oZHZlYzIsIGR2ZWMyKTtidmVjMyBncmVhdGVyVGhhbihkdmVjMywgZHZlYzMpO2J2ZWM0IGdyZWF0ZXJUaGFuKGR2ZWM0LCBkdmVjNCk7YnZlYzIgZ3JlYXRlclRoYW5FcXVhbChkdmVjMiwgZHZlYzIpO2J2ZWMzIGdyZWF0ZXJUaGFuRXF1YWwoZHZlYzMsIGR2ZWMzKTtidmVjNCBncmVhdGVyVGhhbkVxdWFsKGR2ZWM0LCBkdmVjNCk7YnZlYzIgZXF1YWwoZHZlYzIsIGR2ZWMyKTtidmVjMyBlcXVhbChkdmVjMywgZHZlYzMpO2J2ZWM0IGVxdWFsKGR2ZWM0LCBkdmVjNCk7YnZlYzIgbm90RXF1YWwoZHZlYzIsIGR2ZWMyKTtidmVjMyBub3RFcXVhbChkdmVjMywgZHZlYzMpO2J2ZWM0IG5vdEVxdWFsKGR2ZWM0LCBkdmVjNCk7CgBpbnQ2NF90IGFicyhpbnQ2NF90KTtpNjR2ZWMyIGFicyhpNjR2ZWMyKTtpNjR2ZWMzIGFicyhpNjR2ZWMzKTtpNjR2ZWM0IGFicyhpNjR2ZWM0KTtpbnQ2NF90IHNpZ24oaW50NjRfdCk7aTY0dmVjMiBzaWduKGk2NHZlYzIpO2k2NHZlYzMgc2lnbihpNjR2ZWMzKTtpNjR2ZWM0IHNpZ24oaTY0dmVjNCk7aW50NjRfdCAgbWluKGludDY0X3QsICBpbnQ2NF90KTtpNjR2ZWMyICBtaW4oaTY0dmVjMiwgIGludDY0X3QpO2k2NHZlYzMgIG1pbihpNjR2ZWMzLCAgaW50NjRfdCk7aTY0dmVjNCAgbWluKGk2NHZlYzQsICBpbnQ2NF90KTtpNjR2ZWMyICBtaW4oaTY0dmVjMiwgIGk2NHZlYzIpO2k2NHZlYzMgIG1pbihpNjR2ZWMzLCAgaTY0dmVjMyk7aTY0dmVjNCAgbWluKGk2NHZlYzQsICBpNjR2ZWM0KTt1aW50NjRfdCBtaW4odWludDY0X3QsIHVpbnQ2NF90KTt1NjR2ZWMyICBtaW4odTY0dmVjMiwgIHVpbnQ2NF90KTt1NjR2ZWMzICBtaW4odTY0dmVjMywgIHVpbnQ2NF90KTt1NjR2ZWM0ICBtaW4odTY0dmVjNCwgIHVpbnQ2NF90KTt1NjR2ZWMyICBtaW4odTY0dmVjMiwgIHU2NHZlYzIpO3U2NHZlYzMgIG1pbih1NjR2ZWMzLCAgdTY0dmVjMyk7dTY0dmVjNCAgbWluKHU2NHZlYzQsICB1NjR2ZWM0KTtpbnQ2NF90ICBtYXgoaW50NjRfdCwgIGludDY0X3QpO2k2NHZlYzIgIG1heChpNjR2ZWMyLCAgaW50NjRfdCk7aTY0dmVjMyAgbWF4KGk2NHZlYzMsICBpbnQ2NF90KTtpNjR2ZWM0ICBtYXgoaTY0dmVjNCwgIGludDY0X3QpO2k2NHZlYzIgIG1heChpNjR2ZWMyLCAgaTY0dmVjMik7aTY0dmVjMyAgbWF4KGk2NHZlYzMsICBpNjR2ZWMzKTtpNjR2ZWM0ICBtYXgoaTY0dmVjNCwgIGk2NHZlYzQpO3VpbnQ2NF90IG1heCh1aW50NjRfdCwgdWludDY0X3QpO3U2NHZlYzIgIG1heCh1NjR2ZWMyLCAgdWludDY0X3QpO3U2NHZlYzMgIG1heCh1NjR2ZWMzLCAgdWludDY0X3QpO3U2NHZlYzQgIG1heCh1NjR2ZWM0LCAgdWludDY0X3QpO3U2NHZlYzIgIG1heCh1NjR2ZWMyLCAgdTY0dmVjMik7dTY0dmVjMyAgbWF4KHU2NHZlYzMsICB1NjR2ZWMzKTt1NjR2ZWM0ICBtYXgodTY0dmVjNCwgIHU2NHZlYzQpO2ludDY0X3QgIGNsYW1wKGludDY0X3QsICBpbnQ2NF90LCAgaW50NjRfdCk7aTY0dmVjMiAgY2xhbXAoaTY0dmVjMiwgIGludDY0X3QsICBpbnQ2NF90KTtpNjR2ZWMzICBjbGFtcChpNjR2ZWMzLCAgaW50NjRfdCwgIGludDY0X3QpO2k2NHZlYzQgIGNsYW1wKGk2NHZlYzQsICBpbnQ2NF90LCAgaW50NjRfdCk7aTY0dmVjMiAgY2xhbXAoaTY0dmVjMiwgIGk2NHZlYzIsICBpNjR2ZWMyKTtpNjR2ZWMzICBjbGFtcChpNjR2ZWMzLCAgaTY0dmVjMywgIGk2NHZlYzMpO2k2NHZlYzQgIGNsYW1wKGk2NHZlYzQsICBpNjR2ZWM0LCAgaTY0dmVjNCk7dWludDY0X3QgY2xhbXAodWludDY0X3QsIHVpbnQ2NF90LCB1aW50NjRfdCk7dTY0dmVjMiAgY2xhbXAodTY0dmVjMiwgIHVpbnQ2NF90LCB1aW50NjRfdCk7dTY0dmVjMyAgY2xhbXAodTY0dmVjMywgIHVpbnQ2NF90LCB1aW50NjRfdCk7dTY0dmVjNCAgY2xhbXAodTY0dmVjNCwgIHVpbnQ2NF90LCB1aW50NjRfdCk7dTY0dmVjMiAgY2xhbXAodTY0dmVjMiwgIHU2NHZlYzIsICB1NjR2ZWMyKTt1NjR2ZWMzICBjbGFtcCh1NjR2ZWMzLCAgdTY0dmVjMywgIHU2NHZlYzMpO3U2NHZlYzQgIGNsYW1wKHU2NHZlYzQsICB1NjR2ZWM0LCAgdTY0dmVjNCk7aW50NjRfdCAgbWl4KGludDY0X3QsICBpbnQ2NF90LCAgYm9vbCk7aTY0dmVjMiAgbWl4KGk2NHZlYzIsICBpNjR2ZWMyLCAgYnZlYzIpO2k2NHZlYzMgIG1peChpNjR2ZWMzLCAgaTY0dmVjMywgIGJ2ZWMzKTtpNjR2ZWM0ICBtaXgoaTY0dmVjNCwgIGk2NHZlYzQsICBidmVjNCk7dWludDY0X3QgbWl4KHVpbnQ2NF90LCB1aW50NjRfdCwgYm9vbCk7dTY0dmVjMiAgbWl4KHU2NHZlYzIsICB1NjR2ZWMyLCAgYnZlYzIpO3U2NHZlYzMgIG1peCh1NjR2ZWMzLCAgdTY0dmVjMywgIGJ2ZWMzKTt1NjR2ZWM0ICBtaXgodTY0dmVjNCwgIHU2NHZlYzQsICBidmVjNCk7aW50NjRfdCBkb3VibGVCaXRzVG9JbnQ2NChkb3VibGUpO2k2NHZlYzIgZG91YmxlQml0c1RvSW50NjQoZHZlYzIpO2k2NHZlYzMgZG91YmxlQml0c1RvSW50NjQoZHZlYzMpO2k2NHZlYzQgZG91YmxlQml0c1RvSW50NjQoZHZlYzQpO3VpbnQ2NF90IGRvdWJsZUJpdHNUb1VpbnQ2NChkb3VibGUpO3U2NHZlYzIgIGRvdWJsZUJpdHNUb1VpbnQ2NChkdmVjMik7dTY0dmVjMyAgZG91YmxlQml0c1RvVWludDY0KGR2ZWMzKTt1NjR2ZWM0ICBkb3VibGVCaXRzVG9VaW50NjQoZHZlYzQpO2RvdWJsZSBpbnQ2NEJpdHNUb0RvdWJsZShpbnQ2NF90KTtkdmVjMiAgaW50NjRCaXRzVG9Eb3VibGUoaTY0dmVjMik7ZHZlYzMgIGludDY0Qml0c1RvRG91YmxlKGk2NHZlYzMpO2R2ZWM0ICBpbnQ2NEJpdHNUb0RvdWJsZShpNjR2ZWM0KTtkb3VibGUgdWludDY0Qml0c1RvRG91YmxlKHVpbnQ2NF90KTtkdmVjMiAgdWludDY0Qml0c1RvRG91YmxlKHU2NHZlYzIpO2R2ZWMzICB1aW50NjRCaXRzVG9Eb3VibGUodTY0dmVjMyk7ZHZlYzQgIHVpbnQ2NEJpdHNUb0RvdWJsZSh1NjR2ZWM0KTtpbnQ2NF90ICBwYWNrSW50MngzMihpdmVjMik7dWludDY0X3QgcGFja1VpbnQyeDMyKHV2ZWMyKTtpdmVjMiAgICB1bnBhY2tJbnQyeDMyKGludDY0X3QpO3V2ZWMyICAgIHVucGFja1VpbnQyeDMyKHVpbnQ2NF90KTtidmVjMiBsZXNzVGhhbihpNjR2ZWMyLCBpNjR2ZWMyKTtidmVjMyBsZXNzVGhhbihpNjR2ZWMzLCBpNjR2ZWMzKTtidmVjNCBsZXNzVGhhbihpNjR2ZWM0LCBpNjR2ZWM0KTtidmVjMiBsZXNzVGhhbih1NjR2ZWMyLCB1NjR2ZWMyKTtidmVjMyBsZXNzVGhhbih1NjR2ZWMzLCB1NjR2ZWMzKTtidmVjNCBsZXNzVGhhbih1NjR2ZWM0LCB1NjR2ZWM0KTtidmVjMiBsZXNzVGhhbkVxdWFsKGk2NHZlYzIsIGk2NHZlYzIpO2J2ZWMzIGxlc3NUaGFuRXF1YWwoaTY0dmVjMywgaTY0dmVjMyk7YnZlYzQgbGVzc1RoYW5FcXVhbChpNjR2ZWM0LCBpNjR2ZWM0KTtidmVjMiBsZXNzVGhhbkVxdWFsKHU2NHZlYzIsIHU2NHZlYzIpO2J2ZWMzIGxlc3NUaGFuRXF1YWwodTY0dmVjMywgdTY0dmVjMyk7YnZlYzQgbGVzc1RoYW5FcXVhbCh1NjR2ZWM0LCB1NjR2ZWM0KTtidmVjMiBncmVhdGVyVGhhbihpNjR2ZWMyLCBpNjR2ZWMyKTtidmVjMyBncmVhdGVyVGhhbihpNjR2ZWMzLCBpNjR2ZWMzKTtidmVjNCBncmVhdGVyVGhhbihpNjR2ZWM0LCBpNjR2ZWM0KTtidmVjMiBncmVhdGVyVGhhbih1NjR2ZWMyLCB1NjR2ZWMyKTtidmVjMyBncmVhdGVyVGhhbih1NjR2ZWMzLCB1NjR2ZWMzKTtidmVjNCBncmVhdGVyVGhhbih1NjR2ZWM0LCB1NjR2ZWM0KTtidmVjMiBncmVhdGVyVGhhbkVxdWFsKGk2NHZlYzIsIGk2NHZlYzIpO2J2ZWMzIGdyZWF0ZXJUaGFuRXF1YWwoaTY0dmVjMywgaTY0dmVjMyk7YnZlYzQgZ3JlYXRlclRoYW5FcXVhbChpNjR2ZWM0LCBpNjR2ZWM0KTtidmVjMiBncmVhdGVyVGhhbkVxdWFsKHU2NHZlYzIsIHU2NHZlYzIpO2J2ZWMzIGdyZWF0ZXJUaGFuRXF1YWwodTY0dmVjMywgdTY0dmVjMyk7YnZlYzQgZ3JlYXRlclRoYW5FcXVhbCh1NjR2ZWM0LCB1NjR2ZWM0KTtidmVjMiBlcXVhbChpNjR2ZWMyLCBpNjR2ZWMyKTtidmVjMyBlcXVhbChpNjR2ZWMzLCBpNjR2ZWMzKTtidmVjNCBlcXVhbChpNjR2ZWM0LCBpNjR2ZWM0KTtidmVjMiBlcXVhbCh1NjR2ZWMyLCB1NjR2ZWMyKTtidmVjMyBlcXVhbCh1NjR2ZWMzLCB1NjR2ZWMzKTtidmVjNCBlcXVhbCh1NjR2ZWM0LCB1NjR2ZWM0KTtidmVjMiBub3RFcXVhbChpNjR2ZWMyLCBpNjR2ZWMyKTtidmVjMyBub3RFcXVhbChpNjR2ZWMzLCBpNjR2ZWMzKTtidmVjNCBub3RFcXVhbChpNjR2ZWM0LCBpNjR2ZWM0KTtidmVjMiBub3RFcXVhbCh1NjR2ZWMyLCB1NjR2ZWMyKTtidmVjMyBub3RFcXVhbCh1NjR2ZWMzLCB1NjR2ZWMzKTtidmVjNCBub3RFcXVhbCh1NjR2ZWM0LCB1NjR2ZWM0KTtpbnQ2NF90IGZpbmRMU0IoaW50NjRfdCk7aTY0dmVjMiBmaW5kTFNCKGk2NHZlYzIpO2k2NHZlYzMgZmluZExTQihpNjR2ZWMzKTtpNjR2ZWM0IGZpbmRMU0IoaTY0dmVjNCk7aW50NjRfdCBmaW5kTFNCKHVpbnQ2NF90KTtpNjR2ZWMyIGZpbmRMU0IodTY0dmVjMik7aTY0dmVjMyBmaW5kTFNCKHU2NHZlYzMpO2k2NHZlYzQgZmluZExTQih1NjR2ZWM0KTtpbnQ2NF90IGZpbmRNU0IoaW50NjRfdCk7aTY0dmVjMiBmaW5kTVNCKGk2NHZlYzIpO2k2NHZlYzMgZmluZE1TQihpNjR2ZWMzKTtpNjR2ZWM0IGZpbmRNU0IoaTY0dmVjNCk7aW50NjRfdCBmaW5kTVNCKHVpbnQ2NF90KTtpNjR2ZWMyIGZpbmRNU0IodTY0dmVjMik7aTY0dmVjMyBmaW5kTVNCKHU2NHZlYzMpO2k2NHZlYzQgZmluZE1TQih1NjR2ZWM0KTsKAGZsb2F0IG1pbjMoZmxvYXQsIGZsb2F0LCBmbG9hdCk7dmVjMiAgbWluMyh2ZWMyLCAgdmVjMiwgIHZlYzIpO3ZlYzMgIG1pbjModmVjMywgIHZlYzMsICB2ZWMzKTt2ZWM0ICBtaW4zKHZlYzQsICB2ZWM0LCAgdmVjNCk7aW50ICAgbWluMyhpbnQsICAgaW50LCAgIGludCk7aXZlYzIgbWluMyhpdmVjMiwgaXZlYzIsIGl2ZWMyKTtpdmVjMyBtaW4zKGl2ZWMzLCBpdmVjMywgaXZlYzMpO2l2ZWM0IG1pbjMoaXZlYzQsIGl2ZWM0LCBpdmVjNCk7dWludCAgbWluMyh1aW50LCAgdWludCwgIHVpbnQpO3V2ZWMyIG1pbjModXZlYzIsIHV2ZWMyLCB1dmVjMik7dXZlYzMgbWluMyh1dmVjMywgdXZlYzMsIHV2ZWMzKTt1dmVjNCBtaW4zKHV2ZWM0LCB1dmVjNCwgdXZlYzQpO2Zsb2F0IG1heDMoZmxvYXQsIGZsb2F0LCBmbG9hdCk7dmVjMiAgbWF4Myh2ZWMyLCAgdmVjMiwgIHZlYzIpO3ZlYzMgIG1heDModmVjMywgIHZlYzMsICB2ZWMzKTt2ZWM0ICBtYXgzKHZlYzQsICB2ZWM0LCAgdmVjNCk7aW50ICAgbWF4MyhpbnQsICAgaW50LCAgIGludCk7aXZlYzIgbWF4MyhpdmVjMiwgaXZlYzIsIGl2ZWMyKTtpdmVjMyBtYXgzKGl2ZWMzLCBpdmVjMywgaXZlYzMpO2l2ZWM0IG1heDMoaXZlYzQsIGl2ZWM0LCBpdmVjNCk7dWludCAgbWF4Myh1aW50LCAgdWludCwgIHVpbnQpO3V2ZWMyIG1heDModXZlYzIsIHV2ZWMyLCB1dmVjMik7dXZlYzMgbWF4Myh1dmVjMywgdXZlYzMsIHV2ZWMzKTt1dmVjNCBtYXgzKHV2ZWM0LCB1dmVjNCwgdXZlYzQpO2Zsb2F0IG1pZDMoZmxvYXQsIGZsb2F0LCBmbG9hdCk7dmVjMiAgbWlkMyh2ZWMyLCAgdmVjMiwgIHZlYzIpO3ZlYzMgIG1pZDModmVjMywgIHZlYzMsICB2ZWMzKTt2ZWM0ICBtaWQzKHZlYzQsICB2ZWM0LCAgdmVjNCk7aW50ICAgbWlkMyhpbnQsICAgaW50LCAgIGludCk7aXZlYzIgbWlkMyhpdmVjMiwgaXZlYzIsIGl2ZWMyKTtpdmVjMyBtaWQzKGl2ZWMzLCBpdmVjMywgaXZlYzMpO2l2ZWM0IG1pZDMoaXZlYzQsIGl2ZWM0LCBpdmVjNCk7dWludCAgbWlkMyh1aW50LCAgdWludCwgIHVpbnQpO3V2ZWMyIG1pZDModXZlYzIsIHV2ZWMyLCB1dmVjMik7dXZlYzMgbWlkMyh1dmVjMywgdXZlYzMsIHV2ZWMzKTt1dmVjNCBtaWQzKHV2ZWM0LCB1dmVjNCwgdXZlYzQpO2Zsb2F0MTZfdCBtaW4zKGZsb2F0MTZfdCwgZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBtaW4zKGYxNnZlYzIsICAgZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgbWluMyhmMTZ2ZWMzLCAgIGYxNnZlYzMsICAgZjE2dmVjMyk7ZjE2dmVjNCAgIG1pbjMoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGYxNnZlYzQpO2Zsb2F0MTZfdCBtYXgzKGZsb2F0MTZfdCwgZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBtYXgzKGYxNnZlYzIsICAgZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgbWF4MyhmMTZ2ZWMzLCAgIGYxNnZlYzMsICAgZjE2dmVjMyk7ZjE2dmVjNCAgIG1heDMoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGYxNnZlYzQpO2Zsb2F0MTZfdCBtaWQzKGZsb2F0MTZfdCwgZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBtaWQzKGYxNnZlYzIsICAgZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgbWlkMyhmMTZ2ZWMzLCAgIGYxNnZlYzMsICAgZjE2dmVjMyk7ZjE2dmVjNCAgIG1pZDMoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGYxNnZlYzQpO2ludDE2X3QgICBtaW4zKGludDE2X3QsICAgaW50MTZfdCwgICBpbnQxNl90KTtpMTZ2ZWMyICAgbWluMyhpMTZ2ZWMyLCAgIGkxNnZlYzIsICAgaTE2dmVjMik7aTE2dmVjMyAgIG1pbjMoaTE2dmVjMywgICBpMTZ2ZWMzLCAgIGkxNnZlYzMpO2kxNnZlYzQgICBtaW4zKGkxNnZlYzQsICAgaTE2dmVjNCwgICBpMTZ2ZWM0KTtpbnQxNl90ICAgbWF4MyhpbnQxNl90LCAgIGludDE2X3QsICAgaW50MTZfdCk7aTE2dmVjMiAgIG1heDMoaTE2dmVjMiwgICBpMTZ2ZWMyLCAgIGkxNnZlYzIpO2kxNnZlYzMgICBtYXgzKGkxNnZlYzMsICAgaTE2dmVjMywgICBpMTZ2ZWMzKTtpMTZ2ZWM0ICAgbWF4MyhpMTZ2ZWM0LCAgIGkxNnZlYzQsICAgaTE2dmVjNCk7aW50MTZfdCAgIG1pZDMoaW50MTZfdCwgICBpbnQxNl90LCAgIGludDE2X3QpO2kxNnZlYzIgICBtaWQzKGkxNnZlYzIsICAgaTE2dmVjMiwgICBpMTZ2ZWMyKTtpMTZ2ZWMzICAgbWlkMyhpMTZ2ZWMzLCAgIGkxNnZlYzMsICAgaTE2dmVjMyk7aTE2dmVjNCAgIG1pZDMoaTE2dmVjNCwgICBpMTZ2ZWM0LCAgIGkxNnZlYzQpO3VpbnQxNl90ICBtaW4zKHVpbnQxNl90LCAgdWludDE2X3QsICB1aW50MTZfdCk7dTE2dmVjMiAgIG1pbjModTE2dmVjMiwgICB1MTZ2ZWMyLCAgIHUxNnZlYzIpO3UxNnZlYzMgICBtaW4zKHUxNnZlYzMsICAgdTE2dmVjMywgICB1MTZ2ZWMzKTt1MTZ2ZWM0ICAgbWluMyh1MTZ2ZWM0LCAgIHUxNnZlYzQsICAgdTE2dmVjNCk7dWludDE2X3QgIG1heDModWludDE2X3QsICB1aW50MTZfdCwgIHVpbnQxNl90KTt1MTZ2ZWMyICAgbWF4Myh1MTZ2ZWMyLCAgIHUxNnZlYzIsICAgdTE2dmVjMik7dTE2dmVjMyAgIG1heDModTE2dmVjMywgICB1MTZ2ZWMzLCAgIHUxNnZlYzMpO3UxNnZlYzQgICBtYXgzKHUxNnZlYzQsICAgdTE2dmVjNCwgICB1MTZ2ZWM0KTt1aW50MTZfdCAgbWlkMyh1aW50MTZfdCwgIHVpbnQxNl90LCAgdWludDE2X3QpO3UxNnZlYzIgICBtaWQzKHUxNnZlYzIsICAgdTE2dmVjMiwgICB1MTZ2ZWMyKTt1MTZ2ZWMzICAgbWlkMyh1MTZ2ZWMzLCAgIHUxNnZlYzMsICAgdTE2dmVjMyk7dTE2dmVjNCAgIG1pZDModTE2dmVjNCwgICB1MTZ2ZWM0LCAgIHUxNnZlYzQpOwoAdWludCBhdG9taWNBZGQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludCwgdWludCwgaW50LCBpbnQsIGludCk7IGludCBhdG9taWNBZGQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludCwgIGludCwgaW50LCBpbnQsIGludCk7dWludCBhdG9taWNNaW4oY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludCwgdWludCwgaW50LCBpbnQsIGludCk7IGludCBhdG9taWNNaW4oY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludCwgIGludCwgaW50LCBpbnQsIGludCk7dWludCBhdG9taWNNYXgoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludCwgdWludCwgaW50LCBpbnQsIGludCk7IGludCBhdG9taWNNYXgoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludCwgIGludCwgaW50LCBpbnQsIGludCk7dWludCBhdG9taWNBbmQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludCwgdWludCwgaW50LCBpbnQsIGludCk7IGludCBhdG9taWNBbmQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludCwgIGludCwgaW50LCBpbnQsIGludCk7dWludCBhdG9taWNPciAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludCwgdWludCwgaW50LCBpbnQsIGludCk7IGludCBhdG9taWNPciAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludCwgIGludCwgaW50LCBpbnQsIGludCk7dWludCBhdG9taWNYb3IoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludCwgdWludCwgaW50LCBpbnQsIGludCk7IGludCBhdG9taWNYb3IoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludCwgIGludCwgaW50LCBpbnQsIGludCk7dWludCBhdG9taWNFeGNoYW5nZShjb2hlcmVudCB2b2xhdGlsZSBpbm91dCB1aW50LCB1aW50LCBpbnQsIGludCwgaW50KTsgaW50IGF0b21pY0V4Y2hhbmdlKGNvaGVyZW50IHZvbGF0aWxlIGlub3V0ICBpbnQsICBpbnQsIGludCwgaW50LCBpbnQpO3VpbnQgYXRvbWljQ29tcFN3YXAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludCwgdWludCwgdWludCwgaW50LCBpbnQsIGludCwgaW50LCBpbnQpOyBpbnQgYXRvbWljQ29tcFN3YXAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludCwgIGludCwgIGludCwgaW50LCBpbnQsIGludCwgaW50LCBpbnQpO3VpbnQgYXRvbWljTG9hZChjb2hlcmVudCB2b2xhdGlsZSBpbiB1aW50LCBpbnQsIGludCwgaW50KTsgaW50IGF0b21pY0xvYWQoY29oZXJlbnQgdm9sYXRpbGUgaW4gIGludCwgaW50LCBpbnQsIGludCk7dm9pZCBhdG9taWNTdG9yZShjb2hlcmVudCB2b2xhdGlsZSBvdXQgdWludCwgdWludCwgaW50LCBpbnQsIGludCk7dm9pZCBhdG9taWNTdG9yZShjb2hlcmVudCB2b2xhdGlsZSBvdXQgIGludCwgIGludCwgaW50LCBpbnQsIGludCk7CgB1aW50NjRfdCBhdG9taWNNaW4oY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90KTsgaW50NjRfdCBhdG9taWNNaW4oY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90KTt1aW50NjRfdCBhdG9taWNNaW4oY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNNaW4oY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90LCBpbnQsIGludCwgaW50KTt1aW50NjRfdCBhdG9taWNNYXgoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90KTsgaW50NjRfdCBhdG9taWNNYXgoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90KTt1aW50NjRfdCBhdG9taWNNYXgoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNNYXgoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90LCBpbnQsIGludCwgaW50KTt1aW50NjRfdCBhdG9taWNBbmQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90KTsgaW50NjRfdCBhdG9taWNBbmQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90KTt1aW50NjRfdCBhdG9taWNBbmQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNBbmQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90LCBpbnQsIGludCwgaW50KTt1aW50NjRfdCBhdG9taWNPciAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90KTsgaW50NjRfdCBhdG9taWNPciAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90KTt1aW50NjRfdCBhdG9taWNPciAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNPciAoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90LCBpbnQsIGludCwgaW50KTt1aW50NjRfdCBhdG9taWNYb3IoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90KTsgaW50NjRfdCBhdG9taWNYb3IoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90KTt1aW50NjRfdCBhdG9taWNYb3IoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNYb3IoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90LCBpbnQsIGludCwgaW50KTt1aW50NjRfdCBhdG9taWNBZGQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90KTsgaW50NjRfdCBhdG9taWNBZGQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90KTt1aW50NjRfdCBhdG9taWNBZGQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNBZGQoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgIGludDY0X3QsICBpbnQ2NF90LCBpbnQsIGludCwgaW50KTt1aW50NjRfdCBhdG9taWNFeGNoYW5nZShjb2hlcmVudCB2b2xhdGlsZSBpbm91dCB1aW50NjRfdCwgdWludDY0X3QpOyBpbnQ2NF90IGF0b21pY0V4Y2hhbmdlKGNvaGVyZW50IHZvbGF0aWxlIGlub3V0ICBpbnQ2NF90LCAgaW50NjRfdCk7dWludDY0X3QgYXRvbWljRXhjaGFuZ2UoY29oZXJlbnQgdm9sYXRpbGUgaW5vdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNFeGNoYW5nZShjb2hlcmVudCB2b2xhdGlsZSBpbm91dCAgaW50NjRfdCwgIGludDY0X3QsIGludCwgaW50LCBpbnQpO3VpbnQ2NF90IGF0b21pY0NvbXBTd2FwKGNvaGVyZW50IHZvbGF0aWxlIGlub3V0IHVpbnQ2NF90LCB1aW50NjRfdCwgdWludDY0X3QpOyBpbnQ2NF90IGF0b21pY0NvbXBTd2FwKGNvaGVyZW50IHZvbGF0aWxlIGlub3V0ICBpbnQ2NF90LCAgaW50NjRfdCwgIGludDY0X3QpO3VpbnQ2NF90IGF0b21pY0NvbXBTd2FwKGNvaGVyZW50IHZvbGF0aWxlIGlub3V0IHVpbnQ2NF90LCB1aW50NjRfdCwgdWludDY0X3QsIGludCwgaW50LCBpbnQsIGludCwgaW50KTsgaW50NjRfdCBhdG9taWNDb21wU3dhcChjb2hlcmVudCB2b2xhdGlsZSBpbm91dCAgaW50NjRfdCwgIGludDY0X3QsICBpbnQ2NF90LCBpbnQsIGludCwgaW50LCBpbnQsIGludCk7dWludDY0X3QgYXRvbWljTG9hZChjb2hlcmVudCB2b2xhdGlsZSBpbiB1aW50NjRfdCwgaW50LCBpbnQsIGludCk7IGludDY0X3QgYXRvbWljTG9hZChjb2hlcmVudCB2b2xhdGlsZSBpbiAgaW50NjRfdCwgaW50LCBpbnQsIGludCk7dm9pZCBhdG9taWNTdG9yZShjb2hlcmVudCB2b2xhdGlsZSBvdXQgdWludDY0X3QsIHVpbnQ2NF90LCBpbnQsIGludCwgaW50KTt2b2lkIGF0b21pY1N0b3JlKGNvaGVyZW50IHZvbGF0aWxlIG91dCAgaW50NjRfdCwgIGludDY0X3QsIGludCwgaW50LCBpbnQpOwoAaW50ICAgZmxvYXRCaXRzVG9JbnQoaGlnaHAgZmxvYXQgdmFsdWUpO2l2ZWMyIGZsb2F0Qml0c1RvSW50KGhpZ2hwIHZlYzIgIHZhbHVlKTtpdmVjMyBmbG9hdEJpdHNUb0ludChoaWdocCB2ZWMzICB2YWx1ZSk7aXZlYzQgZmxvYXRCaXRzVG9JbnQoaGlnaHAgdmVjNCAgdmFsdWUpO3VpbnQgIGZsb2F0Qml0c1RvVWludChoaWdocCBmbG9hdCB2YWx1ZSk7dXZlYzIgZmxvYXRCaXRzVG9VaW50KGhpZ2hwIHZlYzIgIHZhbHVlKTt1dmVjMyBmbG9hdEJpdHNUb1VpbnQoaGlnaHAgdmVjMyAgdmFsdWUpO3V2ZWM0IGZsb2F0Qml0c1RvVWludChoaWdocCB2ZWM0ICB2YWx1ZSk7ZmxvYXQgaW50Qml0c1RvRmxvYXQoaGlnaHAgaW50ICAgdmFsdWUpO3ZlYzIgIGludEJpdHNUb0Zsb2F0KGhpZ2hwIGl2ZWMyIHZhbHVlKTt2ZWMzICBpbnRCaXRzVG9GbG9hdChoaWdocCBpdmVjMyB2YWx1ZSk7dmVjNCAgaW50Qml0c1RvRmxvYXQoaGlnaHAgaXZlYzQgdmFsdWUpO2Zsb2F0IHVpbnRCaXRzVG9GbG9hdChoaWdocCB1aW50ICB2YWx1ZSk7dmVjMiAgdWludEJpdHNUb0Zsb2F0KGhpZ2hwIHV2ZWMyIHZhbHVlKTt2ZWMzICB1aW50Qml0c1RvRmxvYXQoaGlnaHAgdXZlYzMgdmFsdWUpO3ZlYzQgIHVpbnRCaXRzVG9GbG9hdChoaWdocCB1dmVjNCB2YWx1ZSk7CgBmbG9hdCAgZm1hKGZsb2F0LCAgZmxvYXQsICBmbG9hdCApO3ZlYzIgICBmbWEodmVjMiwgICB2ZWMyLCAgIHZlYzIgICk7dmVjMyAgIGZtYSh2ZWMzLCAgIHZlYzMsICAgdmVjMyAgKTt2ZWM0ICAgZm1hKHZlYzQsICAgdmVjNCwgICB2ZWM0ICApOwoAZG91YmxlIGZtYShkb3VibGUsIGRvdWJsZSwgZG91YmxlKTtkdmVjMiAgZm1hKGR2ZWMyLCAgZHZlYzIsICBkdmVjMiApO2R2ZWMzICBmbWEoZHZlYzMsICBkdmVjMywgIGR2ZWMzICk7ZHZlYzQgIGZtYShkdmVjNCwgIGR2ZWM0LCAgZHZlYzQgKTsKAGZsb2F0IGZyZXhwKGhpZ2hwIGZsb2F0LCBvdXQgaGlnaHAgaW50KTt2ZWMyICBmcmV4cChoaWdocCB2ZWMyLCAgb3V0IGhpZ2hwIGl2ZWMyKTt2ZWMzICBmcmV4cChoaWdocCB2ZWMzLCAgb3V0IGhpZ2hwIGl2ZWMzKTt2ZWM0ICBmcmV4cChoaWdocCB2ZWM0LCAgb3V0IGhpZ2hwIGl2ZWM0KTtmbG9hdCBsZGV4cChoaWdocCBmbG9hdCwgaGlnaHAgaW50KTt2ZWMyICBsZGV4cChoaWdocCB2ZWMyLCAgaGlnaHAgaXZlYzIpO3ZlYzMgIGxkZXhwKGhpZ2hwIHZlYzMsICBoaWdocCBpdmVjMyk7dmVjNCAgbGRleHAoaGlnaHAgdmVjNCwgIGhpZ2hwIGl2ZWM0KTsKAGRvdWJsZSBmcmV4cChkb3VibGUsIG91dCBpbnQpO2R2ZWMyICBmcmV4cCggZHZlYzIsIG91dCBpdmVjMik7ZHZlYzMgIGZyZXhwKCBkdmVjMywgb3V0IGl2ZWMzKTtkdmVjNCAgZnJleHAoIGR2ZWM0LCBvdXQgaXZlYzQpO2RvdWJsZSBsZGV4cChkb3VibGUsIGludCk7ZHZlYzIgIGxkZXhwKCBkdmVjMiwgaXZlYzIpO2R2ZWMzICBsZGV4cCggZHZlYzMsIGl2ZWMzKTtkdmVjNCAgbGRleHAoIGR2ZWM0LCBpdmVjNCk7ZG91YmxlIHBhY2tEb3VibGUyeDMyKHV2ZWMyKTt1dmVjMiB1bnBhY2tEb3VibGUyeDMyKGRvdWJsZSk7CgBoaWdocCB1aW50IHBhY2tVbm9ybTJ4MTYodmVjMik7dmVjMiB1bnBhY2tVbm9ybTJ4MTYoaGlnaHAgdWludCk7CgBoaWdocCB1aW50IHBhY2tTbm9ybTJ4MTYodmVjMik7ICAgICAgdmVjMiB1bnBhY2tTbm9ybTJ4MTYoaGlnaHAgdWludCk7aGlnaHAgdWludCBwYWNrSGFsZjJ4MTYodmVjMik7CgBtZWRpdW1wIHZlYzIgdW5wYWNrSGFsZjJ4MTYoaGlnaHAgdWludCk7CgAgICAgICAgIHZlYzIgdW5wYWNrSGFsZjJ4MTYoaGlnaHAgdWludCk7CgBoaWdocCB1aW50IHBhY2tTbm9ybTR4OCh2ZWM0KTtoaWdocCB1aW50IHBhY2tVbm9ybTR4OCh2ZWM0KTsKAG1lZGl1bXAgdmVjNCB1bnBhY2tTbm9ybTR4OChoaWdocCB1aW50KTttZWRpdW1wIHZlYzQgdW5wYWNrVW5vcm00eDgoaGlnaHAgdWludCk7CgB2ZWM0IHVucGFja1Nub3JtNHg4KGhpZ2hwIHVpbnQpO3ZlYzQgdW5wYWNrVW5vcm00eDgoaGlnaHAgdWludCk7CgBtYXQyIG1hdHJpeENvbXBNdWx0KG1hdDIgeCwgbWF0MiB5KTttYXQzIG1hdHJpeENvbXBNdWx0KG1hdDMgeCwgbWF0MyB5KTttYXQ0IG1hdHJpeENvbXBNdWx0KG1hdDQgeCwgbWF0NCB5KTsKAG1hdDIgICBvdXRlclByb2R1Y3QodmVjMiBjLCB2ZWMyIHIpO21hdDMgICBvdXRlclByb2R1Y3QodmVjMyBjLCB2ZWMzIHIpO21hdDQgICBvdXRlclByb2R1Y3QodmVjNCBjLCB2ZWM0IHIpO21hdDJ4MyBvdXRlclByb2R1Y3QodmVjMyBjLCB2ZWMyIHIpO21hdDN4MiBvdXRlclByb2R1Y3QodmVjMiBjLCB2ZWMzIHIpO21hdDJ4NCBvdXRlclByb2R1Y3QodmVjNCBjLCB2ZWMyIHIpO21hdDR4MiBvdXRlclByb2R1Y3QodmVjMiBjLCB2ZWM0IHIpO21hdDN4NCBvdXRlclByb2R1Y3QodmVjNCBjLCB2ZWMzIHIpO21hdDR4MyBvdXRlclByb2R1Y3QodmVjMyBjLCB2ZWM0IHIpO21hdDIgICB0cmFuc3Bvc2UobWF0MiAgIG0pO21hdDMgICB0cmFuc3Bvc2UobWF0MyAgIG0pO21hdDQgICB0cmFuc3Bvc2UobWF0NCAgIG0pO21hdDJ4MyB0cmFuc3Bvc2UobWF0M3gyIG0pO21hdDN4MiB0cmFuc3Bvc2UobWF0MngzIG0pO21hdDJ4NCB0cmFuc3Bvc2UobWF0NHgyIG0pO21hdDR4MiB0cmFuc3Bvc2UobWF0Mng0IG0pO21hdDN4NCB0cmFuc3Bvc2UobWF0NHgzIG0pO21hdDR4MyB0cmFuc3Bvc2UobWF0M3g0IG0pO21hdDJ4MyBtYXRyaXhDb21wTXVsdChtYXQyeDMsIG1hdDJ4Myk7bWF0Mng0IG1hdHJpeENvbXBNdWx0KG1hdDJ4NCwgbWF0Mng0KTttYXQzeDIgbWF0cml4Q29tcE11bHQobWF0M3gyLCBtYXQzeDIpO21hdDN4NCBtYXRyaXhDb21wTXVsdChtYXQzeDQsIG1hdDN4NCk7bWF0NHgyIG1hdHJpeENvbXBNdWx0KG1hdDR4MiwgbWF0NHgyKTttYXQ0eDMgbWF0cml4Q29tcE11bHQobWF0NHgzLCBtYXQ0eDMpOwoAZmxvYXQgZGV0ZXJtaW5hbnQobWF0MiBtKTtmbG9hdCBkZXRlcm1pbmFudChtYXQzIG0pO2Zsb2F0IGRldGVybWluYW50KG1hdDQgbSk7bWF0MiBpbnZlcnNlKG1hdDIgbSk7bWF0MyBpbnZlcnNlKG1hdDMgbSk7bWF0NCBpbnZlcnNlKG1hdDQgbSk7CgB2ZWM0IHRleHR1cmUyRChzYW1wbGVyMkQsIHZlYzIpO3ZlYzQgdGV4dHVyZTJEUHJvaihzYW1wbGVyMkQsIHZlYzMpO3ZlYzQgdGV4dHVyZTJEUHJvaihzYW1wbGVyMkQsIHZlYzQpO3ZlYzQgdGV4dHVyZTNEKHNhbXBsZXIzRCwgdmVjMyk7dmVjNCB0ZXh0dXJlM0RQcm9qKHNhbXBsZXIzRCwgdmVjNCk7dmVjNCB0ZXh0dXJlQ3ViZShzYW1wbGVyQ3ViZSwgdmVjMyk7CgB2ZWM0IHRleHR1cmUxRChzYW1wbGVyMUQsIGZsb2F0KTt2ZWM0IHRleHR1cmUxRFByb2ooc2FtcGxlcjFELCB2ZWMyKTt2ZWM0IHRleHR1cmUxRFByb2ooc2FtcGxlcjFELCB2ZWM0KTt2ZWM0IHNoYWRvdzFEKHNhbXBsZXIxRFNoYWRvdywgdmVjMyk7dmVjNCBzaGFkb3cyRChzYW1wbGVyMkRTaGFkb3csIHZlYzMpO3ZlYzQgc2hhZG93MURQcm9qKHNhbXBsZXIxRFNoYWRvdywgdmVjNCk7dmVjNCBzaGFkb3cyRFByb2ooc2FtcGxlcjJEU2hhZG93LCB2ZWM0KTt2ZWM0IHRleHR1cmUyRFJlY3Qoc2FtcGxlcjJEUmVjdCwgdmVjMik7dmVjNCB0ZXh0dXJlMkRSZWN0UHJvaihzYW1wbGVyMkRSZWN0LCB2ZWMzKTt2ZWM0IHRleHR1cmUyRFJlY3RQcm9qKHNhbXBsZXIyRFJlY3QsIHZlYzQpO3ZlYzQgc2hhZG93MkRSZWN0KHNhbXBsZXIyRFJlY3RTaGFkb3csIHZlYzMpO3ZlYzQgc2hhZG93MkRSZWN0UHJvaihzYW1wbGVyMkRSZWN0U2hhZG93LCB2ZWM0KTsKAHZlYzQgdGV4dHVyZTJEKHNhbXBsZXJFeHRlcm5hbE9FUywgdmVjMiBjb29yZCk7dmVjNCB0ZXh0dXJlMkRQcm9qKHNhbXBsZXJFeHRlcm5hbE9FUywgdmVjMyk7dmVjNCB0ZXh0dXJlMkRQcm9qKHNhbXBsZXJFeHRlcm5hbE9FUywgdmVjNCk7CgBoaWdocCBpdmVjMiB0ZXh0dXJlU2l6ZShzYW1wbGVyRXh0ZXJuYWxPRVMsIGludCBsb2QpO3ZlYzQgdGV4dHVyZShzYW1wbGVyRXh0ZXJuYWxPRVMsIHZlYzIpO3ZlYzQgdGV4dHVyZShzYW1wbGVyRXh0ZXJuYWxPRVMsIHZlYzIsIGZsb2F0IGJpYXMpO3ZlYzQgdGV4dHVyZVByb2ooc2FtcGxlckV4dGVybmFsT0VTLCB2ZWMzKTt2ZWM0IHRleHR1cmVQcm9qKHNhbXBsZXJFeHRlcm5hbE9FUywgdmVjMywgZmxvYXQgYmlhcyk7dmVjNCB0ZXh0dXJlUHJvaihzYW1wbGVyRXh0ZXJuYWxPRVMsIHZlYzQpO3ZlYzQgdGV4dHVyZVByb2ooc2FtcGxlckV4dGVybmFsT0VTLCB2ZWM0LCBmbG9hdCBiaWFzKTt2ZWM0IHRleGVsRmV0Y2goc2FtcGxlckV4dGVybmFsT0VTLCBpdmVjMiwgaW50IGxvZCk7CgBoaWdocCBpdmVjMiB0ZXh0dXJlU2l6ZShfX3NhbXBsZXJFeHRlcm5hbDJEWTJZRVhULCBpbnQgbG9kKTt2ZWM0IHRleHR1cmUoX19zYW1wbGVyRXh0ZXJuYWwyRFkyWUVYVCwgdmVjMik7dmVjNCB0ZXh0dXJlKF9fc2FtcGxlckV4dGVybmFsMkRZMllFWFQsIHZlYzIsIGZsb2F0IGJpYXMpO3ZlYzQgdGV4dHVyZVByb2ooX19zYW1wbGVyRXh0ZXJuYWwyRFkyWUVYVCwgdmVjMyk7dmVjNCB0ZXh0dXJlUHJvaihfX3NhbXBsZXJFeHRlcm5hbDJEWTJZRVhULCB2ZWMzLCBmbG9hdCBiaWFzKTt2ZWM0IHRleHR1cmVQcm9qKF9fc2FtcGxlckV4dGVybmFsMkRZMllFWFQsIHZlYzQpO3ZlYzQgdGV4dHVyZVByb2ooX19zYW1wbGVyRXh0ZXJuYWwyRFkyWUVYVCwgdmVjNCwgZmxvYXQgYmlhcyk7dmVjNCB0ZXhlbEZldGNoKF9fc2FtcGxlckV4dGVybmFsMkRZMllFWFQgc2FtcGxlciwgaXZlYzIsIGludCBsb2QpOwoAdmVjNCB0ZXh0dXJlMkRHcmFkRVhUKHNhbXBsZXIyRCwgdmVjMiwgdmVjMiwgdmVjMik7dmVjNCB0ZXh0dXJlMkRQcm9qR3JhZEVYVChzYW1wbGVyMkQsIHZlYzMsIHZlYzIsIHZlYzIpO3ZlYzQgdGV4dHVyZTJEUHJvakdyYWRFWFQoc2FtcGxlcjJELCB2ZWM0LCB2ZWMyLCB2ZWMyKTt2ZWM0IHRleHR1cmVDdWJlR3JhZEVYVChzYW1wbGVyQ3ViZSwgdmVjMywgdmVjMywgdmVjMyk7ZmxvYXQgc2hhZG93MkRFWFQoc2FtcGxlcjJEU2hhZG93LCB2ZWMzKTtmbG9hdCBzaGFkb3cyRFByb2pFWFQoc2FtcGxlcjJEU2hhZG93LCB2ZWM0KTsKAGZsb2F0IG5vaXNlMShmbG9hdCB4KTtmbG9hdCBub2lzZTEodmVjMiAgeCk7ZmxvYXQgbm9pc2UxKHZlYzMgIHgpO2Zsb2F0IG5vaXNlMSh2ZWM0ICB4KTt2ZWMyIG5vaXNlMihmbG9hdCB4KTt2ZWMyIG5vaXNlMih2ZWMyICB4KTt2ZWMyIG5vaXNlMih2ZWMzICB4KTt2ZWMyIG5vaXNlMih2ZWM0ICB4KTt2ZWMzIG5vaXNlMyhmbG9hdCB4KTt2ZWMzIG5vaXNlMyh2ZWMyICB4KTt2ZWMzIG5vaXNlMyh2ZWMzICB4KTt2ZWMzIG5vaXNlMyh2ZWM0ICB4KTt2ZWM0IG5vaXNlNChmbG9hdCB4KTt2ZWM0IG5vaXNlNCh2ZWMyICB4KTt2ZWM0IG5vaXNlNCh2ZWMzICB4KTt2ZWM0IG5vaXNlNCh2ZWM0ICB4KTsKAHVpbnQgYXRvbWljQ291bnRlckluY3JlbWVudChhdG9taWNfdWludCk7dWludCBhdG9taWNDb3VudGVyRGVjcmVtZW50KGF0b21pY191aW50KTt1aW50IGF0b21pY0NvdW50ZXIoYXRvbWljX3VpbnQpOwoAdWludCBhdG9taWNDb3VudGVyQWRkKGF0b21pY191aW50LCB1aW50KTt1aW50IGF0b21pY0NvdW50ZXJTdWJ0cmFjdChhdG9taWNfdWludCwgdWludCk7dWludCBhdG9taWNDb3VudGVyTWluKGF0b21pY191aW50LCB1aW50KTt1aW50IGF0b21pY0NvdW50ZXJNYXgoYXRvbWljX3VpbnQsIHVpbnQpO3VpbnQgYXRvbWljQ291bnRlckFuZChhdG9taWNfdWludCwgdWludCk7dWludCBhdG9taWNDb3VudGVyT3IoYXRvbWljX3VpbnQsIHVpbnQpO3VpbnQgYXRvbWljQ291bnRlclhvcihhdG9taWNfdWludCwgdWludCk7dWludCBhdG9taWNDb3VudGVyRXhjaGFuZ2UoYXRvbWljX3VpbnQsIHVpbnQpO3VpbnQgYXRvbWljQ291bnRlckNvbXBTd2FwKGF0b21pY191aW50LCB1aW50LCB1aW50KTsKACAgaW50IGJpdGZpZWxkRXh0cmFjdCggIGludCwgaW50LCBpbnQpO2l2ZWMyIGJpdGZpZWxkRXh0cmFjdChpdmVjMiwgaW50LCBpbnQpO2l2ZWMzIGJpdGZpZWxkRXh0cmFjdChpdmVjMywgaW50LCBpbnQpO2l2ZWM0IGJpdGZpZWxkRXh0cmFjdChpdmVjNCwgaW50LCBpbnQpOyB1aW50IGJpdGZpZWxkRXh0cmFjdCggdWludCwgaW50LCBpbnQpO3V2ZWMyIGJpdGZpZWxkRXh0cmFjdCh1dmVjMiwgaW50LCBpbnQpO3V2ZWMzIGJpdGZpZWxkRXh0cmFjdCh1dmVjMywgaW50LCBpbnQpO3V2ZWM0IGJpdGZpZWxkRXh0cmFjdCh1dmVjNCwgaW50LCBpbnQpOyAgaW50IGJpdGZpZWxkSW5zZXJ0KCAgaW50IGJhc2UsICAgaW50LCBpbnQsIGludCk7aXZlYzIgYml0ZmllbGRJbnNlcnQoaXZlYzIgYmFzZSwgaXZlYzIsIGludCwgaW50KTtpdmVjMyBiaXRmaWVsZEluc2VydChpdmVjMyBiYXNlLCBpdmVjMywgaW50LCBpbnQpO2l2ZWM0IGJpdGZpZWxkSW5zZXJ0KGl2ZWM0IGJhc2UsIGl2ZWM0LCBpbnQsIGludCk7IHVpbnQgYml0ZmllbGRJbnNlcnQoIHVpbnQgYmFzZSwgIHVpbnQsIGludCwgaW50KTt1dmVjMiBiaXRmaWVsZEluc2VydCh1dmVjMiBiYXNlLCB1dmVjMiwgaW50LCBpbnQpO3V2ZWMzIGJpdGZpZWxkSW5zZXJ0KHV2ZWMzIGJhc2UsIHV2ZWMzLCBpbnQsIGludCk7dXZlYzQgYml0ZmllbGRJbnNlcnQodXZlYzQgYmFzZSwgdXZlYzQsIGludCwgaW50KTsKAGxvd3AgICBpbnQgZmluZExTQiggIGludCk7bG93cCBpdmVjMiBmaW5kTFNCKGl2ZWMyKTtsb3dwIGl2ZWMzIGZpbmRMU0IoaXZlYzMpO2xvd3AgaXZlYzQgZmluZExTQihpdmVjNCk7bG93cCAgIGludCBmaW5kTFNCKCB1aW50KTtsb3dwIGl2ZWMyIGZpbmRMU0IodXZlYzIpO2xvd3AgaXZlYzMgZmluZExTQih1dmVjMyk7bG93cCBpdmVjNCBmaW5kTFNCKHV2ZWM0KTsKACB1aW50IHVhZGRDYXJyeShoaWdocCAgdWludCwgaGlnaHAgIHVpbnQsIG91dCBsb3dwICB1aW50IGNhcnJ5KTt1dmVjMiB1YWRkQ2FycnkoaGlnaHAgdXZlYzIsIGhpZ2hwIHV2ZWMyLCBvdXQgbG93cCB1dmVjMiBjYXJyeSk7dXZlYzMgdWFkZENhcnJ5KGhpZ2hwIHV2ZWMzLCBoaWdocCB1dmVjMywgb3V0IGxvd3AgdXZlYzMgY2FycnkpO3V2ZWM0IHVhZGRDYXJyeShoaWdocCB1dmVjNCwgaGlnaHAgdXZlYzQsIG91dCBsb3dwIHV2ZWM0IGNhcnJ5KTsgdWludCB1c3ViQm9ycm93KGhpZ2hwICB1aW50LCBoaWdocCAgdWludCwgb3V0IGxvd3AgIHVpbnQgYm9ycm93KTt1dmVjMiB1c3ViQm9ycm93KGhpZ2hwIHV2ZWMyLCBoaWdocCB1dmVjMiwgb3V0IGxvd3AgdXZlYzIgYm9ycm93KTt1dmVjMyB1c3ViQm9ycm93KGhpZ2hwIHV2ZWMzLCBoaWdocCB1dmVjMywgb3V0IGxvd3AgdXZlYzMgYm9ycm93KTt1dmVjNCB1c3ViQm9ycm93KGhpZ2hwIHV2ZWM0LCBoaWdocCB1dmVjNCwgb3V0IGxvd3AgdXZlYzQgYm9ycm93KTt2b2lkIHVtdWxFeHRlbmRlZChoaWdocCAgdWludCwgaGlnaHAgIHVpbnQsIG91dCBoaWdocCAgdWludCwgb3V0IGhpZ2hwICB1aW50IGxzYik7dm9pZCB1bXVsRXh0ZW5kZWQoaGlnaHAgdXZlYzIsIGhpZ2hwIHV2ZWMyLCBvdXQgaGlnaHAgdXZlYzIsIG91dCBoaWdocCB1dmVjMiBsc2IpO3ZvaWQgdW11bEV4dGVuZGVkKGhpZ2hwIHV2ZWMzLCBoaWdocCB1dmVjMywgb3V0IGhpZ2hwIHV2ZWMzLCBvdXQgaGlnaHAgdXZlYzMgbHNiKTt2b2lkIHVtdWxFeHRlbmRlZChoaWdocCB1dmVjNCwgaGlnaHAgdXZlYzQsIG91dCBoaWdocCB1dmVjNCwgb3V0IGhpZ2hwIHV2ZWM0IGxzYik7dm9pZCBpbXVsRXh0ZW5kZWQoaGlnaHAgICBpbnQsIGhpZ2hwICAgaW50LCBvdXQgaGlnaHAgICBpbnQsIG91dCBoaWdocCAgIGludCBsc2IpO3ZvaWQgaW11bEV4dGVuZGVkKGhpZ2hwIGl2ZWMyLCBoaWdocCBpdmVjMiwgb3V0IGhpZ2hwIGl2ZWMyLCBvdXQgaGlnaHAgaXZlYzIgbHNiKTt2b2lkIGltdWxFeHRlbmRlZChoaWdocCBpdmVjMywgaGlnaHAgaXZlYzMsIG91dCBoaWdocCBpdmVjMywgb3V0IGhpZ2hwIGl2ZWMzIGxzYik7dm9pZCBpbXVsRXh0ZW5kZWQoaGlnaHAgaXZlYzQsIGhpZ2hwIGl2ZWM0LCBvdXQgaGlnaHAgaXZlYzQsIG91dCBoaWdocCBpdmVjNCBsc2IpOyAgaW50IGJpdGZpZWxkUmV2ZXJzZShoaWdocCAgIGludCk7aXZlYzIgYml0ZmllbGRSZXZlcnNlKGhpZ2hwIGl2ZWMyKTtpdmVjMyBiaXRmaWVsZFJldmVyc2UoaGlnaHAgaXZlYzMpO2l2ZWM0IGJpdGZpZWxkUmV2ZXJzZShoaWdocCBpdmVjNCk7IHVpbnQgYml0ZmllbGRSZXZlcnNlKGhpZ2hwICB1aW50KTt1dmVjMiBiaXRmaWVsZFJldmVyc2UoaGlnaHAgdXZlYzIpO3V2ZWMzIGJpdGZpZWxkUmV2ZXJzZShoaWdocCB1dmVjMyk7dXZlYzQgYml0ZmllbGRSZXZlcnNlKGhpZ2hwIHV2ZWM0KTsKACAgaW50IGZpbmRMU0IoICBpbnQpO2l2ZWMyIGZpbmRMU0IoaXZlYzIpO2l2ZWMzIGZpbmRMU0IoaXZlYzMpO2l2ZWM0IGZpbmRMU0IoaXZlYzQpOyAgaW50IGZpbmRMU0IoIHVpbnQpO2l2ZWMyIGZpbmRMU0IodXZlYzIpO2l2ZWMzIGZpbmRMU0IodXZlYzMpO2l2ZWM0IGZpbmRMU0IodXZlYzQpOwoAICBpbnQgYml0Q291bnQoICBpbnQpO2l2ZWMyIGJpdENvdW50KGl2ZWMyKTtpdmVjMyBiaXRDb3VudChpdmVjMyk7aXZlYzQgYml0Q291bnQoaXZlYzQpOyAgaW50IGJpdENvdW50KCB1aW50KTtpdmVjMiBiaXRDb3VudCh1dmVjMik7aXZlYzMgYml0Q291bnQodXZlYzMpO2l2ZWM0IGJpdENvdW50KHV2ZWM0KTsgIGludCBmaW5kTVNCKGhpZ2hwICAgaW50KTtpdmVjMiBmaW5kTVNCKGhpZ2hwIGl2ZWMyKTtpdmVjMyBmaW5kTVNCKGhpZ2hwIGl2ZWMzKTtpdmVjNCBmaW5kTVNCKGhpZ2hwIGl2ZWM0KTsgIGludCBmaW5kTVNCKGhpZ2hwICB1aW50KTtpdmVjMiBmaW5kTVNCKGhpZ2hwIHV2ZWMyKTtpdmVjMyBmaW5kTVNCKGhpZ2hwIHV2ZWMzKTtpdmVjNCBmaW5kTVNCKGhpZ2hwIHV2ZWM0KTsKAGxvd3AgICBpbnQgYml0Q291bnQoICBpbnQpO2xvd3AgaXZlYzIgYml0Q291bnQoaXZlYzIpO2xvd3AgaXZlYzMgYml0Q291bnQoaXZlYzMpO2xvd3AgaXZlYzQgYml0Q291bnQoaXZlYzQpO2xvd3AgICBpbnQgYml0Q291bnQoIHVpbnQpO2xvd3AgaXZlYzIgYml0Q291bnQodXZlYzIpO2xvd3AgaXZlYzMgYml0Q291bnQodXZlYzMpO2xvd3AgaXZlYzQgYml0Q291bnQodXZlYzQpO2xvd3AgICBpbnQgZmluZE1TQihoaWdocCAgIGludCk7bG93cCBpdmVjMiBmaW5kTVNCKGhpZ2hwIGl2ZWMyKTtsb3dwIGl2ZWMzIGZpbmRNU0IoaGlnaHAgaXZlYzMpO2xvd3AgaXZlYzQgZmluZE1TQihoaWdocCBpdmVjNCk7bG93cCAgIGludCBmaW5kTVNCKGhpZ2hwICB1aW50KTtsb3dwIGl2ZWMyIGZpbmRNU0IoaGlnaHAgdXZlYzIpO2xvd3AgaXZlYzMgZmluZE1TQihoaWdocCB1dmVjMyk7bG93cCBpdmVjNCBmaW5kTVNCKGhpZ2hwIHV2ZWM0KTsKAHVpbnQ2NF90IGJhbGxvdEFSQihib29sKTtmbG9hdCByZWFkSW52b2NhdGlvbkFSQihmbG9hdCwgdWludCk7dmVjMiAgcmVhZEludm9jYXRpb25BUkIodmVjMiwgIHVpbnQpO3ZlYzMgIHJlYWRJbnZvY2F0aW9uQVJCKHZlYzMsICB1aW50KTt2ZWM0ICByZWFkSW52b2NhdGlvbkFSQih2ZWM0LCAgdWludCk7aW50ICAgcmVhZEludm9jYXRpb25BUkIoaW50LCAgIHVpbnQpO2l2ZWMyIHJlYWRJbnZvY2F0aW9uQVJCKGl2ZWMyLCB1aW50KTtpdmVjMyByZWFkSW52b2NhdGlvbkFSQihpdmVjMywgdWludCk7aXZlYzQgcmVhZEludm9jYXRpb25BUkIoaXZlYzQsIHVpbnQpO3VpbnQgIHJlYWRJbnZvY2F0aW9uQVJCKHVpbnQsICB1aW50KTt1dmVjMiByZWFkSW52b2NhdGlvbkFSQih1dmVjMiwgdWludCk7dXZlYzMgcmVhZEludm9jYXRpb25BUkIodXZlYzMsIHVpbnQpO3V2ZWM0IHJlYWRJbnZvY2F0aW9uQVJCKHV2ZWM0LCB1aW50KTtmbG9hdCByZWFkRmlyc3RJbnZvY2F0aW9uQVJCKGZsb2F0KTt2ZWMyICByZWFkRmlyc3RJbnZvY2F0aW9uQVJCKHZlYzIpO3ZlYzMgIHJlYWRGaXJzdEludm9jYXRpb25BUkIodmVjMyk7dmVjNCAgcmVhZEZpcnN0SW52b2NhdGlvbkFSQih2ZWM0KTtpbnQgICByZWFkRmlyc3RJbnZvY2F0aW9uQVJCKGludCk7aXZlYzIgcmVhZEZpcnN0SW52b2NhdGlvbkFSQihpdmVjMik7aXZlYzMgcmVhZEZpcnN0SW52b2NhdGlvbkFSQihpdmVjMyk7aXZlYzQgcmVhZEZpcnN0SW52b2NhdGlvbkFSQihpdmVjNCk7dWludCAgcmVhZEZpcnN0SW52b2NhdGlvbkFSQih1aW50KTt1dmVjMiByZWFkRmlyc3RJbnZvY2F0aW9uQVJCKHV2ZWMyKTt1dmVjMyByZWFkRmlyc3RJbnZvY2F0aW9uQVJCKHV2ZWMzKTt1dmVjNCByZWFkRmlyc3RJbnZvY2F0aW9uQVJCKHV2ZWM0KTsKAGJvb2wgYW55SW52b2NhdGlvbkFSQihib29sKTtib29sIGFsbEludm9jYXRpb25zQVJCKGJvb2wpO2Jvb2wgYWxsSW52b2NhdGlvbnNFcXVhbEFSQihib29sKTsKAHZvaWQgc3ViZ3JvdXBCYXJyaWVyKCk7dm9pZCBzdWJncm91cE1lbW9yeUJhcnJpZXIoKTt2b2lkIHN1Ymdyb3VwTWVtb3J5QmFycmllckJ1ZmZlcigpO3ZvaWQgc3ViZ3JvdXBNZW1vcnlCYXJyaWVySW1hZ2UoKTtib29sIHN1Ymdyb3VwRWxlY3QoKTtib29sICAgc3ViZ3JvdXBBbGwoYm9vbCk7CmJvb2wgICBzdWJncm91cEFueShib29sKTsKdXZlYzQgIHN1Ymdyb3VwQmFsbG90KGJvb2wpOwpib29sICAgc3ViZ3JvdXBJbnZlcnNlQmFsbG90KHV2ZWM0KTsKYm9vbCAgIHN1Ymdyb3VwQmFsbG90Qml0RXh0cmFjdCh1dmVjNCwgdWludCk7CnVpbnQgICBzdWJncm91cEJhbGxvdEJpdENvdW50KHV2ZWM0KTsKdWludCAgIHN1Ymdyb3VwQmFsbG90SW5jbHVzaXZlQml0Q291bnQodXZlYzQpOwp1aW50ICAgc3ViZ3JvdXBCYWxsb3RFeGNsdXNpdmVCaXRDb3VudCh1dmVjNCk7CnVpbnQgICBzdWJncm91cEJhbGxvdEZpbmRMU0IodXZlYzQpOwp1aW50ICAgc3ViZ3JvdXBCYWxsb3RGaW5kTVNCKHV2ZWM0KTsKAHZvaWQgc3ViZ3JvdXBNZW1vcnlCYXJyaWVyU2hhcmVkKCk7CgBBkPoDC7aaBThNAgBWTQIAe00CAJ9NAgDCTQIA6E0CABNOAgBATgIAWU4CAHJOAgCLTgIApE4CAL1OAgDVTgIA7k4CABBPAgAyTwIAVE8CAHZPAgCYTwIAuU8CANtPAgD9TwIAH1ACAEFQAgBjUAIAhVACAKZQAgDIUAIA8FACABhRAgBAUQIAaFECAJBRAgC3UQIA31ECAAhSAgAwUgIAVlICAHxSAgCdUgIA0VICAAVTAgA5UwIAbVMCAKFTAgDUUwIACFQCAEVUAgCCVAIAv1QCAPxUAgA5VQIAdVUCALJVAgDvVQIALFYCAGlWAgCmVgIA41YCAB9XAgBPcgBBbmQAWG9yAFNodWZmbGVYb3IAQWRkAE11bABNaW4ATWF4AAAAAAAAAHnLAwA/ZAIARGQCAElkAgAujwMAkWcCAJlnAgChZwIAJ48DALRmAgC6ZgIAwGYCALnLAwAtZAIAM2QCADlkAgB/ywMA9mYCAP1mAgAEZwIAjssDACBnAgAoZwIAMGcCAJ/LAwBOZAIAVGQCAFpkAgCoywMAxmYCAM5mAgDWZgIAhssDAAtnAgASZwIAGWcCAJbLAwA4ZwIAQGcCAEhnAgCjywMAtWQCALtkAgDBZAIAsMsDAN5mAgDmZgIA7mYCAGJvb2wgYW55SW52b2NhdGlvbihib29sKTtib29sIGFsbEludm9jYXRpb25zKGJvb2wpO2Jvb2wgYWxsSW52b2NhdGlvbnNFcXVhbChib29sKTsKAGZsb2F0IG1pbkludm9jYXRpb25zQU1EKGZsb2F0KTt2ZWMyICBtaW5JbnZvY2F0aW9uc0FNRCh2ZWMyKTt2ZWMzICBtaW5JbnZvY2F0aW9uc0FNRCh2ZWMzKTt2ZWM0ICBtaW5JbnZvY2F0aW9uc0FNRCh2ZWM0KTtpbnQgICBtaW5JbnZvY2F0aW9uc0FNRChpbnQpO2l2ZWMyIG1pbkludm9jYXRpb25zQU1EKGl2ZWMyKTtpdmVjMyBtaW5JbnZvY2F0aW9uc0FNRChpdmVjMyk7aXZlYzQgbWluSW52b2NhdGlvbnNBTUQoaXZlYzQpO3VpbnQgIG1pbkludm9jYXRpb25zQU1EKHVpbnQpO3V2ZWMyIG1pbkludm9jYXRpb25zQU1EKHV2ZWMyKTt1dmVjMyBtaW5JbnZvY2F0aW9uc0FNRCh1dmVjMyk7dXZlYzQgbWluSW52b2NhdGlvbnNBTUQodXZlYzQpO2RvdWJsZSBtaW5JbnZvY2F0aW9uc0FNRChkb3VibGUpO2R2ZWMyICBtaW5JbnZvY2F0aW9uc0FNRChkdmVjMik7ZHZlYzMgIG1pbkludm9jYXRpb25zQU1EKGR2ZWMzKTtkdmVjNCAgbWluSW52b2NhdGlvbnNBTUQoZHZlYzQpO2ludDY0X3QgbWluSW52b2NhdGlvbnNBTUQoaW50NjRfdCk7aTY0dmVjMiBtaW5JbnZvY2F0aW9uc0FNRChpNjR2ZWMyKTtpNjR2ZWMzIG1pbkludm9jYXRpb25zQU1EKGk2NHZlYzMpO2k2NHZlYzQgbWluSW52b2NhdGlvbnNBTUQoaTY0dmVjNCk7dWludDY0X3QgbWluSW52b2NhdGlvbnNBTUQodWludDY0X3QpO3U2NHZlYzIgIG1pbkludm9jYXRpb25zQU1EKHU2NHZlYzIpO3U2NHZlYzMgIG1pbkludm9jYXRpb25zQU1EKHU2NHZlYzMpO3U2NHZlYzQgIG1pbkludm9jYXRpb25zQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtaW5JbnZvY2F0aW9uc0FNRChmbG9hdDE2X3QpO2YxNnZlYzIgICBtaW5JbnZvY2F0aW9uc0FNRChmMTZ2ZWMyKTtmMTZ2ZWMzICAgbWluSW52b2NhdGlvbnNBTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1pbkludm9jYXRpb25zQU1EKGYxNnZlYzQpO2ludDE2X3QgbWluSW52b2NhdGlvbnNBTUQoaW50MTZfdCk7aTE2dmVjMiBtaW5JbnZvY2F0aW9uc0FNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1pbkludm9jYXRpb25zQU1EKGkxNnZlYzMpO2kxNnZlYzQgbWluSW52b2NhdGlvbnNBTUQoaTE2dmVjNCk7dWludDE2X3QgbWluSW52b2NhdGlvbnNBTUQodWludDE2X3QpO3UxNnZlYzIgIG1pbkludm9jYXRpb25zQU1EKHUxNnZlYzIpO3UxNnZlYzMgIG1pbkludm9jYXRpb25zQU1EKHUxNnZlYzMpO3UxNnZlYzQgIG1pbkludm9jYXRpb25zQU1EKHUxNnZlYzQpO2Zsb2F0IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChmbG9hdCk7dmVjMiAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHZlYzIpO3ZlYzMgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh2ZWMzKTt2ZWM0ICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodmVjNCk7aW50ICAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGludCk7aXZlYzIgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGl2ZWMyKTtpdmVjMyBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoaXZlYzMpO2l2ZWM0IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpdmVjNCk7dWludCAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHVpbnQpO3V2ZWMyIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1dmVjMik7dXZlYzMgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHV2ZWMzKTt1dmVjNCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodXZlYzQpO2RvdWJsZSBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZG91YmxlKTtkdmVjMiAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGR2ZWMyKTtkdmVjMyAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGR2ZWMzKTtkdmVjNCAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGR2ZWM0KTtpbnQ2NF90IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpbnQ2NF90KTtpNjR2ZWMyIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpNjR2ZWMzKTtpNjR2ZWM0IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpNjR2ZWM0KTt1aW50NjRfdCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodWludDY0X3QpO3U2NHZlYzIgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodTY0dmVjMyk7dTY0dmVjNCAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChmMTZ2ZWM0KTtpbnQxNl90IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpbnQxNl90KTtpMTZ2ZWMyIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpMTZ2ZWM0KTt1aW50MTZfdCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodWludDE2X3QpO3UxNnZlYzIgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodTE2dmVjMyk7dTE2dmVjNCAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHUxNnZlYzQpO2Zsb2F0IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChmbG9hdCk7dmVjMiAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHZlYzIpO3ZlYzMgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh2ZWMzKTt2ZWM0ICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodmVjNCk7aW50ICAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGludCk7aXZlYzIgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGl2ZWMyKTtpdmVjMyBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoaXZlYzMpO2l2ZWM0IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpdmVjNCk7dWludCAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHVpbnQpO3V2ZWMyIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1dmVjMik7dXZlYzMgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHV2ZWMzKTt1dmVjNCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodXZlYzQpO2RvdWJsZSBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZG91YmxlKTtkdmVjMiAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGR2ZWMyKTtkdmVjMyAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGR2ZWMzKTtkdmVjNCAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGR2ZWM0KTtpbnQ2NF90IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpbnQ2NF90KTtpNjR2ZWMyIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWMzKTtpNjR2ZWM0IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWM0KTt1aW50NjRfdCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodWludDY0X3QpO3U2NHZlYzIgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodTY0dmVjMyk7dTY0dmVjNCAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChmMTZ2ZWM0KTtpbnQxNl90IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpbnQxNl90KTtpMTZ2ZWMyIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWM0KTt1aW50MTZfdCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodWludDE2X3QpO3UxNnZlYzIgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodTE2dmVjMyk7dTE2dmVjNCAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHUxNnZlYzQpO2Zsb2F0IG1heEludm9jYXRpb25zQU1EKGZsb2F0KTt2ZWMyICBtYXhJbnZvY2F0aW9uc0FNRCh2ZWMyKTt2ZWMzICBtYXhJbnZvY2F0aW9uc0FNRCh2ZWMzKTt2ZWM0ICBtYXhJbnZvY2F0aW9uc0FNRCh2ZWM0KTtpbnQgICBtYXhJbnZvY2F0aW9uc0FNRChpbnQpO2l2ZWMyIG1heEludm9jYXRpb25zQU1EKGl2ZWMyKTtpdmVjMyBtYXhJbnZvY2F0aW9uc0FNRChpdmVjMyk7aXZlYzQgbWF4SW52b2NhdGlvbnNBTUQoaXZlYzQpO3VpbnQgIG1heEludm9jYXRpb25zQU1EKHVpbnQpO3V2ZWMyIG1heEludm9jYXRpb25zQU1EKHV2ZWMyKTt1dmVjMyBtYXhJbnZvY2F0aW9uc0FNRCh1dmVjMyk7dXZlYzQgbWF4SW52b2NhdGlvbnNBTUQodXZlYzQpO2RvdWJsZSBtYXhJbnZvY2F0aW9uc0FNRChkb3VibGUpO2R2ZWMyICBtYXhJbnZvY2F0aW9uc0FNRChkdmVjMik7ZHZlYzMgIG1heEludm9jYXRpb25zQU1EKGR2ZWMzKTtkdmVjNCAgbWF4SW52b2NhdGlvbnNBTUQoZHZlYzQpO2ludDY0X3QgbWF4SW52b2NhdGlvbnNBTUQoaW50NjRfdCk7aTY0dmVjMiBtYXhJbnZvY2F0aW9uc0FNRChpNjR2ZWMyKTtpNjR2ZWMzIG1heEludm9jYXRpb25zQU1EKGk2NHZlYzMpO2k2NHZlYzQgbWF4SW52b2NhdGlvbnNBTUQoaTY0dmVjNCk7dWludDY0X3QgbWF4SW52b2NhdGlvbnNBTUQodWludDY0X3QpO3U2NHZlYzIgIG1heEludm9jYXRpb25zQU1EKHU2NHZlYzIpO3U2NHZlYzMgIG1heEludm9jYXRpb25zQU1EKHU2NHZlYzMpO3U2NHZlYzQgIG1heEludm9jYXRpb25zQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtYXhJbnZvY2F0aW9uc0FNRChmbG9hdDE2X3QpO2YxNnZlYzIgICBtYXhJbnZvY2F0aW9uc0FNRChmMTZ2ZWMyKTtmMTZ2ZWMzICAgbWF4SW52b2NhdGlvbnNBTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1heEludm9jYXRpb25zQU1EKGYxNnZlYzQpO2ludDE2X3QgbWF4SW52b2NhdGlvbnNBTUQoaW50MTZfdCk7aTE2dmVjMiBtYXhJbnZvY2F0aW9uc0FNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1heEludm9jYXRpb25zQU1EKGkxNnZlYzMpO2kxNnZlYzQgbWF4SW52b2NhdGlvbnNBTUQoaTE2dmVjNCk7dWludDE2X3QgbWF4SW52b2NhdGlvbnNBTUQodWludDE2X3QpO3UxNnZlYzIgIG1heEludm9jYXRpb25zQU1EKHUxNnZlYzIpO3UxNnZlYzMgIG1heEludm9jYXRpb25zQU1EKHUxNnZlYzMpO3UxNnZlYzQgIG1heEludm9jYXRpb25zQU1EKHUxNnZlYzQpO2Zsb2F0IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChmbG9hdCk7dmVjMiAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHZlYzIpO3ZlYzMgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh2ZWMzKTt2ZWM0ICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodmVjNCk7aW50ICAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGludCk7aXZlYzIgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGl2ZWMyKTtpdmVjMyBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoaXZlYzMpO2l2ZWM0IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpdmVjNCk7dWludCAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHVpbnQpO3V2ZWMyIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1dmVjMik7dXZlYzMgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHV2ZWMzKTt1dmVjNCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodXZlYzQpO2RvdWJsZSBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZG91YmxlKTtkdmVjMiAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGR2ZWMyKTtkdmVjMyAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGR2ZWMzKTtkdmVjNCAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGR2ZWM0KTtpbnQ2NF90IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpbnQ2NF90KTtpNjR2ZWMyIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpNjR2ZWMzKTtpNjR2ZWM0IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpNjR2ZWM0KTt1aW50NjRfdCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodWludDY0X3QpO3U2NHZlYzIgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodTY0dmVjMyk7dTY0dmVjNCAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChmMTZ2ZWM0KTtpbnQxNl90IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpbnQxNl90KTtpMTZ2ZWMyIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpMTZ2ZWM0KTt1aW50MTZfdCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodWludDE2X3QpO3UxNnZlYzIgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodTE2dmVjMyk7dTE2dmVjNCAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHUxNnZlYzQpO2Zsb2F0IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChmbG9hdCk7dmVjMiAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHZlYzIpO3ZlYzMgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh2ZWMzKTt2ZWM0ICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodmVjNCk7aW50ICAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGludCk7aXZlYzIgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGl2ZWMyKTtpdmVjMyBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoaXZlYzMpO2l2ZWM0IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpdmVjNCk7dWludCAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHVpbnQpO3V2ZWMyIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1dmVjMik7dXZlYzMgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHV2ZWMzKTt1dmVjNCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodXZlYzQpO2RvdWJsZSBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZG91YmxlKTtkdmVjMiAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGR2ZWMyKTtkdmVjMyAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGR2ZWMzKTtkdmVjNCAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGR2ZWM0KTtpbnQ2NF90IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpbnQ2NF90KTtpNjR2ZWMyIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWMzKTtpNjR2ZWM0IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWM0KTt1aW50NjRfdCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodWludDY0X3QpO3U2NHZlYzIgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodTY0dmVjMyk7dTY0dmVjNCAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChmMTZ2ZWM0KTtpbnQxNl90IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpbnQxNl90KTtpMTZ2ZWMyIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWM0KTt1aW50MTZfdCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodWludDE2X3QpO3UxNnZlYzIgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodTE2dmVjMyk7dTE2dmVjNCAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHUxNnZlYzQpO2Zsb2F0IGFkZEludm9jYXRpb25zQU1EKGZsb2F0KTt2ZWMyICBhZGRJbnZvY2F0aW9uc0FNRCh2ZWMyKTt2ZWMzICBhZGRJbnZvY2F0aW9uc0FNRCh2ZWMzKTt2ZWM0ICBhZGRJbnZvY2F0aW9uc0FNRCh2ZWM0KTtpbnQgICBhZGRJbnZvY2F0aW9uc0FNRChpbnQpO2l2ZWMyIGFkZEludm9jYXRpb25zQU1EKGl2ZWMyKTtpdmVjMyBhZGRJbnZvY2F0aW9uc0FNRChpdmVjMyk7aXZlYzQgYWRkSW52b2NhdGlvbnNBTUQoaXZlYzQpO3VpbnQgIGFkZEludm9jYXRpb25zQU1EKHVpbnQpO3V2ZWMyIGFkZEludm9jYXRpb25zQU1EKHV2ZWMyKTt1dmVjMyBhZGRJbnZvY2F0aW9uc0FNRCh1dmVjMyk7dXZlYzQgYWRkSW52b2NhdGlvbnNBTUQodXZlYzQpO2RvdWJsZSAgYWRkSW52b2NhdGlvbnNBTUQoZG91YmxlKTtkdmVjMiAgIGFkZEludm9jYXRpb25zQU1EKGR2ZWMyKTtkdmVjMyAgIGFkZEludm9jYXRpb25zQU1EKGR2ZWMzKTtkdmVjNCAgIGFkZEludm9jYXRpb25zQU1EKGR2ZWM0KTtpbnQ2NF90IGFkZEludm9jYXRpb25zQU1EKGludDY0X3QpO2k2NHZlYzIgYWRkSW52b2NhdGlvbnNBTUQoaTY0dmVjMik7aTY0dmVjMyBhZGRJbnZvY2F0aW9uc0FNRChpNjR2ZWMzKTtpNjR2ZWM0IGFkZEludm9jYXRpb25zQU1EKGk2NHZlYzQpO3VpbnQ2NF90IGFkZEludm9jYXRpb25zQU1EKHVpbnQ2NF90KTt1NjR2ZWMyICBhZGRJbnZvY2F0aW9uc0FNRCh1NjR2ZWMyKTt1NjR2ZWMzICBhZGRJbnZvY2F0aW9uc0FNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBhZGRJbnZvY2F0aW9uc0FNRCh1NjR2ZWM0KTtmbG9hdDE2X3QgYWRkSW52b2NhdGlvbnNBTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgYWRkSW52b2NhdGlvbnNBTUQoZjE2dmVjMik7ZjE2dmVjMyAgIGFkZEludm9jYXRpb25zQU1EKGYxNnZlYzMpO2YxNnZlYzQgICBhZGRJbnZvY2F0aW9uc0FNRChmMTZ2ZWM0KTtpbnQxNl90IGFkZEludm9jYXRpb25zQU1EKGludDE2X3QpO2kxNnZlYzIgYWRkSW52b2NhdGlvbnNBTUQoaTE2dmVjMik7aTE2dmVjMyBhZGRJbnZvY2F0aW9uc0FNRChpMTZ2ZWMzKTtpMTZ2ZWM0IGFkZEludm9jYXRpb25zQU1EKGkxNnZlYzQpO3VpbnQxNl90IGFkZEludm9jYXRpb25zQU1EKHVpbnQxNl90KTt1MTZ2ZWMyICBhZGRJbnZvY2F0aW9uc0FNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBhZGRJbnZvY2F0aW9uc0FNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBhZGRJbnZvY2F0aW9uc0FNRCh1MTZ2ZWM0KTtmbG9hdCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZmxvYXQpO3ZlYzIgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh2ZWMyKTt2ZWMzICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodmVjMyk7dmVjNCAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHZlYzQpO2ludCAgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpbnQpO2l2ZWMyIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChpdmVjMik7aXZlYzMgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGl2ZWMzKTtpdmVjNCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoaXZlYzQpO3VpbnQgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1aW50KTt1dmVjMiBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodXZlYzIpO3V2ZWMzIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1dmVjMyk7dXZlYzQgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHV2ZWM0KTtkb3VibGUgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChkb3VibGUpO2R2ZWMyICAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGR2ZWMyKTtkdmVjMyAgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChkdmVjMyk7ZHZlYzQgICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZHZlYzQpO2ludDY0X3QgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGludDY0X3QpO2k2NHZlYzIgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGk2NHZlYzIpO2k2NHZlYzMgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGk2NHZlYzMpO2k2NHZlYzQgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGk2NHZlYzQpO3VpbnQ2NF90IGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1aW50NjRfdCk7dTY0dmVjMiAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHU2NHZlYzIpO3U2NHZlYzMgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodTY0dmVjNCk7ZmxvYXQxNl90IGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChmbG9hdDE2X3QpO2YxNnZlYzIgICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQoZjE2dmVjMik7ZjE2dmVjMyAgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRChmMTZ2ZWMzKTtmMTZ2ZWM0ICAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGYxNnZlYzQpO2ludDE2X3QgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGludDE2X3QpO2kxNnZlYzIgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGkxNnZlYzIpO2kxNnZlYzMgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGkxNnZlYzMpO2kxNnZlYzQgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKGkxNnZlYzQpO3VpbnQxNl90IGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1aW50MTZfdCk7dTE2dmVjMiAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuQU1EKHUxNnZlYzIpO3UxNnZlYzMgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbkFNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5BTUQodTE2dmVjNCk7ZmxvYXQgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGZsb2F0KTt2ZWMyICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodmVjMik7dmVjMyAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHZlYzMpO3ZlYzQgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh2ZWM0KTtpbnQgICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoaW50KTtpdmVjMiBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoaXZlYzIpO2l2ZWMzIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpdmVjMyk7aXZlYzQgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGl2ZWM0KTt1aW50ICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodWludCk7dXZlYzIgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHV2ZWMyKTt1dmVjMyBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodXZlYzMpO3V2ZWM0IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1dmVjNCk7ZG91YmxlICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZG91YmxlKTtkdmVjMiAgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChkdmVjMik7ZHZlYzMgICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZHZlYzMpO2R2ZWM0ICAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGR2ZWM0KTtpbnQ2NF90IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpbnQ2NF90KTtpNjR2ZWMyIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWMyKTtpNjR2ZWMzIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWMzKTtpNjR2ZWM0IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpNjR2ZWM0KTt1aW50NjRfdCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodWludDY0X3QpO3U2NHZlYzIgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodTY0dmVjMyk7dTY0dmVjNCAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChmMTZ2ZWM0KTtpbnQxNl90IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpbnQxNl90KTtpMTZ2ZWMyIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRChpMTZ2ZWM0KTt1aW50MTZfdCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodWludDE2X3QpO3UxNnZlYzIgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbkFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5BTUQodTE2dmVjMyk7dTE2dmVjNCAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuQU1EKHUxNnZlYzQpO2Zsb2F0IG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChmbG9hdCk7dmVjMiAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHZlYzIpO3ZlYzMgIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodmVjNCk7aW50ICAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGludCk7aXZlYzIgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoaXZlYzMpO2l2ZWM0IG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpdmVjNCk7dWludCAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1dmVjMik7dXZlYzMgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHV2ZWMzKTt1dmVjNCBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZG91YmxlKTtkdmVjMiAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWMyKTtkdmVjMyAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWM0KTtpbnQ2NF90IG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpbnQ2NF90KTtpNjR2ZWMyIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWMzKTtpNjR2ZWM0IG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWM0KTt1aW50NjRfdCBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodTY0dmVjMyk7dTY0dmVjNCAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChmMTZ2ZWM0KTtpbnQxNl90IG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpbnQxNl90KTtpMTZ2ZWMyIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWM0KTt1aW50MTZfdCBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIG1pbkludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodTE2dmVjMyk7dTE2dmVjNCAgbWluSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZmxvYXQpO3ZlYzIgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodmVjMik7dmVjMyAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHZlYzQpO2ludCAgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaW50KTtpdmVjMiBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMzKTtpdmVjNCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWM0KTt1aW50ICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzIpO3V2ZWMzIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzMpO3V2ZWM0IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGRvdWJsZSk7ZHZlYzIgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZHZlYzIpO2R2ZWMzICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChkdmVjNCk7aW50NjRfdCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDY0X3QpO2k2NHZlYzIgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTY0dmVjMyk7aTY0dmVjNCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGk2NHZlYzQpO3VpbnQ2NF90IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTY0dmVjMik7dTY0dmVjMyAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMik7ZjE2dmVjMyAgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjNCk7aW50MTZfdCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDE2X3QpO2kxNnZlYzIgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTE2dmVjMyk7aTE2dmVjNCBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGkxNnZlYzQpO3VpbnQxNl90IG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIG1pbkludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTE2dmVjMik7dTE2dmVjMyAgbWluSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZmxvYXQpO3ZlYzIgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodmVjMik7dmVjMyAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHZlYzQpO2ludCAgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaW50KTtpdmVjMiBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMzKTtpdmVjNCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWM0KTt1aW50ICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzIpO3V2ZWMzIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzMpO3V2ZWM0IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGRvdWJsZSk7ZHZlYzIgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZHZlYzIpO2R2ZWMzICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChkdmVjNCk7aW50NjRfdCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDY0X3QpO2k2NHZlYzIgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTY0dmVjMyk7aTY0dmVjNCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGk2NHZlYzQpO3VpbnQ2NF90IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTY0dmVjMik7dTY0dmVjMyAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMik7ZjE2dmVjMyAgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjNCk7aW50MTZfdCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDE2X3QpO2kxNnZlYzIgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTE2dmVjMyk7aTE2dmVjNCBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGkxNnZlYzQpO3VpbnQxNl90IG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIG1pbkludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTE2dmVjMik7dTE2dmVjMyAgbWluSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChmbG9hdCk7dmVjMiAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHZlYzIpO3ZlYzMgIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodmVjNCk7aW50ICAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGludCk7aXZlYzIgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoaXZlYzMpO2l2ZWM0IG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpdmVjNCk7dWludCAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1dmVjMik7dXZlYzMgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHV2ZWMzKTt1dmVjNCBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZG91YmxlKTtkdmVjMiAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWMyKTtkdmVjMyAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWM0KTtpbnQ2NF90IG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpbnQ2NF90KTtpNjR2ZWMyIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWMzKTtpNjR2ZWM0IG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWM0KTt1aW50NjRfdCBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodTY0dmVjMyk7dTY0dmVjNCAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChmMTZ2ZWM0KTtpbnQxNl90IG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpbnQxNl90KTtpMTZ2ZWMyIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWM0KTt1aW50MTZfdCBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIG1heEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBtYXhJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodTE2dmVjMyk7dTE2dmVjNCAgbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZmxvYXQpO3ZlYzIgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodmVjMik7dmVjMyAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHZlYzQpO2ludCAgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaW50KTtpdmVjMiBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMzKTtpdmVjNCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWM0KTt1aW50ICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzIpO3V2ZWMzIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzMpO3V2ZWM0IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGRvdWJsZSk7ZHZlYzIgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZHZlYzIpO2R2ZWMzICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChkdmVjNCk7aW50NjRfdCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDY0X3QpO2k2NHZlYzIgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTY0dmVjMyk7aTY0dmVjNCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGk2NHZlYzQpO3VpbnQ2NF90IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTY0dmVjMik7dTY0dmVjMyAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMik7ZjE2dmVjMyAgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjNCk7aW50MTZfdCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDE2X3QpO2kxNnZlYzIgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTE2dmVjMyk7aTE2dmVjNCBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGkxNnZlYzQpO3VpbnQxNl90IG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTE2dmVjMik7dTE2dmVjMyAgbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBtYXhJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZmxvYXQpO3ZlYzIgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodmVjMik7dmVjMyAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHZlYzQpO2ludCAgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaW50KTtpdmVjMiBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMzKTtpdmVjNCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWM0KTt1aW50ICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzIpO3V2ZWMzIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzMpO3V2ZWM0IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGRvdWJsZSk7ZHZlYzIgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZHZlYzIpO2R2ZWMzICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChkdmVjNCk7aW50NjRfdCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDY0X3QpO2k2NHZlYzIgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTY0dmVjMyk7aTY0dmVjNCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGk2NHZlYzQpO3VpbnQ2NF90IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTY0dmVjMik7dTY0dmVjMyAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMik7ZjE2dmVjMyAgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjNCk7aW50MTZfdCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDE2X3QpO2kxNnZlYzIgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTE2dmVjMyk7aTE2dmVjNCBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGkxNnZlYzQpO3VpbnQxNl90IG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTE2dmVjMik7dTE2dmVjMyAgbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBtYXhJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChmbG9hdCk7dmVjMiAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHZlYzIpO3ZlYzMgIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodmVjNCk7aW50ICAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGludCk7aXZlYzIgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoaXZlYzMpO2l2ZWM0IGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpdmVjNCk7dWludCAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1dmVjMik7dXZlYzMgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHV2ZWMzKTt1dmVjNCBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZG91YmxlKTtkdmVjMiAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWMyKTtkdmVjMyAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGR2ZWM0KTtpbnQ2NF90IGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpbnQ2NF90KTtpNjR2ZWMyIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWMzKTtpNjR2ZWM0IGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpNjR2ZWM0KTt1aW50NjRfdCBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1NjR2ZWMyKTt1NjR2ZWMzICBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodTY0dmVjMyk7dTY0dmVjNCAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZmxvYXQxNl90KTtmMTZ2ZWMyICAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKGYxNnZlYzIpO2YxNnZlYzMgICBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChmMTZ2ZWM0KTtpbnQxNl90IGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpbnQxNl90KTtpMTZ2ZWMyIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWMzKTtpMTZ2ZWM0IGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRChpMTZ2ZWM0KTt1aW50MTZfdCBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIGFkZEludm9jYXRpb25zTm9uVW5pZm9ybUFNRCh1MTZ2ZWMyKTt1MTZ2ZWMzICBhZGRJbnZvY2F0aW9uc05vblVuaWZvcm1BTUQodTE2dmVjMyk7dTE2dmVjNCAgYWRkSW52b2NhdGlvbnNOb25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZmxvYXQpO3ZlYzIgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodmVjMik7dmVjMyAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHZlYzQpO2ludCAgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaW50KTtpdmVjMiBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMzKTtpdmVjNCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWM0KTt1aW50ICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzIpO3V2ZWMzIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzMpO3V2ZWM0IGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGRvdWJsZSk7ZHZlYzIgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZHZlYzIpO2R2ZWMzICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChkdmVjNCk7aW50NjRfdCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDY0X3QpO2k2NHZlYzIgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTY0dmVjMyk7aTY0dmVjNCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGk2NHZlYzQpO3VpbnQ2NF90IGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTY0dmVjMik7dTY0dmVjMyAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMik7ZjE2dmVjMyAgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjNCk7aW50MTZfdCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDE2X3QpO2kxNnZlYzIgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTE2dmVjMyk7aTE2dmVjNCBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGkxNnZlYzQpO3VpbnQxNl90IGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTE2dmVjMik7dTE2dmVjMyAgYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBhZGRJbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZmxvYXQpO3ZlYzIgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodmVjMik7dmVjMyAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh2ZWMzKTt2ZWM0ICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHZlYzQpO2ludCAgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaW50KTtpdmVjMiBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMyKTtpdmVjMyBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWMzKTtpdmVjNCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGl2ZWM0KTt1aW50ICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHVpbnQpO3V2ZWMyIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzIpO3V2ZWMzIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzMpO3V2ZWM0IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodXZlYzQpO2RvdWJsZSBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGRvdWJsZSk7ZHZlYzIgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZHZlYzIpO2R2ZWMzICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGR2ZWMzKTtkdmVjNCAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChkdmVjNCk7aW50NjRfdCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDY0X3QpO2k2NHZlYzIgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpNjR2ZWMyKTtpNjR2ZWMzIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTY0dmVjMyk7aTY0dmVjNCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGk2NHZlYzQpO3VpbnQ2NF90IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDY0X3QpO3U2NHZlYzIgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTY0dmVjMik7dTY0dmVjMyAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1NjR2ZWMzKTt1NjR2ZWM0ICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHU2NHZlYzQpO2Zsb2F0MTZfdCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMik7ZjE2dmVjMyAgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjMyk7ZjE2dmVjNCAgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoZjE2dmVjNCk7aW50MTZfdCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGludDE2X3QpO2kxNnZlYzIgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRChpMTZ2ZWMyKTtpMTZ2ZWMzIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQoaTE2dmVjMyk7aTE2dmVjNCBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKGkxNnZlYzQpO3VpbnQxNl90IGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodWludDE2X3QpO3UxNnZlYzIgIGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm1BTUQodTE2dmVjMik7dTE2dmVjMyAgYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybUFNRCh1MTZ2ZWMzKTt1MTZ2ZWM0ICBhZGRJbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtQU1EKHUxNnZlYzQpO2Zsb2F0IHN3aXp6bGVJbnZvY2F0aW9uc0FNRChmbG9hdCwgdXZlYzQpO3ZlYzIgIHN3aXp6bGVJbnZvY2F0aW9uc0FNRCh2ZWMyLCAgdXZlYzQpO3ZlYzMgIHN3aXp6bGVJbnZvY2F0aW9uc0FNRCh2ZWMzLCAgdXZlYzQpO3ZlYzQgIHN3aXp6bGVJbnZvY2F0aW9uc0FNRCh2ZWM0LCAgdXZlYzQpO2ludCAgIHN3aXp6bGVJbnZvY2F0aW9uc0FNRChpbnQsICAgdXZlYzQpO2l2ZWMyIHN3aXp6bGVJbnZvY2F0aW9uc0FNRChpdmVjMiwgdXZlYzQpO2l2ZWMzIHN3aXp6bGVJbnZvY2F0aW9uc0FNRChpdmVjMywgdXZlYzQpO2l2ZWM0IHN3aXp6bGVJbnZvY2F0aW9uc0FNRChpdmVjNCwgdXZlYzQpO3VpbnQgIHN3aXp6bGVJbnZvY2F0aW9uc0FNRCh1aW50LCAgdXZlYzQpO3V2ZWMyIHN3aXp6bGVJbnZvY2F0aW9uc0FNRCh1dmVjMiwgdXZlYzQpO3V2ZWMzIHN3aXp6bGVJbnZvY2F0aW9uc0FNRCh1dmVjMywgdXZlYzQpO3V2ZWM0IHN3aXp6bGVJbnZvY2F0aW9uc0FNRCh1dmVjNCwgdXZlYzQpO2Zsb2F0IHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRChmbG9hdCwgdXZlYzMpO3ZlYzIgIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRCh2ZWMyLCAgdXZlYzMpO3ZlYzMgIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRCh2ZWMzLCAgdXZlYzMpO3ZlYzQgIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRCh2ZWM0LCAgdXZlYzMpO2ludCAgIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRChpbnQsICAgdXZlYzMpO2l2ZWMyIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRChpdmVjMiwgdXZlYzMpO2l2ZWMzIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRChpdmVjMywgdXZlYzMpO2l2ZWM0IHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRChpdmVjNCwgdXZlYzMpO3VpbnQgIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRCh1aW50LCAgdXZlYzMpO3V2ZWMyIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRCh1dmVjMiwgdXZlYzMpO3V2ZWMzIHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRCh1dmVjMywgdXZlYzMpO3V2ZWM0IHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZEFNRCh1dmVjNCwgdXZlYzMpO2Zsb2F0IHdyaXRlSW52b2NhdGlvbkFNRChmbG9hdCwgZmxvYXQsIHVpbnQpO3ZlYzIgIHdyaXRlSW52b2NhdGlvbkFNRCh2ZWMyLCAgdmVjMiwgIHVpbnQpO3ZlYzMgIHdyaXRlSW52b2NhdGlvbkFNRCh2ZWMzLCAgdmVjMywgIHVpbnQpO3ZlYzQgIHdyaXRlSW52b2NhdGlvbkFNRCh2ZWM0LCAgdmVjNCwgIHVpbnQpO2ludCAgIHdyaXRlSW52b2NhdGlvbkFNRChpbnQsICAgaW50LCAgIHVpbnQpO2l2ZWMyIHdyaXRlSW52b2NhdGlvbkFNRChpdmVjMiwgaXZlYzIsIHVpbnQpO2l2ZWMzIHdyaXRlSW52b2NhdGlvbkFNRChpdmVjMywgaXZlYzMsIHVpbnQpO2l2ZWM0IHdyaXRlSW52b2NhdGlvbkFNRChpdmVjNCwgaXZlYzQsIHVpbnQpO3VpbnQgIHdyaXRlSW52b2NhdGlvbkFNRCh1aW50LCAgdWludCwgIHVpbnQpO3V2ZWMyIHdyaXRlSW52b2NhdGlvbkFNRCh1dmVjMiwgdXZlYzIsIHVpbnQpO3V2ZWMzIHdyaXRlSW52b2NhdGlvbkFNRCh1dmVjMywgdXZlYzMsIHVpbnQpO3V2ZWM0IHdyaXRlSW52b2NhdGlvbkFNRCh1dmVjNCwgdXZlYzQsIHVpbnQpO3VpbnQgbWJjbnRBTUQodWludDY0X3QpOwoAZmxvYXQgY3ViZUZhY2VJbmRleEFNRCh2ZWMzKTt2ZWMyICBjdWJlRmFjZUNvb3JkQU1EKHZlYzMpO3VpbnQ2NF90IHRpbWVBTUQoKTtpbiBpbnQgZ2xfU0lNREdyb3VwU2l6ZUFNRDsKAHN0cnVjdCBnbF9UZXh0dXJlRm9vdHByaW50MkROViB7dXZlYzIgYW5jaG9yO3V2ZWMyIG9mZnNldDt1dmVjMiBtYXNrO3VpbnQgbG9kO3VpbnQgZ3JhbnVsYXJpdHk7fTtzdHJ1Y3QgZ2xfVGV4dHVyZUZvb3RwcmludDNETlYge3V2ZWMzIGFuY2hvcjt1dmVjMyBvZmZzZXQ7dXZlYzIgbWFzazt1aW50IGxvZDt1aW50IGdyYW51bGFyaXR5O307Ym9vbCB0ZXh0dXJlRm9vdHByaW50TlYoc2FtcGxlcjJELCB2ZWMyLCBpbnQsIGJvb2wsIG91dCBnbF9UZXh0dXJlRm9vdHByaW50MkROVik7Ym9vbCB0ZXh0dXJlRm9vdHByaW50TlYoc2FtcGxlcjNELCB2ZWMzLCBpbnQsIGJvb2wsIG91dCBnbF9UZXh0dXJlRm9vdHByaW50M0ROVik7Ym9vbCB0ZXh0dXJlRm9vdHByaW50TlYoc2FtcGxlcjJELCB2ZWMyLCBpbnQsIGJvb2wsIG91dCBnbF9UZXh0dXJlRm9vdHByaW50MkROViwgZmxvYXQpO2Jvb2wgdGV4dHVyZUZvb3RwcmludE5WKHNhbXBsZXIzRCwgdmVjMywgaW50LCBib29sLCBvdXQgZ2xfVGV4dHVyZUZvb3RwcmludDNETlYsIGZsb2F0KTtib29sIHRleHR1cmVGb290cHJpbnRDbGFtcE5WKHNhbXBsZXIyRCwgdmVjMiwgZmxvYXQsIGludCwgYm9vbCwgb3V0IGdsX1RleHR1cmVGb290cHJpbnQyRE5WKTtib29sIHRleHR1cmVGb290cHJpbnRDbGFtcE5WKHNhbXBsZXIzRCwgdmVjMywgZmxvYXQsIGludCwgYm9vbCwgb3V0IGdsX1RleHR1cmVGb290cHJpbnQzRE5WKTtib29sIHRleHR1cmVGb290cHJpbnRDbGFtcE5WKHNhbXBsZXIyRCwgdmVjMiwgZmxvYXQsIGludCwgYm9vbCwgb3V0IGdsX1RleHR1cmVGb290cHJpbnQyRE5WLCBmbG9hdCk7Ym9vbCB0ZXh0dXJlRm9vdHByaW50Q2xhbXBOVihzYW1wbGVyM0QsIHZlYzMsIGZsb2F0LCBpbnQsIGJvb2wsIG91dCBnbF9UZXh0dXJlRm9vdHByaW50M0ROViwgZmxvYXQpO2Jvb2wgdGV4dHVyZUZvb3RwcmludExvZE5WKHNhbXBsZXIyRCwgdmVjMiwgZmxvYXQsIGludCwgYm9vbCwgb3V0IGdsX1RleHR1cmVGb290cHJpbnQyRE5WKTtib29sIHRleHR1cmVGb290cHJpbnRMb2ROVihzYW1wbGVyM0QsIHZlYzMsIGZsb2F0LCBpbnQsIGJvb2wsIG91dCBnbF9UZXh0dXJlRm9vdHByaW50M0ROVik7Ym9vbCB0ZXh0dXJlRm9vdHByaW50R3JhZE5WKHNhbXBsZXIyRCwgdmVjMiwgdmVjMiwgdmVjMiwgaW50LCBib29sLCBvdXQgZ2xfVGV4dHVyZUZvb3RwcmludDJETlYpO2Jvb2wgdGV4dHVyZUZvb3RwcmludEdyYWRDbGFtcE5WKHNhbXBsZXIyRCwgdmVjMiwgdmVjMiwgdmVjMiwgZmxvYXQsIGludCwgYm9vbCwgb3V0IGdsX1RleHR1cmVGb290cHJpbnQyRE5WKTsKAHVpbnQgZnJhZ21lbnRNYXNrRmV0Y2hBTUQoc2FtcGxlcjJETVMsICAgICAgIGl2ZWMyKTt1aW50IGZyYWdtZW50TWFza0ZldGNoQU1EKGlzYW1wbGVyMkRNUywgICAgICBpdmVjMik7dWludCBmcmFnbWVudE1hc2tGZXRjaEFNRCh1c2FtcGxlcjJETVMsICAgICAgaXZlYzIpO3VpbnQgZnJhZ21lbnRNYXNrRmV0Y2hBTUQoc2FtcGxlcjJETVNBcnJheSwgIGl2ZWMzKTt1aW50IGZyYWdtZW50TWFza0ZldGNoQU1EKGlzYW1wbGVyMkRNU0FycmF5LCBpdmVjMyk7dWludCBmcmFnbWVudE1hc2tGZXRjaEFNRCh1c2FtcGxlcjJETVNBcnJheSwgaXZlYzMpO3ZlYzQgIGZyYWdtZW50RmV0Y2hBTUQoc2FtcGxlcjJETVMsICAgICAgIGl2ZWMyLCB1aW50KTtpdmVjNCBmcmFnbWVudEZldGNoQU1EKGlzYW1wbGVyMkRNUywgICAgICBpdmVjMiwgdWludCk7dXZlYzQgZnJhZ21lbnRGZXRjaEFNRCh1c2FtcGxlcjJETVMsICAgICAgaXZlYzIsIHVpbnQpO3ZlYzQgIGZyYWdtZW50RmV0Y2hBTUQoc2FtcGxlcjJETVNBcnJheSwgIGl2ZWMzLCB1aW50KTtpdmVjNCBmcmFnbWVudEZldGNoQU1EKGlzYW1wbGVyMkRNU0FycmF5LCBpdmVjMywgdWludCk7dXZlYzQgZnJhZ21lbnRGZXRjaEFNRCh1c2FtcGxlcjJETVNBcnJheSwgaXZlYzMsIHVpbnQpOwoAZmxvYXQxNl90IHJhZGlhbnMoZmxvYXQxNl90KTtmMTZ2ZWMyICAgcmFkaWFucyhmMTZ2ZWMyKTtmMTZ2ZWMzICAgcmFkaWFucyhmMTZ2ZWMzKTtmMTZ2ZWM0ICAgcmFkaWFucyhmMTZ2ZWM0KTtmbG9hdDE2X3QgZGVncmVlcyhmbG9hdDE2X3QpO2YxNnZlYzIgICBkZWdyZWVzKGYxNnZlYzIpO2YxNnZlYzMgICBkZWdyZWVzKGYxNnZlYzMpO2YxNnZlYzQgICBkZWdyZWVzKGYxNnZlYzQpO2Zsb2F0MTZfdCBzaW4oZmxvYXQxNl90KTtmMTZ2ZWMyICAgc2luKGYxNnZlYzIpO2YxNnZlYzMgICBzaW4oZjE2dmVjMyk7ZjE2dmVjNCAgIHNpbihmMTZ2ZWM0KTtmbG9hdDE2X3QgY29zKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGNvcyhmMTZ2ZWMyKTtmMTZ2ZWMzICAgY29zKGYxNnZlYzMpO2YxNnZlYzQgICBjb3MoZjE2dmVjNCk7ZmxvYXQxNl90IHRhbihmbG9hdDE2X3QpO2YxNnZlYzIgICB0YW4oZjE2dmVjMik7ZjE2dmVjMyAgIHRhbihmMTZ2ZWMzKTtmMTZ2ZWM0ICAgdGFuKGYxNnZlYzQpO2Zsb2F0MTZfdCBhc2luKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGFzaW4oZjE2dmVjMik7ZjE2dmVjMyAgIGFzaW4oZjE2dmVjMyk7ZjE2dmVjNCAgIGFzaW4oZjE2dmVjNCk7ZmxvYXQxNl90IGFjb3MoZmxvYXQxNl90KTtmMTZ2ZWMyICAgYWNvcyhmMTZ2ZWMyKTtmMTZ2ZWMzICAgYWNvcyhmMTZ2ZWMzKTtmMTZ2ZWM0ICAgYWNvcyhmMTZ2ZWM0KTtmbG9hdDE2X3QgYXRhbihmbG9hdDE2X3QsIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGF0YW4oZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgYXRhbihmMTZ2ZWMzLCAgIGYxNnZlYzMpO2YxNnZlYzQgICBhdGFuKGYxNnZlYzQsICAgZjE2dmVjNCk7ZmxvYXQxNl90IGF0YW4oZmxvYXQxNl90KTtmMTZ2ZWMyICAgYXRhbihmMTZ2ZWMyKTtmMTZ2ZWMzICAgYXRhbihmMTZ2ZWMzKTtmMTZ2ZWM0ICAgYXRhbihmMTZ2ZWM0KTtmbG9hdDE2X3Qgc2luaChmbG9hdDE2X3QpO2YxNnZlYzIgICBzaW5oKGYxNnZlYzIpO2YxNnZlYzMgICBzaW5oKGYxNnZlYzMpO2YxNnZlYzQgICBzaW5oKGYxNnZlYzQpO2Zsb2F0MTZfdCBjb3NoKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGNvc2goZjE2dmVjMik7ZjE2dmVjMyAgIGNvc2goZjE2dmVjMyk7ZjE2dmVjNCAgIGNvc2goZjE2dmVjNCk7ZmxvYXQxNl90IHRhbmgoZmxvYXQxNl90KTtmMTZ2ZWMyICAgdGFuaChmMTZ2ZWMyKTtmMTZ2ZWMzICAgdGFuaChmMTZ2ZWMzKTtmMTZ2ZWM0ICAgdGFuaChmMTZ2ZWM0KTtmbG9hdDE2X3QgYXNpbmgoZmxvYXQxNl90KTtmMTZ2ZWMyICAgYXNpbmgoZjE2dmVjMik7ZjE2dmVjMyAgIGFzaW5oKGYxNnZlYzMpO2YxNnZlYzQgICBhc2luaChmMTZ2ZWM0KTtmbG9hdDE2X3QgYWNvc2goZmxvYXQxNl90KTtmMTZ2ZWMyICAgYWNvc2goZjE2dmVjMik7ZjE2dmVjMyAgIGFjb3NoKGYxNnZlYzMpO2YxNnZlYzQgICBhY29zaChmMTZ2ZWM0KTtmbG9hdDE2X3QgYXRhbmgoZmxvYXQxNl90KTtmMTZ2ZWMyICAgYXRhbmgoZjE2dmVjMik7ZjE2dmVjMyAgIGF0YW5oKGYxNnZlYzMpO2YxNnZlYzQgICBhdGFuaChmMTZ2ZWM0KTtmbG9hdDE2X3QgcG93KGZsb2F0MTZfdCwgZmxvYXQxNl90KTtmMTZ2ZWMyICAgcG93KGYxNnZlYzIsICAgZjE2dmVjMik7ZjE2dmVjMyAgIHBvdyhmMTZ2ZWMzLCAgIGYxNnZlYzMpO2YxNnZlYzQgICBwb3coZjE2dmVjNCwgICBmMTZ2ZWM0KTtmbG9hdDE2X3QgZXhwKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGV4cChmMTZ2ZWMyKTtmMTZ2ZWMzICAgZXhwKGYxNnZlYzMpO2YxNnZlYzQgICBleHAoZjE2dmVjNCk7ZmxvYXQxNl90IGxvZyhmbG9hdDE2X3QpO2YxNnZlYzIgICBsb2coZjE2dmVjMik7ZjE2dmVjMyAgIGxvZyhmMTZ2ZWMzKTtmMTZ2ZWM0ICAgbG9nKGYxNnZlYzQpO2Zsb2F0MTZfdCBleHAyKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGV4cDIoZjE2dmVjMik7ZjE2dmVjMyAgIGV4cDIoZjE2dmVjMyk7ZjE2dmVjNCAgIGV4cDIoZjE2dmVjNCk7ZmxvYXQxNl90IGxvZzIoZmxvYXQxNl90KTtmMTZ2ZWMyICAgbG9nMihmMTZ2ZWMyKTtmMTZ2ZWMzICAgbG9nMihmMTZ2ZWMzKTtmMTZ2ZWM0ICAgbG9nMihmMTZ2ZWM0KTtmbG9hdDE2X3Qgc3FydChmbG9hdDE2X3QpO2YxNnZlYzIgICBzcXJ0KGYxNnZlYzIpO2YxNnZlYzMgICBzcXJ0KGYxNnZlYzMpO2YxNnZlYzQgICBzcXJ0KGYxNnZlYzQpO2Zsb2F0MTZfdCBpbnZlcnNlc3FydChmbG9hdDE2X3QpO2YxNnZlYzIgICBpbnZlcnNlc3FydChmMTZ2ZWMyKTtmMTZ2ZWMzICAgaW52ZXJzZXNxcnQoZjE2dmVjMyk7ZjE2dmVjNCAgIGludmVyc2VzcXJ0KGYxNnZlYzQpO2Zsb2F0MTZfdCBhYnMoZmxvYXQxNl90KTtmMTZ2ZWMyICAgYWJzKGYxNnZlYzIpO2YxNnZlYzMgICBhYnMoZjE2dmVjMyk7ZjE2dmVjNCAgIGFicyhmMTZ2ZWM0KTtmbG9hdDE2X3Qgc2lnbihmbG9hdDE2X3QpO2YxNnZlYzIgICBzaWduKGYxNnZlYzIpO2YxNnZlYzMgICBzaWduKGYxNnZlYzMpO2YxNnZlYzQgICBzaWduKGYxNnZlYzQpO2Zsb2F0MTZfdCBmbG9vcihmbG9hdDE2X3QpO2YxNnZlYzIgICBmbG9vcihmMTZ2ZWMyKTtmMTZ2ZWMzICAgZmxvb3IoZjE2dmVjMyk7ZjE2dmVjNCAgIGZsb29yKGYxNnZlYzQpO2Zsb2F0MTZfdCB0cnVuYyhmbG9hdDE2X3QpO2YxNnZlYzIgICB0cnVuYyhmMTZ2ZWMyKTtmMTZ2ZWMzICAgdHJ1bmMoZjE2dmVjMyk7ZjE2dmVjNCAgIHRydW5jKGYxNnZlYzQpO2Zsb2F0MTZfdCByb3VuZChmbG9hdDE2X3QpO2YxNnZlYzIgICByb3VuZChmMTZ2ZWMyKTtmMTZ2ZWMzICAgcm91bmQoZjE2dmVjMyk7ZjE2dmVjNCAgIHJvdW5kKGYxNnZlYzQpO2Zsb2F0MTZfdCByb3VuZEV2ZW4oZmxvYXQxNl90KTtmMTZ2ZWMyICAgcm91bmRFdmVuKGYxNnZlYzIpO2YxNnZlYzMgICByb3VuZEV2ZW4oZjE2dmVjMyk7ZjE2dmVjNCAgIHJvdW5kRXZlbihmMTZ2ZWM0KTtmbG9hdDE2X3QgY2VpbChmbG9hdDE2X3QpO2YxNnZlYzIgICBjZWlsKGYxNnZlYzIpO2YxNnZlYzMgICBjZWlsKGYxNnZlYzMpO2YxNnZlYzQgICBjZWlsKGYxNnZlYzQpO2Zsb2F0MTZfdCBmcmFjdChmbG9hdDE2X3QpO2YxNnZlYzIgICBmcmFjdChmMTZ2ZWMyKTtmMTZ2ZWMzICAgZnJhY3QoZjE2dmVjMyk7ZjE2dmVjNCAgIGZyYWN0KGYxNnZlYzQpO2Zsb2F0MTZfdCBtb2QoZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBtb2QoZjE2dmVjMiwgICBmbG9hdDE2X3QpO2YxNnZlYzMgICBtb2QoZjE2dmVjMywgICBmbG9hdDE2X3QpO2YxNnZlYzQgICBtb2QoZjE2dmVjNCwgICBmbG9hdDE2X3QpO2YxNnZlYzIgICBtb2QoZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgbW9kKGYxNnZlYzMsICAgZjE2dmVjMyk7ZjE2dmVjNCAgIG1vZChmMTZ2ZWM0LCAgIGYxNnZlYzQpO2Zsb2F0MTZfdCBtb2RmKGZsb2F0MTZfdCwgb3V0IGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1vZGYoZjE2dmVjMiwgICBvdXQgZjE2dmVjMik7ZjE2dmVjMyAgIG1vZGYoZjE2dmVjMywgICBvdXQgZjE2dmVjMyk7ZjE2dmVjNCAgIG1vZGYoZjE2dmVjNCwgICBvdXQgZjE2dmVjNCk7ZmxvYXQxNl90IG1pbihmbG9hdDE2X3QsIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1pbihmMTZ2ZWMyLCAgIGZsb2F0MTZfdCk7ZjE2dmVjMyAgIG1pbihmMTZ2ZWMzLCAgIGZsb2F0MTZfdCk7ZjE2dmVjNCAgIG1pbihmMTZ2ZWM0LCAgIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1pbihmMTZ2ZWMyLCAgIGYxNnZlYzIpO2YxNnZlYzMgICBtaW4oZjE2dmVjMywgICBmMTZ2ZWMzKTtmMTZ2ZWM0ICAgbWluKGYxNnZlYzQsICAgZjE2dmVjNCk7ZmxvYXQxNl90IG1heChmbG9hdDE2X3QsIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1heChmMTZ2ZWMyLCAgIGZsb2F0MTZfdCk7ZjE2dmVjMyAgIG1heChmMTZ2ZWMzLCAgIGZsb2F0MTZfdCk7ZjE2dmVjNCAgIG1heChmMTZ2ZWM0LCAgIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1heChmMTZ2ZWMyLCAgIGYxNnZlYzIpO2YxNnZlYzMgICBtYXgoZjE2dmVjMywgICBmMTZ2ZWMzKTtmMTZ2ZWM0ICAgbWF4KGYxNnZlYzQsICAgZjE2dmVjNCk7ZmxvYXQxNl90IGNsYW1wKGZsb2F0MTZfdCwgZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBjbGFtcChmMTZ2ZWMyLCAgIGZsb2F0MTZfdCwgZmxvYXQxNl90KTtmMTZ2ZWMzICAgY2xhbXAoZjE2dmVjMywgICBmbG9hdDE2X3QsIGZsb2F0MTZfdCk7ZjE2dmVjNCAgIGNsYW1wKGYxNnZlYzQsICAgZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBjbGFtcChmMTZ2ZWMyLCAgIGYxNnZlYzIsICAgZjE2dmVjMik7ZjE2dmVjMyAgIGNsYW1wKGYxNnZlYzMsICAgZjE2dmVjMywgICBmMTZ2ZWMzKTtmMTZ2ZWM0ICAgY2xhbXAoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGYxNnZlYzQpO2Zsb2F0MTZfdCBtaXgoZmxvYXQxNl90LCBmbG9hdDE2X3QsIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1peChmMTZ2ZWMyLCAgIGYxNnZlYzIsICAgZmxvYXQxNl90KTtmMTZ2ZWMzICAgbWl4KGYxNnZlYzMsICAgZjE2dmVjMywgICBmbG9hdDE2X3QpO2YxNnZlYzQgICBtaXgoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIG1peChmMTZ2ZWMyLCAgIGYxNnZlYzIsICAgZjE2dmVjMik7ZjE2dmVjMyAgIG1peChmMTZ2ZWMzLCAgIGYxNnZlYzMsICAgZjE2dmVjMyk7ZjE2dmVjNCAgIG1peChmMTZ2ZWM0LCAgIGYxNnZlYzQsICAgZjE2dmVjNCk7ZmxvYXQxNl90IG1peChmbG9hdDE2X3QsIGZsb2F0MTZfdCwgYm9vbCk7ZjE2dmVjMiAgIG1peChmMTZ2ZWMyLCAgIGYxNnZlYzIsICAgYnZlYzIpO2YxNnZlYzMgICBtaXgoZjE2dmVjMywgICBmMTZ2ZWMzLCAgIGJ2ZWMzKTtmMTZ2ZWM0ICAgbWl4KGYxNnZlYzQsICAgZjE2dmVjNCwgICBidmVjNCk7ZmxvYXQxNl90IHN0ZXAoZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBzdGVwKGYxNnZlYzIsICAgZjE2dmVjMik7ZjE2dmVjMyAgIHN0ZXAoZjE2dmVjMywgICBmMTZ2ZWMzKTtmMTZ2ZWM0ICAgc3RlcChmMTZ2ZWM0LCAgIGYxNnZlYzQpO2YxNnZlYzIgICBzdGVwKGZsb2F0MTZfdCwgZjE2dmVjMik7ZjE2dmVjMyAgIHN0ZXAoZmxvYXQxNl90LCBmMTZ2ZWMzKTtmMTZ2ZWM0ICAgc3RlcChmbG9hdDE2X3QsIGYxNnZlYzQpO2Zsb2F0MTZfdCBzbW9vdGhzdGVwKGZsb2F0MTZfdCwgZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBzbW9vdGhzdGVwKGYxNnZlYzIsICAgZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgc21vb3Roc3RlcChmMTZ2ZWMzLCAgIGYxNnZlYzMsICAgZjE2dmVjMyk7ZjE2dmVjNCAgIHNtb290aHN0ZXAoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGYxNnZlYzQpO2YxNnZlYzIgICBzbW9vdGhzdGVwKGZsb2F0MTZfdCwgZmxvYXQxNl90LCBmMTZ2ZWMyKTtmMTZ2ZWMzICAgc21vb3Roc3RlcChmbG9hdDE2X3QsIGZsb2F0MTZfdCwgZjE2dmVjMyk7ZjE2dmVjNCAgIHNtb290aHN0ZXAoZmxvYXQxNl90LCBmbG9hdDE2X3QsIGYxNnZlYzQpO2Jvb2wgIGlzbmFuKGZsb2F0MTZfdCk7YnZlYzIgaXNuYW4oZjE2dmVjMik7YnZlYzMgaXNuYW4oZjE2dmVjMyk7YnZlYzQgaXNuYW4oZjE2dmVjNCk7Ym9vbCAgaXNpbmYoZmxvYXQxNl90KTtidmVjMiBpc2luZihmMTZ2ZWMyKTtidmVjMyBpc2luZihmMTZ2ZWMzKTtidmVjNCBpc2luZihmMTZ2ZWM0KTtmbG9hdDE2X3QgZm1hKGZsb2F0MTZfdCwgZmxvYXQxNl90LCBmbG9hdDE2X3QpO2YxNnZlYzIgICBmbWEoZjE2dmVjMiwgICBmMTZ2ZWMyLCAgIGYxNnZlYzIpO2YxNnZlYzMgICBmbWEoZjE2dmVjMywgICBmMTZ2ZWMzLCAgIGYxNnZlYzMpO2YxNnZlYzQgICBmbWEoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGYxNnZlYzQpO2Zsb2F0MTZfdCBmcmV4cChmbG9hdDE2X3QsIG91dCBpbnQpO2YxNnZlYzIgICBmcmV4cChmMTZ2ZWMyLCAgIG91dCBpdmVjMik7ZjE2dmVjMyAgIGZyZXhwKGYxNnZlYzMsICAgb3V0IGl2ZWMzKTtmMTZ2ZWM0ICAgZnJleHAoZjE2dmVjNCwgICBvdXQgaXZlYzQpO2Zsb2F0MTZfdCBsZGV4cChmbG9hdDE2X3QsIGluIGludCk7ZjE2dmVjMiAgIGxkZXhwKGYxNnZlYzIsICAgaW4gaXZlYzIpO2YxNnZlYzMgICBsZGV4cChmMTZ2ZWMzLCAgIGluIGl2ZWMzKTtmMTZ2ZWM0ICAgbGRleHAoZjE2dmVjNCwgICBpbiBpdmVjNCk7dWludCAgICBwYWNrRmxvYXQyeDE2KGYxNnZlYzIpO2YxNnZlYzIgdW5wYWNrRmxvYXQyeDE2KHVpbnQpO2Zsb2F0MTZfdCBsZW5ndGgoZmxvYXQxNl90KTtmbG9hdDE2X3QgbGVuZ3RoKGYxNnZlYzIpO2Zsb2F0MTZfdCBsZW5ndGgoZjE2dmVjMyk7ZmxvYXQxNl90IGxlbmd0aChmMTZ2ZWM0KTtmbG9hdDE2X3QgZGlzdGFuY2UoZmxvYXQxNl90LCBmbG9hdDE2X3QpO2Zsb2F0MTZfdCBkaXN0YW5jZShmMTZ2ZWMyLCAgIGYxNnZlYzIpO2Zsb2F0MTZfdCBkaXN0YW5jZShmMTZ2ZWMzLCAgIGYxNnZlYzMpO2Zsb2F0MTZfdCBkaXN0YW5jZShmMTZ2ZWM0LCAgIGYxNnZlYzQpO2Zsb2F0MTZfdCBkb3QoZmxvYXQxNl90LCBmbG9hdDE2X3QpO2Zsb2F0MTZfdCBkb3QoZjE2dmVjMiwgICBmMTZ2ZWMyKTtmbG9hdDE2X3QgZG90KGYxNnZlYzMsICAgZjE2dmVjMyk7ZmxvYXQxNl90IGRvdChmMTZ2ZWM0LCAgIGYxNnZlYzQpO2YxNnZlYzMgY3Jvc3MoZjE2dmVjMywgZjE2dmVjMyk7ZmxvYXQxNl90IG5vcm1hbGl6ZShmbG9hdDE2X3QpO2YxNnZlYzIgICBub3JtYWxpemUoZjE2dmVjMik7ZjE2dmVjMyAgIG5vcm1hbGl6ZShmMTZ2ZWMzKTtmMTZ2ZWM0ICAgbm9ybWFsaXplKGYxNnZlYzQpO2Zsb2F0MTZfdCBmYWNlZm9yd2FyZChmbG9hdDE2X3QsIGZsb2F0MTZfdCwgZmxvYXQxNl90KTtmMTZ2ZWMyICAgZmFjZWZvcndhcmQoZjE2dmVjMiwgICBmMTZ2ZWMyLCAgIGYxNnZlYzIpO2YxNnZlYzMgICBmYWNlZm9yd2FyZChmMTZ2ZWMzLCAgIGYxNnZlYzMsICAgZjE2dmVjMyk7ZjE2dmVjNCAgIGZhY2Vmb3J3YXJkKGYxNnZlYzQsICAgZjE2dmVjNCwgICBmMTZ2ZWM0KTtmbG9hdDE2X3QgcmVmbGVjdChmbG9hdDE2X3QsIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIHJlZmxlY3QoZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgcmVmbGVjdChmMTZ2ZWMzLCAgIGYxNnZlYzMpO2YxNnZlYzQgICByZWZsZWN0KGYxNnZlYzQsICAgZjE2dmVjNCk7ZmxvYXQxNl90IHJlZnJhY3QoZmxvYXQxNl90LCBmbG9hdDE2X3QsIGZsb2F0MTZfdCk7ZjE2dmVjMiAgIHJlZnJhY3QoZjE2dmVjMiwgICBmMTZ2ZWMyLCAgIGZsb2F0MTZfdCk7ZjE2dmVjMyAgIHJlZnJhY3QoZjE2dmVjMywgICBmMTZ2ZWMzLCAgIGZsb2F0MTZfdCk7ZjE2dmVjNCAgIHJlZnJhY3QoZjE2dmVjNCwgICBmMTZ2ZWM0LCAgIGZsb2F0MTZfdCk7ZjE2bWF0MiAgIG1hdHJpeENvbXBNdWx0KGYxNm1hdDIsICAgZjE2bWF0Mik7ZjE2bWF0MyAgIG1hdHJpeENvbXBNdWx0KGYxNm1hdDMsICAgZjE2bWF0Myk7ZjE2bWF0NCAgIG1hdHJpeENvbXBNdWx0KGYxNm1hdDQsICAgZjE2bWF0NCk7ZjE2bWF0MngzIG1hdHJpeENvbXBNdWx0KGYxNm1hdDJ4MywgZjE2bWF0MngzKTtmMTZtYXQyeDQgbWF0cml4Q29tcE11bHQoZjE2bWF0Mng0LCBmMTZtYXQyeDQpO2YxNm1hdDN4MiBtYXRyaXhDb21wTXVsdChmMTZtYXQzeDIsIGYxNm1hdDN4Mik7ZjE2bWF0M3g0IG1hdHJpeENvbXBNdWx0KGYxNm1hdDN4NCwgZjE2bWF0M3g0KTtmMTZtYXQ0eDIgbWF0cml4Q29tcE11bHQoZjE2bWF0NHgyLCBmMTZtYXQ0eDIpO2YxNm1hdDR4MyBtYXRyaXhDb21wTXVsdChmMTZtYXQ0eDMsIGYxNm1hdDR4Myk7ZjE2bWF0MiAgIG91dGVyUHJvZHVjdChmMTZ2ZWMyLCBmMTZ2ZWMyKTtmMTZtYXQzICAgb3V0ZXJQcm9kdWN0KGYxNnZlYzMsIGYxNnZlYzMpO2YxNm1hdDQgICBvdXRlclByb2R1Y3QoZjE2dmVjNCwgZjE2dmVjNCk7ZjE2bWF0MngzIG91dGVyUHJvZHVjdChmMTZ2ZWMzLCBmMTZ2ZWMyKTtmMTZtYXQzeDIgb3V0ZXJQcm9kdWN0KGYxNnZlYzIsIGYxNnZlYzMpO2YxNm1hdDJ4NCBvdXRlclByb2R1Y3QoZjE2dmVjNCwgZjE2dmVjMik7ZjE2bWF0NHgyIG91dGVyUHJvZHVjdChmMTZ2ZWMyLCBmMTZ2ZWM0KTtmMTZtYXQzeDQgb3V0ZXJQcm9kdWN0KGYxNnZlYzQsIGYxNnZlYzMpO2YxNm1hdDR4MyBvdXRlclByb2R1Y3QoZjE2dmVjMywgZjE2dmVjNCk7ZjE2bWF0MiAgIHRyYW5zcG9zZShmMTZtYXQyKTtmMTZtYXQzICAgdHJhbnNwb3NlKGYxNm1hdDMpO2YxNm1hdDQgICB0cmFuc3Bvc2UoZjE2bWF0NCk7ZjE2bWF0MngzIHRyYW5zcG9zZShmMTZtYXQzeDIpO2YxNm1hdDN4MiB0cmFuc3Bvc2UoZjE2bWF0MngzKTtmMTZtYXQyeDQgdHJhbnNwb3NlKGYxNm1hdDR4Mik7ZjE2bWF0NHgyIHRyYW5zcG9zZShmMTZtYXQyeDQpO2YxNm1hdDN4NCB0cmFuc3Bvc2UoZjE2bWF0NHgzKTtmMTZtYXQ0eDMgdHJhbnNwb3NlKGYxNm1hdDN4NCk7ZmxvYXQxNl90IGRldGVybWluYW50KGYxNm1hdDIpO2Zsb2F0MTZfdCBkZXRlcm1pbmFudChmMTZtYXQzKTtmbG9hdDE2X3QgZGV0ZXJtaW5hbnQoZjE2bWF0NCk7ZjE2bWF0MiBpbnZlcnNlKGYxNm1hdDIpO2YxNm1hdDMgaW52ZXJzZShmMTZtYXQzKTtmMTZtYXQ0IGludmVyc2UoZjE2bWF0NCk7YnZlYzIgbGVzc1RoYW4oZjE2dmVjMiwgZjE2dmVjMik7YnZlYzMgbGVzc1RoYW4oZjE2dmVjMywgZjE2dmVjMyk7YnZlYzQgbGVzc1RoYW4oZjE2dmVjNCwgZjE2dmVjNCk7YnZlYzIgbGVzc1RoYW5FcXVhbChmMTZ2ZWMyLCBmMTZ2ZWMyKTtidmVjMyBsZXNzVGhhbkVxdWFsKGYxNnZlYzMsIGYxNnZlYzMpO2J2ZWM0IGxlc3NUaGFuRXF1YWwoZjE2dmVjNCwgZjE2dmVjNCk7YnZlYzIgZ3JlYXRlclRoYW4oZjE2dmVjMiwgZjE2dmVjMik7YnZlYzMgZ3JlYXRlclRoYW4oZjE2dmVjMywgZjE2dmVjMyk7YnZlYzQgZ3JlYXRlclRoYW4oZjE2dmVjNCwgZjE2dmVjNCk7YnZlYzIgZ3JlYXRlclRoYW5FcXVhbChmMTZ2ZWMyLCBmMTZ2ZWMyKTtidmVjMyBncmVhdGVyVGhhbkVxdWFsKGYxNnZlYzMsIGYxNnZlYzMpO2J2ZWM0IGdyZWF0ZXJUaGFuRXF1YWwoZjE2dmVjNCwgZjE2dmVjNCk7YnZlYzIgZXF1YWwoZjE2dmVjMiwgZjE2dmVjMik7YnZlYzMgZXF1YWwoZjE2dmVjMywgZjE2dmVjMyk7YnZlYzQgZXF1YWwoZjE2dmVjNCwgZjE2dmVjNCk7YnZlYzIgbm90RXF1YWwoZjE2dmVjMiwgZjE2dmVjMik7YnZlYzMgbm90RXF1YWwoZjE2dmVjMywgZjE2dmVjMyk7YnZlYzQgbm90RXF1YWwoZjE2dmVjNCwgZjE2dmVjNCk7CgBpbnQ4X3QgYWJzKGludDhfdCk7aTh2ZWMyIGFicyhpOHZlYzIpO2k4dmVjMyBhYnMoaTh2ZWMzKTtpOHZlYzQgYWJzKGk4dmVjNCk7aW50OF90IHNpZ24oaW50OF90KTtpOHZlYzIgc2lnbihpOHZlYzIpO2k4dmVjMyBzaWduKGk4dmVjMyk7aTh2ZWM0IHNpZ24oaTh2ZWM0KTtpbnQ4X3QgbWluKGludDhfdCB4LCBpbnQ4X3QgeSk7aTh2ZWMyIG1pbihpOHZlYzIgeCwgaW50OF90IHkpO2k4dmVjMyBtaW4oaTh2ZWMzIHgsIGludDhfdCB5KTtpOHZlYzQgbWluKGk4dmVjNCB4LCBpbnQ4X3QgeSk7aTh2ZWMyIG1pbihpOHZlYzIgeCwgaTh2ZWMyIHkpO2k4dmVjMyBtaW4oaTh2ZWMzIHgsIGk4dmVjMyB5KTtpOHZlYzQgbWluKGk4dmVjNCB4LCBpOHZlYzQgeSk7dWludDhfdCBtaW4odWludDhfdCB4LCB1aW50OF90IHkpO3U4dmVjMiBtaW4odTh2ZWMyIHgsIHVpbnQ4X3QgeSk7dTh2ZWMzIG1pbih1OHZlYzMgeCwgdWludDhfdCB5KTt1OHZlYzQgbWluKHU4dmVjNCB4LCB1aW50OF90IHkpO3U4dmVjMiBtaW4odTh2ZWMyIHgsIHU4dmVjMiB5KTt1OHZlYzMgbWluKHU4dmVjMyB4LCB1OHZlYzMgeSk7dTh2ZWM0IG1pbih1OHZlYzQgeCwgdTh2ZWM0IHkpO2ludDhfdCBtYXgoaW50OF90IHgsIGludDhfdCB5KTtpOHZlYzIgbWF4KGk4dmVjMiB4LCBpbnQ4X3QgeSk7aTh2ZWMzIG1heChpOHZlYzMgeCwgaW50OF90IHkpO2k4dmVjNCBtYXgoaTh2ZWM0IHgsIGludDhfdCB5KTtpOHZlYzIgbWF4KGk4dmVjMiB4LCBpOHZlYzIgeSk7aTh2ZWMzIG1heChpOHZlYzMgeCwgaTh2ZWMzIHkpO2k4dmVjNCBtYXgoaTh2ZWM0IHgsIGk4dmVjNCB5KTt1aW50OF90IG1heCh1aW50OF90IHgsIHVpbnQ4X3QgeSk7dTh2ZWMyIG1heCh1OHZlYzIgeCwgdWludDhfdCB5KTt1OHZlYzMgbWF4KHU4dmVjMyB4LCB1aW50OF90IHkpO3U4dmVjNCBtYXgodTh2ZWM0IHgsIHVpbnQ4X3QgeSk7dTh2ZWMyIG1heCh1OHZlYzIgeCwgdTh2ZWMyIHkpO3U4dmVjMyBtYXgodTh2ZWMzIHgsIHU4dmVjMyB5KTt1OHZlYzQgbWF4KHU4dmVjNCB4LCB1OHZlYzQgeSk7aW50OF90ICAgIGNsYW1wKGludDhfdCB4LCBpbnQ4X3QgbWluVmFsLCBpbnQ4X3QgbWF4VmFsKTtpOHZlYzIgIGNsYW1wKGk4dmVjMiAgeCwgaW50OF90IG1pblZhbCwgaW50OF90IG1heFZhbCk7aTh2ZWMzICBjbGFtcChpOHZlYzMgIHgsIGludDhfdCBtaW5WYWwsIGludDhfdCBtYXhWYWwpO2k4dmVjNCAgY2xhbXAoaTh2ZWM0ICB4LCBpbnQ4X3QgbWluVmFsLCBpbnQ4X3QgbWF4VmFsKTtpOHZlYzIgIGNsYW1wKGk4dmVjMiAgeCwgaTh2ZWMyICBtaW5WYWwsIGk4dmVjMiAgbWF4VmFsKTtpOHZlYzMgIGNsYW1wKGk4dmVjMyAgeCwgaTh2ZWMzICBtaW5WYWwsIGk4dmVjMyAgbWF4VmFsKTtpOHZlYzQgIGNsYW1wKGk4dmVjNCAgeCwgaTh2ZWM0ICBtaW5WYWwsIGk4dmVjNCAgbWF4VmFsKTt1aW50OF90ICAgY2xhbXAodWludDhfdCB4LCB1aW50OF90IG1pblZhbCwgdWludDhfdCBtYXhWYWwpO3U4dmVjMiAgY2xhbXAodTh2ZWMyICB4LCB1aW50OF90IG1pblZhbCwgdWludDhfdCBtYXhWYWwpO3U4dmVjMyAgY2xhbXAodTh2ZWMzICB4LCB1aW50OF90IG1pblZhbCwgdWludDhfdCBtYXhWYWwpO3U4dmVjNCAgY2xhbXAodTh2ZWM0ICB4LCB1aW50OF90IG1pblZhbCwgdWludDhfdCBtYXhWYWwpO3U4dmVjMiAgY2xhbXAodTh2ZWMyICB4LCB1OHZlYzIgIG1pblZhbCwgdTh2ZWMyICBtYXhWYWwpO3U4dmVjMyAgY2xhbXAodTh2ZWMzICB4LCB1OHZlYzMgIG1pblZhbCwgdTh2ZWMzICBtYXhWYWwpO3U4dmVjNCAgY2xhbXAodTh2ZWM0ICB4LCB1OHZlYzQgIG1pblZhbCwgdTh2ZWM0ICBtYXhWYWwpO2ludDhfdCAgbWl4KGludDhfdCwgIGludDhfdCwgIGJvb2wpO2k4dmVjMiAgbWl4KGk4dmVjMiwgIGk4dmVjMiwgIGJ2ZWMyKTtpOHZlYzMgIG1peChpOHZlYzMsICBpOHZlYzMsICBidmVjMyk7aTh2ZWM0ICBtaXgoaTh2ZWM0LCAgaTh2ZWM0LCAgYnZlYzQpO3VpbnQ4X3QgbWl4KHVpbnQ4X3QsIHVpbnQ4X3QsIGJvb2wpO3U4dmVjMiAgbWl4KHU4dmVjMiwgIHU4dmVjMiwgIGJ2ZWMyKTt1OHZlYzMgIG1peCh1OHZlYzMsICB1OHZlYzMsICBidmVjMyk7dTh2ZWM0ICBtaXgodTh2ZWM0LCAgdTh2ZWM0LCAgYnZlYzQpO2J2ZWMyIGxlc3NUaGFuKGk4dmVjMiwgaTh2ZWMyKTtidmVjMyBsZXNzVGhhbihpOHZlYzMsIGk4dmVjMyk7YnZlYzQgbGVzc1RoYW4oaTh2ZWM0LCBpOHZlYzQpO2J2ZWMyIGxlc3NUaGFuKHU4dmVjMiwgdTh2ZWMyKTtidmVjMyBsZXNzVGhhbih1OHZlYzMsIHU4dmVjMyk7YnZlYzQgbGVzc1RoYW4odTh2ZWM0LCB1OHZlYzQpO2J2ZWMyIGxlc3NUaGFuRXF1YWwoaTh2ZWMyLCBpOHZlYzIpO2J2ZWMzIGxlc3NUaGFuRXF1YWwoaTh2ZWMzLCBpOHZlYzMpO2J2ZWM0IGxlc3NUaGFuRXF1YWwoaTh2ZWM0LCBpOHZlYzQpO2J2ZWMyIGxlc3NUaGFuRXF1YWwodTh2ZWMyLCB1OHZlYzIpO2J2ZWMzIGxlc3NUaGFuRXF1YWwodTh2ZWMzLCB1OHZlYzMpO2J2ZWM0IGxlc3NUaGFuRXF1YWwodTh2ZWM0LCB1OHZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuKGk4dmVjMiwgaTh2ZWMyKTtidmVjMyBncmVhdGVyVGhhbihpOHZlYzMsIGk4dmVjMyk7YnZlYzQgZ3JlYXRlclRoYW4oaTh2ZWM0LCBpOHZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuKHU4dmVjMiwgdTh2ZWMyKTtidmVjMyBncmVhdGVyVGhhbih1OHZlYzMsIHU4dmVjMyk7YnZlYzQgZ3JlYXRlclRoYW4odTh2ZWM0LCB1OHZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuRXF1YWwoaTh2ZWMyLCBpOHZlYzIpO2J2ZWMzIGdyZWF0ZXJUaGFuRXF1YWwoaTh2ZWMzLCBpOHZlYzMpO2J2ZWM0IGdyZWF0ZXJUaGFuRXF1YWwoaTh2ZWM0LCBpOHZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuRXF1YWwodTh2ZWMyLCB1OHZlYzIpO2J2ZWMzIGdyZWF0ZXJUaGFuRXF1YWwodTh2ZWMzLCB1OHZlYzMpO2J2ZWM0IGdyZWF0ZXJUaGFuRXF1YWwodTh2ZWM0LCB1OHZlYzQpO2J2ZWMyIGVxdWFsKGk4dmVjMiwgaTh2ZWMyKTtidmVjMyBlcXVhbChpOHZlYzMsIGk4dmVjMyk7YnZlYzQgZXF1YWwoaTh2ZWM0LCBpOHZlYzQpO2J2ZWMyIGVxdWFsKHU4dmVjMiwgdTh2ZWMyKTtidmVjMyBlcXVhbCh1OHZlYzMsIHU4dmVjMyk7YnZlYzQgZXF1YWwodTh2ZWM0LCB1OHZlYzQpO2J2ZWMyIG5vdEVxdWFsKGk4dmVjMiwgaTh2ZWMyKTtidmVjMyBub3RFcXVhbChpOHZlYzMsIGk4dmVjMyk7YnZlYzQgbm90RXF1YWwoaTh2ZWM0LCBpOHZlYzQpO2J2ZWMyIG5vdEVxdWFsKHU4dmVjMiwgdTh2ZWMyKTtidmVjMyBub3RFcXVhbCh1OHZlYzMsIHU4dmVjMyk7YnZlYzQgbm90RXF1YWwodTh2ZWM0LCB1OHZlYzQpOyAgaW50OF90IGJpdGZpZWxkRXh0cmFjdCggIGludDhfdCwgaW50OF90LCBpbnQ4X3QpO2k4dmVjMiBiaXRmaWVsZEV4dHJhY3QoaTh2ZWMyLCBpbnQ4X3QsIGludDhfdCk7aTh2ZWMzIGJpdGZpZWxkRXh0cmFjdChpOHZlYzMsIGludDhfdCwgaW50OF90KTtpOHZlYzQgYml0ZmllbGRFeHRyYWN0KGk4dmVjNCwgaW50OF90LCBpbnQ4X3QpOyB1aW50OF90IGJpdGZpZWxkRXh0cmFjdCggdWludDhfdCwgaW50OF90LCBpbnQ4X3QpO3U4dmVjMiBiaXRmaWVsZEV4dHJhY3QodTh2ZWMyLCBpbnQ4X3QsIGludDhfdCk7dTh2ZWMzIGJpdGZpZWxkRXh0cmFjdCh1OHZlYzMsIGludDhfdCwgaW50OF90KTt1OHZlYzQgYml0ZmllbGRFeHRyYWN0KHU4dmVjNCwgaW50OF90LCBpbnQ4X3QpOyAgaW50OF90IGJpdGZpZWxkSW5zZXJ0KCAgaW50OF90IGJhc2UsICAgaW50OF90LCBpbnQ4X3QsIGludDhfdCk7aTh2ZWMyIGJpdGZpZWxkSW5zZXJ0KGk4dmVjMiBiYXNlLCBpOHZlYzIsIGludDhfdCwgaW50OF90KTtpOHZlYzMgYml0ZmllbGRJbnNlcnQoaTh2ZWMzIGJhc2UsIGk4dmVjMywgaW50OF90LCBpbnQ4X3QpO2k4dmVjNCBiaXRmaWVsZEluc2VydChpOHZlYzQgYmFzZSwgaTh2ZWM0LCBpbnQ4X3QsIGludDhfdCk7IHVpbnQ4X3QgYml0ZmllbGRJbnNlcnQoIHVpbnQ4X3QgYmFzZSwgIHVpbnQ4X3QsIGludDhfdCwgaW50OF90KTt1OHZlYzIgYml0ZmllbGRJbnNlcnQodTh2ZWMyIGJhc2UsIHU4dmVjMiwgaW50OF90LCBpbnQ4X3QpO3U4dmVjMyBiaXRmaWVsZEluc2VydCh1OHZlYzMgYmFzZSwgdTh2ZWMzLCBpbnQ4X3QsIGludDhfdCk7dTh2ZWM0IGJpdGZpZWxkSW5zZXJ0KHU4dmVjNCBiYXNlLCB1OHZlYzQsIGludDhfdCwgaW50OF90KTsgIGludDhfdCBiaXRDb3VudCggIGludDhfdCk7aTh2ZWMyIGJpdENvdW50KGk4dmVjMik7aTh2ZWMzIGJpdENvdW50KGk4dmVjMyk7aTh2ZWM0IGJpdENvdW50KGk4dmVjNCk7ICBpbnQ4X3QgYml0Q291bnQoIHVpbnQ4X3QpO2k4dmVjMiBiaXRDb3VudCh1OHZlYzIpO2k4dmVjMyBiaXRDb3VudCh1OHZlYzMpO2k4dmVjNCBiaXRDb3VudCh1OHZlYzQpOyAgaW50OF90IGZpbmRMU0IoICBpbnQ4X3QpO2k4dmVjMiBmaW5kTFNCKGk4dmVjMik7aTh2ZWMzIGZpbmRMU0IoaTh2ZWMzKTtpOHZlYzQgZmluZExTQihpOHZlYzQpOyAgaW50OF90IGZpbmRMU0IoIHVpbnQ4X3QpO2k4dmVjMiBmaW5kTFNCKHU4dmVjMik7aTh2ZWMzIGZpbmRMU0IodTh2ZWMzKTtpOHZlYzQgZmluZExTQih1OHZlYzQpOyAgaW50OF90IGZpbmRNU0IoICBpbnQ4X3QpO2k4dmVjMiBmaW5kTVNCKGk4dmVjMik7aTh2ZWMzIGZpbmRNU0IoaTh2ZWMzKTtpOHZlYzQgZmluZE1TQihpOHZlYzQpOyAgaW50OF90IGZpbmRNU0IoIHVpbnQ4X3QpO2k4dmVjMiBmaW5kTVNCKHU4dmVjMik7aTh2ZWMzIGZpbmRNU0IodTh2ZWMzKTtpOHZlYzQgZmluZE1TQih1OHZlYzQpO2ludDE2X3QgYWJzKGludDE2X3QpO2kxNnZlYzIgYWJzKGkxNnZlYzIpO2kxNnZlYzMgYWJzKGkxNnZlYzMpO2kxNnZlYzQgYWJzKGkxNnZlYzQpO2ludDE2X3Qgc2lnbihpbnQxNl90KTtpMTZ2ZWMyIHNpZ24oaTE2dmVjMik7aTE2dmVjMyBzaWduKGkxNnZlYzMpO2kxNnZlYzQgc2lnbihpMTZ2ZWM0KTtpbnQxNl90IG1pbihpbnQxNl90IHgsIGludDE2X3QgeSk7aTE2dmVjMiBtaW4oaTE2dmVjMiB4LCBpbnQxNl90IHkpO2kxNnZlYzMgbWluKGkxNnZlYzMgeCwgaW50MTZfdCB5KTtpMTZ2ZWM0IG1pbihpMTZ2ZWM0IHgsIGludDE2X3QgeSk7aTE2dmVjMiBtaW4oaTE2dmVjMiB4LCBpMTZ2ZWMyIHkpO2kxNnZlYzMgbWluKGkxNnZlYzMgeCwgaTE2dmVjMyB5KTtpMTZ2ZWM0IG1pbihpMTZ2ZWM0IHgsIGkxNnZlYzQgeSk7dWludDE2X3QgbWluKHVpbnQxNl90IHgsIHVpbnQxNl90IHkpO3UxNnZlYzIgbWluKHUxNnZlYzIgeCwgdWludDE2X3QgeSk7dTE2dmVjMyBtaW4odTE2dmVjMyB4LCB1aW50MTZfdCB5KTt1MTZ2ZWM0IG1pbih1MTZ2ZWM0IHgsIHVpbnQxNl90IHkpO3UxNnZlYzIgbWluKHUxNnZlYzIgeCwgdTE2dmVjMiB5KTt1MTZ2ZWMzIG1pbih1MTZ2ZWMzIHgsIHUxNnZlYzMgeSk7dTE2dmVjNCBtaW4odTE2dmVjNCB4LCB1MTZ2ZWM0IHkpO2ludDE2X3QgbWF4KGludDE2X3QgeCwgaW50MTZfdCB5KTtpMTZ2ZWMyIG1heChpMTZ2ZWMyIHgsIGludDE2X3QgeSk7aTE2dmVjMyBtYXgoaTE2dmVjMyB4LCBpbnQxNl90IHkpO2kxNnZlYzQgbWF4KGkxNnZlYzQgeCwgaW50MTZfdCB5KTtpMTZ2ZWMyIG1heChpMTZ2ZWMyIHgsIGkxNnZlYzIgeSk7aTE2dmVjMyBtYXgoaTE2dmVjMyB4LCBpMTZ2ZWMzIHkpO2kxNnZlYzQgbWF4KGkxNnZlYzQgeCwgaTE2dmVjNCB5KTt1aW50MTZfdCBtYXgodWludDE2X3QgeCwgdWludDE2X3QgeSk7dTE2dmVjMiBtYXgodTE2dmVjMiB4LCB1aW50MTZfdCB5KTt1MTZ2ZWMzIG1heCh1MTZ2ZWMzIHgsIHVpbnQxNl90IHkpO3UxNnZlYzQgbWF4KHUxNnZlYzQgeCwgdWludDE2X3QgeSk7dTE2dmVjMiBtYXgodTE2dmVjMiB4LCB1MTZ2ZWMyIHkpO3UxNnZlYzMgbWF4KHUxNnZlYzMgeCwgdTE2dmVjMyB5KTt1MTZ2ZWM0IG1heCh1MTZ2ZWM0IHgsIHUxNnZlYzQgeSk7aW50MTZfdCAgICBjbGFtcChpbnQxNl90IHgsIGludDE2X3QgbWluVmFsLCBpbnQxNl90IG1heFZhbCk7aTE2dmVjMiAgY2xhbXAoaTE2dmVjMiAgeCwgaW50MTZfdCBtaW5WYWwsIGludDE2X3QgbWF4VmFsKTtpMTZ2ZWMzICBjbGFtcChpMTZ2ZWMzICB4LCBpbnQxNl90IG1pblZhbCwgaW50MTZfdCBtYXhWYWwpO2kxNnZlYzQgIGNsYW1wKGkxNnZlYzQgIHgsIGludDE2X3QgbWluVmFsLCBpbnQxNl90IG1heFZhbCk7aTE2dmVjMiAgY2xhbXAoaTE2dmVjMiAgeCwgaTE2dmVjMiAgbWluVmFsLCBpMTZ2ZWMyICBtYXhWYWwpO2kxNnZlYzMgIGNsYW1wKGkxNnZlYzMgIHgsIGkxNnZlYzMgIG1pblZhbCwgaTE2dmVjMyAgbWF4VmFsKTtpMTZ2ZWM0ICBjbGFtcChpMTZ2ZWM0ICB4LCBpMTZ2ZWM0ICBtaW5WYWwsIGkxNnZlYzQgIG1heFZhbCk7dWludDE2X3QgICBjbGFtcCh1aW50MTZfdCB4LCB1aW50MTZfdCBtaW5WYWwsIHVpbnQxNl90IG1heFZhbCk7dTE2dmVjMiAgY2xhbXAodTE2dmVjMiAgeCwgdWludDE2X3QgbWluVmFsLCB1aW50MTZfdCBtYXhWYWwpO3UxNnZlYzMgIGNsYW1wKHUxNnZlYzMgIHgsIHVpbnQxNl90IG1pblZhbCwgdWludDE2X3QgbWF4VmFsKTt1MTZ2ZWM0ICBjbGFtcCh1MTZ2ZWM0ICB4LCB1aW50MTZfdCBtaW5WYWwsIHVpbnQxNl90IG1heFZhbCk7dTE2dmVjMiAgY2xhbXAodTE2dmVjMiAgeCwgdTE2dmVjMiAgbWluVmFsLCB1MTZ2ZWMyICBtYXhWYWwpO3UxNnZlYzMgIGNsYW1wKHUxNnZlYzMgIHgsIHUxNnZlYzMgIG1pblZhbCwgdTE2dmVjMyAgbWF4VmFsKTt1MTZ2ZWM0ICBjbGFtcCh1MTZ2ZWM0ICB4LCB1MTZ2ZWM0ICBtaW5WYWwsIHUxNnZlYzQgIG1heFZhbCk7aW50MTZfdCAgbWl4KGludDE2X3QsICBpbnQxNl90LCAgYm9vbCk7aTE2dmVjMiAgbWl4KGkxNnZlYzIsICBpMTZ2ZWMyLCAgYnZlYzIpO2kxNnZlYzMgIG1peChpMTZ2ZWMzLCAgaTE2dmVjMywgIGJ2ZWMzKTtpMTZ2ZWM0ICBtaXgoaTE2dmVjNCwgIGkxNnZlYzQsICBidmVjNCk7dWludDE2X3QgbWl4KHVpbnQxNl90LCB1aW50MTZfdCwgYm9vbCk7dTE2dmVjMiAgbWl4KHUxNnZlYzIsICB1MTZ2ZWMyLCAgYnZlYzIpO3UxNnZlYzMgIG1peCh1MTZ2ZWMzLCAgdTE2dmVjMywgIGJ2ZWMzKTt1MTZ2ZWM0ICBtaXgodTE2dmVjNCwgIHUxNnZlYzQsICBidmVjNCk7ZmxvYXQxNl90IGZyZXhwKGZsb2F0MTZfdCwgb3V0IGludDE2X3QpO2YxNnZlYzIgICBmcmV4cChmMTZ2ZWMyLCAgIG91dCBpMTZ2ZWMyKTtmMTZ2ZWMzICAgZnJleHAoZjE2dmVjMywgICBvdXQgaTE2dmVjMyk7ZjE2dmVjNCAgIGZyZXhwKGYxNnZlYzQsICAgb3V0IGkxNnZlYzQpO2Zsb2F0MTZfdCBsZGV4cChmbG9hdDE2X3QsIGludDE2X3QpO2YxNnZlYzIgICBsZGV4cChmMTZ2ZWMyLCAgIGkxNnZlYzIpO2YxNnZlYzMgICBsZGV4cChmMTZ2ZWMzLCAgIGkxNnZlYzMpO2YxNnZlYzQgICBsZGV4cChmMTZ2ZWM0LCAgIGkxNnZlYzQpO2ludDE2X3QgaGFsZkJpdHNUb0ludDE2KGZsb2F0MTZfdCk7aTE2dmVjMiBoYWxmQml0c1RvSW50MTYoZjE2dmVjMik7aTE2dmVjMyBoYWxoQml0c1RvSW50MTYoZjE2dmVjMyk7aTE2dmVjNCBoYWxmQml0c1RvSW50MTYoZjE2dmVjNCk7dWludDE2X3QgaGFsZkJpdHNUb1VpbnQxNihmbG9hdDE2X3QpO3UxNnZlYzIgIGhhbGZCaXRzVG9VaW50MTYoZjE2dmVjMik7dTE2dmVjMyAgaGFsZkJpdHNUb1VpbnQxNihmMTZ2ZWMzKTt1MTZ2ZWM0ICBoYWxmQml0c1RvVWludDE2KGYxNnZlYzQpO2ludDE2X3QgZmxvYXQxNkJpdHNUb0ludDE2KGZsb2F0MTZfdCk7aTE2dmVjMiBmbG9hdDE2Qml0c1RvSW50MTYoZjE2dmVjMik7aTE2dmVjMyBmbG9hdDE2Qml0c1RvSW50MTYoZjE2dmVjMyk7aTE2dmVjNCBmbG9hdDE2Qml0c1RvSW50MTYoZjE2dmVjNCk7dWludDE2X3QgZmxvYXQxNkJpdHNUb1VpbnQxNihmbG9hdDE2X3QpO3UxNnZlYzIgIGZsb2F0MTZCaXRzVG9VaW50MTYoZjE2dmVjMik7dTE2dmVjMyAgZmxvYXQxNkJpdHNUb1VpbnQxNihmMTZ2ZWMzKTt1MTZ2ZWM0ICBmbG9hdDE2Qml0c1RvVWludDE2KGYxNnZlYzQpO2Zsb2F0MTZfdCBpbnQxNkJpdHNUb0Zsb2F0MTYoaW50MTZfdCk7ZjE2dmVjMiAgIGludDE2Qml0c1RvRmxvYXQxNihpMTZ2ZWMyKTtmMTZ2ZWMzICAgaW50MTZCaXRzVG9GbG9hdDE2KGkxNnZlYzMpO2YxNnZlYzQgICBpbnQxNkJpdHNUb0Zsb2F0MTYoaTE2dmVjNCk7ZmxvYXQxNl90IHVpbnQxNkJpdHNUb0Zsb2F0MTYodWludDE2X3QpO2YxNnZlYzIgICB1aW50MTZCaXRzVG9GbG9hdDE2KHUxNnZlYzIpO2YxNnZlYzMgICB1aW50MTZCaXRzVG9GbG9hdDE2KHUxNnZlYzMpO2YxNnZlYzQgICB1aW50MTZCaXRzVG9GbG9hdDE2KHUxNnZlYzQpO2Zsb2F0MTZfdCBpbnQxNkJpdHNUb0hhbGYoaW50MTZfdCk7ZjE2dmVjMiAgIGludDE2Qml0c1RvSGFsZihpMTZ2ZWMyKTtmMTZ2ZWMzICAgaW50MTZCaXRzVG9IYWxmKGkxNnZlYzMpO2YxNnZlYzQgICBpbnQxNkJpdHNUb0hhbGYoaTE2dmVjNCk7ZmxvYXQxNl90IHVpbnQxNkJpdHNUb0hhbGYodWludDE2X3QpO2YxNnZlYzIgICB1aW50MTZCaXRzVG9IYWxmKHUxNnZlYzIpO2YxNnZlYzMgICB1aW50MTZCaXRzVG9IYWxmKHUxNnZlYzMpO2YxNnZlYzQgICB1aW50MTZCaXRzVG9IYWxmKHUxNnZlYzQpO2ludCAgICAgIHBhY2tJbnQyeDE2KGkxNnZlYzIpO3VpbnQgICAgIHBhY2tVaW50MngxNih1MTZ2ZWMyKTtpbnQ2NF90ICBwYWNrSW50NHgxNihpMTZ2ZWM0KTt1aW50NjRfdCBwYWNrVWludDR4MTYodTE2dmVjNCk7aTE2dmVjMiAgdW5wYWNrSW50MngxNihpbnQpO3UxNnZlYzIgIHVucGFja1VpbnQyeDE2KHVpbnQpO2kxNnZlYzQgIHVucGFja0ludDR4MTYoaW50NjRfdCk7dTE2dmVjNCAgdW5wYWNrVWludDR4MTYodWludDY0X3QpO2J2ZWMyIGxlc3NUaGFuKGkxNnZlYzIsIGkxNnZlYzIpO2J2ZWMzIGxlc3NUaGFuKGkxNnZlYzMsIGkxNnZlYzMpO2J2ZWM0IGxlc3NUaGFuKGkxNnZlYzQsIGkxNnZlYzQpO2J2ZWMyIGxlc3NUaGFuKHUxNnZlYzIsIHUxNnZlYzIpO2J2ZWMzIGxlc3NUaGFuKHUxNnZlYzMsIHUxNnZlYzMpO2J2ZWM0IGxlc3NUaGFuKHUxNnZlYzQsIHUxNnZlYzQpO2J2ZWMyIGxlc3NUaGFuRXF1YWwoaTE2dmVjMiwgaTE2dmVjMik7YnZlYzMgbGVzc1RoYW5FcXVhbChpMTZ2ZWMzLCBpMTZ2ZWMzKTtidmVjNCBsZXNzVGhhbkVxdWFsKGkxNnZlYzQsIGkxNnZlYzQpO2J2ZWMyIGxlc3NUaGFuRXF1YWwodTE2dmVjMiwgdTE2dmVjMik7YnZlYzMgbGVzc1RoYW5FcXVhbCh1MTZ2ZWMzLCB1MTZ2ZWMzKTtidmVjNCBsZXNzVGhhbkVxdWFsKHUxNnZlYzQsIHUxNnZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuKGkxNnZlYzIsIGkxNnZlYzIpO2J2ZWMzIGdyZWF0ZXJUaGFuKGkxNnZlYzMsIGkxNnZlYzMpO2J2ZWM0IGdyZWF0ZXJUaGFuKGkxNnZlYzQsIGkxNnZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuKHUxNnZlYzIsIHUxNnZlYzIpO2J2ZWMzIGdyZWF0ZXJUaGFuKHUxNnZlYzMsIHUxNnZlYzMpO2J2ZWM0IGdyZWF0ZXJUaGFuKHUxNnZlYzQsIHUxNnZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuRXF1YWwoaTE2dmVjMiwgaTE2dmVjMik7YnZlYzMgZ3JlYXRlclRoYW5FcXVhbChpMTZ2ZWMzLCBpMTZ2ZWMzKTtidmVjNCBncmVhdGVyVGhhbkVxdWFsKGkxNnZlYzQsIGkxNnZlYzQpO2J2ZWMyIGdyZWF0ZXJUaGFuRXF1YWwodTE2dmVjMiwgdTE2dmVjMik7YnZlYzMgZ3JlYXRlclRoYW5FcXVhbCh1MTZ2ZWMzLCB1MTZ2ZWMzKTtidmVjNCBncmVhdGVyVGhhbkVxdWFsKHUxNnZlYzQsIHUxNnZlYzQpO2J2ZWMyIGVxdWFsKGkxNnZlYzIsIGkxNnZlYzIpO2J2ZWMzIGVxdWFsKGkxNnZlYzMsIGkxNnZlYzMpO2J2ZWM0IGVxdWFsKGkxNnZlYzQsIGkxNnZlYzQpO2J2ZWMyIGVxdWFsKHUxNnZlYzIsIHUxNnZlYzIpO2J2ZWMzIGVxdWFsKHUxNnZlYzMsIHUxNnZlYzMpO2J2ZWM0IGVxdWFsKHUxNnZlYzQsIHUxNnZlYzQpO2J2ZWMyIG5vdEVxdWFsKGkxNnZlYzIsIGkxNnZlYzIpO2J2ZWMzIG5vdEVxdWFsKGkxNnZlYzMsIGkxNnZlYzMpO2J2ZWM0IG5vdEVxdWFsKGkxNnZlYzQsIGkxNnZlYzQpO2J2ZWMyIG5vdEVxdWFsKHUxNnZlYzIsIHUxNnZlYzIpO2J2ZWMzIG5vdEVxdWFsKHUxNnZlYzMsIHUxNnZlYzMpO2J2ZWM0IG5vdEVxdWFsKHUxNnZlYzQsIHUxNnZlYzQpOyAgaW50MTZfdCBiaXRmaWVsZEV4dHJhY3QoICBpbnQxNl90LCBpbnQxNl90LCBpbnQxNl90KTtpMTZ2ZWMyIGJpdGZpZWxkRXh0cmFjdChpMTZ2ZWMyLCBpbnQxNl90LCBpbnQxNl90KTtpMTZ2ZWMzIGJpdGZpZWxkRXh0cmFjdChpMTZ2ZWMzLCBpbnQxNl90LCBpbnQxNl90KTtpMTZ2ZWM0IGJpdGZpZWxkRXh0cmFjdChpMTZ2ZWM0LCBpbnQxNl90LCBpbnQxNl90KTsgdWludDE2X3QgYml0ZmllbGRFeHRyYWN0KCB1aW50MTZfdCwgaW50MTZfdCwgaW50MTZfdCk7dTE2dmVjMiBiaXRmaWVsZEV4dHJhY3QodTE2dmVjMiwgaW50MTZfdCwgaW50MTZfdCk7dTE2dmVjMyBiaXRmaWVsZEV4dHJhY3QodTE2dmVjMywgaW50MTZfdCwgaW50MTZfdCk7dTE2dmVjNCBiaXRmaWVsZEV4dHJhY3QodTE2dmVjNCwgaW50MTZfdCwgaW50MTZfdCk7ICBpbnQxNl90IGJpdGZpZWxkSW5zZXJ0KCAgaW50MTZfdCBiYXNlLCAgIGludDE2X3QsIGludDE2X3QsIGludDE2X3QpO2kxNnZlYzIgYml0ZmllbGRJbnNlcnQoaTE2dmVjMiBiYXNlLCBpMTZ2ZWMyLCBpbnQxNl90LCBpbnQxNl90KTtpMTZ2ZWMzIGJpdGZpZWxkSW5zZXJ0KGkxNnZlYzMgYmFzZSwgaTE2dmVjMywgaW50MTZfdCwgaW50MTZfdCk7aTE2dmVjNCBiaXRmaWVsZEluc2VydChpMTZ2ZWM0IGJhc2UsIGkxNnZlYzQsIGludDE2X3QsIGludDE2X3QpOyB1aW50MTZfdCBiaXRmaWVsZEluc2VydCggdWludDE2X3QgYmFzZSwgIHVpbnQxNl90LCBpbnQxNl90LCBpbnQxNl90KTt1MTZ2ZWMyIGJpdGZpZWxkSW5zZXJ0KHUxNnZlYzIgYmFzZSwgdTE2dmVjMiwgaW50MTZfdCwgaW50MTZfdCk7dTE2dmVjMyBiaXRmaWVsZEluc2VydCh1MTZ2ZWMzIGJhc2UsIHUxNnZlYzMsIGludDE2X3QsIGludDE2X3QpO3UxNnZlYzQgYml0ZmllbGRJbnNlcnQodTE2dmVjNCBiYXNlLCB1MTZ2ZWM0LCBpbnQxNl90LCBpbnQxNl90KTsgIGludDE2X3QgYml0Q291bnQoICBpbnQxNl90KTtpMTZ2ZWMyIGJpdENvdW50KGkxNnZlYzIpO2kxNnZlYzMgYml0Q291bnQoaTE2dmVjMyk7aTE2dmVjNCBiaXRDb3VudChpMTZ2ZWM0KTsgIGludDE2X3QgYml0Q291bnQoIHVpbnQxNl90KTtpMTZ2ZWMyIGJpdENvdW50KHUxNnZlYzIpO2kxNnZlYzMgYml0Q291bnQodTE2dmVjMyk7aTE2dmVjNCBiaXRDb3VudCh1MTZ2ZWM0KTsgIGludDE2X3QgZmluZExTQiggIGludDE2X3QpO2kxNnZlYzIgZmluZExTQihpMTZ2ZWMyKTtpMTZ2ZWMzIGZpbmRMU0IoaTE2dmVjMyk7aTE2dmVjNCBmaW5kTFNCKGkxNnZlYzQpOyAgaW50MTZfdCBmaW5kTFNCKCB1aW50MTZfdCk7aTE2dmVjMiBmaW5kTFNCKHUxNnZlYzIpO2kxNnZlYzMgZmluZExTQih1MTZ2ZWMzKTtpMTZ2ZWM0IGZpbmRMU0IodTE2dmVjNCk7ICBpbnQxNl90IGZpbmRNU0IoICBpbnQxNl90KTtpMTZ2ZWMyIGZpbmRNU0IoaTE2dmVjMik7aTE2dmVjMyBmaW5kTVNCKGkxNnZlYzMpO2kxNnZlYzQgZmluZE1TQihpMTZ2ZWM0KTsgIGludDE2X3QgZmluZE1TQiggdWludDE2X3QpO2kxNnZlYzIgZmluZE1TQih1MTZ2ZWMyKTtpMTZ2ZWMzIGZpbmRNU0IodTE2dmVjMyk7aTE2dmVjNCBmaW5kTVNCKHUxNnZlYzQpO2ludDE2X3QgIHBhY2sxNihpOHZlYzIpO3VpbnQxNl90IHBhY2sxNih1OHZlYzIpO2ludDMyX3QgIHBhY2szMihpOHZlYzQpO3VpbnQzMl90IHBhY2szMih1OHZlYzQpO2ludDMyX3QgIHBhY2szMihpMTZ2ZWMyKTt1aW50MzJfdCBwYWNrMzIodTE2dmVjMik7aW50NjRfdCAgcGFjazY0KGkxNnZlYzQpO3VpbnQ2NF90IHBhY2s2NCh1MTZ2ZWM0KTtpbnQ2NF90ICBwYWNrNjQoaTMydmVjMik7dWludDY0X3QgcGFjazY0KHUzMnZlYzIpO2k4dmVjMiAgIHVucGFjazgoaW50MTZfdCk7dTh2ZWMyICAgdW5wYWNrOCh1aW50MTZfdCk7aTh2ZWM0ICAgdW5wYWNrOChpbnQzMl90KTt1OHZlYzQgICB1bnBhY2s4KHVpbnQzMl90KTtpMTZ2ZWMyICB1bnBhY2sxNihpbnQzMl90KTt1MTZ2ZWMyICB1bnBhY2sxNih1aW50MzJfdCk7aTE2dmVjNCAgdW5wYWNrMTYoaW50NjRfdCk7dTE2dmVjNCAgdW5wYWNrMTYodWludDY0X3QpO2kzMnZlYzIgIHVucGFjazMyKGludDY0X3QpO3UzMnZlYzIgIHVucGFjazMyKHVpbnQ2NF90KTtmbG9hdDY0X3QgcmFkaWFucyhmbG9hdDY0X3QpO2Y2NHZlYzIgICByYWRpYW5zKGY2NHZlYzIpO2Y2NHZlYzMgICByYWRpYW5zKGY2NHZlYzMpO2Y2NHZlYzQgICByYWRpYW5zKGY2NHZlYzQpO2Zsb2F0NjRfdCBkZWdyZWVzKGZsb2F0NjRfdCk7ZjY0dmVjMiAgIGRlZ3JlZXMoZjY0dmVjMik7ZjY0dmVjMyAgIGRlZ3JlZXMoZjY0dmVjMyk7ZjY0dmVjNCAgIGRlZ3JlZXMoZjY0dmVjNCk7ZmxvYXQ2NF90IHNpbihmbG9hdDY0X3QpO2Y2NHZlYzIgICBzaW4oZjY0dmVjMik7ZjY0dmVjMyAgIHNpbihmNjR2ZWMzKTtmNjR2ZWM0ICAgc2luKGY2NHZlYzQpO2Zsb2F0NjRfdCBjb3MoZmxvYXQ2NF90KTtmNjR2ZWMyICAgY29zKGY2NHZlYzIpO2Y2NHZlYzMgICBjb3MoZjY0dmVjMyk7ZjY0dmVjNCAgIGNvcyhmNjR2ZWM0KTtmbG9hdDY0X3QgdGFuKGZsb2F0NjRfdCk7ZjY0dmVjMiAgIHRhbihmNjR2ZWMyKTtmNjR2ZWMzICAgdGFuKGY2NHZlYzMpO2Y2NHZlYzQgICB0YW4oZjY0dmVjNCk7ZmxvYXQ2NF90IGFzaW4oZmxvYXQ2NF90KTtmNjR2ZWMyICAgYXNpbihmNjR2ZWMyKTtmNjR2ZWMzICAgYXNpbihmNjR2ZWMzKTtmNjR2ZWM0ICAgYXNpbihmNjR2ZWM0KTtmbG9hdDY0X3QgYWNvcyhmbG9hdDY0X3QpO2Y2NHZlYzIgICBhY29zKGY2NHZlYzIpO2Y2NHZlYzMgICBhY29zKGY2NHZlYzMpO2Y2NHZlYzQgICBhY29zKGY2NHZlYzQpO2Zsb2F0NjRfdCBhdGFuKGZsb2F0NjRfdCwgZmxvYXQ2NF90KTtmNjR2ZWMyICAgYXRhbihmNjR2ZWMyLCAgIGY2NHZlYzIpO2Y2NHZlYzMgICBhdGFuKGY2NHZlYzMsICAgZjY0dmVjMyk7ZjY0dmVjNCAgIGF0YW4oZjY0dmVjNCwgICBmNjR2ZWM0KTtmbG9hdDY0X3QgYXRhbihmbG9hdDY0X3QpO2Y2NHZlYzIgICBhdGFuKGY2NHZlYzIpO2Y2NHZlYzMgICBhdGFuKGY2NHZlYzMpO2Y2NHZlYzQgICBhdGFuKGY2NHZlYzQpO2Zsb2F0NjRfdCBzaW5oKGZsb2F0NjRfdCk7ZjY0dmVjMiAgIHNpbmgoZjY0dmVjMik7ZjY0dmVjMyAgIHNpbmgoZjY0dmVjMyk7ZjY0dmVjNCAgIHNpbmgoZjY0dmVjNCk7ZmxvYXQ2NF90IGNvc2goZmxvYXQ2NF90KTtmNjR2ZWMyICAgY29zaChmNjR2ZWMyKTtmNjR2ZWMzICAgY29zaChmNjR2ZWMzKTtmNjR2ZWM0ICAgY29zaChmNjR2ZWM0KTtmbG9hdDY0X3QgdGFuaChmbG9hdDY0X3QpO2Y2NHZlYzIgICB0YW5oKGY2NHZlYzIpO2Y2NHZlYzMgICB0YW5oKGY2NHZlYzMpO2Y2NHZlYzQgICB0YW5oKGY2NHZlYzQpO2Zsb2F0NjRfdCBhc2luaChmbG9hdDY0X3QpO2Y2NHZlYzIgICBhc2luaChmNjR2ZWMyKTtmNjR2ZWMzICAgYXNpbmgoZjY0dmVjMyk7ZjY0dmVjNCAgIGFzaW5oKGY2NHZlYzQpO2Zsb2F0NjRfdCBhY29zaChmbG9hdDY0X3QpO2Y2NHZlYzIgICBhY29zaChmNjR2ZWMyKTtmNjR2ZWMzICAgYWNvc2goZjY0dmVjMyk7ZjY0dmVjNCAgIGFjb3NoKGY2NHZlYzQpO2Zsb2F0NjRfdCBhdGFuaChmbG9hdDY0X3QpO2Y2NHZlYzIgICBhdGFuaChmNjR2ZWMyKTtmNjR2ZWMzICAgYXRhbmgoZjY0dmVjMyk7ZjY0dmVjNCAgIGF0YW5oKGY2NHZlYzQpO2Zsb2F0NjRfdCBwb3coZmxvYXQ2NF90LCBmbG9hdDY0X3QpO2Y2NHZlYzIgICBwb3coZjY0dmVjMiwgICBmNjR2ZWMyKTtmNjR2ZWMzICAgcG93KGY2NHZlYzMsICAgZjY0dmVjMyk7ZjY0dmVjNCAgIHBvdyhmNjR2ZWM0LCAgIGY2NHZlYzQpO2Zsb2F0NjRfdCBleHAoZmxvYXQ2NF90KTtmNjR2ZWMyICAgZXhwKGY2NHZlYzIpO2Y2NHZlYzMgICBleHAoZjY0dmVjMyk7ZjY0dmVjNCAgIGV4cChmNjR2ZWM0KTtmbG9hdDY0X3QgbG9nKGZsb2F0NjRfdCk7ZjY0dmVjMiAgIGxvZyhmNjR2ZWMyKTtmNjR2ZWMzICAgbG9nKGY2NHZlYzMpO2Y2NHZlYzQgICBsb2coZjY0dmVjNCk7ZmxvYXQ2NF90IGV4cDIoZmxvYXQ2NF90KTtmNjR2ZWMyICAgZXhwMihmNjR2ZWMyKTtmNjR2ZWMzICAgZXhwMihmNjR2ZWMzKTtmNjR2ZWM0ICAgZXhwMihmNjR2ZWM0KTtmbG9hdDY0X3QgbG9nMihmbG9hdDY0X3QpO2Y2NHZlYzIgICBsb2cyKGY2NHZlYzIpO2Y2NHZlYzMgICBsb2cyKGY2NHZlYzMpO2Y2NHZlYzQgICBsb2cyKGY2NHZlYzQpOwoAZmxvYXQ2NF90IGludGVycG9sYXRlQXRDZW50cm9pZChmbG9hdDY0X3QpO2Y2NHZlYzIgICBpbnRlcnBvbGF0ZUF0Q2VudHJvaWQoZjY0dmVjMik7ZjY0dmVjMyAgIGludGVycG9sYXRlQXRDZW50cm9pZChmNjR2ZWMzKTtmNjR2ZWM0ICAgaW50ZXJwb2xhdGVBdENlbnRyb2lkKGY2NHZlYzQpO2Zsb2F0NjRfdCBpbnRlcnBvbGF0ZUF0U2FtcGxlKGZsb2F0NjRfdCwgaW50KTtmNjR2ZWMyICAgaW50ZXJwb2xhdGVBdFNhbXBsZShmNjR2ZWMyLCAgIGludCk7ZjY0dmVjMyAgIGludGVycG9sYXRlQXRTYW1wbGUoZjY0dmVjMywgICBpbnQpO2Y2NHZlYzQgICBpbnRlcnBvbGF0ZUF0U2FtcGxlKGY2NHZlYzQsICAgaW50KTtmbG9hdDY0X3QgaW50ZXJwb2xhdGVBdE9mZnNldChmbG9hdDY0X3QsIGY2NHZlYzIpO2Y2NHZlYzIgICBpbnRlcnBvbGF0ZUF0T2Zmc2V0KGY2NHZlYzIsICAgZjY0dmVjMik7ZjY0dmVjMyAgIGludGVycG9sYXRlQXRPZmZzZXQoZjY0dmVjMywgICBmNjR2ZWMyKTtmNjR2ZWM0ICAgaW50ZXJwb2xhdGVBdE9mZnNldChmNjR2ZWM0LCAgIGY2NHZlYzIpOwoAdmVjNCBmdHJhbnNmb3JtKCk7AHZlYzQgdGV4dHVyZTJETG9kKHNhbXBsZXIyRCwgdmVjMiwgZmxvYXQpO3ZlYzQgdGV4dHVyZTJEUHJvakxvZChzYW1wbGVyMkQsIHZlYzMsIGZsb2F0KTt2ZWM0IHRleHR1cmUyRFByb2pMb2Qoc2FtcGxlcjJELCB2ZWM0LCBmbG9hdCk7dmVjNCB0ZXh0dXJlM0RMb2Qoc2FtcGxlcjNELCB2ZWMzLCBmbG9hdCk7dmVjNCB0ZXh0dXJlM0RQcm9qTG9kKHNhbXBsZXIzRCwgdmVjNCwgZmxvYXQpO3ZlYzQgdGV4dHVyZUN1YmVMb2Qoc2FtcGxlckN1YmUsIHZlYzMsIGZsb2F0KTsKAHZlYzQgdGV4dHVyZTFETG9kKHNhbXBsZXIxRCwgZmxvYXQsIGZsb2F0KTt2ZWM0IHRleHR1cmUxRFByb2pMb2Qoc2FtcGxlcjFELCB2ZWMyLCBmbG9hdCk7dmVjNCB0ZXh0dXJlMURQcm9qTG9kKHNhbXBsZXIxRCwgdmVjNCwgZmxvYXQpO3ZlYzQgc2hhZG93MURMb2Qoc2FtcGxlcjFEU2hhZG93LCB2ZWMzLCBmbG9hdCk7dmVjNCBzaGFkb3cyRExvZChzYW1wbGVyMkRTaGFkb3csIHZlYzMsIGZsb2F0KTt2ZWM0IHNoYWRvdzFEUHJvakxvZChzYW1wbGVyMURTaGFkb3csIHZlYzQsIGZsb2F0KTt2ZWM0IHNoYWRvdzJEUHJvakxvZChzYW1wbGVyMkRTaGFkb3csIHZlYzQsIGZsb2F0KTt2ZWM0IHRleHR1cmUxREdyYWRBUkIoc2FtcGxlcjFELCBmbG9hdCwgZmxvYXQsIGZsb2F0KTt2ZWM0IHRleHR1cmUxRFByb2pHcmFkQVJCKHNhbXBsZXIxRCwgdmVjMiwgZmxvYXQsIGZsb2F0KTt2ZWM0IHRleHR1cmUxRFByb2pHcmFkQVJCKHNhbXBsZXIxRCwgdmVjNCwgZmxvYXQsIGZsb2F0KTt2ZWM0IHRleHR1cmUyREdyYWRBUkIoc2FtcGxlcjJELCB2ZWMyLCB2ZWMyLCB2ZWMyKTt2ZWM0IHRleHR1cmUyRFByb2pHcmFkQVJCKHNhbXBsZXIyRCwgdmVjMywgdmVjMiwgdmVjMik7dmVjNCB0ZXh0dXJlMkRQcm9qR3JhZEFSQihzYW1wbGVyMkQsIHZlYzQsIHZlYzIsIHZlYzIpO3ZlYzQgdGV4dHVyZTNER3JhZEFSQihzYW1wbGVyM0QsIHZlYzMsIHZlYzMsIHZlYzMpO3ZlYzQgdGV4dHVyZTNEUHJvakdyYWRBUkIoc2FtcGxlcjNELCB2ZWM0LCB2ZWMzLCB2ZWMzKTt2ZWM0IHRleHR1cmVDdWJlR3JhZEFSQihzYW1wbGVyQ3ViZSwgdmVjMywgdmVjMywgdmVjMyk7dmVjNCBzaGFkb3cxREdyYWRBUkIoc2FtcGxlcjFEU2hhZG93LCB2ZWMzLCBmbG9hdCwgZmxvYXQpO3ZlYzQgc2hhZG93MURQcm9qR3JhZEFSQiggc2FtcGxlcjFEU2hhZG93LCB2ZWM0LCBmbG9hdCwgZmxvYXQpO3ZlYzQgc2hhZG93MkRHcmFkQVJCKHNhbXBsZXIyRFNoYWRvdywgdmVjMywgdmVjMiwgdmVjMik7dmVjNCBzaGFkb3cyRFByb2pHcmFkQVJCKCBzYW1wbGVyMkRTaGFkb3csIHZlYzQsIHZlYzIsIHZlYzIpO3ZlYzQgdGV4dHVyZTJEUmVjdEdyYWRBUkIoc2FtcGxlcjJEUmVjdCwgdmVjMiwgdmVjMiwgdmVjMik7dmVjNCB0ZXh0dXJlMkRSZWN0UHJvakdyYWRBUkIoIHNhbXBsZXIyRFJlY3QsIHZlYzMsIHZlYzIsIHZlYzIpO3ZlYzQgdGV4dHVyZTJEUmVjdFByb2pHcmFkQVJCKCBzYW1wbGVyMkRSZWN0LCB2ZWM0LCB2ZWMyLCB2ZWMyKTt2ZWM0IHNoYWRvdzJEUmVjdEdyYWRBUkIoIHNhbXBsZXIyRFJlY3RTaGFkb3csIHZlYzMsIHZlYzIsIHZlYzIpO3ZlYzQgc2hhZG93MkRSZWN0UHJvakdyYWRBUkIoc2FtcGxlcjJEUmVjdFNoYWRvdywgdmVjNCwgdmVjMiwgdmVjMik7CgB2b2lkIEVtaXRTdHJlYW1WZXJ0ZXgoaW50KTt2b2lkIEVuZFN0cmVhbVByaW1pdGl2ZShpbnQpOwB2b2lkIEVtaXRWZXJ0ZXgoKTt2b2lkIEVuZFByaW1pdGl2ZSgpOwoAdm9pZCBiYXJyaWVyKCk7AHZvaWQgbWVtb3J5QmFycmllcigpOwB2b2lkIG1lbW9yeUJhcnJpZXJCdWZmZXIoKTsAdm9pZCBtZW1vcnlCYXJyaWVyU2hhcmVkKCk7dm9pZCBncm91cE1lbW9yeUJhcnJpZXIoKTsAdm9pZCBtZW1vcnlCYXJyaWVyQXRvbWljQ291bnRlcigpO3ZvaWQgbWVtb3J5QmFycmllckltYWdlKCk7AHZvaWQgY29udHJvbEJhcnJpZXIoaW50LCBpbnQsIGludCwgaW50KTsKdm9pZCBtZW1vcnlCYXJyaWVyKGludCwgaW50LCBpbnQpOwoAdm9pZCBjb29wTWF0TG9hZE5WKG91dCBmY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGZsb2F0MTZfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgZmNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBmbG9hdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgZmNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1aW50OF90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCBmY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnQxNl90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCBmY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IGZjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludDY0X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IGZjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdXZlYzJbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IGZjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdXZlYzRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGZjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgZmxvYXQxNl90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihmY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGZsb2F0W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihmY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGZsb2F0NjRfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYoZmNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1aW50OF90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihmY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnQxNl90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihmY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGZjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludDY0X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGZjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdXZlYzJbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGZjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdXZlYzRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwpmY29vcG1hdE5WIGNvb3BNYXRNdWxBZGROVihmY29vcG1hdE5WIEEsIGZjb29wbWF0TlYgQiwgZmNvb3BtYXROViBDKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCBpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGludDhfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgaWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpbnQxNl90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCBpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGludFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgaWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpbnQ2NF90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCBpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGl2ZWMyW10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCBpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGl2ZWM0W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCBpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnQ4X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IGljb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludDE2X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IGljb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgaWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1aW50NjRfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgaWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1dmVjMltdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgaWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1dmVjNFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgdWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpbnQ4X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IHVjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgaW50MTZfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgdWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpbnRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IHVjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgaW50NjRfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgdWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpdmVjMltdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgdWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpdmVjNFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdExvYWROVihvdXQgdWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1aW50OF90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCB1Y29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnQxNl90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0TG9hZE5WKG91dCB1Y29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IHVjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludDY0X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IHVjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdXZlYzJbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRMb2FkTlYob3V0IHVjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdXZlYzRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGljb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgaW50OF90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGludDE2X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGljb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgaW50W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGludDY0X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGljb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgaXZlYzJbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGljb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgaXZlYzRbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKGljb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludDhfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYoaWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1aW50MTZfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYoaWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1aW50W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnQ2NF90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHV2ZWMyW10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVihpY29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHV2ZWM0W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVih1Y29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGludDhfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYodWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpbnQxNl90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVih1Y29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGludFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYodWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCBpbnQ2NF90W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVih1Y29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGl2ZWMyW10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVih1Y29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IGl2ZWM0W10gYnVmLCB1aW50IGVsZW1lbnQsIHVpbnQgc3RyaWRlLCBib29sIGNvbE1ham9yKTsKdm9pZCBjb29wTWF0U3RvcmVOVih1Y29vcG1hdE5WIG0sIHZvbGF0aWxlIGNvaGVyZW50IHVpbnQ4X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKHVjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludDE2X3RbXSBidWYsIHVpbnQgZWxlbWVudCwgdWludCBzdHJpZGUsIGJvb2wgY29sTWFqb3IpOwp2b2lkIGNvb3BNYXRTdG9yZU5WKHVjb29wbWF0TlYgbSwgdm9sYXRpbGUgY29oZXJlbnQgdWludFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYodWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1aW50NjRfdFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYodWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1dmVjMltdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7CnZvaWQgY29vcE1hdFN0b3JlTlYodWNvb3BtYXROViBtLCB2b2xhdGlsZSBjb2hlcmVudCB1dmVjNFtdIGJ1ZiwgdWludCBlbGVtZW50LCB1aW50IHN0cmlkZSwgYm9vbCBjb2xNYWpvcik7Cmljb29wbWF0TlYgY29vcE1hdE11bEFkZE5WKGljb29wbWF0TlYgQSwgaWNvb3BtYXROViBCLCBpY29vcG1hdE5WIEMpOwp1Y29vcG1hdE5WIGNvb3BNYXRNdWxBZGROVih1Y29vcG1hdE5WIEEsIHVjb29wbWF0TlYgQiwgdWNvb3BtYXROViBDKTsKAHZlYzQgdGV4dHVyZTJEKHNhbXBsZXIyRCwgdmVjMiwgZmxvYXQpO3ZlYzQgdGV4dHVyZTJEUHJvaihzYW1wbGVyMkQsIHZlYzMsIGZsb2F0KTt2ZWM0IHRleHR1cmUyRFByb2ooc2FtcGxlcjJELCB2ZWM0LCBmbG9hdCk7dmVjNCB0ZXh0dXJlM0Qoc2FtcGxlcjNELCB2ZWMzLCBmbG9hdCk7dmVjNCB0ZXh0dXJlM0RQcm9qKHNhbXBsZXIzRCwgdmVjNCwgZmxvYXQpO3ZlYzQgdGV4dHVyZUN1YmUoc2FtcGxlckN1YmUsIHZlYzMsIGZsb2F0KTsKAHZlYzQgdGV4dHVyZTFEKHNhbXBsZXIxRCwgZmxvYXQsIGZsb2F0KTt2ZWM0IHRleHR1cmUxRFByb2ooc2FtcGxlcjFELCB2ZWMyLCBmbG9hdCk7dmVjNCB0ZXh0dXJlMURQcm9qKHNhbXBsZXIxRCwgdmVjNCwgZmxvYXQpO3ZlYzQgc2hhZG93MUQoc2FtcGxlcjFEU2hhZG93LCB2ZWMzLCBmbG9hdCk7dmVjNCBzaGFkb3cyRChzYW1wbGVyMkRTaGFkb3csIHZlYzMsIGZsb2F0KTt2ZWM0IHNoYWRvdzFEUHJvaihzYW1wbGVyMURTaGFkb3csIHZlYzQsIGZsb2F0KTt2ZWM0IHNoYWRvdzJEUHJvaihzYW1wbGVyMkRTaGFkb3csIHZlYzQsIGZsb2F0KTsKAHZlYzQgdGV4dHVyZTJETG9kRVhUKHNhbXBsZXIyRCwgdmVjMiwgZmxvYXQpO3ZlYzQgdGV4dHVyZTJEUHJvakxvZEVYVChzYW1wbGVyMkQsIHZlYzMsIGZsb2F0KTt2ZWM0IHRleHR1cmUyRFByb2pMb2RFWFQoc2FtcGxlcjJELCB2ZWM0LCBmbG9hdCk7dmVjNCB0ZXh0dXJlQ3ViZUxvZEVYVChzYW1wbGVyQ3ViZSwgdmVjMywgZmxvYXQpOwoAZmxvYXQgaW50ZXJwb2xhdGVBdENlbnRyb2lkKGZsb2F0KTt2ZWMyICBpbnRlcnBvbGF0ZUF0Q2VudHJvaWQodmVjMik7dmVjMyAgaW50ZXJwb2xhdGVBdENlbnRyb2lkKHZlYzMpO3ZlYzQgIGludGVycG9sYXRlQXRDZW50cm9pZCh2ZWM0KTtmbG9hdCBpbnRlcnBvbGF0ZUF0U2FtcGxlKGZsb2F0LCBpbnQpO3ZlYzIgIGludGVycG9sYXRlQXRTYW1wbGUodmVjMiwgIGludCk7dmVjMyAgaW50ZXJwb2xhdGVBdFNhbXBsZSh2ZWMzLCAgaW50KTt2ZWM0ICBpbnRlcnBvbGF0ZUF0U2FtcGxlKHZlYzQsICBpbnQpO2Zsb2F0IGludGVycG9sYXRlQXRPZmZzZXQoZmxvYXQsIHZlYzIpO3ZlYzIgIGludGVycG9sYXRlQXRPZmZzZXQodmVjMiwgIHZlYzIpO3ZlYzMgIGludGVycG9sYXRlQXRPZmZzZXQodmVjMywgIHZlYzIpO3ZlYzQgIGludGVycG9sYXRlQXRPZmZzZXQodmVjNCwgIHZlYzIpOwoAdm9pZCBiZWdpbkludm9jYXRpb25JbnRlcmxvY2tBUkIodm9pZCk7dm9pZCBlbmRJbnZvY2F0aW9uSW50ZXJsb2NrQVJCKHZvaWQpOwBib29sIGhlbHBlckludm9jYXRpb25FWFQoKTsKAGZsb2F0IGludGVycG9sYXRlQXRWZXJ0ZXhBTUQoZmxvYXQsIHVpbnQpO3ZlYzIgIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQodmVjMiwgIHVpbnQpO3ZlYzMgIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQodmVjMywgIHVpbnQpO3ZlYzQgIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQodmVjNCwgIHVpbnQpO2ludCAgIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQoaW50LCAgIHVpbnQpO2l2ZWMyIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQoaXZlYzIsIHVpbnQpO2l2ZWMzIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQoaXZlYzMsIHVpbnQpO2l2ZWM0IGludGVycG9sYXRlQXRWZXJ0ZXhBTUQoaXZlYzQsIHVpbnQpO3VpbnQgIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQodWludCwgIHVpbnQpO3V2ZWMyIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQodXZlYzIsIHVpbnQpO3V2ZWMzIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQodXZlYzMsIHVpbnQpO3V2ZWM0IGludGVycG9sYXRlQXRWZXJ0ZXhBTUQodXZlYzQsIHVpbnQpO2Zsb2F0MTZfdCBpbnRlcnBvbGF0ZUF0VmVydGV4QU1EKGZsb2F0MTZfdCwgdWludCk7ZjE2dmVjMiAgIGludGVycG9sYXRlQXRWZXJ0ZXhBTUQoZjE2dmVjMiwgICB1aW50KTtmMTZ2ZWMzICAgaW50ZXJwb2xhdGVBdFZlcnRleEFNRChmMTZ2ZWMzLCAgIHVpbnQpO2YxNnZlYzQgICBpbnRlcnBvbGF0ZUF0VmVydGV4QU1EKGYxNnZlYzQsICAgdWludCk7CgBmbG9hdDE2X3QgaW50ZXJwb2xhdGVBdENlbnRyb2lkKGZsb2F0MTZfdCk7ZjE2dmVjMiAgIGludGVycG9sYXRlQXRDZW50cm9pZChmMTZ2ZWMyKTtmMTZ2ZWMzICAgaW50ZXJwb2xhdGVBdENlbnRyb2lkKGYxNnZlYzMpO2YxNnZlYzQgICBpbnRlcnBvbGF0ZUF0Q2VudHJvaWQoZjE2dmVjNCk7ZmxvYXQxNl90IGludGVycG9sYXRlQXRTYW1wbGUoZmxvYXQxNl90LCBpbnQpO2YxNnZlYzIgICBpbnRlcnBvbGF0ZUF0U2FtcGxlKGYxNnZlYzIsICAgaW50KTtmMTZ2ZWMzICAgaW50ZXJwb2xhdGVBdFNhbXBsZShmMTZ2ZWMzLCAgIGludCk7ZjE2dmVjNCAgIGludGVycG9sYXRlQXRTYW1wbGUoZjE2dmVjNCwgICBpbnQpO2Zsb2F0MTZfdCBpbnRlcnBvbGF0ZUF0T2Zmc2V0KGZsb2F0MTZfdCwgZjE2dmVjMik7ZjE2dmVjMiAgIGludGVycG9sYXRlQXRPZmZzZXQoZjE2dmVjMiwgICBmMTZ2ZWMyKTtmMTZ2ZWMzICAgaW50ZXJwb2xhdGVBdE9mZnNldChmMTZ2ZWMzLCAgIGYxNnZlYzIpO2YxNnZlYzQgICBpbnRlcnBvbGF0ZUF0T2Zmc2V0KGYxNnZlYzQsICAgZjE2dmVjMik7CgB1dmVjMiBjbG9jazJ4MzJBUkIoKTt1aW50NjRfdCBjbG9ja0FSQigpO3V2ZWMyIGNsb2NrUmVhbHRpbWUyeDMyRVhUKCk7dWludDY0X3QgY2xvY2tSZWFsdGltZUVYVCgpOwoAdWludCBmcmFnbWVudE1hc2tGZXRjaEFNRChzdWJwYXNzSW5wdXRNUyk7dWludCBmcmFnbWVudE1hc2tGZXRjaEFNRChpc3VicGFzc0lucHV0TVMpO3VpbnQgZnJhZ21lbnRNYXNrRmV0Y2hBTUQodXN1YnBhc3NJbnB1dE1TKTt2ZWM0ICBmcmFnbWVudEZldGNoQU1EKHN1YnBhc3NJbnB1dE1TLCAgdWludCk7aXZlYzQgZnJhZ21lbnRGZXRjaEFNRChpc3VicGFzc0lucHV0TVMsIHVpbnQpO3V2ZWM0IGZyYWdtZW50RmV0Y2hBTUQodXN1YnBhc3NJbnB1dE1TLCB1aW50KTsKAHZvaWQgdHJhY2VOVihhY2NlbGVyYXRpb25TdHJ1Y3R1cmVOVix1aW50LHVpbnQsdWludCx1aW50LHVpbnQsdmVjMyxmbG9hdCx2ZWMzLGZsb2F0LGludCk7dm9pZCBleGVjdXRlQ2FsbGFibGVOVih1aW50LCBpbnQpOwoAYm9vbCByZXBvcnRJbnRlcnNlY3Rpb25OVihmbG9hdCwgdWludCk7CgB2b2lkIGlnbm9yZUludGVyc2VjdGlvbk5WKCk7dm9pZCB0ZXJtaW5hdGVSYXlOVigpOwoAdm9pZCBleGVjdXRlQ2FsbGFibGVOVih1aW50LCBpbnQpOwoAdm9pZCB3cml0ZVBhY2tlZFByaW1pdGl2ZUluZGljZXM0eDhOVih1aW50LCB1aW50KTsKAHN0cnVjdCBnbF9EZXB0aFJhbmdlUGFyYW1ldGVycyB7AGhpZ2hwIGZsb2F0IG5lYXI7aGlnaHAgZmxvYXQgZmFyO2hpZ2hwIGZsb2F0IGRpZmY7AGZsb2F0IG5lYXI7ZmxvYXQgZmFyO2Zsb2F0IGRpZmY7AH07dW5pZm9ybSBnbF9EZXB0aFJhbmdlUGFyYW1ldGVycyBnbF9EZXB0aFJhbmdlOwoAdW5pZm9ybSBtYXQ0ICBnbF9Nb2RlbFZpZXdNYXRyaXg7dW5pZm9ybSBtYXQ0ICBnbF9Qcm9qZWN0aW9uTWF0cml4O3VuaWZvcm0gbWF0NCAgZ2xfTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDt1bmlmb3JtIG1hdDMgIGdsX05vcm1hbE1hdHJpeDt1bmlmb3JtIG1hdDQgIGdsX01vZGVsVmlld01hdHJpeEludmVyc2U7dW5pZm9ybSBtYXQ0ICBnbF9Qcm9qZWN0aW9uTWF0cml4SW52ZXJzZTt1bmlmb3JtIG1hdDQgIGdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhJbnZlcnNlO3VuaWZvcm0gbWF0NCAgZ2xfTW9kZWxWaWV3TWF0cml4VHJhbnNwb3NlO3VuaWZvcm0gbWF0NCAgZ2xfUHJvamVjdGlvbk1hdHJpeFRyYW5zcG9zZTt1bmlmb3JtIG1hdDQgIGdsX01vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhUcmFuc3Bvc2U7dW5pZm9ybSBtYXQ0ICBnbF9Nb2RlbFZpZXdNYXRyaXhJbnZlcnNlVHJhbnNwb3NlO3VuaWZvcm0gbWF0NCAgZ2xfUHJvamVjdGlvbk1hdHJpeEludmVyc2VUcmFuc3Bvc2U7dW5pZm9ybSBtYXQ0ICBnbF9Nb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4SW52ZXJzZVRyYW5zcG9zZTt1bmlmb3JtIGZsb2F0IGdsX05vcm1hbFNjYWxlO3N0cnVjdCBnbF9Qb2ludFBhcmFtZXRlcnMge2Zsb2F0IHNpemU7ZmxvYXQgc2l6ZU1pbjtmbG9hdCBzaXplTWF4O2Zsb2F0IGZhZGVUaHJlc2hvbGRTaXplO2Zsb2F0IGRpc3RhbmNlQ29uc3RhbnRBdHRlbnVhdGlvbjtmbG9hdCBkaXN0YW5jZUxpbmVhckF0dGVudWF0aW9uO2Zsb2F0IGRpc3RhbmNlUXVhZHJhdGljQXR0ZW51YXRpb247fTt1bmlmb3JtIGdsX1BvaW50UGFyYW1ldGVycyBnbF9Qb2ludDtzdHJ1Y3QgZ2xfTWF0ZXJpYWxQYXJhbWV0ZXJzIHt2ZWM0ICBlbWlzc2lvbjt2ZWM0ICBhbWJpZW50O3ZlYzQgIGRpZmZ1c2U7dmVjNCAgc3BlY3VsYXI7ZmxvYXQgc2hpbmluZXNzO307dW5pZm9ybSBnbF9NYXRlcmlhbFBhcmFtZXRlcnMgIGdsX0Zyb250TWF0ZXJpYWw7dW5pZm9ybSBnbF9NYXRlcmlhbFBhcmFtZXRlcnMgIGdsX0JhY2tNYXRlcmlhbDtzdHJ1Y3QgZ2xfTGlnaHRTb3VyY2VQYXJhbWV0ZXJzIHt2ZWM0ICBhbWJpZW50O3ZlYzQgIGRpZmZ1c2U7dmVjNCAgc3BlY3VsYXI7dmVjNCAgcG9zaXRpb247dmVjNCAgaGFsZlZlY3Rvcjt2ZWMzICBzcG90RGlyZWN0aW9uO2Zsb2F0IHNwb3RFeHBvbmVudDtmbG9hdCBzcG90Q3V0b2ZmO2Zsb2F0IHNwb3RDb3NDdXRvZmY7ZmxvYXQgY29uc3RhbnRBdHRlbnVhdGlvbjtmbG9hdCBsaW5lYXJBdHRlbnVhdGlvbjtmbG9hdCBxdWFkcmF0aWNBdHRlbnVhdGlvbjt9O3N0cnVjdCBnbF9MaWdodE1vZGVsUGFyYW1ldGVycyB7dmVjNCAgYW1iaWVudDt9O3VuaWZvcm0gZ2xfTGlnaHRNb2RlbFBhcmFtZXRlcnMgIGdsX0xpZ2h0TW9kZWw7c3RydWN0IGdsX0xpZ2h0TW9kZWxQcm9kdWN0cyB7dmVjNCAgc2NlbmVDb2xvcjt9O3VuaWZvcm0gZ2xfTGlnaHRNb2RlbFByb2R1Y3RzIGdsX0Zyb250TGlnaHRNb2RlbFByb2R1Y3Q7dW5pZm9ybSBnbF9MaWdodE1vZGVsUHJvZHVjdHMgZ2xfQmFja0xpZ2h0TW9kZWxQcm9kdWN0O3N0cnVjdCBnbF9MaWdodFByb2R1Y3RzIHt2ZWM0ICBhbWJpZW50O3ZlYzQgIGRpZmZ1c2U7dmVjNCAgc3BlY3VsYXI7fTtzdHJ1Y3QgZ2xfRm9nUGFyYW1ldGVycyB7dmVjNCAgY29sb3I7ZmxvYXQgZGVuc2l0eTtmbG9hdCBzdGFydDtmbG9hdCBlbmQ7ZmxvYXQgc2NhbGU7fTt1bmlmb3JtIGdsX0ZvZ1BhcmFtZXRlcnMgZ2xfRm9nOwoAaW4gICAgaGlnaHAgdXZlYzMgZ2xfTnVtV29ya0dyb3Vwcztjb25zdCBoaWdocCB1dmVjMyBnbF9Xb3JrR3JvdXBTaXplID0gdXZlYzMoMSwxLDEpO2luIGhpZ2hwIHV2ZWMzIGdsX1dvcmtHcm91cElEO2luIGhpZ2hwIHV2ZWMzIGdsX0xvY2FsSW52b2NhdGlvbklEO2luIGhpZ2hwIHV2ZWMzIGdsX0dsb2JhbEludm9jYXRpb25JRDtpbiBoaWdocCB1aW50IGdsX0xvY2FsSW52b2NhdGlvbkluZGV4OwoAaW4gaGlnaHAgaW50IGdsX0RldmljZUluZGV4OwoAb3V0IGdsX01lc2hQZXJWZXJ0ZXhOViB7dmVjNCBnbF9Qb3NpdGlvbjtmbG9hdCBnbF9Qb2ludFNpemU7ZmxvYXQgZ2xfQ2xpcERpc3RhbmNlW107ZmxvYXQgZ2xfQ3VsbERpc3RhbmNlW107cGVydmlld05WIHZlYzQgZ2xfUG9zaXRpb25QZXJWaWV3TlZbXTtwZXJ2aWV3TlYgZmxvYXQgZ2xfQ2xpcERpc3RhbmNlUGVyVmlld05WW11bXTtwZXJ2aWV3TlYgZmxvYXQgZ2xfQ3VsbERpc3RhbmNlUGVyVmlld05WW11bXTt9IGdsX01lc2hWZXJ0aWNlc05WW107AHBlcnByaW1pdGl2ZU5WIG91dCBnbF9NZXNoUGVyUHJpbWl0aXZlTlYge2ludCBnbF9QcmltaXRpdmVJRDtpbnQgZ2xfTGF5ZXI7aW50IGdsX1ZpZXdwb3J0SW5kZXg7aW50IGdsX1ZpZXdwb3J0TWFza1tdO3BlcnZpZXdOViBpbnQgZ2xfTGF5ZXJQZXJWaWV3TlZbXTtwZXJ2aWV3TlYgaW50IGdsX1ZpZXdwb3J0TWFza1BlclZpZXdOVltdW107fSBnbF9NZXNoUHJpbWl0aXZlc05WW107AG91dCB1aW50IGdsX1ByaW1pdGl2ZUNvdW50TlY7b3V0IHVpbnQgZ2xfUHJpbWl0aXZlSW5kaWNlc05WW107aW4gdWludCBnbF9NZXNoVmlld0NvdW50TlY7aW4gdWludCBnbF9NZXNoVmlld0luZGljZXNOVls0XTtjb25zdCBoaWdocCB1dmVjMyBnbF9Xb3JrR3JvdXBTaXplID0gdXZlYzMoMSwxLDEpO2luIGhpZ2hwIHV2ZWMzIGdsX1dvcmtHcm91cElEO2luIGhpZ2hwIHV2ZWMzIGdsX0xvY2FsSW52b2NhdGlvbklEO2luIGhpZ2hwIHV2ZWMzIGdsX0dsb2JhbEludm9jYXRpb25JRDtpbiBoaWdocCB1aW50IGdsX0xvY2FsSW52b2NhdGlvbkluZGV4OwoAb3V0IHVpbnQgZ2xfVGFza0NvdW50TlY7Y29uc3QgaGlnaHAgdXZlYzMgZ2xfV29ya0dyb3VwU2l6ZSA9IHV2ZWMzKDEsMSwxKTtpbiBoaWdocCB1dmVjMyBnbF9Xb3JrR3JvdXBJRDtpbiBoaWdocCB1dmVjMyBnbF9Mb2NhbEludm9jYXRpb25JRDtpbiBoaWdocCB1dmVjMyBnbF9HbG9iYWxJbnZvY2F0aW9uSUQ7aW4gaGlnaHAgdWludCBnbF9Mb2NhbEludm9jYXRpb25JbmRleDtpbiB1aW50IGdsX01lc2hWaWV3Q291bnROVjtpbiB1aW50IGdsX01lc2hWaWV3SW5kaWNlc05WWzRdOwoAaW4gaGlnaHAgaW50IGdsX0RldmljZUluZGV4O2luIGludCBnbF9EcmF3SURBUkI7CgBpbiBpbnQgZ2xfRHJhd0lEOwoAaW4gdmVjNCAgZ2xfQ29sb3I7aW4gdmVjNCAgZ2xfU2Vjb25kYXJ5Q29sb3I7aW4gdmVjMyAgZ2xfTm9ybWFsO2luIHZlYzQgIGdsX1ZlcnRleDtpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkMDtpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkMTtpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkMjtpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkMztpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkNDtpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkNTtpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkNjtpbiB2ZWM0ICBnbF9NdWx0aVRleENvb3JkNztpbiBmbG9hdCBnbF9Gb2dDb29yZDsKAGF0dHJpYnV0ZSB2ZWM0ICBnbF9Db2xvcjthdHRyaWJ1dGUgdmVjNCAgZ2xfU2Vjb25kYXJ5Q29sb3I7YXR0cmlidXRlIHZlYzMgIGdsX05vcm1hbDthdHRyaWJ1dGUgdmVjNCAgZ2xfVmVydGV4O2F0dHJpYnV0ZSB2ZWM0ICBnbF9NdWx0aVRleENvb3JkMDthdHRyaWJ1dGUgdmVjNCAgZ2xfTXVsdGlUZXhDb29yZDE7YXR0cmlidXRlIHZlYzQgIGdsX011bHRpVGV4Q29vcmQyO2F0dHJpYnV0ZSB2ZWM0ICBnbF9NdWx0aVRleENvb3JkMzthdHRyaWJ1dGUgdmVjNCAgZ2xfTXVsdGlUZXhDb29yZDQ7YXR0cmlidXRlIHZlYzQgIGdsX011bHRpVGV4Q29vcmQ1O2F0dHJpYnV0ZSB2ZWM0ICBnbF9NdWx0aVRleENvb3JkNjthdHRyaWJ1dGUgdmVjNCAgZ2xfTXVsdGlUZXhDb29yZDc7YXR0cmlidXRlIGZsb2F0IGdsX0ZvZ0Nvb3JkOwoAICAgICAgICB2ZWM0ICBnbF9DbGlwVmVydGV4O3ZhcnlpbmcgdmVjNCAgZ2xfRnJvbnRDb2xvcjt2YXJ5aW5nIHZlYzQgIGdsX0JhY2tDb2xvcjt2YXJ5aW5nIHZlYzQgIGdsX0Zyb250U2Vjb25kYXJ5Q29sb3I7dmFyeWluZyB2ZWM0ICBnbF9CYWNrU2Vjb25kYXJ5Q29sb3I7dmFyeWluZyB2ZWM0ICBnbF9UZXhDb29yZFtdO3ZhcnlpbmcgZmxvYXQgZ2xfRm9nRnJhZ0Nvb3JkOwoAICAgIHZlYzQgIGdsX0NsaXBWZXJ0ZXg7b3V0IHZlYzQgIGdsX0Zyb250Q29sb3I7b3V0IHZlYzQgIGdsX0JhY2tDb2xvcjtvdXQgdmVjNCAgZ2xfRnJvbnRTZWNvbmRhcnlDb2xvcjtvdXQgdmVjNCAgZ2xfQmFja1NlY29uZGFyeUNvbG9yO291dCB2ZWM0ICBnbF9UZXhDb29yZFtdO291dCBmbG9hdCBnbF9Gb2dGcmFnQ29vcmQ7CgB2ZWM0IGdsX1Bvc2l0aW9uO2Zsb2F0IGdsX1BvaW50U2l6ZTsAb3V0IGZsb2F0IGdsX0NsaXBEaXN0YW5jZVtdOwBvdXQgZ2xfUGVyVmVydGV4IHt2ZWM0IGdsX1Bvc2l0aW9uO2Zsb2F0IGdsX1BvaW50U2l6ZTtmbG9hdCBnbF9DbGlwRGlzdGFuY2VbXTsAZmxvYXQgZ2xfQ3VsbERpc3RhbmNlW107AH07CgBpbnQgZ2xfVmVydGV4SUQ7AGludCBnbF9JbnN0YW5jZUlEOwBpbiBpbnQgZ2xfVmVydGV4SW5kZXg7aW4gaW50IGdsX0luc3RhbmNlSW5kZXg7AGluIGludCBnbF9CYXNlVmVydGV4QVJCO2luIGludCBnbF9CYXNlSW5zdGFuY2VBUkI7aW4gaW50IGdsX0RyYXdJREFSQjsAb3V0IGludCBnbF9WaWV3cG9ydEluZGV4O291dCBpbnQgZ2xfTGF5ZXI7AGluIGludCBnbF9CYXNlVmVydGV4O2luIGludCBnbF9CYXNlSW5zdGFuY2U7aW4gaW50IGdsX0RyYXdJRDsAb3V0IGludCBnbF9WaWV3cG9ydE1hc2tbXTtvdXQgaW50IGdsX1NlY29uZGFyeVZpZXdwb3J0TWFza05WW107b3V0IHZlYzQgZ2xfU2Vjb25kYXJ5UG9zaXRpb25OVjtvdXQgdmVjNCBnbF9Qb3NpdGlvblBlclZpZXdOVltdO291dCBpbnQgIGdsX1ZpZXdwb3J0TWFza1BlclZpZXdOVltdOwBoaWdocCAgIHZlYzQgIGdsX1Bvc2l0aW9uO21lZGl1bXAgZmxvYXQgZ2xfUG9pbnRTaXplOwBpbiBoaWdocCBpbnQgZ2xfVmVydGV4SUQ7aW4gaGlnaHAgaW50IGdsX0luc3RhbmNlSUQ7AGluIGhpZ2hwIGludCBnbF9WZXJ0ZXhJbmRleDtpbiBoaWdocCBpbnQgZ2xfSW5zdGFuY2VJbmRleDsAaGlnaHAgdmVjNCAgZ2xfUG9zaXRpb247aGlnaHAgZmxvYXQgZ2xfUG9pbnRTaXplOwBvdXQgZ2xfUGVyVmVydGV4IHtoaWdocCB2ZWM0ICBnbF9Qb3NpdGlvbjtoaWdocCBmbG9hdCBnbF9Qb2ludFNpemU7fTsAaW4gaGlnaHAgaW50IGdsX0RldmljZUluZGV4O2luIGhpZ2hwIGludCBnbF9WaWV3SW5kZXg7CgBpbiBoaWdocCB1aW50IGdsX1ZpZXdJRF9PVlI7CgB9IGdsX2luW107aW4gaW50IGdsX1ByaW1pdGl2ZUlESW47b3V0IGdsX1BlclZlcnRleCB7dmVjNCBnbF9Qb3NpdGlvbjtmbG9hdCBnbF9Qb2ludFNpemU7ZmxvYXQgZ2xfQ2xpcERpc3RhbmNlW107CgB9O291dCBpbnQgZ2xfUHJpbWl0aXZlSUQ7b3V0IGludCBnbF9MYXllcjsAb3V0IGludCBnbF9WaWV3cG9ydEluZGV4OwBvdXQgdmVjNCBnbF9DbGlwVmVydGV4OwBpbiBpbnQgZ2xfSW52b2NhdGlvbklEOwBpbiBnbF9QZXJWZXJ0ZXgge2hpZ2hwIHZlYzQgZ2xfUG9zaXRpb247aGlnaHAgZmxvYXQgZ2xfUG9pbnRTaXplO30gZ2xfaW5bXTsKaW4gaGlnaHAgaW50IGdsX1ByaW1pdGl2ZUlESW47aW4gaGlnaHAgaW50IGdsX0ludm9jYXRpb25JRDsKb3V0IGdsX1BlclZlcnRleCB7aGlnaHAgdmVjNCBnbF9Qb3NpdGlvbjtoaWdocCBmbG9hdCBnbF9Qb2ludFNpemU7fTsKb3V0IGhpZ2hwIGludCBnbF9QcmltaXRpdmVJRDtvdXQgaGlnaHAgaW50IGdsX0xheWVyOwoAaW4gaW50IGdsX1BhdGNoVmVydGljZXNJbjtpbiBpbnQgZ2xfUHJpbWl0aXZlSUQ7aW4gaW50IGdsX0ludm9jYXRpb25JRDtvdXQgZ2xfUGVyVmVydGV4IHt2ZWM0IGdsX1Bvc2l0aW9uO2Zsb2F0IGdsX1BvaW50U2l6ZTtmbG9hdCBnbF9DbGlwRGlzdGFuY2VbXTsAZmxvYXQgZ2xfQ3VsbERpc3RhbmNlW107aW50ICBnbF9WaWV3cG9ydE1hc2tbXTt2ZWM0IGdsX1NlY29uZGFyeVBvc2l0aW9uTlY7aW50ICBnbF9TZWNvbmRhcnlWaWV3cG9ydE1hc2tOVltdO3ZlYzQgZ2xfUG9zaXRpb25QZXJWaWV3TlZbXTtpbnQgIGdsX1ZpZXdwb3J0TWFza1BlclZpZXdOVltdOwB9IGdsX291dFtdO3BhdGNoIG91dCBmbG9hdCBnbF9UZXNzTGV2ZWxPdXRlcls0XTtwYXRjaCBvdXQgZmxvYXQgZ2xfVGVzc0xldmVsSW5uZXJbMl07CgBvdXQgaW50IGdsX1ZpZXdwb3J0SW5kZXg7b3V0IGludCBnbF9MYXllcjsKAGluIGhpZ2hwIGludCBnbF9QYXRjaFZlcnRpY2VzSW47aW4gaGlnaHAgaW50IGdsX1ByaW1pdGl2ZUlEO2luIGhpZ2hwIGludCBnbF9JbnZvY2F0aW9uSUQ7b3V0IGdsX1BlclZlcnRleCB7aGlnaHAgdmVjNCBnbF9Qb3NpdGlvbjtoaWdocCBmbG9hdCBnbF9Qb2ludFNpemU7AH0gZ2xfb3V0W107cGF0Y2ggb3V0IGhpZ2hwIGZsb2F0IGdsX1Rlc3NMZXZlbE91dGVyWzRdO3BhdGNoIG91dCBoaWdocCBmbG9hdCBnbF9UZXNzTGV2ZWxJbm5lclsyXTtwYXRjaCBvdXQgaGlnaHAgdmVjNCBnbF9Cb3VuZGluZ0JveE9FU1syXTtwYXRjaCBvdXQgaGlnaHAgdmVjNCBnbF9Cb3VuZGluZ0JveEVYVFsyXTsKAHBhdGNoIG91dCBoaWdocCB2ZWM0IGdsX0JvdW5kaW5nQm94WzJdOwoAaW4gaW50IGdsX1BhdGNoVmVydGljZXNJbjtpbiBpbnQgZ2xfUHJpbWl0aXZlSUQ7aW4gdmVjMyBnbF9UZXNzQ29vcmQ7cGF0Y2ggaW4gZmxvYXQgZ2xfVGVzc0xldmVsT3V0ZXJbNF07cGF0Y2ggaW4gZmxvYXQgZ2xfVGVzc0xldmVsSW5uZXJbMl07b3V0IGdsX1BlclZlcnRleCB7dmVjNCBnbF9Qb3NpdGlvbjtmbG9hdCBnbF9Qb2ludFNpemU7ZmxvYXQgZ2xfQ2xpcERpc3RhbmNlW107AG91dCBpbnQgIGdsX1ZpZXdwb3J0TWFza1tdO291dCB2ZWM0IGdsX1NlY29uZGFyeVBvc2l0aW9uTlY7b3V0IGludCAgZ2xfU2Vjb25kYXJ5Vmlld3BvcnRNYXNrTlZbXTtvdXQgdmVjNCBnbF9Qb3NpdGlvblBlclZpZXdOVltdO291dCBpbnQgIGdsX1ZpZXdwb3J0TWFza1BlclZpZXdOVltdOwBpbiBoaWdocCBpbnQgZ2xfUGF0Y2hWZXJ0aWNlc0luO2luIGhpZ2hwIGludCBnbF9QcmltaXRpdmVJRDtpbiBoaWdocCB2ZWMzIGdsX1Rlc3NDb29yZDtwYXRjaCBpbiBoaWdocCBmbG9hdCBnbF9UZXNzTGV2ZWxPdXRlcls0XTtwYXRjaCBpbiBoaWdocCBmbG9hdCBnbF9UZXNzTGV2ZWxJbm5lclsyXTtvdXQgZ2xfUGVyVmVydGV4IHtoaWdocCB2ZWM0IGdsX1Bvc2l0aW9uO2hpZ2hwIGZsb2F0IGdsX1BvaW50U2l6ZTsAdmVjNCAgZ2xfRnJhZ0Nvb3JkO2Jvb2wgIGdsX0Zyb250RmFjaW5nO2Zsb2F0IGdsX0ZyYWdEZXB0aDsAdmVjMiBnbF9Qb2ludENvb3JkOwBvdXQgaW50IGdsX0ZyYWdTdGVuY2lsUmVmQVJCOwB2ZWM0IGdsX0ZyYWdDb2xvcjsAaW4gZmxvYXQgZ2xfQ2xpcERpc3RhbmNlW107AGluIGZsb2F0IGdsX0ZvZ0ZyYWdDb29yZDtpbiB2ZWM0ICBnbF9UZXhDb29yZFtdO2luIHZlYzQgIGdsX0NvbG9yO2luIHZlYzQgIGdsX1NlY29uZGFyeUNvbG9yOwBpbiBnbF9QZXJGcmFnbWVudCB7aW4gZmxvYXQgZ2xfRm9nRnJhZ0Nvb3JkO2luIHZlYzQgIGdsX1RleENvb3JkW107aW4gdmVjNCAgZ2xfQ29sb3I7aW4gdmVjNCAgZ2xfU2Vjb25kYXJ5Q29sb3I7fTsAdmFyeWluZyB2ZWM0ICBnbF9Db2xvcjt2YXJ5aW5nIHZlYzQgIGdsX1NlY29uZGFyeUNvbG9yO3ZhcnlpbmcgdmVjNCAgZ2xfVGV4Q29vcmRbXTt2YXJ5aW5nIGZsb2F0IGdsX0ZvZ0ZyYWdDb29yZDsAZmxhdCBpbiBpbnQgZ2xfUHJpbWl0aXZlSUQ7AGZsYXQgaW4gIGludCAgZ2xfU2FtcGxlSUQ7ICAgICBpbiAgdmVjMiBnbF9TYW1wbGVQb3NpdGlvbjtmbGF0IGluICBpbnQgIGdsX1NhbXBsZU1hc2tJbltdOyAgICAgb3V0IGludCAgZ2xfU2FtcGxlTWFza1tdOwB1bmlmb3JtIGludCBnbF9OdW1TYW1wbGVzOwBmbGF0IGluIGludCBnbF9MYXllcjtmbGF0IGluIGludCBnbF9WaWV3cG9ydEluZGV4OwBpbiBmbG9hdCBnbF9DdWxsRGlzdGFuY2VbXTtib29sIGdsX0hlbHBlckludm9jYXRpb247AGZsYXQgaW4gaXZlYzIgZ2xfRnJhZ1NpemVFWFQ7ZmxhdCBpbiBpbnQgICBnbF9GcmFnSW52b2NhdGlvbkNvdW50RVhUOwBpbiB2ZWMyIGdsX0JhcnlDb29yZE5vUGVyc3BBTUQ7aW4gdmVjMiBnbF9CYXJ5Q29vcmROb1BlcnNwQ2VudHJvaWRBTUQ7aW4gdmVjMiBnbF9CYXJ5Q29vcmROb1BlcnNwU2FtcGxlQU1EO2luIHZlYzIgZ2xfQmFyeUNvb3JkU21vb3RoQU1EO2luIHZlYzIgZ2xfQmFyeUNvb3JkU21vb3RoQ2VudHJvaWRBTUQ7aW4gdmVjMiBnbF9CYXJ5Q29vcmRTbW9vdGhTYW1wbGVBTUQ7aW4gdmVjMyBnbF9CYXJ5Q29vcmRQdWxsTW9kZWxBTUQ7AGluIGJvb2wgZ2xfRnJhZ0Z1bGx5Q292ZXJlZE5WOwBmbGF0IGluIGl2ZWMyIGdsX0ZyYWdtZW50U2l6ZU5WO2ZsYXQgaW4gaW50ICAgZ2xfSW52b2NhdGlvbnNQZXJQaXhlbE5WO2luIHZlYzMgZ2xfQmFyeUNvb3JkTlY7aW4gdmVjMyBnbF9CYXJ5Q29vcmROb1BlcnNwTlY7AG1lZGl1bXAgdmVjNCBnbF9GcmFnQ29vcmQ7ICAgICAgICBib29sIGdsX0Zyb250RmFjaW5nO21lZGl1bXAgdmVjNCBnbF9GcmFnQ29sb3I7bWVkaXVtcCB2ZWMyIGdsX1BvaW50Q29vcmQ7AGhpZ2hwICAgdmVjNCAgZ2xfRnJhZ0Nvb3JkOyAgICAgICAgYm9vbCAgZ2xfRnJvbnRGYWNpbmc7bWVkaXVtcCB2ZWMyICBnbF9Qb2ludENvb3JkO2hpZ2hwICAgZmxvYXQgZ2xfRnJhZ0RlcHRoOwBib29sIGdsX0hlbHBlckludm9jYXRpb247ZmxhdCBpbiBoaWdocCBpbnQgZ2xfUHJpbWl0aXZlSUQ7ZmxhdCBpbiBoaWdocCBpbnQgZ2xfTGF5ZXI7AGZsYXQgIGluIGxvd3AgICAgIGludCBnbF9TYW1wbGVJRDsgICAgICBpbiBtZWRpdW1wIHZlYzIgZ2xfU2FtcGxlUG9zaXRpb247ZmxhdCAgaW4gaGlnaHAgICAgaW50IGdsX1NhbXBsZU1hc2tJbltdOyAgICAgb3V0IGhpZ2hwICAgIGludCBnbF9TYW1wbGVNYXNrW107AHVuaWZvcm0gbG93cCBpbnQgZ2xfTnVtU2FtcGxlczsAaGlnaHAgZmxvYXQgZ2xfRnJhZ0RlcHRoRVhUOwBmbGF0IGluIGl2ZWMyIGdsX0ZyYWdtZW50U2l6ZU5WO2ZsYXQgaW4gaW50ICAgZ2xfSW52b2NhdGlvbnNQZXJQaXhlbE5WOwBpbiB2ZWMzIGdsX0JhcnlDb29yZE5WO2luIHZlYzMgZ2xfQmFyeUNvb3JkTm9QZXJzcE5WOwB1bmlmb3JtIHVpbnQgZ2xfU3ViR3JvdXBTaXplQVJCO2luIHVpbnQgICAgIGdsX1N1Ykdyb3VwSW52b2NhdGlvbkFSQjtpbiB1aW50NjRfdCBnbF9TdWJHcm91cEVxTWFza0FSQjtpbiB1aW50NjRfdCBnbF9TdWJHcm91cEdlTWFza0FSQjtpbiB1aW50NjRfdCBnbF9TdWJHcm91cEd0TWFza0FSQjtpbiB1aW50NjRfdCBnbF9TdWJHcm91cExlTWFza0FSQjtpbiB1aW50NjRfdCBnbF9TdWJHcm91cEx0TWFza0FSQjsKAHVuaWZvcm0gdWludCBnbF9TdWJHcm91cFNpemVBUkI7ZmxhdCBpbiB1aW50ICAgICBnbF9TdWJHcm91cEludm9jYXRpb25BUkI7ZmxhdCBpbiB1aW50NjRfdCBnbF9TdWJHcm91cEVxTWFza0FSQjtmbGF0IGluIHVpbnQ2NF90IGdsX1N1Ykdyb3VwR2VNYXNrQVJCO2ZsYXQgaW4gdWludDY0X3QgZ2xfU3ViR3JvdXBHdE1hc2tBUkI7ZmxhdCBpbiB1aW50NjRfdCBnbF9TdWJHcm91cExlTWFza0FSQjtmbGF0IGluIHVpbnQ2NF90IGdsX1N1Ykdyb3VwTHRNYXNrQVJCOwoAZmxhdCBpbiBoaWdocCBpbnQgZ2xfRGV2aWNlSW5kZXg7ZmxhdCBpbiBoaWdocCBpbnQgZ2xfVmlld0luZGV4OwoAaW4gbWVkaXVtcCB1aW50ICBnbF9TdWJncm91cFNpemU7aW4gbWVkaXVtcCB1aW50ICBnbF9TdWJncm91cEludm9jYXRpb25JRDtpbiBoaWdocCAgIHV2ZWM0IGdsX1N1Ymdyb3VwRXFNYXNrO2luIGhpZ2hwICAgdXZlYzQgZ2xfU3ViZ3JvdXBHZU1hc2s7aW4gaGlnaHAgICB1dmVjNCBnbF9TdWJncm91cEd0TWFzaztpbiBoaWdocCAgIHV2ZWM0IGdsX1N1Ymdyb3VwTGVNYXNrO2luIGhpZ2hwICAgdXZlYzQgZ2xfU3ViZ3JvdXBMdE1hc2s7aW4gaGlnaHAgICB1aW50ICBnbF9XYXJwc1BlclNNTlY7aW4gaGlnaHAgICB1aW50ICBnbF9TTUNvdW50TlY7aW4gaGlnaHAgICB1aW50ICBnbF9XYXJwSUROVjtpbiBoaWdocCAgIHVpbnQgIGdsX1NNSUROVjsKAGluIGhpZ2hwICAgdWludCAgZ2xfTnVtU3ViZ3JvdXBzO2luIGhpZ2hwICAgdWludCAgZ2xfU3ViZ3JvdXBJRDsKAGZsYXQgaW4gbWVkaXVtcCB1aW50ICBnbF9TdWJncm91cFNpemU7ZmxhdCBpbiBtZWRpdW1wIHVpbnQgIGdsX1N1Ymdyb3VwSW52b2NhdGlvbklEO2ZsYXQgaW4gaGlnaHAgICB1dmVjNCBnbF9TdWJncm91cEVxTWFzaztmbGF0IGluIGhpZ2hwICAgdXZlYzQgZ2xfU3ViZ3JvdXBHZU1hc2s7ZmxhdCBpbiBoaWdocCAgIHV2ZWM0IGdsX1N1Ymdyb3VwR3RNYXNrO2ZsYXQgaW4gaGlnaHAgICB1dmVjNCBnbF9TdWJncm91cExlTWFzaztmbGF0IGluIGhpZ2hwICAgdXZlYzQgZ2xfU3ViZ3JvdXBMdE1hc2s7ZmxhdCBpbiBoaWdocCAgIHVpbnQgIGdsX1dhcnBzUGVyU01OVjtmbGF0IGluIGhpZ2hwICAgdWludCAgZ2xfU01Db3VudE5WO2ZsYXQgaW4gaGlnaHAgICB1aW50ICBnbF9XYXJwSUROVjtmbGF0IGluIGhpZ2hwICAgdWludCAgZ2xfU01JRE5WOwoAaW4gICAgdXZlYzMgIGdsX0xhdW5jaElETlY7aW4gICAgdXZlYzMgIGdsX0xhdW5jaFNpemVOVjsKAGNvbnN0IHVpbnQgZ2xfUmF5RmxhZ3NOb25lTlYgPSAwVTtjb25zdCB1aW50IGdsX1JheUZsYWdzT3BhcXVlTlYgPSAxVTtjb25zdCB1aW50IGdsX1JheUZsYWdzTm9PcGFxdWVOViA9IDJVO2NvbnN0IHVpbnQgZ2xfUmF5RmxhZ3NUZXJtaW5hdGVPbkZpcnN0SGl0TlYgPSA0VTtjb25zdCB1aW50IGdsX1JheUZsYWdzU2tpcENsb3Nlc3RIaXRTaGFkZXJOViA9IDhVO2NvbnN0IHVpbnQgZ2xfUmF5RmxhZ3NDdWxsQmFja0ZhY2luZ1RyaWFuZ2xlc05WID0gMTZVO2NvbnN0IHVpbnQgZ2xfUmF5RmxhZ3NDdWxsRnJvbnRGYWNpbmdUcmlhbmdsZXNOViA9IDMyVTtjb25zdCB1aW50IGdsX1JheUZsYWdzQ3VsbE9wYXF1ZU5WID0gNjRVO2NvbnN0IHVpbnQgZ2xfUmF5RmxhZ3NDdWxsTm9PcGFxdWVOViA9IDEyOFU7CgBpbiAgICB1dmVjMyAgZ2xfTGF1bmNoSUROVjtpbiAgICB1dmVjMyAgZ2xfTGF1bmNoU2l6ZU5WO2luICAgICBpbnQgICBnbF9QcmltaXRpdmVJRDtpbiAgICAgaW50ICAgZ2xfSW5zdGFuY2VJRDtpbiAgICAgaW50ICAgZ2xfSW5zdGFuY2VDdXN0b21JbmRleE5WO2luICAgIHZlYzMgICBnbF9Xb3JsZFJheU9yaWdpbk5WO2luICAgIHZlYzMgICBnbF9Xb3JsZFJheURpcmVjdGlvbk5WO2luICAgIHZlYzMgICBnbF9PYmplY3RSYXlPcmlnaW5OVjtpbiAgICB2ZWMzICAgZ2xfT2JqZWN0UmF5RGlyZWN0aW9uTlY7aW4gICAgZmxvYXQgIGdsX1JheVRtaW5OVjtpbiAgICBmbG9hdCAgZ2xfUmF5VG1heE5WO2luICAgIG1hdDR4MyBnbF9PYmplY3RUb1dvcmxkTlY7aW4gICAgbWF0NHgzIGdsX1dvcmxkVG9PYmplY3ROVjtpbiAgICB1aW50ICAgZ2xfSW5jb21pbmdSYXlGbGFnc05WOwoAaW4gICAgdXZlYzMgIGdsX0xhdW5jaElETlY7aW4gICAgdXZlYzMgIGdsX0xhdW5jaFNpemVOVjtpbiAgICAgaW50ICAgZ2xfUHJpbWl0aXZlSUQ7aW4gICAgIGludCAgIGdsX0luc3RhbmNlSUQ7aW4gICAgIGludCAgIGdsX0luc3RhbmNlQ3VzdG9tSW5kZXhOVjtpbiAgICB2ZWMzICAgZ2xfV29ybGRSYXlPcmlnaW5OVjtpbiAgICB2ZWMzICAgZ2xfV29ybGRSYXlEaXJlY3Rpb25OVjtpbiAgICB2ZWMzICAgZ2xfT2JqZWN0UmF5T3JpZ2luTlY7aW4gICAgdmVjMyAgIGdsX09iamVjdFJheURpcmVjdGlvbk5WO2luICAgIGZsb2F0ICBnbF9SYXlUbWluTlY7aW4gICAgZmxvYXQgIGdsX1JheVRtYXhOVjtpbiAgICBmbG9hdCAgZ2xfSGl0VE5WO2luICAgIHVpbnQgICBnbF9IaXRLaW5kTlY7aW4gICAgbWF0NHgzIGdsX09iamVjdFRvV29ybGROVjtpbiAgICBtYXQ0eDMgZ2xfV29ybGRUb09iamVjdE5WO2luICAgIHVpbnQgICBnbF9JbmNvbWluZ1JheUZsYWdzTlY7CgBpbiAgICB1dmVjMyAgZ2xfTGF1bmNoSUROVjtpbiAgICB1dmVjMyAgZ2xfTGF1bmNoU2l6ZU5WO2luICAgIHZlYzMgICBnbF9Xb3JsZFJheU9yaWdpbk5WO2luICAgIHZlYzMgICBnbF9Xb3JsZFJheURpcmVjdGlvbk5WO2luICAgIHZlYzMgICBnbF9PYmplY3RSYXlPcmlnaW5OVjtpbiAgICB2ZWMzICAgZ2xfT2JqZWN0UmF5RGlyZWN0aW9uTlY7aW4gICAgZmxvYXQgIGdsX1JheVRtaW5OVjtpbiAgICBmbG9hdCAgZ2xfUmF5VG1heE5WO2luICAgIHVpbnQgICBnbF9JbmNvbWluZ1JheUZsYWdzTlY7CgBmbGF0IGluIGhpZ2hwIHVpbnQgZ2xfVmlld0lEX09WUjsKAGNvbnN0IGludCBnbF9TY29wZURldmljZSAgICAgID0gMTsKAGNvbnN0IGludCBnbF9TY29wZVdvcmtncm91cCAgID0gMjsKAGNvbnN0IGludCBnbF9TY29wZVN1Ymdyb3VwICAgID0gMzsKAGNvbnN0IGludCBnbF9TY29wZUludm9jYXRpb24gID0gNDsKAGNvbnN0IGludCBnbF9TY29wZVF1ZXVlRmFtaWx5ID0gNTsKAGNvbnN0IGludCBnbF9TZW1hbnRpY3NSZWxheGVkICAgICAgICAgPSAweDA7CgBjb25zdCBpbnQgZ2xfU2VtYW50aWNzQWNxdWlyZSAgICAgICAgID0gMHgyOwoAY29uc3QgaW50IGdsX1NlbWFudGljc1JlbGVhc2UgICAgICAgICA9IDB4NDsKAGNvbnN0IGludCBnbF9TZW1hbnRpY3NBY3F1aXJlUmVsZWFzZSAgPSAweDg7CgBjb25zdCBpbnQgZ2xfU2VtYW50aWNzTWFrZUF2YWlsYWJsZSAgID0gMHgyMDAwOwoAY29uc3QgaW50IGdsX1NlbWFudGljc01ha2VWaXNpYmxlICAgICA9IDB4NDAwMDsKAGNvbnN0IGludCBnbF9TZW1hbnRpY3NWb2xhdGlsZSAgICAgICAgPSAweDgwMDA7CgBjb25zdCBpbnQgZ2xfU3RvcmFnZVNlbWFudGljc05vbmUgICAgID0gMHgwOwoAY29uc3QgaW50IGdsX1N0b3JhZ2VTZW1hbnRpY3NCdWZmZXIgICA9IDB4NDA7CgBjb25zdCBpbnQgZ2xfU3RvcmFnZVNlbWFudGljc1NoYXJlZCAgID0gMHgxMDA7CgBjb25zdCBpbnQgZ2xfU3RvcmFnZVNlbWFudGljc0ltYWdlICAgID0gMHg4MDA7CgBjb25zdCBpbnQgZ2xfU3RvcmFnZVNlbWFudGljc091dHB1dCAgID0gMHgxMDAwOwoAAAAAAAABAAAACAAAAAkAAAADAAAAYm9vbCBzcGFyc2VUZXhlbHNSZXNpZGVudEFSQihpbnQgY29kZSk7CgAsZjE2dmVjACx2ZWMAdmVjNCAAaW50IABPZmZzZXRzAEFSQgAsZmxvYXQALGl2ZWMyAFs0XQAsb3V0IAAsaW50AEFNRAAsZmxvYXQxNl90AExvZAB0ZXhlbABzcGFyc2VUZXhlbAAsZjE2dmVjNAAsdmVjNAAsZmxvYXQxNl90LGZsb2F0MTZfdAAsZmxvYXQsZmxvYXQAZmxvYXQxNl90IABmbG9hdCAAUHJvagBHcmFkAEZldGNoAENsYW1wAHZlYwAsaXZlYwAsIGl2ZWMALCBpbnQAaGlnaHAgAHZlYzQgaW1hZ2VMb2FkKHJlYWRvbmx5IHZvbGF0aWxlIGNvaGVyZW50IAB2b2lkIGltYWdlU3RvcmUod3JpdGVvbmx5IHZvbGF0aWxlIGNvaGVyZW50IAB2ZWM0KTsKAGludCBzcGFyc2VJbWFnZUxvYWRBUkIocmVhZG9ubHkgdm9sYXRpbGUgY29oZXJlbnQgACwgb3V0IABoaWdocCBpbnQAaGlnaHAgdWludAAsIGludCwgaW50LCBpbnQsIGludCwgaW50ACBpbWFnZUF0b21pY0xvYWQodm9sYXRpbGUgY29oZXJlbnQgACwgaW50LCBpbnQsIGludCk7CgB2b2lkIGltYWdlQXRvbWljU3RvcmUodm9sYXRpbGUgY29oZXJlbnQgACBpbWFnZUF0b21pY0NvbXBTd2FwKHZvbGF0aWxlIGNvaGVyZW50IABB0JQJC4saTksCAHFLAgCUSwIAt0sCANpLAgD8SwIAH0wCACwgaW50LCBpbnQsIGludABmbG9hdCBpbWFnZUF0b21pY0V4Y2hhbmdlKHZvbGF0aWxlIGNvaGVyZW50IAAsIGZsb2F0KTsKAHZlYzQgaW1hZ2VMb2FkTG9kQU1EKHJlYWRvbmx5IHZvbGF0aWxlIGNvaGVyZW50IAB2b2lkIGltYWdlU3RvcmVMb2RBTUQod3JpdGVvbmx5IHZvbGF0aWxlIGNvaGVyZW50IABpbnQgc3BhcnNlSW1hZ2VMb2FkTG9kQU1EKHJlYWRvbmx5IHZvbGF0aWxlIGNvaGVyZW50IAAgaW1hZ2VBdG9taWNBZGQodm9sYXRpbGUgY29oZXJlbnQgACBpbWFnZUF0b21pY01pbih2b2xhdGlsZSBjb2hlcmVudCAAIGltYWdlQXRvbWljTWF4KHZvbGF0aWxlIGNvaGVyZW50IAAgaW1hZ2VBdG9taWNBbmQodm9sYXRpbGUgY29oZXJlbnQgACBpbWFnZUF0b21pY09yKHZvbGF0aWxlIGNvaGVyZW50IAAgaW1hZ2VBdG9taWNYb3Iodm9sYXRpbGUgY29oZXJlbnQgACBpbWFnZUF0b21pY0V4Y2hhbmdlKHZvbGF0aWxlIGNvaGVyZW50IABpdmVjACBpbWFnZVNpemUocmVhZG9ubHkgd3JpdGVvbmx5IHZvbGF0aWxlIGNvaGVyZW50IAAgdGV4dHVyZVNpemUoACxpbnQpOwoAaW1hZ2VTYW1wbGVzKHJlYWRvbmx5IHdyaXRlb25seSB2b2xhdGlsZSBjb2hlcmVudCAAdGV4dHVyZVNhbXBsZXMoAHZlYzIgdGV4dHVyZVF1ZXJ5TG9kKAAsIGZsb2F0MTZfdAAsIGZsb2F0ACwgZjE2dmVjACwgdmVjAGludCB0ZXh0dXJlUXVlcnlMZXZlbHMoAHZlYzQgc3VicGFzc0xvYWQAYm9vbCAgIHN1Ymdyb3VwQWxsRXF1YWwoJXMpOwoAJXMgICAgIHN1Ymdyb3VwQnJvYWRjYXN0KCVzLCB1aW50KTsKACVzICAgICBzdWJncm91cEJyb2FkY2FzdEZpcnN0KCVzKTsKACVzICAgICBzdWJncm91cFNodWZmbGUoJXMsIHVpbnQpOwoAJXMgICAgIHN1Ymdyb3VwU2h1ZmZsZVhvciglcywgdWludCk7CgAlcyAgICAgc3ViZ3JvdXBTaHVmZmxlVXAoJXMsIHVpbnQgZGVsdGEpOwoAJXMgICAgIHN1Ymdyb3VwU2h1ZmZsZURvd24oJXMsIHVpbnQgZGVsdGEpOwoAJXMgICAgIHN1Ymdyb3VwQWRkKCVzKTsKACVzICAgICBzdWJncm91cE11bCglcyk7CgAlcyAgICAgc3ViZ3JvdXBNaW4oJXMpOwoAJXMgICAgIHN1Ymdyb3VwTWF4KCVzKTsKACVzICAgICBzdWJncm91cEFuZCglcyk7CgAlcyAgICAgc3ViZ3JvdXBPciglcyk7CgAlcyAgICAgc3ViZ3JvdXBYb3IoJXMpOwoAJXMgICAgIHN1Ymdyb3VwSW5jbHVzaXZlQWRkKCVzKTsKACVzICAgICBzdWJncm91cEluY2x1c2l2ZU11bCglcyk7CgAlcyAgICAgc3ViZ3JvdXBJbmNsdXNpdmVNaW4oJXMpOwoAJXMgICAgIHN1Ymdyb3VwSW5jbHVzaXZlTWF4KCVzKTsKACVzICAgICBzdWJncm91cEluY2x1c2l2ZUFuZCglcyk7CgAlcyAgICAgc3ViZ3JvdXBJbmNsdXNpdmVPciglcyk7CgAlcyAgICAgc3ViZ3JvdXBJbmNsdXNpdmVYb3IoJXMpOwoAJXMgICAgIHN1Ymdyb3VwRXhjbHVzaXZlQWRkKCVzKTsKACVzICAgICBzdWJncm91cEV4Y2x1c2l2ZU11bCglcyk7CgAlcyAgICAgc3ViZ3JvdXBFeGNsdXNpdmVNaW4oJXMpOwoAJXMgICAgIHN1Ymdyb3VwRXhjbHVzaXZlTWF4KCVzKTsKACVzICAgICBzdWJncm91cEV4Y2x1c2l2ZUFuZCglcyk7CgAlcyAgICAgc3ViZ3JvdXBFeGNsdXNpdmVPciglcyk7CgAlcyAgICAgc3ViZ3JvdXBFeGNsdXNpdmVYb3IoJXMpOwoAJXMgICAgIHN1Ymdyb3VwQ2x1c3RlcmVkQWRkKCVzLCB1aW50KTsKACVzICAgICBzdWJncm91cENsdXN0ZXJlZE11bCglcywgdWludCk7CgAlcyAgICAgc3ViZ3JvdXBDbHVzdGVyZWRNaW4oJXMsIHVpbnQpOwoAJXMgICAgIHN1Ymdyb3VwQ2x1c3RlcmVkTWF4KCVzLCB1aW50KTsKACVzICAgICBzdWJncm91cENsdXN0ZXJlZEFuZCglcywgdWludCk7CgAlcyAgICAgc3ViZ3JvdXBDbHVzdGVyZWRPciglcywgdWludCk7CgAlcyAgICAgc3ViZ3JvdXBDbHVzdGVyZWRYb3IoJXMsIHVpbnQpOwoAJXMgICAgIHN1Ymdyb3VwUXVhZEJyb2FkY2FzdCglcywgdWludCk7CgAlcyAgICAgc3ViZ3JvdXBRdWFkU3dhcEhvcml6b250YWwoJXMpOwoAJXMgICAgIHN1Ymdyb3VwUXVhZFN3YXBWZXJ0aWNhbCglcyk7CgAlcyAgICAgc3ViZ3JvdXBRdWFkU3dhcERpYWdvbmFsKCVzKTsKAHV2ZWM0ICBzdWJncm91cFBhcnRpdGlvbk5WKCVzKTsKACVzICAgICBzdWJncm91cFBhcnRpdGlvbmVkQWRkTlYoJXMsIHV2ZWM0IGJhbGxvdCk7CgAlcyAgICAgc3ViZ3JvdXBQYXJ0aXRpb25lZE11bE5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRNaW5OViglcywgdXZlYzQgYmFsbG90KTsKACVzICAgICBzdWJncm91cFBhcnRpdGlvbmVkTWF4TlYoJXMsIHV2ZWM0IGJhbGxvdCk7CgAlcyAgICAgc3ViZ3JvdXBQYXJ0aXRpb25lZEFuZE5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRPck5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRYb3JOViglcywgdXZlYzQgYmFsbG90KTsKACVzICAgICBzdWJncm91cFBhcnRpdGlvbmVkSW5jbHVzaXZlQWRkTlYoJXMsIHV2ZWM0IGJhbGxvdCk7CgAlcyAgICAgc3ViZ3JvdXBQYXJ0aXRpb25lZEluY2x1c2l2ZU11bE5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRJbmNsdXNpdmVNaW5OViglcywgdXZlYzQgYmFsbG90KTsKACVzICAgICBzdWJncm91cFBhcnRpdGlvbmVkSW5jbHVzaXZlTWF4TlYoJXMsIHV2ZWM0IGJhbGxvdCk7CgAlcyAgICAgc3ViZ3JvdXBQYXJ0aXRpb25lZEluY2x1c2l2ZUFuZE5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRJbmNsdXNpdmVPck5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRJbmNsdXNpdmVYb3JOViglcywgdXZlYzQgYmFsbG90KTsKACVzICAgICBzdWJncm91cFBhcnRpdGlvbmVkRXhjbHVzaXZlQWRkTlYoJXMsIHV2ZWM0IGJhbGxvdCk7CgAlcyAgICAgc3ViZ3JvdXBQYXJ0aXRpb25lZEV4Y2x1c2l2ZU11bE5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRFeGNsdXNpdmVNaW5OViglcywgdXZlYzQgYmFsbG90KTsKACVzICAgICBzdWJncm91cFBhcnRpdGlvbmVkRXhjbHVzaXZlTWF4TlYoJXMsIHV2ZWM0IGJhbGxvdCk7CgAlcyAgICAgc3ViZ3JvdXBQYXJ0aXRpb25lZEV4Y2x1c2l2ZUFuZE5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRFeGNsdXNpdmVPck5WKCVzLCB1dmVjNCBiYWxsb3QpOwoAJXMgICAgIHN1Ymdyb3VwUGFydGl0aW9uZWRFeGNsdXNpdmVYb3JOViglcywgdXZlYzQgYmFsbG90KTsKAEHkrgkLvgFMAQAATQEAAE4BAABPAQAAUAEAAFEBAABSAQAAUwEAAFQBAABVAQAAVgEAAFcBAABYAQAAWQEAAFoBAABbAQAAXAEAAF0BAABeAQAAXwEAAGABAABhAQAAYgEAAGMBAABkAQAAZQEAAGYBAABnAQAAaAEAAGkBAABqAQAAawEAAGwBAABtAQAAbgEAAG8BAABwAQAAcQEAAHIBAABzAQAAdAEAAHUBAAB2AQAAdwEAAHgBAAB5AQAAegEAAHsBAEGssAkLxgFMAQAATQEAAHwBAABPAQAAUAEAAFEBAABSAQAAUwEAAFQBAABVAQAAVgEAAH0BAAB+AQAAWQEAAFoBAABbAQAAXAEAAF0BAABeAQAAXwEAAGABAABhAQAAYgEAAH8BAACAAQAAZQEAAGYBAACBAQAAggEAAGkBAABqAQAAawEAAGwBAABtAQAAbgEAAG8BAABwAQAAcQEAAHIBAABzAQAAdAEAAHUBAAB2AQAAdwEAAHgBAAB5AQAAgwEAAIQBAACFAQAAhgEAQfyxCQvaAUwBAABNAQAAhwEAAE8BAACIAQAAUQEAAIkBAABTAQAAVAEAAFUBAABWAQAAfQEAAFgBAABZAQAAWgEAAFsBAACKAQAAXQEAAIsBAABfAQAAYAEAAGEBAABiAQAAfwEAAGQBAABlAQAAZgEAAIwBAACNAQAAaQEAAGoBAABrAQAAbAEAAG0BAABuAQAAbwEAAHABAABxAQAAcgEAAHMBAAB0AQAAdQEAAHYBAAB3AQAAeAEAAHkBAACOAQAAjwEAAJABAACRAQAAkgEAAJMBAACUAQAAlQEAAJYBAEHgswkLckwBAABNAQAAlwEAAJgBAABQAQAAUQEAAFIBAABTAQAAVAEAAFUBAABWAQAAfQEAAFgBAABZAQAAmQEAAJoBAABcAQAAXQEAAF4BAABfAQAAYAEAAGEBAABiAQAAfwEAAGQBAABlAQAAmwEAAJwBAACdAQBB3LQJC3JMAQAATQEAAJ4BAACYAQAAUAEAAFEBAABSAQAAUwEAAFQBAABVAQAAVgEAAH0BAABYAQAAnwEAAFoBAACaAQAAXAEAAF0BAABeAQAAXwEAAGABAABhAQAAYgEAAH8BAABkAQAAoAEAAGYBAACcAQAAoQEAQdi1CQu+AUwBAABNAQAAogEAAE8BAABQAQAAowEAAFIBAABTAQAAVAEAAFUBAABWAQAAfQEAAFgBAABZAQAAWgEAAFsBAABcAQAApAEAAF4BAABfAQAAYAEAAGEBAABiAQAAfwEAAGQBAABlAQAAZgEAAKUBAACmAQAAaQEAAGoBAABrAQAAbAEAAG0BAABuAQAAbwEAAHABAABxAQAAcgEAAHMBAAB0AQAAdQEAAHYBAAB3AQAAeAEAAHkBAACnAQAAqAEAQaC3CQvKAUwBAABNAQAAqQEAAE8BAACIAQAAUQEAAFIBAABTAQAAqgEAAFUBAABWAQAAfQEAAFgBAABZAQAAWgEAAFsBAACKAQAAXQEAAF4BAABfAQAAqwEAAGEBAABiAQAAfwEAAGQBAABlAQAAZgEAAKwBAACtAQAAaQEAAGoBAABrAQAAbAEAAG0BAABuAQAAbwEAAHABAABxAQAAcgEAAHMBAAB0AQAAdQEAAHYBAAB3AQAAeAEAAHkBAACuAQAArwEAALABAACxAQAAsgEAQfS4CQvGAUwBAABNAQAAswEAAE8BAACIAQAAUQEAAFIBAAC0AQAAVAEAAFUBAABWAQAAfQEAAFgBAABZAQAAWgEAAFsBAACKAQAAXQEAAF4BAAC1AQAAYAEAAGEBAABiAQAAfwEAAGQBAABlAQAAZgEAAKwBAAC2AQAAaQEAAGoBAABrAQAAbAEAAG0BAABuAQAAbwEAAHABAABxAQAAcgEAAHMBAAB0AQAAdQEAAHYBAAB3AQAAeAEAAHkBAAC3AQAAuAEAALkBAAC6AQBBxLoJC8IBTAEAAE0BAAC7AQAATwEAAFABAABRAQAAUgEAAFMBAABUAQAAvAEAAFYBAAB9AQAAWAEAAFkBAABaAQAAWwEAAFwBAABdAQAAXgEAAF8BAABgAQAAvQEAAGIBAAB/AQAAZAEAAGUBAABmAQAArAEAAL4BAABpAQAAagEAAGsBAABsAQAAbQEAAG4BAABvAQAAcAEAAHEBAAByAQAAcwEAAHQBAAB1AQAAdgEAAHcBAAB4AQAAeQEAAL8BAADAAQAAwQEAQZC8CQt6TAEAAE0BAADCAQAAmAEAAFABAABRAQAAUgEAAFMBAABUAQAAVQEAAMMBAAB9AQAAWAEAAFkBAABaAQAAmgEAAFwBAABdAQAAXgEAAF8BAABgAQAAYQEAAMQBAAB/AQAAZAEAAGUBAABmAQAAnAEAAMUBAADGAQAAxwEAQZS9CQu2AUwBAABNAQAAGwEAAE8BAABQAQAAUQEAAFIBAABTAQAAVAEAAFUBAABWAQAAfQEAAFgBAABZAQAAWgEAAFsBAABcAQAAXQEAAF4BAABfAQAAYAEAAGEBAABiAQAAfwEAAGQBAABlAQAAZgEAAKwBAADIAQAAaQEAAGoBAABrAQAAbAEAAG0BAABuAQAAbwEAAHABAABxAQAAcgEAAHMBAAB0AQAAdQEAAHYBAAB3AQAAeAEAAHkBAEHUvgkLgQNMAQAATQEAABsBAABPAQAAiAEAAFEBAABSAQAAUwEAAFQBAABVAQAAVgEAAH0BAABYAQAAWQEAAFoBAABbAQAAigEAAF0BAABeAQAAXwEAAGABAABhAQAAYgEAAH8BAABkAQAAZQEAAGYBAACsAQAAyQEAAGkBAABqAQAAawEAAGwBAABtAQAAbgEAAG8BAABwAQAAcQEAAHIBAABzAQAAdAEAAHUBAAB2AQAAdwEAAHgBAAB5AQAA0wEAANUBAADWAQAA1wEAAMoBAADzAQAA9AEAAPUBAADLAQAA9gEAAPcBAAD4AQAA0gEAAOQBAADlAQAA5gEAANQBAADhAQAA4gEAAOMBAADMAQAA5wEAAOgBAADpAQAAzQEAAOoBAADrAQAA7AEAAM4BAADtAQAA7gEAAO8BAADPAQAA8AEAAPEBAADyAQAA0AEAAPkBAAD6AQAA+wEAANEBAAD8AQAA/QEAAP4BAAAFAAAAFAAAAAcAAAAUAAAACQAAABQAAAALAEHgwQkLFQEAAAABAAAAAgAAAAIAAAADAAAAAwBBgMIJCyrKAQAAywEAAMwBAADNAQAAzgEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAQbTCCQu6AcoBAADVAQAA1gEAAM0BAADOAQAAzwEAANABAADXAQAA0gEAANMBAADUAQAAeGECAI5hAgCkYQIAuGECAMphAgDdYQIAc2hpZnQtc2FtcGxlci1iaW5kaW5nAHNoaWZ0LXRleHR1cmUtYmluZGluZwBzaGlmdC1pbWFnZS1iaW5kaW5nAHNoaWZ0LVVCTy1iaW5kaW5nAHNoaWZ0LXNzYm8tYmluZGluZwBzaGlmdC11YXYtYmluZGluZwBB+MMJC64jTAEAAE0BAAAbAQAAmAEAAFABAABRAQAAUgEAAFMBAABUAQAAVQEAAFYBAAB9AQAAWAEAAFkBAABaAQAAmgEAAFwBAABdAQAAXgEAAF8BAABgAQAAYQEAAGIBAAB/AQAAZAEAAGUBAABmAQAAnAEAANgBAABpbGxlZ2FsIHVzZSBvZiBlc2NhcGUgY2hhcmFjdGVyAFwAbm90IHN1cHBvcnRlZAB1bmV4cGVjdGVkIHRva2VuAAAAAOLkAwDL5QMAE+QDAAAAAAA72wMAJNwDABzlAwAF5gMAMuUDABvmAwA75AMADdsDAHRleHR1cmUtcmVjdGFuZ2xlIHNhbXBsZXIga2V5d29yZAAAAJnkAwCC5QMAVW5rbm93biBnbHNsYW5nIGtleXdvcmQAOiVkAHVzaW5nIGZ1dHVyZSBrZXl3b3JkAHVzaW5nIGZ1dHVyZSB0eXBlIGtleXdvcmQAdXNpbmcgZnV0dXJlIG5vbi1zcXVhcmUgbWF0cml4IHR5cGUga2V5d29yZAB1c2luZyBFUyBwcmVjaXNpb24gcXVhbGlmaWVyIGtleXdvcmQAZnV0dXJlIHJlc2VydmVkIHdvcmQgaW4gRVMgMzAwIGFuZCBrZXl3b3JkIGluIEdMU0wAdXNpbmcgZnV0dXJlIHJlc2VydmVkIGtleXdvcmQAUmVzZXJ2ZWQgd29yZC4AcmVzb3VyY2UAYnJlYWsAY29udGludWUAZG8AZm9yAHdoaWxlAGJ2ZWMyAGJ2ZWMzAGJ2ZWM0AHZlYzIAdmVjMwB2ZWM0AGl2ZWMyAGl2ZWMzAGl2ZWM0AG1hdDIAbWF0MwBtYXQ0AHN1cGVycABtYXQyeDIAbWF0MngzAG1hdDJ4NABtYXQzeDIAbWF0M3gzAG1hdDN4NABtYXQ0eDIAbWF0NHgzAG1hdDR4NAB1dmVjMgB1dmVjMwB1dmVjNAByZXN0cmljdABkbWF0MgBkbWF0MwBkbWF0NABkbWF0MngyAGRtYXQyeDMAZG1hdDJ4NABkbWF0M3gyAGRtYXQzeDMAZG1hdDN4NABkbWF0NHgyAGRtYXQ0eDMAZG1hdDR4NABpbWFnZTFEAGlpbWFnZTFEAHVpbWFnZTFEAGltYWdlMkQAaWltYWdlMkQAdWltYWdlMkQAaW1hZ2UzRABpaW1hZ2UzRAB1aW1hZ2UzRABpbWFnZTJEUmVjdABpaW1hZ2UyRFJlY3QAdWltYWdlMkRSZWN0AGltYWdlQ3ViZQBpaW1hZ2VDdWJlAHVpbWFnZUN1YmUAaW1hZ2VCdWZmZXIAaWltYWdlQnVmZmVyAHVpbWFnZUJ1ZmZlcgBpbWFnZTFEQXJyYXkAaWltYWdlMURBcnJheQB1aW1hZ2UxREFycmF5AGltYWdlMkRBcnJheQBpaW1hZ2UyREFycmF5AHVpbWFnZTJEQXJyYXkAaW1hZ2VDdWJlQXJyYXkAaWltYWdlQ3ViZUFycmF5AHVpbWFnZUN1YmVBcnJheQBpbWFnZTJETVMAaWltYWdlMkRNUwB1aW1hZ2UyRE1TAGltYWdlMkRNU0FycmF5AGlpbWFnZTJETVNBcnJheQB1aW1hZ2UyRE1TQXJyYXkAZHZlYzIAZHZlYzMAZHZlYzQAaTY0dmVjMgBpNjR2ZWMzAGk2NHZlYzQAdTY0dmVjMgB1NjR2ZWMzAHU2NHZlYzQAaTh2ZWMyAGk4dmVjMwBpOHZlYzQAdTh2ZWMyAHU4dmVjMwB1OHZlYzQAaTE2dmVjMgBpMTZ2ZWMzAGkxNnZlYzQAdTE2dmVjMgB1MTZ2ZWMzAHUxNnZlYzQAaW50MzJfdABpMzJ2ZWMyAGkzMnZlYzMAaTMydmVjNAB1aW50MzJfdAB1MzJ2ZWMyAHUzMnZlYzMAdTMydmVjNABmMTZ2ZWMyAGYxNnZlYzMAZjE2dmVjNABmMTZtYXQyAGYxNm1hdDMAZjE2bWF0NABmMTZtYXQyeDIAZjE2bWF0MngzAGYxNm1hdDJ4NABmMTZtYXQzeDIAZjE2bWF0M3gzAGYxNm1hdDN4NABmMTZtYXQ0eDIAZjE2bWF0NHgzAGYxNm1hdDR4NABmMzJ2ZWMyAGYzMnZlYzMAZjMydmVjNABmMzJtYXQyAGYzMm1hdDMAZjMybWF0NABmMzJtYXQyeDIAZjMybWF0MngzAGYzMm1hdDJ4NABmMzJtYXQzeDIAZjMybWF0M3gzAGYzMm1hdDN4NABmMzJtYXQ0eDIAZjMybWF0NHgzAGYzMm1hdDR4NABmNjR2ZWMyAGY2NHZlYzMAZjY0dmVjNABmNjRtYXQyAGY2NG1hdDMAZjY0bWF0NABmNjRtYXQyeDIAZjY0bWF0MngzAGY2NG1hdDJ4NABmNjRtYXQzeDIAZjY0bWF0M3gzAGY2NG1hdDN4NABmNjRtYXQ0eDIAZjY0bWF0NHgzAGY2NG1hdDR4NABzYW1wbGVyMkQAc2FtcGxlckN1YmUAc2FtcGxlckN1YmVTaGFkb3cAc2FtcGxlcjJEQXJyYXkAc2FtcGxlcjJEQXJyYXlTaGFkb3cAaXNhbXBsZXIyRABpc2FtcGxlcjNEAGlzYW1wbGVyQ3ViZQBpc2FtcGxlcjJEQXJyYXkAdXNhbXBsZXIyRAB1c2FtcGxlcjNEAHVzYW1wbGVyQ3ViZQB1c2FtcGxlcjJEQXJyYXkAc2FtcGxlcjNEAHNhbXBsZXIyRFNoYWRvdwB0ZXh0dXJlMkQAdGV4dHVyZUN1YmUAdGV4dHVyZTJEQXJyYXkAaXRleHR1cmUyRABpdGV4dHVyZTNEAGl0ZXh0dXJlQ3ViZQBpdGV4dHVyZTJEQXJyYXkAdXRleHR1cmUyRAB1dGV4dHVyZTNEAHV0ZXh0dXJlQ3ViZQB1dGV4dHVyZTJEQXJyYXkAdGV4dHVyZTNEAHNhbXBsZXJTaGFkb3cAdGV4dHVyZUN1YmVBcnJheQBpdGV4dHVyZUN1YmVBcnJheQB1dGV4dHVyZUN1YmVBcnJheQBzYW1wbGVyQ3ViZUFycmF5AHNhbXBsZXJDdWJlQXJyYXlTaGFkb3cAaXNhbXBsZXJDdWJlQXJyYXkAdXNhbXBsZXJDdWJlQXJyYXkAc2FtcGxlcjFEQXJyYXlTaGFkb3cAaXNhbXBsZXIxREFycmF5AHVzYW1wbGVyMUQAaXNhbXBsZXIxRAB1c2FtcGxlcjFEQXJyYXkAc2FtcGxlckJ1ZmZlcgBpc2FtcGxlcjJEUmVjdAB1c2FtcGxlcjJEUmVjdABpc2FtcGxlckJ1ZmZlcgB1c2FtcGxlckJ1ZmZlcgBzYW1wbGVyMkRNUwBpc2FtcGxlcjJETVMAdXNhbXBsZXIyRE1TAHNhbXBsZXIyRE1TQXJyYXkAaXNhbXBsZXIyRE1TQXJyYXkAdXNhbXBsZXIyRE1TQXJyYXkAc2FtcGxlcjFEAHNhbXBsZXIxRFNoYWRvdwBzYW1wbGVyMkRSZWN0AHNhbXBsZXIyRFJlY3RTaGFkb3cAc2FtcGxlcjFEQXJyYXkAaXRleHR1cmUxREFycmF5AHV0ZXh0dXJlMUQAaXRleHR1cmUxRAB1dGV4dHVyZTFEQXJyYXkAdGV4dHVyZUJ1ZmZlcgBpdGV4dHVyZTJEUmVjdAB1dGV4dHVyZTJEUmVjdABpdGV4dHVyZUJ1ZmZlcgB1dGV4dHVyZUJ1ZmZlcgB0ZXh0dXJlMkRNUwBpdGV4dHVyZTJETVMAdXRleHR1cmUyRE1TAHRleHR1cmUyRE1TQXJyYXkAaXRleHR1cmUyRE1TQXJyYXkAdXRleHR1cmUyRE1TQXJyYXkAdGV4dHVyZTFEAHRleHR1cmUyRFJlY3QAdGV4dHVyZTFEQXJyYXkAc3VicGFzc0lucHV0AHN1YnBhc3NJbnB1dE1TAGlzdWJwYXNzSW5wdXQAaXN1YnBhc3NJbnB1dE1TAHVzdWJwYXNzSW5wdXQAdXN1YnBhc3NJbnB1dE1TAGYxNnNhbXBsZXIxRABmMTZzYW1wbGVyMkQAZjE2c2FtcGxlcjNEAGYxNnNhbXBsZXIyRFJlY3QAZjE2c2FtcGxlckN1YmUAZjE2c2FtcGxlcjFEQXJyYXkAZjE2c2FtcGxlcjJEQXJyYXkAZjE2c2FtcGxlckN1YmVBcnJheQBmMTZzYW1wbGVyQnVmZmVyAGYxNnNhbXBsZXIyRE1TAGYxNnNhbXBsZXIyRE1TQXJyYXkAZjE2c2FtcGxlcjFEU2hhZG93AGYxNnNhbXBsZXIyRFNoYWRvdwBmMTZzYW1wbGVyMkRSZWN0U2hhZG93AGYxNnNhbXBsZXJDdWJlU2hhZG93AGYxNnNhbXBsZXIxREFycmF5U2hhZG93AGYxNnNhbXBsZXIyREFycmF5U2hhZG93AGYxNnNhbXBsZXJDdWJlQXJyYXlTaGFkb3cAZjE2aW1hZ2UxRABmMTZpbWFnZTJEAGYxNmltYWdlM0QAZjE2aW1hZ2UyRFJlY3QAZjE2aW1hZ2VDdWJlAGYxNmltYWdlMURBcnJheQBmMTZpbWFnZTJEQXJyYXkAZjE2aW1hZ2VDdWJlQXJyYXkAZjE2aW1hZ2VCdWZmZXIAZjE2aW1hZ2UyRE1TAGYxNmltYWdlMkRNU0FycmF5AGYxNnRleHR1cmUxRABmMTZ0ZXh0dXJlMkQAZjE2dGV4dHVyZTNEAGYxNnRleHR1cmUyRFJlY3QAZjE2dGV4dHVyZUN1YmUAZjE2dGV4dHVyZTFEQXJyYXkAZjE2dGV4dHVyZTJEQXJyYXkAZjE2dGV4dHVyZUN1YmVBcnJheQBmMTZ0ZXh0dXJlQnVmZmVyAGYxNnRleHR1cmUyRE1TAGYxNnRleHR1cmUyRE1TQXJyYXkAZjE2c3VicGFzc0lucHV0AGYxNnN1YnBhc3NJbnB1dE1TAGNvbW1vbgBwYXJ0aXRpb24AYWN0aXZlAGFzbQBjbGFzcwB1bmlvbgBlbnVtAHR5cGVkZWYAdGVtcGxhdGUAdGhpcwBnb3RvAGlubGluZQBub2lubGluZQBwdWJsaWMAc3RhdGljAGV4dGVybgBleHRlcm5hbABpbnRlcmZhY2UAbG9uZwBzaG9ydABoYWxmAGZpeGVkAHVuc2lnbmVkAGlucHV0AG91dHB1dABodmVjMgBodmVjMwBodmVjNABmdmVjMgBmdmVjMwBmdmVjNABzYW1wbGVyM0RSZWN0AGZpbHRlcgBzaXplb2YAY2FzdABuYW1lc3BhY2UAJyA6IABjYW4ndCBtb2RpZnkgYSByZWFkb25seSBidWZmZXIAY2FuJ3QgbW9kaWZ5IGEgc2hhZGVycmVjb3JkbnYgcXVhbGlmaWVkIGJ1ZmZlcgBjYW5ub3QgbW9kaWZ5IGhpdEF0dHJpYnV0ZU5WIGluIHRoaXMgc3RhZ2UAY2FuJ3QgbW9kaWZ5IGEgY29uc3QAY2FuJ3QgbW9kaWZ5IGEgdW5pZm9ybQBjYW4ndCBtb2RpZnkgdm9pZABjYW4ndCBtb2RpZnkgYW4gYXRvbWljX3VpbnQAY2FuJ3QgbW9kaWZ5IGFjY2VsZXJhdGlvblN0cnVjdHVyZU5WAGNhbid0IG1vZGlmeSBhIHNhbXBsZXIAY2FuJ3QgcmVhZCBmcm9tIHdyaXRlb25seSBvYmplY3Q6IABpbmRleCBvdXQgb2YgcmFuZ2UgJyVkJwBhcnJheSBpbmRleCBvdXQgb2YgcmFuZ2UgJyVkJwB2ZWN0b3IgaW5kZXggb3V0IG9mIHJhbmdlICclZCcAbWF0cml4IGluZGV4IG91dCBvZiByYW5nZSAnJWQnAHZlY3RvciBzd2l6emxlIHRvbyBsb25nAAAEAAAAdW5rbm93biBzd2l6emxlIHNlbGVjdGlvbgB2ZWN0b3Igc3dpenpsZSBzZWxlY3Rpb24gb3V0IG9mIHJhbmdlAHZlY3RvciBzd2l6emxlIHNlbGVjdG9ycyBub3QgZnJvbSB0aGUgc2FtZSBzZXQAQbDnCQuWAtkBAADaAQAA2wEAANwBAADdAQAA3gEAAN8BAADgAQAA4QEAAOIBAADjAQAA5AEAAOUBAADmAQAA5wEAAOgBAADpAQAA6gEAAOsBAADsAQAA7QEAAO4BAADvAQAA8AEAAPEBAADyAQAA8wEAAPQBAAD1AQAA9gEAAPcBAAD4AQAA+QEAAPoBAAD7AQAA/AEAAP0BAAD+AQAA/wEAAAACAAABAgAAAgIAAAMCAAAEAgAAGwEAAAUCAAAGAgAABwIAAAgCAAAJAgAAGwEAABsBAAAbAQAAGwEAABsBAAAKAgAACwIAAAwCAAANAgAADgIAAA8CAAAQAgAAEQIAABICAAATAgAAFAIAABUCAAAWAgAAFwIAABgCAEHQ6QkLzAIZAgAAGgIAANsBAADcAQAA3QEAAN4BAADfAQAA4AEAAOEBAADiAQAA4wEAAOQBAADlAQAA5gEAAOcBAADoAQAA6QEAAOoBAADrAQAA7AEAAO0BAADuAQAA7wEAAPABAADxAQAA8gEAAPMBAAD0AQAA9QEAAPYBAAD3AQAA+AEAAPkBAAD6AQAA+wEAAPwBAAD9AQAA/gEAAP8BAAAAAgAAAQIAAAICAAADAgAABAIAABsCAAAFAgAABgIAAAcCAAAIAgAACQIAABwCAAAdAgAAHgIAAB8CAAAgAgAACgIAAAsCAAAMAgAADQIAACECAAAiAgAAEAIAABECAAASAgAAEwIAABQCAAAVAgAAIwIAABcCAAAkAgAAU291cmNlIGVudHJ5IHBvaW50IG11c3QgYmUgIm1haW4iAHVzZS1zdG9yYWdlLWJ1ZmZlcgBBqOwJC7UcJQIAACYCAABn5AMAUOUDAGdlb21ldHJ5IHNoYWRlcnMAAAAA4uQDAMvlAwB0ZXNzZWxsYXRpb24gc2hhZGVycwAAAAC52wMAo9sDAGNvbXB1dGUgc2hhZGVycwA84wMAdGFzayBzaGFkZXJzAG1lc2ggc2hhZGVycwBjYW4ndCByZWFkIGZyb20gZXhwbGljaXRseS1pbnRlcnBvbGF0ZWQgb2JqZWN0OiAAdGVzc2VsbGF0aW9uLWNvbnRyb2wgcGVyLXZlcnRleCBvdXRwdXQgbC12YWx1ZSBtdXN0IGJlIGluZGV4ZWQgd2l0aCBnbF9JbnZvY2F0aW9uSUQAIGwtdmFsdWUgb2Ygc3dpenpsZSBjYW5ub3QgaGF2ZSBkdXBsaWNhdGUgY29tcG9uZW50cwBjYW4ndCBtb2RpZnkgZ2xfRnJhZ0RlcHRoIGlmIHVzaW5nIGVhcmx5X2ZyYWdtZW50X3Rlc3RzACBsLXZhbHVlIHJlcXVpcmVkAGNhbid0IG1vZGlmeSBnbF9JbnN0YW5jZUlEAGNhbid0IG1vZGlmeSBnbF9WZXJ0ZXhJRABjYW4ndCBtb2RpZnkgZ2xfRnJvbnRGYWNlAGNhbid0IG1vZGlmeSBnbF9GcmFnQ29vcmQAY2FuJ3QgbW9kaWZ5IGdsX1BvaW50Q29vcmQAY2FuJ3QgbW9kaWZ5IHNoYWRlciBpbnB1dAAiJXMiICglcykAKCVzKQBvcHRpbWl6ZQBvcHRpbWl6ZSBwcmFnbWEgc3ludGF4IGlzIGluY29ycmVjdAAiKCIgZXhwZWN0ZWQgYWZ0ZXIgJ29wdGltaXplJyBrZXl3b3JkAG9uAG9mZgAib24iIG9yICJvZmYiIGV4cGVjdGVkIGFmdGVyICcoJyBmb3IgJ29wdGltaXplJyBwcmFnbWEAIikiIGV4cGVjdGVkIHRvIGVuZCAnb3B0aW1pemUnIHByYWdtYQBkZWJ1ZwBkZWJ1ZyBwcmFnbWEgc3ludGF4IGlzIGluY29ycmVjdAAiKCIgZXhwZWN0ZWQgYWZ0ZXIgJ2RlYnVnJyBrZXl3b3JkACJvbiIgb3IgIm9mZiIgZXhwZWN0ZWQgYWZ0ZXIgJygnIGZvciAnZGVidWcnIHByYWdtYQAiKSIgZXhwZWN0ZWQgdG8gZW5kICdkZWJ1ZycgcHJhZ21hAHVzZV9zdG9yYWdlX2J1ZmZlcgBleHRyYSB0b2tlbnMAdXNlX3Z1bGthbl9tZW1vcnlfbW9kZWwAdXNlX3ZhcmlhYmxlX3BvaW50ZXJzAHJlcXVpcmVzIFNQSVItViAxLjMAI3ByYWdtYSB1c2VfdmFyaWFibGVfcG9pbnRlcnMAb25jZQBub3QgaW1wbGVtZW50ZWQAI3ByYWdtYSBvbmNlAGdsc2xhbmdfYmluYXJ5X2RvdWJsZV9vdXRwdXQAdXNlLXZhcmlhYmxlLXBvaW50ZXJzAHVzZS12dWxrYW4tbWVtb3J5LW1vZGVsAHVzZWQgYXQgZW5kIG9mIGNvbW1lbnQ7IHRoZSBmb2xsb3dpbmcgbGluZSBpcyBzdGlsbCBwYXJ0IG9mIHRoZSBjb21tZW50AGxpbmUgY29udGludWF0aW9uAHVzZWQgYXQgZW5kIG9mIGNvbW1lbnQsIGJ1dCB0aGlzIHZlcnNpb24gZG9lcyBub3QgcHJvdmlkZSBsaW5lIGNvbnRpbnVhdGlvbgBub3QgYWxsb3dlZCBpbiB0aGlzIHZlcnNpb24AR0xfAG5hbWVzIGJlZ2lubmluZyB3aXRoICJHTF8iIGNhbid0IGJlICh1bilkZWZpbmVkOgAiZGVmaW5lZCIgY2FuJ3QgYmUgKHVuKWRlZmluZWQ6AHByZWRlZmluZWQgbmFtZXMgY2FuJ3QgYmUgKHVuKWRlZmluZWQ6AG5hbWVzIGNvbnRhaW5pbmcgY29uc2VjdXRpdmUgdW5kZXJzY29yZXMgYXJlIHJlc2VydmVkLCBhbmQgYW4gZXJyb3IgaWYgdmVyc2lvbiA8PSAzMDA6AG5hbWVzIGNvbnRhaW5pbmcgY29uc2VjdXRpdmUgdW5kZXJzY29yZXMgYXJlIHJlc2VydmVkOgBjb21waWxhdGlvbiB0ZXJtaW5hdGVkAG1lbWJlciBvZiBuYW1lbGVzcyBibG9jayB3YXMgbm90IHJlZGVjbGFyZWQAY2Fubm90IGJlIHVzZWQgKG1heWJlIGFuIGluc3RhbmNlIG5hbWUgaXMgbmVlZGVkKQB2YXJpYWJsZSBuYW1lIGV4cGVjdGVkACBsZWZ0IG9mICdbJyBpcyBub3Qgb2YgdHlwZSBhcnJheSwgbWF0cml4LCBvciB2ZWN0b3IgAFsAZG9lcyBub3Qgb3BlcmF0ZSBvbiB0eXBlcyBjb250YWluaW5nIGZsb2F0MTYAZG9lcyBub3Qgb3BlcmF0ZSBvbiB0eXBlcyBjb250YWluaW5nICh1KWludDE2AGRvZXMgbm90IG9wZXJhdGUgb24gdHlwZXMgY29udGFpbmluZyAodSlpbnQ4AABe4AMAYnVmZmVyIHJlZmVyZW5jZSBpbmRleGluZwBhcnJheSBtdXN0IGJlIHNpemVkIGJ5IGEgcmVkZWNsYXJhdGlvbiBvciBsYXlvdXQgcXVhbGlmaWVyIGJlZm9yZSBiZWluZyBpbmRleGVkIHdpdGggYSB2YXJpYWJsZQB2YXJpYWJsZSBpbmRleGluZyBidWZmZXIgYmxvY2sgYXJyYXkAAJnkAwCC5QMAdmFyaWFibGUgaW5kZXhpbmcgdW5pZm9ybSBibG9jayBhcnJheQB2YXJpYWJsZSBpbmRleGluZyBmcmFnbWVudCBzaGFkZXIgb3V0cHV0IGFycmF5AHZhcmlhYmxlIGluZGV4aW5nIHNhbXBsZXIgYXJyYXkAAAAAx98DAHZhcmlhYmxlIGluZGV4AGFycmF5IG11c3QgYmUgcmVkZWNsYXJlZCB3aXRoIGEgc2l6ZSBiZWZvcmUgYmVpbmcgaW5kZXhlZCB3aXRoIGEgdmFyaWFibGUAdW5rbm93bgB2ZXJ0aWNlcwBtYXhfcHJpbWl0aXZlcyoAbWF4X3ByaW1pdGl2ZXMAbWF4X3ZlcnRpY2VzAAAAlH8CAJt/AgChfwIAsX8CALx/AgDGfwIA2n8CAOl/AgDvfwIAcG9pbnRzAGxpbmVzAGxpbmVzX2FkamFjZW5jeQBsaW5lX3N0cmlwAHRyaWFuZ2xlcwB0cmlhbmdsZXNfYWRqYWNlbmN5AHRyaWFuZ2xlX3N0cmlwAHF1YWRzAGlzb2xpbmVzAAEAAAACAAAABAAAAAAAAAADAAAABgAAAGdsX1ZlcnRleElEAGdsX0luc3RhbmNlSUQAKERpZCB5b3UgbWVhbiBnbF9JbnN0YW5jZUluZGV4PykAKERpZCB5b3UgbWVhbiBnbF9WZXJ0ZXhJbmRleD8pAHVuZGVjbGFyZWQgaWRlbnRpZmllcgB0ZXNzZWxsYXRpb24gaW5wdXQgYXJyYXkgc2l6ZSBtdXN0IGJlIGdsX01heFBhdGNoVmVydGljZXMgb3IgaW1wbGljaXRseSBzaXplZAB0eXBlIG11c3QgYmUgYW4gYXJyYXk6AGluY29uc2lzdGVudCBpbnB1dCBwcmltaXRpdmUgZm9yIGFycmF5IHNpemUgb2YAaW5jb25zaXN0ZW50IG91dHB1dCBudW1iZXIgb2YgdmVydGljZXMgZm9yIGFycmF5IHNpemUgb2YAIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gMyBmb3IgcGVydmVydGV4TlYAaW5jb25zaXN0ZW50IG91dHB1dCBhcnJheSBzaXplIG9mACB3cm9uZyBvcGVyYW5kIHR5cGVzOgBubyBvcGVyYXRpb24gJyVzJyBleGlzdHMgdGhhdCB0YWtlcyBhIGxlZnQtaGFuZCBvcGVyYW5kIG9mIHR5cGUgJyVzJyBhbmQgYSByaWdodCBvcGVyYW5kIG9mIHR5cGUgJyVzJyAob3IgdGhlcmUgaXMgbm8gYWNjZXB0YWJsZSBjb252ZXJzaW9uKQAgd3Jvbmcgb3BlcmFuZCB0eXBlAG5vIG9wZXJhdGlvbiAnJXMnIGV4aXN0cyB0aGF0IHRha2VzIGFuIG9wZXJhbmQgb2YgdHlwZSAlcyAob3IgdGhlcmUgaXMgbm8gYWNjZXB0YWJsZSBjb252ZXJzaW9uKQAubGVuZ3RoAC5sZW5ndGgoKSBvbiB2ZWN0b3JzIGFuZCBtYXRyaWNlcwBkb2VzIG5vdCBvcGVyYXRlIG9uIHRoaXMgdHlwZToAY2Fubm90IGFwcGx5IHRvIGFuIGFycmF5OgAuAGNhbm5vdCBhcHBseSB0byBhIGNvb3BlcmF0aXZlIG1hdHJpeCB0eXBlOgBzY2FsYXIgc3dpenpsZQBjYW4ndCBzd2l6emxlIHR5cGVzIGNvbnRhaW5pbmcgZmxvYXQxNgBjYW4ndCBzd2l6emxlIHR5cGVzIGNvbnRhaW5pbmcgKHUpaW50MTYAY2FuJ3Qgc3dpenpsZSB0eXBlcyBjb250YWluaW5nICh1KWludDgAbm8gc3VjaCBmaWVsZCBpbiBzdHJ1Y3R1cmUAZG9lcyBub3QgYXBwbHkgdG8gdGhpcyB0eXBlOgBjb25zdHJ1Y3RvcgAAAHfgAwByZWZlcmVuY2UgY29udmVyc2lvbiB0byB1dmVjMgB1dmVjMiBjb252ZXJzaW9uIHRvIHJlZmVyZW5jZQCBAAAAAAAAAHcAAAAmAAAALgBB7IgKCxVWAAAAhQAAAAAAAAB7AAAAKgAAADEAQYyJCgsZUgAAAFQAAAB/AAAAAAAAAHUAAAAAAAAALABBsIkKCxVNAAAAVAAAAIMAAAAAAAAAeQAAACgAQdSJCgsRUAAAAFgAAAB9AAAANAAAADcAQfCJCgsJXAAAAF8AAACHAEGEigoLBTMAAAA2AEGUigoL0yBbAAAAXgAAAHVuc3VwcG9ydGVkIGNvbnN0cnVjdGlvbgBjYW4ndCBjb252ZXJ0AGNhbm5vdCBjb252ZXJ0IHBhcmFtZXRlciAlZCBmcm9tICclcycgdG8gJyVzJwBsb2NhbCBmdW5jdGlvbiBkZWNsYXJhdGlvbgByZWRlZmluaXRpb24gb2YgYnVpbHQtaW4gZnVuY3Rpb24AbXVsdGlwbGUgcHJvdG90eXBlcyBmb3Igc2FtZSBmdW5jdGlvbgBvdmVybG9hZGVkIGZ1bmN0aW9ucyBtdXN0IGhhdmUgdGhlIHNhbWUgcmV0dXJuIHR5cGUAb3ZlcmxvYWRlZCBmdW5jdGlvbnMgbXVzdCBoYXZlIHRoZSBzYW1lIHBhcmFtZXRlciBzdG9yYWdlIHF1YWxpZmllcnMgZm9yIGFyZ3VtZW50AG92ZXJsb2FkZWQgZnVuY3Rpb25zIG11c3QgaGF2ZSB0aGUgc2FtZSBwYXJhbWV0ZXIgcHJlY2lzaW9uIHF1YWxpZmllcnMgZm9yIGFyZ3VtZW50AGFycmF5IGluIGZ1bmN0aW9uIHJldHVybiB0eXBlAGZ1bmN0aW9uIG5hbWUgaXMgcmVkZWNsYXJhdGlvbiBvZiBleGlzdGluZyBuYW1lAGNhbid0IGZpbmQgZnVuY3Rpb24AZnVuY3Rpb24gYWxyZWFkeSBoYXMgYSBib2R5AGZ1bmN0aW9uIGNhbm5vdCB0YWtlIGFueSBwYXJhbWV0ZXIocykAZW50cnkgcG9pbnQgY2Fubm90IHJldHVybiBhIHZhbHVlAGNhbm5vdCBjb25zdHJ1Y3Qgd2l0aCB0aGVzZSBhcmd1bWVudHMAYnVpbHQtaW4gZnVuY3Rpb24AZmxvYXQxNiB0eXBlcyBjYW4gb25seSBiZSBpbiB1bmlmb3JtIGJsb2NrIG9yIGJ1ZmZlciBzdG9yYWdlACh1KWludDE2IHR5cGVzIGNhbiBvbmx5IGJlIGluIHVuaWZvcm0gYmxvY2sgb3IgYnVmZmVyIHN0b3JhZ2UAKHUpaW50OCB0eXBlcyBjYW4gb25seSBiZSBpbiB1bmlmb3JtIGJsb2NrIG9yIGJ1ZmZlciBzdG9yYWdlAE5vbi1MLXZhbHVlIGNhbm5vdCBiZSBwYXNzZWQgZm9yICdvdXQnIG9yICdpbm91dCcgcGFyYW1ldGVycy4AYXJndW1lbnQgY2Fubm90IGRyb3AgbWVtb3J5IHF1YWxpZmllciB3aGVuIHBhc3NlZCB0byBmb3JtYWwgcGFyYW1ldGVyAHZvbGF0aWxlAGNvaGVyZW50AHJlYWRvbmx5AHdyaXRlb25seQBpbWFnZSBmb3JtYXRzIG11c3QgbWF0Y2gAZm9ybWF0AGNhbGxpbmcgdXNlciBmdW5jdGlvbiBmcm9tIGdsb2JhbCBzY29wZQBtYWluKAB0ZW1wUmV0dXJuAHRlbXBBcmcAY2FsbCBhcmd1bWVudABzYW1wbGVyIGNvbnN0cnVjdG9yIG11c3QgYXBwZWFyIGF0IHBvaW50IG9mIHVzZQAoLi4uKQBub24tY29uc3RhbnQgb2Zmc2V0IGFyZ3VtZW50AG11c3QgYmUgYSBjb21waWxlLXRpbWUgY29uc3RhbnQ6AG9mZnNldHMgYXJndW1lbnQAbXVzdCBiZSAwLCAxLCAyLCBvciAzOgBjb21wb25lbnQgYXJndW1lbnQAT2Zmc2V0AHRleGVsRmV0Y2hPZmZzZXQAYXJndW1lbnQgbXVzdCBiZSBjb21waWxlLXRpbWUgY29uc3RhbnQAdGV4ZWwgb2Zmc2V0AHZhbHVlIGlzIG91dCBvZiByYW5nZToAW2dsX01pblByb2dyYW1UZXhlbE9mZnNldCwgZ2xfTWF4UHJvZ3JhbVRleGVsT2Zmc2V0XQBpbWFnZVNhbXBsZXMAdGV4dHVyZVNhbXBsZXMgYW5kIGltYWdlU2FtcGxlcwBpbWFnZUF0b21pYwBvbmx5IHN1cHBvcnRlZCBvbiBpbWFnZSB3aXRoIGZvcm1hdCByMzJpIG9yIHIzMnVpAG9ubHkgc3VwcG9ydGVkIG9uIGludGVnZXIgaW1hZ2VzAG9ubHkgc3VwcG9ydGVkIG9uIGltYWdlIHdpdGggZm9ybWF0IHIzMmYASW50ZXJuYWwgRXJyb3IAYnVpbHQgaW4gdW5hcnkgb3BlcmF0b3IgZnVuY3Rpb24uICBUeXBlOiAlcwB3aXRoIGJpYXMgYXJndW1lbnQAAACFXgQAQt0DAG9mZnNldABjb21wb25lbnRzIG11c3QgYmUgaW4gdGhlIHJhbmdlIFswLCAzXQBtYXNrAGNvbXBvbmVudHMgbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAsIDMxXQBwYXlsb2FkIG51bWJlcgBjYWxsYWJsZSBkYXRhIG51bWJlcgAAAt8DAAAAAAAg4gMAIN8DAGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZXJwb2xhbnQsIG9yIGludGVycG9sYW50LWFycmF5IGVsZW1lbnQAYXJndW1lbnQgbXVzdCBiZSBxdWFsaWZpZWQgYXMgX19leHBsaWNpdEludGVycEFNRCBpbgBpbnRlcnBvbGFudAB2ZXJ0ZXggaW5kZXgAbXVzdCBiZSBpbiB0aGUgcmFuZ2UgWzAsIDJdAGNsdXN0ZXIgc2l6ZQBhcmd1bWVudCBtdXN0IGJlIGF0IGxlYXN0IDEAYXJndW1lbnQgbXVzdCBiZSBhIHBvd2VyIG9mIDIAaWQA498DAHN1Ymdyb3VwIG9wAInnAwC05wMA4OcDAAzoAwBnbF9TZW1hbnRpY3NBY3F1aXJlIG11c3Qgbm90IGJlIHVzZWQgd2l0aCAoaW1hZ2UpIGF0b21pYyBzdG9yZQBnbF9TZW1hbnRpY3NSZWxlYXNlIG11c3Qgbm90IGJlIHVzZWQgd2l0aCAoaW1hZ2UpIGF0b21pYyBsb2FkAGdsX1NlbWFudGljc0FjcXVpcmVSZWxlYXNlIG11c3Qgbm90IGJlIHVzZWQgd2l0aCAoaW1hZ2UpIGF0b21pYyBsb2FkL3N0b3JlAEludmFsaWQgc2VtYW50aWNzIHZhbHVlAEludmFsaWQgc3RvcmFnZSBjbGFzcyBzZW1hbnRpY3MgdmFsdWUAU2VtYW50aWNzIG11c3QgaW5jbHVkZSBleGFjdGx5IG9uZSBvZiBnbF9TZW1hbnRpY3NSZWxlYXNlLCBnbF9TZW1hbnRpY3NBY3F1aXJlLCBvciBnbF9TZW1hbnRpY3NBY3F1aXJlUmVsZWFzZQBTZW1hbnRpY3MgbXVzdCBub3QgaW5jbHVkZSBtdWx0aXBsZSBvZiBnbF9TZW1hbnRpY3NSZWxlYXNlLCBnbF9TZW1hbnRpY3NBY3F1aXJlLCBvciBnbF9TZW1hbnRpY3NBY3F1aXJlUmVsZWFzZQBzZW1VbmVxdWFsIG11c3Qgbm90IGluY2x1ZGUgbXVsdGlwbGUgb2YgZ2xfU2VtYW50aWNzUmVsZWFzZSwgZ2xfU2VtYW50aWNzQWNxdWlyZSwgb3IgZ2xfU2VtYW50aWNzQWNxdWlyZVJlbGVhc2UAU3RvcmFnZSBjbGFzcyBzZW1hbnRpY3MgbXVzdCBub3QgYmUgemVybwBzZW1VbmVxdWFsIG11c3Qgbm90IGJlIGdsX1NlbWFudGljc1JlbGVhc2Ugb3IgZ2xfU2VtYW50aWNzQWNxdWlyZVJlbGVhc2UAZ2xfU2VtYW50aWNzTWFrZUF2YWlsYWJsZSByZXF1aXJlcyBnbF9TZW1hbnRpY3NSZWxlYXNlIG9yIGdsX1NlbWFudGljc0FjcXVpcmVSZWxlYXNlAGdsX1NlbWFudGljc01ha2VWaXNpYmxlIHJlcXVpcmVzIGdsX1NlbWFudGljc0FjcXVpcmUgb3IgZ2xfU2VtYW50aWNzQWNxdWlyZVJlbGVhc2UAZ2xfU2VtYW50aWNzVm9sYXRpbGUgbXVzdCBub3QgYmUgdXNlZCB3aXRoIG1lbW9yeUJhcnJpZXIgb3IgY29udHJvbEJhcnJpZXIAc2VtRXF1YWwgYW5kIHNlbVVuZXF1YWwgbXVzdCBlaXRoZXIgYm90aCBpbmNsdWRlIGdsX1NlbWFudGljc1ZvbGF0aWxlIG9yIG5laXRoZXIAdGVzc2VsbGF0aW9uIGNvbnRyb2wgYmFycmllcigpIGNhbm5vdCBiZSBwbGFjZWQgd2l0aGluIGZsb3cgY29udHJvbAB0ZXNzZWxsYXRpb24gY29udHJvbCBiYXJyaWVyKCkgbXVzdCBiZSBpbiBtYWluKCkAdGVzc2VsbGF0aW9uIGNvbnRyb2wgYmFycmllcigpIGNhbm5vdCBiZSBwbGFjZWQgYWZ0ZXIgYSByZXR1cm4gZnJvbSBtYWluKCkAYmVnaW5JbnZvY2F0aW9uSW50ZXJsb2NrQVJCKCkgbXVzdCBiZSBpbiBhIGZyYWdtZW50IHNoYWRlcgBiZWdpbkludm9jYXRpb25JbnRlcmxvY2tBUkIoKSBtdXN0IGJlIGluIG1haW4oKQBiZWdpbkludm9jYXRpb25JbnRlcmxvY2tBUkIoKSBjYW5ub3QgYmUgcGxhY2VkIGFmdGVyIGEgcmV0dXJuIGZyb20gbWFpbigpAGJlZ2luSW52b2NhdGlvbkludGVybG9ja0FSQigpIGNhbm5vdCBiZSBwbGFjZWQgd2l0aGluIGZsb3cgY29udHJvbABiZWdpbkludm9jYXRpb25JbnRlcmxvY2tBUkIoKSBtdXN0IG9ubHkgYmUgY2FsbGVkIG9uY2UAYmVnaW5JbnZvY2F0aW9uSW50ZXJsb2NrQVJCKCkgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGVuZEludm9jYXRpb25JbnRlcmxvY2tBUkIoKQBlbmRJbnZvY2F0aW9uSW50ZXJsb2NrQVJCKCkgbXVzdCBiZSBpbiBhIGZyYWdtZW50IHNoYWRlcgBlbmRJbnZvY2F0aW9uSW50ZXJsb2NrQVJCKCkgbXVzdCBiZSBpbiBtYWluKCkAZW5kSW52b2NhdGlvbkludGVybG9ja0FSQigpIGNhbm5vdCBiZSBwbGFjZWQgYWZ0ZXIgYSByZXR1cm4gZnJvbSBtYWluKCkAZW5kSW52b2NhdGlvbkludGVybG9ja0FSQigpIGNhbm5vdCBiZSBwbGFjZWQgd2l0aGluIGZsb3cgY29udHJvbABlbmRJbnZvY2F0aW9uSW50ZXJsb2NrQVJCKCkgbXVzdCBvbmx5IGJlIGNhbGxlZCBvbmNlAGNhbid0IHVzZSBmdW5jdGlvbiBzeW50YXggb24gdmFyaWFibGUAbm8gbWF0Y2hpbmcgb3ZlcmxvYWRlZCBmdW5jdGlvbiBmb3VuZABhbWJpZ3VvdXMgYmVzdCBmdW5jdGlvbiB1bmRlciBpbXBsaWNpdCB0eXBlIGNvbnZlcnNpb24AQairCgv8tAFhbWJpZ3VvdXMgZnVuY3Rpb24gc2lnbmF0dXJlIG1hdGNoOiBtdWx0aXBsZSBzaWduYXR1cmVzIG1hdGNoIHVuZGVyIGltcGxpY2l0IHR5cGUgY29udmVyc2lvbgBhcnJheSBhcmd1bWVudCBtdXN0IGJlIHNpemVkAGNhbid0IGNvbnN0cnVjdCBzdHJ1Y3R1cmUgY29udGFpbmluZyAxNi1iaXQgdHlwZQBjYW4ndCBjb25zdHJ1Y3Qgc3RydWN0dXJlIGNvbnRhaW5pbmcgOC1iaXQgdHlwZQAxNi1iaXQgYXJyYXlzIG5vdCBzdXBwb3J0ZWQAMTYtYml0IHZlY3RvcnMgb25seSB0YWtlIHZlY3RvciB0eXBlcwA4LWJpdCBhcnJheXMgbm90IHN1cHBvcnRlZAA4LWJpdCB2ZWN0b3JzIG9ubHkgdGFrZSB2ZWN0b3IgdHlwZXMAYXJyYXkgY29uc3RydWN0b3IgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBhcmd1bWVudABhcnJheSBjb25zdHJ1Y3RvciBuZWVkcyBvbmUgYXJndW1lbnQgcGVyIGFycmF5IGVsZW1lbnQAYXJyYXkgY29uc3RydWN0b3IgYXJndW1lbnQgbm90IGNvcnJlY3QgdHlwZSB0byBjb25zdHJ1Y3QgYXJyYXkgZWxlbWVudABjb25zdHJ1Y3Rpbmcgbm9uLWFycmF5IGNvbnN0aXR1ZW50IGZyb20gYXJyYXkgYXJndW1lbnQAY29uc3RydWN0aW5nIG1hdHJpeCBmcm9tIG1hdHJpeABtYXRyaXggY29uc3RydWN0ZWQgZnJvbSBtYXRyaXggY2FuIG9ubHkgaGF2ZSBvbmUgYXJndW1lbnQAdG9vIG1hbnkgYXJndW1lbnRzAE51bWJlciBvZiBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzIGRvZXMgbm90IG1hdGNoIHRoZSBudW1iZXIgb2Ygc3RydWN0dXJlIGZpZWxkcwBub3QgZW5vdWdoIGRhdGEgcHJvdmlkZWQgZm9yIGNvbnN0cnVjdGlvbgB3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzAENvb3BlcmF0aXZlIG1hdHJpeCBjb25zdHJ1Y3RvciBhcmd1bWVudCBtdXN0IGJlIHNjYWxhciBvciBjb29wZXJhdGl2ZSBtYXRyaXgAY29uc3RydWN0b3IgYXJndW1lbnQgZG9lcyBub3QgaGF2ZSBhIHR5cGUAY2Fubm90IGNvbnZlcnQgYSBzYW1wbGVyAGNhbm5vdCBjb252ZXJ0IGFuIGF0b21pY191aW50AGNhbm5vdCBjb252ZXJ0IGEgdm9pZABzYW1wbGVyLWNvbnN0cnVjdG9yIHJlcXVpcmVzIHR3byBhcmd1bWVudHMAc2FtcGxlci1jb25zdHJ1Y3RvciBjYW5ub3QgbWFrZSBhbiBhcnJheSBvZiBzYW1wbGVycwBzYW1wbGVyLWNvbnN0cnVjdG9yIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzY2FsYXIgdGV4dHVyZVhYWCB0eXBlAHNhbXBsZXItY29uc3RydWN0b3IgZmlyc3QgYXJndW1lbnQgbXVzdCBtYXRjaCB0eXBlIGFuZCBkaW1lbnNpb25hbGl0eSBvZiBjb25zdHJ1Y3RvciB0eXBlAHNhbXBsZXItY29uc3RydWN0b3Igc2Vjb25kIGFyZ3VtZW50IG11c3QgYmUgYSBzY2FsYXIgdHlwZSAnc2FtcGxlcicAbWV0aG9kIGRvZXMgbm90IGFjY2VwdCBhbnkgYXJndW1lbnRzAGdsX2luAGdsX291dABnbF9NZXNoVmVydGljZXNOVgBnbF9NZXNoUHJpbWl0aXZlc05WAGFycmF5IG11c3QgZmlyc3QgYmUgc2l6ZWQgYnkgYSByZWRlY2xhcmF0aW9uIG9yIGxheW91dCBxdWFsaWZpZXIAYXJyYXkgbXVzdCBiZSBkZWNsYXJlZCB3aXRoIGEgc2l6ZSBiZWZvcmUgdXNpbmcgdGhpcyBtZXRob2QALmxlbmd0aCgpAHVuZXhwZWN0ZWQgdXNlIG9mIC5sZW5ndGgoKQB2b2lkIGZ1bmN0aW9uIGNhbm5vdCByZXR1cm4gYSB2YWx1ZQBjYW5ub3QgY29udmVydCByZXR1cm4gdmFsdWUgdG8gZnVuY3Rpb24gcmV0dXJuIHR5cGUAdHlwZSBjb252ZXJzaW9uIG9uIHJldHVybiB2YWx1ZXMgd2FzIG5vdCBleHBsaWNpdGx5IGFsbG93ZWQgdW50aWwgdmVyc2lvbiA0MjAAdHlwZSBkb2VzIG5vdCBtYXRjaCwgb3IgaXMgbm90IGNvbnZlcnRpYmxlIHRvLCB0aGUgZnVuY3Rpb24ncyByZXR1cm4gdHlwZQBjYW4ndCB1c2Ugd2l0aCBzdHJ1Y3RzIGNvbnRhaW5pbmcgZmxvYXQxNgBjYW4ndCB1c2Ugd2l0aCBhcnJheXMgY29udGFpbmluZyBmbG9hdDE2AGNhbid0IHVzZSB3aXRoIHN0cnVjdHMgY29udGFpbmluZyBpbnQxNgBjYW4ndCB1c2Ugd2l0aCBhcnJheXMgY29udGFpbmluZyBpbnQxNgBjYW4ndCB1c2Ugd2l0aCBzdHJ1Y3RzIGNvbnRhaW5pbmcgdWludDE2AGNhbid0IHVzZSB3aXRoIGFycmF5cyBjb250YWluaW5nIHVpbnQxNgBjYW4ndCB1c2Ugd2l0aCBzdHJ1Y3RzIGNvbnRhaW5pbmcgaW50OABjYW4ndCB1c2Ugd2l0aCBhcnJheXMgY29udGFpbmluZyBpbnQ4AGNhbid0IHVzZSB3aXRoIHN0cnVjdHMgY29udGFpbmluZyB1aW50OABjYW4ndCB1c2Ugd2l0aCBhcnJheXMgY29udGFpbmluZyB1aW50OABhcnJheWVkIGNvbnN0cnVjdG9yAGNhbm5vdCBjb25zdHJ1Y3QgdGhpcyB0eXBlAGFsbCBkZWZhdWx0IHByZWNpc2lvbnMgYXJlIGhpZ2hwOyB1c2UgcHJlY2lzaW9uIHN0YXRlbWVudHMgdG8gcXVpZXQgd2FybmluZywgZS5nLjoKICAgICAgICAgInByZWNpc2lvbiBtZWRpdW1wIGludDsgcHJlY2lzaW9uIGhpZ2hwIGZsb2F0OyIAY2Fubm90IGNvbnZlcnQgZnJvbSAnJXMnIHRvICclcycAY29uc3RhbnQgZXhwcmVzc2lvbiByZXF1aXJlZABzY2FsYXIgaW50ZWdlciBleHByZXNzaW9uIHJlcXVpcmVkAG5vdCBhbGxvd2VkIGluIG5lc3RlZCBzY29wZQBpZGVudGlmaWVycyBzdGFydGluZyB3aXRoICJnbF8iIGFyZSByZXNlcnZlZABpZGVudGlmaWVycyBjb250YWluaW5nIGNvbnNlY3V0aXZlIHVuZGVyc2NvcmVzICgiX18iKSBhcmUgcmVzZXJ2ZWQsIGFuZCBhbiBlcnJvciBpZiB2ZXJzaW9uIDw9IDMwMABpZGVudGlmaWVycyBjb250YWluaW5nIGNvbnNlY3V0aXZlIHVuZGVyc2NvcmVzICgiX18iKSBhcmUgcmVzZXJ2ZWQAYm9vbGVhbiBleHByZXNzaW9uIGV4cGVjdGVkAACQ2gMAc2FtcGxlckV4dGVybmFsT0VTAACq2gMAytoDAF9fc2FtcGxlckV4dGVybmFsMkRZMllFWFQAbm9uLXVuaWZvcm0gc3RydWN0IGNvbnRhaW5zIGEgc2FtcGxlciBvciBpbWFnZToAc2FtcGxlci9pbWFnZSB0eXBlcyBjYW4gb25seSBiZSB1c2VkIGluIHVuaWZvcm0gdmFyaWFibGVzIG9yIGZ1bmN0aW9uIHBhcmFtZXRlcnM6AG5vbi11bmlmb3JtIHN0cnVjdCBjb250YWlucyBhbiBhdG9taWNfdWludDoAYXRvbWljX3VpbnRzIGNhbiBvbmx5IGJlIHVzZWQgaW4gdW5pZm9ybSB2YXJpYWJsZXMgb3IgZnVuY3Rpb24gcGFyYW1ldGVyczoAbm9uLXVuaWZvcm0gc3RydWN0IGNvbnRhaW5zIGFuIGFjY2VsZXJhdGlvblN0cnVjdHVyZU5WOgBhY2NlbGVyYXRpb25TdHJ1Y3R1cmVOViBjYW4gb25seSBiZSB1c2VkIGluIHVuaWZvcm0gdmFyaWFibGVzIG9yIGZ1bmN0aW9uIHBhcmFtZXRlcnM6AG5vbi1vcGFxdWUgdW5pZm9ybXMgb3V0c2lkZSBhIGJsb2NrAG5vbi1vcGFxdWUgdW5pZm9ybSB2YXJpYWJsZXMgbmVlZCBhIGxheW91dChsb2NhdGlvbj1MKQBub3QgYWxsb3dlZCBvbiBibG9jayBvciBzdHJ1Y3R1cmUgbWVtYmVycwBub251bmlmb3JtRVhUAGNhbiBvbmx5IGFwcGx5IHRvIGEgc3RhbmRhbG9uZSBxdWFsaWZpZXIAcG9pbnRfbW9kZQBpbnZvY2F0aW9ucwBsb2NhbF9zaXplAGxvY2FsX3NpemUgaWQAZWFybHlfZnJhZ21lbnRfdGVzdHMAcG9zdF9kZXB0aF9jb3ZlcmFnZQBibGVuZCBlcXVhdGlvbgBudW1fdmlld3MAAJyjAgC0owIAzqMCAOejAgACpAIAIaQCAHBpeGVsX2ludGVybG9ja19vcmRlcmVkAHBpeGVsX2ludGVybG9ja191bm9yZGVyZWQAc2FtcGxlX2ludGVybG9ja19vcmRlcmVkAHNhbXBsZV9pbnRlcmxvY2tfdW5vcmRlcmVkAHNoYWRpbmdfcmF0ZV9pbnRlcmxvY2tfb3JkZXJlZABzaGFkaW5nX3JhdGVfaW50ZXJsb2NrX3Vub3JkZXJlZABjY3cAY3cAAAAAWKQCAGakAgB+pAIAZXF1YWxfc3BhY2luZwBmcmFjdGlvbmFsX2V2ZW5fc3BhY2luZwBmcmFjdGlvbmFsX29kZF9zcGFjaW5nAGluIGZvciBzdGFnZSBpbnB1dHMAb3V0IGZvciBzdGFnZSBvdXRwdXRzAGNhbm5vdCB1c2UgJ2lub3V0JyBhdCBnbG9iYWwgc2NvcGUAZm9yIG5vbi1wYXJhbWV0ZXIsIGNhbiBvbmx5IGFwcGx5IHRvICdpbicgb3Igbm8gc3RvcmFnZSBxdWFsaWZpZXIAY2FuIG9ubHkgYXBwbHkgdG8gYW4gb3V0cHV0AGNhbiBvbmx5IGFwcGx5IHRvIGFuIG91dHB1dCwgb3IgdG8gYW4gaW5wdXQgaW4gYSBub24tdmVydGV4IHN0YWdlCgBtZW1vcnkgcXVhbGlmaWVycyBjYW5ub3QgYmUgdXNlZCBvbiB0aGlzIHR5cGUAYnVmZmVycyBjYW4gYmUgZGVjbGFyZWQgb25seSBhcyBibG9ja3MAY2FuIG9ubHkgYmUgYXBwbGllZCB0byBhIHN0YW5kYWxvbmUgJ291dCcAY2Fubm90IGJlIGJvb2wAc2hhZGVyIGlucHV0L291dHB1dABtdXN0IGJlIHF1YWxpZmllZCBhcyBmbGF0AGNhbm5vdCB1c2UgaW50ZXJwb2xhdGlvbiBxdWFsaWZpZXJzIHdpdGggcGF0Y2gAdGFza05WIHZhcmlhYmxlcyBjYW4gYmUgZGVjbGFyZWQgb25seSBhcyBibG9ja3MAY2Fubm90IGJlIGEgc3RydWN0dXJlIG9yIGFycmF5AHZlcnRleCBpbnB1dCBhcnJheXMAdmVydGV4LXNoYWRlciBgZG91YmxlYCB0eXBlIGlucHV0AHZlcnRleCBpbnB1dCBjYW5ub3QgYmUgZnVydGhlciBxdWFsaWZpZWQAZnJhZ21lbnQtc2hhZGVyIHN0cnVjdCBpbnB1dABmcmFnbWVudC1zaGFkZXIgc3RydWN0IGlucHV0IGNvbnRhaW5pbmcgc3RydWN0dXJlAGZyYWdtZW50LXNoYWRlciBzdHJ1Y3QgaW5wdXQgY29udGFpbmluZyBhbiBhcnJheQBnbG9iYWwgc3RvcmFnZSBpbnB1dCBxdWFsaWZpZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBjb21wdXRlIHNoYWRlcgBjYW4gb25seSB1c2Ugb24gb3V0cHV0IGluIHRlc3NlbGxhdGlvbi1jb250cm9sIHNoYWRlcgB2ZXJ0ZXgtc2hhZGVyIHN0cnVjdCBvdXRwdXQAdmVydGV4LXNoYWRlciBzdHJ1Y3Qgb3V0cHV0IGNvbnRhaW5pbmcgc3RydWN0dXJlAHZlcnRleC1zaGFkZXIgc3RydWN0IG91dHB1dCBjb250YWluaW5nIGFuIGFycmF5AGZyYWdtZW50IHNoYWRlciBvdXRwdXQAY2Fubm90IGJlIGEgc3RydWN0dXJlAGNhbm5vdCBiZSBhIG1hdHJpeABjYW4ndCB1c2UgYXV4aWxpYXJ5IHF1YWxpZmllciBvbiBhIGZyYWdtZW50IG91dHB1dABjZW50cm9pZC9zYW1wbGUvcGF0Y2gAY2FuJ3QgdXNlIGludGVycG9sYXRpb24gcXVhbGlmaWVyIG9uIGEgZnJhZ21lbnQgb3V0cHV0AGZsYXQvc21vb3RoL25vcGVyc3BlY3RpdmUAY2Fubm90IGNvbnRhaW4gYSBkb3VibGUsIGludDY0LCBvciB1aW50NjQAZ2xvYmFsIHN0b3JhZ2Ugb3V0cHV0IHF1YWxpZmllciBjYW5ub3QgYmUgdXNlZCBpbiBhIGNvbXB1dGUgc2hhZGVyAGNhbiBvbmx5IHVzZSBvbiBpbnB1dCBpbiB0ZXNzZWxsYXRpb24tZXZhbHVhdGlvbiBzaGFkZXIAY2FuIG9ubHkgaGF2ZSBvbmUgYXV4aWxpYXJ5IHF1YWxpZmllciAoY2VudHJvaWQsIHBhdGNoLCBhbmQgc2FtcGxlKQBjYW4gb25seSBoYXZlIG9uZSBpbnRlcnBvbGF0aW9uIHF1YWxpZmllciAoZmxhdCwgc21vb3RoLCBub3BlcnNwZWN0aXZlLCBfX2V4cGxpY2l0SW50ZXJwQU1EKQBwcmVjaXNlIHF1YWxpZmllciBtdXN0IGFwcGVhciBmaXJzdABpbnZhcmlhbnQgcXVhbGlmaWVyIG11c3QgYXBwZWFyIGJlZm9yZSBpbnRlcnBvbGF0aW9uLCBzdG9yYWdlLCBhbmQgcHJlY2lzaW9uIHF1YWxpZmllcnMgAGludGVycG9sYXRpb24gcXVhbGlmaWVycyBtdXN0IGFwcGVhciBiZWZvcmUgc3RvcmFnZSBhbmQgcHJlY2lzaW9uIHF1YWxpZmllcnMAQXV4aWxpYXJ5IHF1YWxpZmllcnMgKGNlbnRyb2lkLCBwYXRjaCwgYW5kIHNhbXBsZSkgbXVzdCBhcHBlYXIgYmVmb3JlIHN0b3JhZ2UgYW5kIHByZWNpc2lvbiBxdWFsaWZpZXJzAHByZWNpc2lvbiBxdWFsaWZpZXIgbXVzdCBhcHBlYXIgYXMgbGFzdCBxdWFsaWZpZXIAaW4vb3V0IG11c3QgYXBwZWFyIGJlZm9yZSBjb25zdAB0b28gbWFueSBzdG9yYWdlIHF1YWxpZmllcnMAb25seSBvbmUgcHJlY2lzaW9uIHF1YWxpZmllciBhbGxvd2VkAG9ubHkgb25lIGNvaGVyZW50L2RldmljZWNvaGVyZW50L3F1ZXVlZmFtaWx5Y29oZXJlbnQvd29ya2dyb3VwY29oZXJlbnQvc3ViZ3JvdXBjb2hlcmVudCBxdWFsaWZpZXIgYWxsb3dlZAByZXBsaWNhdGVkIHF1YWxpZmllcnMAY2FuIG9ubHkgYXBwbHkgaGlnaHAgdG8gYXRvbWljX3VpbnQAcHJlY2lzaW9uAGNhbm5vdCBhcHBseSBwcmVjaXNpb24gc3RhdGVtZW50IHRvIHRoaXMgdHlwZTsgdXNlICdmbG9hdCcsICdpbnQnIG9yIGEgc2FtcGxlciB0eXBlAGF0b21pYyBjb3VudGVycyBjYW4gb25seSBiZSBoaWdocAB0eXBlIHJlcXVpcmVzIGRlY2xhcmF0aW9uIG9mIGRlZmF1bHQgcHJlY2lzaW9uIHF1YWxpZmllcgBzdWJzdGl0dXRpbmcgJ21lZGl1bXAnAHR5cGUgY2Fubm90IGhhdmUgcHJlY2lzaW9uIHF1YWxpZmllcgBzYW1wbGVycyBhbmQgYXRvbWljX3VpbnRzIGNhbm5vdCBiZSBvdXRwdXQgcGFyYW1ldGVycwBtdXN0IGJlIGEgY29uc3RhbnQgaW50ZWdlciBleHByZXNzaW9uAG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyAGNvbnN0IGFycmF5AHZlcnRleC1zaGFkZXIgYXJyYXktb2YtYXJyYXkgb3V0cHV0AHZlcnRleC1zaGFkZXIgYXJyYXktb2Ytc3RydWN0IG91dHB1dABmcmFnbWVudC1zaGFkZXIgYXJyYXktb2YtYXJyYXkgaW5wdXQAZnJhZ21lbnQtc2hhZGVyIGFycmF5LW9mLXN0cnVjdCBpbnB1dABmcmFnbWVudC1zaGFkZXIgYXJyYXktb2YtYXJyYXkgb3V0cHV0AGFycmF5IHNpemUgcmVxdWlyZWQAYXJyYXkgaW5pdGlhbGl6ZXIgbXVzdCBiZSBzaXplZABvbmx5IG91dGVybW9zdCBkaW1lbnNpb24gb2YgYW4gYXJyYXkgb2YgYXJyYXlzIGNhbiBiZSBpbXBsaWNpdGx5IHNpemVkAG9ubHkgb3V0ZXJtb3N0IGRpbWVuc2lvbiBvZiBhbiBhcnJheSBvZiBhcnJheXMgY2FuIGJlIGEgc3BlY2lhbGl6YXRpb24gY29uc3RhbnQAYXJyYXlzIG9mIGFycmF5cwBjYW5ub3QgcmVkZWNsYXJlIGEgdXNlci1ibG9jayBtZW1iZXIgYXJyYXkAYXJyYXkgdmFyaWFibGUgbmFtZSBleHBlY3RlZAByZWRlY2xhcmluZyBub24tYXJyYXkgYXMgYXJyYXkAcmVkZWNsYXJhdGlvbiBvZiBhcnJheSB3aXRoIGEgZGlmZmVyZW50IGVsZW1lbnQgdHlwZQByZWRlY2xhcmF0aW9uIG9mIGFycmF5IHdpdGggYSBkaWZmZXJlbnQgYXJyYXkgZGltZW5zaW9ucyBvciBzaXplcwByZWRlY2xhcmF0aW9uIG9mIGFycmF5IHdpdGggc2l6ZQBnbF9UZXhDb29yZABnbF9NYXhUZXh0dXJlQ29vcmRzAGdsX1RleENvb3JkIGFycmF5IHNpemUAZ2xfTWF4Q2xpcERpc3RhbmNlcwBnbF9DbGlwRGlzdGFuY2UgYXJyYXkgc2l6ZQBnbF9NYXhDdWxsRGlzdGFuY2VzAGdsX0N1bGxEaXN0YW5jZSBhcnJheSBzaXplAGdsX0NsaXBEaXN0YW5jZVBlclZpZXdOViBhcnJheSBzaXplAGdsX0N1bGxEaXN0YW5jZVBlclZpZXdOViBhcnJheSBzaXplAG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvACVzICglZCkAbWVzaCB2aWV3IG91dHB1dCBhcnJheSBzaXplIG11c3QgYmUgZ2xfTWF4TWVzaFZpZXdDb3VudE5WIG9yIGltcGxpY2l0bHkgc2l6ZWQAcmVxdWlyZXMgYSB2aWV3IGFycmF5IGRpbWVuc2lvbgB2YXJpYWJsZXMgd2l0aCBxdWFsaWZpZXIgJ2NvbnN0JyBtdXN0IGJlIGluaXRpYWxpemVkAMrkAwCz5QMAZ2xfRm9nRnJhZ0Nvb3JkAGdsX0Zyb250Q29sb3IAZ2xfQmFja0NvbG9yAGdsX0Zyb250U2Vjb25kYXJ5Q29sb3IAZ2xfQmFja1NlY29uZGFyeUNvbG9yAGdsX1NlY29uZGFyeUNvbG9yAGdsX0NvbG9yAGdsX0ZyYWdTdGVuY2lsUmVmQVJCAGdsX1NhbXBsZU1hc2sAZ2xfUHJpbWl0aXZlSW5kaWNlc05WAGNhbm5vdCByZWRlY2xhcmUgYWZ0ZXIgdXNlAGNhbm5vdCBhcHBseSBsYXlvdXQgcXVhbGlmaWVyIHRvAHJlZGVjbGFyYXRpb24AY2Fubm90IGNoYW5nZSBzdG9yYWdlLCBtZW1vcnksIG9yIGF1eGlsaWFyeSBxdWFsaWZpY2F0aW9uIG9mAGNhbm5vdCBjaGFuZ2UgaW50ZXJwb2xhdGlvbiBxdWFsaWZpY2F0aW9uIG9mAGNhbm5vdCBjaGFuZ2UgcXVhbGlmaWNhdGlvbiBvZgBjYW4gb25seSBjaGFuZ2UgbGF5b3V0IHF1YWxpZmljYXRpb24gb2YAY2Fubm90IGNoYW5nZSBpbnB1dCBzdG9yYWdlIHF1YWxpZmljYXRpb24gb2YAY2Fubm90IHJlZGVjbGFyZSB3aXRoIGRpZmZlcmVudCBxdWFsaWZpY2F0aW9uOgBjYW5ub3QgY2hhbmdlIG91dHB1dCBzdG9yYWdlIHF1YWxpZmljYXRpb24gb2YAYWxsIHJlZGVjbGFyYXRpb25zIG11c3QgdXNlIHRoZSBzYW1lIGRlcHRoIGxheW91dCBvbgByZWRlY2xhcmF0aW9uIG9ubHkgYWxsb3dlZCBmb3Igb3ZlcnJpZGVfY292ZXJhZ2UgbGF5b3V0AHJlZGVjbGFyYXRpb24gb25seSBhbGxvd2VkIGZvciB2aWV3cG9ydF9yZWxhdGl2ZSBvciBzZWNvbmRhcnlfdmlld19vZmZzZXQgbGF5b3V0AGJ1aWx0LWluIGJsb2NrIHJlZGVjbGFyYXRpb24AZ2xfUGVyVmVydGV4AGdsX1BlckZyYWdtZW50AGdsX01lc2hQZXJWZXJ0ZXhOVgBnbF9NZXNoUGVyUHJpbWl0aXZlTlYAY2Fubm90IHJlZGVjbGFyZSBibG9jazogAGJsb2NrIGRlY2xhcmF0aW9uAGNhbm5vdCByZWRlY2xhcmUgYSBidWlsdC1pbiBibG9jayB3aXRoIGEgdXNlciBuYW1lAG5vIGRlY2xhcmF0aW9uIGZvdW5kIGZvciByZWRlY2xhcmF0aW9uAGNhbiBvbmx5IHJlZGVjbGFyZSBhIGJ1aWx0LWluIGJsb2NrIG9uY2UsIGFuZCBiZWZvcmUgYW55IHVzZQBjYW5ub3QgcmVkZWNsYXJlIGEgbm9uIGJsb2NrIGFzIGEgYmxvY2sAY2Fubm90IHJlZGVjbGFyZSBibG9jayBtZW1iZXIgd2l0aCBhIGRpZmZlcmVudCB0eXBlAGNhbm5vdCBjaGFuZ2UgYXJyYXluZXNzIG9mIHJlZGVjbGFyZWQgYmxvY2sgbWVtYmVyAGNhbm5vdCBjaGFuZ2UgYXJyYXkgc2l6ZSBvZiByZWRlY2xhcmVkIGJsb2NrIG1lbWJlcgBtaXNzaW5nIHBlcnZpZXdOViBxdWFsaWZpZXIgdG8gcmVkZWNsYXJlZCBibG9jayBtZW1iZXIAY2Fubm90IGFkZCBwZXJ2aWV3TlYgcXVhbGlmaWVyIHRvIHJlZGVjbGFyZWQgYmxvY2sgbWVtYmVyAG1pc3NpbmcgcGVycHJpbWl0aXZlTlYgcXVhbGlmaWVyIHRvIHJlZGVjbGFyZWQgYmxvY2sgbWVtYmVyAGNhbm5vdCBhZGQgcGVycHJpbWl0aXZlTlYgcXVhbGlmaWVyIHRvIHJlZGVjbGFyZWQgYmxvY2sgbWVtYmVyAGNhbm5vdCBhZGQgbWVtb3J5IHF1YWxpZmllciB0byByZWRlY2xhcmVkIGJsb2NrIG1lbWJlcgBjYW5ub3QgYWRkIG5vbi1YRkIgbGF5b3V0IHRvIHJlZGVjbGFyZWQgYmxvY2sgbWVtYmVyAGNhbm5vdCBhZGQgcGF0Y2ggdG8gcmVkZWNsYXJlZCBibG9jayBtZW1iZXIAbWVtYmVyIGNhbm5vdCBjb250cmFkaWN0IGJsb2NrIChvciB3aGF0IGJsb2NrIGluaGVyaXRlZCBmcm9tIGdsb2JhbCkAeGZiX2J1ZmZlcgB4ZmJfc3RyZWFtAGJsb2NrIHJlZGVjbGFyYXRpb24gaGFzIGV4dHJhIG1lbWJlcnMAY2Fubm90IGNoYW5nZSBhcnJheW5lc3Mgb2YgcmVkZWNsYXJlZCBibG9jawBjYW5ub3QgY2hhbmdlIGFycmF5IHNpemUgb2YgcmVkZWNsYXJlZCBibG9jawBjYW4gb25seSBiZSB1c2VkIG9uIHZhcmlhYmxlIGRlY2xhcmF0aW9uAGxvY2F0aW9uAFNQSVItViByZXF1aXJlcyBsb2NhdGlvbiBmb3IgdXNlciBpbnB1dC9vdXRwdXQAY2Fubm90IHNwZWNpZnkgbWF0cml4IGxheW91dCBvbiBhIHZhcmlhYmxlIGRlY2xhcmF0aW9uAGxheW91dABjYW5ub3Qgc3BlY2lmeSBwYWNraW5nIG9uIGEgdmFyaWFibGUgZGVjbGFyYXRpb24AY2Fubm90IHNwZWNpZnkgb24gYSB2YXJpYWJsZSBkZWNsYXJhdGlvbgBhbGlnbgBjYW4gb25seSBzcGVjaWZ5IG9uIGEgdW5pZm9ybSBibG9jawBwdXNoX2NvbnN0YW50AGNhbiBvbmx5IHNwZWNpZnkgb24gYSBidWZmZXIgYmxvY2sAc2hhZGVyUmVjb3JkTlYAdG9vIGxhcmdlIGZvciBmcmFnbWVudCBvdXRwdXQAdHlwZSBvdmVyZmxvd3MgdGhlIGF2YWlsYWJsZSA0IGNvbXBvbmVudHMAY29tcG9uZW50AGNhbm5vdCBhcHBseSB0byBhIG1hdHJpeCwgc3RydWN0dXJlLCBvciBibG9jawBkb3VibGVzIGNhbm5vdCBzdGFydCBvbiBhbiBvZGQtbnVtYmVyZWQgY29tcG9uZW50AGxvY2F0aW9uIHF1YWxpZmllciBvbiBpbi9vdXQgYmxvY2sAY2Fubm90IGFwcGx5IHRvIHRhc2tOViBpbi9vdXQgYmxvY2tzAGNhbm5vdCBhcHBseSB0byB1bmlmb3JtIG9yIGJ1ZmZlciBibG9jawBjYW4gb25seSBhcHBseSB0byB1bmlmb3JtLCBidWZmZXIsIGluLCBvciBvdXQgc3RvcmFnZSBxdWFsaWZpZXJzAG92ZXJsYXBwaW5nIHVzZSBvZiBsb2NhdGlvbgBmcmFnbWVudCBvdXRwdXRzIHNoYXJpbmcgdGhlIHNhbWUgbG9jYXRpb24gbXVzdCBiZSB0aGUgc2FtZSBiYXNpYyB0eXBlAG92ZXJsYXBwaW5nIG9mZnNldHMgYXQAeGZiX29mZnNldABvZmZzZXQgJWQgaW4gYnVmZmVyICVkAHR5cGUgY29udGFpbnMgZG91YmxlIG9yIDY0LWJpdCBpbnRlZ2VyOyB4ZmJfb2Zmc2V0IG11c3QgYmUgYSBtdWx0aXBsZSBvZiA4AG11c3QgYmUgYSBtdWx0aXBsZSBvZiBzaXplIG9mIGZpcnN0IGNvbXBvbmVudAB0eXBlIGNvbnRhaW5zIGhhbGYgZmxvYXQgb3IgMTYtYml0IGludGVnZXI7IHhmYl9vZmZzZXQgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDIAYWxsIHN0cmlkZSBzZXR0aW5ncyBtdXN0IG1hdGNoIGZvciB4ZmIgYnVmZmVyAHhmYl9zdHJpZGUAcmVxdWlyZXMgYmxvY2ssIG9yIHNhbXBsZXIvaW1hZ2UsIG9yIGF0b21pYy1jb3VudGVyIHR5cGUAYmluZGluZwBhc3N1bWluZyBiaW5kaW5nIGNvdW50IG9mIG9uZSBmb3IgY29tcGlsZS10aW1lIGNoZWNraW5nIG9mIGJpbmRpbmcgbnVtYmVycyBmb3IgdW5zaXplZCBhcnJheQAodXNpbmcgYXJyYXkpAHNhbXBsZXIgYmluZGluZyBub3QgbGVzcyB0aGFuIGdsX01heENvbWJpbmVkVGV4dHVyZUltYWdlVW5pdHMAYXRvbWljX3VpbnQgYmluZGluZyBpcyB0b28gbGFyZ2U7IHNlZSBnbF9NYXhBdG9taWNDb3VudGVyQmluZGluZ3MAbGF5b3V0KGJpbmRpbmc9WCkgaXMgcmVxdWlyZWQAdW5pZm9ybS9idWZmZXIgYmxvY2tzIHJlcXVpcmUgbGF5b3V0KGJpbmRpbmc9WCkAc2FtcGxlci90ZXh0dXJlL2ltYWdlIHJlcXVpcmVzIGxheW91dChiaW5kaW5nPVgpAEdlbmVyYXRpbmcgU1BJUi1WIGFycmF5LW9mLWFycmF5cywgYnV0IFZ1bGthbiBvbmx5IHN1cHBvcnRzIHNpbmdsZSBhcnJheSBsZXZlbCBmb3IgdGhpcyByZXNvdXJjZQBbXVtdAG9ubHkgYXBwbGllcyB0byBibG9jayBtZW1iZXJzLCBub3QgYmxvY2tzAG9ubHkgYXBwbHkgdG8gaW1hZ2VzAGRvZXMgbm90IGFwcGx5IHRvIGZsb2F0aW5nIHBvaW50IGltYWdlcwBkb2VzIG5vdCBhcHBseSB0byBzaWduZWQgaW50ZWdlciBpbWFnZXMAZG9lcyBub3QgYXBwbHkgdG8gdW5zaWduZWQgaW50ZWdlciBpbWFnZXMAZm9ybWF0IHJlcXVpcmVzIHJlYWRvbmx5IG9yIHdyaXRlb25seSBtZW1vcnkgcXVhbGlmaWVyAGltYWdlIHZhcmlhYmxlcyBub3QgZGVjbGFyZWQgJ3dyaXRlb25seScgYW5kIHdpdGhvdXQgYSBmb3JtYXQgbGF5b3V0IHF1YWxpZmllcgBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBibG9jawBidWZmZXJfcmVmZXJlbmNlAHJlcXVpcmVzIGFuIGlucHV0X2F0dGFjaG1lbnRfaW5kZXggbGF5b3V0IHF1YWxpZmllcgBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBzdWJwYXNzAGlucHV0X2F0dGFjaG1lbnRfaW5kZXgAY2FuIG9ubHkgYmUgYXBwbGllZCB0byAnY29uc3QnLXF1YWxpZmllZCBzY2FsYXIAY29uc3RhbnRfaWQAY2FuIG9ubHkgYmUgYXBwbGllZCB0byBhIHNjYWxhcgBjYW5ub3QgYmUgYXBwbGllZCB0byB0aGlzIHR5cGUAY2Fubm90IGFwcGx5IGxheW91dCBxdWFsaWZpZXJzIHRvIGEgc2hhcmVkIHZhcmlhYmxlAG11c3Qgc3BlY2lmeSAnbG9jYXRpb24nIHRvIHVzZSAnY29tcG9uZW50JwBsb2NhdGlvbiBxdWFsaWZpZXIgb24gaW5wdXQAAAAAAACE2wMAJNwDAGxvY2F0aW9uIHF1YWxpZmllciBvbiBvdXRwdXQAbG9jYXRpb24gcXVhbGlmaWVyIG9uIHVuaWZvcm0gb3IgYnVmZmVyAGNhbiBvbmx5IGJlIHVzZWQgb24gYW4gb3V0cHV0AGluZGV4AGNhbiBvbmx5IGJlIHVzZWQgd2l0aCBhbiBleHBsaWNpdCBsb2NhdGlvbgByZXF1aXJlcyB1bmlmb3JtIG9yIGJ1ZmZlciBzdG9yYWdlIHF1YWxpZmllcgBzdHJlYW0AeGZiIGxheW91dCBxdWFsaWZpZXIAbWF0cml4IG9yIHBhY2tpbmcgcXVhbGlmaWVycyBjYW4gb25seSBiZSB1c2VkIG9uIGEgdW5pZm9ybSBvciBidWZmZXIAb2Zmc2V0L2FsaWduIGNhbiBvbmx5IGJlIHVzZWQgb24gYSB1bmlmb3JtIG9yIGJ1ZmZlcgBjYW4gb25seSBiZSB1c2VkIHdpdGggYSB1bmlmb3JtAGNhbm5vdCBiZSB1c2VkIHdpdGggcHVzaF9jb25zdGFudABzZXQAY2FuIG9ubHkgYmUgdXNlZCB3aXRoIGJ1ZmZlcgBjYW4gb25seSBiZSB1c2VkIHdpdGggYSBidWZmZXIAY2Fubm90IGJlIHVzZWQgd2l0aCBzaGFkZXJSZWNvcmROVgBjYW5ub3QgYXBwbHkgbGF5b3V0IHF1YWxpZmllcnMgdG8gaGl0QXR0cmlidXRlTlYgdmFyaWFibGUAc3RvcmFnZSBxdWFsaWZpZXIgbm90IGFsbG93ZWQgb24gZnVuY3Rpb24gcGFyYW1ldGVyAGNhbm5vdCB1c2UgYXV4aWxpYXJ5IG9yIGludGVycG9sYXRpb24gcXVhbGlmaWVycyBvbiBhIGZ1bmN0aW9uIHBhcmFtZXRlcgBjYW5ub3QgdXNlIGxheW91dCBxdWFsaWZpZXJzIG9uIGEgZnVuY3Rpb24gcGFyYW1ldGVyAGNhbm5vdCB1c2UgaW52YXJpYW50IHF1YWxpZmllciBvbiBhIGZ1bmN0aW9uIHBhcmFtZXRlcgBxdWFsaWZpZXIgaGFzIG5vIGVmZmVjdCBvbiBub24tb3V0cHV0IHBhcmFtZXRlcnMAY2Fubm90IG5lc3QgYSBibG9jayBkZWZpbml0aW9uIGluc2lkZSBhIHN0cnVjdHVyZSBvciBibG9jawBjYW5ub3QgbmVzdCBhIHN0cnVjdHVyZSBkZWZpbml0aW9uIGluc2lkZSBhIHN0cnVjdHVyZSBvciBibG9jawBjYW4ndCB1c2Ugd2l0aCBzYW1wbGVycyBvciBzdHJ1Y3RzIGNvbnRhaW5pbmcgc2FtcGxlcnMAY2FuJ3QgdXNlIHdpdGggcmVmZXJlbmNlIHR5cGVzAGNhbid0IHVzZSB3aXRoIHR5cGVzIGNvbnRhaW5pbmcgYXJyYXlzIHNpemVkIHdpdGggYSBzcGVjaWFsaXphdGlvbiBjb25zdGFudABjYW5ub3QgdXNlIHN0b3JhZ2Ugb3IgaW50ZXJwb2xhdGlvbiBxdWFsaWZpZXJzIG9uIHN0cnVjdHVyZSBtZW1iZXJzAGNhbm5vdCB1c2UgbWVtb3J5IHF1YWxpZmllcnMgb24gc3RydWN0dXJlIG1lbWJlcnMAY2Fubm90IHVzZSBsYXlvdXQgcXVhbGlmaWVycyBvbiBzdHJ1Y3R1cmUgbWVtYmVycwBjYW5ub3QgdXNlIGludmFyaWFudCBxdWFsaWZpZXIgb24gc3RydWN0dXJlIG1lbWJlcnMAaW5kdWN0aXZlLWxvb3AgaW5pdC1kZWNsYXJhdGlvbiByZXF1aXJlcyB0aGUgZm9ybSAidHlwZS1zcGVjaWZpZXIgbG9vcC1pbmRleCA9IGNvbnN0YW50LWV4cHJlc3Npb24iAGluZHVjdGl2ZSBsb29wIHJlcXVpcmVzIGEgc2NhbGFyICdpbnQnIG9yICdmbG9hdCcgbG9vcCBpbmRleABpbmR1Y3RpdmUtbG9vcCBjb25kaXRpb24gcmVxdWlyZXMgdGhlIGZvcm0gImxvb3AtaW5kZXggPGNvbXBhcmlzb24tb3A+IGNvbnN0YW50LWV4cHJlc3Npb24iAGluZHVjdGl2ZS1sb29wIHRlcm1pbmF0aW9uIHJlcXVpcmVzIHRoZSBmb3JtICJsb29wLWluZGV4KyssIGxvb3AtaW5kZXgtLSwgbG9vcC1pbmRleCArPSBjb25zdGFudC1leHByZXNzaW9uLCBvciBsb29wLWluZGV4IC09IGNvbnN0YW50LWV4cHJlc3Npb24iAAjgAwBzY2FsYXIgYmxvY2sgbGF5b3V0AGltYWdlIGxvYWQtc3RvcmUgZm9ybWF0AGltYWdlIGxvYWQgc3RvcmUAAAAARuADAHBhc3N0aHJvdWdoAP7hAwBnZW9tZXRyeSBzaGFkZXIgcGFzc3Rocm91Z2gAb3JpZ2luX3VwcGVyX2xlZnQAcGl4ZWxfY2VudGVyX2ludGVnZXIAAJLdAwCN3wMAcG9zdCBkZXB0aCBjb3ZlcmFnZQBkZXB0aCBsYXlvdXQgcXVhbGlmaWVyAGZyYWdtZW50IHNoYWRlciBpbnRlcmxvY2sgbGF5b3V0IHF1YWxpZmllcgAAANDdAwCv4gMAYmxlbmRfc3VwcG9ydAB1bmtub3duIGJsZW5kIGVxdWF0aW9uAG92ZXJyaWRlX2NvdmVyYWdlAADa4QMAc2FtcGxlIG1hc2sgb3ZlcnJpZGUgY292ZXJhZ2UAdmlld3BvcnRfcmVsYXRpdmUAjVwEAHZpZXcgcG9ydCBhcnJheTIAc2hhZGVycmVjb3JkbnYAZGVyaXZhdGl2ZV9ncm91cF8AAAD84gMAY29tcHV0ZSBzaGFkZXIgZGVyaXZhdGl2ZXMAZGVyaXZhdGl2ZV9ncm91cF9xdWFkc252AGRlcml2YXRpdmVfZ3JvdXBfbGluZWFybnYAdW5yZWNvZ25pemVkIGxheW91dCBpZGVudGlmaWVyLCBvciBxdWFsaWZpZXIgcmVxdWlyZXMgYXNzaWdubWVudCAoZS5nLiwgYmluZGluZyA9IDQpAADAzAIA18wCAOzMAgACzQIAF80CAC3NAgBGzQIAXs0CAHbNAgCOzQIAp80CAL/NAgDVzQIA8s0CAArOAgAnzgIAYmxlbmRfc3VwcG9ydF9tdWx0aXBseQBibGVuZF9zdXBwb3J0X3NjcmVlbgBibGVuZF9zdXBwb3J0X292ZXJsYXkAYmxlbmRfc3VwcG9ydF9kYXJrZW4AYmxlbmRfc3VwcG9ydF9saWdodGVuAGJsZW5kX3N1cHBvcnRfY29sb3Jkb2RnZQBibGVuZF9zdXBwb3J0X2NvbG9yYnVybgBibGVuZF9zdXBwb3J0X2hhcmRsaWdodABibGVuZF9zdXBwb3J0X3NvZnRsaWdodABibGVuZF9zdXBwb3J0X2RpZmZlcmVuY2UAYmxlbmRfc3VwcG9ydF9leGNsdXNpb24AYmxlbmRfc3VwcG9ydF9oc2xfaHVlAGJsZW5kX3N1cHBvcnRfaHNsX3NhdHVyYXRpb24AYmxlbmRfc3VwcG9ydF9oc2xfY29sb3IAYmxlbmRfc3VwcG9ydF9oc2xfbHVtaW5vc2l0eQBibGVuZF9zdXBwb3J0X2FsbF9lcXVhdGlvbnMAAFTOAgBezgIAbM4CAHfOAgBkZXB0aF9hbnkAZGVwdGhfZ3JlYXRlcgBkZXB0aF9sZXNzAGRlcHRoX3VuY2hhbmdlZABsYXlvdXQtaWQgdmFsdWUAbm9uLWxpdGVyYWwgbGF5b3V0LWlkIHZhbHVlAGNhbm5vdCBiZSBuZWdhdGl2ZQAAANTbAwCE3AMAbmVlZHMgYSBsaXRlcmFsIGludGVnZXIAdW5pZm9ybSBidWZmZXItbWVtYmVyIGFsaWduAG11c3QgYmUgYSBwb3dlciBvZiAyAGxvY2F0aW9uIGlzIHRvbyBsYXJnZQBzZXQgaXMgdG9vIGxhcmdlAGRlc2NyaXB0b3Igc2V0AGJpbmRpbmcgaXMgdG9vIGxhcmdlAHNwZWNpYWxpemF0aW9uLWNvbnN0YW50IGlkIGlzIHRvbyBsYXJnZQBzcGVjaWFsaXphdGlvbi1jb25zdGFudCBpZCBhbHJlYWR5IHVzZWQAY29tcG9uZW50IGlzIHRvbyBsYXJnZQB4ZmJfAHRyYW5zZm9ybSBmZWVkYmFjayBxdWFsaWZpZXIAYnVmZmVyIGlzIHRvbyBsYXJnZToAZ2xfTWF4VHJhbnNmb3JtRmVlZGJhY2tCdWZmZXJzIGlzICVkAGludGVybmFsIG1heCBpcyAlZABvZmZzZXQgaXMgdG9vIGxhcmdlOgAxLzQgc3RyaWRlIGlzIHRvbyBsYXJnZToAZ2xfTWF4VHJhbnNmb3JtRmVlZGJhY2tJbnRlcmxlYXZlZENvbXBvbmVudHMgaXMgJWQAc3RyaWRlIGlzIHRvbyBsYXJnZToAYXR0YWNobWVudCBpbmRleCBpcyB0b28gbGFyZ2UAAAB75gMAjOYDAHNlY29uZGFyeV92aWV3X29mZnNldAAAAEpcBABzdGVyZW8gdmlldyByZW5kZXJpbmcAYnVmZmVyX3JlZmVyZW5jZV9hbGlnbgBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwAG11c3QgYmUgYXQgbGVhc3QgMQB0b28gbGFyZ2UsIG11c3QgYmUgbGVzcyB0aGFuIGdsX01heEdlb21ldHJ5T3V0cHV0VmVydGljZXMAc2VsZWN0aW5nIG91dHB1dCBzdHJlYW0AaW5kZXggbGF5b3V0IHF1YWxpZmllciBvbiBmcmFnbWVudCBvdXRwdXQAdmFsdWUgbXVzdCBiZSAwIG9yIDEAdG9vIGxhcmdlLCBtdXN0IGJlIGxlc3MgdGhhbiBnbF9NYXhNZXNoT3V0cHV0VmVydGljZXNOVgB0b28gbGFyZ2UsIG11c3QgYmUgbGVzcyB0aGFuIGdsX01heE1lc2hPdXRwdXRQcmltaXRpdmVzTlYAbG9jYWxfc2l6ZV8AZ2xfV29ya0dyb3VwU2l6ZQBsb2NhbF9zaXplX3gAbG9jYWxfc2l6ZV95AGxvY2FsX3NpemVfegBsb2NhbF9zaXplX3hfaWQAbG9jYWxfc2l6ZV95X2lkAGxvY2FsX3NpemVfel9pZAB0aGVyZSBpcyBubyBzdWNoIGxheW91dCBpZGVudGlmaWVyIGZvciB0aGlzIHN0YWdlIHRha2luZyBhbiBhc3NpZ25lZCB2YWx1ZQBjYW5ub3QgdXNlIGluIGEgYmxvY2sgYXJyYXkgd2hlcmUgbmV3IGxvY2F0aW9ucyBhcmUgbmVlZGVkIGZvciBlYWNoIGJsb2NrIGVsZW1lbnQAYXJyYXkgbXVzdCBiZSBleHBsaWNpdGx5IHNpemVkAGF0b21pYyBjb3VudGVycyBzaGFyaW5nIHRoZSBzYW1lIG9mZnNldDoAYXRvbWljX3VpbnQgYmluZGluZyBpcyB0b28gbGFyZ2UAdXNlbGVzcyBhcHBsaWNhdGlvbiBvZiBsYXlvdXQgcXVhbGlmaWVyAGV4cGVjdGVkIGZvdXIgdHlwZSBwYXJhbWV0ZXJzAGV4cGVjdGVkIDE2LCAzMiwgb3IgNjQgYml0cyBmb3IgZmlyc3QgdHlwZSBwYXJhbWV0ZXIAZXhwZWN0ZWQgOCBvciAzMiBiaXRzIGZvciBmaXJzdCB0eXBlIHBhcmFtZXRlcgB1bmV4cGVjdGVkIHR5cGUgcGFyYW1ldGVycwB2YXJpYWJsZXMgd2l0aCByZWZlcmVuY2UgdHlwZSBjYW4ndCBoYXZlIHF1YWxpZmllciAnY29uc3QnAHF1YWxpZmllcgBDb29wZXJhdGl2ZSBtYXRyaXggdHlwZXMgbXVzdCBub3QgYmUgdXNlZCBpbiBzaGFyZWQgbWVtb3J5AGNhbiBvbmx5IGFwcGx5IG9yaWdpbl91cHBlcl9sZWZ0IGFuZCBwaXhlbF9jZW50ZXJfb3JpZ2luIHRvIGdsX0ZyYWdDb29yZABsYXlvdXQgcXVhbGlmaWVyAGNhbiBvbmx5IGFwcGx5IGRlcHRoIGxheW91dCB0byBnbF9GcmFnRGVwdGgAY2Fubm90IGNoYW5nZSB0aGUgdHlwZSBvZgBpbml0aWFsaXplciByZXF1aXJlcyBhIHZhcmlhYmxlLCBub3QgYSBtZW1iZXIAIGNhbm5vdCBpbml0aWFsaXplIHRoaXMgdHlwZSBvZiBxdWFsaWZpZXIgAGFycmF5IGluaXRpYWxpemVyAHVuaWZvcm0gaW5pdGlhbGl6ZXJzIG11c3QgYmUgY29uc3RhbnQAJyVzJwBnbG9iYWwgY29uc3QgaW5pdGlhbGl6ZXJzIG11c3QgYmUgY29uc3RhbnQAbm9uLWNvbnN0YW50IGluaXRpYWxpemVyAG5vbi1jb25zdGFudCBnbG9iYWwgaW5pdGlhbGl6ZXIgKG5lZWRzIEdMX0VYVF9zaGFkZXJfbm9uX2NvbnN0YW50X2dsb2JhbF9pbml0aWFsaXplcnMpAG5vbi1tYXRjaGluZyBvciBub24tY29udmVydGlibGUgY29uc3RhbnQgdHlwZSBmb3IgY29uc3QgaW5pdGlhbGl6ZXIAd3JvbmcgbnVtYmVyIG9mIHN0cnVjdHVyZSBtZW1iZXJzAGluaXRpYWxpemVyIGxpc3QAd3JvbmcgbnVtYmVyIG9mIG1hdHJpeCBjb2x1bW5zOgB3cm9uZyB2ZWN0b3Igc2l6ZSAob3Igcm93cyBpbiBhIG1hdHJpeCBjb2x1bW4pOgB1bmV4cGVjdGVkIGluaXRpYWxpemVyLWxpc3QgdHlwZToAYXJyYXktb2YtYXJyYXkgb2YgYmxvY2sAbWVtYmVyIHN0b3JhZ2UgcXVhbGlmaWVyIGNhbm5vdCBjb250cmFkaWN0IGJsb2NrIHN0b3JhZ2UgcXVhbGlmaWVyAG1lbWJlciBvZiB1bmlmb3JtIG9yIGJ1ZmZlciBibG9jayBjYW5ub3QgaGF2ZSBhbiBhdXhpbGlhcnkgb3IgaW50ZXJwb2xhdGlvbiBxdWFsaWZpZXIAb2Zmc2V0IG9uIGJsb2NrIG1lbWJlcgBtZW1iZXIgb2YgYmxvY2sgY2Fubm90IGJlIG9yIGNvbnRhaW4gYSBzYW1wbGVyLCBpbWFnZSwgb3IgYXRvbWljX3VpbnQgdHlwZQBtZW1iZXIgb2YgYmxvY2sgY2Fubm90IGJlIG9yIGNvbnRhaW4gYSBjb29wZXJhdGl2ZSBtYXRyaXggdHlwZQBjYW4gb25seSBiZSB1c2VkIHdpdGggc3RkMTQwLCBzdGQ0MzAsIG9yIHNjYWxhciBsYXlvdXQgcGFja2luZwBtZW1iZXIgY2Fubm90IGNvbnRyYWRpY3QgYmxvY2sAbWVtYmVyIG9mIGJsb2NrIGNhbm5vdCBoYXZlIGEgcGFja2luZyBsYXlvdXQgcXVhbGlmaWVyAGxvY2F0aW9uIG9uIGJsb2NrIG1lbWJlcgBjYW4gb25seSB1c2UgaW4gYW4gaW4vb3V0IGJsb2NrAG9mZnNldC9hbGlnbgBibG9jayBuYW1lIGNhbm5vdCBiZSByZWRlZmluZWQAQ2Fubm90IHJldXNlIGJsb2NrIG5hbWUgd2l0aGluIHRoZSBzYW1lIGludGVyZmFjZToAYmxvY2sgbmFtZSBjYW5ub3QgcmVkZWZpbmUgYSBub24tYmxvY2sgbmFtZQBuYW1lbGVzcyBibG9jayBjb250YWlucyBhIG1lbWJlciB0aGF0IGFscmVhZHkgaGFzIGEgbmFtZSBhdCBnbG9iYWwgc2NvcGUAYmxvY2sgaW5zdGFuY2UgbmFtZSByZWRlZmluaXRpb24AbXVzdCBiZSBhIG11bHRpcGxlIG9mIHRoZSBtZW1iZXIncyBhbGlnbm1lbnQAY2Fubm90IGxpZSBpbiBwcmV2aW91cyBtZW1iZXJzAGVpdGhlciB0aGUgYmxvY2sgbmVlZHMgYSBsb2NhdGlvbiwgb3IgYWxsIG1lbWJlcnMgbmVlZCBhIGxvY2F0aW9uLCBvciBubyBtZW1iZXJzIGhhdmUgYSBsb2NhdGlvbgBjYW5ub3QgYXBwbHkgdG8gYSBibG9jawBjYW5ub3QgdXNlIGludGVycG9sYXRpb24gcXVhbGlmaWVycyBvbiBhbiBpbnRlcmZhY2UgYmxvY2sAY2Fubm90IHVzZSBjZW50cm9pZCBxdWFsaWZpZXIgb24gYW4gaW50ZXJmYWNlIGJsb2NrAGNhbm5vdCB1c2Ugc2FtcGxlIHF1YWxpZmllciBvbiBhbiBpbnRlcmZhY2UgYmxvY2sAY2Fubm90IHVzZSBpbnZhcmlhbnQgcXVhbGlmaWVyIG9uIGFuIGludGVyZmFjZSBibG9jawB1bmlmb3JtIGJsb2NrAHN0ZDQzMCByZXF1aXJlcyB0aGUgYnVmZmVyIHN0b3JhZ2UgcXVhbGlmaWVyAGJ1ZmZlciBibG9jawBpbnB1dCBibG9jawBmcmFnbWVudCBpbnB1dCBibG9jawBpbnB1dCBibG9ja3MgY2Fubm90IGJlIHVzZWQgaW4gYSBtZXNoIHNoYWRlcgBvdXRwdXQgYmxvY2sAdmVydGV4IG91dHB1dCBibG9jawBjYW4gb25seSB1c2Ugb24gaW5wdXQgYmxvY2tzIGluIG1lc2ggc2hhZGVyAG91dHB1dCBibG9ja3MgY2Fubm90IGJlIHVzZWQgaW4gYSB0YXNrIHNoYWRlcgByYXlQYXlsb2FkTlYgYmxvY2sAcmF5UGF5bG9hZEluTlYgYmxvY2sAaGl0QXR0cmlidXRlTlYgYmxvY2sAY2FsbGFibGVEYXRhTlYgYmxvY2sAY2FsbGFibGVEYXRhSW5OViBibG9jawBvbmx5IHVuaWZvcm0sIGJ1ZmZlciwgaW4sIG9yIG91dCBibG9ja3MgYXJlIHN1cHBvcnRlZABpZGVudGlmaWVyIG5vdCBwcmV2aW91c2x5IGRlY2xhcmVkAGNhbm5vdCByZS1xdWFsaWZ5IGEgZnVuY3Rpb24gbmFtZQBjYW5ub3QgYWRkIHN0b3JhZ2UsIGF1eGlsaWFyeSwgbWVtb3J5LCBpbnRlcnBvbGF0aW9uLCBsYXlvdXQsIG9yIHByZWNpc2lvbiBxdWFsaWZpZXIgdG8gYW4gZXhpc3RpbmcgdmFyaWFibGUAY2Fubm90IGNoYW5nZSBxdWFsaWZpY2F0aW9uIGFmdGVyIHVzZQB1bmtub3duIHJlcXVhbGlmaWNhdGlvbgBjYW4gb25seSBhcHBseSB0byAnb3V0JwBjYW5ub3QgY2hhbmdlIHByZXZpb3VzbHkgc2V0IGxheW91dCB2YWx1ZQBjYW4gb25seSBhcHBseSB0byAnaW4nAGNhbm5vdCBhcHBseSB0byBpbnB1dABjYW5ub3QgY2hhbmdlIHByZXZpb3VzbHkgc2V0IGlucHV0IHByaW1pdGl2ZQBjYW5ub3QgYXBwbHkgdG8gJ291dCcAY2Fubm90IGNoYW5nZSBwcmV2aW91c2x5IHNldCBvdXRwdXQgcHJpbWl0aXZlAGNhbm5vdCBhcHBseSB0bzoAY2Fubm90IGNoYW5nZSBwcmV2aW91c2x5IHNldCB2ZXJ0ZXggc3BhY2luZwBjYW5ub3QgY2hhbmdlIHByZXZpb3VzbHkgc2V0IHZlcnRleCBvcmRlcgBjYW5ub3QgY2hhbmdlIHByZXZpb3VzbHkgc2V0IHNpemUAdG9vIGxhcmdlOyBzZWUgZ2xfTWF4Q29tcHV0ZVdvcmtHcm91cFNpemUAdG9vIGxhcmdlOyBzZWUgZ2xfTWF4TWVzaFdvcmtHcm91cFNpemVOVgB0b28gbGFyZ2U7IHNlZSBnbF9NYXhUYXNrV29ya0dyb3VwU2l6ZU5WAHBvc3RfY292ZXJhZ2VfY292ZXJhZ2UAY2Fubm90IGNoYW5nZSBwcmV2aW91c2x5IHNldCBmcmFnbWVudCBzaGFkZXIgaW50ZXJsb2NrIG9yZGVyaW5nAGNhbm5vdCBiZSBib3RoIHNwZWNpZmllZABkZXJpdmF0aXZlX2dyb3VwX3F1YWRzTlYgYW5kIGRlcml2YXRpdmVfZ3JvdXBfbGluZWFyTlYAcmVxdWlyZXMgbG9jYWxfc2l6ZV94IGFuZCBsb2NhbF9zaXplX3kgdG8gYmUgbXVsdGlwbGUgb2YgdHdvAGRlcml2YXRpdmVfZ3JvdXBfcXVhZHNOVgByZXF1aXJlcyB0b3RhbCBncm91cCBzaXplIHRvIGJlIG11bHRpcGxlIG9mIGZvdXIAZGVyaXZhdGl2ZV9ncm91cF9saW5lYXJOVgBjYW5ub3QgdXNlIGF1eGlsaWFyeSwgbWVtb3J5LCBpbnRlcnBvbGF0aW9uLCBvciBwcmVjaXNpb24gcXVhbGlmaWVyIGluIGEgZGVmYXVsdCBxdWFsaWZpZXIgZGVjbGFyYXRpb24gKGRlY2xhcmF0aW9uIHdpdGggbm8gdHlwZSkAY2Fubm90IHVzZSBvZmZzZXQgb3IgYWxpZ24gcXVhbGlmaWVycyBpbiBhIGRlZmF1bHQgcXVhbGlmaWVyIGRlY2xhcmF0aW9uIChkZWNsYXJhdGlvbiB3aXRoIG5vIHR5cGUpAGRlZmF1bHQgcXVhbGlmaWVyIHJlcXVpcmVzICd1bmlmb3JtJywgJ2J1ZmZlcicsICdpbicsIG9yICdvdXQnIHN0b3JhZ2UgcXVhbGlmaWNhdGlvbgBjYW5ub3QgZGVjbGFyZSBhIGRlZmF1bHQsIGluY2x1ZGUgYSB0eXBlIG9yIGZ1bGwgZGVjbGFy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Cjv+5QA7/jv+NRw7/jv+O/5ZAMcgOgncADv+O/6iBzv+4ADQADv+O/6iB+IAO/47/gAAAAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkASUBJgEnASgBKQEqASsBLAEtAS4BLwEwATEBMgEzATQBNQE2ATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAEGy4AsLspIBQQEAAMcBAABmATsBOgFpAQAAawFsAUEBTQFvAQQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AAwCOgE/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEAYgBjAGQAZQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAHMAdAB1AHYAdwB4AHkAegB7AHwAfQB+AH8AgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAAoQCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcAyADJAMoAywDMAM0AzgDPANAA0QDSANMA1ADVANYA1wDYANkA2gDbANwA3QDeAN8A4ADhAOIA4wDkAOUA5gDnAOgA6QDqAOsA7ADtAO4A7wDwAPEA8gDzAPQA9QD2APcA+AD5APoA+wD8AP0A/gD/AAABAQECAQMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEjASQBVQFdAaABegH6AQYCmAEIAo0BgAELAkQCxQGQAikBKgEuAUQBXgE8AT4BJQEmAToBXgE8AXYBRAE8AXIBlQGWAUMBKwEsATwBRAFVATsBcwG6AawCQwFeAUEBXQFVATsBhQFMAU0BUQFeAWUBXQFlAWgBZQFfAScBKAE8AWUBZAFlAbcCcgHIAUMBPQF2ATsBvgJBAegBcgHqAUEBOgF2ATwBPAFIAskCQAGFAdsBPgFDATsBQQE7ATsBRAGFAUEBkAFBAUEBQQE7AWYCRAHDAUEBkAFBAUQBQQEmAkEBRAHFAUQBxwFEAQYCQQEIAhUCRAELAjABMQEyATMBNAE1ATYBNwE4ATkBUwFUAVUBGQIyAjMCNAI1AkEBQwFBAUQBSQFKAUsBwwHNAsUBRgHHAUgBjwKbAj8BwwFBAcUBTAHHAUEBQgFBAUIBLgIvAj4BMAIxAiECPgFKAl4BPAFeAU4CagI2AjcCXgFEAUMBDAJeATsBOgE8AV4BXgFQAU8BLQEvAcMCTgE9ATwBOgE/AUQBRAH6AV0CXgJCAToBOgE6ASYCRAH6AWYCRAE6AToBXgFeATsBPQEMAtMCPQFeAToBQQFmAT8BPQEMAjsBOgFeATsBPgFDAYoCRAE7AT4BagE/AZACPgFEATgCJgI5AjwCOgKhAjsCygEoAT0CJgJ0AnIBkgJ2ASACvQJ2AckCcAGbAsoCkgKsAgQCrAIEAqMCBAL/////RAJqAv////9IAmUBuAL//6ECRAL//7EC//9IAv/////////////////////IAv///////////////8MC/////////////////////2oCkAL//////////////////2oC//////////////////+nAv////////////////////////////+sAv//////////////////jwKQAv//kgL/////////////jwKQAv//kgL/////////////////////////////pwL//////////6wC////////pwL//////////6wC//+3Av///////////////74C//+3Av///////////////74C///JAv///////80C///////////JAtMC/////80C////////AAD//9MCAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf//////////////////////////////////////////////////////////////////////////////////RAH//////////////////////////////////1IBUwFUAVUBVgH/////////////////////XwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwH/////////////////////gAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////8nASgB/////////////////////////////////////////////zoB//88Af//PgE/Af//////////RAFFAUYBRwFIAf///////////////////////1IBUwFUAVUBVgH///////9aAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAf//awFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////8nASgB/////////////////////////////////////////////zoB//88Af//PgE/Af//////////RAFFAUYBRwFIAf///////////////////////1IBUwFUAVUBVgH///////9aAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAf//awFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////8nASgB/////////////////////////////////////////////zoB//88Af//PgH/////////////RAFFAUYBRwFIAf///////////////////////1IBUwFUAVUBVgH///////9aAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAf//awFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////8nASgB/////////////////////////////////////////////zoB//88Af//PgH/////////////RAFFAUYBRwFIAf///////////////////////1IBUwFUAVUBVgH///////9aAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAf//awFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////8nASgB/////////////////////////////////////////////zoB//88Af//////////////////RAFFAUYBRwFIAf///////////////////////1IBUwFUAVUBVgH///////9aAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAf//awFsAW0BbgFvAXABcQFyAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////8nASgB/////////////////////////////////////////////zoB////////////////////////RAFFAUYBRwFIAf///////////////////////1IBUwFUAVUBVgH///////9aAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////8nASgB/////////////////////////////////////////////zoB//////////////////////////9FAUYBRwFIAf///////////////////////1IBUwFUAVUB//////////9aAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwF4AXkBegF7AXwBfQF+AX8BgAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf//////////////////////////////////////////////////////////////////////////////////RAH//////////////////////////////////1IBUwFUAVUBVgH/////////////////////XwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwH/////////////////////gAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf//////////////////////////////////////////////////////////////////////////////////RAH//////////////////////////////////1IBUwFUAVUB/////////////////////14BXwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwH/////////////////////gAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////////////////////////////////////////////////////////////////////8/Af///////////////////////////////////////////////1IBUwFUAVUB////////////////////////XwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwH/////////////////////gAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////////////////////////////////////////////////////////////////////8/Af///////////////////////////////////////////////1IBUwFUAVUB////////////////////////XwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwH/////////////////////gAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf////////////////////////////////////////////////////////////////////8/Af///////////////////////////////////////////////1IBUwFUAVUB////////////////////////XwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwH/////////////////////gAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBIwEkAf///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IBUwFUAVUB////////////////////////XwFgAWEBYgFjAWQBZQH///////////////////////////////9yAXMBdAF1AXYBdwH/////////////////////gAH//4IBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwA/////z8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAH/////JwEoAf////////////////////////////////////////////86Af///////z4BPwH/////////////RQFGAUcBSAH/////////////////////////////////////////////WgFbAVwBXQFeAV8B//////////9kAWUB////////////////////////////////////////////////eAF5AXoBewF8AX0BfgF/Af///////////////////////4kBBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwA/////z8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAH/////JwEoAf////////////////////////////////////////////86Af////89Af//////////////////RQFGAUcBSAH/////////////////////////////////////////////WgFbAVwBXQFeAV8B//////////9kAWUB////////////////////////////////////////////////eAF5AXoBewF8AX0BfgF/Af///////////////////////4kBBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwA/////z8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAH/////JwEoAf////////////////////////////////////////////86Af///////z4B////////////////RQFGAUcBSAH/////////////////////////////////////////////WgFbAVwBXQFeAV8B//////////9kAWUB////////////////////////////////////////////////eAF5AXoBewF8AX0BfgF/Af///////////////////////4kBBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwA/////z8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAH/////JwEoAf////////////////////////////////////////////86Af////89Af//////////////////RQFGAUcBSAH/////////////////////////////////////////////WgFbAVwBXQFeAV8B//////////9kAWUB////////////////////////////////////////////////eAF5AXoBewF8AX0BfgF/Af///////////////////////4kBBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwA/////z8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAH/////JwEoAf////////////////////////////////////////////86Af///////////////////////0QBRQFGAUcBSAH/////////////////////////////////////////////WgFbAVwBXQFeAV8B//////////9kAWUB////////////////////////////////////////////////eAF5AXoBewF8AX0BfgF/Af///////////////////////4kBBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwA/////z8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAH/////JwEoAf////////////////////////////////////////////86Af//////////////////////////RQFGAUcBSAH/////////////////////////////////////////////WgFbAVwBXQFeAV8B//////////9kAWUB////////////////////////////////////////////////eAF5AXoBewF8AX0BfgF/Af///////////////////////4kBBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwA/////z8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAH/////JwEoAf//fwH//////////////////////////////////40B//86Af//////////////////////////RQFGAUcBSAGeAZ8B////////////////////////////////////////WgFbAVwBXQFeAV8B//////////9kAWUB/////70B///////////////////////////IAf//////////eAF5AXoBewF8AX0BfgF/Af///////////////9sB/////4kB////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////HgL///////////////////////////////8rAiwCLQIuAi8CMAIxAjICMwI0AjUCNgI3AjgCOQI6AjsCPAI9Av///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////6ECAEHw8gwLpAlhAR4CUAEmAlIB4QHJAWsB5AFgAeUB5gHKAR8C6QECAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgBqAmwBPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiAXYBfQESApkBYQJlAgkCZwLaAcEBaQKPAiUCpgIyAjMCPQJtAYcBjQFpATACMQKXAXoBjQF9AY4B2wF2AQUCBwKYATYCNwKNAdwBdwHLAYgBGwKmAgYCbgHMAX4BYAFxAcMBNAI1Aj4CagFhAWABUAGEAVIBKQETAhQC2wFgAS4BLwHEAncBJwILAqICdwEYAswCowJNAmABTwIZAt7/YAEVAtsBkQLEAhYCxAFBApoBZgJsApsBrQKuApwBYAFeAvQBXgJeAngBzwKZAnkBfQEOAvMBXgIPAl4CJQJ0Al8CwwF1AsMBbwEJAl4CCQJuApQCCQJSAlMCVAJVAlYCVwJYAlkCWgJbAiUBJgEnAXACfgJ/AoACgQJ0AlwCcgGeAisCLAItAiAC0wLEAS4CxAEvAmECsAKaAmABmwJgAX8BYAFeApYCXgKxAnoCewKGAXwCfQJzApABkwKLAY0BlQGVAiUCggKDApYBwgHIAcMBDQIXAhwC2wEhAioCOAI5AjsCPALOAjoCPwJCAkUCQwJGAkcC9AGXApgCUAJJAkoCTgLDAUsC8wEJAlEC3f/f/2sCbwLk/4sCxAFhAp0CjAKhAl4CqQK1ArMCYAG3ArgCtgLCAvH9wwKgAsgCyQLeAcoC1gKlAs0C1QKEAsQBhQKIAoYCsgKHAikCaAGJAmABnwKSAaoCkwFyAssClAHRApEBCQLSAqsCuQJiAqUCYwK0AmQCAAAAAPQBwwEAAAAA9AGDAccCAAAnAvMBAADBAgAA8wEAQaT8DAsC0AIAQbL8DAsCCQIAQcT8DAsExAGnAgBB1vwMCwJgAQBB5vwMCwJ9AQBB/vwMCwKnAgBBjv0MCwj0AfQBAAD0AQBBoP0MCwjzAfMBAADzAQBBvv0MCwJ+AQBByP0MCwr0AQAAAAAAAGABAEHa/QwLBvMBAAD0AQBB7P0MCwb0AQAA8wEAQf79DAsO8wEAAPQBAAAAAAAA9AEAQZT+DAvaBPMB9AEAAAAA8wEAAAAAAACCAQAA8wEBAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBAEGsgw0LAiMBAEHIgw0LCiQBJQEmAScBKAEAQeKDDQsOKQEqASsBLAEtAS4BLwEAQYiEDQsMMAExATIBMwE0ATUBAEGkhA0LggU2AQAANwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwEBAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBAAAAAJ4BnwEAQciJDQsMoAEAAN0BAADeAd8BAEHciQ0LCuABoQGiAaMBpAEAQfiJDQveBSQBJQEmAScBKAEAAAAAAAClAaYBpwGoAakBKQEqASsBLAEtAS4BLwHhAeIB4wHkAQAA5QHmAecB6AHpAeoB6wEwATEBMgEzATQBNQGqAasBrAGtAa4BrwGwAbEBNgHsATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BAQACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiAQAAAACeAZ8BAEH4jw0LDKABAADdAQAA3gFgAgBBjJANCwrgAaEBogGjAaQBAEGokA0L3gUkASUBJgEnASgBAAAAAAAApQGmAacBqAGpASkBKgErASwBLQEuAS8B4QHiAeMB5AEAAOUB5gHnAegB6QHqAesBMAExATIBMwE0ATUBqgGrAawBrQGuAa8BsAGxATYB7AE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAQEAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEAYgBjAGQAZQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAHMAdAB1AHYAdwB4AHkAegB7AHwAfQB+AH8AgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAAoQCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcAyADJAMoAywDMAM0AzgDPANAA0QDSANMA1ADVANYA1wDYANkA2gDbANwA3QDeAN8A4ADhAOIA4wDkAOUA5gDnAOgA6QDqAOsA7ADtAO4A7wDwAPEA8gDzAPQA9QD2APcA+AD5APoA+wD8AP0A/gD/AAABAQECAQMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEAAAAAngGfAQBBqJYNCwqgAQAA3QEAAN4BAEG8lg0LCuABoQGiAaMBpAEAQdiWDQveBSQBJQEmAScBKAEAAAAAAAClAaYBpwGoAakBKQEqASsBLAEtAS4BLwHhAeIB4wHkAQAA5QHmAecB6AHpAeoB6wEwATEBMgEzATQBNQGqAasBrAGtAa4BrwGwAbEBNgHsATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BAQACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiAQAAAACeAZ8BAEHYnA0LCqABAADdAQAAkAEAQeycDQsK4AGhAaIBowGkAQBBiJ0NC94FJAElASYBJwEoAQAAAAAAAKUBpgGnAagBqQEpASoBKwEsAS0BLgEvAeEB4gHjAeQBAADlAeYB5wHoAekB6gHrATABMQEyATMBNAE1AaoBqwGsAa0BrgGvAbABsQE2AewBNwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwEBAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBAAAAAJ4BnwEAQYijDQsGoAEAAN0BAEGcow0LCuABoQGiAaMBpAEAQbijDQveBSQBJQEmAScBKAEAAAAAAAClAaYBpwGoAakBKQEqASsBLAEtAS4BLwHhAeIB4wHkAQAA5QHmAecB6AHpAeoB6wEwATEBMgEzATQBNQGqAasBrAGtAa4BrwGwAbEBNgHsATcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BAQACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiAQAAAACeAZ8BAEG4qQ0LAqABAEHMqQ0LCuABoQGiAaMBpAEAQeipDQsoJAElASYBJwEoAQAAAAAAAKUBpgGnAagBqQEpASoBKwEsAS0BLgEvAQBBqKoNC54FMAExATIBMwE0ATUBqgGrAawBrQGuAa8BsAGxATYBAAA3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAQEAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEAYgBjAGQAZQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAHMAdAB1AHYAdwB4AHkAegB7AHwAfQB+AH8AgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAAoQCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcAyADJAMoAywDMAM0AzgDPANAA0QDSANMA1ADVANYA1wDYANkA2gDbANwA3QDeAN8A4ADhAOIA4wDkAOUA5gDnAOgA6QDqAOsA7ADtAO4A7wDwAPEA8gDzAPQA9QD2APcA+AD5APoA+wD8AP0A/gD/AAABAQECAQMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEAAAAAngGfAQBB6K8NCwKgAQBB/q8NCwihAaIBowGkAQBBmLANCwgkASUBJgEnAQBBqLANCxilAaYBpwGoAakBKQEqASsBLAEtAS4BLwEAQdiwDQuWBTABMQEyATMBNAE1AaoBqwGsAa0BrgGvAbABsQE2AQAANwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwEBAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBAEGstg0LAiMBAEHItg0LCiQBJQEmAScBKAEAQeK2DQsOKQEqASsBLAEtAS4BLwEAQYi3DQsMMAExATIBMwE0ATUBAEGktw0L+gQ2AQAANwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwEBAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBAEHcvA0LAnsBAEH4vA0LCCQBJQEmAScBAEGQvQ0LEHwBKQEqASsBLAEtAS4BLwEAQbi9DQsMMAExATIBMwE0ATUBAEHUvQ0L+gQ2AQAANwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwEBAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYAtwC4ALkAugC7ALwAvQC+AL8AwADBAMIAwwDEAMUAxgDHAMgAyQDKAMsAzADNAM4AzwDQANEA0gDTANQA1QDWANcA2ADZANoA2wDcAN0A3gDfAOAA4QDiAOMA5ADlAOYA5wDoAOkA6gDrAOwA7QDuAO8A8ADxAPIA8wD0APUA9gD3APgA+QD6APsA/AD9AP4A/wAAAQEBAgEDAQQBBQEGAQcBCAEJAQoBCwEMAQ0BDgEPARABEQESARMBFAEVARYBFwEYARkBGgEbARwBHQEeAR8BIAEhASIBAEGCww0LAiQCAEGoww0LCCQBJQEmAScBAEHCww0LDikBKgErASwBLQEuAS8BAEHoww0LDDABMQEyATMBNAE1AQBBhMQNC/oENgEAADcBOAE5AToBOwE8AT0BPgE/AUABQQFCAUMBRAFFAUYBRwFIAUkBSgFLAUwBTQFOAU8BAQACAAMABAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiAQBBsskNCwJ2AgBB2MkNCwgkASUBJgEnAQBB8skNCw4pASoBKwEsAS0BLgEvAQBBmMoNCwwwATEBMgEzATQBNQEAQbTKDQv6BDYBAAA3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAQEAAgADAAQABQAGAAcACAAJAAoACwAMAA0ADgAPABAAEQASABMAFAAVABYAFwAYABkAGgAbABwAHQAeAB8AIAAhACIAIwAkACUAJgAnACgAKQAqACsALAAtAC4ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAEYARwBIAEkASgBLAEwATQBOAE8AUABRAFIAUwBUAFUAVgBXAFgAWQBaAFsAXABdAF4AXwBgAGEAYgBjAGQAZQBmAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAHMAdAB1AHYAdwB4AHkAegB7AHwAfQB+AH8AgACBAIIAgwCEAIUAhgCHAIgAiQCKAIsAjACNAI4AjwCQAJEAkgCTAJQAlQCWAJcAmACZAJoAmwCcAJ0AngCfAKAAoQCiAKMApAClAKYApwCoAKkAqgCrAKwArQCuAK8AsACxALIAswC0ALUAtgC3ALgAuQC6ALsAvAC9AL4AvwDAAMEAwgDDAMQAxQDGAMcAyADJAMoAywDMAM0AzgDPANAA0QDSANMA1ADVANYA1wDYANkA2gDbANwA3QDeAN8A4ADhAOIA4wDkAOUA5gDnAOgA6QDqAOsA7ADtAO4A7wDwAPEA8gDzAPQA9QD2APcA+AD5APoA+wD8AP0A/gD/AAABAQECAQMBBAEFAQYBBwEIAQkBCgELAQwBDQEOAQ8BEAERARIBEwEUARUBFgEXARgBGQEaARsBHAEdAR4BHwEgASEBIgEAQeLPDQsCnAIAQYjQDQsIJAElASYBJwEAQaLQDQsOKQEqASsBLAEtAS4BLwEAQcjQDQsMMAExATIBMwE0ATUBAEHk0A0L+gQ2AQAANwE4ATkBOgE7ATwBPQE+AT8BQAFBAUIBQwFEAUUBRgFHAUgBSQFKAUsBTAFNAU4BTwEBAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0ATgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAGIAYwBkAGUAZgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgBzAHQAdQB2AHcAeAB5AHoAewB8AH0AfgB/AIAAgQCCAIMAhACFAIYAhwCIAIkAigCLAIwAjQCOAI8AkACRAJIAkwCUAJUAlgCXAJgAmQCaAJsAnACdAJ4AnwCgAKEAogCjAKQApQCmAKcAqACpAKoAqwCsAK0ArgCvALAAsQCyALMAtAC1ALYA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ADMANAA1ADYANwA4ADkAOgAAAAAAPQA+AD8AQABBAEIAQwBEAEUARgBHAEgASQBKAEsATABNAE4ATwBQAFEAUgBTAFQAVQBWAFcAWABZAFoAWwBcAF0AXgBfAGAAYQBiAGMAZABlAGYAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAcwB0AHUAdgB3AHgAeQB6AHsAfAB9AH4AfwCAAIEAggCDAIQAhQCGAIcAiACJAIoAiwCMAI0AjgCPAJAAkQCSAJMAlACVAJYAlwCYAJkAmgCbAJwAnQCeAJ8AoAChAKIAowCkAKUApgCnAKgAqQCqAKsArACtAK4ArwCwALEAsgCzALQAtQC2ALcAuAC5ALoAuwC8AL0AvgC/AMAAwQDCAMMAxADFAMYAxwDIAMkAygDLAMwAzQDOAM8A0ADRANIA0wDUANUA1gDXANgA2QDaANsA3ADdAN4A3wDgAOEA4gDjAOQA5QDmAOcA6ADpAOoA6wDsAO0A7gDvAPAA8QDyAPMA9AD1APYA9wD4APkA+gD7APwA/QD+AP8AAAEBAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiAQAAAACeAZ8BAAC8AQBB+oAOCwbOAQAAoAEAQZSBDgsMoQGiAaMBpAEQAhECAEG+gQ4LDKUBpgGnAagBqQEpAQBB0oEOCwouARoCAAAAAB0CAEHwgQ4LAs4BAEH6gQ4LEKoBqwGsAa0BrgGvAbABsQEAQZaCDgsIzgEAAAAAPgEAQZyDDgsCcQIAQbaDDgsmdwJ4AnkCzgHOAc4BzgHOAc4BzgHOAc4BzgHOAc4BzgHOAc4BzgEAQaKFDgsCzgEAQbKFDgu3BpwAywDJAMoAyADPANAA0QDSANMA1ADVANYA1wDMAM0AzgDYANkA2gDbANwA3QDeAN8A4ADhAOIA4wBHAUgBSQFKAUsBTAFNAWEBYgFjAWQBZQFmAWcBcAF9AX4BcQFyAXQBcwF1AXYBdwF4AXkBegF7AXwBpAClAOUA5gDkAOcA7gDvAOwA7QDqAOsA6ADpAAUBBgEHAREBEgETAQIBAwEEAQ4BDwEQAf8AAAEBAQsBDAENAfwA/QD+AAgBCQEKAfAA8QDyABQBFQEWAfMA9AD1ACABIQEiAfYA9wD4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ZCBsaXRlcmFsADY0LWJpdCBpbnRlZ2VyIGxpdGVyYWwANjQtYml0IHVuc2lnbmVkIGludGVnZXIgbGl0ZXJhbAAxNi1iaXQgaW50ZWdlciBsaXRlcmFsADE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGxpdGVyYWwAZG91YmxlIGxpdGVyYWwAaGFsZiBmbG9hdCBsaXRlcmFsAFtdAGZ1bmN0aW9uIGNhbGwsIG1ldGhvZCwgb3Igc3Vicm91dGluZSBjYWxsIGV4cGVjdGVkAGluY29tcGxldGUgbWV0aG9kIHN5bnRheABiaXR3aXNlIG5vdAAqAC8AJQArAC0AYml0IHNoaWZ0IGxlZnQAYml0IHNoaWZ0IHJpZ2h0ADwAYXJyYXkgY29tcGFyaXNvbgAmAGJpdHdpc2UgZXhjbHVzaXZlIG9yAF4AYml0d2lzZSBpbmNsdXNpdmUgb3IAfAA/AGFycmF5IGFzc2lnbm1lbnQAPQBhc3NpZ24AYml0LXNoaWZ0IGxlZnQgYXNzaWduAGJpdC1zaGlmdCByaWdodCBhc3NpZ24AYml0d2lzZS1hbmQgYXNzaWduAGJpdHdpc2UteG9yIGFzc2lnbgBiaXR3aXNlLW9yIGFzc2lnbgBwcmVjaXNpb24gc3RhdGVtZW50AGNhbm5vdCBiZSBhbiBhcmd1bWVudCB0eXBlIGV4Y2VwdCBmb3IgJyh2b2lkKScAdm9pZABubyBxdWFsaWZpZXJzIGFsbG93ZWQgZm9yIGZ1bmN0aW9uIHJldHVybgBhcnJheWVkIHR5cGUAaWxsZWdhbCB1c2Ugb2YgdHlwZSAndm9pZCcAaW52YXJpYW50AHNtb290aABmbGF0AG5vcGVyc3BlY3RpdmUAX19leHBsaWNpdEludGVycEFNRABleHBsaWNpdCBpbnRlcnBvbGF0aW9uAHBlcnZlcnRleE5WAGZyYWdtZW50IHNoYWRlciBiYXJ5Y2VudHJpYwBwZXJwcmltaXRpdmVOVgAAADzjAwBwZXJ2aWV3TlYAdGFza05WAHNoYXJlZABwcmVjaXNlAJnkAwCC5QMAaW5vdXQAaW4Ab3V0AGNlbnRyb2lkAHVuaWZvcm0AYnVmZmVyAGF0dHJpYnV0ZQB2YXJ5aW5nAHBhdGNoAHNhbXBsZQBoaXRBdHRyaWJ1dGVOVgByYXlQYXlsb2FkTlYAcmF5UGF5bG9hZEluTlYAY2FsbGFibGVEYXRhTlYAY2FsbGFibGVEYXRhSW5OVgAAAt8DAGRldmljZWNvaGVyZW50AHF1ZXVlZmFtaWx5Y29oZXJlbnQAd29ya2dyb3VwY29oZXJlbnQAc3ViZ3JvdXBjb2hlcmVudABub25wcml2YXRlAHN1YnJvdXRpbmUAYXJyYXkgc2l6ZQB0eXBlIHBhcmFtZXRlcgB1bnNpZ25lZCBpbnRlZ2VyAHVuc2lnbmVkIGludGVnZXIgdmVjdG9yAGRvdWJsZQBmbG9hdDE2X3QAZmxvYXQzMl90AGZsb2F0NjRfdAA4LWJpdCBzaWduZWQgaW50ZWdlcgA4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyADE2LWJpdCBzaWduZWQgaW50ZWdlcgAxNi1iaXQgdW5zaWduZWQgaW50ZWdlcgAzMi1iaXQgc2lnbmVkIGludGVnZXIAMzItYml0IHVuc2lnbmVkIGludGVnZXIANjQtYml0IGludGVnZXIANjQtYml0IHVuc2lnbmVkIGludGVnZXIAZG91YmxlIHZlY3RvcgBoYWxmIGZsb2F0IHZlY3RvcgBmbG9hdDMyX3QgdmVjdG9yAGZsb2F0NjRfdCB2ZWN0b3IAOC1iaXQgc2lnbmVkIGludGVnZXIgdmVjdG9yADE2LWJpdCBzaWduZWQgaW50ZWdlciB2ZWN0b3IAMzItYml0IHNpZ25lZCBpbnRlZ2VyIHZlY3RvcgA2NC1iaXQgaW50ZWdlciB2ZWN0b3IAOC1iaXQgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3IAMTYtYml0IHVuc2lnbmVkIGludGVnZXIgdmVjdG9yADMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHZlY3RvcgA2NC1iaXQgdW5zaWduZWQgaW50ZWdlciB2ZWN0b3IAZG91YmxlIG1hdHJpeABoYWxmIGZsb2F0IG1hdHJpeABmbG9hdDMyX3QgbWF0cml4AGZsb2F0NjRfdCBtYXRyaXgAYXRvbWljIGNvdW50ZXIgdHlwZXMAaGFsZiBmbG9hdCBzYW1wbGVyAGhhbGYgZmxvYXQgdGV4dHVyZQBoYWxmIGZsb2F0IGltYWdlAHN1YnBhc3MgaW5wdXQAaGFsZiBmbG9hdCBzdWJwYXNzIGlucHV0AGZjb29wbWF0TlYAaWNvb3BtYXROVgB1Y29vcG1hdE5WAGV4cGVjdGVkIHR5cGUgbmFtZQBoaWdocCBwcmVjaXNpb24gcXVhbGlmaWVyAG1lZGl1bXAgcHJlY2lzaW9uIHF1YWxpZmllcgBsb3dwIHByZWNpc2lvbiBxdWFsaWZpZXIAcmVkZWZpbml0aW9uAHN0cnVjdABkdXBsaWNhdGUgbWVtYmVyIG5hbWU6AHsgfSBzdHlsZSBpbml0aWFsaXplcnMAZGVtb3RlAAAAAJXgAwBjYW5ub3QgYXBwZWFyIG91dHNpZGUgc3dpdGNoIHN0YXRlbWVudABjYXNlAGNhbm5vdCBiZSBuZXN0ZWQgaW5zaWRlIGNvbnRyb2wgZmxvdwBkZWZhdWx0AHdoaWxlIGxvb3BzIG5vdCBhdmFpbGFibGUAbGltaXRhdGlvbgBkby13aGlsZSBsb29wcyBub3QgYXZhaWxhYmxlAGNvbnRpbnVlIHN0YXRlbWVudCBvbmx5IGFsbG93ZWQgaW4gbG9vcHMAYnJlYWsgc3RhdGVtZW50IG9ubHkgYWxsb3dlZCBpbiBzd2l0Y2ggYW5kIGxvb3BzAG5vbi12b2lkIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdmFsdWUAcmV0dXJuAGRpc2NhcmQAZXh0cmFuZW91cyBzZW1pY29sb24AZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWU6AAAAAKjfAwBBoqgOC4dSmwGcAZ0BnQGdAZ0BnQGdAZ0BnQGdAZ0BnQGdAZ0BnQGeAZ4BngGeAZ4BngGfAaABoQGiAaIBowGjAaQBpAGlAaYBpgGmAacBpwGnAacBqAGoAagBqAGpAakBqQGpAaoBqgGqAasBqwGrAawBrAGsAawBrAGtAa0BrQGuAa4BrwGvAbABsAGxAbEBsgGyAbMBswG0AbUBtAG2AbYBtwG3AbcBtwG3AbcBtwG3AbcBtwG3AbgBuAG5AboBugG6AboBugG6AboBugG6AbwBuwG9Ab0BvgG/Ab8BwAHAAcEBwgHCAcMBwwHDAcMBxAHFAcUBxQHFAcUBxgHGAcYBxgHGAccBxwHIAckByQHJAckByQHJAckByQHKAcsBywHMAcwBzAHNAc4BzgHPAc8BzwHPAc8BzwHPAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHRAdIB0gHTAdMB1AHUAdQB1AHVAdUB1gHXAdcB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdgB2AHYAdkB2QHZAdsB2gHcAdoB3QHdAd4B3gHfAd8B4AHgAeEB4QHhAeIB4gHjAeQB5AHlAeUB5QHlAeUB5QHlAeUB5gHnAegB6QHnAeoB6gHsAesB7QHrAe4B7gHvAe8B8AHwAfEB8QHyAfMB8wH0AfQB9QH1AfcB9gH4AfgB+QH5AfoB+gH8AfsB/QH7Af4B+wH/Af8BAAIAAgECAQICAgICAgICAgICAwIDAgQCBAIEAgYCBQIHAggCCAIJAgkCAAA7/jv+O/47/jv+O/47/jv+O/47/jv+O/74ITv+p/+o/4b/rP/t/+7/7//w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AI2yAwCbsgMApbIDAKyyAwC1sgMAvLIDAMqyAwDWsgMA47IDAPCyAwD7sgMABbMDAA6zAwARswMAFbMDABuzAwAiswMAJ7MDAC2zAwAzswMAPLMDAD+zAwBEswMASLMDAEuzAwBTswMAWrMDAGGzAwBmswMAbrMDAHazAwB9swMAhLMDAImzAwCQswMAl7MDAKazAwC0swMAw7MDANOzAwDhswMA8LMDAP6zAwANtAMAGLQDAB+0AwAptAMANbQDAD+0AwBKtAMAV7QDAF20AwBktAMAb7QDAHi0AwCBtAMAirQDAJO0AwCdtAMArLQDAMC0AwDStAMA47QDAO60AwD8tAMADrUDABq1AwAptQMAM7UDAD21AwBFtQMATbUDAGG1AwB0tQMAh7UDAJq1AwCotQMAwLUDANa1AwD5tQMAHrYDADO2AwBHtgMAWLYDAGe2AwCBtgMAlbYDAKa2AwC8tgMA0LYDAN+2AwD3tgMAD7cDACa3AwA9twMAU7cDAGq3AwButwMAhLcDAJi3AwCjtwMAt7cDAMO3AwDTtwMA17cDAOe3AwD6twMADrgDAC64AwA+uAMAU7gDAGm4AwCCuAMAl7gDAKq4AwC/uAMA07gDAOu4AwD8uAMAFbkDACm5AwA7uQMASrkDAGC5AwByuQMAiLkDAJe5AwCmuQMAtrkDANO5AwDsuQMACroDACK6AwA2ugMAR7oDAEu6AwBPugMAZ7oDAHq6AwCRugMAo7oDAK+6AwDAugMA1roDAOC6AwDxugMAArsDABW7AwAZuwMAHbsDADS7AwBFuwMASbsDAE27AwBtuwMAfLsDAJG7AwCluwMAx7sDAOC7AwDquwMA+7sDABq8AwAevAMANLwDAD+8AwBTvAMAdbwDAHq8AwB/vAMAhLwDAJe8AwCkvAMAt7wDAMa8AwDXvAMA7LwDAAC9AwAZjgMABb0DABS9AwAAAAAAc3ludGF4IGVycm9yLCB1bmV4cGVjdGVkICVzLCBleHBlY3RpbmcgJXMgb3IgJXMgb3IgJXMAc3ludGF4IGVycm9yLCB1bmV4cGVjdGVkICVzLCBleHBlY3RpbmcgJXMgb3IgJXMAc3ludGF4IGVycm9yLCB1bmV4cGVjdGVkICVzLCBleHBlY3RpbmcgJXMAc3ludGF4IGVycm9yLCB1bmV4cGVjdGVkICVzAHN5bnRheCBlcnJvciwgdW5leHBlY3RlZCAlcywgZXhwZWN0aW5nICVzIG9yICVzIG9yICVzIG9yICVzACRlbmQAJHVuZGVmaW5lZABDT05TVABCT09MAElOVABVSU5UAEZMT0FUAEJWRUMyAEJWRUMzAEJWRUM0AElWRUMyAElWRUMzAElWRUM0AFVWRUMyAFVWRUMzAFVWRUM0AFZFQzIAVkVDMwBWRUM0AE1BVDIATUFUMwBNQVQ0AE1BVDJYMgBNQVQyWDMATUFUMlg0AE1BVDNYMgBNQVQzWDMATUFUM1g0AE1BVDRYMgBNQVQ0WDMATUFUNFg0AFNBTVBMRVIyRABTQU1QTEVSM0QAU0FNUExFUkNVQkUAU0FNUExFUjJEU0hBRE9XAFNBTVBMRVJDVUJFU0hBRE9XAFNBTVBMRVIyREFSUkFZAFNBTVBMRVIyREFSUkFZU0hBRE9XAElTQU1QTEVSMkQASVNBTVBMRVIzRABJU0FNUExFUkNVQkUASVNBTVBMRVIyREFSUkFZAFVTQU1QTEVSMkQAVVNBTVBMRVIzRABVU0FNUExFUkNVQkUAVVNBTVBMRVIyREFSUkFZAFNBTVBMRVIAU0FNUExFUlNIQURPVwBURVhUVVJFMkQAVEVYVFVSRTNEAFRFWFRVUkVDVUJFAFRFWFRVUkUyREFSUkFZAElURVhUVVJFMkQASVRFWFRVUkUzRABJVEVYVFVSRUNVQkUASVRFWFRVUkUyREFSUkFZAFVURVhUVVJFMkQAVVRFWFRVUkUzRABVVEVYVFVSRUNVQkUAVVRFWFRVUkUyREFSUkFZAEFUVFJJQlVURQBWQVJZSU5HAEZMT0FUMTZfVABGTE9BVDMyX1QARE9VQkxFAEZMT0FUNjRfVABJTlQ2NF9UAFVJTlQ2NF9UAElOVDMyX1QAVUlOVDMyX1QASU5UMTZfVABVSU5UMTZfVABJTlQ4X1QAVUlOVDhfVABJNjRWRUMyAEk2NFZFQzMASTY0VkVDNABVNjRWRUMyAFU2NFZFQzMAVTY0VkVDNABJMzJWRUMyAEkzMlZFQzMASTMyVkVDNABVMzJWRUMyAFUzMlZFQzMAVTMyVkVDNABJMTZWRUMyAEkxNlZFQzMASTE2VkVDNABVMTZWRUMyAFUxNlZFQzMAVTE2VkVDNABJOFZFQzIASThWRUMzAEk4VkVDNABVOFZFQzIAVThWRUMzAFU4VkVDNABEVkVDMgBEVkVDMwBEVkVDNABETUFUMgBETUFUMwBETUFUNABGMTZWRUMyAEYxNlZFQzMARjE2VkVDNABGMTZNQVQyAEYxNk1BVDMARjE2TUFUNABGMzJWRUMyAEYzMlZFQzMARjMyVkVDNABGMzJNQVQyAEYzMk1BVDMARjMyTUFUNABGNjRWRUMyAEY2NFZFQzMARjY0VkVDNABGNjRNQVQyAEY2NE1BVDMARjY0TUFUNABETUFUMlgyAERNQVQyWDMARE1BVDJYNABETUFUM1gyAERNQVQzWDMARE1BVDNYNABETUFUNFgyAERNQVQ0WDMARE1BVDRYNABGMTZNQVQyWDIARjE2TUFUMlgzAEYxNk1BVDJYNABGMTZNQVQzWDIARjE2TUFUM1gzAEYxNk1BVDNYNABGMTZNQVQ0WDIARjE2TUFUNFgzAEYxNk1BVDRYNABGMzJNQVQyWDIARjMyTUFUMlgzAEYzMk1BVDJYNABGMzJNQVQzWDIARjMyTUFUM1gzAEYzMk1BVDNYNABGMzJNQVQ0WDIARjMyTUFUNFgzAEYzMk1BVDRYNABGNjRNQVQyWDIARjY0TUFUMlgzAEY2NE1BVDJYNABGNjRNQVQzWDIARjY0TUFUM1gzAEY2NE1BVDNYNABGNjRNQVQ0WDIARjY0TUFUNFgzAEY2NE1BVDRYNABBVE9NSUNfVUlOVABBQ0NTVFJVQ1ROVgBGQ09PUE1BVE5WAElDT09QTUFUTlYAVUNPT1BNQVROVgBTQU1QTEVSQ1VCRUFSUkFZAFNBTVBMRVJDVUJFQVJSQVlTSEFET1cASVNBTVBMRVJDVUJFQVJSQVkAVVNBTVBMRVJDVUJFQVJSQVkAU0FNUExFUjFEAFNBTVBMRVIxREFSUkFZAFNBTVBMRVIxREFSUkFZU0hBRE9XAElTQU1QTEVSMUQAU0FNUExFUjFEU0hBRE9XAFNBTVBMRVIyRFJFQ1QAU0FNUExFUjJEUkVDVFNIQURPVwBJU0FNUExFUjJEUkVDVABVU0FNUExFUjJEUkVDVABTQU1QTEVSQlVGRkVSAElTQU1QTEVSQlVGRkVSAFVTQU1QTEVSQlVGRkVSAFNBTVBMRVIyRE1TAElTQU1QTEVSMkRNUwBVU0FNUExFUjJETVMAU0FNUExFUjJETVNBUlJBWQBJU0FNUExFUjJETVNBUlJBWQBVU0FNUExFUjJETVNBUlJBWQBTQU1QTEVSRVhURVJOQUxPRVMAU0FNUExFUkVYVEVSTkFMMkRZMllFWFQASVNBTVBMRVIxREFSUkFZAFVTQU1QTEVSMUQAVVNBTVBMRVIxREFSUkFZAEYxNlNBTVBMRVIxRABGMTZTQU1QTEVSMkQARjE2U0FNUExFUjNEAEYxNlNBTVBMRVIyRFJFQ1QARjE2U0FNUExFUkNVQkUARjE2U0FNUExFUjFEQVJSQVkARjE2U0FNUExFUjJEQVJSQVkARjE2U0FNUExFUkNVQkVBUlJBWQBGMTZTQU1QTEVSQlVGRkVSAEYxNlNBTVBMRVIyRE1TAEYxNlNBTVBMRVIyRE1TQVJSQVkARjE2U0FNUExFUjFEU0hBRE9XAEYxNlNBTVBMRVIyRFNIQURPVwBGMTZTQU1QTEVSMURBUlJBWVNIQURPVwBGMTZTQU1QTEVSMkRBUlJBWVNIQURPVwBGMTZTQU1QTEVSMkRSRUNUU0hBRE9XAEYxNlNBTVBMRVJDVUJFU0hBRE9XAEYxNlNBTVBMRVJDVUJFQVJSQVlTSEFET1cASU1BR0UxRABJSU1BR0UxRABVSU1BR0UxRABJTUFHRTJEAElJTUFHRTJEAFVJTUFHRTJEAElNQUdFM0QASUlNQUdFM0QAVUlNQUdFM0QASU1BR0UyRFJFQ1QASUlNQUdFMkRSRUNUAFVJTUFHRTJEUkVDVABJTUFHRUNVQkUASUlNQUdFQ1VCRQBVSU1BR0VDVUJFAElNQUdFQlVGRkVSAElJTUFHRUJVRkZFUgBVSU1BR0VCVUZGRVIASU1BR0UxREFSUkFZAElJTUFHRTFEQVJSQVkAVUlNQUdFMURBUlJBWQBJTUFHRTJEQVJSQVkASUlNQUdFMkRBUlJBWQBVSU1BR0UyREFSUkFZAElNQUdFQ1VCRUFSUkFZAElJTUFHRUNVQkVBUlJBWQBVSU1BR0VDVUJFQVJSQVkASU1BR0UyRE1TAElJTUFHRTJETVMAVUlNQUdFMkRNUwBJTUFHRTJETVNBUlJBWQBJSU1BR0UyRE1TQVJSQVkAVUlNQUdFMkRNU0FSUkFZAEYxNklNQUdFMUQARjE2SU1BR0UyRABGMTZJTUFHRTNEAEYxNklNQUdFMkRSRUNUAEYxNklNQUdFQ1VCRQBGMTZJTUFHRTFEQVJSQVkARjE2SU1BR0UyREFSUkFZAEYxNklNQUdFQ1VCRUFSUkFZAEYxNklNQUdFQlVGRkVSAEYxNklNQUdFMkRNUwBGMTZJTUFHRTJETVNBUlJBWQBURVhUVVJFQ1VCRUFSUkFZAElURVhUVVJFQ1VCRUFSUkFZAFVURVhUVVJFQ1VCRUFSUkFZAFRFWFRVUkUxRABJVEVYVFVSRTFEAFVURVhUVVJFMUQAVEVYVFVSRTFEQVJSQVkASVRFWFRVUkUxREFSUkFZAFVURVhUVVJFMURBUlJBWQBURVhUVVJFMkRSRUNUAElURVhUVVJFMkRSRUNUAFVURVhUVVJFMkRSRUNUAFRFWFRVUkVCVUZGRVIASVRFWFRVUkVCVUZGRVIAVVRFWFRVUkVCVUZGRVIAVEVYVFVSRTJETVMASVRFWFRVUkUyRE1TAFVURVhUVVJFMkRNUwBURVhUVVJFMkRNU0FSUkFZAElURVhUVVJFMkRNU0FSUkFZAFVURVhUVVJFMkRNU0FSUkFZAEYxNlRFWFRVUkUxRABGMTZURVhUVVJFMkQARjE2VEVYVFVSRTNEAEYxNlRFWFRVUkUyRFJFQ1QARjE2VEVYVFVSRUNVQkUARjE2VEVYVFVSRTFEQVJSQVkARjE2VEVYVFVSRTJEQVJSQVkARjE2VEVYVFVSRUNVQkVBUlJBWQBGMTZURVhUVVJFQlVGRkVSAEYxNlRFWFRVUkUyRE1TAEYxNlRFWFRVUkUyRE1TQVJSQVkAU1VCUEFTU0lOUFVUAFNVQlBBU1NJTlBVVE1TAElTVUJQQVNTSU5QVVQASVNVQlBBU1NJTlBVVE1TAFVTVUJQQVNTSU5QVVQAVVNVQlBBU1NJTlBVVE1TAEYxNlNVQlBBU1NJTlBVVABGMTZTVUJQQVNTSU5QVVRNUwBMRUZUX09QAFJJR0hUX09QAElOQ19PUABERUNfT1AATEVfT1AAR0VfT1AARVFfT1AATkVfT1AAQU5EX09QAE9SX09QAFhPUl9PUABNVUxfQVNTSUdOAERJVl9BU1NJR04AQUREX0FTU0lHTgBNT0RfQVNTSUdOAExFRlRfQVNTSUdOAFJJR0hUX0FTU0lHTgBBTkRfQVNTSUdOAFhPUl9BU1NJR04AT1JfQVNTSUdOAFNVQl9BU1NJR04ATEVGVF9QQVJFTgBSSUdIVF9QQVJFTgBMRUZUX0JSQUNLRVQAUklHSFRfQlJBQ0tFVABMRUZUX0JSQUNFAFJJR0hUX0JSQUNFAERPVABDT01NQQBDT0xPTgBFUVVBTABTRU1JQ09MT04AQkFORwBEQVNIAFRJTERFAFBMVVMAU1RBUgBTTEFTSABQRVJDRU5UAExFRlRfQU5HTEUAUklHSFRfQU5HTEUAVkVSVElDQUxfQkFSAENBUkVUAEFNUEVSU0FORABRVUVTVElPTgBJTlZBUklBTlQASElHSF9QUkVDSVNJT04ATUVESVVNX1BSRUNJU0lPTgBMT1dfUFJFQ0lTSU9OAFBSRUNJU0lPTgBQQUNLRUQAUkVTT1VSQ0UAU1VQRVJQAEZMT0FUQ09OU1RBTlQASU5UQ09OU1RBTlQAVUlOVENPTlNUQU5UAEJPT0xDT05TVEFOVABJREVOVElGSUVSAFRZUEVfTkFNRQBDRU5UUk9JRABJTgBPVVQASU5PVVQAU1RSVUNUAFZPSUQAV0hJTEUAQlJFQUsAQ09OVElOVUUARE8ARUxTRQBGT1IASUYARElTQ0FSRABSRVRVUk4AU1dJVENIAENBU0UAREVGQVVMVABVTklGT1JNAFNIQVJFRABCVUZGRVIARkxBVABTTU9PVEgATEFZT1VUAERPVUJMRUNPTlNUQU5UAElOVDE2Q09OU1RBTlQAVUlOVDE2Q09OU1RBTlQARkxPQVQxNkNPTlNUQU5UAElOVDMyQ09OU1RBTlQAVUlOVDMyQ09OU1RBTlQASU5UNjRDT05TVEFOVABVSU5UNjRDT05TVEFOVABTVUJST1VUSU5FAERFTU9URQBQQVlMT0FETlYAUEFZTE9BRElOTlYASElUQVRUUk5WAENBTExEQVRBTlYAQ0FMTERBVEFJTk5WAFBBVENIAFNBTVBMRQBOT05VTklGT1JNAENPSEVSRU5UAFZPTEFUSUxFAFJFU1RSSUNUAFJFQURPTkxZAFdSSVRFT05MWQBERVZJQ0VDT0hFUkVOVABRVUVVRUZBTUlMWUNPSEVSRU5UAFdPUktHUk9VUENPSEVSRU5UAFNVQkdST1VQQ09IRVJFTlQATk9OUFJJVkFURQBOT1BFUlNQRUNUSVZFAEVYUExJQ0lUSU5URVJQQU1EAFBFUlZFUlRFWE5WAFBFUlBSSU1JVElWRU5WAFBFUlZJRVdOVgBQRVJUQVNLTlYAUFJFQ0lTRQAkYWNjZXB0AHZhcmlhYmxlX2lkZW50aWZpZXIAcHJpbWFyeV9leHByZXNzaW9uAHBvc3RmaXhfZXhwcmVzc2lvbgBpbnRlZ2VyX2V4cHJlc3Npb24AZnVuY3Rpb25fY2FsbABmdW5jdGlvbl9jYWxsX29yX21ldGhvZABmdW5jdGlvbl9jYWxsX2dlbmVyaWMAZnVuY3Rpb25fY2FsbF9oZWFkZXJfbm9fcGFyYW1ldGVycwBmdW5jdGlvbl9jYWxsX2hlYWRlcl93aXRoX3BhcmFtZXRlcnMAZnVuY3Rpb25fY2FsbF9oZWFkZXIAZnVuY3Rpb25faWRlbnRpZmllcgB1bmFyeV9leHByZXNzaW9uAHVuYXJ5X29wZXJhdG9yAG11bHRpcGxpY2F0aXZlX2V4cHJlc3Npb24AYWRkaXRpdmVfZXhwcmVzc2lvbgBzaGlmdF9leHByZXNzaW9uAHJlbGF0aW9uYWxfZXhwcmVzc2lvbgBlcXVhbGl0eV9leHByZXNzaW9uAGFuZF9leHByZXNzaW9uAGV4Y2x1c2l2ZV9vcl9leHByZXNzaW9uAGluY2x1c2l2ZV9vcl9leHByZXNzaW9uAGxvZ2ljYWxfYW5kX2V4cHJlc3Npb24AbG9naWNhbF94b3JfZXhwcmVzc2lvbgBsb2dpY2FsX29yX2V4cHJlc3Npb24AY29uZGl0aW9uYWxfZXhwcmVzc2lvbgAkQDEAYXNzaWdubWVudF9leHByZXNzaW9uAGFzc2lnbm1lbnRfb3BlcmF0b3IAZXhwcmVzc2lvbgBjb25zdGFudF9leHByZXNzaW9uAGRlY2xhcmF0aW9uAGJsb2NrX3N0cnVjdHVyZQAkQDIAaWRlbnRpZmllcl9saXN0AGZ1bmN0aW9uX3Byb3RvdHlwZQBmdW5jdGlvbl9kZWNsYXJhdG9yAGZ1bmN0aW9uX2hlYWRlcl93aXRoX3BhcmFtZXRlcnMAZnVuY3Rpb25faGVhZGVyAHBhcmFtZXRlcl9kZWNsYXJhdG9yAHBhcmFtZXRlcl9kZWNsYXJhdGlvbgBwYXJhbWV0ZXJfdHlwZV9zcGVjaWZpZXIAaW5pdF9kZWNsYXJhdG9yX2xpc3QAc2luZ2xlX2RlY2xhcmF0aW9uAGZ1bGx5X3NwZWNpZmllZF90eXBlAGludmFyaWFudF9xdWFsaWZpZXIAaW50ZXJwb2xhdGlvbl9xdWFsaWZpZXIAbGF5b3V0X3F1YWxpZmllcgBsYXlvdXRfcXVhbGlmaWVyX2lkX2xpc3QAbGF5b3V0X3F1YWxpZmllcl9pZABwcmVjaXNlX3F1YWxpZmllcgB0eXBlX3F1YWxpZmllcgBzaW5nbGVfdHlwZV9xdWFsaWZpZXIAc3RvcmFnZV9xdWFsaWZpZXIAbm9uX3VuaWZvcm1fcXVhbGlmaWVyAHR5cGVfbmFtZV9saXN0AHR5cGVfc3BlY2lmaWVyAGFycmF5X3NwZWNpZmllcgB0eXBlX3BhcmFtZXRlcl9zcGVjaWZpZXJfb3B0AHR5cGVfcGFyYW1ldGVyX3NwZWNpZmllcgB0eXBlX3BhcmFtZXRlcl9zcGVjaWZpZXJfbGlzdAB0eXBlX3NwZWNpZmllcl9ub25hcnJheQBwcmVjaXNpb25fcXVhbGlmaWVyAHN0cnVjdF9zcGVjaWZpZXIAJEAzACRANABzdHJ1Y3RfZGVjbGFyYXRpb25fbGlzdABzdHJ1Y3RfZGVjbGFyYXRpb24Ac3RydWN0X2RlY2xhcmF0b3JfbGlzdABzdHJ1Y3RfZGVjbGFyYXRvcgBpbml0aWFsaXplcgBpbml0aWFsaXplcl9saXN0AGRlY2xhcmF0aW9uX3N0YXRlbWVudABzdGF0ZW1lbnQAc2ltcGxlX3N0YXRlbWVudABkZW1vdGVfc3RhdGVtZW50AGNvbXBvdW5kX3N0YXRlbWVudAAkQDUAJEA2AHN0YXRlbWVudF9ub19uZXdfc2NvcGUAc3RhdGVtZW50X3Njb3BlZAAkQDcAJEA4AGNvbXBvdW5kX3N0YXRlbWVudF9ub19uZXdfc2NvcGUAc3RhdGVtZW50X2xpc3QAZXhwcmVzc2lvbl9zdGF0ZW1lbnQAc2VsZWN0aW9uX3N0YXRlbWVudABzZWxlY3Rpb25fc3RhdGVtZW50X25vbmF0dHJpYnV0ZWQAc2VsZWN0aW9uX3Jlc3Rfc3RhdGVtZW50AGNvbmRpdGlvbgBzd2l0Y2hfc3RhdGVtZW50AHN3aXRjaF9zdGF0ZW1lbnRfbm9uYXR0cmlidXRlZAAkQDkAc3dpdGNoX3N0YXRlbWVudF9saXN0AGNhc2VfbGFiZWwAaXRlcmF0aW9uX3N0YXRlbWVudABpdGVyYXRpb25fc3RhdGVtZW50X25vbmF0dHJpYnV0ZWQAJEAxMAAkQDExACRAMTIAZm9yX2luaXRfc3RhdGVtZW50AGNvbmRpdGlvbm9wdABmb3JfcmVzdF9zdGF0ZW1lbnQAanVtcF9zdGF0ZW1lbnQAdHJhbnNsYXRpb25fdW5pdABleHRlcm5hbF9kZWNsYXJhdGlvbgBmdW5jdGlvbl9kZWZpbml0aW9uACRAMTMAYXR0cmlidXRlX2xpc3QAc2luZ2xlX2F0dHJpYnV0ZQAlcyVkAEG0+g4LVhsBAAAnAgAAKAIAACkCAAAqAgAAKwIAACwCAAAtAgAALgIAAC8CAAAwAgAAMQIAABsBAAAbAQAAMgIAADMCAAA0AgAANQIAADYCAAAbAQAANwIAADgCAEGU+w4LBjkCAAA6AgBBpPsOC84BOwIAADwCAAA9AgAAPgIAAD8CAABAAgAAQQIAAEICAABDAgAARAIAAEUCAABGAgAARwIAAEgCAABJAgAASgIAAEsCAABMAgAATQIAAE4CAABPAgAAUAIAAFECAABSAgAAUwIAAFQCAABVAgAAVgIAAFcCAABYAgAAWQIAAFoCAABbAgAAXAIAAF0CAABeAgAAXwIAAGACAABhAgAAYgIAAGMCAABkAgAAZQIAAGYCAABnAgAAaAIAAGkCAABqAgAAawIAAGwCAABtAgAAbgIAQfz8DgujIm8CAABwAgAAAr8DAAe/AwAOvwMA+o0DAP2NAwAKjgMAEo4DAN2NAwBHjgMAVI4DADiOAwBjjgMAco4DAPqNAwD9jQMA9I0DABS/AwAmvwMAMr8DAGtCBABAvwMAET4EAE2/AwBcvwMAab8DAHe/AwCBvwMAdW5rbm93biBxdWFsaWZpZXIAdGVtcABnbG9iYWwAY29uc3QAY29uc3QgKHJlYWQgb25seSkAZ2xfVmVydGV4SWQAZ2xfSW5zdGFuY2VJZABnbF9Qb2ludFNpemUAZ2xfRnJvbnRGYWNpbmcAZ2xfRnJhZ0Nvb3JkAGdsX1BvaW50Q29vcmQAZnJhZ0NvbG9yAGdsX0ZyYWdEZXB0aABsYXlvdXQoACBsb2NhdGlvbj0AIGNvbXBvbmVudD0AIGluZGV4PQAgc2V0PQAgYmluZGluZz0AIHN0cmVhbT0AIG9mZnNldD0AIGFsaWduPQAgeGZiX2J1ZmZlcj0AIHhmYl9vZmZzZXQ9ACB4ZmJfc3RyaWRlPQAgaW5wdXRfYXR0YWNobWVudF9pbmRleD0AIGNvbnN0YW50X2lkPQAgcHVzaF9jb25zdGFudAAgYnVmZmVyX3JlZmVyZW5jZQAgYnVmZmVyX3JlZmVyZW5jZV9hbGlnbj0AIHBhc3N0aHJvdWdoACBsYXlvdXRWaWV3cG9ydFJlbGF0aXZlACBsYXlvdXRTZWNvbmRhcnlWaWV3cG9ydFJlbGF0aXZlT2Zmc2V0PQAgc2hhZGVyUmVjb3JkTlYAIGludmFyaWFudAAgbm9Db250cmFjdGlvbgAgY2VudHJvaWQAIHNtb290aAAgZmxhdAAgbm9wZXJzcGVjdGl2ZQAgX19leHBsaWNpdEludGVycEFNRAAgcGVydmVydGV4TlYAIHBlcnByaW1pdGl2ZU5WACBwZXJ2aWV3TlYAIHRhc2tOVgAgcGF0Y2gAIHNhbXBsZQAgY29oZXJlbnQAIGRldmljZWNvaGVyZW50ACBxdWV1ZWZhbWlseWNvaGVyZW50ACB3b3JrZ3JvdXBjb2hlcmVudAAgc3ViZ3JvdXBjb2hlcmVudAAgbm9ucHJpdmF0ZQAgdm9sYXRpbGUAIHJlc3RyaWN0ACByZWFkb25seQAgd3JpdGVvbmx5ACBzcGVjaWFsaXphdGlvbi1jb25zdGFudAAgbm9udW5pZm9ybQAgdW5zaXplZAAgcnVudGltZS1zaXplZCBhcnJheSBvZgAtZWxlbWVudCBhcnJheSBvZgBYAC1jb21wb25lbnQgdmVjdG9yIG9mACBtYXRyaXggb2YAewB9ANxfBABaxAMAaMQDAHbEAwCCxAMAlMQDAKfEAwC8xAMAycQDANTEAwDhxAMA9MQDAAPFAwASxQMAIcUDADDFAwA/xQMATMUDAGHFAwBwxQMAf8UDAI7FAwCdxQMArMUDALXFAwDAxQMAzMUDANrFAwDlxQMA8sUDAPnFAwACxgMADMYDABfGAwAkxgMAMcYDADjGAwA/xgMATsYDAF3GAwBsxgMAe8YDAIrGAwCZxgMAqMYDALfGAwDCxgMAzMYDAODGAwDzxgMA/MYDAAnHAwAWxwMAIscDACjHAwA2xwMARMcDAFPHAwBixwMAbscDAHjHAwB+xwMAjccDAJLHAwCcxwMAp8cDALHHAwC6xwMAxMcDANPHAwDcxwMA68cDAPjHAwAJyAMAGsgDADPIAwBKyAMAWsgDAHLIAwCIyAMAm8gDAKXIAwCxyAMAvcgDANTIAwDjyAMA98gDAA/JAwAhyQMAN8kDAErJAwBZyQMAb8kDAHrJAwCHyQMAnckDAK7JAwDCyQMA1MkDAOnJAwD5yQMACcoDABDKAwAaygMAKsoDADrKAwBNygMAWcoDAGzKAwB4ygMAicoDAJzKAwCyygMAyMoDANfKAwDnygMA+coDAAbLAwAQywMAGcsDAHVua25vd24gYnVpbHQtaW4gdmFyaWFibGUATnVtV29ya0dyb3VwcwBXb3JrR3JvdXBTaXplAFdvcmtHcm91cElEAExvY2FsSW52b2NhdGlvbklEAEdsb2JhbEludm9jYXRpb25JRABMb2NhbEludm9jYXRpb25JbmRleABOdW1TdWJncm91cHMAU3ViZ3JvdXBJRABTdWJHcm91cFNpemUAU3ViR3JvdXBJbnZvY2F0aW9uAFN1Ykdyb3VwRXFNYXNrAFN1Ykdyb3VwR2VNYXNrAFN1Ykdyb3VwR3RNYXNrAFN1Ykdyb3VwTGVNYXNrAFN1Ykdyb3VwTHRNYXNrAFN1Ymdyb3VwU2l6ZQBTdWJncm91cEludm9jYXRpb25JRABTdWJncm91cEVxTWFzawBTdWJncm91cEdlTWFzawBTdWJncm91cEd0TWFzawBTdWJncm91cExlTWFzawBTdWJncm91cEx0TWFzawBWZXJ0ZXhJZABJbnN0YW5jZUlkAFZlcnRleEluZGV4AEluc3RhbmNlSW5kZXgAQmFzZVZlcnRleABCYXNlSW5zdGFuY2UARHJhd0lkAFBvc2l0aW9uAFBvaW50U2l6ZQBDbGlwVmVydGV4AENsaXBEaXN0YW5jZQBDdWxsRGlzdGFuY2UATm9ybWFsAFZlcnRleABNdWx0aVRleENvb3JkMABNdWx0aVRleENvb3JkMQBNdWx0aVRleENvb3JkMgBNdWx0aVRleENvb3JkMwBNdWx0aVRleENvb3JkNABNdWx0aVRleENvb3JkNQBNdWx0aVRleENvb3JkNgBNdWx0aVRleENvb3JkNwBGcm9udENvbG9yAEJhY2tDb2xvcgBGcm9udFNlY29uZGFyeUNvbG9yAEJhY2tTZWNvbmRhcnlDb2xvcgBUZXhDb29yZABGb2dGcmFnQ29vcmQASW52b2NhdGlvbklEAFByaW1pdGl2ZUlEAExheWVyAFZpZXdwb3J0SW5kZXgAUGF0Y2hWZXJ0aWNlcwBUZXNzTGV2ZWxPdXRlcgBUZXNzTGV2ZWxJbm5lcgBCb3VuZGluZ0JveABUZXNzQ29vcmQAQ29sb3IAU2Vjb25kYXJ5Q29sb3IARmFjZQBGcmFnQ29vcmQAUG9pbnRDb29yZABGcmFnQ29sb3IARnJhZ0RhdGEARnJhZ0RlcHRoAEZyYWdTdGVuY2lsUmVmAFNhbXBsZUlkAFNhbXBsZVBvc2l0aW9uAFNhbXBsZU1hc2tJbgBIZWxwZXJJbnZvY2F0aW9uAEJhcnlDb29yZE5vUGVyc3AAQmFyeUNvb3JkTm9QZXJzcENlbnRyb2lkAEJhcnlDb29yZE5vUGVyc3BTYW1wbGUAQmFyeUNvb3JkU21vb3RoAEJhcnlDb29yZFNtb290aENlbnRyb2lkAEJhcnlDb29yZFNtb290aFNhbXBsZQBCYXJ5Q29vcmRQdWxsTW9kZWwAVmlld0luZGV4AERldmljZUluZGV4AEZyYWdTaXplRVhUAEZyYWdJbnZvY2F0aW9uQ291bnRFWFQAVmlld3BvcnRNYXNrTlYAU2Vjb25kYXJ5UG9zaXRpb25OVgBTZWNvbmRhcnlWaWV3cG9ydE1hc2tOVgBQb3NpdGlvblBlclZpZXdOVgBWaWV3cG9ydE1hc2tQZXJWaWV3TlYARnJhZ0Z1bGx5Q292ZXJlZE5WAEZyYWdtZW50U2l6ZU5WAEludm9jYXRpb25zUGVyUGl4ZWxOVgBMYXVuY2hJZE5WAExhdW5jaFNpemVOVgBJbnN0YW5jZUN1c3RvbUluZGV4TlYAV29ybGRSYXlPcmlnaW5OVgBXb3JsZFJheURpcmVjdGlvbk5WAE9iamVjdFJheU9yaWdpbk5WAE9iamVjdFJheURpcmVjdGlvbk5WAE9iamVjdFJheVRtaW5OVgBPYmplY3RSYXlUbWF4TlYASGl0VE5WAEhpdEtpbmROVgBPYmplY3RUb1dvcmxkTlYAV29ybGRUb09iamVjdE5WAEluY29taW5nUmF5RmxhZ3NOVgBCYXJ5Q29vcmROVgBCYXJ5Q29vcmROb1BlcnNwTlYAVGFza0NvdW50TlYAUHJpbWl0aXZlQ291bnROVgBQcmltaXRpdmVJbmRpY2VzTlYAQ2xpcERpc3RhbmNlUGVyVmlld05WAEN1bGxEaXN0YW5jZVBlclZpZXdOVgBMYXllclBlclZpZXdOVgBNZXNoVmlld0NvdW50TlYATWVzaFZpZXdJbmRpY2VzTlYAV2FycHNQZXJTTU5WAFNNQ291bnROVgBXYXJwSUROVgBTTUlETlYA6YwDAHnLAwAnjwMALo8DAH/LAwCGywMAjssDAJbLAwCfywMAo8sDAKjLAwCwywMAucsDAL7LAwDKywMA2MsDAOLLAwDoywMAAMwDAHVua25vd24gdHlwZQBmbG9hdABpbnQ4X3QAdWludDhfdABpbnQxNl90AHVpbnQxNl90AGludAB1aW50AGludDY0X3QAdWludDY0X3QAYm9vbABhdG9taWNfdWludABzYW1wbGVyL2ltYWdlAHN0cnVjdHVyZQBibG9jawBhY2NlbGVyYXRpb25TdHJ1Y3R1cmVOVgByZWZlcmVuY2UAc2FtcGxlcgAAAPzXAwAA2AMACtgDAAbYAwAD2AMAINgDAB7YAwAO2AMAEtgDAHN1YnBhc3MAaW1hZ2UARXh0ZXJuYWxPRVMAX18ARXh0ZXJuYWwyRFkyWUVYVAAAAJTMAwCXzAMAmswDAJ3MAwCizAMAqcwDALDMAwBNUwBBcnJheQBTaGFkb3cAMUQAMkQAM0QAQ3ViZQAyRFJlY3QAQnVmZmVyAElucHV0AAAA3F8EAOTMAwDpzAMA8cwDAHVua25vd24gcHJlY2lzaW9uIHF1YWxpZmllcgBsb3dwAG1lZGl1bXAAaGlnaHAAAKjNAwCwzQMAuM0DAL3NAwDDzQMAwNYDAM/NAwDVzQMA280DAOrNAwDvzQMA9s0DAP/NAwAEzgMACM4DAAzOAwAPzgMAHM4DACfOAwAxzgMAO84DAMDWAwBEzgMATM4DAFTOAwBbzgMAwNYDAGDOAwBmzgMAbM4DAHHOAwB2zgMAwNYDAHrOAwCDzgMAjM4DAJTOAwDA1gMAms4DAKHOAwCozgMAs84DALnOAwC/zgMAcmdiYTMyZgByZ2JhMTZmAHIzMmYAcmdiYTgAcmdiYThfc25vcm0AcmczMmYAcmcxNmYAcjExZl9nMTFmX2IxMGYAcjE2ZgByZ2JhMTYAcmdiMTBfYTIAcmcxNgByZzgAcjE2AHI4AHJnYmExNl9zbm9ybQByZzE2X3Nub3JtAHJnOF9zbm9ybQByMTZfc25vcm0Acjhfc25vcm0AcmdiYTMyaQByZ2JhMTZpAHJnYmE4aQByMzJpAHJnMzJpAHJnMTZpAHJnOGkAcjE2aQByOGkAcmdiYTMydWkAcmdiYTE2dWkAcmdiYTh1aQByMzJ1aQByZzMydWkAcmcxNnVpAHJnYjEwX2EydWkAcmc4dWkAcjE2dWkAcjh1aQDdjQMA2M4DAN/OAwDmzgMA7c4DAHN0ZDE0MABzdGQ0MzAAcGFja2VkAHNjYWxhcgByb3dfbWFqb3IAY29sdW1uX21ham9yAFdhcm5pbmcsICh2ZXJzaW9uLCBwcm9maWxlKSBmb3JjZWQgdG8gYmUgKAApLCB3aGlsZSBpbiBzb3VyY2UgY29kZSBpdCBpcyAoAElsbGVnYWwgdG8gaGF2ZSBub24tY29tbWVudCwgbm9uLXdoaXRlc3BhY2UgdG9rZW5zIGJlZm9yZSAjdmVyc2lvbgAKIGludDsAQaifDwt8cQIAAHICAAAgY29tcGlsYXRpb24gZXJyb3JzLiAgTm8gY29kZSBnZW5lcmF0ZWQuCgoAVU5LTk9XTiBFUlJPUjogAE5PVEU6IABVTklNUExFTUVOVEVEOiAASU5URVJOQUwgRVJST1I6IABFUlJPUjogAFdBUk5JTkc6IABBsKAPC3VzAgAAdAIAAG1haW4AZW50cnktcG9pbnQAQnVpbHRpblN5bWJvbFRhYmxlIHsKAH0KAFVuYWJsZSB0byBwYXJzZSBidWlsdC1pbnMAVW5hYmxlIHRvIHBhcnNlIGJ1aWx0LWlucwolcwoAAAABAAAAAAAAAAIAQbShDwuQDAMAAAByZWxheGVkLWVycm9ycwBzdXBwcmVzcy13YXJuaW5ncwBrZWVwLXVuY2FsbGVkAHNvdXJjZS1lbnRyeXBvaW50AGNsaWVudCB2dWxrYW4xMDAAY2xpZW50IG9wZW5nbDEwMAB0YXJnZXQtZW52IHNwaXJ2MS4xAHRhcmdldC1lbnYgc3BpcnYxLjIAdGFyZ2V0LWVudiBzcGlydjEuMwB0YXJnZXQtZW52IHNwaXJ2MS40AHRhcmdldC1lbnYgc3BpcnYxLjUAdGFyZ2V0LWVudiBzcGlydlVua25vd24AdGFyZ2V0LWVudiB2dWxrYW5Vbmtub3duAHRhcmdldC1lbnYgdnVsa2FuMS4xAHRhcmdldC1lbnYgdnVsa2FuMS4wAHRhcmdldC1lbnYgb3BlbmdsACN2ZXJzaW9uOiB2ZXJzaW9ucyAzMDAsIDMxMCwgYW5kIDMyMCByZXF1aXJlIHNwZWNpZnlpbmcgdGhlICdlcycgcHJvZmlsZQAjdmVyc2lvbjogdmVyc2lvbnMgYmVmb3JlIDE1MCBkbyBub3QgYWxsb3cgYSBwcm9maWxlIHRva2VuACN2ZXJzaW9uOiB2ZXJzaW9ucyAzMDAsIDMxMCwgYW5kIDMyMCBzdXBwb3J0IG9ubHkgdGhlIGVzIHByb2ZpbGUAI3ZlcnNpb246IG9ubHkgdmVyc2lvbiAzMDAsIDMxMCwgYW5kIDMyMCBzdXBwb3J0IHRoZSBlcyBwcm9maWxlAHZlcnNpb24gbm90IHN1cHBvcnRlZAAjdmVyc2lvbjogZ2VvbWV0cnkgc2hhZGVycyByZXF1aXJlIGVzIHByb2ZpbGUgd2l0aCB2ZXJzaW9uIDMxMCBvciBub24tZXMgcHJvZmlsZSB3aXRoIHZlcnNpb24gMTUwIG9yIGFib3ZlACN2ZXJzaW9uOiB0ZXNzZWxsYXRpb24gc2hhZGVycyByZXF1aXJlIGVzIHByb2ZpbGUgd2l0aCB2ZXJzaW9uIDMxMCBvciBub24tZXMgcHJvZmlsZSB3aXRoIHZlcnNpb24gMTUwIG9yIGFib3ZlACN2ZXJzaW9uOiBjb21wdXRlIHNoYWRlcnMgcmVxdWlyZSBlcyBwcm9maWxlIHdpdGggdmVyc2lvbiAzMTAgb3IgYWJvdmUsIG9yIG5vbi1lcyBwcm9maWxlIHdpdGggdmVyc2lvbiA0MjAgb3IgYWJvdmUAI3ZlcnNpb246IHJheSB0cmFjaW5nIHNoYWRlcnMgcmVxdWlyZSBub24tZXMgcHJvZmlsZSB3aXRoIHZlcnNpb24gNDYwIG9yIGFib3ZlACN2ZXJzaW9uOiBtZXNoL3Rhc2sgc2hhZGVycyByZXF1aXJlIGVzIHByb2ZpbGUgd2l0aCB2ZXJzaW9uIDMyMCBvciBhYm92ZSwgb3Igbm9uLWVzIHByb2ZpbGUgd2l0aCB2ZXJzaW9uIDQ1MCBvciBhYm92ZQAjdmVyc2lvbjogc3RhdGVtZW50IG11c3QgYXBwZWFyIGZpcnN0IGluIGVzLXByb2ZpbGUgc2hhZGVyOyBiZWZvcmUgY29tbWVudHMgb3IgbmV3bGluZXMAI3ZlcnNpb246IEVTIHNoYWRlcnMgZm9yIFNQSVItViByZXF1aXJlIHZlcnNpb24gMzEwIG9yIGhpZ2hlcgAjdmVyc2lvbjogY29tcGlsYXRpb24gZm9yIFNQSVItViBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjb21wYXRpYmlsaXR5IHByb2ZpbGUAI3ZlcnNpb246IERlc2t0b3Agc2hhZGVycyBmb3IgVnVsa2FuIFNQSVItViByZXF1aXJlIHZlcnNpb24gMTQwIG9yIGhpZ2hlcgAjdmVyc2lvbjogRGVza3RvcCBzaGFkZXJzIGZvciBPcGVuR0wgU1BJUi1WIHJlcXVpcmUgdmVyc2lvbiAzMzAgb3IgaGlnaGVyAMDWAwBrUQQAsNYDAHBRBACw1gMAsNYDALDWAwB+UQQAdW5rbm93biBwcm9maWxlAG5vbmUAQdCtDwsGdQIAAHYCAEHgrQ8LIncCAAB4AgAAeQIAAHoCAAB7AgAAfAIAAH0CAAB+AgAAfwIAQYyuDwsWdwIAAIACAACBAgAAegIAAHsCAAB8AgBBrK4PCyJ3AgAAggIAAHkCAAB6AgAAewIAAHwCAAB9AgAAGwEAAH8CAEHYrg8LAQEAQeiuDwu8AoMCAACEAgAAQ2Fubm90IG1peCBFUyBwcm9maWxlIHdpdGggbm9uLUVTIHByb2ZpbGUgc2hhZGVycwBDYW5ub3QgYXR0YWNoIG11bHRpcGxlIEVTIHNoYWRlcnMgb2YgdGhlIHNhbWUgdHlwZSB0byBhIHNpbmdsZSBwcm9ncmFtAApMaW5rZWQgACBzdGFnZToKCgBmMTYAaTgAdTgAaTE2AHUxNgBpNjQAdTY0AGF1AGFzbnYAdQBpAHMAdABJAHAAQQBTAEUAWQAAAOg0BABQ2AMAUtgDAG3YAwBv2AMActgDAHTYAwAyADMATQBzdHJ1Y3QtAGJsb2NrLQBzJWQAcyVwAEMAUjIAQgBQACA8AD4ALABbMF0Ab2YgAG4AYW5vbnltb3VzIG1lbWJlciAAIG9mIABMRVZFTCAAQbCxDwuiAYUCAACGAgAAhwIAACkCAAAqAgAAiAIAAIkCAACKAgAAiwIAAC8CAAAwAgAAMQIAAIwCAACNAgAAMgIAADMCAAA0AgAANQIAADYCAACOAgAANwIAADgCAACPAgAAkAIAAJECAACSAgAAkwIAAJQCAACVAgAAlgIAAJcCAACYAgAAmQIAAJoCAACbAgAAnAIAAJ0CAACeAgAAnwIAAKACAAChAgBB3LIPC4YBogIAAKMCAACkAgAAKQIAACoCAAArAgAALAIAAC0CAAAuAgAApQIAAKYCAAAxAgAApwIAAKgCAAAyAgAAMwIAADQCAAA1AgAANgIAAKkCAAA3AgAAOAIAAKoCAACrAgAArAIAAK0CAACuAgAArwIAALACAACxAgAAsgIAALMCAAC0AgAAtQIAQeyzDwunTbYCAAAnAgAAtwIAACkCAAAqAgAAKwIAACwCAAAtAgAALgIAAC8CAAAwAgAAuAIAALkCAAC6AgAAMgIAADMCAAC7AgAAvAIAAL0CAAC+AgAANwIAADgCAAC/AgAAwAIAAMECAABHTF9PRVNfdGV4dHVyZV8zRABHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMAR0xfRVhUX2ZyYWdfZGVwdGgAR0xfT0VTX0VHTF9pbWFnZV9leHRlcm5hbABHTF9PRVNfRUdMX2ltYWdlX2V4dGVybmFsX2Vzc2wzAEdMX0VYVF9ZVVZfdGFyZ2V0AEdMX0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QAR0xfRVhUX3NoYWRvd19zYW1wbGVycwBHTF9BUkJfdGV4dHVyZV9yZWN0YW5nbGUAR0xfM0RMX2FycmF5X29iamVjdHMAR0xfQVJCX3NoYWRpbmdfbGFuZ3VhZ2VfNDIwcGFjawBHTF9BUkJfdGV4dHVyZV9nYXRoZXIAR0xfQVJCX2dwdV9zaGFkZXI1AEdMX0FSQl9zZXBhcmF0ZV9zaGFkZXJfb2JqZWN0cwBHTF9BUkJfY29tcHV0ZV9zaGFkZXIAR0xfQVJCX3Rlc3NlbGxhdGlvbl9zaGFkZXIAR0xfQVJCX2VuaGFuY2VkX2xheW91dHMAR0xfQVJCX3RleHR1cmVfY3ViZV9tYXBfYXJyYXkAR0xfQVJCX3NoYWRlcl90ZXh0dXJlX2xvZABHTF9BUkJfZXhwbGljaXRfYXR0cmliX2xvY2F0aW9uAEdMX0FSQl9leHBsaWNpdF91bmlmb3JtX2xvY2F0aW9uAEdMX0FSQl9zaGFkZXJfaW1hZ2VfbG9hZF9zdG9yZQBHTF9BUkJfc2hhZGVyX2F0b21pY19jb3VudGVycwBHTF9BUkJfc2hhZGVyX2RyYXdfcGFyYW1ldGVycwBHTF9BUkJfc2hhZGVyX2dyb3VwX3ZvdGUAR0xfQVJCX2Rlcml2YXRpdmVfY29udHJvbABHTF9BUkJfc2hhZGVyX3RleHR1cmVfaW1hZ2Vfc2FtcGxlcwBHTF9BUkJfdmlld3BvcnRfYXJyYXkAR0xfQVJCX3NoYWRlcl9iYWxsb3QAR0xfQVJCX3NwYXJzZV90ZXh0dXJlMgBHTF9BUkJfc3BhcnNlX3RleHR1cmVfY2xhbXAAR0xfQVJCX3NoYWRlcl9zdGVuY2lsX2V4cG9ydABHTF9BUkJfcG9zdF9kZXB0aF9jb3ZlcmFnZQBHTF9BUkJfc2hhZGVyX3ZpZXdwb3J0X2xheWVyX2FycmF5AEdMX0FSQl9mcmFnbWVudF9zaGFkZXJfaW50ZXJsb2NrAEdMX0FSQl9zaGFkZXJfY2xvY2sAR0xfS0hSX3NoYWRlcl9zdWJncm91cF9iYXNpYwBHTF9LSFJfc2hhZGVyX3N1Ymdyb3VwX3ZvdGUAR0xfS0hSX3NoYWRlcl9zdWJncm91cF9hcml0aG1ldGljAEdMX0tIUl9zaGFkZXJfc3ViZ3JvdXBfYmFsbG90AEdMX0tIUl9zaGFkZXJfc3ViZ3JvdXBfc2h1ZmZsZQBHTF9LSFJfc2hhZGVyX3N1Ymdyb3VwX3NodWZmbGVfcmVsYXRpdmUAR0xfS0hSX3NoYWRlcl9zdWJncm91cF9jbHVzdGVyZWQAR0xfS0hSX3NoYWRlcl9zdWJncm91cF9xdWFkAEdMX0tIUl9tZW1vcnlfc2NvcGVfc2VtYW50aWNzAEdMX0VYVF9zaGFkZXJfYXRvbWljX2ludDY0AEdMX0VYVF9zaGFkZXJfbm9uX2NvbnN0YW50X2dsb2JhbF9pbml0aWFsaXplcnMAR0xfRVhUX3NoYWRlcl9pbWFnZV9sb2FkX2Zvcm1hdHRlZABHTF9FWFRfcG9zdF9kZXB0aF9jb3ZlcmFnZQBHTF9FWFRfY29udHJvbF9mbG93X2F0dHJpYnV0ZXMAR0xfRVhUX25vbnVuaWZvcm1fcXVhbGlmaWVyAEdMX0VYVF9zYW1wbGVybGVzc190ZXh0dXJlX2Z1bmN0aW9ucwBHTF9FWFRfc2NhbGFyX2Jsb2NrX2xheW91dABHTF9FWFRfZnJhZ21lbnRfaW52b2NhdGlvbl9kZW5zaXR5AEdMX0VYVF9idWZmZXJfcmVmZXJlbmNlAEdMX0VYVF9idWZmZXJfcmVmZXJlbmNlMgBHTF9FWFRfYnVmZmVyX3JlZmVyZW5jZV91dmVjMgBHTF9FWFRfZGVtb3RlX3RvX2hlbHBlcl9pbnZvY2F0aW9uAEdMX0VYVF9zaGFkZXJfMTZiaXRfc3RvcmFnZQBHTF9FWFRfc2hhZGVyXzhiaXRfc3RvcmFnZQBHTF9BTURfc2hhZGVyX2JhbGxvdABHTF9BTURfc2hhZGVyX3RyaW5hcnlfbWlubWF4AEdMX0FNRF9zaGFkZXJfZXhwbGljaXRfdmVydGV4X3BhcmFtZXRlcgBHTF9BTURfZ2NuX3NoYWRlcgBHTF9BTURfZ3B1X3NoYWRlcl9oYWxmX2Zsb2F0AEdMX0FNRF9zaGFkZXJfaW1hZ2VfbG9hZF9zdG9yZV9sb2QAR0xfQU1EX3NoYWRlcl9mcmFnbWVudF9tYXNrAEdMX0FNRF9ncHVfc2hhZGVyX2hhbGZfZmxvYXRfZmV0Y2gAR0xfTlZfc2FtcGxlX21hc2tfb3ZlcnJpZGVfY292ZXJhZ2UAR0xfTlZfZ2VvbWV0cnlfc2hhZGVyX3Bhc3N0aHJvdWdoAEdMX05WX3NoYWRlcl9hdG9taWNfaW50NjQAR0xfTlZfY29uc2VydmF0aXZlX3Jhc3Rlcl91bmRlcmVzdGltYXRpb24AR0xfTlZfc2hhZGVyX25vcGVyc3BlY3RpdmVfaW50ZXJwb2xhdGlvbgBHTF9OVl9zaGFkZXJfc3ViZ3JvdXBfcGFydGl0aW9uZWQAR0xfTlZfc2hhZGluZ19yYXRlX2ltYWdlAEdMX05WX3JheV90cmFjaW5nAEdMX05WX2ZyYWdtZW50X3NoYWRlcl9iYXJ5Y2VudHJpYwBHTF9OVl9jb21wdXRlX3NoYWRlcl9kZXJpdmF0aXZlcwBHTF9OVl9zaGFkZXJfdGV4dHVyZV9mb290cHJpbnQAR0xfTlZfbWVzaF9zaGFkZXIAR0xfTlZfY29vcGVyYXRpdmVfbWF0cml4AEdMX05WX3NoYWRlcl9zbV9idWlsdGlucwBHTF9OVl9pbnRlZ2VyX2Nvb3BlcmF0aXZlX21hdHJpeABHTF9BTkRST0lEX2V4dGVuc2lvbl9wYWNrX2VzMzFhAEdMX0tIUl9ibGVuZF9lcXVhdGlvbl9hZHZhbmNlZABHTF9PRVNfc2FtcGxlX3ZhcmlhYmxlcwBHTF9PRVNfc2hhZGVyX2ltYWdlX2F0b21pYwBHTF9PRVNfc2hhZGVyX211bHRpc2FtcGxlX2ludGVycG9sYXRpb24AR0xfT0VTX3RleHR1cmVfc3RvcmFnZV9tdWx0aXNhbXBsZV8yZF9hcnJheQBHTF9FWFRfZ2VvbWV0cnlfc2hhZGVyAEdMX0VYVF9nZW9tZXRyeV9wb2ludF9zaXplAEdMX0VYVF9ncHVfc2hhZGVyNQBHTF9FWFRfcHJpbWl0aXZlX2JvdW5kaW5nX2JveABHTF9FWFRfc2hhZGVyX2lvX2Jsb2NrcwBHTF9FWFRfdGVzc2VsbGF0aW9uX3NoYWRlcgBHTF9FWFRfdGVzc2VsbGF0aW9uX3BvaW50X3NpemUAR0xfRVhUX3RleHR1cmVfYnVmZmVyAEdMX0VYVF90ZXh0dXJlX2N1YmVfbWFwX2FycmF5AEdMX09FU19nZW9tZXRyeV9zaGFkZXIAR0xfT0VTX2dlb21ldHJ5X3BvaW50X3NpemUAR0xfT0VTX2dwdV9zaGFkZXI1AEdMX09FU19wcmltaXRpdmVfYm91bmRpbmdfYm94AEdMX09FU19zaGFkZXJfaW9fYmxvY2tzAEdMX09FU190ZXNzZWxsYXRpb25fc2hhZGVyAEdMX09FU190ZXNzZWxsYXRpb25fcG9pbnRfc2l6ZQBHTF9PRVNfdGV4dHVyZV9idWZmZXIAR0xfT0VTX3RleHR1cmVfY3ViZV9tYXBfYXJyYXkAR0xfRVhUX2RldmljZV9ncm91cABHTF9FWFRfbXVsdGl2aWV3AEdMX0VYVF9zaGFkZXJfcmVhbHRpbWVfY2xvY2sAR0xfT1ZSX211bHRpdmlldwBHTF9PVlJfbXVsdGl2aWV3MgBHTF9FWFRfc2hhZGVyX2V4cGxpY2l0X2FyaXRobWV0aWNfdHlwZXNfaW50OABHTF9FWFRfc2hhZGVyX2V4cGxpY2l0X2FyaXRobWV0aWNfdHlwZXNfaW50MzIAR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2Zsb2F0MTYAR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2Zsb2F0MzIAR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2Zsb2F0NjQAR0xfRVhUX3NoYWRlcl9zdWJncm91cF9leHRlbmRlZF90eXBlc19pbnQ4AEdMX0VYVF9zaGFkZXJfc3ViZ3JvdXBfZXh0ZW5kZWRfdHlwZXNfaW50MTYAR0xfRVhUX3NoYWRlcl9zdWJncm91cF9leHRlbmRlZF90eXBlc19pbnQ2NABHTF9FWFRfc2hhZGVyX3N1Ymdyb3VwX2V4dGVuZGVkX3R5cGVzX2Zsb2F0MTYAI2RlZmluZSBHTF9FUyAxCiNkZWZpbmUgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0ggMQojZGVmaW5lIEdMX09FU190ZXh0dXJlXzNEIDEKI2RlZmluZSBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgMQojZGVmaW5lIEdMX0VYVF9mcmFnX2RlcHRoIDEKI2RlZmluZSBHTF9PRVNfRUdMX2ltYWdlX2V4dGVybmFsIDEKI2RlZmluZSBHTF9PRVNfRUdMX2ltYWdlX2V4dGVybmFsX2Vzc2wzIDEKI2RlZmluZSBHTF9FWFRfWVVWX3RhcmdldCAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCAxCiNkZWZpbmUgR0xfRVhUX3NoYWRvd19zYW1wbGVycyAxCiNkZWZpbmUgR0xfQU5EUk9JRF9leHRlbnNpb25fcGFja19lczMxYSAxCiNkZWZpbmUgR0xfS0hSX2JsZW5kX2VxdWF0aW9uX2FkdmFuY2VkIDEKI2RlZmluZSBHTF9PRVNfc2FtcGxlX3ZhcmlhYmxlcyAxCiNkZWZpbmUgR0xfT0VTX3NoYWRlcl9pbWFnZV9hdG9taWMgMQojZGVmaW5lIEdMX09FU19zaGFkZXJfbXVsdGlzYW1wbGVfaW50ZXJwb2xhdGlvbiAxCiNkZWZpbmUgR0xfT0VTX3RleHR1cmVfc3RvcmFnZV9tdWx0aXNhbXBsZV8yZF9hcnJheSAxCiNkZWZpbmUgR0xfRVhUX2dlb21ldHJ5X3NoYWRlciAxCiNkZWZpbmUgR0xfRVhUX2dlb21ldHJ5X3BvaW50X3NpemUgMQojZGVmaW5lIEdMX0VYVF9ncHVfc2hhZGVyNSAxCiNkZWZpbmUgR0xfRVhUX3ByaW1pdGl2ZV9ib3VuZGluZ19ib3ggMQojZGVmaW5lIEdMX0VYVF9zaGFkZXJfaW9fYmxvY2tzIDEKI2RlZmluZSBHTF9FWFRfdGVzc2VsbGF0aW9uX3NoYWRlciAxCiNkZWZpbmUgR0xfRVhUX3Rlc3NlbGxhdGlvbl9wb2ludF9zaXplIDEKI2RlZmluZSBHTF9FWFRfdGV4dHVyZV9idWZmZXIgMQojZGVmaW5lIEdMX0VYVF90ZXh0dXJlX2N1YmVfbWFwX2FycmF5IDEKI2RlZmluZSBHTF9PRVNfZ2VvbWV0cnlfc2hhZGVyIDEKI2RlZmluZSBHTF9PRVNfZ2VvbWV0cnlfcG9pbnRfc2l6ZSAxCiNkZWZpbmUgR0xfT0VTX2dwdV9zaGFkZXI1IDEKI2RlZmluZSBHTF9PRVNfcHJpbWl0aXZlX2JvdW5kaW5nX2JveCAxCiNkZWZpbmUgR0xfT0VTX3NoYWRlcl9pb19ibG9ja3MgMQojZGVmaW5lIEdMX09FU190ZXNzZWxsYXRpb25fc2hhZGVyIDEKI2RlZmluZSBHTF9PRVNfdGVzc2VsbGF0aW9uX3BvaW50X3NpemUgMQojZGVmaW5lIEdMX09FU190ZXh0dXJlX2J1ZmZlciAxCiNkZWZpbmUgR0xfT0VTX3RleHR1cmVfY3ViZV9tYXBfYXJyYXkgMQojZGVmaW5lIEdMX0VYVF9zaGFkZXJfbm9uX2NvbnN0YW50X2dsb2JhbF9pbml0aWFsaXplcnMgMQoAI2RlZmluZSBHTF9OVl9zaGFkZXJfbm9wZXJzcGVjdGl2ZV9pbnRlcnBvbGF0aW9uIDEKACNkZWZpbmUgR0xfRlJBR01FTlRfUFJFQ0lTSU9OX0hJR0ggMQojZGVmaW5lIEdMX0FSQl90ZXh0dXJlX3JlY3RhbmdsZSAxCiNkZWZpbmUgR0xfQVJCX3NoYWRpbmdfbGFuZ3VhZ2VfNDIwcGFjayAxCiNkZWZpbmUgR0xfQVJCX3RleHR1cmVfZ2F0aGVyIDEKI2RlZmluZSBHTF9BUkJfZ3B1X3NoYWRlcjUgMQojZGVmaW5lIEdMX0FSQl9zZXBhcmF0ZV9zaGFkZXJfb2JqZWN0cyAxCiNkZWZpbmUgR0xfQVJCX2NvbXB1dGVfc2hhZGVyIDEKI2RlZmluZSBHTF9BUkJfdGVzc2VsbGF0aW9uX3NoYWRlciAxCiNkZWZpbmUgR0xfQVJCX2VuaGFuY2VkX2xheW91dHMgMQojZGVmaW5lIEdMX0FSQl90ZXh0dXJlX2N1YmVfbWFwX2FycmF5IDEKI2RlZmluZSBHTF9BUkJfc2hhZGVyX3RleHR1cmVfbG9kIDEKI2RlZmluZSBHTF9BUkJfZXhwbGljaXRfYXR0cmliX2xvY2F0aW9uIDEKI2RlZmluZSBHTF9BUkJfZXhwbGljaXRfdW5pZm9ybV9sb2NhdGlvbiAxCiNkZWZpbmUgR0xfQVJCX3NoYWRlcl9pbWFnZV9sb2FkX3N0b3JlIDEKI2RlZmluZSBHTF9BUkJfc2hhZGVyX2F0b21pY19jb3VudGVycyAxCiNkZWZpbmUgR0xfQVJCX3NoYWRlcl9kcmF3X3BhcmFtZXRlcnMgMQojZGVmaW5lIEdMX0FSQl9zaGFkZXJfZ3JvdXBfdm90ZSAxCiNkZWZpbmUgR0xfQVJCX2Rlcml2YXRpdmVfY29udHJvbCAxCiNkZWZpbmUgR0xfQVJCX3NoYWRlcl90ZXh0dXJlX2ltYWdlX3NhbXBsZXMgMQojZGVmaW5lIEdMX0FSQl92aWV3cG9ydF9hcnJheSAxCiNkZWZpbmUgR0xfQVJCX2dwdV9zaGFkZXJfaW50NjQgMQojZGVmaW5lIEdMX0FSQl9zaGFkZXJfYmFsbG90IDEKI2RlZmluZSBHTF9BUkJfc3BhcnNlX3RleHR1cmUyIDEKI2RlZmluZSBHTF9BUkJfc3BhcnNlX3RleHR1cmVfY2xhbXAgMQojZGVmaW5lIEdMX0FSQl9zaGFkZXJfc3RlbmNpbF9leHBvcnQgMQojZGVmaW5lIEdMX0FSQl9wb3N0X2RlcHRoX2NvdmVyYWdlIDEKI2RlZmluZSBHTF9BUkJfZnJhZ21lbnRfc2hhZGVyX2ludGVybG9jayAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9ub25fY29uc3RhbnRfZ2xvYmFsX2luaXRpYWxpemVycyAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9pbWFnZV9sb2FkX2Zvcm1hdHRlZCAxCiNkZWZpbmUgR0xfRVhUX3Bvc3RfZGVwdGhfY292ZXJhZ2UgMQojZGVmaW5lIEdMX0VYVF9jb250cm9sX2Zsb3dfYXR0cmlidXRlcyAxCiNkZWZpbmUgR0xfRVhUX25vbnVuaWZvcm1fcXVhbGlmaWVyIDEKI2RlZmluZSBHTF9FWFRfc2hhZGVyXzE2Yml0X3N0b3JhZ2UgMQojZGVmaW5lIEdMX0VYVF9zaGFkZXJfOGJpdF9zdG9yYWdlIDEKI2RlZmluZSBHTF9FWFRfc2FtcGxlcmxlc3NfdGV4dHVyZV9mdW5jdGlvbnMgMQojZGVmaW5lIEdMX0VYVF9zY2FsYXJfYmxvY2tfbGF5b3V0IDEKI2RlZmluZSBHTF9FWFRfZnJhZ21lbnRfaW52b2NhdGlvbl9kZW5zaXR5IDEKI2RlZmluZSBHTF9FWFRfYnVmZmVyX3JlZmVyZW5jZSAxCiNkZWZpbmUgR0xfRVhUX2J1ZmZlcl9yZWZlcmVuY2UyIDEKI2RlZmluZSBHTF9FWFRfYnVmZmVyX3JlZmVyZW5jZV91dmVjMiAxCiNkZWZpbmUgR0xfRVhUX2RlbW90ZV90b19oZWxwZXJfaW52b2NhdGlvbiAxCiNkZWZpbmUgR0xfS0hSX3NoYWRlcl9zdWJncm91cF9iYXNpYyAxCiNkZWZpbmUgR0xfS0hSX3NoYWRlcl9zdWJncm91cF92b3RlIDEKI2RlZmluZSBHTF9LSFJfc2hhZGVyX3N1Ymdyb3VwX2FyaXRobWV0aWMgMQojZGVmaW5lIEdMX0tIUl9zaGFkZXJfc3ViZ3JvdXBfYmFsbG90IDEKI2RlZmluZSBHTF9LSFJfc2hhZGVyX3N1Ymdyb3VwX3NodWZmbGUgMQojZGVmaW5lIEdMX0tIUl9zaGFkZXJfc3ViZ3JvdXBfc2h1ZmZsZV9yZWxhdGl2ZSAxCiNkZWZpbmUgR0xfS0hSX3NoYWRlcl9zdWJncm91cF9jbHVzdGVyZWQgMQojZGVmaW5lIEdMX0tIUl9zaGFkZXJfc3ViZ3JvdXBfcXVhZCAxCiNkZWZpbmUgRV9HTF9FWFRfc2hhZGVyX2F0b21pY19pbnQ2NCAxCiNkZWZpbmUgRV9HTF9FWFRfc2hhZGVyX3JlYWx0aW1lX2Nsb2NrIDEKI2RlZmluZSBHTF9BTURfc2hhZGVyX2JhbGxvdCAxCiNkZWZpbmUgR0xfQU1EX3NoYWRlcl90cmluYXJ5X21pbm1heCAxCiNkZWZpbmUgR0xfQU1EX3NoYWRlcl9leHBsaWNpdF92ZXJ0ZXhfcGFyYW1ldGVyIDEKI2RlZmluZSBHTF9BTURfZ2NuX3NoYWRlciAxCiNkZWZpbmUgR0xfQU1EX2dwdV9zaGFkZXJfaGFsZl9mbG9hdCAxCiNkZWZpbmUgR0xfQU1EX3RleHR1cmVfZ2F0aGVyX2JpYXNfbG9kIDEKI2RlZmluZSBHTF9BTURfZ3B1X3NoYWRlcl9pbnQxNiAxCiNkZWZpbmUgR0xfQU1EX3NoYWRlcl9pbWFnZV9sb2FkX3N0b3JlX2xvZCAxCiNkZWZpbmUgR0xfQU1EX3NoYWRlcl9mcmFnbWVudF9tYXNrIDEKI2RlZmluZSBHTF9BTURfZ3B1X3NoYWRlcl9oYWxmX2Zsb2F0X2ZldGNoIDEKI2RlZmluZSBHTF9OVl9zYW1wbGVfbWFza19vdmVycmlkZV9jb3ZlcmFnZSAxCiNkZWZpbmUgR0xfTlZfZ2VvbWV0cnlfc2hhZGVyX3Bhc3N0aHJvdWdoIDEKI2RlZmluZSBHTF9OVl92aWV3cG9ydF9hcnJheTIgMQojZGVmaW5lIEdMX05WX3NoYWRlcl9hdG9taWNfaW50NjQgMQojZGVmaW5lIEdMX05WX2NvbnNlcnZhdGl2ZV9yYXN0ZXJfdW5kZXJlc3RpbWF0aW9uIDEKI2RlZmluZSBHTF9OVl9zaGFkZXJfc3ViZ3JvdXBfcGFydGl0aW9uZWQgMQojZGVmaW5lIEdMX05WX3NoYWRpbmdfcmF0ZV9pbWFnZSAxCiNkZWZpbmUgR0xfTlZfcmF5X3RyYWNpbmcgMQojZGVmaW5lIEdMX05WX2ZyYWdtZW50X3NoYWRlcl9iYXJ5Y2VudHJpYyAxCiNkZWZpbmUgR0xfTlZfY29tcHV0ZV9zaGFkZXJfZGVyaXZhdGl2ZXMgMQojZGVmaW5lIEdMX05WX3NoYWRlcl90ZXh0dXJlX2Zvb3RwcmludCAxCiNkZWZpbmUgR0xfTlZfbWVzaF9zaGFkZXIgMQojZGVmaW5lIEdMX05WX2Nvb3BlcmF0aXZlX21hdHJpeCAxCiNkZWZpbmUgR0xfTlZfaW50ZWdlcl9jb29wZXJhdGl2ZV9tYXRyaXggMQojZGVmaW5lIEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlcyAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2ludDggMQojZGVmaW5lIEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlc19pbnQxNiAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2ludDMyIDEKI2RlZmluZSBHTF9FWFRfc2hhZGVyX2V4cGxpY2l0X2FyaXRobWV0aWNfdHlwZXNfaW50NjQgMQojZGVmaW5lIEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlc19mbG9hdDE2IDEKI2RlZmluZSBHTF9FWFRfc2hhZGVyX2V4cGxpY2l0X2FyaXRobWV0aWNfdHlwZXNfZmxvYXQzMiAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2Zsb2F0NjQgMQojZGVmaW5lIEdMX0VYVF9zaGFkZXJfc3ViZ3JvdXBfZXh0ZW5kZWRfdHlwZXNfaW50OCAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9zdWJncm91cF9leHRlbmRlZF90eXBlc19pbnQxNiAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9zdWJncm91cF9leHRlbmRlZF90eXBlc19pbnQ2NCAxCiNkZWZpbmUgR0xfRVhUX3NoYWRlcl9zdWJncm91cF9leHRlbmRlZF90eXBlc19mbG9hdDE2IDEKACNkZWZpbmUgR0xfY29yZV9wcm9maWxlIDEKACNkZWZpbmUgR0xfY29tcGF0aWJpbGl0eV9wcm9maWxlIDEKACNkZWZpbmUgR0xfRVhUX2RldmljZV9ncm91cCAxCiNkZWZpbmUgR0xfRVhUX211bHRpdmlldyAxCiNkZWZpbmUgR0xfTlZfc2hhZGVyX3NtX2J1aWx0aW5zIDEKACNkZWZpbmUgR0xfT1ZSX211bHRpdmlldyAxCiNkZWZpbmUgR0xfT1ZSX211bHRpdmlldzIgMQoAI2RlZmluZSBHTF9HT09HTEVfY3BwX3N0eWxlX2xpbmVfZGlyZWN0aXZlIDEKI2RlZmluZSBHTF9HT09HTEVfaW5jbHVkZV9kaXJlY3RpdmUgMQoAI2RlZmluZSBWVUxLQU4gACNkZWZpbmUgR0xfU1BJUlYgABL9AwAZ/QMALv0DAEb9AwBP/QMAWP0DAGD9AwBv/QMAfP0DAIT9AwCQ/QMAlf0DAJ79AwCj/QMAdW5rbm93biBzdGFnZQB2ZXJ0ZXgAdGVzc2VsbGF0aW9uIGNvbnRyb2wAdGVzc2VsbGF0aW9uIGV2YWx1YXRpb24AZ2VvbWV0cnkAZnJhZ21lbnQAY29tcHV0ZQByYXktZ2VuZXJhdGlvbgBpbnRlcnNlY3Rpb24AYW55LWhpdABjbG9zZXN0LWhpdABtaXNzAGNhbGxhYmxlAHRhc2sAbWVzaABub3Qgc3VwcG9ydGVkIGluIHRoaXMgc3RhZ2U6AG5vdCBzdXBwb3J0ZWQgd2l0aCB0aGlzIHByb2ZpbGU6AGV4dGVuc2lvbiAAIGlzIGJlaW5nIHVzZWQgZm9yIABub3Qgc3VwcG9ydGVkIGZvciB0aGlzIHZlcnNpb24gb3IgdGhlIGVuYWJsZWQgZXh0ZW5zaW9ucwBmZWF0dXJlIG5vdCB5ZXQgaW1wbGVtZW50ZWQAZGVwcmVjYXRlZCwgbWF5IGJlIHJlbW92ZWQgaW4gZnV0dXJlIHJlbGVhc2UAIGRlcHJlY2F0ZWQgaW4gdmVyc2lvbiAAOyBtYXkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgcmVsZWFzZQAlcyBwcm9maWxlOyByZW1vdmVkIGluIHZlcnNpb24gJWQAbm8gbG9uZ2VyIHN1cHBvcnRlZCBpbgBUaGUgZm9sbG93aW5nIGV4dGVuc2lvbiBtdXN0IGJlIGVuYWJsZWQgdG8gdXNlIHRoaXMgZmVhdHVyZToAcmVxdWlyZWQgZXh0ZW5zaW9uIG5vdCByZXF1ZXN0ZWQ6AFBvc3NpYmxlIGV4dGVuc2lvbnMgaW5jbHVkZToAcmVxdWlyZQBlbmFibGUAZGlzYWJsZQB3YXJuAGJlaGF2aW9yIG5vdCBzdXBwb3J0ZWQ6AGV4dGVuc2lvbiAnYWxsJyBjYW5ub3QgaGF2ZSAncmVxdWlyZScgb3IgJ2VuYWJsZScgYmVoYXZpb3IAZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQ6AGV4dGVuc2lvbiBpcyBvbmx5IHBhcnRpYWxseSBzdXBwb3J0ZWQ6ACNleHRlbnNpb24gR0xfTlZfbWVzaF9zaGFkZXIAAFvhAwD/VAQA+eYDAOdUBAD/VAQAJ1UEAAAAAAD/VAQAnuYDADogAAAAAAAAW+EDALjgAwD/VAQA+eYDAP9UBAAp5wMA/1QEAFnnAwC34QMAQaCBEAvJAedUBAC44AMA/1QEACdVBADU4AMA/1QEAJ7mAwAAAAAA/1QEAMvmAwBVVQQA/1QEAG1VBABub3QgYWxsb3dlZCB3aGVuIGdlbmVyYXRpbmcgU1BJUi1WAG5vdCBhbGxvd2VkIHdoZW4gdXNpbmcgR0xTTCBmb3IgVnVsa2FuAG9ubHkgYWxsb3dlZCB3aGVuIHVzaW5nIEdMU0wgZm9yIFZ1bGthbgBvbmx5IGFsbG93ZWQgd2hlbiBnZW5lcmF0aW5nIFNQSVItVgBB9IIQC9pswgIAAMMCAADbAQAA3AEAAN0BAADeAQAA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6AEAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAO8BAADwAQAA8QEAAPIBAADzAQAA9AEAAPUBAAD2AQAA9wEAAPgBAAD5AQAA+gEAAPsBAAD8AQAA/QEAAP4BAAD/AQAAAAIAABsBAAAbAQAAGwEAABsBAABtb3ZlIHNlY29uZCBjaGlsZCB0byBmaXJzdCBjaGlsZABhZGQgc2Vjb25kIGNoaWxkIGludG8gZmlyc3QgY2hpbGQAc3VidHJhY3Qgc2Vjb25kIGNoaWxkIGludG8gZmlyc3QgY2hpbGQAbXVsdGlwbHkgc2Vjb25kIGNoaWxkIGludG8gZmlyc3QgY2hpbGQAbWF0cml4IG11bHQgc2Vjb25kIGNoaWxkIGludG8gZmlyc3QgY2hpbGQAdmVjdG9yIHNjYWxlIHNlY29uZCBjaGlsZCBpbnRvIGZpcnN0IGNoaWxkAG1hdHJpeCBzY2FsZSBzZWNvbmQgY2hpbGQgaW50byBmaXJzdCBjaGlsZABkaXZpZGUgc2Vjb25kIGNoaWxkIGludG8gZmlyc3QgY2hpbGQAbW9kIHNlY29uZCBjaGlsZCBpbnRvIGZpcnN0IGNoaWxkAGFuZCBzZWNvbmQgY2hpbGQgaW50byBmaXJzdCBjaGlsZABvciBzZWNvbmQgY2hpbGQgaW50byBmaXJzdCBjaGlsZABleGNsdXNpdmUgb3Igc2Vjb25kIGNoaWxkIGludG8gZmlyc3QgY2hpbGQAbGVmdCBzaGlmdCBzZWNvbmQgY2hpbGQgaW50byBmaXJzdCBjaGlsZAByaWdodCBzaGlmdCBzZWNvbmQgY2hpbGQgaW50byBmaXJzdCBjaGlsZABkaXJlY3QgaW5kZXgAaW5kaXJlY3QgaW5kZXgAOiBkaXJlY3QgaW5kZXggZm9yIHN0cnVjdHVyZQB2ZWN0b3Igc3dpenpsZQBhZGQAc3VidHJhY3QAY29tcG9uZW50LXdpc2UgbXVsdGlwbHkAZGl2aWRlAG1vZAByaWdodC1zaGlmdABsZWZ0LXNoaWZ0AGJpdHdpc2UgYW5kAGluY2x1c2l2ZS1vcgBleGNsdXNpdmUtb3IAQ29tcGFyZSBFcXVhbABDb21wYXJlIE5vdCBFcXVhbABDb21wYXJlIExlc3MgVGhhbgBDb21wYXJlIEdyZWF0ZXIgVGhhbgBDb21wYXJlIExlc3MgVGhhbiBvciBFcXVhbABDb21wYXJlIEdyZWF0ZXIgVGhhbiBvciBFcXVhbABFcXVhbABOb3RFcXVhbAB2ZWN0b3Itc2NhbGUAdmVjdG9yLXRpbWVzLW1hdHJpeABtYXRyaXgtdGltZXMtdmVjdG9yAG1hdHJpeC1zY2FsZQBtYXRyaXgtbXVsdGlwbHkAbG9naWNhbC1vcgBsb2dpY2FsLXhvcgBsb2dpY2FsLWFuZAA8dW5rbm93biBvcD4AICgALCBvcGVyYXRpb24gYXQgADoAPyAAICAATmVnYXRlIHZhbHVlAE5lZ2F0ZSBjb25kaXRpb25hbABCaXR3aXNlIG5vdABQb3N0LUluY3JlbWVudABQb3N0LURlY3JlbWVudABQcmUtSW5jcmVtZW50AFByZS1EZWNyZW1lbnQAY29weSBvYmplY3QAQ29udmVydCBpbnQ4X3QgdG8gYm9vbABDb252ZXJ0IHVpbnQ4X3QgdG8gYm9vbABDb252ZXJ0IGludDE2X3QgdG8gYm9vbABDb252ZXJ0IHVpbnQxNl90IHRvIGJvb2wAQ29udmVydCBpbnQgdG8gYm9vbABDb252ZXJ0IHVpbnQgdG8gYm9vbABDb252ZXJ0IGludDY0IHRvIGJvb2wAQ29udmVydCB1aW50NjQgdG8gYm9vbABDb252ZXJ0IGZsb2F0MTZfdCB0byBib29sAENvbnZlcnQgZmxvYXQgdG8gYm9vbABDb252ZXJ0IGRvdWJsZSB0byBib29sAENvbnZlcnQgYm9vbCB0byBpbnQ4X3QAQ29udmVydCBib29sIHRvIHVpbnQ4X3QAQ29udmVydCBib29sIHRvIGluMTZ0X3QAQ29udmVydCBib29sIHRvIHVpbnQxNl90AENvbnZlcnQgYm9vbCB0byBpbnQAQ29udmVydCBib29sIHRvIHVpbnQAQ29udmVydCBib29sIHRvIGludDY0AENvbnZlcnQgYm9vbCB0byB1aW50NjQAQ29udmVydCBib29sIHRvIGZsb2F0MTZfdABDb252ZXJ0IGJvb2wgdG8gZmxvYXQAQ29udmVydCBib29sIHRvIGRvdWJsZQBDb252ZXJ0IGludDhfdCB0byBpbnQxNl90AENvbnZlcnQgaW50OF90IHRvIGludABDb252ZXJ0IGludDhfdCB0byBpbnQ2NABDb252ZXJ0IGludDhfdCB0byB1aW50OF90AENvbnZlcnQgaW50OF90IHRvIHVpbnQxNl90AENvbnZlcnQgaW50OF90IHRvIHVpbnQAQ29udmVydCBpbnQ4X3QgdG8gdWludDY0AENvbnZlcnQgdWludDhfdCB0byBpbnQ4X3QAQ29udmVydCB1aW50OF90IHRvIGludDE2X3QAQ29udmVydCB1aW50OF90IHRvIGludABDb252ZXJ0IHVpbnQ4X3QgdG8gaW50NjQAQ29udmVydCB1aW50OF90IHRvIHVpbnQxNl90AENvbnZlcnQgdWludDhfdCB0byB1aW50AENvbnZlcnQgdWludDhfdCB0byB1aW50NjQAQ29udmVydCBpbnQ4X3QgdG8gZmxvYXQxNl90AENvbnZlcnQgaW50OF90IHRvIGZsb2F0AENvbnZlcnQgaW50OF90IHRvIGRvdWJsZQBDb252ZXJ0IHVpbnQ4X3QgdG8gZmxvYXQxNl90AENvbnZlcnQgdWludDhfdCB0byBmbG9hdABDb252ZXJ0IHVpbnQ4X3QgdG8gZG91YmxlAENvbnZlcnQgaW50MTZfdCB0byBpbnQ4X3QAQ29udmVydCBpbnQxNl90IHRvIGludABDb252ZXJ0IGludDE2X3QgdG8gaW50NjQAQ29udmVydCBpbnQxNl90IHRvIHVpbnQ4X3QAQ29udmVydCBpbnQxNl90IHRvIHVpbnQxNl90AENvbnZlcnQgaW50MTZfdCB0byB1aW50AENvbnZlcnQgaW50MTZfdCB0byB1aW50NjQAQ29udmVydCBpbnQxNl90IHRvIGZsb2F0MTZfdABDb252ZXJ0IGludDE2X3QgdG8gZmxvYXQAQ29udmVydCBpbnQxNl90IHRvIGRvdWJsZQBDb252ZXJ0IHVpbnQxNl90IHRvIGludDhfdABDb252ZXJ0IHVpbnQxNl90IHRvIGludDE2X3QAQ29udmVydCB1aW50MTZfdCB0byBpbnQAQ29udmVydCB1aW50MTZfdCB0byBpbnQ2NABDb252ZXJ0IHVpbnQxNl90IHRvIHVpbnQ4X3QAQ29udmVydCB1aW50MTZfdCB0byB1aW50AENvbnZlcnQgdWludDE2X3QgdG8gdWludDY0AENvbnZlcnQgdWludDE2X3QgdG8gZmxvYXQxNl90AENvbnZlcnQgdWludDE2X3QgdG8gZmxvYXQAQ29udmVydCB1aW50MTZfdCB0byBkb3VibGUAQ29udmVydCBpbnQgdG8gaW50OF90AENvbnZlcnQgaW50IHRvIGludDE2X3QAQ29udmVydCBpbnQgdG8gaW50NjQAQ29udmVydCBpbnQgdG8gdWludDhfdABDb252ZXJ0IGludCB0byB1aW50MTZfdABDb252ZXJ0IGludCB0byB1aW50AENvbnZlcnQgaW50IHRvIHVpbnQ2NABDb252ZXJ0IGludCB0byBmbG9hdDE2X3QAQ29udmVydCBpbnQgdG8gZmxvYXQAQ29udmVydCBpbnQgdG8gZG91YmxlAENvbnZlcnQgdWludCB0byBpbnQ4X3QAQ29udmVydCB1aW50IHRvIGludDE2X3QAQ29udmVydCB1aW50IHRvIGludABDb252ZXJ0IHVpbnQgdG8gaW50NjQAQ29udmVydCB1aW50IHRvIHVpbnQ4X3QAQ29udmVydCB1aW50IHRvIHVpbnQxNl90AENvbnZlcnQgdWludCB0byB1aW50NjQAQ29udmVydCB1aW50IHRvIGZsb2F0MTZfdABDb252ZXJ0IHVpbnQgdG8gZmxvYXQAQ29udmVydCB1aW50IHRvIGRvdWJsZQBDb252ZXJ0IGludDY0IHRvIGludDhfdABDb252ZXJ0IGludDY0IHRvIGludDE2X3QAQ29udmVydCBpbnQ2NCB0byBpbnQAQ29udmVydCBpbnQ2NCB0byB1aW50OF90AENvbnZlcnQgaW50NjQgdG8gdWludDE2X3QAQ29udmVydCBpbnQ2NCB0byB1aW50AENvbnZlcnQgaW50NjQgdG8gdWludDY0AENvbnZlcnQgaW50NjQgdG8gZmxvYXQxNl90AENvbnZlcnQgaW50NjQgdG8gZmxvYXQAQ29udmVydCBpbnQ2NCB0byBkb3VibGUAQ29udmVydCB1aW50NjQgdG8gaW50OF90AENvbnZlcnQgdWludDY0IHRvIGludDE2X3QAQ29udmVydCB1aW50NjQgdG8gaW50AENvbnZlcnQgdWludDY0IHRvIGludDY0AENvbnZlcnQgdWludDY0IHRvIHVpbnQ4X3QAQ29udmVydCB1aW50NjQgdG8gdWludDE2AENvbnZlcnQgdWludDY0IHRvIHVpbnQAQ29udmVydCB1aW50NjQgdG8gZmxvYXQxNl90AENvbnZlcnQgdWludDY0IHRvIGZsb2F0AENvbnZlcnQgdWludDY0IHRvIGRvdWJsZQBDb252ZXJ0IGZsb2F0MTZfdCB0byBpbnQ4X3QAQ29udmVydCBmbG9hdDE2X3QgdG8gaW50MTZfdABDb252ZXJ0IGZsb2F0MTZfdCB0byBpbnQAQ29udmVydCBmbG9hdDE2X3QgdG8gaW50NjQAQ29udmVydCBmbG9hdDE2X3QgdG8gdWludDhfdABDb252ZXJ0IGZsb2F0MTZfdCB0byB1aW50MTZfdABDb252ZXJ0IGZsb2F0MTZfdCB0byB1aW50AENvbnZlcnQgZmxvYXQxNl90IHRvIHVpbnQ2NABDb252ZXJ0IGZsb2F0MTZfdCB0byBmbG9hdABDb252ZXJ0IGZsb2F0MTZfdCB0byBkb3VibGUAQ29udmVydCBmbG9hdCB0byBmbG9hdDE2X3QAQ29udmVydCBmbG9hdCB0byBkb3VibGUAQ29udmVydCBmbG9hdCB0byBpbnQ4X3QAQ29udmVydCBmbG9hdCB0byBpbnQxNl90AENvbnZlcnQgZmxvYXQgdG8gaW50AENvbnZlcnQgZmxvYXQgdG8gaW50NjQAQ29udmVydCBmbG9hdCB0byB1aW50OF90AENvbnZlcnQgZmxvYXQgdG8gdWludDE2X3QAQ29udmVydCBmbG9hdCB0byB1aW50AENvbnZlcnQgZmxvYXQgdG8gdWludDY0AENvbnZlcnQgZG91YmxlIHRvIGZsb2F0MTZfdABDb252ZXJ0IGRvdWJsZSB0byBmbG9hdABDb252ZXJ0IGRvdWJsZSB0byBpbnQ4X3QAQ29udmVydCBkb3VibGUgdG8gaW50MTZfdABDb252ZXJ0IGRvdWJsZSB0byBpbnQAQ29udmVydCBkb3VibGUgdG8gaW50NjQAQ29udmVydCBkb3VibGUgdG8gdWludDhfdABDb252ZXJ0IGRvdWJsZSB0byB1aW50MTZfdABDb252ZXJ0IGRvdWJsZSB0byB1aW50AENvbnZlcnQgZG91YmxlIHRvIHVpbnQ2NABDb252ZXJ0IHVpbnQ2NF90IHRvIHBvaW50ZXIAQ29udmVydCBwb2ludGVyIHRvIHVpbnQ2NF90AHJhZGlhbnMAZGVncmVlcwBzaW5lAGNvc2luZQB0YW5nZW50AGFyYyBzaW5lAGFyYyBjb3NpbmUAYXJjIHRhbmdlbnQAaHlwLiBzaW5lAGh5cC4gY29zaW5lAGh5cC4gdGFuZ2VudABhcmMgaHlwLiBzaW5lAGFyYyBoeXAuIGNvc2luZQBhcmMgaHlwLiB0YW5nZW50AGV4cABsb2cAZXhwMgBsb2cyAHNxcnQAaW52ZXJzZSBzcXJ0AEFic29sdXRlIHZhbHVlAFNpZ24ARmxvb3IAdHJ1bmMAcm91bmQAcm91bmRFdmVuAENlaWxpbmcARnJhY3Rpb24AaXNuYW4AaXNpbmYAZmxvYXRCaXRzVG9JbnQAZmxvYXRCaXRzVG9VaW50AGludEJpdHNUb0Zsb2F0AHVpbnRCaXRzVG9GbG9hdABkb3VibGVCaXRzVG9JbnQ2NABkb3VibGVCaXRzVG9VaW50NjQAaW50NjRCaXRzVG9Eb3VibGUAdWludDY0Qml0c1RvRG91YmxlAGZsb2F0MTZCaXRzVG9JbnQxNgBmbG9hdDE2Qml0c1RvVWludDE2AGludDE2Qml0c1RvRmxvYXQxNgB1aW50MTZCaXRzVG9GbG9hdDE2AHBhY2tTbm9ybTJ4MTYAdW5wYWNrU25vcm0yeDE2AHBhY2tVbm9ybTJ4MTYAdW5wYWNrVW5vcm0yeDE2AHBhY2tIYWxmMngxNgB1bnBhY2tIYWxmMngxNgBwYWNrMTYAcGFjazMyAHBhY2s2NAB1bnBhY2szMgB1bnBhY2sxNgB1bnBhY2s4AFBhY2tTbm9ybTR4OABVbnBhY2tTbm9ybTR4OABQYWNrVW5vcm00eDgAVW5wYWNrVW5vcm00eDgAUGFja0RvdWJsZTJ4MzIAVW5wYWNrRG91YmxlMngzMgBwYWNrSW50MngzMgB1bnBhY2tJbnQyeDMyAHBhY2tVaW50MngzMgB1bnBhY2tVaW50MngzMgBwYWNrSW50MngxNgB1bnBhY2tJbnQyeDE2AHBhY2tVaW50MngxNgB1bnBhY2tVaW50MngxNgBwYWNrSW50NHgxNgB1bnBhY2tJbnQ0eDE2AHBhY2tVaW50NHgxNgB1bnBhY2tVaW50NHgxNgBwYWNrRmxvYXQyeDE2AHVucGFja0Zsb2F0MngxNgBsZW5ndGgAbm9ybWFsaXplAGRQZHgAZFBkeQBmd2lkdGgAZFBkeEZpbmUAZFBkeUZpbmUAZndpZHRoRmluZQBkUGR4Q29hcnNlAGRQZHlDb2Fyc2UAZndpZHRoQ29hcnNlAGludGVycG9sYXRlQXRDZW50cm9pZABkZXRlcm1pbmFudABpbnZlcnNlAHRyYW5zcG9zZQBhbnkAYWxsAGFycmF5IGxlbmd0aABFbWl0U3RyZWFtVmVydGV4AEVuZFN0cmVhbVByaW1pdGl2ZQBBdG9taWNDb3VudGVySW5jcmVtZW50AEF0b21pY0NvdW50ZXJEZWNyZW1lbnQAQXRvbWljQ291bnRlcgB0ZXh0dXJlU2l6ZQB0ZXh0dXJlUXVlcnlMb2QAdGV4dHVyZVF1ZXJ5TGV2ZWxzAHRleHR1cmVTYW1wbGVzAGltYWdlUXVlcnlTaXplAGltYWdlUXVlcnlTYW1wbGVzAGltYWdlTG9hZABiaXRGaWVsZFJldmVyc2UAYml0Q291bnQAZmluZExTQgBmaW5kTVNCAG5vaXNlAGJhbGxvdAByZWFkRmlyc3RJbnZvY2F0aW9uAGFueUludm9jYXRpb24AYWxsSW52b2NhdGlvbnMAYWxsSW52b2NhdGlvbnNFcXVhbABzdWJncm91cEVsZWN0AHN1Ymdyb3VwQWxsAHN1Ymdyb3VwQW55AHN1Ymdyb3VwQWxsRXF1YWwAc3ViZ3JvdXBCcm9hZGNhc3QAc3ViZ3JvdXBCcm9hZGNhc3RGaXJzdABzdWJncm91cEJhbGxvdABzdWJncm91cEludmVyc2VCYWxsb3QAc3ViZ3JvdXBCYWxsb3RCaXRFeHRyYWN0AHN1Ymdyb3VwQmFsbG90Qml0Q291bnQAc3ViZ3JvdXBCYWxsb3RJbmNsdXNpdmVCaXRDb3VudABzdWJncm91cEJhbGxvdEV4Y2x1c2l2ZUJpdENvdW50AHN1Ymdyb3VwQmFsbG90RmluZExTQgBzdWJncm91cEJhbGxvdEZpbmRNU0IAc3ViZ3JvdXBTaHVmZmxlAHN1Ymdyb3VwU2h1ZmZsZVhvcgBzdWJncm91cFNodWZmbGVVcABzdWJncm91cFNodWZmbGVEb3duAHN1Ymdyb3VwQWRkAHN1Ymdyb3VwTXVsAHN1Ymdyb3VwTWluAHN1Ymdyb3VwTWF4AHN1Ymdyb3VwQW5kAHN1Ymdyb3VwT3IAc3ViZ3JvdXBYb3IAc3ViZ3JvdXBJbmNsdXNpdmVBZGQAc3ViZ3JvdXBJbmNsdXNpdmVNdWwAc3ViZ3JvdXBJbmNsdXNpdmVNaW4Ac3ViZ3JvdXBJbmNsdXNpdmVNYXgAc3ViZ3JvdXBJbmNsdXNpdmVBbmQAc3ViZ3JvdXBJbmNsdXNpdmVPcgBzdWJncm91cEluY2x1c2l2ZVhvcgBzdWJncm91cEV4Y2x1c2l2ZUFkZABzdWJncm91cEV4Y2x1c2l2ZU11bABzdWJncm91cEV4Y2x1c2l2ZU1pbgBzdWJncm91cEV4Y2x1c2l2ZU1heABzdWJncm91cEV4Y2x1c2l2ZUFuZABzdWJncm91cEV4Y2x1c2l2ZU9yAHN1Ymdyb3VwRXhjbHVzaXZlWG9yAHN1Ymdyb3VwQ2x1c3RlcmVkQWRkAHN1Ymdyb3VwQ2x1c3RlcmVkTXVsAHN1Ymdyb3VwQ2x1c3RlcmVkTWluAHN1Ymdyb3VwQ2x1c3RlcmVkTWF4AHN1Ymdyb3VwQ2x1c3RlcmVkQW5kAHN1Ymdyb3VwQ2x1c3RlcmVkT3IAc3ViZ3JvdXBDbHVzdGVyZWRYb3IAc3ViZ3JvdXBRdWFkQnJvYWRjYXN0AHN1Ymdyb3VwUXVhZFN3YXBIb3Jpem9udGFsAHN1Ymdyb3VwUXVhZFN3YXBWZXJ0aWNhbABzdWJncm91cFF1YWRTd2FwRGlhZ29uYWwAc3ViZ3JvdXBQYXJ0aXRpb25OVgBzdWJncm91cFBhcnRpdGlvbmVkQWRkTlYAc3ViZ3JvdXBQYXJ0aXRpb25lZE11bE5WAHN1Ymdyb3VwUGFydGl0aW9uZWRNaW5OVgBzdWJncm91cFBhcnRpdGlvbmVkTWF4TlYAc3ViZ3JvdXBQYXJ0aXRpb25lZEFuZE5WAHN1Ymdyb3VwUGFydGl0aW9uZWRPck5WAHN1Ymdyb3VwUGFydGl0aW9uZWRYb3JOVgBzdWJncm91cFBhcnRpdGlvbmVkSW5jbHVzaXZlQWRkTlYAc3ViZ3JvdXBQYXJ0aXRpb25lZEluY2x1c2l2ZU11bE5WAHN1Ymdyb3VwUGFydGl0aW9uZWRJbmNsdXNpdmVNaW5OVgBzdWJncm91cFBhcnRpdGlvbmVkSW5jbHVzaXZlTWF4TlYAc3ViZ3JvdXBQYXJ0aXRpb25lZEluY2x1c2l2ZUFuZE5WAHN1Ymdyb3VwUGFydGl0aW9uZWRJbmNsdXNpdmVPck5WAHN1Ymdyb3VwUGFydGl0aW9uZWRJbmNsdXNpdmVYb3JOVgBzdWJncm91cFBhcnRpdGlvbmVkRXhjbHVzaXZlQWRkTlYAc3ViZ3JvdXBQYXJ0aXRpb25lZEV4Y2x1c2l2ZU11bE5WAHN1Ymdyb3VwUGFydGl0aW9uZWRFeGNsdXNpdmVNaW5OVgBzdWJncm91cFBhcnRpdGlvbmVkRXhjbHVzaXZlTWF4TlYAc3ViZ3JvdXBQYXJ0aXRpb25lZEV4Y2x1c2l2ZUFuZE5WAHN1Ymdyb3VwUGFydGl0aW9uZWRFeGNsdXNpdmVPck5WAHN1Ymdyb3VwUGFydGl0aW9uZWRFeGNsdXNpdmVYb3JOVgBjbGlwAGlzZmluaXRlAGxvZzEwAHJjcABzYXR1cmF0ZQBzcGFyc2VUZXhlbHNSZXNpZGVudABtaW5JbnZvY2F0aW9ucwBtYXhJbnZvY2F0aW9ucwBhZGRJbnZvY2F0aW9ucwBtaW5JbnZvY2F0aW9uc05vblVuaWZvcm0AbWF4SW52b2NhdGlvbnNOb25Vbmlmb3JtAGFkZEludm9jYXRpb25zTm9uVW5pZm9ybQBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW4AbWF4SW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuAGFkZEludm9jYXRpb25zSW5jbHVzaXZlU2NhbgBtaW5JbnZvY2F0aW9uc0luY2x1c2l2ZVNjYW5Ob25Vbmlmb3JtAG1heEludm9jYXRpb25zSW5jbHVzaXZlU2Nhbk5vblVuaWZvcm0AYWRkSW52b2NhdGlvbnNJbmNsdXNpdmVTY2FuTm9uVW5pZm9ybQBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW4AbWF4SW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuAGFkZEludm9jYXRpb25zRXhjbHVzaXZlU2NhbgBtaW5JbnZvY2F0aW9uc0V4Y2x1c2l2ZVNjYW5Ob25Vbmlmb3JtAG1heEludm9jYXRpb25zRXhjbHVzaXZlU2Nhbk5vblVuaWZvcm0AYWRkSW52b2NhdGlvbnNFeGNsdXNpdmVTY2FuTm9uVW5pZm9ybQBtYmNudABmcmFnbWVudE1hc2tGZXRjaEFNRABmcmFnbWVudEZldGNoQU1EAGN1YmVGYWNlSW5kZXgAY3ViZUZhY2VDb29yZABzdWJwYXNzTG9hZABzdWJwYXNzTG9hZE1TAENvbnN0cnVjdCByZWZlcmVuY2UgdHlwZQBCYWQgdW5hcnkgb3AAbm9kZSBpcyBzdGlsbCBFT3BOdWxsIQBTZXF1ZW5jZQoATGlua2VyIE9iamVjdHMKAENvbW1hAEZ1bmN0aW9uIERlZmluaXRpb246IABGdW5jdGlvbiBDYWxsOiAARnVuY3Rpb24gUGFyYW1ldGVyczogAENvbnN0cnVjdCBmbG9hdABDb25zdHJ1Y3QgZG91YmxlAENvbnN0cnVjdCB2ZWMyAENvbnN0cnVjdCB2ZWMzAENvbnN0cnVjdCB2ZWM0AENvbnN0cnVjdCBkdmVjMgBDb25zdHJ1Y3QgZHZlYzMAQ29uc3RydWN0IGR2ZWM0AENvbnN0cnVjdCBib29sAENvbnN0cnVjdCBidmVjMgBDb25zdHJ1Y3QgYnZlYzMAQ29uc3RydWN0IGJ2ZWM0AENvbnN0cnVjdCBpbnQ4X3QAQ29uc3RydWN0IGk4dmVjMgBDb25zdHJ1Y3QgaTh2ZWMzAENvbnN0cnVjdCBpOHZlYzQAQ29uc3RydWN0IGludABDb25zdHJ1Y3QgaXZlYzIAQ29uc3RydWN0IGl2ZWMzAENvbnN0cnVjdCBpdmVjNABDb25zdHJ1Y3QgdWludDhfdABDb25zdHJ1Y3QgdTh2ZWMyAENvbnN0cnVjdCB1OHZlYzMAQ29uc3RydWN0IHU4dmVjNABDb25zdHJ1Y3QgdWludABDb25zdHJ1Y3QgdXZlYzIAQ29uc3RydWN0IHV2ZWMzAENvbnN0cnVjdCB1dmVjNABDb25zdHJ1Y3QgaW50NjQAQ29uc3RydWN0IGk2NHZlYzIAQ29uc3RydWN0IGk2NHZlYzMAQ29uc3RydWN0IGk2NHZlYzQAQ29uc3RydWN0IHVpbnQ2NABDb25zdHJ1Y3QgdTY0dmVjMgBDb25zdHJ1Y3QgdTY0dmVjMwBDb25zdHJ1Y3QgdTY0dmVjNABDb25zdHJ1Y3QgaW50MTZfdABDb25zdHJ1Y3QgaTE2dmVjMgBDb25zdHJ1Y3QgaTE2dmVjMwBDb25zdHJ1Y3QgaTE2dmVjNABDb25zdHJ1Y3QgdWludDE2X3QAQ29uc3RydWN0IHUxNnZlYzIAQ29uc3RydWN0IHUxNnZlYzMAQ29uc3RydWN0IHUxNnZlYzQAQ29uc3RydWN0IG1hdDIAQ29uc3RydWN0IG1hdDJ4MwBDb25zdHJ1Y3QgbWF0Mng0AENvbnN0cnVjdCBtYXQzeDIAQ29uc3RydWN0IG1hdDMAQ29uc3RydWN0IG1hdDN4NABDb25zdHJ1Y3QgbWF0NHgyAENvbnN0cnVjdCBtYXQ0eDMAQ29uc3RydWN0IG1hdDQAQ29uc3RydWN0IGRtYXQyAENvbnN0cnVjdCBkbWF0MngzAENvbnN0cnVjdCBkbWF0Mng0AENvbnN0cnVjdCBkbWF0M3gyAENvbnN0cnVjdCBkbWF0MwBDb25zdHJ1Y3QgZG1hdDN4NABDb25zdHJ1Y3QgZG1hdDR4MgBDb25zdHJ1Y3QgZG1hdDR4MwBDb25zdHJ1Y3QgZG1hdDQAQ29uc3RydWN0IGltYXQyAENvbnN0cnVjdCBpbWF0MngzAENvbnN0cnVjdCBpbWF0Mng0AENvbnN0cnVjdCBpbWF0M3gyAENvbnN0cnVjdCBpbWF0MwBDb25zdHJ1Y3QgaW1hdDN4NABDb25zdHJ1Y3QgaW1hdDR4MgBDb25zdHJ1Y3QgaW1hdDR4MwBDb25zdHJ1Y3QgaW1hdDQAQ29uc3RydWN0IHVtYXQyAENvbnN0cnVjdCB1bWF0MngzAENvbnN0cnVjdCB1bWF0Mng0AENvbnN0cnVjdCB1bWF0M3gyAENvbnN0cnVjdCB1bWF0MwBDb25zdHJ1Y3QgdW1hdDN4NABDb25zdHJ1Y3QgdW1hdDR4MgBDb25zdHJ1Y3QgdW1hdDR4MwBDb25zdHJ1Y3QgdW1hdDQAQ29uc3RydWN0IGJtYXQyAENvbnN0cnVjdCBibWF0MngzAENvbnN0cnVjdCBibWF0Mng0AENvbnN0cnVjdCBibWF0M3gyAENvbnN0cnVjdCBibWF0MwBDb25zdHJ1Y3QgYm1hdDN4NABDb25zdHJ1Y3QgYm1hdDR4MgBDb25zdHJ1Y3QgYm1hdDR4MwBDb25zdHJ1Y3QgYm1hdDQAQ29uc3RydWN0IGZsb2F0MTZfdABDb25zdHJ1Y3QgZjE2dmVjMgBDb25zdHJ1Y3QgZjE2dmVjMwBDb25zdHJ1Y3QgZjE2dmVjNABDb25zdHJ1Y3QgZjE2bWF0MgBDb25zdHJ1Y3QgZjE2bWF0MngzAENvbnN0cnVjdCBmMTZtYXQyeDQAQ29uc3RydWN0IGYxNm1hdDN4MgBDb25zdHJ1Y3QgZjE2bWF0MwBDb25zdHJ1Y3QgZjE2bWF0M3g0AENvbnN0cnVjdCBmMTZtYXQ0eDIAQ29uc3RydWN0IGYxNm1hdDR4MwBDb25zdHJ1Y3QgZjE2bWF0NABDb25zdHJ1Y3Qgc3RydWN0dXJlAENvbnN0cnVjdCBjb21iaW5lZCB0ZXh0dXJlLXNhbXBsZXIAQ29uc3RydWN0IHJlZmVyZW5jZQBDb25zdHJ1Y3QgY29vcGVyYXRpdmUgbWF0cml4AG1vZGYAcG93AG1pbgBtYXgAY2xhbXAAbWl4AHN0ZXAAc21vb3Roc3RlcABkaXN0YW5jZQBkb3QtcHJvZHVjdABjcm9zcy1wcm9kdWN0AGZhY2UtZm9yd2FyZAByZWZsZWN0AHJlZnJhY3QAb3V0ZXIgcHJvZHVjdABFbWl0VmVydGV4AEVuZFByaW1pdGl2ZQBCYXJyaWVyAE1lbW9yeUJhcnJpZXIATWVtb3J5QmFycmllckF0b21pY0NvdW50ZXIATWVtb3J5QmFycmllckJ1ZmZlcgBNZW1vcnlCYXJyaWVySW1hZ2UATWVtb3J5QmFycmllclNoYXJlZABHcm91cE1lbW9yeUJhcnJpZXIAcmVhZEludm9jYXRpb24Ac3dpenpsZUludm9jYXRpb25zAHN3aXp6bGVJbnZvY2F0aW9uc01hc2tlZAB3cml0ZUludm9jYXRpb24AbWluMwBtYXgzAG1pZDMAdGltZQBBdG9taWNBZGQAQXRvbWljTWluAEF0b21pY01heABBdG9taWNBbmQAQXRvbWljT3IAQXRvbWljWG9yAEF0b21pY0V4Y2hhbmdlAEF0b21pY0NvbXBTd2FwAEF0b21pY0xvYWQAQXRvbWljU3RvcmUAQXRvbWljQ291bnRlckFkZABBdG9taWNDb3VudGVyU3VidHJhY3QAQXRvbWljQ291bnRlck1pbgBBdG9taWNDb3VudGVyTWF4AEF0b21pY0NvdW50ZXJBbmQAQXRvbWljQ291bnRlck9yAEF0b21pY0NvdW50ZXJYb3IAQXRvbWljQ291bnRlckV4Y2hhbmdlAEF0b21pY0NvdW50ZXJDb21wU3dhcABpbWFnZVN0b3JlAGltYWdlQXRvbWljQWRkAGltYWdlQXRvbWljTWluAGltYWdlQXRvbWljTWF4AGltYWdlQXRvbWljQW5kAGltYWdlQXRvbWljT3IAaW1hZ2VBdG9taWNYb3IAaW1hZ2VBdG9taWNFeGNoYW5nZQBpbWFnZUF0b21pY0NvbXBTd2FwAGltYWdlQXRvbWljTG9hZABpbWFnZUF0b21pY1N0b3JlAGltYWdlTG9hZExvZABpbWFnZVN0b3JlTG9kAHRleHR1cmUAdGV4dHVyZVByb2oAdGV4dHVyZUxvZAB0ZXh0dXJlT2Zmc2V0AHRleHR1cmVGZXRjaAB0ZXh0dXJlRmV0Y2hPZmZzZXQAdGV4dHVyZVByb2pPZmZzZXQAdGV4dHVyZUxvZE9mZnNldAB0ZXh0dXJlUHJvakxvZAB0ZXh0dXJlUHJvakxvZE9mZnNldAB0ZXh0dXJlR3JhZAB0ZXh0dXJlR3JhZE9mZnNldAB0ZXh0dXJlUHJvakdyYWQAdGV4dHVyZVByb2pHcmFkT2Zmc2V0AHRleHR1cmVHYXRoZXIAdGV4dHVyZUdhdGhlck9mZnNldAB0ZXh0dXJlR2F0aGVyT2Zmc2V0cwB0ZXh0dXJlQ2xhbXAAdGV4dHVyZU9mZnNldENsYW1wAHRleHR1cmVHcmFkQ2xhbXAAdGV4dHVyZUdyYWRPZmZzZXRDbGFtcAB0ZXh0dXJlR2F0aGVyTG9kAHRleHR1cmVHYXRoZXJMb2RPZmZzZXQAdGV4dHVyZUdhdGhlckxvZE9mZnNldHMAc3BhcnNlVGV4dHVyZQBzcGFyc2VUZXh0dXJlT2Zmc2V0AHNwYXJzZVRleHR1cmVMb2QAc3BhcnNlVGV4dHVyZUxvZE9mZnNldABzcGFyc2VUZXhlbEZldGNoAHNwYXJzZVRleGVsRmV0Y2hPZmZzZXQAc3BhcnNlVGV4dHVyZUdyYWQAc3BhcnNlVGV4dHVyZUdyYWRPZmZzZXQAc3BhcnNlVGV4dHVyZUdhdGhlcgBzcGFyc2VUZXh0dXJlR2F0aGVyT2Zmc2V0AHNwYXJzZVRleHR1cmVHYXRoZXJPZmZzZXRzAHNwYXJzZUltYWdlTG9hZABzcGFyc2VUZXh0dXJlQ2xhbXAAc3BhcnNlVGV4dHVyZU9mZnNldENsYW1wAHNwYXJzZVRleHR1cmVHcmFkQ2xhbXAAc3BhcnNlVGV4dHVyZUdyYWRPZmZzZXRDbGFtAHNwYXJzZVRleHR1cmVHYXRoZXJMb2QAc3BhcnNlVGV4dHVyZUdhdGhlckxvZE9mZnNldABzcGFyc2VUZXh0dXJlR2F0aGVyTG9kT2Zmc2V0cwBzcGFyc2VJbWFnZUxvYWRMb2QAaW1hZ2VTYW1wbGVGb290cHJpbnROVgBpbWFnZVNhbXBsZUZvb3RwcmludENsYW1wTlYAaW1hZ2VTYW1wbGVGb290cHJpbnRMb2ROVgBpbWFnZVNhbXBsZUZvb3RwcmludEdyYWROVgBtYWdlU2FtcGxlRm9vdHByaW50R3JhZENsYW1wTlYAYWRkQ2FycnkAc3ViQm9ycm93AHVNdWxFeHRlbmRlZABpTXVsRXh0ZW5kZWQAYml0ZmllbGRFeHRyYWN0AGJpdGZpZWxkSW5zZXJ0AGZtYQBmcmV4cABsZGV4cABpbnRlcnBvbGF0ZUF0U2FtcGxlAGludGVycG9sYXRlQXRPZmZzZXQAaW50ZXJwb2xhdGVBdFZlcnRleABzaW5jb3MAbXVsAEFsbE1lbW9yeUJhcnJpZXJXaXRoR3JvdXBTeW5jAERldmljZU1lbW9yeUJhcnJpZXIARGV2aWNlTWVtb3J5QmFycmllcldpdGhHcm91cFN5bmMAV29ya2dyb3VwTWVtb3J5QmFycmllcgBXb3JrZ3JvdXBNZW1vcnlCYXJyaWVyV2l0aEdyb3VwU3luYwBzdWJncm91cEJhcnJpZXIAc3ViZ3JvdXBNZW1vcnlCYXJyaWVyAHN1Ymdyb3VwTWVtb3J5QmFycmllckJ1ZmZlcgBzdWJncm91cE1lbW9yeUJhcnJpZXJJbWFnZQBzdWJncm91cE1lbW9yeUJhcnJpZXJTaGFyZWQAdHJhY2VOVgByZXBvcnRJbnRlcnNlY3Rpb25OVgBpZ25vcmVJbnRlcnNlY3Rpb25OVgB0ZXJtaW5hdGVSYXlOVgBleGVjdXRlQ2FsbGFibGVOVgB3cml0ZVBhY2tlZFByaW1pdGl2ZUluZGljZXM0eDhOVgBMb2FkIGNvb3BlcmF0aXZlIG1hdHJpeABTdG9yZSBjb29wZXJhdGl2ZSBtYXRyaXgATXVsQWRkIGNvb3BlcmF0aXZlIG1hdHJpY2VzAElzSGVscGVySW52b2NhdGlvbgBCYWQgYWdncmVnYXRpb24gb3AAVGVzdCBjb25kaXRpb24gYW5kIHNlbGVjdAA6IG5vIHNob3J0Y2lyY3VpdAA6IEZsYXR0ZW4AOiBEb250RmxhdHRlbgBDb25kaXRpb24KAHRydWUgY2FzZQoAdHJ1ZSBjYXNlIGlzIG51bGwKAGZhbHNlIGNhc2UKAENvbnN0YW50OgoAdHJ1ZQBmYWxzZQBjb25zdCBib29sACVkICglcykAY29uc3QgaW50OF90ACV1ICglcykAY29uc3QgdWludDhfdABjb25zdCBpbnQxNl90AGNvbnN0IHVpbnQxNl90AGNvbnN0IGludABjb25zdCB1aW50ACVsbGQgKCVzKQBjb25zdCBpbnQ2NF90ACVsbHUgKCVzKQBjb25zdCB1aW50NjRfdABVbmtub3duIGNvbnN0YW50AC0xLiNJTkYAKzEuI0lORgAxLiNJTkQAJS0uMTNlACVmACA6IAAxADAAJyAoACkKAExvb3Agd2l0aCBjb25kaXRpb24gAG5vdCAAdGVzdGVkIGZpcnN0ADogVW5yb2xsADogRG9udFVucm9sbAA6IERlcGVuZGVuY3kgAExvb3AgQ29uZGl0aW9uCgBObyBsb29wIGNvbmRpdGlvbgoATG9vcCBCb2R5CgBObyBsb29wIGJvZHkKAExvb3AgVGVybWluYWwgRXhwcmVzc2lvbgoA2TUEAOY1BAD1NQQAAzYEABQ2BAAbNgQAJTYEAEJyYW5jaDogVW5rbm93biBCcmFuY2gAIHdpdGggZXhwcmVzc2lvbgoAQnJhbmNoOiBLaWxsAEJyYW5jaDogUmV0dXJuAEJyYW5jaDogQnJlYWsAQnJhbmNoOiBDb250aW51ZQBjYXNlOiAAZGVmYXVsdDogAERlbW90ZQBzd2l0Y2gAY29uZGl0aW9uCgBib2R5CgBTaGFkZXIgdmVyc2lvbjogAFJlcXVlc3RlZCAAaW4geGZiIG1vZGUKAHZlcnRpY2VzID0gAGlucHV0IHByaW1pdGl2ZSA9IAB2ZXJ0ZXggc3BhY2luZyA9IAB0cmlhbmdsZSBvcmRlciA9IAB1c2luZyBwb2ludCBtb2RlCgBpbnZvY2F0aW9ucyA9IABtYXhfdmVydGljZXMgPSAAb3V0cHV0IHByaW1pdGl2ZSA9IABnbF9GcmFnQ29vcmQgcGl4ZWwgY2VudGVyIGlzIGludGVnZXIKAGdsX0ZyYWdDb29yZCBvcmlnaW4gaXMgdXBwZXIgbGVmdAoAdXNpbmcgZWFybHlfZnJhZ21lbnRfdGVzdHMKAHVzaW5nIHBvc3RfZGVwdGhfY292ZXJhZ2UKAHVzaW5nIAB1c2luZwBpbnRlcmxvY2sgb3JkZXJpbmcgPSAAbWF4X3ByaW1pdGl2ZXMgPSAAbG9jYWxfc2l6ZSA9ICgALCAAbG9jYWxfc2l6ZSBpZHMgPSAoAEHY7xALVcoBAADEAgAAxQIAAMYCAADHAgAAyAIAAMkCAADKAgAAywIAAMwCAADNAgAAaW5kdWN0aXZlIGxvb3AgaW5kZXggbW9kaWZpZWQAbGltaXRhdGlvbnMAQbjwEAtJygEAAM4CAADMAQAAzQEAAM8CAADQAgAA0AEAANECAADSAQAA0wEAANQBAABOb24tY29uc3RhbnQtaW5kZXgtZXhwcmVzc2lvbgBBjPEQC+0DygEAANICAADTAgAAzQEAAM4BAADPAQAA0AEAANQCAADSAQAA0wEAANQBAABMaW5raW5nIAAgc3RhZ2U6IABUeXBlcyBtdXN0IG1hdGNoOgBTdG9yYWdlIHF1YWxpZmllcnMgbXVzdCBtYXRjaDoAUHJlY2lzaW9uIHF1YWxpZmllcnMgbXVzdCBtYXRjaDoAUHJlc2VuY2Ugb2YgaW52YXJpYW50IHF1YWxpZmllciBtdXN0IG1hdGNoOgBQcmVzZW5jZSBvZiBwcmVjaXNlIHF1YWxpZmllciBtdXN0IG1hdGNoOgBJbnRlcnBvbGF0aW9uIGFuZCBhdXhpbGlhcnkgc3RvcmFnZSBxdWFsaWZpZXJzIG11c3QgbWF0Y2g6AE1lbW9yeSBxdWFsaWZpZXJzIG11c3QgbWF0Y2g6AExheW91dCBxdWFsaWZpY2F0aW9uIG11c3QgbWF0Y2g6AEluaXRpYWxpemVycyBtdXN0IG1hdGNoOgAgICAgADogIgAiIHZlcnN1cyAiAE11bHRpcGxlIGZ1bmN0aW9uIGJvZGllcyBpbiBtdWx0aXBsZSBjb21waWxhdGlvbiB1bml0cyBmb3IgdGhlIHNhbWUgc2lnbmF0dXJlIGluIHRoZSBzYW1lIHN0YWdlOgBBhPUQCyrKAQAA1QIAANYCAADNAQAAzgEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAQbj1EAsqygEAANcCAADYAgAAzQEAAM4BAADPAQAA0AEAANEBAADSAQAA0wEAANQBAEHs9RALiBPKAQAA2QIAANoCAADNAQAAzgEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAAHN0YWdlcyBtdXN0IG1hdGNoIHdoZW4gbGlua2luZyBpbnRvIGEgc2luZ2xlIHN0YWdlAENhbm5vdCBjcm9zcyBsaW5rIEVTIGFuZCBkZXNrdG9wIHByb2ZpbGVzAG51bWJlciBvZiBpbnZvY2F0aW9ucyBtdXN0IG1hdGNoIGJldHdlZW4gY29tcGlsYXRpb24gdW5pdHMAQ29udHJhZGljdG9yeSBsYXlvdXQgbWF4X3ZlcnRpY2VzIHZhbHVlcwBDb250cmFkaWN0b3J5IGxheW91dCB2ZXJ0aWNlcyB2YWx1ZXMAQ29udHJhZGljdG9yeSBsYXlvdXQgbWF4X3ByaW1pdGl2ZXMgdmFsdWVzAENvbnRyYWRpY3RvcnkgaW5wdXQgbGF5b3V0IHByaW1pdGl2ZXMAQ29udHJhZGljdG9yeSBvdXRwdXQgbGF5b3V0IHByaW1pdGl2ZXMAZ2xfRnJhZ0Nvb3JkIHJlZGVjbGFyYXRpb25zIG11c3QgbWF0Y2ggYWNyb3NzIHNoYWRlcnMAQ29udHJhZGljdG9yeSBpbnB1dCB2ZXJ0ZXggc3BhY2luZwBDb250cmFkaWN0b3J5IHRyaWFuZ2xlIG9yZGVyaW5nAENvbnRyYWRpY3RvcnkgbG9jYWwgc2l6ZQBDb250cmFkaWN0b3J5IGxvY2FsIHNpemUgc3BlY2lhbGl6YXRpb24gaWRzAENvbnRyYWRpY3RvcnkgZGVwdGggbGF5b3V0cwBDb250cmFkaWN0b3J5IHhmYl9zdHJpZGUAY2FuJ3QgaGFuZGxlIG11bHRpcGxlIGVudHJ5IHBvaW50cyBwZXIgc3RhZ2UATWlzc2luZyBlbnRyeSBwb2ludDogRWFjaCBzdGFnZSByZXF1aXJlcyBvbmUgZW50cnkgcG9pbnQAT25seSBvbmUgcHVzaF9jb25zdGFudCBibG9jayBpcyBhbGxvd2VkIHBlciBzdGFnZQBnbF9DbGlwRGlzdGFuY2UAZ2xfQ2xpcFZlcnRleABDYW4gb25seSB1c2Ugb25lIG9mIGdsX0NsaXBEaXN0YW5jZSBvciBnbF9DbGlwVmVydGV4IChnbF9DbGlwRGlzdGFuY2UgaXMgcHJlZmVycmVkKQBnbF9DdWxsRGlzdGFuY2UAQ2FuIG9ubHkgdXNlIG9uZSBvZiBnbF9DdWxsRGlzdGFuY2Ugb3IgZ2xfQ2xpcFZlcnRleCAoZ2xfQ2xpcERpc3RhbmNlIGlzIHByZWZlcnJlZCkAZ2xfRnJhZ0NvbG9yAGdsX0ZyYWdEYXRhAENhbm5vdCB1c2UgZ2xfRnJhZ0NvbG9yIG9yIGdsX0ZyYWdEYXRhIHdoZW4gdXNpbmcgdXNlci1kZWZpbmVkIG91dHB1dHMAQ2Fubm90IHVzZSBib3RoIGdsX0ZyYWdDb2xvciBhbmQgZ2xfRnJhZ0RhdGEAeGZiX3N0cmlkZSBpcyB0b28gc21hbGwgdG8gaG9sZCBhbGwgYnVmZmVyIGVudHJpZXM6ACAgICB4ZmJfYnVmZmVyIAAsIHhmYl9zdHJpZGUgACwgbWluaW11bSBzdHJpZGUgbmVlZGVkOiAAeGZiX3N0cmlkZSBtdXN0IGJlIG11bHRpcGxlIG9mIDggZm9yIGJ1ZmZlciBob2xkaW5nIGEgZG91YmxlIG9yIDY0LWJpdCBpbnRlZ2VyOgB4ZmJfc3RyaWRlIG11c3QgYmUgbXVsdGlwbGUgb2YgNDoAeGZiX3N0cmlkZSBtdXN0IGJlIG11bHRpcGxlIG9mIDIgZm9yIGJ1ZmZlciBob2xkaW5nIGEgaGFsZiBmbG9hdCBvciAxNi1iaXQgaW50ZWdlcjoAeGZiX3N0cmlkZSBpcyB0b28gbGFyZ2U6ACwgY29tcG9uZW50cyAoMS80IHN0cmlkZSkgbmVlZGVkIGFyZSAALCBnbF9NYXhUcmFuc2Zvcm1GZWVkYmFja0ludGVybGVhdmVkQ29tcG9uZW50cyBpcyAAQXQgbGVhc3Qgb25lIHNoYWRlciBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0IGxheW91dCh2ZXJ0aWNlcz0uLi4pAEF0IGxlYXN0IG9uZSBzaGFkZXIgbXVzdCBzcGVjaWZ5IGFuIGlucHV0IGxheW91dCBwcmltaXRpdmUAQXQgbGVhc3Qgb25lIHNoYWRlciBtdXN0IHNwZWNpZnkgYW4gb3V0cHV0IGxheW91dCBwcmltaXRpdmUAQXQgbGVhc3Qgb25lIHNoYWRlciBtdXN0IHNwZWNpZnkgYSBsYXlvdXQobWF4X3ZlcnRpY2VzID0gdmFsdWUpAHBvc3RfZGVwdGhfY292ZXJhZ2UgcmVxdWlyZXMgZWFybHlfZnJhZ21lbnRfdGVzdHMAT25seSBvbmUgc2hhZGVyUmVjb3JkTlYgYnVmZmVyIGJsb2NrIGlzIGFsbG93ZWQgcGVyIHN0YWdlAGdsX1Bvc2l0aW9uAENhbiBvbmx5IHVzZSBvbmUgb2YgZ2xfUG9zaXRpb24gb3IgZ2xfUG9zaXRpb25QZXJWaWV3TlYAZ2xfQ2xpcERpc3RhbmNlUGVyVmlld05WAENhbiBvbmx5IHVzZSBvbmUgb2YgZ2xfQ2xpcERpc3RhbmNlIG9yIGdsX0NsaXBEaXN0YW5jZVBlclZpZXdOVgBnbF9DdWxsRGlzdGFuY2VQZXJWaWV3TlYAQ2FuIG9ubHkgdXNlIG9uZSBvZiBnbF9DdWxsRGlzdGFuY2Ugb3IgZ2xfQ3VsbERpc3RhbmNlUGVyVmlld05WAGdsX0xheWVyAGdsX0xheWVyUGVyVmlld05WAENhbiBvbmx5IHVzZSBvbmUgb2YgZ2xfTGF5ZXIgb3IgZ2xfTGF5ZXJQZXJWaWV3TlYAQ2FuIG9ubHkgdXNlIG9uZSBvZiBnbF9WaWV3cG9ydE1hc2sgb3IgZ2xfVmlld3BvcnRNYXNrUGVyVmlld05WAEF0IGxlYXN0IG9uZSBzaGFkZXIgbXVzdCBzcGVjaWZ5IGEgbGF5b3V0KG1heF9wcmltaXRpdmVzID0gdmFsdWUpAE9ubHkgb25lIHRhc2tOViBpbnRlcmZhY2UgYmxvY2sgaXMgYWxsb3dlZCBwZXIgc2hhZGVyAFVua25vd24gU3RhZ2UuAEGAiRELiQLKAQAA2wIAANwCAADNAQAAzgEAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAAGdsXwB3aGVuIG1vcmUgdGhhbiBvbmUgZnJhZ21lbnQgc2hhZGVyIG91dHB1dCwgYWxsIG11c3QgaGF2ZSBsb2NhdGlvbiBxdWFsaWZpZXJzAE5vIGZ1bmN0aW9uIGRlZmluaXRpb24gKGJvZHkpIGZvdW5kOiAAUmVjdXJzaW9uIGRldGVjdGVkOgAgY2FsbGluZyAAAAAACAAAAAIAAAABAAAAAQAAAAIAAAACAAAABAAAAAQAAAAIAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAgAAAAQAEGUixEL6AndAgAA3gIAAMwBAADfAgAAzgEAAM8BAADQAQAA4AIAANIBAADTAQAA1AEAAGFub25AAG11c3QgYmUgZm9sbG93ZWQgYnkgbWFjcm8gbmFtZQAjZGVmaW5lAGJhZCBhcmd1bWVudABkdXBsaWNhdGUgbWFjcm8gcGFyYW1ldGVyAG1pc3NpbmcgcGFyZW50aGVzaXMAbWlzc2luZyBzcGFjZSBhZnRlciBtYWNybyBuYW1lAE1hY3JvIHJlZGVmaW5lZDsgZnVuY3Rpb24tbGlrZSB2ZXJzdXMgb2JqZWN0LWxpa2U6AE1hY3JvIHJlZGVmaW5lZDsgZGlmZmVyZW50IG51bWJlciBvZiBhcmd1bWVudHM6AE1hY3JvIHJlZGVmaW5lZDsgZGlmZmVyZW50IGFyZ3VtZW50IG5hbWVzOgBNYWNybyByZWRlZmluZWQ7IGRpZmZlcmVudCBzdWJzdGl0dXRpb25zOgAjdW5kZWYAY2FuIG9ubHkgYmUgZm9sbG93ZWQgYnkgYSBzaW5nbGUgbWFjcm8gbmFtZQBtYXhpbXVtIG5lc3RpbmcgZGVwdGggZXhjZWVkZWQAI2lmLyNpZmRlZi8jaWZuZGVmACNlbGlmIGFmdGVyICNlbHNlACNlbGlmACNlbHNlIGFmdGVyICNlbHNlACNlbHNlACNpZgBkZWZpbmVkAG5vbnBvcnRhYmxlIHdoZW4gZXhwYW5kZWQgZnJvbSBtYWNyb3MgZm9yIHByZXByb2Nlc3NvciBleHByZXNzaW9uAGNhbm5vdCB1c2UgaW4gcHJlcHJvY2Vzc29yIGV4cHJlc3Npb24gd2hlbiBleHBhbmRlZCBmcm9tIG1hY3JvcwBpbmNvcnJlY3QgZGlyZWN0aXZlLCBleHBlY3RlZCBpZGVudGlmaWVyAHByZXByb2Nlc3NvciBldmFsdWF0aW9uAGV4cGVjdGVkICcpJwArAAAA4QIAAC0AAADiAgAAfgAAAOMCAAAhAAAA5AIAAGJhZCBleHByZXNzaW9uAACOAAAAAgAAAOUCAACNAAAAAwAAAOYCAAB8AAAABAAAAOcCAABeAAAABQAAAOgCAAAmAAAABgAAAOkCAACQAAAABwAAAOoCAACRAAAABwAAAOsCAAA+AAAACAAAAOwC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ADY0LWJpdCBoZXhhZGVjaW1hbCBsaXRlcmFsADE2LWJpdCBoZXhhZGVjaW1hbCBsaXRlcmFsAG51bWVyaWMgbGl0ZXJhbCB0b28gbG9uZwBvY3RhbCBsaXRlcmFsIGRpZ2l0IHRvbyBsYXJnZQBvY3RhbCBsaXRlcmFsIHRvbyBiaWcANjQtYml0IG9jdGFsIGxpdGVyYWwAMTYtYml0IG9jdGFsIGxpdGVyYWwAbnVtZXJpYyBsaXRlcmFsIHRvbyBiaWcANjQtYml0IGxpdGVyYWwAMTYtYml0ICBsaXRlcmFsADE2LWJpdCBsaXRlcmFsAEVuZCBvZiBpbnB1dCBpbiBjb21tZW50AGNvbW1lbnQARW5kIG9mIGxpbmUgaW4gc3RyaW5nAHN0cmluZwBHTF9BTURfZ3B1X3NoYWRlcl9pbnQxNgBHTF9FWFRfc2hhZGVyX2V4cGxpY2l0X2FyaXRobWV0aWNfdHlwZXMAR0xfRVhUX3NoYWRlcl9leHBsaWNpdF9hcml0aG1ldGljX3R5cGVzX2ludDE2AEdMX0FSQl9ncHVfc2hhZGVyX2ludDY0AEdMX0VYVF9zaGFkZXJfZXhwbGljaXRfYXJpdGhtZXRpY190eXBlc19pbnQ2NABwcmVwcm9jZXNzb3IgZGlyZWN0aXZlIGNhbm5vdCBiZSBwcmVjZWRlZCBieSBhbm90aGVyIHRva2VuACMAc3RyaW5nIGxpdGVyYWxzIG5vdCBzdXBwb3J0ZWQAIiIAY2hhcmFjdGVyIGxpdGVyYWxzIG5vdCBzdXBwb3J0ZWQAbWlzc2luZyAjZW5kaWYAdW5leHBlY3RlZCBsb2NhdGlvbgAjIwB1bmV4cGVjdGVkIGxvY2F0aW9uOyBlbmQgb2YgcmVwbGFjZW1lbnQgbGlzdAB1bmV4cGVjdGVkIGxvY2F0aW9uOyBlbmQgb2YgYXJndW1lbnQAbm90IHN1cHBvcnRlZCBmb3IgdGhlc2UgdG9rZW5zAGNvbWJpbmVkIHRva2VucyBhcmUgdG9vIGxvbmcAY29tYmluZWQgdG9rZW4gaXMgaW52YWxpZABB8K0RC0H3AgAAKAMAACkDAAAqAwAAKwMAAPwCAAD9AgAA/gIAAP8CAAAAAwAAAQMAAHRva2VuIHBhc3RpbmcgKCMjKQAlcwBBvK4RCyr3AgAALAMAAC0DAAAuAwAALwMAADADAAAxAwAA/gIAAP8CAAAAAwAAAQMAQfCuEQsq9wIAADIDAAAzAwAANAMAADUDAAD8AgAA/QIAAP4CAAD/AgAAAAMAAAEDAEGkrxELKjYDAAA3AwAAOAMAAM0BAAA5AwAAOgMAANABAAA7AwAA0gEAANMBAADUAQBB2K8RCyrKAQAAPAMAAD0DAADNAQAAPgMAAM8BAADQAQAA0QEAANIBAADTAQAA1AEAQYywEQsvPwMAAEADAABBAwAAzQEAAEIDAABDAwAA0AEAAEQDAADSAQAARQMAANQBAAAoACkAQcSwEQuEA0YDAABHAwAASAMAAEkDAABKAwAASwMAAEwDAABNAwAATgMAAE8DAABQAwAAU1BWX0VYVF9kZXNjcmlwdG9yX2luZGV4aW5nAFNQVl9FWFRfZGVtb3RlX3RvX2hlbHBlcl9pbnZvY2F0aW9uAG1pc3NpbmcgdXNlciBmdW5jdGlvbjsgbGlua2VyIG5lZWRzIHRvIGNhdGNoIHRoYXQAU1BWX0tIUl9zaGFkZXJfYXRvbWljX2NvdW50ZXJfb3BzAFNQVl9FWFRfZnJhZ21lbnRfc2hhZGVyX2ludGVybG9jawB1bmtub3duIGdsc2xhbmcgYWdncmVnYXRlAFNQVl9BTURfc2hhZGVyX2JhbGxvdABTUFZfQU1EX3NoYWRlcl90cmluYXJ5X21pbm1heABTUFZfQU1EX3NoYWRlcl9leHBsaWNpdF92ZXJ0ZXhfcGFyYW1ldGVyAFNQVl9LSFJfc2hhZGVyX2JhbGxvdABTUFZfS0hSX3N1Ymdyb3VwX3ZvdGUAQdizEQvqDQEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAGludm9jYXRpb24gb3BlcmF0aW9uAFNQVl9BTURfZ2NuX3NoYWRlcgBTUFZfS0hSX3NoYWRlcl9jbG9jawB1bmtub3duIG9wZXJhdGlvbiB3aXRoIG5vIGFyZ3VtZW50cwBTUFZfTlZfY29vcGVyYXRpdmVfbWF0cml4AFNQVl9OVl92aWV3cG9ydF9hcnJheTIAU1BWX05WX3N0ZXJlb192aWV3X3JlbmRlcmluZwBTUFZfTlZfZ2VvbWV0cnlfc2hhZGVyX3Bhc3N0aHJvdWdoAFNQVl9FWFRfc2hhZGVyX3ZpZXdwb3J0X2luZGV4X2xheWVyAFNQVl9LSFJfc2hhZGVyX2RyYXdfcGFyYW1ldGVycwBTUFZfRVhUX3NoYWRlcl9zdGVuY2lsX2V4cG9ydABTUFZfS0hSX2RldmljZV9ncm91cABTUFZfS0hSX211bHRpdmlldwBTUFZfRVhUX2ZyYWdtZW50X2ludm9jYXRpb25fZGVuc2l0eQBTUFZfTlZYX211bHRpdmlld19wZXJfdmlld19hdHRyaWJ1dGVzAFNQVl9FWFRfZnJhZ21lbnRfZnVsbHlfY292ZXJlZABTUFZfTlZfc2hhZGluZ19yYXRlAFNQVl9OVl9mcmFnbWVudF9zaGFkZXJfYmFyeWNlbnRyaWMAU1BWX05WX3NoYWRlcl9zbV9idWlsdGlucwBTUFZfTlZfbWVzaF9zaGFkZXIAZ2xfU2Vjb25kYXJ5Vmlld3BvcnRNYXNrTlYAR0xfTlZfc3RlcmVvX3ZpZXdfcmVuZGVyaW5nAGdsX1NlY29uZGFyeVBvc2l0aW9uTlYAZ2xfVmlld3BvcnRNYXNrAEdMX05WX3ZpZXdwb3J0X2FycmF5MgBnbF9Qb3NpdGlvblBlclZpZXdOVgBHTF9OVlhfbXVsdGl2aWV3X3Blcl92aWV3X2F0dHJpYnV0ZXMAZ2xfVmlld3BvcnRNYXNrUGVyVmlld05WAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAA////fwYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAAP///38VAAAAFgAAABcAAAAYAAAA////fxkAAAAaAAAAGwAAABwAAAAdAAAA////fx4AAAAfAAAAIAAAACEAAAD///9/IwAAACQAAAAiAAAAJQAAACYAAAAnAAAAU1BWX0FNRF9ncHVfc2hhZGVyX2hhbGZfZmxvYXRfZmV0Y2gAcGFyYW0AYXJnAFNQVl9LSFJfc3RvcmFnZV9idWZmZXJfc3RvcmFnZV9jbGFzcwAABwAAAAYAAAAHAAAABwAAAAcAAAAHAAAABwAAAAQAAADaFAAA3hQAANsUAADQFAAA0RQAAAcAAAAHAAAABwAAAAcAAABTUFZfQU1EX3NoYWRlcl9pbWFnZV9sb2FkX3N0b3JlX2xvZABTUFZfQU1EX3NoYWRlcl9mcmFnbWVudF9tYXNrAEdMX0FNRF90ZXh0dXJlX2dhdGhlcl9iaWFzX2xvZABTUFZfQU1EX3RleHR1cmVfZ2F0aGVyX2JpYXNfbG9kAFNQVl9OVl9zaGFkZXJfaW1hZ2VfZm9vdHByaW50AHVua25vd24gZ2xzbGFuZyB1bmFyeQBTUFZfRVhUX3BoeXNpY2FsX3N0b3JhZ2VfYnVmZmVyAFNQVl9LSFJfcGh5c2ljYWxfc3RvcmFnZV9idWZmZXIAbWF0cml4IHN3aXp6bGUAdW5rbm93biBnbHNsYW5nIGJpbmFyeSBvcGVyYXRpb24AZm9yY2luZyAzMi1iaXQgdmVjdG9yIHR5cGUgdG8gbm9uIDY0LWJpdCBzY2FsYXIAZm9yY2luZyBub24gMzItYml0IHZlY3RvciB0eXBlAFNQVl9OVl9zYW1wbGVfbWFza19vdmVycmlkZV9jb3ZlcmFnZQAATmVpdGhlciBhIGZyb250LWVuZCBjb25zdGFudCBub3IgYSBzcGVjIGNvbnN0YW50LgAvLyBPcE1vZHVsZVByb2Nlc3NlZCAACgAjbGluZSAxCgBHTFNMLnN0ZC40NTAAU1BWX0tIUl92dWxrYW5fbWVtb3J5X21vZGVsAFNQVl9LSFJfcG9zdF9kZXB0aF9jb3ZlcmFnZQBTUFZfTlZfY29tcHV0ZV9zaGFkZXJfZGVyaXZhdGl2ZXMAABMAAAAUAAAAFQAAABMAAAAWAAAAFwAAAFNQVl9OVl9yYXlfdHJhY2luZwBBzMERCxVRAwAAUgMAAAIAAAACAAAAAAAAAAIAQfDBEQs6AQAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAMEUAADCFAAAwxQAAMQUAADFFAAAxhQAAJMUAACUFABBtMIRCwZTAwAAVAMAQcTCEQsPVQMAAFYDAABSZXNUeXBlAEH4whELAQEAQYTDEQsGVwMAAFgDAEGUwxELNFkDAABaAwAAAQAAAAIAAAADAAAAAgAAAAIAAAABAAAAAgAAAGluZGV4YWJsZQAAAAMCIwcAQdjDEQvSAVNQVl9BTURfZ3B1X3NoYWRlcl9pbnQxNgBTUFZfQU1EX2dwdV9zaGFkZXJfaGFsZl9mbG9hdABTUFZfTlZfc2hhZGVyX3N1Ymdyb3VwX3BhcnRpdGlvbmVkAFNQVl9LSFJfOGJpdF9zdG9yYWdlAFNQVl9LSFJfMTZiaXRfc3RvcmFnZQBhbGxvY2F0b3I8VD46OmFsbG9jYXRlKHNpemVfdCBuKSAnbicgZXhjZWVkcyBtYXhpbXVtIHN1cHBvcnRlZCBzaXplAAAAAFsDAABcAwBBuMURCwEFAEHExRELAQEAQdzFEQsLAgAAAAMAAADYZAQAQfTFEQsBAgBBg8YRCwX//////wBByMYRCwEFAEHUxhELAQYAQezGEQsOAgAAAAcAAADoZAQAAAQAQYTHEQsBAQBBk8cRCwUK/////wBBlMkRCwMQaQQ=';\n\nvar Module = (function() {\n  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;\n  return (\nfunction(Module) {\n  Module = Module || {};\n\nvar d;d||(d=typeof Module !== 'undefined' ? Module : {});d.compileGLSLZeroCopy=function(a,b,c){c=!!c;if(\"vertex\"===b)var e=0;else if(\"fragment\"===b)e=4;else if(\"compute\"===b)e=5;else throw Error(\"shader_stage must be 'vertex', 'fragment', or 'compute'\");b=d._malloc(4);var g=d._malloc(4),f=aa([a,e,c,b,g]);c=ba(b);a=ba(g);d._free(b);d._free(g);if(0===f)throw Error(\"GLSL compilation failed\");b={};g=c/4;b.data=d.HEAPU32.subarray(g,g+a);b.free=function(){d._destroy_output_buffer(f)};return b};\nd.compileGLSL=function(a,b,c){a=d.compileGLSLZeroCopy(a,b,c);b=a.data.slice();a.free();return b};var k={},p;for(p in d)d.hasOwnProperty(p)&&(k[p]=d[p]);var ca=\"./this.program\",r=!1,t=!1;r=\"object\"===typeof window;t=\"function\"===typeof importScripts;var u=\"\",w;\nif(r||t)t?u=self.location.href:document.currentScript&&(u=document.currentScript.src),_scriptDir&&(u=_scriptDir),0!==u.indexOf(\"blob:\")?u=u.substr(0,u.lastIndexOf(\"/\")+1):u=\"\",t&&(w=function(a){var b=new XMLHttpRequest;b.open(\"GET\",a,!1);b.responseType=\"arraybuffer\";b.send(null);return new Uint8Array(b.response)});var da=d.print||console.log.bind(console),x=d.printErr||console.warn.bind(console);for(p in k)k.hasOwnProperty(p)&&(d[p]=k[p]);k=null;d.thisProgram&&(ca=d.thisProgram);var y;\nd.wasmBinary&&(y=d.wasmBinary);\"object\"!==typeof WebAssembly&&x(\"no native wasm support detected\");function ba(a){var b=\"i32\";\"*\"===b.charAt(b.length-1)&&(b=\"i32\");switch(b){case \"i1\":return z[a>>0];case \"i8\":return z[a>>0];case \"i16\":return A[a>>1];case \"i32\":return B[a>>2];case \"i64\":return B[a>>2];case \"float\":return C[a>>2];case \"double\":return D[a>>3];default:E(\"invalid type for getValue: \"+b)}return null}var F,ea=new WebAssembly.Table({initial:861,maximum:861,element:\"anyfunc\"}),fa=!1;\nfunction ha(){var a=d._convert_glsl_to_spirv;a||E(\"Assertion failed: Cannot call unknown function convert_glsl_to_spirv, make sure it is exported\");return a}\nfunction aa(a){var b=[\"string\",\"number\",\"boolean\",\"number\",\"number\"],c={string:function(a){var b=0;if(null!==a&&void 0!==a&&0!==a){var c=(a.length<<2)+1;b=ia(c);G(a,H,b,c)}return b},array:function(a){var b=ia(a.length);z.set(a,b);return b}},e=ha(),g=[],f=0;if(a)for(var h=0;h<a.length;h++){var m=c[b[h]];m?(0===f&&(f=ja()),g[h]=m(a[h])):g[h]=a[h]}a=e.apply(null,g);0!==f&&ka(f);return a}var la=\"undefined\"!==typeof TextDecoder?new TextDecoder(\"utf8\"):void 0;\nfunction ma(a,b,c){var e=b+c;for(c=b;a[c]&&!(c>=e);)++c;if(16<c-b&&a.subarray&&la)return la.decode(a.subarray(b,c));for(e=\"\";b<c;){var g=a[b++];if(g&128){var f=a[b++]&63;if(192==(g&224))e+=String.fromCharCode((g&31)<<6|f);else{var h=a[b++]&63;g=224==(g&240)?(g&15)<<12|f<<6|h:(g&7)<<18|f<<12|h<<6|a[b++]&63;65536>g?e+=String.fromCharCode(g):(g-=65536,e+=String.fromCharCode(55296|g>>10,56320|g&1023))}}else e+=String.fromCharCode(g)}return e}function I(a){return a?ma(H,a,void 0):\"\"}\nfunction G(a,b,c,e){if(0<e){e=c+e-1;for(var g=0;g<a.length;++g){var f=a.charCodeAt(g);if(55296<=f&&57343>=f){var h=a.charCodeAt(++g);f=65536+((f&1023)<<10)|h&1023}if(127>=f){if(c>=e)break;b[c++]=f}else{if(2047>=f){if(c+1>=e)break;b[c++]=192|f>>6}else{if(65535>=f){if(c+2>=e)break;b[c++]=224|f>>12}else{if(c+3>=e)break;b[c++]=240|f>>18;b[c++]=128|f>>12&63}b[c++]=128|f>>6&63}b[c++]=128|f&63}}b[c]=0}}\nfunction na(a){for(var b=0,c=0;c<a.length;++c){var e=a.charCodeAt(c);55296<=e&&57343>=e&&(e=65536+((e&1023)<<10)|a.charCodeAt(++c)&1023);127>=e?++b:b=2047>=e?b+2:65535>=e?b+3:b+4}return b}\"undefined\"!==typeof TextDecoder&&new TextDecoder(\"utf-16le\");function oa(a){0<a%65536&&(a+=65536-a%65536);return a}var J,z,H,A,pa,B,K,C,D;\nfunction qa(a){J=a;d.HEAP8=z=new Int8Array(a);d.HEAP16=A=new Int16Array(a);d.HEAP32=B=new Int32Array(a);d.HEAPU8=H=new Uint8Array(a);d.HEAPU16=pa=new Uint16Array(a);d.HEAPU32=K=new Uint32Array(a);d.HEAPF32=C=new Float32Array(a);d.HEAPF64=D=new Float64Array(a)}var ra=d.TOTAL_MEMORY||16777216;d.wasmMemory?F=d.wasmMemory:F=new WebAssembly.Memory({initial:ra/65536});F&&(J=F.buffer);ra=J.byteLength;qa(J);B[79464]=5560896;\nfunction L(a){for(;0<a.length;){var b=a.shift();if(\"function\"==typeof b)b();else{var c=b.T;\"number\"===typeof c?void 0===b.R?d.dynCall_v(c):d.dynCall_vi(c,b.R):c(void 0===b.R?null:b.R)}}}var sa=[],ta=[],ua=[],va=[];function wa(){var a=d.preRun.shift();sa.unshift(a)}var M=0,xa=null,N=null;d.preloadedImages={};d.preloadedAudios={};function E(a){if(d.onAbort)d.onAbort(a);da(a);x(a);fa=!0;throw new WebAssembly.RuntimeError(\"abort(\"+a+\"). Build with -s ASSERTIONS=1 for more info.\");}\nfunction ya(){var a=O;return String.prototype.startsWith?a.startsWith(\"data:application/octet-stream;base64,\"):0===a.indexOf(\"data:application/octet-stream;base64,\")}var O=wasmuri;if(!ya()){var za=O;O=d.locateFile?d.locateFile(za,u):u+za}function Aa(){try{if(y)return new Uint8Array(y);if(w)return w(O);throw\"both async and sync fetching of the wasm failed\";}catch(a){E(a)}}\nfunction Ba(){return y||!r&&!t||\"function\"!==typeof fetch?new Promise(function(a){a(Aa())}):fetch(O,{credentials:\"same-origin\"}).then(function(a){if(!a.ok)throw\"failed to load wasm binary file at '\"+O+\"'\";return a.arrayBuffer()}).catch(function(){return Aa()})}ta.push({T:function(){Ca()}});var Da=[null,[],[]],Ea=0;function Fa(){Ea+=4;return B[Ea-4>>2]}var Ga={};\nfunction Ha(a){switch(a){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError(\"Unknown type size: \"+a);}}var Ia=void 0;function P(a){for(var b=\"\";H[a];)b+=Ia[H[a++]];return b}var Ja={},Ka={},Ma={};function Na(a,b){if(void 0===a)a=\"_unknown\";else{a=a.replace(/[^a-zA-Z0-9_]/g,\"$\");var c=a.charCodeAt(0);a=48<=c&&57>=c?\"_\"+a:a}return(new Function(\"body\",\"return function \"+a+'() {\\n    \"use strict\";    return body.apply(this, arguments);\\n};\\n'))(b)}\nfunction Oa(a){var b=Error,c=Na(a,function(b){this.name=a;this.message=b;b=Error(b).stack;void 0!==b&&(this.stack=this.toString()+\"\\n\"+b.replace(/^Error(:[^\\n]*)?\\n/,\"\"))});c.prototype=Object.create(b.prototype);c.prototype.constructor=c;c.prototype.toString=function(){return void 0===this.message?this.name:this.name+\": \"+this.message};return c}var Pa=void 0;function Q(a){throw new Pa(a);}\nfunction R(a,b,c){c=c||{};if(!(\"argPackAdvance\"in b))throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");var e=b.name;a||Q('type \"'+e+'\" must have a positive integer typeid pointer');if(Ka.hasOwnProperty(a)){if(c.U)return;Q(\"Cannot register type '\"+e+\"' twice\")}Ka[a]=b;delete Ma[a];Ja.hasOwnProperty(a)&&(b=Ja[a],delete Ja[a],b.forEach(function(a){a()}))}var Qa=[],S=[{},{value:void 0},{value:null},{value:!0},{value:!1}];\nfunction Ra(a){switch(a){case void 0:return 1;case null:return 2;case !0:return 3;case !1:return 4;default:var b=Qa.length?Qa.pop():S.length;S[b]={W:1,value:a};return b}}function Sa(a){return this.fromWireType(K[a>>2])}function Ta(a){if(null===a)return\"null\";var b=typeof a;return\"object\"===b||\"array\"===b||\"function\"===b?a.toString():\"\"+a}\nfunction Ua(a,b){switch(b){case 2:return function(a){return this.fromWireType(C[a>>2])};case 3:return function(a){return this.fromWireType(D[a>>3])};default:throw new TypeError(\"Unknown float type: \"+a);}}\nfunction Va(a,b,c){switch(b){case 0:return c?function(a){return z[a]}:function(a){return H[a]};case 1:return c?function(a){return A[a>>1]}:function(a){return pa[a>>1]};case 2:return c?function(a){return B[a>>2]}:function(a){return K[a>>2]};default:throw new TypeError(\"Unknown integer type: \"+a);}}var Wa={};\nfunction Xa(){if(!Ya){var a={USER:\"web_user\",LOGNAME:\"web_user\",PATH:\"/\",PWD:\"/\",HOME:\"/home/web_user\",LANG:(\"object\"===typeof navigator&&navigator.languages&&navigator.languages[0]||\"C\").replace(\"-\",\"_\")+\".UTF-8\",_:ca},b;for(b in Wa)a[b]=Wa[b];var c=[];for(b in a)c.push(b+\"=\"+a[b]);Ya=c}return Ya}var Ya;function T(a){return 0===a%4&&(0!==a%100||0===a%400)}function Za(a,b){for(var c=0,e=0;e<=b;c+=a[e++]);return c}var U=[31,29,31,30,31,30,31,31,30,31,30,31],V=[31,28,31,30,31,30,31,31,30,31,30,31];\nfunction W(a,b){for(a=new Date(a.getTime());0<b;){var c=a.getMonth(),e=(T(a.getFullYear())?U:V)[c];if(b>e-a.getDate())b-=e-a.getDate()+1,a.setDate(1),11>c?a.setMonth(c+1):(a.setMonth(0),a.setFullYear(a.getFullYear()+1));else{a.setDate(a.getDate()+b);break}}return a}\nfunction $a(a,b,c,e){function g(a,b,c){for(a=\"number\"===typeof a?a.toString():a||\"\";a.length<b;)a=c[0]+a;return a}function f(a,b){return g(a,b,\"0\")}function h(a,b){function c(a){return 0>a?-1:0<a?1:0}var f;0===(f=c(a.getFullYear()-b.getFullYear()))&&0===(f=c(a.getMonth()-b.getMonth()))&&(f=c(a.getDate()-b.getDate()));return f}function m(a){switch(a.getDay()){case 0:return new Date(a.getFullYear()-1,11,29);case 1:return a;case 2:return new Date(a.getFullYear(),0,3);case 3:return new Date(a.getFullYear(),\n0,2);case 4:return new Date(a.getFullYear(),0,1);case 5:return new Date(a.getFullYear()-1,11,31);case 6:return new Date(a.getFullYear()-1,11,30)}}function q(a){a=W(new Date(a.J+1900,0,1),a.P);var b=m(new Date(a.getFullYear()+1,0,4));return 0>=h(m(new Date(a.getFullYear(),0,4)),a)?0>=h(b,a)?a.getFullYear()+1:a.getFullYear():a.getFullYear()-1}var l=B[e+40>>2];e={Z:B[e>>2],Y:B[e+4>>2],N:B[e+8>>2],M:B[e+12>>2],K:B[e+16>>2],J:B[e+20>>2],O:B[e+24>>2],P:B[e+28>>2],ia:B[e+32>>2],X:B[e+36>>2],$:l?I(l):\"\"};\nc=I(c);l={\"%c\":\"%a %b %d %H:%M:%S %Y\",\"%D\":\"%m/%d/%y\",\"%F\":\"%Y-%m-%d\",\"%h\":\"%b\",\"%r\":\"%I:%M:%S %p\",\"%R\":\"%H:%M\",\"%T\":\"%H:%M:%S\",\"%x\":\"%m/%d/%y\",\"%X\":\"%H:%M:%S\",\"%Ec\":\"%c\",\"%EC\":\"%C\",\"%Ex\":\"%m/%d/%y\",\"%EX\":\"%H:%M:%S\",\"%Ey\":\"%y\",\"%EY\":\"%Y\",\"%Od\":\"%d\",\"%Oe\":\"%e\",\"%OH\":\"%H\",\"%OI\":\"%I\",\"%Om\":\"%m\",\"%OM\":\"%M\",\"%OS\":\"%S\",\"%Ou\":\"%u\",\"%OU\":\"%U\",\"%OV\":\"%V\",\"%Ow\":\"%w\",\"%OW\":\"%W\",\"%Oy\":\"%y\"};for(var n in l)c=c.replace(new RegExp(n,\"g\"),l[n]);var v=\"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\nLa=\"January February March April May June July August September October November December\".split(\" \");l={\"%a\":function(a){return v[a.O].substring(0,3)},\"%A\":function(a){return v[a.O]},\"%b\":function(a){return La[a.K].substring(0,3)},\"%B\":function(a){return La[a.K]},\"%C\":function(a){return f((a.J+1900)/100|0,2)},\"%d\":function(a){return f(a.M,2)},\"%e\":function(a){return g(a.M,2,\" \")},\"%g\":function(a){return q(a).toString().substring(2)},\"%G\":function(a){return q(a)},\"%H\":function(a){return f(a.N,2)},\n\"%I\":function(a){a=a.N;0==a?a=12:12<a&&(a-=12);return f(a,2)},\"%j\":function(a){return f(a.M+Za(T(a.J+1900)?U:V,a.K-1),3)},\"%m\":function(a){return f(a.K+1,2)},\"%M\":function(a){return f(a.Y,2)},\"%n\":function(){return\"\\n\"},\"%p\":function(a){return 0<=a.N&&12>a.N?\"AM\":\"PM\"},\"%S\":function(a){return f(a.Z,2)},\"%t\":function(){return\"\\t\"},\"%u\":function(a){return a.O||7},\"%U\":function(a){var b=new Date(a.J+1900,0,1),c=0===b.getDay()?b:W(b,7-b.getDay());a=new Date(a.J+1900,a.K,a.M);return 0>h(c,a)?f(Math.ceil((31-\nc.getDate()+(Za(T(a.getFullYear())?U:V,a.getMonth()-1)-31)+a.getDate())/7),2):0===h(c,b)?\"01\":\"00\"},\"%V\":function(a){var b=m(new Date(a.J+1900,0,4)),c=m(new Date(a.J+1901,0,4)),e=W(new Date(a.J+1900,0,1),a.P);return 0>h(e,b)?\"53\":0>=h(c,e)?\"01\":f(Math.ceil((b.getFullYear()<a.J+1900?a.P+32-b.getDate():a.P+1-b.getDate())/7),2)},\"%w\":function(a){return a.O},\"%W\":function(a){var b=new Date(a.J,0,1),c=1===b.getDay()?b:W(b,0===b.getDay()?1:7-b.getDay()+1);a=new Date(a.J+1900,a.K,a.M);return 0>h(c,a)?f(Math.ceil((31-\nc.getDate()+(Za(T(a.getFullYear())?U:V,a.getMonth()-1)-31)+a.getDate())/7),2):0===h(c,b)?\"01\":\"00\"},\"%y\":function(a){return(a.J+1900).toString().substring(2)},\"%Y\":function(a){return a.J+1900},\"%z\":function(a){a=a.X;var b=0<=a;a=Math.abs(a)/60;return(b?\"+\":\"-\")+String(\"0000\"+(a/60*100+a%60)).slice(-4)},\"%Z\":function(a){return a.$},\"%%\":function(){return\"%\"}};for(n in l)0<=c.indexOf(n)&&(c=c.replace(new RegExp(n,\"g\"),l[n](e)));n=ab(c);if(n.length>b)return 0;z.set(n,a);return n.length-1}\nfor(var bb=Array(256),X=0;256>X;++X)bb[X]=String.fromCharCode(X);Ia=bb;Pa=d.BindingError=Oa(\"BindingError\");d.InternalError=Oa(\"InternalError\");d.count_emval_handles=function(){for(var a=0,b=5;b<S.length;++b)void 0!==S[b]&&++a;return a};d.get_first_emval=function(){for(var a=5;a<S.length;++a)if(void 0!==S[a])return S[a];return null};function ab(a){var b=Array(na(a)+1);G(a,b,0,b.length);return b}\nvar db={j:function(){},g:function(){d.___errno_location&&(B[d.___errno_location()>>2]=63);return-1},v:function(a,b){Ea=b;try{var c=Fa();var e=Fa();if(-1===c||0===e)var g=-28;else{var f=Ga.V[c];if(f&&e===f.fa){var h=(void 0).da(f.ca);Ga.ba(c,h,e,f.flags);(void 0).ha(h);Ga.V[c]=null;f.aa&&Y(f.ga)}g=0}return g}catch(m){return E(m),-m.S}},d:function(){},s:function(a,b,c,e,g){var f=Ha(c);b=P(b);R(a,{name:b,fromWireType:function(a){return!!a},toWireType:function(a,b){return b?e:g},argPackAdvance:8,readValueFromPointer:function(a){if(1===\nc)var e=z;else if(2===c)e=A;else if(4===c)e=B;else throw new TypeError(\"Unknown boolean type size: \"+b);return this.fromWireType(e[a>>f])},L:null})},q:function(a,b){b=P(b);R(a,{name:b,fromWireType:function(a){var b=S[a].value;4<a&&0===--S[a].W&&(S[a]=void 0,Qa.push(a));return b},toWireType:function(a,b){return Ra(b)},argPackAdvance:8,readValueFromPointer:Sa,L:null})},e:function(a,b,c){c=Ha(c);b=P(b);R(a,{name:b,fromWireType:function(a){return a},toWireType:function(a,b){if(\"number\"!==typeof b&&\"boolean\"!==\ntypeof b)throw new TypeError('Cannot convert \"'+Ta(b)+'\" to '+this.name);return b},argPackAdvance:8,readValueFromPointer:Ua(b,c),L:null})},b:function(a,b,c,e,g){function f(a){return a}b=P(b);-1===g&&(g=4294967295);var h=Ha(c);if(0===e){var m=32-8*c;f=function(a){return a<<m>>>m}}var q=-1!=b.indexOf(\"unsigned\");R(a,{name:b,fromWireType:f,toWireType:function(a,c){if(\"number\"!==typeof c&&\"boolean\"!==typeof c)throw new TypeError('Cannot convert \"'+Ta(c)+'\" to '+this.name);if(c<e||c>g)throw new TypeError('Passing a number \"'+\nTa(c)+'\" from JS side to C/C++ side to an argument of type \"'+b+'\", which is outside the valid range ['+e+\", \"+g+\"]!\");return q?c>>>0:c|0},argPackAdvance:8,readValueFromPointer:Va(b,h,0!==e),L:null})},a:function(a,b,c){function e(a){a>>=2;var b=K;return new g(b.buffer,b[a+1],b[a])}var g=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array][b];c=P(c);R(a,{name:c,fromWireType:e,argPackAdvance:8,readValueFromPointer:e},{U:!0})},f:function(a,b){b=P(b);var c=\"std::string\"===\nb;R(a,{name:b,fromWireType:function(a){var b=K[a>>2];if(c){var f=H[a+4+b],e=0;0!=f&&(e=f,H[a+4+b]=0);var m=a+4;for(f=0;f<=b;++f){var q=a+4+f;if(0==H[q]){m=I(m);if(void 0===l)var l=m;else l+=String.fromCharCode(0),l+=m;m=q+1}}0!=e&&(H[a+4+b]=e)}else{l=Array(b);for(f=0;f<b;++f)l[f]=String.fromCharCode(H[a+4+f]);l=l.join(\"\")}Y(a);return l},toWireType:function(a,b){b instanceof ArrayBuffer&&(b=new Uint8Array(b));var f=\"string\"===typeof b;f||b instanceof Uint8Array||b instanceof Uint8ClampedArray||b instanceof\nInt8Array||Q(\"Cannot pass non-string to std::string\");var e=(c&&f?function(){return na(b)}:function(){return b.length})(),g=cb(4+e+1);K[g>>2]=e;if(c&&f)G(b,H,g+4,e+1);else if(f)for(f=0;f<e;++f){var q=b.charCodeAt(f);255<q&&(Y(g),Q(\"String has UTF-16 code units that do not fit in 8 bits\"));H[g+4+f]=q}else for(f=0;f<e;++f)H[g+4+f]=b[f];null!==a&&a.push(Y,g);return g},argPackAdvance:8,readValueFromPointer:Sa,L:function(a){Y(a)}})},r:function(a,b,c){c=P(c);if(2===b){var e=function(){return pa};var g=\n1}else 4===b&&(e=function(){return K},g=2);R(a,{name:c,fromWireType:function(a){for(var b=e(),c=K[a>>2],f=Array(c),l=a+4>>g,n=0;n<c;++n)f[n]=String.fromCharCode(b[l+n]);Y(a);return f.join(\"\")},toWireType:function(a,c){var f=c.length,h=cb(4+f*b),l=e();K[h>>2]=f;for(var n=h+4>>g,v=0;v<f;++v)l[n+v]=c.charCodeAt(v);null!==a&&a.push(Y,h);return h},argPackAdvance:8,readValueFromPointer:Sa,L:function(a){Y(a)}})},t:function(a,b){b=P(b);R(a,{ea:!0,name:b,argPackAdvance:0,fromWireType:function(){},toWireType:function(){}})},\nc:function(){E()},n:function(a,b,c){H.set(H.subarray(b,b+c),a)},o:function(a){if(2147418112<a)return!1;for(var b=Math.max(z.length,16777216);b<a;)536870912>=b?b=oa(2*b):b=Math.min(oa((3*b+2147483648)/4),2147418112);a:{try{F.grow(b-J.byteLength+65535>>16);qa(F.buffer);var c=1;break a}catch(e){}c=void 0}return c?!0:!1},h:function(a,b){var c=0;Xa().forEach(function(e,g){var f=b+c;g=B[a+4*g>>2]=f;for(f=0;f<e.length;++f)z[g++>>0]=e.charCodeAt(f);z[g>>0]=0;c+=e.length+1});return 0},i:function(a,b){var c=\nXa();B[a>>2]=c.length;var e=0;c.forEach(function(a){e+=a.length+1});B[b>>2]=e;return 0},l:function(){return 0},m:function(){return 0},k:function(a,b,c,e){try{for(var g=0,f=0;f<c;f++){for(var h=B[b+8*f>>2],m=B[b+(8*f+4)>>2],q=0;q<m;q++){var l=H[h+q],n=Da[a];0===l||10===l?((1===a?da:x)(ma(n,0)),n.length=0):n.push(l)}g+=m}B[e>>2]=g;return 0}catch(v){return E(v),v.S}},memory:F,w:function(){},p:function(){},u:function(a,b,c,e){return $a(a,b,c,e)},table:ea},eb=function(){function a(a){d.asm=a.exports;M--;\nd.monitorRunDependencies&&d.monitorRunDependencies(M);0==M&&(null!==xa&&(clearInterval(xa),xa=null),N&&(a=N,N=null,a()))}function b(b){a(b.instance)}function c(a){return Ba().then(function(a){return WebAssembly.instantiate(a,e)}).then(a,function(a){x(\"failed to asynchronously prepare wasm: \"+a);E(a)})}var e={env:db,wasi_unstable:db};M++;d.monitorRunDependencies&&d.monitorRunDependencies(M);if(d.instantiateWasm)try{return d.instantiateWasm(e,a)}catch(g){return x(\"Module.instantiateWasm callback failed with error: \"+\ng),!1}(function(){if(y||\"function\"!==typeof WebAssembly.instantiateStreaming||ya()||\"function\"!==typeof fetch)return c(b);fetch(O,{credentials:\"same-origin\"}).then(function(a){return WebAssembly.instantiateStreaming(a,e).then(b,function(a){x(\"wasm streaming compile failed: \"+a);x(\"falling back to ArrayBuffer instantiation\");c(b)})})})();return{}}();d.asm=eb;var Ca=d.___wasm_call_ctors=function(){return d.asm.x.apply(null,arguments)};d._convert_glsl_to_spirv=function(){return d.asm.y.apply(null,arguments)};\nd._destroy_output_buffer=function(){return d.asm.z.apply(null,arguments)};var cb=d._malloc=function(){return d.asm.A.apply(null,arguments)},Y=d._free=function(){return d.asm.B.apply(null,arguments)};d.___getTypeName=function(){return d.asm.C.apply(null,arguments)};d.___embind_register_native_and_builtin_types=function(){return d.asm.D.apply(null,arguments)};\nvar ja=d.stackSave=function(){return d.asm.E.apply(null,arguments)},ia=d.stackAlloc=function(){return d.asm.F.apply(null,arguments)},ka=d.stackRestore=function(){return d.asm.G.apply(null,arguments)};d.dynCall_vi=function(){return d.asm.H.apply(null,arguments)};d.dynCall_v=function(){return d.asm.I.apply(null,arguments)};d.asm=eb;var Z;d.then=function(a){if(Z)a(d);else{var b=d.onRuntimeInitialized;d.onRuntimeInitialized=function(){b&&b();a(d)}}return d};N=function fb(){Z||gb();Z||(N=fb)};\nfunction gb(){function a(){if(!Z&&(Z=!0,!fa)){L(ta);L(ua);if(d.onRuntimeInitialized)d.onRuntimeInitialized();if(d.postRun)for(\"function\"==typeof d.postRun&&(d.postRun=[d.postRun]);d.postRun.length;){var a=d.postRun.shift();va.unshift(a)}L(va)}}if(!(0<M)){if(d.preRun)for(\"function\"==typeof d.preRun&&(d.preRun=[d.preRun]);d.preRun.length;)wa();L(sa);0<M||(d.setStatus?(d.setStatus(\"Running...\"),setTimeout(function(){setTimeout(function(){d.setStatus(\"\")},1);a()},1)):a())}}d.run=gb;\nif(d.preInit)for(\"function\"==typeof d.preInit&&(d.preInit=[d.preInit]);0<d.preInit.length;)d.preInit.pop()();gb();\n\n\n  return Module\n}\n);\n})();\nexport default (() => {\n  const initialize = () => {\n    return new Promise(resolve => {\n      Module({\n        locateFile() {\n          return wasmuri;\n        },\n        onRuntimeInitialized() {\n          resolve({\n            compileGLSLZeroCopy: this.compileGLSLZeroCopy,\n            compileGLSL: this.compileGLSL,\n          });\n        },\n      });\n    });\n  };\n\n  let instance;\n  return () => {\n    if (!instance) {\n      instance = initialize();\n    }\n    return instance;\n  };\n})();\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport class BufferManager {\n  private numUsedBuffers = 0;\n  private numFreeBuffers = 0;\n  private freeBuffers: Map<string, GPUBuffer[]> = new Map();\n  private usedBuffers: Map<string, GPUBuffer[]> = new Map();\n\n  public numBytesUsed = 0;\n  public numBytesAllocated = 0;\n\n  constructor(private device: GPUDevice) {}\n\n  acquireBuffer(byteSize: number, usage: GPUBufferUsageFlags) {\n    const key = getBufferKey(byteSize, usage);\n    if (!this.freeBuffers.has(key)) {\n      this.freeBuffers.set(key, []);\n    }\n\n    if (!this.usedBuffers.has(key)) {\n      this.usedBuffers.set(key, []);\n    }\n\n    this.numBytesUsed += byteSize;\n    this.numUsedBuffers++;\n\n    if (this.freeBuffers.get(key).length > 0) {\n      this.numFreeBuffers--;\n\n      const newBuffer = this.freeBuffers.get(key).shift();\n      this.usedBuffers.get(key).push(newBuffer);\n      return newBuffer;\n    }\n\n    this.numBytesAllocated += byteSize;\n    const newBuffer = this.device.createBuffer({size: byteSize, usage});\n    this.usedBuffers.get(key).push(newBuffer);\n\n    return newBuffer;\n  }\n\n  releaseBuffer(\n      buffer: GPUBuffer, byteSize: number, usage: GPUBufferUsageFlags) {\n    if (this.freeBuffers == null) {\n      return;\n    }\n\n    const key = getBufferKey(byteSize, usage);\n    if (!this.freeBuffers.has(key)) {\n      this.freeBuffers.set(key, []);\n    }\n\n    this.freeBuffers.get(key).push(buffer);\n    this.numFreeBuffers++;\n    this.numUsedBuffers--;\n\n    const bufferList = this.usedBuffers.get(key);\n    const bufferIndex = bufferList.indexOf(buffer);\n    if (bufferIndex < 0) {\n      throw new Error(\n          'Cannot release a buffer that was never provided by this ' +\n          'buffer manager');\n    }\n    bufferList.splice(bufferIndex, 1);\n    this.numBytesUsed -= byteSize;\n  }\n\n  getNumUsedBuffers(): number {\n    return this.numUsedBuffers;\n  }\n\n  getNumFreeBuffers(): number {\n    return this.numFreeBuffers;\n  }\n\n  reset() {\n    this.freeBuffers = new Map();\n    this.usedBuffers = new Map();\n    this.numUsedBuffers = 0;\n    this.numFreeBuffers = 0;\n    this.numBytesUsed = 0;\n    this.numBytesAllocated = 0;\n  }\n\n  dispose() {\n    if (this.freeBuffers == null && this.usedBuffers == null) {\n      return;\n    }\n\n    this.freeBuffers.forEach((buffers, key) => {\n      buffers.forEach(buff => {\n        buff.destroy();\n      });\n    });\n\n    this.usedBuffers.forEach((buffers, key) => {\n      buffers.forEach(buff => {\n        buff.destroy();\n      });\n    });\n\n    this.freeBuffers = null;\n    this.usedBuffers = null;\n    this.numUsedBuffers = 0;\n    this.numFreeBuffers = 0;\n    this.numBytesUsed = 0;\n    this.numBytesAllocated = 0;\n  }\n}\n\nfunction getBufferKey(byteSize: number, usage: GPUBufferUsageFlags) {\n  return `${byteSize}_${usage}`;\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {util} from '@tensorflow/tfjs-core';\nimport {getGlobalIndexStringWgsl, getMainHeaderStringWgsl} from '../../shader_preprocessor_wgsl';\n\nimport {computeDispatch, flatDispatchLayout, WebGPULayout} from '../../webgpu_util';\nimport {WebGPUProgram} from '../webgpu_program';\n\nexport class FromPixelsProgram implements WebGPUProgram {\n  outputShape: number[] = [0];\n  shaderKey: string;\n  workPerThread: number;\n  dispatchLayout: {x: number[]};\n  variableNames: string[] = [];\n  dispatch: [number, number, number];\n  workGroupSize: [number, number, number] =\n      [256, 1, 1];  // The empirical value.\n\n  pipeline: GPUComputePipeline;\n  uniform: GPUBuffer;\n  lastUniformData: number[] = [];\n\n  inputTexture: GPUTexture = null;\n  layout: WebGPULayout = null;\n  lastPixelSize = {width: 0, height: 0};\n  // Default to WGSL, because GLSL will complain: The provided value\n  // 'read-only' is not a valid enum value of type GPUStorageTextureAccess.\n  useWgsl = true;\n  useImport: boolean;\n\n  private disposed = false;\n\n  updateOutputShape(outputShape: number[]) {\n    if (util.arraysEqual(this.outputShape, outputShape)) {\n      return;\n    }\n\n    this.outputShape = outputShape;\n    this.workPerThread = outputShape[2];  // numChannels in outputShape.\n    this.dispatchLayout = flatDispatchLayout(this.outputShape);\n    this.dispatch = computeDispatch(\n        this.dispatchLayout, this.outputShape, this.workGroupSize,\n        [this.workPerThread, 1, 1]);\n  }\n\n  constructor() {\n    this.shaderKey = 'fromPixels';\n    this.useImport = false;\n  }\n\n  makeFromPixelsSource(): string {\n    const textureLoad = this.useImport ?\n        'textureLoad(src, vec2<i32>(coords.yx));' :\n        'textureLoad(src, vec2<i32>(coords.yx), 0)';\n    const textureType = this.useImport ? 'texture_external' : 'texture_2d<f32>';\n    return `\n      [[binding(1), group(0)]] var src: ${textureType};\n\n      ${getMainHeaderStringWgsl()} {\n        ${getGlobalIndexStringWgsl()}\n        let flatIndexBase = index * uniforms.numChannels;\n        let coords: vec3<u32> = getCoordsFromFlatIndex(flatIndexBase);\n        let values = ${textureLoad};\n        for (var i: u32 = 0u; i < uniforms.numChannels; i = i + 1u) {\n          let flatIndex = flatIndexBase + i;\n          if (flatIndex < uniforms.size) {\n            result.numbers[flatIndex] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `;\n  }\n\n  getUserCodeWgsl(): string {\n    return this.makeFromPixelsSource();\n  }\n\n  getUserCode(): string {\n    const userCode = `\n    layout (local_size_x = ${this.workGroupSize[0]},\n      local_size_y = 1,\n      local_size_z = 1) in;\n    layout(set = 0, binding = 1, rgba8) uniform readonly image2D srcImage;\n    layout(set = 0, binding = 2) uniform Meta {\n      int size;\n      int numChannels;\n      ivec2 outShapeStrides;\n    };\n\n    ivec3 getCoordsFromFlatIndex(int flatIndexBase);\n\n    void main() {\n      int flatIndexBase = int(gl_GlobalInvocationID.x) * numChannels;\n      ivec3 coords = getCoordsFromFlatIndex(flatIndexBase);\n      int texR = coords[0];\n      int texC = coords[1];\n      vec4 values = imageLoad(srcImage, ivec2(texC, texR));\n      for(int i = 0; i < numChannels; i++) {\n        float value = values[i];\n        int flatIndex = flatIndexBase + i;\n        if (flatIndex < size) {\n          result[flatIndex] = int(floor(255.0 * value));\n        }\n      }\n    }\n    `;\n    return userCode;\n  }\n\n  setPipeline(pipeline: GPUComputePipeline) {\n    this.pipeline = pipeline;\n  }\n\n  setUniform(device: GPUDevice, uniformData: number[]) {\n    // Create the uniform buffer if it does not exist.\n    // The uniform buffer size is fixed so we can hold\n    // and reuse it always.\n    if (!this.uniform) {\n      const uniformBuffer = device.createBuffer({\n        size: uniformData.length *\n            4,  // The uniform buffer contains two 4 bytes element always.\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST\n      });\n\n      this.uniform = uniformBuffer;\n    }\n\n    // No need to update uniform buffer if no changes.\n    if (!uniformData ||\n        ((uniformData.length === this.lastUniformData.length) &&\n         uniformData.every((v, i) => v === this.lastUniformData[i]))) {\n      return;\n    }\n\n    device.queue.writeBuffer(this.uniform, 0, new Uint32Array(uniformData));\n\n    this.lastUniformData = uniformData;\n  }\n\n  makeInputTexture(device: GPUDevice, pixelWidth: number, pixelHeight: number):\n      GPUTexture {\n    if (!this.inputTexture || this.lastPixelSize.width !== pixelWidth ||\n        this.lastPixelSize.height !== pixelHeight) {\n      if (this.inputTexture) {\n        this.inputTexture.destroy();\n      }\n\n      this.inputTexture = device.createTexture({\n        size: [pixelWidth, pixelHeight],\n        format: 'rgba8unorm',\n        usage: this.useWgsl ?\n            GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT |\n                GPUTextureUsage.TEXTURE_BINDING :\n            GPUTextureUsage.COPY_DST | GPUTextureUsage.RENDER_ATTACHMENT |\n                GPUTextureUsage.STORAGE_BINDING,\n      });\n      this.lastPixelSize.width = pixelWidth;\n      this.lastPixelSize.height = pixelHeight;\n    }\n    return this.inputTexture;\n  }\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n    if (this.uniform) {\n      this.uniform.destroy();\n    }\n    if (this.inputTexture) {\n      this.inputTexture.destroy();\n    }\n    this.disposed = true;\n  }\n\n  getLayout(device: GPUDevice): WebGPULayout {\n    if (this.layout === null) {\n      this.layout = this.createTextureLayout(device);\n    }\n    return this.layout;\n  }\n\n  private createTextureLayout(device: GPUDevice): WebGPULayout {\n    const bindGroupLayoutEntries: GPUBindGroupLayoutEntry[] = [];\n    // Output buffer binding layout.\n    bindGroupLayoutEntries.push({\n      binding: 0,\n      visibility: GPUShaderStage.COMPUTE,\n      buffer: {type: 'storage' as const}\n    });\n    // Input buffer binding layout.\n    this.useWgsl ?\n        bindGroupLayoutEntries.push(\n            {binding: 1, visibility: GPUShaderStage.COMPUTE, texture: {}}) :\n        bindGroupLayoutEntries.push({\n          binding: 1,\n          visibility: GPUShaderStage.COMPUTE,\n          storageTexture: {access: 'read-only', format: 'rgba8unorm'}\n        });\n    // Uniform buffer binding layout.\n    bindGroupLayoutEntries.push(\n        {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {}});\n    const fromPixelBindGroupLayout =\n        device.createBindGroupLayout({entries: bindGroupLayoutEntries});\n    const fromPixelPipelineLayout = device.createPipelineLayout(\n        {bindGroupLayouts: [fromPixelBindGroupLayout]});\n    return {\n      bindGroupLayout: fromPixelBindGroupLayout,\n      pipelineLayout: fromPixelPipelineLayout\n    };\n  }\n}\n", "/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {WebGPULayout} from '../../webgpu_util';\nimport {FromPixelsProgram} from './from_pixels_webgpu';\n\nexport class FromPixelsImportProgram extends FromPixelsProgram {\n  useWgsl = true;\n  layout: WebGPULayout = null;\n  useImport = true;\n\n  getUserCodeWgsl(): string {\n    return this.makeFromPixelsSource();\n  }\n\n  getLayout(device: GPUDevice): WebGPULayout {\n    if (this.layout === null) {\n      this.layout = this.createTextureImportLayout(device);\n    }\n    return this.layout;\n  }\n\n  private createTextureImportLayout(device: GPUDevice): WebGPULayout {\n    const bindGroupLayoutEntries: GPUBindGroupLayoutEntry[] = [];\n    // Output buffer binding layout.\n    bindGroupLayoutEntries.push({\n      binding: 0,\n      visibility: GPUShaderStage.COMPUTE,\n      buffer: {type: 'storage' as const}\n    });\n    // Input buffer binding layout.\n    bindGroupLayoutEntries.push({\n      binding: 1,\n      visibility: GPUShaderStage.COMPUTE,\n      externalTexture: {},\n    });\n    // Uniform buffer binding layout.\n    bindGroupLayoutEntries.push(\n        {binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: {}});\n    const fromPixelImportBindGroupLayout =\n        device.createBindGroupLayout({entries: bindGroupLayoutEntries});\n    const fromPixelImportPipelineLayout = device.createPipelineLayout(\n        {bindGroupLayouts: [fromPixelImportBindGroupLayout]});\n    return {\n      bindGroupLayout: fromPixelImportBindGroupLayout,\n      pipelineLayout: fromPixelImportPipelineLayout\n    };\n  }\n}\n", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/// <reference types=\"@webgpu/types\" />\n\nimport './flags_webgpu';\n\nimport {backend_util, buffer, DataStorage, DataType, DataValues, engine, env, KernelBackend, Rank, RecursiveArray, ShapeMap, TensorBuffer, TensorInfo, TimingInfo, util} from '@tensorflow/tfjs-core';\nimport {Glslang} from '@webgpu/glslang/dist/web-devel/glslang.onefile';\n\nimport {BufferManager} from './buffer_manager';\nimport {FromPixelsImportProgram} from './kernels/FromPixels_utils/from_pixels_import_webgpu';\nimport {FromPixelsProgram} from './kernels/FromPixels_utils/from_pixels_webgpu';\nimport * as webgpu_program from './kernels/webgpu_program';\nimport * as webgpu_util from './webgpu_util';\nimport {WebGPULayout} from './webgpu_util';\n\nexport interface WebGPUMemoryInfo extends backend_util.MemoryInfo {\n  numBytesInGPU: number;\n  numBytesAllocatedInGPU: number;\n  unreliable: boolean;\n}\n\ntype BufferInfo = {\n  byteSize: number,\n  usage: GPUBufferUsageFlags,\n  buffer?: GPUBuffer\n};\n\ntype TensorBufferInfo = {\n  values: backend_util.BackendValues,\n  dtype: DataType,\n  bufferInfo: BufferInfo,\n  refCount: number,\n  // For complex numbers, the real and imaginary parts are stored as their own\n  // individual tensors, with a parent joining the two with the\n  // complexTensorInfos field.\n  complexTensorInfos?: {real: TensorInfo, imag: TensorInfo}\n};\n\ninterface DataId {}\n\nexport type WebGPUKernelInfo = {\n  name: string; query: Promise<number>;\n};\n\nexport type TimerNode = RecursiveArray<WebGPUKernelInfo>|WebGPUKernelInfo;\n\nexport interface WebGPUTimingInfo extends TimingInfo {\n  uploadWaitMs: number;\n  downloadWaitMs: number;\n}\n\n// Empirically determined constant used to determine size threshold for handing\n// off execution to the CPU.\nconst CPU_HANDOFF_SIZE_THRESHOLD =\n    env().getNumber('CPU_HANDOFF_SIZE_THRESHOLD');\n\nexport class WebGPUBackend extends KernelBackend {\n  device: GPUDevice;\n  queue: GPUQueue;\n  glslang: Glslang;\n  currentCommandEncoder: GPUCommandEncoder;\n  tensorMap: DataStorage<TensorBufferInfo>;\n  supportTimeQuery: boolean;\n  dummyCanvas: HTMLCanvasElement;\n  dummyContext: GPUCanvasContext;\n\n  private static nextDataId = 0;\n  private nextDataId(): number {\n    return WebGPUBackend.nextDataId++;\n  }\n  private commandQueueOwnedIds = new WeakSet<DataId>();\n  private layoutCache: {[key: number]: WebGPULayout};\n  private pipelineCache: {[key: string]: GPUComputePipeline};\n  private bufferManager: BufferManager;\n\n  private tensorDisposalQueue: DataId[] = [];\n  private uniformDisposalQueue: BufferInfo[] = [];\n\n  private disposed = false;\n\n  private programTimersStack: TimerNode[];\n  private activeTimers: TimerNode[];\n  private uploadWaitMs = 0;\n  private downloadWaitMs = 0;\n  private computePassNumberInEncoder = 0;\n  private querySet: GPUQuerySet;\n  private fromPixelProgram?: FromPixelsProgram;\n  private fromPixelImportProgram?: FromPixelsImportProgram;\n\n  constructor(device: GPUDevice, glslang: Glslang, supportTimeQuery = false) {\n    super();\n    if (!webgpu_util.isWebGPUSupported()) {\n      throw new Error('WebGPU is not supported on this device');\n    }\n    this.layoutCache = {};\n    this.pipelineCache = {};\n    this.device = device;\n    this.queue = device.queue;\n    this.currentCommandEncoder = null;\n    this.glslang = glslang;\n    this.supportTimeQuery = supportTimeQuery;\n\n    this.bufferManager = new BufferManager(this.device);\n    this.tensorMap = new DataStorage(this, engine());\n    if (this.supportTimeQuery) {\n      this.querySet = this.device.createQuerySet({\n        type: 'timestamp',\n        count: 2,\n      });\n    }\n\n    // Profiling tools like PIX needs this dummy canvas to\n    // trigger capturing a frame.\n    if (env().getBool('WEBGPU_USE_PROFILE_TOOL')) {\n      this.dummyCanvas = document.createElement('canvas');\n      this.dummyCanvas.width = 1;\n      this.dummyCanvas.height = 1;\n\n      // TODO: @webgpu/types 0.1.6 version has a bug to support both old\n      // rendring context type and webgpu context type. Use any to bypass this.\n      // tslint:disable-next-line:no-any\n      this.dummyContext = this.dummyCanvas.getContext('webgpu') as any;\n      this.dummyContext.configure({\n        device,\n        format: 'bgra8unorm',\n      });\n\n      document.body.appendChild(this.dummyCanvas);\n    }\n  }\n\n  floatPrecision(): 32 {\n    return 32;\n  }\n\n  defaultGpuBufferUsage(): number {\n    return GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC |\n        GPUBufferUsage.COPY_DST;\n  }\n\n  flushDisposalQueue() {\n    this.tensorDisposalQueue.forEach(d => {\n      this.maybeReleaseBuffer(d);\n      this.tensorMap.delete(d);\n    });\n    this.uniformDisposalQueue.forEach(\n        d => this.bufferManager.releaseBuffer(d.buffer, d.byteSize, d.usage));\n\n    this.tensorDisposalQueue = [];\n    this.uniformDisposalQueue = [];\n  }\n\n  /**\n   * Dispose the memory if the dataId has 0 refCount. Return true if the memory\n   * is released or memory is not managed in this backend, false if memory is\n   * not cleared.\n   * @param dataId\n   * @oaram force Optional, remove the data regardless of refCount\n   */\n  disposeData(dataId: DataId, force = false): boolean {\n    if (this.tensorMap.has(dataId)) {\n      const data = this.tensorMap.get(dataId);\n      data.refCount--;\n      if (!force && data.refCount > 0) {\n        return false;\n      }\n\n      if (this.commandQueueOwnedIds.has(dataId)) {\n        this.tensorDisposalQueue.push(dataId);\n        return false;\n      } else {\n        this.maybeReleaseBuffer(dataId);\n      }\n\n      const {complexTensorInfos} = this.tensorMap.get(dataId);\n      if (complexTensorInfos != null) {\n        this.disposeData(complexTensorInfos.real.dataId, true);\n        this.disposeData(complexTensorInfos.imag.dataId, true);\n      }\n\n      this.tensorMap.delete(dataId);\n    }\n    return true;\n  }\n\n  memory(): WebGPUMemoryInfo {\n    return {\n      numBytesInGPU: this.bufferManager.numBytesUsed,\n      numBytesAllocatedInGPU: this.bufferManager.numBytesAllocated,\n      unreliable: false\n    } as WebGPUMemoryInfo;\n  }\n\n  getBufferManager(): BufferManager {\n    return this.bufferManager;\n  }\n\n  acquireBuffer(\n      byteSize: number,\n      usage: GPUBufferUsageFlags = this.defaultGpuBufferUsage()) {\n    return this.bufferManager.acquireBuffer(byteSize, usage);\n  }\n\n  maybeReleaseBuffer(dataId: DataId) {\n    const info = this.tensorMap.get(dataId);\n    if (info != null && info.bufferInfo.buffer != null) {\n      this.bufferManager.releaseBuffer(\n          info.bufferInfo.buffer, info.bufferInfo.byteSize,\n          info.bufferInfo.usage);\n      info.bufferInfo.buffer = null;\n    }\n  }\n\n  /** Return refCount of a `TensorData`. */\n  refCount(dataId: DataId): number {\n    if (this.tensorMap.has(dataId)) {\n      const tensorData = this.tensorMap.get(dataId);\n      return tensorData.refCount;\n    }\n    return 0;\n  }\n\n  /** Increase refCount of a `TensorData`. */\n  incRef(dataId: DataId): void {\n    const tensorData = this.tensorMap.get(dataId);\n    tensorData.refCount++;\n  }\n\n  /** Decrease refCount of a `TensorData`. */\n  decRef(dataId: DataId): void {\n    if (this.tensorMap.has(dataId)) {\n      const tensorData = this.tensorMap.get(dataId);\n      tensorData.refCount--;\n    }\n  }\n\n  write(values: backend_util.BackendValues, shape: number[], dtype: DataType):\n      DataId {\n    if (dtype === 'complex64' && values != null) {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n\n    const dataId = {id: this.nextDataId()};\n    const byteSize =\n        util.sizeFromShape(shape) * webgpu_util.GPUBytesPerElement(dtype);\n\n    // bool is stored in Uint8Array, converted it to Int32Array.\n    if (dtype === 'bool' && values instanceof Uint8Array) {\n      values = Int32Array.from(values);\n    }\n\n    this.tensorMap.set(dataId, {\n      dtype,\n      values,\n      bufferInfo: {byteSize, usage: this.defaultGpuBufferUsage()},\n      refCount: 1\n    });\n    return dataId;\n  }\n\n  move(\n      dataId: DataId, values: backend_util.BackendValues, shape: number[],\n      dtype: DataType, refCount: number): void {\n    if (dtype === 'complex64') {\n      throw new Error(\n          `Cannot write to a complex64 dtype. ` +\n          `Please use tf.complex(real, imag).`);\n    }\n    const byteSize =\n        util.sizeFromShape(shape) * webgpu_util.GPUBytesPerElement(dtype);\n\n    this.tensorMap.set(dataId, {\n      dtype,\n      values,\n      bufferInfo: {byteSize, usage: this.defaultGpuBufferUsage()},\n      refCount\n    });\n  }\n\n  submitQueue() {\n    this.queue.submit([this.currentCommandEncoder.finish()]);\n    this.currentCommandEncoder = null;\n    this.computePassNumberInEncoder = 0;\n\n    this.commandQueueOwnedIds = new WeakSet<DataId>();\n\n    this.flushDisposalQueue();\n  }\n\n  getBuffer(dataId: DataId) {\n    this.uploadToGPU(dataId);\n    return this.tensorMap.get(dataId).bufferInfo.buffer;\n  }\n\n  getFromPixelsProgram(type: 'copyExternal'|'import'): FromPixelsProgram {\n    switch (type) {\n      case 'copyExternal': {\n        if (!this.fromPixelProgram) {\n          this.fromPixelProgram = new FromPixelsProgram();\n        }\n        return this.fromPixelProgram;\n      }\n      case 'import': {\n        if (!this.fromPixelImportProgram) {\n          this.fromPixelImportProgram = new FromPixelsImportProgram();\n        }\n        return this.fromPixelImportProgram;\n      }\n      default:\n        util.assert(false, () => `Unsupported fromPixels shape`);\n        return undefined;\n    }\n  }\n\n  ensureCommandEncoderReady() {\n    if (!this.currentCommandEncoder) {\n      this.currentCommandEncoder = this.device.createCommandEncoder();\n    }\n  }\n\n  private async getBufferData(info: TensorBufferInfo):\n      Promise<backend_util.BackendValues> {\n    if (info.values != null) {\n      // Data is on the CPU.\n      return info.values;\n    }\n    const staging = this.acquireBuffer(\n        info.bufferInfo.byteSize,\n        GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);\n    this.ensureCommandEncoderReady();\n    this.currentCommandEncoder.copyBufferToBuffer(\n        info.bufferInfo.buffer, 0, staging, 0, info.bufferInfo.byteSize);\n    this.submitQueue();\n\n    await staging.mapAsync(GPUMapMode.READ);\n    const values = staging.getMappedRange().slice(0);\n\n    staging.unmap();\n    if (staging != null) {\n      this.bufferManager.releaseBuffer(\n          staging, info.bufferInfo.byteSize,\n          GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);\n    }\n\n    // Need to get texture from swapChain to enable profiling tool\n    // to capture a frame\n    if (env().getBool('WEBGPU_USE_PROFILE_TOOL')) {\n      util.assert(\n          this.dummyContext !== undefined,\n          () => `Fail to get context for profiling tool`);\n      this.dummyContext.getCurrentTexture();\n    }\n\n    return values as backend_util.BackendValues;\n  }\n\n  private convertAndCacheOnCPU(dataId: DataId, data: backend_util.TypedArray):\n      backend_util.TypedArray {\n    const info = this.tensorMap.get(dataId);\n\n    this.maybeReleaseBuffer(dataId);\n\n    info.values = data;\n    return info.values;\n  }\n\n  // TODO: Remove once this is fixed:\n  // https://github.com/tensorflow/tfjs/issues/1595\n  readSync(dataId: object): backend_util.BackendValues {\n    const texData = this.tensorMap.get(dataId);\n    const {values} = texData;\n\n    if (values == null) {\n      throw new Error(\n          'WebGPU readSync is only available for CPU-resident tensors.');\n    }\n\n    return values;\n  }\n\n  async read(dataId: object): Promise<backend_util.BackendValues> {\n    if (!this.tensorMap.has(dataId)) {\n      throw new Error(`Tensor ${dataId} was not registered!`);\n    }\n    const info = this.tensorMap.get(dataId);\n\n    const {values} = info;\n\n    if (values != null) {\n      // TODO(xing.xu@intel.com): Merge backend_util.BackendValues and\n      // backend_util.TypedArray.\n      return this.convertAndCacheOnCPU(\n                 dataId, values as backend_util.TypedArray) as\n          backend_util.BackendValues;\n    }\n\n    // Download the values from the GPU.\n    let vals: backend_util.BackendValues;\n    if (info.dtype === 'complex64') {\n      const ps = await Promise.all([\n        this.read(info.complexTensorInfos.real.dataId),\n        this.read(info.complexTensorInfos.imag.dataId)\n      ]);\n\n      const realValues = ps[0];\n      const imagValues = ps[1];\n      vals = backend_util.mergeRealAndImagArrays(\n          realValues as Float32Array, imagValues as Float32Array);\n    } else {\n      const data = await this.getBufferData(info);\n      vals =\n          webgpu_util.ArrayBufferToTypedArray(data as ArrayBuffer, info.dtype);\n    }\n    this.convertAndCacheOnCPU(dataId, vals);\n    return vals;\n  }\n\n  bufferSync<R extends Rank>(t: TensorInfo): TensorBuffer<R> {\n    const data = this.readSync(t.dataId);\n    let decodedData = data as DataValues;\n    if (t.dtype === 'string') {\n      try {\n        // Decode the bytes into string.\n        decodedData = (data as Uint8Array[]).map(d => util.decodeString(d));\n      } catch {\n        throw new Error('Failed to decode encoded string bytes into utf-8');\n      }\n    }\n    return buffer(t.shape as ShapeMap[R], t.dtype, decodedData) as\n        TensorBuffer<R>;\n  }\n\n  async time(f: () => void): Promise<WebGPUTimingInfo> {\n    const oldActiveTimers = this.activeTimers;\n    const newActiveTimers: TimerNode[] = [];\n\n    let outerMostTime = false;\n    if (this.programTimersStack == null) {\n      this.programTimersStack = newActiveTimers;\n      outerMostTime = true;\n    } else {\n      this.activeTimers.push(newActiveTimers);\n    }\n    this.activeTimers = newActiveTimers;\n\n    f();\n\n    const flattenedActiveTimerQueries =\n        util.flatten(this.activeTimers.map((d: WebGPUKernelInfo) => d.query))\n            .filter(d => d != null);\n    const flattenedActiveTimerNames =\n        util.flatten(this.activeTimers.map((d: WebGPUKernelInfo) => d.name))\n            .filter(d => d != null);\n\n    this.activeTimers = oldActiveTimers;\n\n    if (outerMostTime) {\n      this.programTimersStack = null;\n    }\n    const res: WebGPUTimingInfo = {\n      uploadWaitMs: this.uploadWaitMs,\n      downloadWaitMs: this.downloadWaitMs,\n      kernelMs: null,\n      wallMs: null\n    };\n\n    const kernelMs = await Promise.all(flattenedActiveTimerQueries);\n    res['kernelMs'] = util.sum(kernelMs);\n    res['getExtraProfileInfo'] = () =>\n        kernelMs.map((d, i) => ({name: flattenedActiveTimerNames[i], ms: d}))\n            .map(d => `${d.name}: ${d.ms}`)\n            .join(', ');\n    this.uploadWaitMs = 0;\n    this.downloadWaitMs = 0;\n    return res;\n  }\n\n  getAndSavePipeline(key: string, getPipeline: () => GPUComputePipeline) {\n    if (!(key in this.pipelineCache)) {\n      this.pipelineCache[key] = getPipeline();\n    }\n    return this.pipelineCache[key];\n  }\n\n  makeTensorInfo(\n      shape: number[], dtype: DataType,\n      values?: backend_util.BackendValues|string[]): TensorInfo {\n    let dataId;\n    if (dtype === 'string' && values != null && values.length > 0 &&\n        util.isString(values[0])) {\n      const encodedValues =\n          (values as {} as string[]).map(d => util.encodeString(d));\n\n      dataId = this.write(encodedValues, shape, dtype);\n    } else {\n      dataId = this.write(values as backend_util.BackendValues, shape, dtype);\n    }\n    return {dataId, shape, dtype};\n  }\n\n  private tensorToBinding(tensor?: TensorInfo): GPUBindingResource {\n    if (!tensor) {\n      return null;\n    }\n\n    const tensorData = this.tensorMap.get(tensor.dataId);\n\n    return {\n      offset: 0,\n      size: tensorData.bufferInfo.byteSize,\n      buffer: tensorData.bufferInfo.buffer\n    };\n  }\n\n  async getQueryTime(query: GPUQuerySet): Promise<number> {\n    if (this.supportTimeQuery) {\n      return this.getTimeFromQuerySet(query);\n    } else {\n      return 0;\n    }\n  }\n\n  uploadToGPU(dataId: DataId): void {\n    const info = this.tensorMap.get(dataId);\n\n    if (info.bufferInfo.buffer != null) {\n      // Already on the GPU.\n      return;\n    }\n\n    info.bufferInfo.buffer = this.acquireBuffer(info.bufferInfo.byteSize);\n\n    if (info.values) {\n      this.queue.writeBuffer(\n          info.bufferInfo.buffer, 0, info.values as ArrayBuffer);\n      // TODO: WebGPU doesn't support read data synchronously from GPU to CPU.\n      // So it will report error when switching backend from WebGPU to others.\n      // There are two situations: 1) swithcing the backend after running a\n      // model; 2) swithcing the backend within the model. Temporarilly keep the\n      // values on CPU to solve the first issue.\n      // info.values = null;\n    }\n  }\n\n  private makeUniformsDataView(data: DataView): GPUBindingResource {\n    const dimensionsBuffer = this.acquireBuffer(\n        data.byteLength, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);\n    this.queue.writeBuffer(dimensionsBuffer, 0, data);\n\n    return {offset: 0, size: data.byteLength, buffer: dimensionsBuffer};\n  }\n\n  private arrayToDataView(\n      arrays: Array<{type: string; data: number[]}>, length: number): DataView {\n    const BYTES_PER_ELEMENT = 4;\n    const uniformDataView =\n        new DataView(new ArrayBuffer(length * BYTES_PER_ELEMENT));\n\n    let dataViewIndex = 0;\n    arrays.forEach(array => {\n      const arrayData = array.data;\n\n      if (array.type !== 'int32' && array.type !== 'float32' &&\n          array.type !== 'uint32') {\n        throw new Error(`${array.type} not supported!`);\n      }\n\n      if (array.type === 'int32') {\n        arrayData.forEach(d => {\n          uniformDataView.setInt32(dataViewIndex * BYTES_PER_ELEMENT, d, true);\n          dataViewIndex++;\n        });\n      } else if (array.type === 'uint32') {\n        arrayData.forEach(d => {\n          uniformDataView.setUint32(dataViewIndex * BYTES_PER_ELEMENT, d, true);\n          dataViewIndex++;\n        });\n      } else {\n        arrayData.forEach(d => {\n          uniformDataView.setFloat32(\n              dataViewIndex * BYTES_PER_ELEMENT, d, true);\n          dataViewIndex++;\n        });\n      }\n    });\n\n    return uniformDataView;\n  }\n\n  private computePadding(uniformsWithType:\n                             Array<{type: string; data: number[];}>): DataView {\n    let currentOffset = 0;\n    let padding = 0;\n    let dataViewIndex = 0;\n    const dimUniformsData: Array<{type: string; data: number[];}> = [];\n    uniformsWithType.forEach((d, i) => {\n      if (d.data.length === 0) {\n        d.data = [1];\n      }\n      // Complete std140 layout rules are documented here:\n      // tslint:disable-next-line:max-line-length\n      // https://www.khronos.org/registry/OpenGL/specs/gl/glspec45.core.pdf#page=159\n      let baseAlignment: number;\n      switch (d.data.length) {\n        case 0:\n          baseAlignment = 1;\n          break;\n        case 1:\n          baseAlignment = 1;\n          break;\n        case 2:\n          baseAlignment = 2;\n          break;\n        case 3:\n          baseAlignment = 4;\n          break;\n        case 4:\n          baseAlignment = 4;\n          break;\n        default:\n          util.assert(false, () => `Unsupported ${d.data.length}D shape`);\n      }\n\n      padding = Math.ceil(currentOffset / baseAlignment) * baseAlignment -\n          currentOffset;\n      for (let p = 0; p < padding; ++p) {\n        dimUniformsData.push({type: d.type, data: [0]});\n        dataViewIndex++;\n      }\n      dimUniformsData.push({type: d.type, data: d.data});\n      dataViewIndex = dataViewIndex + d.data.length;\n      currentOffset += d.data.length + padding;\n    });\n\n    return this.arrayToDataView(dimUniformsData, dataViewIndex);\n  }\n\n  // This layout is used by all programs except fromPixel.\n  private createLayout(inputEntrySize: number): WebGPULayout {\n    const bindGroupLayoutEntries: GPUBindGroupLayoutEntry[] = [];\n    // Output buffer binding layout.\n    bindGroupLayoutEntries.push({\n      binding: 0,\n      visibility: GPUShaderStage.COMPUTE,\n      buffer: {type: 'storage' as const}\n    });\n    // Input buffer binding layout. Depends on variableNames length.\n    for (let i = 0; i < inputEntrySize; i++) {\n      bindGroupLayoutEntries.push({\n        binding: i + 1,\n        visibility: GPUShaderStage.COMPUTE,\n        buffer: {type: 'read-only-storage' as const}\n      });\n    }\n    bindGroupLayoutEntries.push({\n      binding: inputEntrySize + 1,\n      visibility: GPUShaderStage.COMPUTE,\n      buffer: {type: 'uniform' as const}\n    });\n    const bindGroupLayout =\n        this.device.createBindGroupLayout({entries: bindGroupLayoutEntries});\n    const pipelineLayout =\n        this.device.createPipelineLayout({bindGroupLayouts: [bindGroupLayout]});\n    return {bindGroupLayout, pipelineLayout};\n  }\n\n  private getCachedOrCreateLayout(inputEntrySize: number): WebGPULayout {\n    if (!(inputEntrySize in this.layoutCache)) {\n      this.layoutCache[inputEntrySize] = this.createLayout(inputEntrySize);\n    }\n    return this.layoutCache[inputEntrySize];\n  }\n\n  public runWebGPUProgram(\n      program: webgpu_program.WebGPUProgram, inputs: TensorInfo[],\n      outputDtype: DataType,\n      programUniforms?: Array<{type: string; data: number[]}>): TensorInfo {\n    const output = this.makeTensorInfo(program.outputShape, outputDtype);\n    const outData = this.tensorMap.get(output.dataId);\n    if (util.sizeFromShape(output.shape) === 0) {\n      // Short-circuit the computation since the result is empty (has 0 in its\n      // shape).\n      outData.values =\n          util.getTypedArrayFromDType(output.dtype as 'float32', 0);\n      return output;\n    }\n\n    // There are five kinds of uniforms: NAN, shapes, shape strides, program\n    // size, program defined uniforms.\n    let uniformsWithType: Array<{type: string; data: number[];}> =\n        [{type: 'float32', data: [NaN]}];\n    const bufferShapes = inputs.concat(output).map(d => d.shape);\n    let uniformsType = 'int32';\n    if (program.useWgsl) {\n      uniformsType = 'uint32';\n    }\n    bufferShapes.map(d => {\n      uniformsWithType.push({type: uniformsType, data: d});\n    });\n    const strides = util.computeStrides(output.shape);\n    uniformsWithType.push({type: uniformsType, data: strides});\n    if (program.size != null) {\n      uniformsWithType.push({type: uniformsType, data: [program.size]});\n    }\n    uniformsWithType.push({type: 'int32', data: program.dispatch});\n    if (programUniforms) {\n      uniformsWithType = [...uniformsWithType, ...programUniforms];\n    }\n\n    let uniforms: GPUBindingResource = null;\n    const uniformsDataView = this.computePadding(uniformsWithType);\n    const uniformsByteLength = uniformsDataView.byteLength;\n    uniforms = this.makeUniformsDataView(uniformsDataView);\n\n    const inputsData = inputs.map((input: TensorInfo, i: number) => {\n      if (input.dtype === 'complex64') {\n        throw new Error(\n            `GPGPUProgram does not support complex64 input. For complex64 ` +\n            `dtypes, please separate the program into real and imaginary ` +\n            `parts.`);\n      }\n      this.uploadToGPU(input.dataId);\n\n      return {\n        // Returning dtype from tensorMap because it reflects dtype\n        // of underlying buffer, rather than abstract dtype.\n        dtype: this.tensorMap.get(input.dataId).dtype,\n        shape: input.shape,\n        name: program.variableNames[i]\n      };\n    });\n    this.uploadToGPU(output.dataId);\n    const bufferTypes = inputsData.map(d => d.dtype).concat(output.dtype);\n    const broadcastDims = inputsData.map(\n        d => backend_util.getBroadcastDims(d.shape, output.shape));\n    const inputShapesEqualsOutShape =\n        inputsData.map(d => util.arraysEqual(d.shape, output.shape)).join('_');\n    const broadcastDimsKey = broadcastDims.map(d => d.join('_')).join(';');\n    const key = webgpu_program.makeShaderKey(\n        program, bufferShapes, bufferTypes, broadcastDimsKey,\n        inputShapesEqualsOutShape);\n\n    const {bindGroupLayout, pipelineLayout} =\n        this.getCachedOrCreateLayout(program.variableNames.length);\n\n    const pipeline = this.getAndSavePipeline(key, () => {\n      return webgpu_program.compileProgram(\n          this.glslang, this.device, program, pipelineLayout, inputsData,\n          output);\n    });\n\n    const shouldTimeProgram = this.activeTimers != null;\n\n    // Creating bind groups on the fly should never be a bottleneck.\n    const bg = webgpu_program.makeBindGroup(\n        this.device, bindGroupLayout, inputs.map(t => this.tensorToBinding(t)),\n        this.tensorToBinding(output), uniforms);\n\n    this.ensureCommandEncoderReady();\n    const pass = this.currentCommandEncoder.beginComputePass();\n    if (shouldTimeProgram) {\n      if (this.supportTimeQuery) {\n        pass.writeTimestamp(this.querySet, 0);\n      }\n    }\n    pass.setPipeline(pipeline);\n    pass.setBindGroup(0, bg);\n    pass.dispatch(\n        program.dispatch[0], program.dispatch[1], program.dispatch[2]);\n    if (shouldTimeProgram) {\n      if (this.supportTimeQuery) {\n        pass.writeTimestamp(this.querySet, 1);\n      }\n    }\n    pass.endPass();\n    this.computePassNumberInEncoder++;\n\n    inputs.forEach(input => {\n      this.commandQueueOwnedIds.add(input.dataId);\n    });\n    this.commandQueueOwnedIds.add(output.dataId);\n    if (uniforms) {\n      const uniformInfo = {\n        byteSize: uniformsByteLength,\n        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM,\n        buffer: (uniforms as GPUBufferBinding).buffer\n      };\n      this.uniformDisposalQueue.push(uniformInfo);\n    }\n\n    if (env().get('WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE') as\n        number <= this.computePassNumberInEncoder) {\n      this.submitQueue();\n    }\n\n    if (shouldTimeProgram) {\n      this.activeTimers.push({\n        name: program.constructor.name,\n        query: this.getQueryTime(this.querySet)\n      });\n    }\n    return output;\n  }\n\n  runFromPixelsProgram(\n      program: FromPixelsProgram, output: GPUBuffer, layout: WebGPULayout,\n      externalResource: GPUExternalTexture|GPUTextureView, outputId: DataId) {\n    const bindGroup = this.device.createBindGroup({\n      layout: layout.bindGroupLayout,\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: output,\n          }\n        },\n        {\n          binding: 1,\n          resource: externalResource,\n        },\n        {\n          binding: 2,\n          resource: {\n            buffer: program.uniform,\n          }\n        }\n      ],\n    });\n    this.ensureCommandEncoderReady();\n    const passEncoder = this.currentCommandEncoder.beginComputePass();\n    const shouldTimeProgram = this.activeTimers != null;\n    if (shouldTimeProgram) {\n      if (this.supportTimeQuery) {\n        passEncoder.writeTimestamp(this.querySet, 0);\n      }\n    }\n    passEncoder.setPipeline(program.pipeline);\n    passEncoder.setBindGroup(0, bindGroup);\n    passEncoder.dispatch(\n        program.dispatch[0], program.dispatch[1], program.dispatch[2]);\n    if (shouldTimeProgram) {\n      if (this.supportTimeQuery) {\n        passEncoder.writeTimestamp(this.querySet, 1);\n      }\n    }\n    passEncoder.endPass();\n    this.commandQueueOwnedIds.add(outputId);\n    this.submitQueue();\n    if (shouldTimeProgram) {\n      this.activeTimers.push({\n        name: program.constructor.name,\n        query: this.getQueryTime(this.querySet)\n      });\n    }\n  }\n\n  async getTimeFromQuerySet(querySet: GPUQuerySet) {\n    const queryBuffer = this.acquireBuffer(\n        16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE);\n    const dst = this.acquireBuffer(\n        16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n\n    this.ensureCommandEncoderReady();\n    this.currentCommandEncoder.resolveQuerySet(querySet, 0, 2, queryBuffer, 0);\n    this.currentCommandEncoder.copyBufferToBuffer(queryBuffer, 0, dst, 0, 16);\n    this.submitQueue();\n    await dst.mapAsync(GPUMapMode.READ);\n    const arrayBuf = new BigUint64Array(dst.getMappedRange());\n    const timeElapsedNanos = Number((arrayBuf[1] - arrayBuf[0]));\n    dst.unmap();\n    this.bufferManager.releaseBuffer(\n        dst, 16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);\n    this.bufferManager.releaseBuffer(\n        queryBuffer, 16,\n        GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE);\n    // Return milliseconds.\n    return timeElapsedNanos / 1000000;\n  }\n\n  shouldExecuteOnCPU(\n      inputs: TensorInfo[],\n      sizeThreshold = CPU_HANDOFF_SIZE_THRESHOLD): boolean {\n    return env().getBool('WEBGPU_CPU_FORWARD') &&\n        inputs.every(\n            input =>\n                this.tensorMap.get(input.dataId).bufferInfo.buffer == null &&\n                util.sizeFromShape(input.shape) < sizeThreshold);\n  }\n\n  numDataIds() {\n    return this.tensorMap.numDataIds() - this.tensorDisposalQueue.length;\n  }\n\n  dispose() {\n    if (this.disposed) {\n      return;\n    }\n    this.bufferManager.dispose();\n\n    if (this.fromPixelProgram) {\n      this.fromPixelProgram.dispose();\n    }\n\n    if (this.fromPixelImportProgram) {\n      this.fromPixelImportProgram.dispose();\n    }\n\n    this.disposed = true;\n  }\n}\n", "/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as webgpu_util from './webgpu_util';\nexport {WebGPUBackend} from './backend_webgpu';\nexport {WebGPUProgram} from './kernels/webgpu_program';\nexport {webgpu_util};", "/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport './flags_webgpu';\nimport './register_all_kernels';\n\nimport {device_util, env, registerBackend} from '@tensorflow/tfjs-core';\nimport glslangInit from '@webgpu/glslang/dist/web-devel/glslang.onefile';\n\nimport {WebGPUBackend} from './backend_webgpu';\nimport * as webgpu from './webgpu';\nimport {isWebGPUSupported} from './webgpu_util';\n\nif (device_util.isBrowser() && isWebGPUSupported()) {\n  registerBackend('webgpu', async () => {\n    // Remove it once we figure out how to correctly read the tensor data\n    // before the tensor is disposed in profiling mode.\n    env().set('CHECK_COMPUTATION_FOR_ERRORS', false);\n\n    const glslang = await glslangInit();\n    const gpuDescriptor: GPURequestAdapterOptions = {\n      powerPreference: env().get('WEBGPU_USE_LOW_POWER_GPU') ?\n          'low-power' :\n          'high-performance'\n    };\n\n    const adapter = await navigator.gpu.requestAdapter(gpuDescriptor);\n    let deviceDescriptor: GPUDeviceDescriptor = {};\n    const supportTimeQuery = adapter.features.has('timestamp-query');\n\n    if (supportTimeQuery) {\n      deviceDescriptor = {requiredFeatures: ['timestamp-query' as const]};\n    } else {\n      console.warn(\n          `This device doesn't support timestamp-query extension. ` +\n          `Start Chrome browser with flag ` +\n          `--disable-dawn-features=disallow_unsafe_apis then try again. ` +\n          `Or zero will shown for the kernel time when profiling mode is` +\n          `enabled. Using performance.now is not workable for webgpu since` +\n          `it doesn't support synchronously to read data from GPU.`);\n    }\n    const device: GPUDevice = await adapter.requestDevice(deviceDescriptor);\n    return new WebGPUBackend(device, glslang, supportTimeQuery);\n  }, 3 /*priority*/);\n}\n\nexport {webgpu};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU;AAKjB,QAAI,OAAO;AAEX,QAAI;AACF,aAAO,IAAI,YAAY,SAAS,IAAI,YAAY,OAAO,IAAI,WAAW;AAAA,QACpE;AAAA,QAAG;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAK;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAG;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAG;AAAA,QAAK;AAAA,QAAI;AAAA,QAAI;AAAA,QAAK;AAAA,QA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",
  "names": []
}
